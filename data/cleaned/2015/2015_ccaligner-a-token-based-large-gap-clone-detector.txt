ccaligner a token based large gap clone detector pengcheng wang university of science and technology of china school of computer science wpc520 mail.ustc.edu.cnjeffrey svajlenko university of saskatchewan department of computer science canada jeff.svajlenko gmail.comyanzhao wu university of science and technology of china school of computer science wuyanzha mail.ustc.edu.cn yun xu university of science and technology of china school of computer science xuyun ustc.edu.cnchanchal k. roy university of saskatchewan department of computer science canada croy cs.usask.ca abstract copying code and then pasting with large number of edits is a common activity in software development and the pasted code is akindofcomplicatedtype 3clone.duetolargenumberofedits we consider the clone as a large gap clone.
large gap clone can reflect the extension of code such as change and improvement.
the existing state of the art clone detectors suffer from several limitations in detecting large gap clones.
in this paper we propose a tool ccaligner using code window that considers eedit distanceformatchingtodetectlarge gapclones.inourapproach a novele mismatch index is designed and the asymmetric similarity coefficient is used for similarity measure.
we thoroughly evaluate ccaligner bothfor large gap clone detection and for general type type and type clone detection.
the results show that ccalignerperformsbetterthanothercompetingtoolsinlarge gap clonedetection and hasthebestexecution timefor 10mlocinput withgoodprecisionandrecallingeneraltype 1totype 3clone detection.comparedwithexistingstate of the arttools ccaligner is the best performing large gap clone detection tool and remains competitivewiththebestclonedetectorsingeneraltype type and type clone detection.
ccs concepts softwareanditsengineering softwaremaintenancetools keywords clone detection large gap clone evaluation also with key laboratory on high performance computing anhui province.
yun xu is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
reference format pengchengwang jeffreysvajlenko yanzhaowu yunxu andchanchal k. roy.
.
ccaligner a token based large gap clone detector.
in icse icse 40th international conference on software engineering may june3 gothenburg sweden.
acm newyork ny usa 12pages.
introduction reusing code via copying and pasting is a frequent activity in softwaredevelopment.thecopiedcodeisknownasa codeclone.
code clones may lead to software maintenance problems and bug propagation .
therefore clone detection is useful for a variety of tasks e.g.
refactoring debugging softwareevolutionstudy andsoftwaremanagement .copied code withfurthermodifications likestatements insertion deletion in addition to changes in identifiers is called type clone.
ueda et al.
call such clones as gapped code clones andthuswefurthercalltype 3cloneswithalargenumberofedits i.e.
statements insertion deletion as large gap clones.w ef o c u s onthestudyoflarge gapclonesdetectionaswellasalltype 1to type clones detection in large code bases.
large gapclonescanreflectdifferencebetweentwosimilarcode corresponding to the extension e.g.
change or improvement of code.copyingcodewithmanystatementsinsertion deletionisa common behavior in software development.
fig.
shows an ex ample of large gap clones found in project ant .
.
.
nearly the same size of the original statements are inserted and lines in fig.
1b are large gaps which reflect the extension from the previous runprogramtothenew runprogram.inadditiontointraprojectclones inter projectclonesmaycontainlarge gapclones likeclonesindifferentversionsofthesoftwareordifferentsoftware developed for similar applications.
hence it is important to find the large gap clones.
numerous tools have been developed for clone detection .
accordingtodifferentsourcerepresentations mostclonedetectors can be classified into six classes text based token based treebased pdgbased metricsbased andhybridapproaches .however majorityoftextandtoken based detectors cannot detect type clones.
although tree and pdg basedtechniques can support thedetection of type 3clones tools based on these approaches suffer from large execution times.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang j. svajlenko y. wu y. xu and c. k. roy .
.
b a b .
.
.
.
.
?
.
.
.
?
.
.
.
!
.
.
.
b .
.
.
.
.
.
b .
.
?
c .
?
.
?
.
.
a .
a 89a .
.
?
.
.
.
?
.
.
.
.
.
.
.
.
.
?
c .
.
.
.
.
.
.
.
.
a .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c !
.
.
b ?
.
?
.
.
.
c c .
?
7a .
.
.
.
.
.
b a b .
.
.
.
.
?
.
.
.
?
.
.
.
!
.
.
.
.
.
.
.
.
.
.
a .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c !
.
.
b ?
.
?
.
.
.
c c !
.
figure example of large gap clone in project ant .
.
.
existing studieshave shown thatthere are moretype 3clones inthesoftwaresystemsthanothertypes .therefore type clonescanbethemostneededincodeclonedetection.moreover large gapclonesarecomplicatedtype 3clones andthestate of thearttoolssufferfromseverallimitations.forexample ccfinderx hasgoodscalabilityandexecutiontime butitonlysupports type1 2clonedetection.iclones canonlydetecttype 3clones with small gaps and the method is not very scalable.
although deckard can detect type clones its precision and recall are poor .
nicad can detect type clones effectively but it islimitedbylargeexecutiontimesandfailstodetectwhenscales to large code bases.
sourcerercc measures overlap similarity of pairs of code blocks at token level granularity to detect type3 clones but the similarity of large gap clones that have largedifference in token is low.
therefore sourcerercc needs to set a verylowsimilaritythresholdforlarge gapclonedetection which could extremely hurt precision.
in order to support fast and accurate detection of type clones especially the large gap clones we propose a technique and im plement it as a tool named ccaligner.
token based detectiontechniques have good scalability and execution time and thus ccaligner uses tokenization to normalize for type type variations.
in particular ccaligner considers sliding code windows i.e.
continuous code fragments instead of tokens as basic unit formatching.comparedtoasingletoken codewindowcaptures thelocal sequence characteristicsofsource code i.e.
localnessof software andcanimprovematchingaccuracy.tofurtherenhancethedetectioncapabilityofclonegaps weconsiderpairsof codewindowsmatchwith e mismatch insteadofexactlymatching.furthermore ccalignerusesasymmetricsimilaritycoefficient as similarity function which is more suitable for measuring the clone with largegaps since this similarity measure isrobust even if two code blocks have large difference in size.
our tool is needed to detect evaluate the large gap clones previously missed in clone studies.withoutsuchtools developerscannotmitigatetherisks caused by them.
ourexperimentsshowthatccalignerperformsbestinthedetectionoflarge gapclones andhasagoodperformanceindetectionof all type type and type clones.
to evaluate the ability of large gapclonedetection weconductanempiricalstudywitheight subject systems and also compare with nicad and sourcerercc the best performing gapped clone detectors from the literature .
furthermore to see the extent of large gap clone detection performance of ccaligner we make use of the mutation injection basedapproach where weadaptanestablishedbenchmark roy and cordy and svajlenko et al for syntactically creating gappedcloneofdifferentsizes toevaluateandcompareccaligner with state of the art gapped clone detection tools including nicad sourcerercc iclones and deckard for recall.
our study shows that ccaligner is the best performing large gap clonedetectiontooltodate.moreover wecompareccalignerwith different state of the art tools for type type and type clone detection andtheresultsshowthatccalignerisfastandcanscale to 10mloc inputs with good precision and recall.
the major contributions of this paper include weshowthatusingcodewindowsthatconsider eeditdistance for matching is effective to detect large gap clones.
we design a novel e mismatch index and use asymmetric similarity function in implementation.
we experimentally demonstrate the best parameterization to detect clones.
weimplementtheproposedtechniquesasatool ccaligner.
we show the effectiveness of the proposed techniques by comprehensively evaluating ccaligner.
the evaluations demonstrate that ccaligner is the best performinglarge gapclonedetectiontool andremainscompet itive with the best clone detectors in general type type and type clone detection.
theremainderofthispaperisstructuredasfollows.section2 describessomeconceptsaboutcodeclone andgivesdefinitionof large gapclones.section3presentsthedetailedprocessofclone detection.
section evaluates our tool both for detection of clones with large gaps and for general clone detection.
section surveys related work and section discusses our limitations.
the paper concludes with discussion and future work in section .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ccaligner a token based large gap clone detector icse may june gothenburg sweden preliminary definition inthissection wefirstintroduceconceptsanddefinitionregarding code clones.
we then propose the definition of type clones with edit distance measure.
furthermore we present a formal definition of large gap clones.
code fragment is a continuous segment of source code and code blockcan bea functionor asequence ofstatements withinbraces.
clonesare code pairs or groups that have the same or similar fragment.let uk i i sk ek beacodefragment where iisthefileid skandekrepresentingthestartandendlineofthe kthfragment inthisfile respectively.todefinemoreprecisely a clonepair isa triple uk i ul j t where code fragments uk iandul jare two similar codefragmentsand tistheclonetype type 3or4 .a clone group orclone class is a set of similar fragments defined as the tuple uk i ul j ... u h t whereeachpairofcodefragmentsisaclone pair.inaddition minclonesize istheminimumlinesortokensin length that could be seen as clone.
generally lines and tokens in length or greater are the standard size for detecting .
royetal.
andbellonetal.
classifyclonesintofourtypes type 1clones are identical code fragments except for variations in whitespace commentsandlayout.
type 2clonesareidenticalcode fragments except for variations in identifiers literals and variable types in addition to type clone variations.
type 3clones are copiedfragmentswithfurthermodificationssuchasadded deleted orchangedstatements inadditiontotype 2clonevariations.
type4clones are code fragments that perform similar functionality but are implemented by different syntactic variants.
while type and type clones are precisely defined and form an equivalence relationship there is no consensus on a suitable similaritymeasurefortype 3clones.type 3clonesaretypically defined with respect to line statement level edits and thus we applywidely adoptededitdistance measuretotype 3clone definition.
definition .
.
edit distance the edit distance between two code fragments uk iandul j denoted by dist uk i ul j is the minimum number of single line insertion deletion and substitution that are needed to transform uk itoul j. as an example two code blocks in fig.
are type clones with e corresponding to lines insertion lines in fig.
1b .
unmapped statements within the clone fragments are known as clone gaps e.g.
lines in fig.
1b .
when the proportion of clone gaps is large we consider such clones as large gap clones.
in other words pairs of code fragments are large gap clones if satisfy they are type clones and they have large difference in size.
the quantitative definition of large gap clones are as follows.
definition .
.
large gap clones given two code blocks uk iand ul j assumetheirnumberofpretty printedlinesare liandlj assumeli lj respectively.
let li lj where is the ratio of code length in terms of pretty printed lines.
if uk iandul jare type clones and .
then they are large gap clones.
weidentifylarge gapclonesviaascale differencevalue and we next explain why selecting the lower bound as .
for quantitative definition.letb1be the original code block whose code length is andb2 be the large gap clone of b1with lines insertion i.e.
the code length of b2is 3 .
it means when clone gaps are half size of the original code .
accordingto our definition.
therefore we identify large gap clones if the clone gaps are nearly half the size of the original code .
or larger .
.
according to definition .
two codeblocksin fig.
are large gapclones since they are type clones and .
falls in the range of .
.
approach theentireprocessofourapproachissummarizedinfig.
.itcan beconsideredintwophases lexicalanalysisandclonedetection.
the following subsections describe the design of each phase.
.
lexical analysis in the lexical analysis phase code blocks are first extracted from thesourcefiles.pretty printingisusedtolayoutthetokensforone statement per line.
tokenization is used to normalize for type and type variations.
in order to reduce the redundancy of code and constitute the objectofclonedetection codeblocksarefirstextractedfromsource filesandthenpretty printedusingtxl asofmanystate ofthe art approaches e.g.
sourcerercc .
after this step a set of pretty printedcodeblocksisproduced.wethentokenizeeachcode blockbyconvertingeachitem suchaskeywords operators etc inthecodeblocktothecorrespondingtoken.inordertotolerate identifier renaming i.e.
type identifiers e.g.
variables and functions are mapped into the same token id.
our lexical analyzer is mainly based on a scanner generated by flex .
this scanner can parse a single code block to ordered elements.
the original codeblocksaretransformedintonormalizedandtokenizedcode blocks as the input of following clone detection.
.
clone detection givenasetoftokenizedcodeblocks wheretype type 2variationshavebeeneliminated wethenimplementslidingwindows whichtolerate eeditdistanceacrosstheseblocks.weevaluatepairs of code blocks are clones by measuring their ratio of matched windows considering edit distance e and report those satisfying the similarity threshold.
algorithm describes the steps in detail.
it works in two stages matching via index and generating candidate set lines and verifying the candidate and reporting clone pairs lines .
each step is described as follows.
.
.
index and match.
compared to a single token code window can capture the local sequence characteristics of source code.
hence ccalignerconsiderscodewindows i.e.
continuouscode fragments asbasicunitformatching.itusesslidingwindowsto break the blocks.
since the windows are overlapping all code fragments of the window size must be located in a window.
to further enhance the detection capability of clone gaps we consider pairs of code windows match with e mismatch instead of exactly matching.
for example assume the window size is and e giventwocodewindows wa w andwb w prime infig.
where w meansthecodewindowcontaininglines3 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang j. svajlenko y. wu y. xu and c. k. roy figure the overview of our approach.
algorithm clone detection input fis set of tokenized code blocks f1 f2 ... fn qis the window size eis edit distance threshold and is the similarity threshold q eand are specified by the user output all clone pairs 1candmap 2hashset 3foreach blockfinfdo 4l num of lines in block f 5numwin id l q 6fori l q 1do ti token statement of ith line forj ceqdo h diffcombination ti ti ... ti q his different q e grams k hash h v fid hashsubset .insert k i ifcandmap .find k then candmap k .value candmap k .value v else candmap .insert k v end end end 20hashset fid .insert hashsubset 21hashsubset 22end 23candpair 24foreach map in candmap do ifnumofvalue 2then candmap .value sort candmap .value fid candpair candpair each pair in candmap .value end 29end 30remove duplicate element in candpair 32foreach pair fm fn incandpair do setintersection hashset fm hashset fn 34nummatch matched num of windows in fm 35nummatch matched num of windows in fn ifnummatch numwin mornummatch numwin nthen clonepair clonepair fm fn end 39end 40returnclonepair codeinfig.1aand w prime meansthecodewindowcontaining lines code in fig.
1b we consider waandwbare matched with mismatch.
assumeqis the window size i.e.
there are qlines code in a window and eis edit distance threshold.
we further use an effective method to guarantee that each window just needs to be processedoncebydesigningthe e mismatchindex whichavoids using time consuming dynamic programming to verify the edit distance between each pair of windows.
when ccaligner scans awindow itgeneratesall q e grams1ofthiswindow andbuilds 1assume code window w1 a b c d whereq .
when we set e its all grams are bcd acd abdandabc.an index mapping each q e gram to corresponding code block and window.
next for each sliding window its q e grams are generated and the index is updated dynamically.
detailed steps are shown in algorithm .
assume the number of lines in block fisl then there will be l q 1code windows line where qisthe window size.
eachcodewindow isasetof q lines token statements ti ti ... ti q wheretiis the token statementof ithline.defineeachcodewindowasa q gram then ccalignerbuilds e mismatchindexandfinishesmatching lines .whentwocodewindows q grams canbematchedunder eedit distance their q e gramsshouldbematchedintheindex.
formally it can be stated in the form of the following theorem its proof is available online2 due to limited space theorem .
.
given code windows a and b consisting of q token statements the length of a and b is q if a and b can be matchedwith maximum edit distance of e then a and b must have at least one matching subsequence with minimum length of q e. tounderstandthistheorem wegiveanexampleinfig.
.assume the window size is q and let edit distance be specified as e then two code windows w1andw2could be seen as two grams.afterthe w1isprocessed allits5 gramsareupdatedto theindex.
w2isthecodewindow b c d e f andwhenitsall grams are updated to the index we can find a match with w1by bcdef.
rghzlqgrz d e f g h i j e f g h i qgh h efghi efghi pdwfkhg dfghi jfghi deghi jeghi defhi jefhi defgi jefgi defgh jefgh figure example for theorem .
.
accordingtothetheorem inordertofindoutifcodewindows a andbare matched weonly needto check if their q e grams have at least one match.
therefore for each sliding window ccaligner extractsallthedifferent q e gramsofthe q grams anditbuilds an inverted index k v mapping q e grams to the code blocks containing them lines .
then the code blocks containing similar code windows will be grouped line .
to improve efficiency a hash value is computed on q e grams sequenceusingthemurmurhashhashfunction chosenforits lowcollisionrate.besides ccalignersavesasetoftuples angbracketlefthashval winid angbracketrightfor each code block line which is used for the next authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ccaligner a token based large gap clone detector icse may june gothenburg sweden step to verify the candidates.
overall when the cutting window is sliding ccalignerbuildstheindexalongwithmatching.thewhole process finishes when the sliding window scans all code blocks.
since the code blocks containing similar code windows have been merged in the valueofcandmap k each pair in candmap k .value is a clone candidate lines in algorithm1 .
.
.
verify.
thisstepistoverifywhetherthecandidatesare clones.foreachpair angbracketleftfn fm angbracketrightincandpair codeblocks fnandfm contain at least one matched code window with eedit distance.
inordertofurthermeasurethesimilarityoftwocodeblocks we useasymmetric dice similarity coefficient as similarity function defined as follows definition .
.
asymmetric dice similarity coefficient sim fm fn wfm wfn min wfm wfn wherewfmis the set of code windows contained in the code block fm wfnis the set of code windows contained in the code block fn and the min function normalizes the similarity score with respect to the number of windows contained in the smaller code block.
by calculating an intersection between hashset fn andhashset fm then the number of matched code windows considering e edit distance is obtained.
if the sim fm fn satisfies specified by user then ccaligner reports angbracketleftfn fm angbracketrightas a clone pair lines .
weusetheasymmetricdicecoefficientinsteadofothersimilarity measures e.g.
the jaccard coefficient because large gap clones havealargedifferenceinsize.therefore consideringtheminimum cardinalityofthesetsofcodewindowsatthedenominatorofthe formula allows to weigh the similarity between code blocks better.
considerthecodeinfig.1asanexampletoshowhowccaligner enableslarge gapclonedetection.thesetwocodeblockshavebeen prettyprinted andwecoulddirectlytakealookatthesourcecode sincetheircorrespondingtokensarethesameifthecodeblocksarethesame.inclonedetectionphase assumethewindowsizeis6and eachwindowtolerates1mismatch i.e.
q 6ande thenfor eachwindowitwillproducesix5 gramsformatching.ifthereexists one grams match between two windows these two windows are considered as a match.
code block in fig.
1a will produce sliding codewindowseachcontaining6linesofcode andcodeblockinfig.
1bwillproduce17slidingcodewindows.consider winset fa w w ...w forcodeblockinfig.1a where w meansthethefirstcodewindowcontainingfirst6linesofcode and winset fb w prime w prime ...w prime for code block in fig.
1b.
finally windows in winset fa match with the windows inwinset fb .
note that w can match with w prime due toour1 mismatchstrategy.accordingtooursimilaritymeasure sim fa fb .
so this pair of large gap clones can be detected setting similarity threshold as .
however some existing state of the art tools suffer from several limitations in detection of the large gap clone in fig.
.
for example nicad will miss this clone since it uses lcs similarity for type and the lcs similarity of these two blocks is very low.
sourcerercc will miss such clone unless a low similarity threshold isset whichcouldextremelyhurttheperformance.
besides werunline baseddetectoriclones anditevenfails to report the similar regions before and after the gap.table recall per clone type and precision measured for bigclonebench with different parameterization qerecallprecision t1 t2 vst3 st3 mt3 evaluation inthissectionwethoroughlyevaluateccalignerbothforlargegap clone detection and for general type type and type 3clone detection.
we begin by demonstrating experimentally that q ande work best for clone detection which balance recall with precision and performance.
.
parameter setting ccalignerimplementsslidingwindowswhichtolerate eeditdistance across code blocks and evaluates pairs of code blocks areclones by measuring their ratio of matched windows consider ing edit distance e .
hence the choice of window size qand edit distance threshold ewill affect the performance of clone detection.
to find the most suitable parameterization for detecting we try various combinations of q eto evaluate ccaligner with bigclonebench using the bigcloneeval framework for minimum clone size of lines and a similarity threshold of .
bigclonebench is a large benchmark of manually validated clones in a large inter project java repository.
bigcloneeval allows theuser to conduct custom recall measurement experiments on top of bigclonebench and automatically handles aspects such as tool execution and recall analysis .
since lines in length orgreater are the standard size fordetecting andwhen eislarge theaccuracyofthematchwould below.hence weselect q 6andeasasmallnumber.inourexperiments wetryvariouscombinationsof q 8ande .
whene pairs of code windows are exactly matched.
recall is summarized per clone type as per the bigclonebench definitions .specifically bigclonebenchsplitsthetype 3clonesinto multiplecategorizesbytheirsyntacticalsimilarity.very strongly type vst3 clones are those that are similar by syntax stronglytype st3 clonesare70 similar andmoderately type mt3 clonesare50 similar.wemeasureprecisionby manually validating a random sample of the clones detected by ccalignerduringthebigclonebenchexperiments.werandomly select clones for each parameterization to validate clone pairs in total .
the recall is reported by the bigcloneeval framework.
detailed results are summarized in table .
we can see that ccaligner has perfect or near perfect type and type recall evene sincethetype type 2variationshasbeennormalized intokenization.forthesame q wheneislarger therecalloftype authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang j. svajlenko y. wu y. xu and c. k. roy i.e.
vst3 st3 and mt3 gets better but the precision gets worse because allowing more mismatch in windows will enhance the detection capability of clone gaps but cause more false positive.
although the recall is the best when q ande the precision is rather poor.
we can see that angbracketleftq e angbracketright angbracketleftq e angbracketright and angbracketleftq e angbracketrightwork better for clone detection which balance recall with precision.
table execution time and memory space with different parameterization for linux .
.
configuration q e performancetime 13m 2s 32m 37s 28m 16s space .
gb .
gb .
gb we next evaluate the execution time of ccaligner with these three configurations to justify the best choice for detection.
to obviously show the difference of performance we use large codebase linux kernel .
.
as our target.
the source code contains code files with 767loc i.e.
line of code measured by tool cloc .theresultsareintable2.wecanseethatccalignerneeds less time and memory space for detection when q ande .
therefore q ande are the most suitable configurations for detectingwhichbalancerecallwithprecisionandperformance.we thus setq ande for the next clone detection evaluation.
.
large gap clone detection after experimentally determining the parameters i.e.
qande used for clone detection we now demonstrate the ability of our ccalignerforlarge gapclonedetection.wefirstconductanempirical study with eight subject systems and compare with stateof the artgappedclonedetectorsintermsofprecision recalland f1 score.furthermore toseetheextentoflarge gapclonedetection performance of ccaligner we develop a variant of an establishedsyntactic benchmarking framework the mutation injection based framework toevaluateandcomparetherecallofccaligner for different gap sizes.
.
.
empirical study .weselectatotalofeightcandjava open source projects as our dataset for evaluation.
the size of thesourcecodeoftheprojectsvariesfrom43klocto138kloc.
the detailed statistics of subject systems can be seen in table measured by tool cloc .
table subject system s statistics system language files loc cook .
c redis .
.
c postgresql .
c linux .
c jdk .
.
java opennlp .
.
java 291maven .
.
java 840ant .
.
java from the literature nicad and sourcerercc are the best performinggappedclonedetectors.hence wecompareccaligneragainsthigh recalltoolsnicadandsourcerercctodemonstrate that ccaligner can detect large gap clones that the best of the competing tools are missing.
we first detect code clones in these projects using ccaligner nicad and sourcerercc all with the configurations of min length lines min similarity .
we define recall lg fp union of tp wherelg fpis the true positive large gap clones reported by one tool anddenominatoristheunionoftruepositivelarge gapclones removing duplicate elements reported by different tools.
we also define f1 score precision recall precision recall.
after the clone results are obtained we measure precision by manually validating a random sample of the clones detected by different tools for each .
to measure the recall of large gap detection we choose the union of true positive large gap clones reported by different tools as the reference corpus.
to create the large gaprecallbenchmark weselecttheclonessatisfyingourdef inition2.
i.e.
large gapclones bycalculatingthescale difference value .i f .
we consider this clone pair as a large gap clone.
furthermore wemanuallyvalidatealldetectedlarge gapclones and remove the false positive clones.
table shows the detailed values of precision recall and f1score for each tool in detection of c projects.
lgin table is thenumberofdetectedlarge gapclones and fpisthenumberof falsepositiveclonesamongtheselarge gapclones.comparedtonicad and sourcerercc our ccaligner has the best recall and f1 score in each project.
sourcerercc and nicad miss many largegapclonesthatccalignerdetects reflectedasmuchlowerrecall.
the total recall and f1 score of ccaligner in c projects are the best whereas the other tools are much lower.
finally a manual validationidentifies377truepositivelarge gapclonesinthesec projects.
table large gap clone evaluation results for c. system tool lg fp precision recall f1 score cook .34nicad sourcerercc ccaligner redis .
.0nicad sourcerercc ccaligner postgresql .0nicad sourcerercc ccaligner linux .0nicad sourcerercc ccaligner totalnicad .
sourcerercc ccaligner table5showsthedetailedresultsforjavaprojects.compared to nicad and sourcerercc ccaligner also has the best recall and f1 scoreinallprojects.forexample ccalignergetsthebestrecall authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ccaligner a token based large gap clone detector icse may june gothenburg sweden of and best f1 score of among all the tools in maven .
.
project.
nicad fails to detect large gap clone in these projects and sourcerercc still has much lower recall and f1 score althoughits precision is a little better than ccaligner.
finally a manual validationidentifies525truepositivelarge gapclonesinthesejava projects.
table large gap clone evaluation results for java.
system tool lg fp precision recall f1 score jdk .
.2nicad sourcerercc ccaligner opennlp .
.1nicad sourcerercc ccaligner maven .
.0nicad sourcerercc ccaligner ant .
.1nicad sourcerercc 25ccaligner totalnicad sourcerercc ccaligner sincesourcererccandnicadonlydetectafewlarge gapclones in our reference corpus containing c and java true positive large gap clones.
we further run nicad and sourcerercc with allowingmoresimilaritythresholdstoseehowtheprecisionand recall vary.
we run nicad and sourcerercc all with min similarity threshold as and .
we measure precision by manually validatingarandomsampleoftheclonesreportedbysourcererccand nicad 400foreachlanguage sameasccaligner andtherecall reflectshowmanylarge gapclonescanbedetectedinourreference corpus.thedetailedresultsfornicadareinfig.
andthedetailed resultsforsourcererccareinfig.
.theprecision recallandf1score of ccaligner for the reference corpus are summarized in the totalitemintable4andtable5.theresultsshowthattherecall of the tools in both c and java projects only increases a bit but the precision becomes worse.
for example even setting similarity as50 sourcerercconlydetects135large gapclonesoutof377 large gap clones contained in the c reference corpus with precision whereas ccaligner can detect large gap clones with86 precision.hence theexperimentsdemonstratethat ccaligner is able to detect large gap clones that the best of the competing tools are missing without harming the precision.
to further show empirically the large gap clones we detect we summarize the number of different types of clones detected byccaligner in these c and java projects in table .
since is the ratio of code length in terms of pretty printed lines given pairs of clones weapproximatelyconsiderthemastype 1ortype 2clones if andwhen isnotequalto1 weapproximatelyconsider them as type clones.
we also summarize the proportion of largegapclonesintype 3clonesandallclones.wecanseethatthere are more type clones than other types in most projects which is consistentwithexistingstudies .amongtype 3clones the proportion of large gap clones varies from to and among all clones the proportion of large gap clones varies from to figure performance of nicad with different similarity thresholds.
figure performance of sourcerercc with different similarity thresholds.
.
for example there are of clones of type clones inpostgresql .
are large gap clones.
it shows that large gap clones are common and exist in real software systems.
table proportion of large gap clones detected by ccaligner system type type all lg type lg all cook .
redis .
.
postgresql .
linux .
jdk .
.
opennlp .
.
maven .
.
ant .
.
our comparison section .
with the state of the art tools will also show that ccaligner is also competitive with sourcerercc and nicad in type clone detection in terms of execution time precision and recall.
.
.
gapped clone evaluation .since precision could be approximated with randomly validating a significant samples of the detected clones our way of reporting the precision above isaligned with the state of the art .
however for measuringrecall oneneedstohaveanoracle .wehavebuilt theoraclebyunioningthegappedclonesdetectedbythesubject tools from our subject systems and then manually validating from them.
while this gives an approximate and relative comparison of recall among the competing tools it does not guarantee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang j. svajlenko y. wu y. xu and c. k. roy the recall values we reportedabove.
we thus wanted to examine the extent of large gap clone detection performance of ccaligner for different gap sizes using an established procedure borrowed from mutation analysis community.
in particular we adapt an established mutation injection based benchmarking framework forsyntacticallycreatinggappedclonesofdifferentsizes and evaluate and compare ccaligner with the state of the artgapped clone detection tools including nicad sourcerercc iclones and deckard for recall.
mutation based approach can automatically and efficiently measure and compare the recall of clone detection tools for different types of clones.
by using code mutation operators to generate and track a large number of artificial clones we can then automaticallymeasurehowefficiently i.e.
recall theseknownclonesare detected by group of tools for comparing different tools.
we designed a clone producing mutation operator that copies a code fragmentand inserts a singlegap of a certainlength into the copiedversion.weusedtheframeworkwithourmutationoperator to generate synthetic gapped clones per gap length rangingfrom one source line to source lines.
in total our referencecorpus contains synthetic gapped clones.
we constrainedthe clone synthesis to clones that are source lines or greater before insertion of the gaps.
we selected the code fragments from a large repository of java source code jdk and various apache commonslibraries andinjectedthegappedsyntheticclonesone at a time into the subject system.
we use the same original code fragments andinjection locations for eachgap length so we can compare recallacross the gap lengths withoutbias due to the original source code used and injection locations.
we measured ccaligner s recall for the clones per inserted gap length.
we configured nicad for a threshold with identifier andliteralvaluenormalizationsenabled.weconfiguredccaligner deckard and sourcerercc also with a threshold.
we executed iclonesforaminimumclonelengthof50tokensandaminimum block length of tokens.
figure recall for gapped clones by gap length weshowtherecallofccalignerandthecompetingtoolsacross the gap lengths in figure .
as can be seen while all the tools can detectcloneswithsmallgaps ccaligneristheonlytoolthatcan detectcloneswithlargergaps.sourcerercchasgoodrecallforgapsof one of two source lines but recall quickly diminishes after three sourcelines.nicad duetopowerfulnormalization maintainshigh recall until gaps of length five where its recall begins to diminish.
weseethaticlonesanddeckardperformmuchworseinthegapped clone detection.
ccalignerhassimilarrecalltonicadandsourcererccforsingle line gaps.due to more conservativeconfiguration ccaligner has lower recall for clones with the smaller gaps.
however it is able to maintainthisrecallevenforthecloneswithlargegaps.therecallof the other tools drops off because with larger gaps it becomes more likelytheclonescanbeclassifiedaslarge gapclones andcannot be detected with a standard threshold by the other tools.
while nicad and sourcerercc could detect these large gap clones by lowering their threshold this would result in poor precision.
in contrast ccaligner can detect these large gap clones while maintaining precision.
.
general clone detection to evaluate the ability of ccaligner to detect general purpose clones i.e.
type type and type clones we extend the tool evaluation experiment in the sourcerercc publication by sajnani et al.
.
we execute these evaluations for our ccaligner under the same conditions used by them and directly compare against thepreviousresultsintheliterature .forexperiments on execution time recall and precision we execute ccaligner for minimum clone size of lines window size q an edit distance e anda similaritythreshold of60 .
theconfigurations ofthe competing tools from the experiment we extend can be found in sajnani et al.
s work .
.
.
execution performance .weusethesameinputasused bysajnanietal.
intheirexperimentwithsourcerercc.weexecuteonacomparablemachinewithaquad corecpu 12gbofmemoryand a solidstate drive.execution performancefor ccaligner and the competing tools is shown in table .
we find that ccaligner has fast execution performance with scalabilityuptotenmillionlinesofcode.ccalignerfailsforthe 100mloc input with an out of memory error.
specifically the emismatch index which is kept in memory to enable fast detection exceeds the available memory 12gb .
still this is very good scalability and most software systems do not reach even 10mloc.
compared to the state of the art ccaligner shares the best execution time while achieving the second best scalability.
execution time is very similar to ccfinderx and sourcerercc.
however ccfinderx only detects type and type clones and sourcerercc misses many large gap clones which can be detected by ccaligner as we showed previously.
ccaligner s scalability falls behind ccfinderx and sourcerercc.
however both of these tools stillrequiredaysofexecutiontimetoscaleto100mloc.sourcererccspecificallywasdesignedtoenablelarge scaleclonedetection whilewefocusonthedetectionoflarge gapcloneswithccaligner.
whileccfinderxscaleswell itsclonedetectionismuchsimpler focusing only on type and type clones.
.
.
recall .we measure clone detection recall using svajlenko et al.
s two proven benchmarks the mutation and injection framework and bigclonebench .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ccaligner a token based large gap clone detector icse may june gothenburg sweden table execution time for varying input sizes loc ccaligner ccfinderx deckard iclones nicad sourcerercc 1k 1s 3s 2s 1s 1s 3s 10k 1s 4s 9s 1s 4s 6s 100k 7s 21s 1m 34s 2s 21s 15s 1m 1m 13s 2m 18s 1hr 12m 3s 4m 1s 1m 30s 10m 24m 56s 28m 51s 11hr 42m 47s 32m 11s 100m 3d 5hr 49m 1d 12h 54m table recall measured by the mutation framework language clone type ccaligner ccfinderx deckard iclones nicad sourcerercc java1 c1 c table recall per clone type and precision measured for bigclonebench tool ccaligner ccfinderx deckard iclones nicad sourcerercc type type very strongly type strongly type moderately type precision precision 10loc forthemutationandinjectionframework recallissummarized per clone type in table .
we also include the results of the competing tools as measured in the previous work .
ccaligner has perfect or near perfect recall for clones of the first three types in all three of the tested languages.
nicad and sourcerercc perform similarly.
ccaligner performs better than iclones for type clones and performs much better than ccfinderx and deckard.
ccalignerrecallissignificantlybetterthanthatofccfinderxand deckard.
for bigclonebench recall is summarized in table .
we also show the recall of the competing tools as measured in the previous work .
recall is summarized per clone type as we described in section .
.
ccaligner and most of the competing tools have prefect or near perfect type and type recall.
more interesting is the comparison of type recall.
ccaligner has near perfect recallforthevery stronglytype 3clones fallingbetweennicad andsourcerercc.ccalignerhasthesecondbeststronglytype recall falling behind nicad but ahead of sourcerercc.
ccaligner alsohasthesecondbestmoderatelytype 3recall althoughnone of the tools have a significant recall for this category.
these results showthatccalignerisastrongtype 3clonedetector.overallit has the second best recall second only to that of nicad.
.
.
precision .we measured precision by manually validatingarandomandstatisticallysignificantsampleoftheclonesdetected by ccaligner during the bigclonebench experiment.
we randomly selected clones to validate a statistically significantsample.
precision is summarized in table .
the results for theother tools were taken from the previous work .
ccaligner has the 3rd best precision at just slightly behind sourcerercc.
the previous work suggests that tools that target high type recall can have low precision for small clone sizes.
while lines isacommonminimumclonesizeinbenchmarking many modern type clone detectors recommend a larger min imum clone size in the range lines or equivalent .
therefore asdoneintheexperiment wealsomeasureprecision for just those clones that are lines in length or larger.
in this case precision increases for ccaligner to .
.
.
summary .we summarize our results of the extension of sajnani et al.
s experiment with our ccaligner in table .
we show recall for all clone types and for just type clones both consideringjusttheverystronglyandstronglytype 3categoriesin bigclonebench .weshowprecisionmeasuredforaminimumclone size of lines and lines of code.
we also show the maximum scalability of each tool as well as their execution time for the 10mloc input the max scalability of ccaligner .
using these results we can demonstrate the position of ccaligner amongst the state of the art.
ccalignerhasthesecondbestrecall bothoverallandspecifically for type clones behind only nicad but ahead of tools like sourcerercc and iclones.
while nicad has very high recall itsexecution time is much longer than ccaligner for 10mloc inputs.
as well nicad s precision suffers for small clones lines authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang j. svajlenko y. wu y. xu and c. k. roy table recall and precision summary tool ccaligner ccfinderx deckard iclones nicad sourcerercc recall192 recall t3 precision 6loc precision 10loc scalability 10mloc 100mloc 1mloc 100kloc 10mloc 100mloc time 10mloc 24m56s 28m51s 11hr24m 32m11s 1including t1 t2 vst3 and st3 categories.2including vst3 and st3 categories.
whichccalignercandetectthesesmallcloneswithgoodprecision.
ccalignerhas similarprecisionto sourcerercc but betterrecall specificallyforthetype 3clones.ccalignerhasthebestexecution time for the 10mloc input.
ccaligner has competitive scalability amongst the tools.
only sourcerercc designed for scalability and ccfinderx does not detect type clones can scale to 100mloc.
while deckard and iclones detect type clones their recall is lowerthanccalignerandtheycannotscaletoeven10mlocon our standard workstation.
our ccaligner is well situated amongst the competing tools with excellent execution time and good recall and precision.
besides ccaligneristhebestperforminglarge gapclonedetection tool.
related work there have been numerous clone detectors in the literature and rattan et al.
summarized most of the tools in their research.
amongthetextbasedtools johnson appliedafingerprinting technique for comparison of source code and ducasse etal.
useddynamicpatternmatchingforlinebasedcomparison.
however both techniques do not support type clones detection.
nicad isatextbasedhybridtool whichusedlongestcommon subsequencealgorithmforcodecomparison andcandetecttype cloneseffectively.ho wever this methodwillfailtodetectlarge gap clones since the clones have large difference in lcs similarity.
among the token based tools sourcerercc and iclones support type clone detection.
sajnani et al.
measuredoverlap similarityofpairs ofcodeblocksat token level granularity to identify clones which will miss many large gapclones since the similarity measure is not robust to large gaps.iclones usessuffixtreebasedtokenbytokencomparisonto detect type type clones and then merges neighboring type and type clones to form type clones.
however iclones can only detect type clones with small gaps.
tree and program dependency graph pdg based tools can supportthe detectionoftype cloneswell such asclonedr deckard duplix and gplag where clonedr and deckard are tree based and duplix and gplag are pdg based.
however large gapclonesmayaffectthetreeandpdgstructure due to the extension of the code and thus these tools will fail to detect large gap clones.
amongthemetricsbasedtools kodhaietal.
only support type and type clones detection.
mayrand et al.
andkontogiannisetal.
detectedclonesusingmetricsextracted from ast of source code.
however like tree based tools they will fail todetect large gapclones sincelarge gaps mayaffect theaststructure and further affect the metrics.there exists some other techniques for clone detection such as mecc .
mecc detects code clones by comparing programs abstractmemorystates.whiletheyhaveaverygoodrecallintype3 even type clones their methods will miss the large gap clones where large gaps affect the memory states.
besides mecc also suffers from large execution time.
limitations one limitation of the current implementation of ccaligner is that it cannot scale to detect clones in 100mloc input on a standard workstation with 12gb of memory since ccaligner stores thewholee mismatchindexinmemoryduringtheprocessofgenerating clone candidates.
another limitation is the evaluation work.
the configurations of the tools affect the performance of clone detection .toreducethislimitation wefollowtheconfigurations of previous literature work which seemed to be standard.
conclusion and future work in this paper we have presented a novel clone detecting technique and implemented the proposed technique as a tool ccaligner.
we havedemonstratedthecorrectnessofourtechnique andshowed theeffectivenessoftheproposedtechniquebyexperimentallyeval uatingit.weconductanempiricalstudyforlarge gapclonesdetection with eight systemsto demonstrate that ccaligner can detect large gapclonesthatthebestofthecompetingtoolsaremissing shown as the best recall and f1 score in all selected open source projects.
moreover we develop a variant of the mutation injection frameworktoevaluateandcomparetherecallofccalignerfordif ferentgapsizes.theresultsfurthershowthatccaligneristhebestperforming large gap clone detection tool.
we further demonstrate that ccaligner remains competitive with thebest clone detectors in general type type and type clone detection shown as thebestexecutiontimefor10mlocinputwithgoodprecisionand recall.
we offer ccaligner as a large gap clone detector and other clonerelatedresearchcouldbenefitfromthedetectionoflarge gap clones such as clone refactoring .
inthefuturework weareplanningonimprovingthescalability ofourproposedapproach.thedatastructureofouralgorithmis organized as angbracketleftkey value angbracketright so it is especially suitable for distributed computing like hadoop .