clone merge an eclipse plugin to abstract near clone c methods krishna narasimhan institut f ur informatik goethe university frankfurt krishna.nm86 gmail.com abstract software clones are prevalent.
in the work of lagu e et al.
they observe that .
and .
of the source code in different versions of a large mature code base are clones.
the work of baxter et al.
reports even higher numbers sometimes exceeding .
we consider the prevalence of such near miss clones to be strong indicators that copy paste modify is a wide spread development methodology.
even though clones are prevalent they are a significant development headache.
specially if bugs arise in one of the clones they need to be fixed in all of the clones.
this problem is acknowledged in the work of juergens et al.
who say in their work that cloning can be a substantial problem during development and maintenance since inconsistent clones constitute a major source of faults .
a similar concern is raised in practitioner literature suggesting that clones should be removed in some form or the other.
we present a tool that can be installed as a plugin to eclipse cdt the development environment for c c .
the research prototype comes with a refactoring option called copy paste merge refactoring which is available as a menu option in the modified version of the eclipse cdt.
i. o verview fig.
.
eclipse refactoring option the tool is inspired by the approach presented by krishna narasimhan and christoph reichenbach in their paper titled copy and paste redeemed to appear in the same conference s main track ase .
the overview of the approach is simple.
each method definition suspected to be copy pasted is provided as an input in the ast form to a a merge function.
we use the merge function to identify the nodes that are unique to each subset of the asts.
using these unique nodes and the asts they come from merge points are generated.
for each merge point a resolution pattern is decided based on the type of the node.
a resolution pattern is simply a code transformation pattern that determines the appropriate way to merge nodes.
for examples nodes containing constants can be merged using an extra parameter to the function.
the current version of the prototype works on a single input file that contains all the clone groups marked with pragma annotations that specify which are the methods that are to be used as input for the refactoring.
the clone groups can be of any size in terms of number of ast nodes.
a clone group is a group of methods which the developers consider to be nearclones and believes should be abstracted.
the input are tobe placed in a special file called input.cpp inside a project called astdifftest .
for more detailed instructions refer to the website.
the refactoring creates or updates a file called input.cppmergedoutput.cpp which contains the clone groups merged into one function called mergedfunction .
the function definitions of the clone groups are replaced with calls to the merged function with parameters and or template parameters helping the merged function as to how it decides the merge process.
currently four kinds of merges are supported differences in constants are resolved using an extra parameter based on the type of the constant differences in types are resolved using a template parameter.
differences in statements are resolved using a switch statement differences in names such as field names variable names are resolved using extra parameter.
if the name happens as part of a left hand side of an assignment corresponding pointer operations are added to the caller and callee.
ii.
s cenarios here let us see a few real scenarios where our tool might be used.
one for each type of difference a. differences in constants consider figure which is the input of a clone group with differences of constants.
for each of the constants in action module and clientid an extra parameter is introduced to the merged function and that parameter is placed in the position of the constants.
and each of the calling functions pass their respective constants which can be seen in the output in .
b. differences in field names and statements consider figure which is the input of a clone group with differences of statements of calls to fn1 and fn2 and also differences in field access of x y and celldiv cellmod .
for the statement difference a switch statement is introduced and an extra parameter denoting which function to switch between.
for the field accesses an extra parameter of unknown template type is introduced and for x y a pointer operation is introduced because it happens in the lvalue.
the output can be seen in .fig.
.
constant difference input iii.
r elation to other tools as far as we are aware this is the first tool that breaks the barriers of using only grammatical information while performing merges of near clones.
there are refactoring options that allow for extracting methods from common code.
but they are very trivial and work on exact differences.
they are not able to perform such type and other sophisticated program analysis that we perform in order to find the points of abstraction and performing an abstraction using abstraction patterns like using a template and switch patterns.
for a future version of the tool we plan to introduce a user selection where the user can choose between abstraction patterns.
for example using an if conditional branch instead of a switch.
or using a global field instead of an extra parameter.
this is easily possible because of the way the tool is built using merge points and resolution patterns which is described in a complementary paper submitted to ase titled copy and paste redeemed .
in the terminology of koschke et al.
they mention three types of clones with type being the mostevolved and sophisticated of clones which have considerable parts of their asts differing.
perhaps the most closely related clone management approach to our algorithm is cedar which targets java and relies on eclipse refactorings for abstraction.
our approach is more general and does not rely on existing refactorings like extract method.
unlike our approach cedar is limited to type clones.
iv.
i mpact to industry to the best of our knowledge ours is the only work to support merging the common type clones inexact clones in a wide variety of cases.
as roy et al.
note type clones are particularly common and frequently evolve out of type and clones.
this already sets our tool potentially in the forefront of industry application.
in order to test the quality of abstractions performed by our tool we checked out popular github repositories and abstracted a few of their clone groups using our tool.
during the month of february we picked the top trending repositories from github gatheredfig.
.
constant difference output fig.
.
statement and field name inputfig.
.
statement and field name output clone groups using a simple clone detector implemented by ourselves.
we picked random clone groups abstracted them using our tool and submitted clone groups abstracted as pull requests.
out of these were merged back into the code.
we even got positive feedback from many of the maintainers including the ones from google protobuf and oracle nodedb repositories.
this indicates that people in the industry prefer to have such abstractions in their code bases.
this evaluation also indicated that there is a common prevalence of copy pastemodify method of extending functionality which seems to be easier.
so our tool can allow industry users to apply copypaste mode of refactoring which is easy and then use our tool to abstract them into a preferred form of the final code.
our pull requests can be found in figure v. w ebsite here is a website which has complete information about test inputs a sample video demonstrating a run of the tool and also a downloadable version of the eclipse cdt with the refactoring pre installed and instructions on how to install and use it.
the link to the download of the tool is link to a video demonstration of the tool is http youtu.be vm8s0 tm0ty?hd