string analysis for java and android applications ding li yingjun lyu mian wan william g. j. halfond university of southern california los angeles california usa dingli yingjunl mianwan halfond usc.edu abstract string analysis is critical for many veri cation techniques.
however accurately modeling string variables is a challenging problem.
current approaches are generally customized for certain problem domains or have critical limitations in handling loops providing context sensitive inter procedural analysis and performing e cient analysis on complicated apps.
to address these limitations we propose a general framework violist for string analysis that allows researchers to more exibly choose how they will address each of these challenges by separating the representation and interpretation of string operations.
in our evaluation we show that our approach can achieve high accuracy on both java and android apps in a reasonable amount of time.
we also compared our approach with a popular and widely used string analyzer and found that our approach has higher precision and shorter execution time while maintaining the same level of recall.
categories and subject descriptors d. .
testing and debugging general terms algorithms keywords string analysis mobile apps .
introduction strings play an important role in modern software.
the server side of modern web applications may use strings to output html content and make sql queries to databases while the client side may process string based user input and send it to the server side via various string based protocols.
mobile apps may generate string based http requests to cloud based servers and even large scale systems such as distributed event based deb systems may pass messages whose attributes are represented as strings.
by analyzing these strings and determining their possible values engineers can better understand an application s potential runtime behaviors.
for example string analysis has been used to detect sql injection attacks prevent cross site scripting attacks detect errors in html output optimize energy consumption of mobile web apps improve penetration testing and understand the runtime behavior of deb systems .
inaccurate string analysis can reduce the e ectiveness of these approaches.
for example an imprecise string analysis can lead to the identi cation of less energy e cient color schemes i.e.
and an unsafe string analysis could miss possible vulnerabilities e.g.
.
despite their widespread use and importance accurately analyzing strings remains a signi cant challenge due to several issues how to analyze string values generated in possibly nested loops that may include loop carried data dependencies context sensitivity for strings manipulated and composed inter procedurally exibility to attach di erent semantics to string operations and scalability to handle long strings or strings manipulated using a complex series of operations.
existing techniques that use string analysis have mainly side stepped these challenges by cleverly leveraging aspects of their problem domain to simplify the required string analysis.
the result is these key challenges for the analysis of strings have not been adequately addressed.
existing work related to string analysis can be broadly described as either performing string analysis in support of another software engineering goal or directly providing a string analysis technique.
approaches that fall into the rst category include those for approximating html output e.g.
computing possible sql queries e.g.
and identifying messages passed in deb systems .
these approaches have often not needed to address key challenges in string analysis due to aspects of their problem domains.
for example to optimize display energy it was su cient to assume that loops were unraveled once.
the result of leveraging these domain speci c insights is that the developed techniques are not generalizable since assumptions that work for one problem domain may not be appropriate for others.
this has implications for the research community as each group that wants to develop techniques that need string analysis must essentially start from scratch.
more generalizable techniques have also been proposed permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
e.g.
.
however these have trade o s in how they handle the four challenges which makes them less broadly applicable.
for example jsa uses global alias analysis to model inter procedural manipulation of strings which as we show in section leads to scalability problems when analyzing android applications that include extensive invocations of framework apis.
yu and colleagues proposed a finite state automata fsa based widen operation which can partially solve the rst challenge but is not able to handle nested loops.
symbolic execution based techniques can more precisely address challenges and .
however these techniques may not scale for large programs and may make simplifying assumptions about the strings under analysis.
the goal of the work presented in this paper is to present a general framework for string analysis that allows researchers to more exibly choose how they will address each of the four challenges.
our key insight into how to do this is to separate the representation and interpretation of string operations.
our string analysis framework violist de nes an intermediate representation ir that faithfully represents the string operations performed on an application s string variables.
violist s ir is designed to accurately capture complex dataow dependencies in loops and context sensitive call site information.
violist also allows for the straightforward integration of ir interpreters that can implement the user s necessary interpretation of the string construction semantics.
for example it is straightforward to write an interpreter that will unravel loops once ntimes or approximate an upper bound for in nite unraveling.
finally violist can easily scale up and analyze large programs.
to evaluate the usefulness and e ectiveness of our framework we carried out an extensive empirical evaluation.
for the evaluation we implemented two di erent ir interpreters and used these to compare the accuracy and scalability of violist against the popular java string analyzer jsa .
for this evaluation we used a mixture of publicly available benchmarks systematically created test cases to mimic different data and control ows and real world java and android applications.
our results showed that violist is able to generate results that on average are more precise than jsa while maintaining the same level of recall.
furthermore violist was able to generate these results for a wider range of applications and to do this faster than jsa.
.
motivation in this section we provide a motivating example program to illustrate the four challenges mentioned in section .
.
loops consider a string analysis that targets the variable cat line c19 .
this variable is rede ned in each iteration of the loop at lines .
although the upper bound on the loop can be trivially identi ed via inspection in general it is challenging for a static string analysis to accurately account for the loop s upper bound.
therefore many techniques e.g.
simply assume the loop will be executed an in nite number of times or unrolled only once e.g.
.
even techniques that do model loops are generally unable to model the relationship of nested loops an example of which is shown at lines .
nested loops are more challenging to analyze because it is necessary to model the relationship of the strings in the inner and outer loops e.g.
dande .1class examplef 2public static string adda string v 3f return v a 5g 6public static string replacea string v 7f return v.replaceall a b 9g public static void main string args f string a a string b adda a b adda b system.out.println b string c a string f for inti i i 18f c c a f f c 21g c replacea c c replacea aaaa system.out.println c string d string e for inti i i 28f d d e system.out.println d for intj j j 32f e e b 34g 35g 36g 37g program example program techniques based on the widen approach for approximating loops would not be able to handle this scenario.
many ow based techniques would simply model this as one large loop which is safe but reduces precision.
.
context sensitivity next consider a string analysis that includes string manipulations that are carried out inter procedurally.
an example of this is in method main at lines and which calls the method adda.
many string analyses handle this sort of invocations without any call site context sensitivity e.g.
.
this means that when analyzing the values at lines and these analyses will assume that the return value can be based on the arguments provided at any call sites toadda.
using the example this means that the value of b at lines and13 would be approximated as f aa ba g instead of aa for line and ba for line .
as with handling of loops this approach is safe but loses precision as extra possible string values would be returned as a possible value of the variable b. the reason this occurs is that the analyses use a global data ow analysis which is in turn based on the call graph of the application.
this representation of the inter procedural controlow results in a lack of context sensitivity.
techniques that use symbolic execution do not face this problem but may require smt problem solving and need to analyze all possible paths of a program which can make it di cult to scale the techniques for large programs.
.
flexible semantics a general limitation of many string based approaches is that they are tightly tied to one speci c method of interpreting string values.
for example jsa approximates loops as having an in nite upper bound both d model and the string analysis underpinning nyx assume loops are unraveled once.
beyond that many string analyses are highly customized to make approximations in ways that are appropriate for their problem domains but that limit their 662general applicability.
for researchers and software engineers who are attempting to leverage string analysis it is generally necessary to develop their own string analysis to be used for their project.
this can be a signi cant barrier to entry and to the success of the project.
.
scalability lastly symbolic execution techniques could be used to address the context sensitive problem.
however these techniques may not scale easily for large programs.
to improve scalability symbolic execution techniques may assume strings are bounded in length e.g.
no longer than characters which limits the techniques general applicability or model strings as sequences of characters which cannot adequately represent the semantics of certain string operations such as replaceall .
.
approach our approach provides a general framework for string analysis.
this framework allows for the development of customized string analyses that vary in terms of recall and precision in how they handle loops context sensitivity and string operation semantics.
to build this framework we designed an approach that separates the representation of the string operations from their interpretation.
this separation allows all string analyses to share a common underlying string model yet attaches di erent semantics to the modeled instructions.
our approach can be de ned as having two general phases.
in the rst the approach builds a model of the string operations in the program under test put and then in the second applies a custom interpreter to the model that implements the desired string operation semantics.
to model the string operations we de ne an ir that captures the data ow dependencies between string variables and string operations.
the ir can be computed for any code that can be represented in a static single assignment ssa form for which translations exist for most mainstream language e.g.
java dalvik and php .
in addition the ir also includes operations that allow it to represent strings de ned externally to the block of code e.g.
method parameters and data dependencies caused by loops.
we de ne the details of the ir in more depth in section .
.
in the rst phase our approach analyzes the put and computes an ir based summary for each of its methods.
within each method the approach uses a region based analysis to identify code enclosed by possibly nested loops and then specially models the data dependencies caused by loops.
in the second phase our approach translates the irbased summaries into a string representation.
to do this our framework allows a user to supply an interpreter of their choice that implements the desired semantics with respect to string operations loops and context sensitivity.
as part of the evaluation we implemented two such interpreters one that models the strings as fsas as is done in jsa and the second that carries out an n bounded loop unraveling for all loops in the put.
the interpreters also allow the users to leverage additional analyses such as alias analysis that can more precisely identify loop upper bounds include domain speci c knowledge or resolve other constraints.
.
the intermediate representation we de ne an ir that represents the control and data owrelationships among the string variables and string operations in a program.
the goal of the ir is to precisely model these relationships while deferring any sort of interpretation or approximation of these relationships until the second phase.
our ir speci cally targets control and data ow relationships that have traditionally complicated the modeling and interpretation of strings.
namely strings de ned external to the analysis scope strings constructed within possibly nested loops and inter procedural string manipulation.
our ir is structured as a tree with the leaf nodes de ning either string constants or placeholders for unknown variables.
the internal nodes in the ir tree are string expressions that represent the values of string variables in the put.
for explanatory purposes in the paper we will represent expressions in the ir tree as op a a2 whereopis the operation of the expression and airepresents the various arguments to op.
we write the de nition of a variable in the form ofvl wherevis the source code based name of the variable andlis the line number of the de nition.
to illustrate line of program is represented as b13 adda b .
in cases where a variable is de ned outside of the scope of the analysis e.g.
method parameters our approach leaves placeholders in the ir.
a placeholder variable is denoted by the subscript notation of xn wherexis a xed symbol andnis a number unique within the analysis scope identifying the external variable.
for example consider line of program the ir for this line is vx4 a .
these placeholders are preserved until they can be resolved.
for example in this case the ir of line becomes the method summary for adda .
whenever a call site for adda is encountered say at line the argument can be provided for the placeholders.
placeholders also allow additional analysis to be employed by the interpreters to resolve strings that may originate from les or database queries.
our approach de nes several ir operators to model the e ects of loops.
the rst of these is which is used to represent string variables whose values are partly de ned via a loop carried data dependency.
the form of this operator is t v r exp .
herevis the name of the variable de ned in the loop ris the id of the loop our approach numbers each loop region as explained in section .
trepresents the number of the loop iterations with t denoting the initial value of a variable in a loop and t denoting the value of a variable after one iteration and expis the ir expression that contains vin the loop.
note that expmay contain additional expressions which enables nested loops to be easily modeled.
within exp the de ned variable vis represented using the symbol t0 v r. to illustrate consider the variable e33in program .
equation shows the value of e33for thekthiteration.
k e33 r2 k e33 r2 b this equation shows that the value of eat line is equal to the concatenation of its value from the previous iteration and the constant string b .
here the identi er r2 refers to the loop region id which we will explain in more detail in section .
.
the nal loop related operator is .
the expression has the same format as the expression but denotes a dependency between self referring variables in the same loop instead of a nested loop dependency.
here we de ne self663referring variable as a variable that de nes itself at least in part via a loop carried dependency.
the expressions are always sub expressions of the expressions.
when a expression is used it represents that the variable of the expression depends on the variable of the expression and both of them are from the same loop.
to make this clear we take the example at line and line in program .
in our example both c19andf20 are self referring variables from the same loop and c19is used to de ne f20.
the ir of f20is shown in equation where the underlined portion refers to the value of c19 which shows how the value of f20depends on the value of c19.
in this expression the superscript of means the value of the variable in the current iteration and nmeans the value n iterations prior.
f20 f20 r3 f20 r3 c19 r3 c19 r3 a a we introduce the symbol because the dependency between self referring variables in the same loop is di erent from the dependency due to nested loops.
we compare the value off20in equation to the ir of d29in equation .
in the ir of d29 the underlined portion refers to the value of e33 which is generated in a loop di erent from that of d29.
on the contrary in the ir of f20 the underlined portion refers toc19 which is a variable from the same loop of f20.
d29 d29 r1 d29 r1 e33 r2 e33 r2 e .
interpretation of the intermediate representation the interpretation step converts the ir of string variables into a representation of strings.
our framework allows users to provide an interpreter that translates the ir as needed for di erent analysis problem.
to do this a user would need to implement two things the string model for each string operation e.g.
append and trim and a widen andconverge function for the expressions.
here widen is used to generalize the expression on each iteration to make the string values converge quicker.
for example one instance of widen proposed by yu and colleagues can generalize string set f a aa aaa gto the regular expressiona .converge is used to judge when the approach should terminate iterating over the expression.
the general process for ir interpretation is as follows.
first our approach uses the target string models to represent all leaf nodes in the ir that are string constants and external inputs.
second our approach calculates the value of each non leaf node using a postorder traversal of the ir tree.
during this calculation our approach uses the speci ed string operation semantics to calculate the value of each ir operation.
third when the approach encounters a expression it iterates over the expression to calculate the resulting string value.
we will describe this process in more detail in the next paragraph.
after each iteration our approach calls thewiden expression to generalize the string model created in the current iteration and then the converge method to check if it should stop iterating over the expression.
our approach may iterate several times over each expression depending on the widen andconverge operations.
in each iteration while interpreting the expression t v r exp whereexpcontains at least one k v r our ap proach rst increases the counter tfor the expression and all v r. after this our approach sets the value of k v ras the value of k v r exp generated in the kthiteration.
then it calculates the value of exp calls thewiden operation to calculate the result of current iteration.
this value will be recorded as the value of in future iterations.
during each iteration if our approach encounters a nested expression it will iterate over this expression until the value converges using the processes we described in the prior paragraph.
if it encounters a expression the approach updates the counters for and its and calculates the value with a process similar to that of interpreting the expression.
the only di erence is that our approach does not iterate over the operation several times.
it only calculates the value of once without calling the widen andconverge .
we do this because represents another variable in the same loop so its value can only be calculated once in each iteration.
the resulting values of the expression will also be recorded as the values of future corresponding operators.
.
getting the intermediate representation in this section we describe how our approach generates the ir for a given put.
as inputs our approach requires the call graph cg of the put and the ssa representation of each method in the put.
in general most mainstream languages e.g.
java dalvik and php have analyses available that can provide both of these elements.
given these inputs our approach analyzes each method in reverse topological order with respect to the put s cg.
for each method the approach then identi es the region tree rt and builds the ir for each region in this tree in a bottom up fashion.
after the approach nishes analyzing a method the resulting ir serves as its summary and is reused whenever another method calls the summarized method.
.
.
intra procedural analysis the approach begins with an intra procedural analysis to calculate the ir based summary for each method in the put.
the rst step of this analysis is to identify the bodies of loops and their relationship to other loops.
this information is needed in order to use the loop modeling operands de ned by the ir.
to identify loops our approach uses a standard analysis to identify regions in the method s control flow graph cfg .
the regions of a method can be represented as a rt in which nested regions are shown as children of their parent regions and the root node of the tree is the method body.
figure shows the rt for an excerpt of the code of program .
in this gure r0 represents the method body of main andr1 r3 are loops in the method.
after the approach builds the rt the next step is to generate the ir for each region.
the approach analyzes the rt using a post order traversal i.e.
starting with the leaf nodes so that the results of analyzing nested regions can be incorporated into the analysis of the parent regions.
in general there are two types of regions that the approach analyzes.
the rst type is method body regions mbrs which represent the main body of a method e.g.
r0 and the second type is loop body regions lbrs which are the regions that represent the bodies of loops e.g.
r1 r3 .
we now explain how the approach analyzes each of these region types.
664figure the region tree for program algorithm getting the intra procedural intermediate representation input a regionr output the ir of string variables in r external all external variables for all instruction sinrin topological order do ifsde nes a variable vthen represent s in the form of the ir as v op a 1a2 for allai2par s do ifaihas been solved and ai62external then replace aiwith its ir end if end for end if end for .
.
general region processing regardless of their types all regions are rst processed by algorithm .
the input to algorithm is the ssa representation of the code in a region r. the output of algorithm is a basic ir transformation of rthat does not consider the e ect of loops.
the rst step of algorithm is to identify variables whose de nitions occur outside of the region line .
these variables can be identi ed in a straightforward way since the code is in ssa form by checking if they are de ned in the current region.
all other variables are considered to be internal variables.
the approach will leave placeholders for external variables until their de nitions are located in a containing region.
an example of an external variable is the use ofcon the righthand side of line in r3.
after nding all external variables the approach then iterates over each instruction in rin topological order with respect tor s cfg.
for each instruction iin which the left hand side de nes an internal variable v the approach convertsiinto an ir operand of the form op a 1a2 as shown in section .
.
then the approach iterates over all arguments for op which ispar s .
if any argument aihas previously been de ned on the lefthand side of an instruction in the region then the righthand side of that de nition is substituted for the ai.
this process is continued until there are no more such previously de ned internal variables present in the ir form of i. then the approach repeats this for each of the remaining i2r.
note that since the e ects of loops are not considered at this time and the instructions areprocessed in topological order the transformation converges on a xed point after one iteration over the instructions in r. example to illustrate algorithm rst consider line of r3 in figure .
the ir for this line is c19 a .
note that due to the ssa transformation c15 a could also be a de nition here.
however we omit these ssa based de nitions from the explanation for simplicity since our code example is not shown in ssa form.
following with this the ir for line in r3 would be f20 c19 a .
.
.
processing loop regions the next step is to analyze all lbrs and more precisely model the e ects of loops in the region.
this is performed by the algorithm shown as algorithm .
the input to algorithm is the ir of an lbr that has already been processed by algorithm .
the output is an ir representation of the lbr that has been adjusted to model the e ects of loops.
the ir of an lbr can be incorporated into its parent loop or a mbr.
algorithm can be thought of as having three general phases.
the rst of these lines rewrites all string variables within the lbr so that they have counters attached to them.
these counters are then used in the second phase to identify dependencies between loop iterations.
the second phase lines iterates over the instructions in the lbr and replaces string variables de ned in the loop with values updated for each iteration.
loop carried data dependencies are identi ed and replaced with the and operators so that the de nitions of the string variables can converge on a xed point.
finally in the third phase lines the analysis replaces certain operators with the operators.
we now explain these three phases in more detail below.
in the rst phase lines our approach assigns and initializes a counter to all region internal string variables.
the analysis iterates over each instruction i2lbr and if it is of the form v op a 1a2 am an i.e.
a de nition andvis an internal variable then the analysis performs the following transformations.
the variable vis rewritten to be v0and each of the arguments akis rewritten as a k. the intuition behind this transformation is that the superscripts show that the variable on the lefthand side is de ned by the values of the righthand side variables that come from the previous i.e.
iteration.
note that since algorithm has already propagated all values forward all righthand side variables were de ned in the previous iteration or in the base case external to the lbr.
to illustrate the rst phase we will build on the example from section .
.
.
here for line of program the ir isf20 f20 c19 a .
the transformed version of this ir with counters inserted and initialized would be f0 f c a .
note that after the transformation done by algorithm the f20on the righthand side refers to the value of ffrom the previous loop s iteration or in the base case the value provided at line .
in the second phase lines the approach iterates over each instruction propagating values and updating counters until the ir of the instructions converges on a xed point.
the approach begins this phase by iterating over each instruction that is of the form v0 op a 1a2 an i.e.
a de nition .
at lines the approach adds all variables on the righthand side that are region internal variables to a worklist q. then at lines the approach will 665iterate over all variables in the worklist replacing them with updated values and introduce and notions so that variables de ned in the loop will converge to a xed point.
in the loop beginning at line the approach dequeues the rst argument in the worklist and determines if it refers to v i.e.
if it is a self reference.
if it is then the approach replaces the self reference with the notation and puts a notation around the expression as described in section .
.
if the argument is not a self reference then the approach replaces it with the most up to date ir representation and decreases all counters in the replaced expressions by the counter value for the replaced argument.
this maintains the correspondence between loop iterations.
all arguments present in the replaced argument that are self