static race detection for device drivers the goblint approach vesal vojdani university of tartu estoniakalmer apinis university of tartu estoniavootele r tov university of tartu estonia helmut seidl technische universit t m nchen germanyvarmo vene university of tartu estoniaralf vogler technische universit t m nchen germany abstract devicedriversrelyonfine grainedlockingtoensuresafeaccessto shareddatastructures.
forhumantesters concurrencymakessuch codenotoriouslyhardtodebug forautomatedreasoning dynamically allocated memory and low level pointer manipulation poses significantchallenges.
wepresentaflexibleapproachtodatarace analysis implemented in the open source goblint static analysis framework that combines different pointer and value analyses in ordertohandleawiderangeoflockingidioms includinglocksallocateddynamicallyaswellaslocksstoredinarrays.
tothebestof ourknowledge thisisthemostambitiouseffort havinglastedwell overtenyears tocreateafullyautomatedstaticracedetectiontool that can deal with most of the intricate locking schemes found in linuxdevicedrivers.
ourevaluationshowsthattheseanalysesare sufficiently precise but practical use of these techniques requires inferringenvironmentalanddomain specificassumptions.
ccs concepts theory of computation !program analysis software and its engineering !software safety keywords concurrency racecondition abstractinterpretation .
introduction amultiple access data race occursinaconcurrentprogramwhen differentthreadssimultaneouslyattempttoaccessasharedmemory locationandoneoftheaccessesisawriteoperation.
withoutproper synchronization the result of such accesses areunpredictable.
as a problem notoriously hard to debug there has been plenty of efforttodetectsuchbugsstatically .
however fully automatedstaticanalyzershavehadlimitedsuccessinchallenging settings suchasanalyzingdevicedrivers.
the basic approach to race detection is to track the set of locks definitely held by each thread and so ensure that all accesses todata mtx list prev nextdata mtx list prev nextdata mtx list prev next nodelist next prevlist lock figure mixed granularity locking scheme.
sharedmemorylocationsareprotectedbyacommonlock.
thissocalled lockset algorithm wasfirstappliedinadynamicsetting .
thereare however seriousdifficultieswhenadaptingthisideato the static analysis of linux device drivers.
in low level c code locks can be placed within heap allocated data structures as depicted in figure .
elements within a linked list have their own locks protecting their data fields however the linked list itself is protectedbyalistlock.
asthelinuxkernellistshavetheirfields embedded into the container struct we have different portions of thesamestructurebeingprotectedwithdifferentlocksofdifferent granularity.
sincepreciseshape analysisiscostlyforthelow level linkedlistsprovidedbythelinuxlistapi weuseacombination of aliasing and points to analyses each targeting locking schemesofdifferentgranularities.
linuxcodealsofeaturescomplicatedcontrolflow.
conditional locking possibly failing locks and value dependent synchronization have been reported as major sources of false alarms for race detectors .
theseconstructsrequirethatthevaluesofprogram variables be taken into account in a concurrent setting.
further whenlocksarestoredinarrays weneedrelationalanalysesto correlatelockindiceswiththedatatheyprotect.
we present an algorithm for static race detection that can deal with value dependent synchronization and we then extend this to deal with several locking schemes for dynamically allocated data.
most crucially the approach we present in this paper is parametric on the precise analyses used.
race freedom is a conditional propositionthatrequiresthecombinationofmay aliasinformation with must equality information.
we show how such information canbecombinedinamodularandgenericfashion.
thisextensibilityhasallowedustokeepimprovingtheframework adaptingitto different concurrency models as well as considering increasingly complicatedlockingidioms.
the algorithm described in the paper was implemented in the goblinttool whichwasusedtoevaluatetheapproach.
thegoblint permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
isanexhaustivebugdetectiontool itreliesonsounddataflowanalysesusingabstractdomainstoconservativelyover approximatethe behavior of the system.
thus when the analyzer is satisfied we have high confidence in the correctness of the analyzed code but thenaturaldrawbackisthatwemayhavemanyspuriouswarnings.
to get a realistic impression of its ability we chose as our analysis targets all linux character device drivers which our front end librarycoulddigest.
theresultsshowthatonaveragelessthan5 of memory locations are ruled potential races where the access is directlyinthesourcecodeofthedriver.
whilewewerenotableto excludethesecasesaspotentialracesuponmanualinspection we did not find any races in currently maintained device drivers that wewereconvincedcouldleadtoacrashorcorruptionofdata.
for apracticallyusefultool westillneedtoreducethenumberoffalse alarms by taking domain specific and environmental assumptions intoaccount.
insummary thispapermakesthefollowingcontributions wepresentasoundconcurrencyabstraction basedon privatization thatcandetectracesandcomputethevalueofinteger variables section3 .
weextendtheprivatizationapproachfromstaticintegersvariables to generic heap regions.
we present a race detection algorithm parametric on may and must alias analyses that can deal with a wide range of locking schemes sections and5 .
wehaveimplementedthisapproachintheopen sourcegoblintanalyzer1andevaluatedthisapproachonasetofdevice drivers section6 .
wewillbeginbypresentingtheconsistencymodelthatarchitectureindependentcodeinthelinuxkernelmayassume.
thiswillmake our analysis much clearer because there is a correspondence between what our analysis computes and the configurations of the model.
section4illustratesourapproachwithmanyexamples.
.
consistency model the linux operating system supports many different architectures eachwithdifferingmodelsofmemoryconsistency.
outside architecture specific code we can make few assumptions about when read and write operations are visible to different threads.
in thissection wedescribeamodelofconcurrentexecutionthatonly makestheconsistencyassumptionssatisfiedbyallarchitectures.
asweanalyzelinuxkernelmodulesseparately wemodeleach driverasanopenprogramoperatinginahostileenvironment.
each module contains an initialization function where execution of the modulebegins.
thisfunctionwilleventuallyregisterasetofcallbackfunctionsandinterrupthandlerswiththeenvironmentwhich can then call these exported functions at will.
from the moment these functions are registered we assume they can potentially run inparallel.
inreality therearemorerefinedschedulingconstraints e.g.
probe functions and open close run sequentially for each device.
althoughourconcurrencymodelover approximatesthedata flow we can still consider more refined may run in parallel informationwhenreportingdataraces aswillbeseeninexample5.
in our model whenever the kernel calls the operations of the devicedriver theassociatedcallbackfunctionrunsinanewthread instance.
followingtheterminologyofdeligiannisetal.
the registeredfunctionsformthesetofthread templates t. thecode of each thread template t2 tis given as a control flow graph n e nt wherenis the set of program points ntthe start point of this thread template and each edge u l v 2eis a transition labeled with either an elementary command sor one oftheprimitiveconcurrencyoperationsforacquiringandreleasing mutexes l sjlock m junlock m sincethispaperfocusesexclusivelyonlock basedsynchronization we do not include in our formalism any constructs for threads to waitoneachotherwithouttheuseofmutexes suchaswaitqueues eventsandconditionalvariables.
as an unbounded number of instances of each thread template may run in parallel the set of thread identifiers is i t n. henceforth whenweusetheword thread wespecificallymean thesethreadinstancesidentifiedbytheelementsin i. thus inour formalmodel weassumethatafterexecutionofsomeinitialization code we have an infinite set of threads iready to run in parallel.
thesethreadsissueinstructionsthatinvolvememoryaccesses including the synchronization operations.
in a multi processor system such instructions are not completed instantly.
the following recountsthestandardterminology.
definition .
aninstructionis completed with respect to another threadwhen that thread can read the new value in the case of a store ornolongerinfluencetheresult inthecaseofaread.
aninstructionis completed whenitiscompletedwithrespecttoallother threads.
there has to be some memory consistency between the views of each thread this is determined by the consistency model ofthearchitecture.
asmentionedabove wehavetoassumetheweakestconsistency model common to all supported architectures.
the linux memorymodelonlyprovidestheguaranteesof release consistency .
under this consistency model synchronization operations are distinguished as acquire and release operations and they only serve asone waybarriers.
forexample memoryoperationsissuedafter an acquire will be completed after the acquire operation has completed however memoryoperationsissuedbeforetheacquiremay be completed after the acquire operation has completed.
we describe the model at a high level leaving the details of the cache coherence protocol and its implementation to indeterminism.
we onlyenforcethat atworst cachesneedtobeflusheduponrelease andinvalidateduponacquire.
letldenotetheaddressspace i.e.
thesetofmemorylocations available to the program.
to reduce notational overhead we treat local variables as thread local globals in this formalization.
the state of a single threaded program could be described by its programcounter indicatingthelocation u2nofthenextcommand tobeexecuted andamappingfrommemorylocationstotheirvalues.
astheintra threadsemanticsisoflittleinteresttous weshall justviewmemorylocationsasholdingintegervalues.
thestateof memoryisthusrepresentedasamappingin d l !n.
the state of executing a multi threaded program is represented inourmodelbythelocalstatesofeachofthethreadsin iaswell as shared state 2 d representing e.g.
physical memory or the value at the home node depending on the architecture.
in our model commands are issued in their intra thread order although the order in which they complete is non deterministic.
the state of an individual thread i2 iis thus characterized by its program counterui indicating the command it is about to issue and the thread slocal possiblycached viewofmemory i2 d. inorder to formalize the consistency model we also associate with each thread the set of lock addresses it has acquired i22las well asthesetofaddresses wi22lwhosecachedvaluesareyettobe 392table summary of notation mnemonic aid for entire paper not self contained .
concretemodel abstractanalysis u i !nprogramcounterforeachthread u n computesinvariantforeachprogrampoint.
i !
d memoryviewofeachthread n!dprivatizedstateatthatprogrampoint.
i !
2llocksheldbyagiventhread.
n!2msmust setof symbolic locksatthatpoint.
w i !
2lpendingwrites dirtycache g!2mrcommon relative locksduringaccess.
d mainmemory.
d globalinvariant.
flushed to main memory.
the components of the concrete model are summarized in table which also shows the corresponding analysisabstractionofeachcomponent.
wemodeltheexecutionasanon deterministictransitionsystem.
a configuration d0 u0 w0 0 is an initial configuration if u0maps each thread to an entry of a function 0maps all threads to the empty lockset w0states that no thread has pending cachewrites and 0isapossiblestateofmainmemoryafter runningtheinitializationcode.
let d0denotethesetofinitialconfigurations.
givenaninitialstate thesystemevolvesaccordingto thefollowingtransitions.
atanymoment anythread i2 icanbechosenandthestateof the system is updated.
we adopt the following notational conventiontodescribethesetransitions u w !
u w weuseprimedsymbolstodenotethepost state andwewillspecifyonlythechangestothepost state assumingthesemapsremain thesameforanyvaluenotexplicitlymentionedinthedescriptions below.
there are two kinds of transitions in our system one correspondstothecpuissuinganinstructionandtheotheraretransitionssimulatingarbitrarybehaviorsofthememorysubsystem.
we firstconsiderthelatterrules.
flush.anypendingwrites x2wimaybeflushedtomainmemorysuchthat x i x andw i win fxg.
invalidate.
clean locations in the cache x 2wimay be invalidated at any time.
we model this by immediately updating thevalueinthecache i x x .
in real systems and in our analysis implementation cache invalidationonlysetsaflagandthecacheisonlyupdateduponanactual readrequest.
thismodelisstillsuitabletoprovethesoundnessof ouranalysisbecauseitisanon deterministicmodelthatallowsthe refreshingofthecacheatanytime.
the cpu transitions will update the program counter as it issuesinstructions.
forathread i assumethereisanoutgoingedge ui l v 2efrom its current program counter uito some other nodev.
if the instruction lcan be issued in the current configuration we take that transition and set u i v. we now consider the effect of issuing ordinary as well as synchronization actions.
we assume an intra thread semantic function for basic statements jsk d !
d. this may be a partial function for example if s is a conditional guard the transition is only defined when the inputstatesatisfiestheconditionof s. weobtainthesetofreadand write accesses while evaluating that instruction using the function jska d !
2lwherea2 fr w rwgindicatestheaccessesweare interestedin.
statements.
ifjsk iis defined we update the thread local view i jsk i. wealsomarkanyupdatedlocationsasdirtyin thecachew i wi jskw i.acquire.ifthelockmisavailable i.e.
m 2 j j weset i i fmgandweinvalidateallcleancachelocations 8x 2 wi i x x .
release.if we have the lock i.e.
m2 i we release the lock i in fmgand flush all pending writes 8x2wi x i x andw i .
the side condition for acquire which only permits the acquisitionofalockifnothreadalreadyholdsit ensuresnon interleaving execution of critical sections protected by the same lock.
the release transition requires that a thread holds the lock it attempts to release.
accordingtothesemanticsofthekernelmutexsubsystem attempting to reacquire a lock one already holds results in a deadlock whileattemptingtoreleasealockonedoesnotholdresultsin afailure bothcasesleadtostuckstatesinoursemantics.
definition .
the set of reachable configurations dis the transitive reflexive closure of the transition relation applied to the set ofinitialconfigurations i.e.
d fdj 9d02d0 d0!
dg definition .
there is a race in configuration u w at locationx2 lifdistinctthreads iandjmaybothissueinstructions accessing that location i.e.
ui s1 2eand uj s2 2e withx2js1krw i js2krw j. wesaythereisaraceatlocation x2 lifthereexistsaconfiguration d2dcontainingaraceat x. here wedonotdistinguishbetweenreadorwriteaccesses.
this distinction thoughpracticallyimportant isnotconceptuallyinteresting and would make the subsequent analysis far more cumbersometodescribe.
.
value and mutex analysis computingwhetherthereexistracesinaprogrambasedonthe semanticsdescribedpreviouslyisinfeasible.
thenumberofinterleavings grows exponentially with the number of statements even forjusttwothreads.
inwhatfollows ourgoalistoprovideefficient analyses that can detect races first assuming memory locations l arelimitedtoasetoffixedintegervariablenames g andthengeneralizingtoabstractionsofarbitrarymemorylocationsinsection5.
thegeneralapproachistosetupaconstraintsystemthatuses abstractsemanticsinstead wherethesolutionoftheconstraintsystem providesusreliableinformationaboutdataraces.
considertheprograminfig.
.
themainthreadsetstheglobal variablexto1andstartstwothreads.
globally thesharedvariable xhas value .
this invariant however is locally violated by the first thread while it holds the lock.
the other thread relies on the invariant to hold whenever it acquires the lock otherwise it sets xto an error value.
verifying that this program is free from races requirestheinferenceoftheinvariant buttheinvariantcanonlybe soundlydeducediftheprogramcanbeshowntobefreefromraces.
this means that the invariants and data races are to be inferred at thesametime.
3931t1 6t2 1011lock m x x x x unlock m lock m if x if x unlock m unlock m x figure example program in our model.
our abstract semantics contains a global lockset mapping a globalinvariant andforeachprogrampoint asetoflocks as well as a privatized mapping of the variables to their abstract values .
inourimplementation thismappingprimarilystoreslocal variables but we will focus here on the framework for analyzing sharedglobalvariablesthatareprivatized andthustreatedaslocal variables within critical sections.
the analysis itself is succinctly expressed as a constraint system.
we will present this top down first showing the entire system and only then defining the functionsusedintheconstraints.
forallprogrampoints u2n edges u s v 2e sharedglobals x2g andstartpoints ntwitht2 i wehavethefollowingconstraints.
v v jsk u u nt nt mfs u u syncs u u u u syncs u u thefirsttwoconstraintsareconcernedwiththeintra threadbehavioroftheprogram.
weassumethatwehaveasoundvalueand lockset analysis that give the abstract intra thread semantics of an individual instruction as jsk .
this function is applied in the first constraint to the privatized state uand the obtained values must be taken into account by the local state and lockset at the destinationnode.
thesecondconstraintmakessurethreadsstartwiththe proper initial values.
since we track must sets of locks the orderingisreversedwith and?
m thelock setsareinitially empty.
thethirdconstraintupdatesthemapthatspecifieswhichglobals areprotectedbywhichlocks.
thisisdoneusingthemutexfunction mfsalongsideinterpretationofaninstruction sintheabstractstate .
thus weneedtoconstrainthelocksetoftheaccessedvariables jsk rw withthecurrentlockset .
mfs d 2m !g!2m mfs x ifx2jsk rw ?otherwise.
as the bottom value here is m we effectively leave the locksets fortheuntouchedglobalsalone.
the last two constraints correspond to the flushing and invalidation actions of the concrete model.
here the privatized values of unprotected globals are synchronized with the global invariant.table fixpoint computation of the example.
u u x u x comment mstartwith 0andm fmgmlockisacquired fmgfmgprotectedaccessto x fmgfmgxisstillprotected fmgonlynow x x fmgstartwith x fmgfmglockisacquired ?m fmgconditionx 1isfalse ?m fmgdeadcode notarace!
fmgfmgconditionx 1maybetrue fmglockisreleased fmgre computefirstthread fmgfmg x x stillholds fmgfmgfixpoint!
forthis weneedanoperatorthatdeterminesthesetofglobalsprotectedbysomelockset accordingtothegloballocksetmap prot fx2gj x g wethendefineasynchronizationfunctionthatreturnsnon bottom valuesfromamap fortheunprotectedglobalsthatareaccessed byastatement sinstate syncs x xifx2jsk rw andx 2prot ?otherwise.
usingthisfunction thelasttwoconstraintssynchronizetheprivatizedinformationwiththeglobalinvariant ontheportionofthe sharedstatethatmaynotbeprotectedatagivenprogrampoint.
wesolvethesystembyfixpointiteration.
theconstraintsystem is monotonic because as the locksets are constrained fewer and fewervariablesareprivatized.
wecansolvethesystembyiterating fromtheleastelementasshowninthefollowingexample.
example .
the process of solving the constraint of the examplefromfig.2isshownintable2.
foreachprogrampoint u the values u x and uhavetobe re computedforacommon x .
the value x will start off as the set of all mutexes mand can only decrease.
the integer variable is initially unreachable ?and thelocksetistheemptyset.
first wecomputethethreevaluesfor eachrowgoingfromtoptobottomofthetableinthenaturalorder oftheprogrampointlabels.
afterthefirstiterationweseethatwe mustcomputeprogrampoints1and2again astheyhavenotbeen consideredfor x fmg.
however noneoftherespectivevalues u x and unorthestartingpointofthread2willchange.
we have therefore foundtheleastsolutionoftheconstraintsystem.
having computed the least solution to the above constraint system we will flag all global variables with an empty lockset as potentiallyracing race fx2gj x g next wewillformallyrelateourabstractsemanticswiththeconcrete model.
this will be done using a concretization function that maps abstract states sinto sets of concrete states dthat are representedby s. forthiswerequirethattheanalysisweusealso 394providetheirconcretizationfunction whichwewillalsocall .
notethatthemainconcretizationfunction willnotnecessarilybe monotonic.
wedonotrequiremonotonicityaswewillonlyuseit toshowsoundnessofsolutionsoftheconstraintsystem.
lets be a solution to the above constraint system.
aconfiguration u w s iffthefollowingconditionshold for each thread i whose program counter is now ui the mutexesacquiredaresoundlyapproximatedbytheanalysis ui i andthelocksetsdonotoverlap i.e.
i j onlyifi j. the global invariant contains the values for all unprotected globals 8x 2 j2iprot uj x x thewaythread iviewsmemoryiscorrectlyrepresentedfor allglobalsitmayaccessorforwhichithaspendingwrites 8x2prot ui race wi i x ui x the set of pending writes wimust include all updated protectedglobals fx2prot ui j i x x g wi theanalysisdoesnotcareaboutvaluesthatcannotbeaccessedby thegiventhreads.
also theglobalinvariantonlypartiallyspecifies the values of main memory.
within a critical section the state of main memory could have any value as this does not influence the value of the computation after synchronization points.
thus we mayincludesomeconfigurationsinourinterpretationoftheanalysisresultthatarenottrulyreachable butwhatreallymattersisthat wearecertaintoincludeallreachableconfigurations.
theorem1 soundness .
ifsis the least solution to the above constraint system and d is the set of reaching configurations we haved s .
proofidea.
asdistheleastsetclosedunderthetransitionsdefinedintheprevioussection wewouldneedtoshowthattheconcretizationofouranalysisresults s isalsoclosedundereachof the transition rules.
we will briefly describe the key observations thataformalsoundnessproofwouldrelyon.
forordinaryinstructions constraints and ensure thatallvalues accessibleby a threadatprogrampoint uaresoundlyover approximatedintheprivatizedstate u. theresultingcomputation therefore remainsin s aslongasourintra threadtransferfunctionsaresound.
let us also consider a release action.
in this case a previously protectedlocationmaynowbeunprotectedandotherthreadsmay potentiallyaccessit.
wedidnotrequireprotectedvaluestoberepresented by our global invariant but the value is correctly representedinthelocalstate u. aswerequirethatprotectedlocations with differing cached values mark such locations as dirty the outstanding write will complete and by constraint that value is propagatedintotheglobalinvariant.
conversely duringanacquire action someglobal xmaynowbeprotectedbyathread i. inthat case thevalueof xiseitheralreadyrepresentedin u orwehave x 2wi sothecachemustbeinvalidated andbyconstraint the local state will take the correct value of xfrom the global invariant.
theorem2 racefreedom .
lets be a solution to the constraint system.
for any global x2g if there is a race atx we havex2race .proof.for there to be a race at variable xthere would need to be some reachable configuration where two different threads both issue instructions accessing x. given that their locksets may not overlap and our analysis is sound x would be constrained by twosetswithnoelementsincommon ensuring x .
theanalysiscanbeinstantiatedwithdifferentabstractdomains andourframeworkallowtheseanalysestobebothpath andcontextsensitive.
path sensitivityisimportantinordertodealwithconditional locking or potentially failing locking operations.
for this we use a property simulation abstract domain .
the relevant property is the set of definitely held locks so we never join locksets instead wetrackthevalueabstractionforallpossiblelocksets.
in this way an operation like r try lock m will split the state reflectinginthereturnvalue rwhetherthelockisacquiredornot.
we have not included function calls and local variables in this framework because our treatment is fairly standard and relies on the entry and combine operators used in the functional approach to inter procedural analysis .
applying the flow insensitive treatment of shared globals in a context sensitive setting requires computingpartialglobalinvariants asweonlywantconsider thecontextsthatareencounteredduringanalysis resultinginsideeffectingconstraintsystems .
.
a general approach we now extend the notion of a memory location from a set of static variables to static identifiers that represent disjoint portions of shared memory locations.
we do not rely on a fixed heap abstraction instead ourgoalistoarriveataflexibleframeworkthat combinesdifferentanalyses.
wemayeventakeamoreeinsteinian viewofspaceandencodetemporalinformationaswell.
generally speaking racefreedomisaconditionalpropositionoftheform iftwoaccesses mayconflict certainsafetyconditions musthold.
forexample iftwoaccessexpressionsmayalias theircorresponding lock expressions must alias.
there are however other justifications for excluding races that fit within this paradigm.
we let each analysis contribute to either side of the conditional a thread uniquenessanalysisprovidesanadditionalsafetyguaranteeexcludingraces whileahappens beforeanalysiscanrefinethenotionof whenaccessesmayconflict.
instead of the set gof variables from a fixed set of names we nowmovetoanabstractdomain g representingmainlymay alias equivalenceclasses.
combiningmay aliasinformationisstraightforward given two analyses that soundly partition memory into may aliasequivalentclasses theircartesianproductwillalsoform a sound partitioning.
our privatization framework requires that we not only answer pairwise may alias queries but that we give acanonicalrepresentativeforeachaddressexpression.
thisisprovided by e.g.
by region based shape analyses .
we refer to the canonical representative of a heap region as the ownerof that region.
in order to correlate regions with locks owners must refer to unique memory locations that can be described statically.
such descriptions however may depend on parameters such as the base address and integer offsets to specify concrete locations intheheap.
example .
considerthefollowingexampleofper elementlocking.
theassumptionhereisthattheparameterisentirelyunknown to us still it should not be hard to establish that the program is race freeforanyelementoftype node.
395struct node mutex mtx int data thread t struct node p lock p!mtx p!data unlock p!mtx wehavenobetterdescriptionoftheregionthisaccessbelongsthan its type and the field that was accessed.
for the lock we have to keepasymboliclockset fp!mtxg andifatthetimeofaccess we canestablish thatthe basepointers areequal weconvert thesymboliclocksettoarelativelockset f .mtxgbyreplacingreferences torealvariableswithsymbolichostvariables.
forthisexample we get node.data f .mtxg this will serve to decouple our may and must alias information so that we can map an arbitrary may alias equivalence class to a locksetanduse torefertoindividualelementsofthisequivalence class.
example .
thisideacanalsobeappliedtodealwitharray based locking.
ifwehaveanarrayoflocksthatisusedstatically wecould simplyaddconcreteindexestothelockset.
ifwecanestablishan equality though wereplacetheindexwithasymbolicindex.
consider a simple program now with an array of locks protecting an arrayofdata mutex mtxs thread t1 int i int data lock mtxs data unlock mtxs we will now replace anything established an equal by an integer must equalityanalysiswithsymbolicindices data fmtxs g example .
we say that a thread is unique if only a single instanceofagiventhreadtemplateiseverspawned.
wecanassume thatauniquethread talwaysholdsamutex mt.
thereisaclassic exampleintheintelthreadcheckertutorialwherethethreadcreatedbyparameter iistheonlythreadthataccesseselement data .
int data int main int i thread t int i while i data spawn t i givenananalysisthatensures itakesuniquevaluesineachiteration ofthewhileloop wecanverifythisexamplebyreducingitthecase abovewherethearrayisprotectedbyanarrayoflocks data fmt g example .
asimilarapproachenablesustomakeuseofdomainspecificknowledge.
considerfollowingtwofunctions void open file f void close file f g g f!data f!data assumethatthereisanenvironmentalguaranteethatforeachfile f thesefunctionsarecalledsequentiallywithopenalwayspreceding aclose however differentfilesmaybeopenedconcurrently.
basedmtxs slots t figure medium grained locking scheme .
onthisinformation weareabletodeducethateachaccessto fin function openis protected by the lock mopen and that accesses tof!datainopenandclosecannot race as they are time wise disjoint file.data open fmopen g file.data close fmclose g weneedtheuniquenessmutextoexpressthattherecanbenoconcurrent opens and the time regions to express that open and close maynothappenconcurrently.
notethatnosuchguaranteesareextendedtotheglobalvariable g sowehave g meaning thattheaccesscanhappeninanytimeperiod.
example .
letusnowconsiderdynamicallyallocatedstructures.
wecanextendper elementlockingjustaseasilytoallocation site abstraction butwenowneedtoconsiderlocksthatprotectanentire datastructure suchasalinkedlist.
asouralgorithmisparametric onhowthesemay aliasequivalenceclassesareobtained wedonot needtocareifwearedealingwithmay points tosetsortheresult of a more sophisticated heap analysis.
we do however need the heapanalysistoexportarrayindexexpressions.
consider now a synchronized hash table figure .
when the pointertstartstotraverseacertainbucket ourpointeranalysismay beabletosaythatthisbelongstotheregiondescribedby slots .
lock mtxs t slots !next while t !
null t!data t t !next unlock mtxs wemaythennotethatthe iusedwhentfirstenteredthememory region slots is equal to the index used when acquiring the lock locks .
ifaregionanalysiscandeterminewhenthesebucketsare disjoint we can essentially reduce this case to the previous example r slots ln.data fmtxs g to incorporate this analysis into our framework the analysis providesthesymbolicindexexpressionoftheregionthatapointerbelongsto.
whenweaccess t!data theregionanalysisknowsthat t2r slots andtheindexexpression imustbemadeavailable toourframework sowecanmakesureitcorrespondstotheindex usedwhenacquiringalock.
example .
thefollowingexample althoughcontrived willclarifytheintuitionbehindourapproach.
assumethatthedatafieldof ourstructisitselfanarrayandwenowhaveamatrixoflocks 396lock mtxs t slots !next lock mtxs t!data unlock mtxs unlock mtxs thefirstlockofeachrowisreservedfortheslots sotherestofthe locksareoffsetbyone.
itisworthseeinghowthisisexpressedin ourlocksets r slots ln.next fmtxs g r slots ln.data fmtxs g when we access t!data we are given the list of index expressions which we use to check against the expressions used when acquiring the locks.
our framework does not know that i is part of the region and jis the offset of the access but relies on whatever combination of may alias analyses we use to be consistent inawaymadepreciseinthenextsection wheneveraskedfor thelistofindexexpressions.
example .
finally weconsiderourintroductoryexamplefrom figure1 wherewehavearegionofmemorythatprotectsthelock field embedded into elements whose data fields are protected by theirownmutexes.
struct node int data int mtx struct list head list assumewehaveaglobalmutex list lockandagloballistof nodes ndlist.
we may be iterating through ndlist attemptingtofindthelastnodehavingagivenvalue struct node find int id struct list head lp ndlist.next struct node np res lock list lock while lp !
ndlist np container of lp list lock np !mtx if np!data id res np unlock np !mtx lp lp !next unlock list lock return res in this case we will have the following common locksets while executingthefindfunction r ndlist lh.next flist lockg r ndlist node.data flist lock .mtxg the above function returns the found node which the user may accesswithoutthelistlock restrictingthelocksetfurther r ndlist node.data f .mtxg the access to the list fields however is not influenced by this accessbecauseboththefieldandthetypeforthataccessaredifferent.
forthisexample wedidnotactuallyusetheregioninformation butthemomentwehaveanotherlistusingthekernelapilisttype lh we would be accessing the same fields for all lists in the program.
ifwewanttoverifycaseswheredifferentlistsareprotected bydifferentlocks weneedthiscombinationofregionanalysiswith field sensitivityandtypeinformation.
.
symbolic and relative locks we now formalize the ideas from the previous section.
the set g a product of individual partitioning domains serves as a more generalnotionofglobals.
ourfundamentalassumptionisthatthe heapanalysesaresuchthatwheneverwehavesomeabstraction ofaconcreteheap wecanconceptuallymapaconcretememory locationltoauniqueownerandalistofindexvalues own l2 g n .
while we use these indices to analyze races our value analysisisnotsensitivetoindices i.e.
wecomputeasingleabstract valuethatmustover approximatetheentireregion.
the critical change to our lockset analysis is rather the sets we trackforeachprogrampoint wenowtrack symbolic locks ms an expression of the form lock adr will thus add the expression adr to the symbolic lockset.
for an unlock of adr we must remove alllocksthatmaypossiblyaliaswith adr .
thesyntaxforaddress expressionsweconsiderisasfollows adr ajpjadr.fjadr.
wherefisafieldselectorand eisanindexexpression.
incsyntax theleft associativeinfixoperator .
isdefinedby adr.f adr!f adr.
adr notethattheprefixaddress ofoperatorhasalowerprioritythanthe postfix operators.
the above expressions are thus purely address computationswhereweapplyoffsetstoabasepointer nopointer isdereferencedduringevaluation.
example .
the following is the c translation of two example addressexpressions a .f.
.g a.f .g p.f.
.g p!f .g in the case of actual dereferences our front end introduces temporaryvariables forexample theexpression lock p!f!mtx istranslatedintothestatements t p !f lock t!mtx .
oursymboliclocksetanalysisadds t.mtxtothelocksetandrelies on our must equality analysis to track the equality t p!f.
wecanthenusethatequalitytoassociateanaccess p!f!data withthesymboliclock t.mtx however wedonotadd p!f!mtx tooursymboliclocksetbecausethisaddresshasnotaconstantoffsettoitsbasepointer p. recallthatthekeymappinginourracedetectionalgorithmwas g!2m which maps a shared variable to the set of locks always held while accessing that shared variable.
the notion of a shared variable is now expanded to these owners in g. we will againmapeachownertoasetoflocks butoursymboliclocksets mayrefertolocalvariables.
fortheglobalmappingofalwaysheld locks we interpret the locks relative to its owner.
a relative lock is an address expression just like our symbolic locks except the base pointer may be either a global variable or a designated host variable adr aj jadr.fjadr.
similarly integerexpressions e maynotrefertolocalintegervariablesbutinsteadusespecialvariables whenlockexpressionsandaccessexpressionshavematchingindices suchasinexample3.
in order to apply the privatization based race detection frameworkfrominsection3 weneedafunction relthattranslatessymboliclocksetstorelativelocksets usingpointerandintegerequality 397information.
assuming the soundness of this translation the special constants are treated as uninterpreted symbols and do not differfromconcretenames.
althoughthestructureofsharedowners x2gisopaquetous wewillrequiretheaccessfunctionprovided bythedomain jskrwtonowreturnatupleoftheform x es which containsadditionallythelistofrelevantexpressions.
wenowdiscussthemodificationstotheauxiliaryfunctionsused toconstrain .
atthetimeofanaccess wehavesymboliclocksets thatcontainreferencestothecurrentstateoflocalvariables.
these valuesdonotmakesenseglobally sothefunctiongivingustheset ofcommonlyheldlocksmustperformatranslation.
wewillagain presentdefinitionstop down usingoperationsthatwillbedefined aftertheiruse.
wefirstgivetheredefinedthemutexmapfunction foraccessedvariables mfs d 2ms !g!2mr mfs x rel es if x es 2jsk rw ?
otherwise theonlydifferencefromsection3istheuseofthetranslationfunctionrelthatperformsthetranslationfromsymbolictorelativelocksets rel d e 2ms !2mr rel es m fm 2mrj 9m2m m m g the semantic substitution operator ereplaces every subexpressione inewithrwhenever j e x. justaswithsyntactic substitutions wecanliftthisdefinitiontoapairoflistsbycomposing the individual substitutions corresponding to each element of thezippedlist intuitively we apply the semantic substitution to each element of therelativelocksandkeeponlythosewhereallreferencestolocal variableshavebeensubstituted.
notethatthisissoundaslongas ourequalityanalysisissound butwemayfailtoestablishanequality inwhichcaseouranalysiswillflagthisaccessasunprotected.
thesynchronizationfunctionwillalsohavetoconvertsymbolic locksetstorelativeonesinordertochecktheintersectionwiththe setoflocksthatarealwaysheldwhenaccessingthatsharedregion syncs g xif x es 2jsk rw andg 2prot rel i es ?otherwise withthesemodificationsinplace theconstraintsystemremainsexactlythesameasbefore.
wewillnowgivesomeintuitionaboutthe semantics of privatization in the context of relative locksets.
this isbestappreciatedbyconsideringanexampleofper elementprivatization.
example .
we will again use a simplistic integer example of aninvariantbeingtemporarilyviolatedwithinacriticalsection.
for i i i lock mtxs data invariant violated data invariant restored unlock mtxs assume five different threads execute this code.
then at a given moment eachthreadmighthaveprivatizedaspecificindexofthearray.
wenowdescribethemeaningofouranalysisresultsforsuch programs.
in order to relate the invariant based semantics using symbolic locksets with the concrete model our concretization must now be abletohandlesymboliclocksets.
first symboliclocksetsmustbe subsumedby the concrete lockset after being evaluated in the corresponding concrete state i.e.
8i2 i j uik i i. if we look back at the definition in section we must now rewrite the concretizationconditionstoallowarbitrarylocationsinsteadofthe fixednames.
mainly weneedtoadapt prot tothisnewsetting.
ourmemoryabstractionsaresuchthatconceptuallyeachconcrete memorylocationcorrespondstoapair x is 2g n .
wemust determinewhetherthesespecificindices isofregionxareprotected intheconcretestate bythesymboliclocks .
forthis wecheck whether the indices match a symbolic lockset if variables are replacedwiththeirconcretevaluesfrom .
wecanoverloadthefunction relforthis keepinginmindthatwearenowrelativizinglocks inaconcretesettingtogivemeaningtoouranalysisresults.
wethus determinewhetheralocationisprotectedusing prot rel is .
thisiseffectivelytheonlychangeneeded recallthatwecompute asingleinvariantforeachregionandonlyallowindicestobeprivatizedwithincriticalsections.
theorem3 heapsoundness .
given a heap abstraction that relates memory locations l2 l to indexed regions we have d s also for heap manipulating programs.
proofidea.
themainthreattosoundness comparedtothesimple case is to ensure that distinct locks mtx andmtx are not relativized into the same relative lock mtx when accessing the same location.
assume we have two accesses to the same region with index expressions es1andes2in states 1and holding symbolic locks m1andm2that were relativized to the same lock.
if the index expressions coincide we have jes1k jes2k .
thisequality togetherwiththefactthatrelativemutexeshavehad all their variables successfully substituted allows us to make the criticalinference 1m1 2m2 jm1k jm2k that is relative locks coincide when accessing the same location only if the corresponding concrete locks coincide.
this is essentially the only additional idea in our proofs of soundness and race freedom.
.
experimental evaluation ourbenchmarksuiteconsistsof26devicedrivers allcharacterdevicedriversofthe4.0versionofthelinuxkernelthatcil the front end library for goblint can digest.
the size of the programs in the suite range from to lines of physical source linesofcode sloc generatedusingdavida.wheeler s sloccount .
the performed analysis integrates value points to symbolic lockset region thread uniqueness and symbolic equality analyses asdescribedintheprevioussection.
additionally the analysiswasconfiguredtobepath andcontext sensitive to increaseprecision.
ahigh leveloverviewoftheanalysisresultsisshownintable3.
foreachanalyzeddriverwenotetheanalysistime numberofmemory locations found safe and two categories of potentially unsafe locations.
tendriverswereanalyzedinunderonesecondeach driverswereanalyzedinbetweenoneandtensecondseach andthe threeremainingdriversrequiredtentoabout75secondseach.
our statisticsisbasedonmemorylocations ratherthanaccesssitesor pairsofaccesses whichmayseemmorenaturalmeasures.
thisis 398table overview of analysis results for each driver race driver time safe indirect direct hangcheck timer.c .5s mem.c .8s dtlk.c .1s efirtc.c .8s genrtc.c .9s lp.c .1s toshiba.c .1s nvram.c .8s misc.c .5s applicom.c .3s ipmi poweroff.c .1s random.c .6s rtc.c .0s scx200 gpio.c .4s ttyprintk.c .6s apm emulation.c .2s ppdev.c .3s raw.c .9s pc8736x gpio.c .0s ipmi watchdog.c .9s hpet.c .9s tlclk.c .9s ipmi devintf.c .4s ipmi msghandler.c .0s bsr.c .0s sonypi.c .7s because our analysis framework tracks abstract values associated with each abstract memory location so even a single unprotected accessmeansthatwemaynotprivatizethatregionofmemory.
we therefore count the location as unprotected although all other accessestothatabstractlocationmaybeproperlysynchronized.
the abstract description of a memory location depends on the precise analysesuse.
wethereforereportracesusingastandardallocation site abstraction of the heap.
although the analyzer may use finer heap abstractions to distinguish accesses to different objects allocatedatthesamesite theseareallgroupedforourstatisticstomake theresultscomparablewhenenablingdifferentheapanalyses.
apotentialraceisconsidered directifitisseenasunsafebased on direct accesses i.e.
when a location is accessed directly by an expressioninthesourcecode e.g.
byanassignmenttothelocation.
anindirectrace ontheotherhand isreportedwhensafetycannot beguaranteedwhenweadditionallyconsiderindirectaccesses.
an indirectaccesscanhappenifapointertothelocationispotentially passedtoan externfunction afunctionforwhichtheanalyzer doesnothavethesourcecode.
one source of indirect accesses comes from the use of various containerdatastructures where forexample theapicallthatinserts an object into the container may theoretically access all objects in the container.
another example of indirect accesses is the private data field in the filestructure of linux.
in that use case pointers to the driver s private data are inserted into the structureandpassedaroundwithit.
thatmeansthatdataracefreedomisguaranteedonlybyconvention.
directracesreportedhereareeitherrealdataracesorfalsepositivesthatgenerallyariseduetotheuseofunsupportedprotection mechanisms additionalassumptionsontheenvironment orsimply0200400600 drivers sameorderastable3 nr.
ofracesdirectrace indirectrace safe figure distribution of direct and indirect races analysisprecisionloss.
proportionsofsafelocationsversusdirect and indirect races can be seen in fig.
.
on average of locationsarereportedasdirectraces wecountthisasasuccess.
the number would even drop to .
if the outliers random.c and ipmi msghandler.c were removed.
these two differ from restofthedriversinthebenchmarksuitineithertheirassumptions orcodecomplexity.
thefirst random.c doesnotexposemost of its non static functions outside the linux kernel.
instead most ofthefunctionsareusedwithinthekernelcodetogenerateentropy.
itseemsthatinthemajorityofthelocationswheregoblintdetects a data race the responsibility for thread safety is left to the caller.
asthecomputationofentropyisapproximateandsecurityonlyrequires lower bounds on this value it is likely that such races are benign and at worst only fail to count added entropy.
increasing precision in this case would require more domain specific informationabouttheenvironmentinwhichthefunctionsareused.
themodule ipmi msghandler.c hasahighercomplexity thanmostothercharacterdevicedrivers.
itusesadvancedpatterns thatgoblintdoesnotyetsupport e.g.
read copy update atomic readandupdateoperations andper elementlockingwherethelock hasanon constantoffsettoitsbasepointer.
lockingpatternsthat goblintcanfollowarenotadheredtoin unregister panic and initialization modes whererunninginitializationseveraltimesis avoided by a boolean flag whose safety is unclear.
in addition to that the usage of variables suggests that some of its input are assumedtobenotsharedandshouldnotbeaccessedatthesametime.
effective analysis of this driver requires more effort to handle the advancedpatternsandintegrationofinformationabouttheenvironmentitisusedin.
thenumberofindirectracesisonaveragemuchlargerthanthe numberofdirectraces.
infact onaverage47 outofalllocations areruledindirectraces.
fourteenofthe26drivershadasignificant portionofthememorylocationsescaped.
theseissueswecountas a failure of our tool in its current form but not necessarily failure oftheapproach asthesafetyofapifunctionsisnotautomatically derivable.
onesolutionwouldbemanualannotations.
next we evaluate the benefit that adding advanced features to goblinthasbrought.
table4showsdataforallmodulesthatwere affectedbyswitchingthespecificfeaturesonandoff.
outofthe26 drivers 19useonlystaticlocksandsevenadditionallyusesomerelativelockingpattern.
theadditionofsymboliclockingisabletodecreasethenumberofreportedracesinonly ipmi msghandler.c .
but additionally there are several near misses.
in lp.c the exported function lp release does not acquire the relative lock 399table contributions of features directracecountforfeatureset driver base region symb.
both apm emulation.c hpet.c ipmi devintf.c ipmi msghandler.c ppdev.c random.c lp table .port mutex contrarytothepatternestablishedbyotherfunctions thiswouldmakethreememorylocationswithdirectracessafe.
relativelocking weconclude isused in complicated drivers and needs to be supported but its analysis practicallyrequirestakingenvironmentalassumptionsintoaccount.
a slightly better situation is with dynamic lists six drivers use dynamic lists and five of them get fewer warnings when enabling regionanalysis.
butalsotheretheresultscouldbebetterifmoreenvironmentalassumptionscouldbediscoveredandusedintheanalysis.
weconcludethatflexible genericcombinationofexistinganalyses can be decently successful for analyzing data races in open programs.
toreachthislevel weneededtopaycloseattentionto precisionwhenimplementingsupportforpopularlockingpatterns.
atthispoint however thelimitingfactoristheenvironmentofthe module.
adding more and more specific features will have a minor effect if safety hinges on the convention of use of the module.
a similar observation was made by logozzo et al.
who suggestinferringassumptionsaspreconditionsandanalyzesubsequent versionsofthesoftwareunderthoseassumptions.
wewouldneed assumptionsaboutwhethercertainthreadsmayruninparallel.
.
related work wewillfocushereonautomatedstaticapproachestoracedetection.
theastre analyzer hasinrecentyearsbeenextendedto analyzeconcurrentprograms .
theconcurrencyabstractionis basedonthreadspropagating influences tootherthreads effectively thiscomputesaflow insensitiveinvariantfortheglobalstate very similar to our privatization framework and is proven sound withrespecttothereorderingofcommandsthatareallowedinweak memorymodels.
min furtherextendstheframeworktotake relationalinvariantsintoaccount.
wedidnotpropagaterelational invariantsinthispaper butthesearestraightforwardinoursetting withanexplicitglobalinvariant.
astre ensurestheabsenceofall runtime errors and also detects race conditions but it is not clear howtheydealwithdynamicallyallocatedlocks intheirformalexpositions afinitesetoflocksisassumed.
whoop isarecentracedetectiontoolthatcombinesracedetection with a precise bug detector to eliminate false alarms.
the static race detector works by instrumenting the program such that symbolic execution can generate the proof obligations needed to verify race freedom.
it does not consider dynamically allocated locks.
otherracedetectors includinglocksmith cobe and relay focus only on aliasing analyses ignoring abstraction of integer variables.
we share some similarity with these approaches.
the composition of may alias analysis is exploited in cobe to speed up pointer alias analyses by running them in a sequencefrommorecoarse grainedtomorefine grainedkahlon .
relay uses symbolic locksets for procedure summarization.
they also use the term relative locksets to summarize the effect of afunction on the set of definitely held locks that is not related our useoftheterm.
compared to state of the art race detection tools for c our approach has the following advantages.
we can handle both valuedependentsynchronizationpatternsandconsiderdynamicallyallocated locks.
in particular we handle per element locking without theneedforprogrammerannotations.
thelocksmithanalyzeruses existentialtypesforthis butreliesonprogrammerannotations .
we can also handle medium grained locking such as a linked list being protected by a list lock.
this feature is unique to goblint among all race detection tools we have tested including commercial tools.
last but certainly not least we can analyze locking schemesinvolvingarraysoflocks asmayoccurinasynchronized hashtable.
forjava naikandaiken propose conditional mustnot aliasing todealwithlockingschemesofvariouslevelsofgranularity.
the analysis of heap manipulating multi threaded programs is anactivefieldofresearchinitsownright.
mostconcurrentshape analyses algorithms e.g.
focus primarily on provingpropertiessuchasmemorysafety datastructureinvariants and linearizability for small but complex concurrent implementations of data structures.
the basic idea of our approach resembles the thread modular shape analysis of gotsman et al.
.
that analysis however relies on a priori race detection and lock set computation to enable sequential shape analysis of concurrent programs.
in contrast we jointly analyze values and establish race freedom.
more lightweight pointer analyses have also been developed that alsocombinewithintegervalues .
forstaticdevicedriververification themethodofchoiceseems tobesoftwaremodelcheckers whereslam hasmadeitsway into the windows driver framework and for linux the linux driververification ldv projecthaveextendedtheblastmodel checker withpointeranalysestoanalyzedevicedrivercode .
fromourperspective themostrelevantworkaremethodsformodel checkingconcurrentprograms butthefocussofarhas notbeenondetectingraceconditionsandsequentialconsistencyis assumed.
theldvprojectreportsondevelopingaracedetection tool on top of the cpachecker framework .
this is an extensible framework that combines model checking and static analysis featuring automatic abstract domain selection .
ideas from this paper could be integrated into that framework allowing more expensiveanalysestobeonlyusedforcomplicatedidioms.
.
conclusion we have presented the analysis framework goblint.
the concept of global invariants refined by a notion of privatization enablesustorealizereasonablypreciseyetscalableanalyzersofmultithreaded c programs.
we applied this approach to realize precise and efficient data race analyzers.
on top of a generalization of locksetanalysis dedicatedanalysesareprovidedwhichcoverspecificprogrammingidiomssuchasvalue dependentlockingorperelementlocking.
wearguethat duetotheflexibilityofthegeneral framework additionalanalysescaneasilybeprovidedtocatchfurtherlockingpatterns however inferringenvironmentalconstraints maynowbethemostpromisingwayforward.
.