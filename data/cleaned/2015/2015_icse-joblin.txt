from developer networks to verified communities a fine grained approach mitchell joblin siemens ag erlangen germanywolfgang mauerer siemens ag oth regensburg munich regensburg germanysven apel janet siegmund university of passau passau germanydirk riehle friedrich alexander university erlangen n urnberg erlangen germanyc ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.
abstract effective software engineering demands a coordinated effort.
unfortunately a comprehensive view on developer coordination is rarely available to support software engineering decisions despite the significant implications on software quality software architecture and developer productivity.
we present a fine grained verifiable and fully automated approach to capture a view on developer coordination based on commit information and source code structure mined from version control systems.
we apply methodology from network analysis and machine learning to identify developer communities automatically.
compared to previous work our approach is fine grained and identifies statistically significant communities using order statistics and a community verification technique based on graph conductance.
to demonstrate the scalability and generality of our approach we analyze ten open source projects with complex and active histories written in various programming languages.
by surveying open source developers from the ten projects we validate the authenticity of inferred community structure with respect to reality.
our results indicate that developers of open source projects form statistically significant community structures and this particular view on collaboration largely coincides with developers perceptions of real world collaboration.
i. i ntroduction software engineering is fundamentally the coordinated effort of individuals to construct a software system.
typically the complexity of a software system is managed by a divide andconquer strategy in which the system whole is decomposed into simpler sub components .
software developers are required to coordinate their efforts to manage sub component dependencies and to reconcile the software s sub components into a functional whole.
failure in the software to meet expectations is often the consequence of insufficient coordination between developers .
recent empirical research has demonstrated the significant influence of developer organization on software quality .
it even suggests that evaluation methods that are entirely based on organizational properties are more indicative of fault proneness than traditional source code centric metrics .
recently version control systems vcs have been used to construct developer networks that capture the organizational structure .
thus far the primary focus has been on characterizing the global network properties that govern all developer networks such as the small worldproperty.1the predominant method to construct developer networks assumes that all developers contributing to a common file are collaborating.
we will show that this coarse grained view results in over connecting the developer network which obscures important latent network properties such as community structure.
additionally we will challenge the current working assumption that developer networks are an accurate representation of reality.
we propose an approach to construct developer networks from a vcs with a primary focus on identifying fine grained organizational features developer network construction we propose two distinct fine grained methods that improve on the state ofthe art a by analyzing the source code structure at the function level instead of at the file level and b by analyzing the committer author relationship to identify closely collaborating developers.
developer network analysis we propose a statistically sound approach of identifying and verifying developer communities a by applying sophisticated communitydetection algorithms for detecting overlapping communities in directed and weighted graphs which have not been used before on developer networks and b by applying sound statistical methods with carefully chosen null models and community quality metrics to verify that the developer communities arise from an organized effort and not as an artifact of the method.
we have applied our method to empirically study ten opensource projects listed in table i. we chose the projects to demonstrate our methods applicability to a wide range of projects from a variety of domains written in various programming languages and ranging in size from tens of developers to thousands.
in summary we make the following contributions we define a general approach for automatically constructing developer networks based on source code structure and commit information obtained from a vcs that is applicable to a wide variety of software projects.
we study ten popular open source projects and demonstrate that the state of the art method of constructing 1the small world property is a well understood characteristic of networks where the distance between nodes grows with the logarithm of the number of nodes and it is responsible for the small world phenomenon .developer networks is unsuitable to identify fine grained organizational features while our approach is suitable.
we demonstrate that committer author information can be used to automatically construct developer networks with similar information as developer networks constructed using the manual certificate of origin reporting system for documenting the responsibility of code changes.
we present an approach to statistically evaluate the existence of developer network communities using state ofthe art machine learning algorithms and network analysis techniques suitable for directed weighted networks with overlapping communities.
we validate our approach by questioning open source developers from ten different projects and show that most developers agree that the networks accurately capture reality and the identified communities have real world meaning.
all experimental data are available at a supplementary site .
ii.
b ackground we begin with the introduction of vcss as a data source for empirical software engineering research.
then we formalize developer collaboration in terms of network structure.
a. version control systems software engineers use version control systems to coordinate their incremental contributions to a common software system.
a vcs stores the entire source code change history in the form of atomic change sets called commits which contain information about the changed lines of code and the person responsible for the change set.
through the application of data mining to vcss it is possible to glean insights about the coordination structure from the change history .
git is a popular vcs that is especially appropriate for data mining and it supports migration from many other vcss .
git also captures additional data that other vcss neglect .
for example in open source projects the author of a patch often differs from the person who commits the patch to the main development branch.
for each commit git captures distinct author and committer information.
git also supports a signoff i.e.
developer s certificate of origin convention that helps track responsibility for a patch.
a sign off tag is a selfreported reference to anyone who authored tested reviewed or committed a patch.
in section iv we show how this information is useful for studying developer collaboration.
b. network analysis the data stored in a vcs enable researchers to identify collaborative relationships between developers that arise from the software development process.
the developer relationships can be described by a network in which nodes represent developers and edges represent collaborations between developers.
a network can be formalized as a graph g v e wherev is a set of vertices and eis a set of edges denoted by v g ande g respectively.
some edge e2ewith originu2vand destination v2vis denotede fu vg.
graph edges may be undirected or directed.
in the latter case the two edges are defined by ordered pairs so that u v and v u are distinct.
weights can be assigned to edges represented by a function w e!r.
in our context the edge weight represents the strength of collaboration between two developers.
by formalizing developer relationships as a graph we can use network analysis and visualization techniques to distill the vast amount of data into practical insights.
however networks often contain a substantial amount of noise that can conceal the latent graph structures.
community detection algorithms address this problem by identifying topologically related groups of nodes.
acommunity is formally characterized by a group of nodes that are densely connected to nodes within the group and sparsely connected to all other nodes in the network .
communities are expected to naturally form as a result of commonalities that exist between members of a community e.g.
a shared responsibility to handle the development of a particular system component each community would represent a division of labor and indicate an organized effort .
unfortunately two known problems exist networks that arise from a random process can exhibit community structure and there is no guarantee that the identified communities will coincide the more abstract notions of a community developer communities in the real world which have characteristics that transcend the strictly topological domain.
for this reason identifying meaningful communities is not trivial and requires appropriate metrics for identifying and differentiating communities that result from a random process from communities that result from an organized process .
in section iii b we address this problem for community detection in developer networks.
iii.
o urapproach we now present our approach to construct developer networks and to infer and verify developer communities using statistical techniques.
all source code that implements our approach is available under the gplv2 and mit licenses on the supplementary website.
a. network construction we propose two methods for constructing developer networks each of which captures different views on developer collaboration.
function based method to construct a developer network we use a heuristic for identifying when two developers are engaged in a coordinated effort.
coordination theory has established that the demand for coordination arises from inter dependencies between the tasks carried out by a set of individuals .
therefore the validity of the heuristic is based on how accurately it can identify inter dependent developer tasks.
previous research relied on file based heuristic where developers were said to be coordinated when they made a contribution to a common file .
advantages of using a file based heuristic include ease of computation programming language independence and suitability for heterogeneous documents e.g.
source code and configurationfiles .
the file based approach has certainly proved useful for studying global network properties e.g.
vertex degree distribution average clustering coefficient average shortest path length however we identified specific limitations of the file based approach that hinder community detection and justify a more fine grained method see section iv .
the activity of contributing code to a common file does not always demand a coordinated effort because files often contain a multitude of different functionalities.
in our function based approach we use a more fine grained heuristic based on code structure where developers are considered to be coordinated when they contribute code to a common function block.2the rationale is that code within a function block is inter dependent as a result of accomplishing a relatively small task which is the key principle of functional and procedural abstraction and which indicates that the developers of that function are engaged in a coordinated effort.
a finer grained heuristic will invariably result in identifying a subset of the developer relationships implied by a coarser grained heuristic.
by using the functionbased approach we consciously sacrifice some edges between developers in the corresponding developer network to gain the ability to detect developer communities.
in section iv f we empirically address this trade off by testing whether the sacrificed edges are authentic with respect to capturing realworld collaboration.
in section iv d we discuss how the file based and function based heuristics perform with respect to identifying developer communities.
software development is achieved through incremental contributions where one builds on previous work to introduce or improve features or functionality through commits which are typically only a few lines of code .
we capture this notion of incremental contributions by using the commits timestamp for identifying the appropriate directions of the edges in the network.
for example developer a creates a new function without the need to collaborate closely with any other developer.
at a later point when that functionality is modified developer b must understand and adhere to the constraints imposed by the remaining contribution of developer a. thus the dependency is unidirectional developer a does not need to be aware of the contribution of developer b .
by using directed edges we enhance the graph by modeling an additional dimension of developer coordination which is utilized by the community detection algorithm to more accurately identify communities.
to support numerous programming languages with our approach we use the source code indexing tool exuberant ctags to obtain the necessary structural information.
exuberant ctags supports over programming languages and is able to process thousands of files in seconds.
it is necessarily based on heuristics for recognizing function blocks but this is not problematic for our use case as we discuss in section v .
using the author information acquired from git together with structural information provided by exuberant ctags we construct a weighted and directed developer network.
vertices 2for example the same function implemented in c or the same method or constructor implemented in javaof the network represent developers who authored the code and edges are included between two developers only when both had made a contribution to a common function block.
we assign a weight to each edge in the network to model the varying degrees of collaboration between two developers from contributing to a common software artifact.
for the function based method we formalize the edge weight between developersd1andd2collaborating on function fas !d1 d2 f nx i 1ix j 1jslocd1 i f j jslocd2 j f j where slocd1 i f is the set of source lines of code added or modified neglecting white space additions by developer d1to function fin commiti.
the commits are sorted in time increasing order so that a collaboration is only assigned between developer d1and developers who made a previous commit.
equation defines the collaboration between developers as a function of both temporal location and amount of contributed code made through successive changes.
the nested summation captures the consecutive nature of one commit building upon the development work of all previous commits.
the inner summation captures the collaboration weight between a single commit and all prior commits to that function.
the outer summation then sums over all commits relevant to f. equation considers directionality of edges therefore!d1 d2 f !d2 d1 f in general.
finally the total weight between d1andd2is wd1 d2 x f2fwd1 d2 f wherefis the set of all functions.
committer author based method our second method is inspired by earlier work that used sign off tags on commit messages to build developer networks .
in this method tags are used to identify relationships between all people that contributed to a common commit including authors reviewers and testers.
a tag based network contains important information about the software development process workflow and developers with related interests and knowledge .
signoff tags are self reported