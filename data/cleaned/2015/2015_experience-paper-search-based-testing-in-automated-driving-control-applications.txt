experience paper search based testing in automated driving control applications christoph gladisch thomas heinz christian heinzemann jens oehlerking anne von vietinghoff tim pfitzer robert bosch gmbh corporate research renningen germany robert bosch automotive steering gmbh schw abisch gm und germany firstname.lastname de.bosch.com anne.vonvietinghoff de.bosch.com abstract automated test generation and evaluation in simulation environments is a key technology for verification of automated driving ad applications.
search based testing sbt is an approach for automated test generation that leverages optimization to efficiently generate interesting concrete tests from abstract test descriptions.
in this experience paper we report on our observations after successfully applying sbt to ad control applications in several use cases with different characteristics.
based on our experiences we derive a number of lessons learned that we consider important for the adoption of sbt methods and tools in industrial settings.
the key lesson is that sbt finds relevant errors and provides valuable feedback to the developers but requires tool support for writing specifications.
index t erms search based testing automated driving automated test generation experience paper i. i ntroduction automated driving ad applications aim at taking the driving responsibility from the human driver .
as a consequence these systems have high safety and performance demands meaning that they must not pose a safety threat to their environment and that they should not obstruct the surrounding traffic.
both of these issues demand thorough testing of the ad software under a variety of traffic scenarios.
to this end virtualized software testing in simulated worlds is a key technology to achieve fast feedback during development and to support safety arguments for the systems .
the complexity of the simulated environment and the number of scenarios to be tested necessitate the use of automated test generation and evaluation techniques.
typically ad applications have functional blocks that conceptually follow a sense plan act architecture as illustrated in figure 1a.1in this architecture the sensors provide raw information from the physical environment e.g.
based on cameras lidars and inertia sensors.
the sense component translates this information into a model of the vehicle s environment.
the plan component decides on a maneuver to be taken given the current environment e.g.
stay in lane or change lane which is then realized by the actcomponent.
the actcomponent typically contains several cascaded feedbackcontrol algorithms that control the vehicle s actuators and close the loop to the physical environment .
1please note that real architectures are much more complex but always contain the basic elements of sense plan and act.testing an ad application monolithically is infeasible because of the high dimensionality of the test space.
therefore testing demands a careful decomposition of the testing problem into smaller test problems that can be addressed individually.
in this paper we are concerned with testing the actcomponent of the ad application which results in the simulation setup shown in figure 1b.
to obtain this setup we assume the following decomposition on the ad application.
we separate testing of the sense component from testing the plan and act .
to this end we use ground truth from the simulator as a replacement for the sense component.
we further decompose the behavior of the plan component into equivalence classes on the planner s decisions where each equivalence class is represented by a so called logical scenario in which the same behavior is expected by the actcomponent i.e.
by the software under test.
an example for a logical scenario could be following a preceding vehicle in its lane on a highway with lanes with a low speed vehicle cutting into the ad vehicle s lane.
for testing the correct behavior of the actcomponent the logical scenarios must be instantiated into concrete scenarios in a particular simulation framework.
thus each concrete scenario results in one closed loop simulation run test in the simulation framework.
executing the simulation for the given concrete scenario particularly requires to stimulate the software and its surrounding system under test with concrete values for the different parameters of the logical scenario.
in our example above this includes parameters like vehicle speeds initial distances between vehicles the timing of a cutin or the gradient of the road.
due to their physical nature these parameters are real valued thus rendering the resulting test space infinitely large.
in this paper we are concerned with the question of how to efficiently generate concrete scenarios from a given logical scenario.
instead of using random testing or fixed gridding of the parameters of the logical parameters we use search based testing.
search based testing sbt is a method for automated test generation based on optimization using metaheuristics.
the basic idea of sbt is using a quantitative metric a fitness function that describes how well a requirement is satisfied and employing an optimizer that utilizes this metric to automatically generate interesting tests for the software under test.
the optimizer tries to find parameter valuations 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sense softwareplan act sensors physical environmentactuators a high level architecture of a system for automated drivingsoftware under test equivalence class of plan environment model scenario physics system under testactground truth b simulation setup for actcomponent fig.
system architecture and simulation setup that minimize the quantitative metric which in turn is a worst case for the system under test.
we use an instance of sbt that particularly supports continuous parameter spaces by using optimization algorithms such as bayesian optimization .
in this experience paper we report our observations of applying sbt in the context of ad applications for generating concrete scenarios from logical scenarios or in other words for testing the control aspects of an ad application cf.
section ii .
while sbt achieved impressive results in academic papers that show the usefulness of the technique it is not yet widely adopted in the automotive industry.
we discuss the application of sbt to three different logical scenarios of an ad software on a highway cf.
section iii adaptive cruise control lane keeping under adversarial environment conditions and steering control.
based on these successful applications of sbt we report our lessons learned and the impediments we faced with respect to the tool framework and specification cf.
section iv .
these lessons learned are not specific for a particular implementation but focus on the general use and criteria for acceptance of sbt as a method in the ad domain.
key results of our study are i sbt effectively finds relevant errors in ad applications ii user acceptance depends on seamless integration into existing tool chains and actionable feedback from test results and iii good support for writing and debugging specifications is essential.
ii.
s earch based testing figure shows the setup of the sbt framework.
a test task is an informal description consisting of a logical scenario and a specification cf.
sec.
i .
the specification is formalized into an executable monitor stl monitor and the logical scenario is implemented as an input signal generator.
the input signal generator system under test sut and monitor are composed into a simulation on which test are executed.
the test generation is driven by an optimizer which tries to find test inputs to sut to minimize the sut s performance w.r.t.
the specification i.e.
as computed by the stl monitors.
the output format of the optimizer is a low dimensional vector of real values in the following referred to as parameters .
the input signal generator maps these parameters onto a concrete scenario and technically interfaces the sut.system under test optimizerinput signal generator select parameter valuesstl monitors simulation derive scalar robustness from monitor signalstest tasklogical scenariospecification fig.
search based testing framework the techniques for search based testing that we used in our case studies are based on falsification tools such as breach and s taliro .
these tools allow the user to provide closed loop specifications in signal temporal logic stl or metric temporal logic mtl respectively.
these logics are an extension of linear temporal logic towards continuous time and real valued signals see for an extensive survey.
moreover they come with a robust semantics2 which is real valued instead of boolean and quantifies the degree of specification satisfaction or violation for a given signal.
falsification tools use these values to drive an optimization loop so that new tests are generated which lead to challenging tests for the system.
there is also a large body of work in sbt with handcrafted performance metrics that are not based on logics for instance focusing on the search aspect.
for our experiments we concentrate on temporal logic based techniques.
in this paper we use the boolean operators and or not and implies if then and predicates such as equality and less or equal .
temporal logic extends boolean logic with the temporal operator u and its instances square and which evaluate any formulas over 2also called quantitative semantics .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a time sequence e.g.
a signal from a simulation.
u is true iff is true at each time step until becomes true square is true iff is always true and is true iff is true at least once when evaluating .
operators with subscripts square or evaluate on a subinterval relative to the current evaluation time t. bothaandbmay be negative allowing for temporal operators that refer to both future and past relative to t. temporal operators can be arbitrarily nested with boolean operators.
under boolean semantics the predicates and boolean and temporal operators evaluate to true or false.
under robust semantics the predicates and operators evaluate to real values such that positive values indicate a degree of a formula being true and negative values indicate the degree of false .
under robust semantics the operators of stl are semantically defined as follows see llbracket latticetop rrbracket t llbracketx c rrbracket t x t c llbracket rrbracket t llbracket rrbracket t llbracket 1 2 rrbracket t m a x llbracket 1 rrbracket t llbracket 2 rrbracket t llbracket 1u 2 rrbracket t s u p t prime t a t b min llbracket 2 rrbracket t prime inf t prime prime t a t prime llbracket 1 rrbracket t prime prime llbracket 1s 2 rrbracket t s u p t prime t a t b min llbracket 2 rrbracket t prime inf t prime prime t prime t b llbracket 1 rrbracket t prime prime particularly comparison of a signal xto a bound is implemented as the difference of the signal to the bound.
for example the formula x 3is evaluated under robust semantics as the value of x t 3for all t. in addition we may define the operators latticetopu and square as usual.
as an intuition returns the maximum robustness of the subformula over the specified time interval wheras square returns the minimum.
we chose to not use any of the frameworks from academia directly but developed our own specific implementation targeted at the specific needs of ad applications.
in particular formalized functional specifications are not currently the state of the art in the automotive industry which means that such a framework must provide means to debug specifications and also specification patterns for the common cases.
furthermore tool chains for software development and simulation are already highly complex such that it is imperative to create as little tool overhead as possible.
to best adapt our implementation to the needs of the automotive industry we made the following initial design decisions we implemented temporal logic monitors as online filters that run alongside the simulation.
this was driven by the assumption that specifications are usually of the form square where is a potentially complex temporal formula.
in order to make formula and system debugging easier we chose to implement and all its subformulas asonline filters so that the resulting robustness signals can be examined.
the top level square operator is then dealt with by simply taking the minimum robustness over all times.
the result is a framework that is similar in spirit to streaming languages .
also this approach enables early termination of often costly simulations and the on the fly creation of test inputs.
we kept the implementation independent of the simulation tool by building a c library with the core algorithms than can be interfaced from different tools.
we did not restrict the framework to temporal logic operators to leave the possibility open for custom operators whenever needed.
for the tools we used we created a tight tool integration.
for example for matlab the filters are included in simulink via s functions.
we did not build our own optimizers but used off the shelf optimizers provided by matlab e.g.
bayesian optimization to allow for customization to the specific sbt problem at hand.
iii.
i ndustrial case studies in this section we describe three selected case studies in an industrial ad setting adaptive cruise control acc section iii a lane keeping section iii b and steering control section iii c .
these case studies were done in cooperation with different development teams from different business units with diverse mindsets and engineering cultures.
a. adaptive cruise control scenario description the first case study is an adaptive cruise controller acc for highway situations.
this controller is active when the planner decides to stay in the current lane potentially following a vehicle ahead.
the overall task is to keep a safe distance to other vehicles whenever possible.
this includes so called cut ins i.e.
lane changes of other vehicles in front of the ego vehicle which can occur at potentially unsafe distances.
if there are no other vehicles in front then a set speed should be respected which may be a combination of passenger input via a human machine interface speed limit information from the perception etc.
therefore the goal of the controller is to either acc1 respect a velocity dependent distance to the preceding vehicle in the same lane acc2 respect a set speed in absence of a preceding vehicle or when it is far away the specification of this system is primarily defined on physical quantities such as velocity and position necessitating a closed loop test.
therefore the test setup includes not only the controller itself but also a physical simulation of the ego vehicle and relevant other vehicles in this case using the commercial tool ipg carmaker .
the acc software that we used was in an early stage of development and therefore we expected to find some specification violations using this method.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
test setup in general there are specifications for the modes of operation acc1 and acc2 as well as transitions in between.
each of these corresponds to a number of different logical scenarios to be tested with sbt.
in the following we explain three specific logical scenarios for the acc functionality which represent different traffic configurations.
each configuration maps to a specific sbt problem.
all scenarios have in common that the real valued test parameters are situated in the physical environment instead of varying input into the system under test directly we vary parameters in the simulation of the physical environment to create a range of situations the system under test should react to and then monitor the closed loop response.
the input signal generator for this case study maps these parameters onto a signal description file for ipg carmaker.
specification the first logical scenario involves a specification for a transition from acc2 to acc1 where the ego vehicle either approaches another vehicle or a cut in by another vehicle occurs while the ego vehicle is in set speed control.
we assume that there are no other vehicles in this scenario.
two parameters are varied for this logical scenario the initial velocities of the two vehicles.
the initial distance is set to a fixed large amount.
the preceding vehicle is assumed to have constant velocity.
in natural language the specification can be expressed as follows whenever we detect another vehicle in front of us and this vehicle has been the preceding vehicle for at least t seconds we expect the distance dto this vehicle to stay within a corridor of epsilon1around the desired distance ddes.
the desired distance ddesis computed relative to the velocity of the ego vehicle as faster speeds require larger safety corridors.
the formalization of the specification in stl is as follows square vehicledetected newvehicle d ddes v epsilon1 here vehicledetected is a boolean flag signifying whether there is a vehicle in front of and in the same lane as the ego vehicle within sensor range.
newvehicle is an event that indicates whether there is a new vehicle in front of the ego vehicle either because there was a cut in or because the ego approached a vehicle from behind that was outside sensor range.
the distance to the preceding vehicle is denoted by d if there is none and ddes v is the velocity dependent desired distance.
in the simulation the event newvehicle is triggered if there is a negative jump on the distance to the preceding vehicle from one sample to the next newvehicle t d tprev d t .
inside the outer box operator the specification only uses past time stl i.e.
all temporal operators only refer to time intervals that lie in the past .
this subformula can be monitored online using robust semantics.
the value of the entire specification i.e.
the box operator applied to the past time formula is the minimum of the monitor signal evaluating the past time formula.
this yields the scalar robustness value forthe entire formula which is then used by an optimizer to select a new test aiming at minimizing this value.
however in contrast to the past time formula above the informal textual requirements that already exist in practice in tools such as doors are often in future form whenever we detect another vehicle in front of us the distancedto this vehicle shall reach a corridor of epsilon1around the desired distance ddes withintseconds and shall remain within this corridor .
one way to make these monitorable online is to select a fixed future lookahead s. this way the formula can be monitored online with a delay of s. one realization of such a formula would be square newvehicle square vehicledetected square d ddes v epsilon1 this formula is not equivalent to the past time formula above because it requires vehicledetected to stay true for the entires interval.
this is to point out that there are generally different formalizations of existing informal requirements that reflect its intention.
one lesson learned while conducting these experiments was that specifications using combined past and future time temporal logic are generally easier to understand and to write correctly for engineers.
while the formula above is not particularly complex in past form this is not true for many other formulas.
we will give some more examples of this later in this section and also discuss future versus past operators in section iv g. test results figure shows the test results for the case when the ego vehicle drives up to the preceding vehicle.
a total tests were generated for this logical scenario using the robust semantics of the past time formula given above and a bayesian optimizer with each single test taking roughly minutes.
it should be noted that the evaluation times for the online monitors added less than seconds to the simulation time.
the time used for generating the gaussian regression model for the bayesian optimizer was negligible compared to the simulation time.
the two dimensional test space was sampled using optimization with the goal of minimizing the robustness of the temporal logic formula defined above.
the x axis is the initial velocity of the ego vehicle the y axis is the constant velocity of the preceding vehicle and the z axis is the robustness value with negative values signifying failed tests.
in order to avoid interpolation artifacts the plot uses v oronoi interpolation i.e.
each plateau represents a single test and consists of all points for which no other test exists that is closer in euclidean distance.
for the part of the input space where the ego vehicle is slower than the preceding vehicle no tests are generated.
in this case the distance between the two vehicles increases and thus the preceding vehicle would never be detected.
the failed tests were caused by a problem in the trajectory planning algorithm that resulted in a too slow convergence to the desired distance.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
lqlwldo yhorflw hjr yhklfohpd yhorflw suhfhglqj yhklfoh plqpd 5rexvwqhvv plq plqpd fig.
test results for transition from speed control to distance control of adaptive cruise control specification as can be seen even in such a simple test setup the robustness surface not monotonic or convex and the worst case can not be found by simple boundary value testing.
further experiments in other setups for the specifications that follow also confirm this.
some of the issues encountered are hidden switches for different discrete modes of operation.
these could be fixed by separating them into separate scenarios with different specifications.
in addition we also found controller errors that only occurred in small areas of the parameter space.
as the system under test was in an early stage of development this is not surprising.
in fact the quantitative robustness was confirmed to be more valuable than simple pass fail information by engineers since the physical model is not a perfect model of reality and since the choice of control parameters for the system under test was not final.
specification one specification that we tested for case acc2 set speed control without a preceding vehicle is given in the following.
it describes the reaction to a change in preferred set speed by the passenger using controls inside the cabin or the recognized speed limit signs whenever the set speed vsetis increased the actual velocity vshall have passed percent of the jump height jump vsetafter tseconds and analogously for decreases in set speed.
to formalize this we need to save the jump height vsetof the last jump as jump vsetin order to refer to it at a later time.
the stl formula is square vset vset v .1 jump vset square vset vset v .1 jump vset note that this also is a future time specification and it would be rather cumbersome to formalize it as a past time formula.
specification another scenario of importance is the cut in while we are already following another vehicle.
this scenario involves three vehicles the ego vehicle the vehicle that the ego originally followed and the vehicle performing the cut in see figure for an illustration whenever we detect another vehicle in front of us we shall respect a velocity dependent safe minimum distance dsafe v as long as the cut in was far enough away to allow this.
d d min cutin fig.
cut in while following another vehicle we chose the following future time stl formula square newvehicle square vehicledetected d d min cutin v square d dsafe v if the cut in is very close to the ego vehicle closer than dmin cutin v the precondition of this specification is not met as the ego cannot decelerate fast enough to avoid a distance violation.
this would then be an unavoidable accident where instead of acc the system would switch to a function that minimizes the collision impact with its own set of specifications.
while the complexity of this specification is still limited the difficulty in this scenario lies in the fact that we now have to orchestrate three vehicles to drive in a prescribed manner.
in particular we need to parameterize the relative position and velocity of the cut in vehicle when changing lanes.
this requires complex scenario setups with synchronization of the behavior of the simulated agents.
in fact here the specification can be seen as including an idealized dynamical model of the ego vehicle s braking capabilities.
on an abstract level the intention behind the specifications is something along the lines of if it is physically possible to obey the safe distance then i should do it with the braking capabilities of the ego vehicle being encoded in a velocity dependent threshold dmin cutin v .
the underlying more general pattern is that ad specifications often contain predicted states of the world.
in other words we could also write d d min cutin v in a more general form as t dpred t wheredpred t is the predicted distance wrt.
some predictive model of the vehicles at time tin the future.
this is a common pattern in ad applications which is reflected in the use of quantities such as time to collision time to brake etc.
in the specifications.
b. lane keeping scenario description this case study deals with an automated vehicle s ability of staying within a lane in challenging conditions by steering and or braking.
in particular we consider longitudinal and lateral road slopes wind and the curvature of the road which in combination might result in a vehicle to leaving its designated driving lane.
test setup simulation setup and interface of the system under test with its environment are identical to the adaptive cruise control case.
however for the scenario considered here authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
there is no preceding vehicle.
instead road parameters are varied in particular curvature and slope both in longitudinal and lateral direction as well as angle and velocity of a constant wind affecting the vehicle the distribution of the vehicle s mass and the set velocity of the vehicle resulting in a six dimensional test space.
the road is modeled as a straight segment followed by a curve with constant curvature to the left .
specification informally the requirement is the vehicle shall stay within the lane boundaries if this is possible with the actuators it is equipped with.
formally the specification is square max vehicle corridor where is the current lateral wheel torque and max is the maximum lateral wheel torque the vehicle is capable of delivering.
the larger the lateral wheel torque the tighter is the resulting curve driven by the vehicle i.e.
the maximum lateral wheel torque available determines the tightest drivable curve.
determining whether the vehicle is inside the corridor is a geometric operation that computes whether the vehicle s bounding box is completely enclosed in the lane which is described by polynomial constraints.
according to this specification it is only allowed to leave the corridor if the maximum lateral wheel torque is applied i.e.
if the vehicle physically has no chance of staying in the lane.
for the robustness computation this necessitates distance computation between the road boundary and the vehicle bounding box.
in case there is no physical possibility to stay in the lane e.g.
due to extreme winds a mitigation function is activated with a separate set of requirements.
test results again the results are obtained by employing robust semantics of stl and bayesian optimization on the sixdimensional test space .
we ran tests with each test taking roughly minutes due to the high fidelity simulation of the car physics.
figure shows a scatter plot of the test results projected to three dimensions longitudinal gradient wind velocity and ego vehicle set velocity.
red triangles signify failed tests and green circles successful tests.
the distribution of failed tests shows two clusters one at a low velocity range and one at a high velocity range.
the first cluster of failed tests is caused by a switching behavior of the system under test.
it turned itself off as the vehicle was too slow i.e.
the design domain of the lane keeping function is left.
this illustrates an important point for these kinds of test setups failed tests mean that there is a mismatch between specification and closed loop model.
failed tests can either be caused by the actual software under test the environment model or the specification.
in case of lane keeping low speeds should be excluded in the specification as these are covered by a different software function with its own set of specifications.
the second cluster represents a set of tests where it is not physically possible to stay in the lane but nevertheless the ego vehicle did not apply maximum wheel torque.
this can either be framed as a problem of the system under test or the specification because it may be impossible tomaxmin min grade in velocity in km hwindvelocity in km hmax min max fig.
test results for lane keeping function specification achieve this theoretical maximum braking torque under some conditions .
c. steering control scenario description the third case study is concerned with a low level controller of the steering system.
the goal of the controller is to track the desired position of the steering rack which essentially defines the orientation of the front wheels with respect to the vehicle chassis.
it does so by computing a motor torque output signal that is applied to an electric motor in order to move the rack to the desired rack position.
the actual rack position and its time derivative the rack speed are fed back into the controller.
figure depicts the test setup for the steering controller.
plant model vehicle model steering mechanics admissible rack position corridor motor torque desired rack positionsteering controllerrack position rack speed lower bound for rack position upper bound for rack position monitor monitor 2rack position monitorssystem under test fig.
test setup for steering controller specification the specification that the implementation must adhere to is a typical example for a tracking controller f or any desired rack position trajectory rdes t such that the desired rack position remains within rmax and the desired rack speed vdes t remains within vmax the actual rack position r t shall remain within a corridor around the desired rack position rdes t .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in temporal logic this specification can be expressed as follows square rdes t rmax vdes t vmax square rl t r t r t ru t test setup to obtain a tractable sbt problem families of signal forms are assumed that can be characterized by few parameters.
one particular choice is the following rdes t p1sin parenleftbiggp2 p1 t parenrightbigg .
the desired rack speed vdes t equals the time derivate of the desired rack position rdes t .
it follows to vdes t drdes t dt p2cos parenleftbiggp2 p1 t parenrightbigg .
this renders p1 the amplitude of the desired rack position and p2 the amplitude of the desired rack speed.
thus the limitations on the desired rack position and its time derivative can be expressed as a constraint on the parameters p1and p2.
therefore the precondition of specification can be satisfied constructively by generating only feasible input signals.
as a consequence only the postcondition square rl t r t r t ru t has to be monitored.
figure depicts two postcondition monitor signals where monitor represents the lower bound constraint rl t r t and monitor the upper bound constraint r t ru t .
alternatively the postcondition can be expressed as a conjunction of monitor and monitor .
test results the controller was tested in an early development phase.
it was well known that the specification is not satisfied for all feasible parameter values.
thus rather than a single failed test it was of interest to obtain an overview of the degree of specification satisfaction for the entire parameter space.
in particular regions where specification satisfaction changes abruptly shall be identified.
again the results are obtained by employing robust semantics of stl and bayesian optimization on the two dimensional test space.
we ran tests.
a single simulation of the system under test took approximately seconds.
the overall optimization took hours and minutes i.e.
for this case study the main execution time was consumed by the bayesian optimizer.
due to the short simulation time for the system under test a swarm based optimization algorithm would also have been a meaningful choice.
figure shows a v oronoi plot of the test results for monitor .
as for the first case study iii a the two dimensional test space was sampled by minimizing the robustness of the specification.
the x axis depicts the amplitude of the desired rack position parameter p1in eq.
the y axis represents the amplitude of the desired rack speed parameter p2in eq.
and the z axis shows the robustness value where negative values are depicted in red and indicate specification violations.
as the robustness decreases the degree of violation plq5repd 5re 5rexvwqhvv plq6shhg pd 6shhgudfn6shhg psolwxghplq3rv pd 3rvudfn3rv psolwxgh fig.
test results for steering controller specification upper bound constraint 3d v oronoi plot pd 6shhg udfn6shhg psolwxgh plq6shhg udfn3rv psolwxghplq3rv pd 3rv fig.
test results for steering controller specification upper bound constraint 2d scatter plot grows.
figure shows a two dimensional scatter plot of the same tests.
each test result is depicted as a point.
again the color indicates the degree of satisfaction green circles or violation red triangles of the specification.
both plots provide some indication that specification satisfaction mostly depends on the amplitude of the desired rack speed.
moreover the degree of violation absolute value of the negative robustness significantly increases in a small range of desired rack position amplitudes.
iv .
d iscussion in the following we discuss our lessons learned from the three successful applications of sbt discussed in section iii and in particular the impediments for applying sbt in the industrial setting.
our lessons learned fall in two categories lessons with respect to an sbt framework subsection iv a to iv d and lessons regarding creation of formal specifications subsections iv e to iv h .
when it comes to formal authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
specification and their implementation in monitors issues and lessons are often subtle and therefore need to be discussed in more technical detail.
a. sbt works in practice the most important lesson we learned is that sbt actually works well in the industrial setting for control systems and specifications i.e.
sbt actually finds relevant errors in these kinds of systems.
in general we found three kinds of errors as discussed in section iii b .
first we found errors in the software under test which are the ones we are actually looking for.
results for the use cases we analyzed are provided in section iii.
second we found errors in the models of the physical environment that are used for simulation.
these errors often relate to physical effects that the software is sensitive to but that were not correctly implemented in the physics models.
third we found errors in the specifications where the requirement did not specify what was intended.
we discuss this point in more detail in section iv g. in general the ability of finding errors and the possibility of visualizing the test results in 2d and 3d plots which provide useful information beyond pass fail results that also gives hints on the cause of the error.
this lead to high acceptance of the method for engineers.
in general the black box optimizers used in sbt do not scale to arbitrary dimensionality of the input space.
here the second most important lesson we learned is that in all the use cases we saw to date we were able to scale sbt to the size of the problem.
from the case studies reported in section iii the lane keeping had the largest input space with inputs.
apart from these we also ran sbt problems not reported in this paper with up to 9d input spaces that could be handled without issues.
making it scale for the general ad use case however requires a proper decomposition of the overall testing problem into appropriately sized logical scenarios.
lesson consider an iterative approach by analyzing the tests created so far in order to identify and remove parameters from the input space that the software under test is not sensitive to.
b. bring sbt to the users all the case studies reported in section iii involved matlab either as a development or simulation tool.
this is not a coincidence but a result from integrating our implementation into matlab simulink cf.
section ii .
in other settings e.g.
pure c and python based test environments based on ros the matlab based sbt tooling is perceived as yet another tool with low acceptance.
as a consequence our sbt tooling was not used in these settings due to a lack of tool integration.
in order to overcome such problems the sbt tooling requires multiple front ends for integrating seamlessly into the workflows and the tooling of the users.
in particular since it turned out that sbt has a strong benefit when used in early development phases this is the case for all three case studies integration into the development environment turned out to be crucial so that sbt can be used alongside the development with minimal overhead.this motivated our custom implementation and design.
in particular our framework has a core c library which can be customized with front ends that are based on dataflow semantics e.g.
matlab simulink and front ends for programming languages in form of language bindings via apis e.g.
for c or python.
lesson seamless integration into existing tools and workflows is essential for acceptance among users.
c. robustness landscapes look like mountain ranges the results presented in section iii show that the robustness landscapes for our applications are non convex and potentially non smooth due to switches in the software under test which we expected.
in particular they contain a number of local minima and in some cases also plateaus.
in such cases local optimization approaches like hill climbing get either frequently stuck or degenerate to random walks on the plateau .
instead global optimization algorithms like bayesian optimization yielded much better results in our use cases.
in early phases of the development the landscape as such is more interesting for the developer as the actual minimum as it is the case for the acc use case.
in these phases the models are often only rough approximations of reality and information from the landscapes gives helpful insights to the users.
plotting such landscapes however is a problem on its own for input spaces with more than three parameters as they can t be plotted entirely.
instead we have to plot projections to 2d or 3d with the difficulty that multiple x d samples may get projected to the same 2d or 3d point in the plot.
to this end explicit support for such projections was highly appreciated by the users.
for the optimization algorithms this means that there should be a way to controlling the tradeoff between quickly finding failing tests and covering the test space leading to hybrid objective functions as those described in which again makes bayesian optimization a good candidate.
swarm based optimizers could also be used but seemed less promising for many systems due to the high computational cost of a single simulation.
lesson global optimization is essential due to nonconvex landscapes.
see also .
lesson support 2d and 3d projections of higher dimensional robustness landscapes for inspection of the test results.
lesson visualization of projected robustness landscapes is an important asset.
d. simulation is costly the simulations for the acc and lane keeping scenarios are costly as they involve multiple tools matlab simulink ipg carmaker and complex vehicle simulation models in a co simulation.
as a result simulation runs with real time factors down to i.e.
minute of simulation time takes minutes to simulate.
as a consequence we had better experience with approaches like bayesian optimization that require only few simulation runs compared to other approaches authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
like genetic algorithms.
evaluation of more than one specification on a single simulation run is also important even though typically only one at a time can be used for optimization.
the high simulation times also imply that the performance of monitoring is not the most important concern but for acceptance it is mandatory that monitoring must not slow down the simulation.
in our case we were able to scale the monitoring for the formulas we presented such that it had no impact on simulation time up to simulation samples in formula scope .
furthermore it is desirable to support early termination of the simulation.
in particular we may terminate the simulation in case the final robustness value of the specification can no longer change during the remainder of the simulation.
whether this is the case however depends on the scenario being used and the specifications being checked.
as an example consider property for the acc use case.
if the scenario involves only one change of the set speed then the final robustness is determined once the of the jump height have been reached and the simulation can be terminated.
depending on the set bound on the simulation time this might significantly increase performance.
lesson support sample efficient optimizers as computation resources are always limited.
for high fidelity simulations with long simulation times bayesian optimization worked fairly well.
lesson consider parallelization of sbt from the start see for example .
lesson performance is not the most important concern for the monitoring compared to e.g.
usability but make sure that it does not slow down simulation.
lesson enable the initialization of bayesian optimization problems from a set of existing test runs.
e. temporal logics are not enough we started in our applications by favoring stl based specifications for defining the metrics for sbt as it is also available in s taliro and breach.
while temporal logics such as stl are highly suitable for many kinds of specifications there exists a non negligible set of sub specifications that cannot be expressed in temporal logic or where using a temporal logic is overly complicated.
in the steering control use case the specification demands that the actual rack position remains in a corridor around the desired rack position.
the upper and lower bound that define the corridor can be expressed as outputs of a dynamical system that takes the desired rack position as input.
this cannot be expressed by an stl formula i.e.
it is not possible to express the postcondition in stl using only the desired and actual rack position as signals.
however when calculating the upper and lower bound signals in the model as shown in figure the stl specification is simple.
in the acc use case we face a t90 property cf.
property which is quite common for these kinds of systems.
for such a property we require a so called step detector that detects an instant change in a signal s value resulting from adiscrete event.
in our example the event is a new set speed being provided.
apart from detecting the step we also need to store the step height i.e.
the difference of the value before and after the jump.
without storing the step height we wouldn t be able to evaluate whether of the jump height have been eventually reached until the deadline t. storing the jump height requires a memory element which is usually realized as a freeze operator in extensions of stl like stl .
however these extensions are quite complicated to apply in their full form as most users are no trained experts in formal logics.
in addition we observed that a full freeze operator implementation was not necessary in any of the use cases we have observed in industrial practice to date.
instead we realized a simplified freeze operator that takes a condition and a value and always returns the value from the last point in time where the condition was satisfied.
while this does not give us the full expressive power of the freeze operator from stl we found this to be sufficient for the use cases we encountered.
a second observation from the aforementioned t90 property is that a form of time robustness is necessary.
the stl formulas and plots in section iii are all based on so called space robustness as defined through the robust semantics in equations i.e.
for the atomic propositions of the logic we compare signals to bounds at each point in time tand calculate robustness values as the distance of the signal to the bound.
this means that signal values at different times tcan not be related to each other when computing the robustness.
instead time robustness measures for each tand each corresponding space robust or signal value how much later this value is reached.
as an example consider the plot in fig.
.
the property checks whether x 3at some point in time between the current point in time tandt .
under space robustness given by standard robust semantics this formula resolves to max t x t i.e.
the distance of xto the bound.
under time robustness one would be interested in min t t x t i.e.
how much earlier or later compared to the time bound the subformula becomes true.
such an interpretation however introduces a different kind of semantics of operators and formulas see for example .
this in turn has a negative impact on the understandability of the specifications by non experts in temporal logics.
in our examples of t90 properties the engineers are usually only interested in how much early or late the controller reaches of the step height.
more generally phrased the engineers are often only interested in the temporal difference of two discrete events.
this is a special case of a general time robustness that can be understood and implemented much easier.
based on this observation we implemented this special case with a custom operator in our framework.
with this approach time is treated as yet another physical quantity and the resulting robustness values seamlessly integrate with the remaining stl operators.
lesson allow user defined non stl operators.
this includes custom signal preprocessing operators like a simple freeze outside the logic to allow for flexibility.
lesson include time robustness in a simplified form authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1x t1234 .
.
f x time robustness space robustness fig.
illustration of space robustness vs. time robustness supporting exactly the use cases you have.
the main use case for time robustness is the time distance between two events.
f .
simple specifications are often possible the specifications that we provided in section iii are quite simple in terms of the number of temporal operators being used per specification and the nesting depth of temporal operators being less or equal to .
this is not for sake of simplification but representative for the complexity of industrial requirements that we have faced so far in the automotive domain.
many specifications only have a very simple temporal component like property or can be brought into such a form as property by an appropriate input generation cf.
also section iv h .
such invariant properties are quite common in the ad domain especially for spatial properties like staying in a corridor e.g.
the lane in the lane keeping use case or keeping a minimum safety distance to all other objects i.e.
no other car or pedestrian must be hit by the ad vehicle.
a second kind of requirements that we have frequently seen has the form square precondition postcondition .
here the precondition detects a particular event and the postcondition defines the desired temporal response of the software under test.
a frequently recurring subset of specifications in this category is given by the classical step response properties.
in such specifications the precondition typically detects a jump of a value e.g.
the provision of a new set speed or the instantaneous reduction of the distance to the preceding car resulting from a cut in cf.
properties and .
as postconditions engineers frequently check for t90 requirements cf.
section iv e and property settling time requirements i.e.
the controlled quantity only deviates from the desired value by a constant bound after a deadline or bounded overshoots i.e.
the controlled value does not exceed the desired value by more than a defined margin .
since these kinds of specification frequently occur the framework should ease the task of writing specifications by providing a pattern library with the most frequent preconditions and postconditions.
we found that more complicated requirements can often be decomposed and expressed by multiple simpler monitors.in these cases each of the simpler monitors typically turns out to be invariants and or the precondition postcondition style specifications discussed in the previous paragraph.
as an example consider property .
an exception are specifications that include a predictive part as mentioned at the end of section iii a e.g.
demanding that the vehicle has to master a situation e.g.
the cut in in figure if it is physically possible to do so.
such properties are important to distinguish errors in the system from impossible situations automatically3.
however such parts of a specification are also not expressed in terms of temporal logic cf.
section iv e but require dedicated physical vehicle models.
lesson provide support for pattern libraries and treat patterns as first level modeling entities in the framework.
this includes support for recurring domain specific parts of specifications and or the signal preprocessing e.g.
calculation of distances w.r.t.
lanes from positions .
g. f ormal specifications even simple ones are difficult to write at first glance this seems to be a contradiction to the previous statement that real specifications have simple structure.
however that real specifications do not have a complex structure unfortunately does not imply that they are easy to write.
in general temporal logic specifications are hard to write from scratch even for experienced developers and experts in formal logics .
as a consequence it is necessary to debug specifications in order to see whether the result of the evaluation matches the intent of the developer.
this requires access to intermediate results of all subformulas and the signal preprocessing steps e.g.
the step detection or corridor computation .
such a debugging facility is also of great use when inspecting failing test runs for identifying the root cause of the error.
as already discussed in section iii a the textual requirements that need to be formalized for sbt often have a future form.
even though we have no empirical evidence it is easier for users to write down requirements in the form if event a happens the system shall react as follows and reach condition y after time t. to ease formalization of the textual requirements and to improve understandability it is necessary to allow both causal and acausal temporal formulas.
causal formulas only refer to values in the past whereas acausal formulas also refer to values in the future.
the downside of using future formulas however is that online monitoring gets much more complicated as the truth value at time tcan only be computed at time t tand all intermediate values need to be buffered.
in addition we are required to explicitly define the upper bound tfor each formula which was however not a problem in practice.
for the understandability the unisono feedback from the developers was that the robust semantics for stl must be consistent with the boolean interpretation of the formula for 3in fact mitigation requirements have to be checked for the case that collision is inevitable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
all possible cases i.e.
any robust value must map to true orfalse .
this is done by distinguishing between positive and negative values but special handling of is required in order to not create an inconsistent logic.
in particular there needs to be a way to distinguish strict and non strict inequalities such that any possible robustness value including has a defined boolean interpretation .
a frequent problem that we observed with the precondition postcondition style specifications results from interpreting the precondition under robust semantics.
this may lead to the circumstance that the optimizer finds that the minimum robustness for the entire formula can be achieved by satisfying the precondition as much as possible without considering the postcondition.
this however is obviously not useful as we are particularly interested in the value of the postcondition.
this can be solved by interpreting the precondition under boolean semantics.
lesson provide a modular evaluation approach with visible intermediate evaluations.
this demands a semantically sound compositional construction and execution of specifications and corresponding monitors.
lesson support the possibility to specify acausal formulas with time windows referring to future values.
lesson allow boolean interpretation of subformulas especially for preconditions.
lesson ensure consistency with boolean semantics for all possible cases.
h. test setup affects specification and search space as depicted in figure the specification depends on the input signal output of the input signal generator and the output signal of the system under test.
in some cases e.g.
for the steering control use case the precondition depends only on the input signal which makes it possible to constructively satisfy the precondition by designing a suitable input signal generator.
thus the precondition does not need to be monitored.
even if the precondition depends on the output designing a suitable input signal generator may simplify the monitor significantly.
another design goal of the input signal generator is to restrict the search space to render the optimization problem tractable.
a potential downside is that relevant behavior is not considered.
sometimes it is not clear how to select parameterized families of input signals.
in such cases a viable alternative is to search over arbitrary input signals .
lesson restricting the input space may lead to simpler specification monitors.
lesson the input signal generator defines the search space.
there is a tradeoff between tractability of the optimization problem and restriction of the search space.
v. c onclusion in this paper we presented three selected case studies from the ad domain and evaluated the application of sbt on the cases studies.
the evaluation is based on our own sbt framework inspired by s taliro and breach.
we discuss several lessons that we learned during the case studies.
key lessonsare i that sbt works well in the industrial setting ii that provision of actionable feedback and seamless integration into the developers tools are key to acceptance of the method and iii that good support for writing and debugging specifications is essential as writing specifications is difficult.
the results of this experience report shall help researchers and practitioners to bring sbt into a widespread use in industrial practice.
in addition to the reported lessons learned future work could focus on i online signal generation for identifying challenging and arbitrarily shaped input signals for the software under test ii searching in the scenario space for automatically constructing meaningful scenarios and iii finding arguments on when to stop testing in case no falsifying runs are found .
despite promising initial works there are still many open questions particularly in the industrial setting.
acknowledgment we thank monja megger for conducting the lane keeping case study .