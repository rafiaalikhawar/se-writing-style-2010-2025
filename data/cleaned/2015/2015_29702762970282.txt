bovinspector automatic inspection and repair of buffer overflow vulnerabilities fengjuan gao state key laboratory of novel software technology nanjing university nanjing china fjgao seg.nju.edu.cnlinzhang wang state key laboratory of novel software technology nanjing university nanjing china lzwang nju.edu.cnxuandong li state key laboratory of novel software technology nanjing university nanjing china lxd nju.edu.cn abstract bu er over ow is one of the most common types of software vulnerabilities.
various static analysis and dynamic testing techniques have been proposed to detect bu er overow vulnerabilities.
with automatic tool support static bu er over ow detection technique has been widely used in academia and industry.
however it tends to report too many false positives fundamentally due to the lack of software execution information.
currently static warnings can only be validated by manual inspection which signi cantly limits the practicality of the static analysis.
in this paper we present bovinspector a tool framework for automatic static bu er over ow warnings inspection and validated bugs repair.
given the program source code and static bu er over ow vulnerability warnings bovinspector rst performs warning reachability analysis.
then bovinspector executes the source code symbolically under the guidance of reachable warnings.
each reachable warning is validated and classi ed by checking whether all the path conditions and the bu er over ow constraints can be satis ed simultaneously.
for each validated true warning bovinspector x it with three prede ned strategies.
bovinspector is complementary to prior static bu er over ow discovery schemes.
experimental results on real open source programs show that bovinspector can automatically inspect on average of .
of total warnings and false warnings account for about to on average of .
of the total inspected warnings.
in addition the automatically generated patches x all target vulnerabilities.
further information regarding the implementation and experimental results of bovinspector is available at and a short video for demonstrating the capabilities of bovinspector is now available at ccs concepts software and its engineering !software veri cation and validation software defect analysis soft ware testing and debugging security and privacy !vulnerability scanners keywords bu er over ow symbolic execution validation automatic repair .
introduction bu er over ow occurs when a program writes data to a bu er overruns the bu er s boundary and overwrites adjacent memory locations.
the bu er over ow vulnerability provides a way for attackers to corrupt data crash the program or execute malicious code.
attackers often carefully construct their inputs to over ow the bu er and overwrite the adjacent memory which may contain return address to execute their malicious code.
although bu er over ow has been explored for many years it remains one of the most common types of software vulnerabilities according to the statistics by common vulnerabilities and exposures cve .
bu er over ow attacks against both legacy and newlydeployed software systems can lead to system crash denial of service or loss of control to external attackers leading to disastrous consequences.
challenge.
static program analysis and dynamic testing approaches have been proposed to detect bu er over ow vulnerabilities.
dynamic testing methods are commonly used during software deployment however they highly rely on the completeness of the test suite.
static analysis approaches can achieve high level automation which makes them popular in practice such as .
however the key limitation of static technique is that the reported bu er over ow vulnerabilities warnings contain too many false positives fundamentally due to the lack of software execution information.
each static vulnerability warning needs to be manually inspected to identify true vulnerabilities and false alarms.
our experience shows that even commercial and mature static analysis tools like hp fortify which is one of the leading commercial products in application security market1 can report a great number of warnings for a moderate sized program.
as shown in table as the scale of program increases the total number of warnings will also increase notably.
it s challenging for programmers to manually inspect all of the warnings and source code to 1gartner magic quadrant for static application security testing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
table warnings reported by fortify on real world programs program scaletotal number of warningstotal number of buffer overflow warnings gzip1.
.
.1k tftp hpa5.
.3k net tool .
.1k inspircd2.
.
.1k udisks2.
.
.1k tiff4.
.
.4k freetype2.
.
.6k firefox .
.3k nd and repair true vulnerabilities which is a daunting task that can be extremely tedious labor intensive and timeconsuming.
in addition the false positives waste a huge amount of human e ort on manual inspection.
our proposal.
in this paper we present an automatic framework bovinspector to help programmers to inspect bu er over ow vulnerability warnings output by existing static program analysis tools for c programs as well as repair validated true bu er over ow vulnerabilities.
first bovinspector performs warning reachability analysis to nd reachable path segments of each static bu er over ow warning in the control ow graph of the program.
next bovinspector explores all the program paths guided by previous generated reachable path segments of each reachable warning in an extended symbolic execution engine.
then each reachable warning is validated and classi ed by checking whether all the path conditions and the bu er over ow constraints can be satis ed simultaneously during the symbolic execution.
finally for each validated true warning bovinspector xes it by adding boundary checks or replacing unsafe apis with safe ones.
so far bovinspector is complementary to prior static bu er over ow detection techniques.
we make the following contributions we combine static analysis and dynamic symbolic execution technique to automatically inspect bu er overow warnings which will then be classi ed into true warnings false warnings and undecidable warnings.
we provide three strategies to automatically repair validated true bu er over ow vulnerabilities i.e.
adding boundary checks replacing the api with a safer one extending bu ers according to empirical study of human repair of bu er over ow vulnerabilities in real world projects.
we implement a prototype tool bovinspector to support for automatically inspecting warnings and repairing vulnerabilities.
.
method figure shows the overall framework of bovinspector which mainly consists of four steps warning reachability analysis guided symbolic execution bu er over ow validation and targeted automatic repair.
the key idea of bovinspector is to use symbolic execution to automatically identify those bu er over ow warnings reported by static analysis that are true warnings or false warnings.
to avoid the infamous path explosion issue of symbolic execution bovinspector uses static analysis to guide the symbolic execution so that it only focuses on the execution paths that cover the bu er overow warnings generated by static program analysis.
aftervalidating the bu er over ow vulnerabilities bovinspector will automatically repair these bu er over ow vulnerabilities according to popular human repair strategies.
.
warning reachability analysis given the source code of a program we rst use fortify to perform a static analysis to get all the bu er over ow warnings.
each bu er over ow warning can be represented as a tuple d l1 l2 ... l n o in which d is the statement label where the bu er is declared l i i n is the statement label where an operation is performed on the bu er and o is the statement label where the bu er over ow may occur.
the statement label including le name and line number represents where the statement is.
to con rm whether the bu er over ow warning point is reachable we rst build cfg for each procedure from the source code.
each basic block in cfg will be packaged into a cfgnode to record its predecessor and successor.
then we generate the interprocedural control flow graph icfg according to the calling relationships among procedures.
next we try to obtain the reachability of the warning points on the icfg.
if we just perform a depth rst traversal on the icfg we will get many paths that does not contain any path segments in the bu er over ow warnings.
so based on our bi direction icfg for each warning point we perform backward tracking on the icfg starting from the warning point which can signi cantly reduce the number of useless paths.
for a warning point a warning path set is a set of complete paths covering all the reachable path segments of the warning starting from the program entrance and ending at the warning point.
and a warning point may have more than one warning path set.
if there is such a warning path set existing for a warning point we consider the warning point is reachable.
otherwise the warning point is unreachable and the corresponding warning point will be classi ed as a false warning.
.
guided symbolic execution symbolic execution is commonly used in software testing which executes a program with symbolic inputs.
in this paper we use the klee symbolic execution engine.
but traditional symbolic execution has an infamous path explosion issue.
to avoid path explosion bovinspector uses warning reachability analysis s results to guide klee s symbolic execution to only focus on the warning paths.
and that means we should remove the execution states not corresponding to any of the warning paths.
the symbolic execution engine maintains an execution state pool containing all the executed states.
and the engine fetches program counter from the pool and interprets the instruction pointed by the counter.
if the instruction is a branch command the symbolic execution engine will duplicate the current execution state set the two execution states next instruction to the true direction and false direction of the branch instruction separately and add the path constraint to the corresponding execution state.
next we need to decide which direction of the branch instruction to choose to reach the warning point namely which execution state to choose during symbolic execution.
each instruction can be represented by its basic block s entrance statement label.
if both states statement labels are in the warning path set we will not remove any of the state.
if only one state s statement label is in the warning path set then we will remove the other state from the state pool.
if both states statement labels are not in the warning path set 787source code static analysisbuffer overflow warningswarning reachability analysisguided information guided symbolic executionbuffer overflow validationvalidated buffer overflow position reporttargeted automatic repairrepaired source code fortify kleebovinspectorfigure the framework of bovinspector we will not remove any of the states because sometimes the symbolic execution engine will explore inside some library calls which are not in the warning path set and sometimes the bu er over ow will be triggered by multiple execution of a loop.
each time when an instruction is interpreted the symbolic execution engine will select an execution state from the state pool to perform the next execution which will continue until there s no state in the execution state pool or the time threshold value is exceeded.
.
buffer overflow validation klee can only identify some common defects such as null pointers and out of bound pointers during runtime.
to validate bu er over ow warnings during symbolic execution we extend klee s symbolic execution engine by adding a bu er over ow validation module.
during the guided symbolic execution the extended executor will collect the path conditions.
when encountering a bu er over ow warning point the extended executor will duplicate the current execution state and add bu er over ow constraints what bu er over ow constraints need to be added will be discussed in the following contents into its corresponding backup state.
then the constraint solver will be invoked to determine whether the path conditions together with the bu er over ow constraints are satis able.
apparently there may be more than one reachable path for a bu er over ow warning point.
if one of the reachable path s constraints together with the bu er over ow constraints are satis able then the bu er over ow warning reported by fortify is a true warning and the speci c method will be invoked to generate a test case that will follow the path and trigger the bu er over ow.
if none of the reachable path s constraints together with the bu er over ow constraints are satis able then the bu er over ow warning reported by fortify is a false warning.
if the constraints cannot be solved in the given time threshold then the bu er over ow warning reported by fortify is an undecidable warning.
first to determine which apis should be focused on in our bovinspector we studied apis operating bu ers in c99 and linux system call interface.
the apis we focus on in bovinspector are copying functions concatenation functions format input output functions character input output functions and le input output functions.
in addition to these apis we also care about direct bu er accessing namely array and pointer accessing.
next we need to determine what condition should be satis ed to trigger a bu er over ow vulnerability.
as a bu erover ow occurs when more data is written into a bu er than it can hold we need to gure out the targeted bu er s real capacity and the original data s possible length.
to trigger a bu er over ow the original data s possible length must be bigger than the targeted bu er s real capacity which constructs the bu er over ow constraints.
accordingly to avoid a bu er over ow the boundary check need to be added will be that if bu er over ow constraints are satis able the program must be terminated.
finally based on the above analysis we propose our bu er over ow constraints and repair models which is shown in table .
particularly we put direct bu er accessing in the model.
direct bu er accessing includes array and pointer accessing.
column shows the apis that bovinspector can handle with column shows what parameters format the apis use column shows what constraint must be satis ed to trigger a bu er over ow and column shows what api can be used to replace the corresponding apis to secure the program.
in column strlen and sizeof are c language library functions.
strlen returns the length of the c string without including the terminating null character .
and sizeof returns the size of data type or variables .
take strcpy for example to explain how we construct the bu er over ow constraints strcpy copies the c string pointed by src into the array pointed by dest including the terminating null character and stopping at that point .
to trigger a bu er over ow strlen src is because the source string includes a terminating null character should be bigger than sizeof dest which means bu er over ow constraints of strcpy will be strlen src sizof dest and so on.
.
targeted automatic repair tao et al.
perform an empirical study on detecting and xing bu er over ow bugs.
more speci cally they investigate o cially adopted or programmers preferred x approaches for bu er over ow vulnerabilities in real world programs reported in cve .
the investigation shows that adding boundary checks turns out the most common way nearly to x bu er over ow vulnerabilities followed by replacing api with a safer api and extending the bu er size.
bovinspector implements the top three of the most popular bu er over ow repair strategies according to this conclusion.
currently bovinspector can handle bu er over ow vulnerabilities caused by the apis listed in table .
we design three repair strategies for bovinspector i.e.
default for adding boundary checks api rep for replac788table bu er over ow constraints and repair models type api parameters format bu er over ow constraints safer api option strcpy char dest const char src strlen src sizeof dest strncpy dest src sizeof dest 2strncpy memcpy memmove memset snprintf vsnprintf char dest const char src size t n n sizeof dest strcat char dest const char src strlen src strlen dest sizeof dest snprintf dest strlen dest sizeof dest strlen dest s src strncat char dest const char src size t n minfstrlen src ng strlen dest sizeof dest sprintf char str const char format ... format string length sizeof str snprintf str sizeof str format ... fgets char str int num file stream num sizeof str fread void ptr size t size size t count file stream size count sizeof ptr read int fd void buf size t count count sizeof buf 9buf buf i i typesize sizeof buf linux development environment ubuntu .
llvm infrastructure llvm .
warning reachability analysis module fortify .2kleeguided symbolic execution modulebuffer overflow validation module buffer overflow repair module figure bovinspector tool architecture ing the api with a safer api and extend for modifying the bu er s de nition to extend its bu er.
bovinspector takes source code les that need to be repaired and their bu er over ow vulnerabilities reports as inputs and outputs repaired source code les.
bovinspector reads the bu er over ow vulnerabilities reports and extracts the position of each bu er over ow vulnerability and the targeted api.
the reports may contain bu er over ow vulnerabilities at multiple locations in di erent source les.
if we insert some statements in the source code to repair the rst vulnerability it will result in a line number mismatch between the source code and the report for the other vulnerabilities.
so bovinspector rst extracts all the bu er over ow vulnerabilities reports in each source le and then sorts the positions of bu er over ow vulnerabilities in each source le by the line numbers in descending order.
then bovinspector repairs the bu er over ow vulnerabilities in each source le according to the above order.
for each bu er over ow vulnerability bovinspector rst locates the corresponding source code and fetches the actual parameters from it.
and the required parameters are listed in the fourth column of table .
given the targeted api required parameters and repair mode bovinspector will return the corresponding repair suggestions adding boundary checks in this mode bovinspector will add a boundary check in the previous line of the bu er over ow line.
and the boundary check is an if statement with the condition constructed from the fourth column of table with the actual parameters.
speci cally if the targeted api is sprintf we will compute the length of format string by setting the rst parameter of vsnprintf to null and the second to .
replacing the api with a safer api in this mode bovinspector will rewrite the bu er over ow line with a safer api calling constructed from the fth column of table with the actual parameters.
speci cally as table shows there are only three types of apis having a safer api option .
the other types of apis will be repaired by adding boundary checks in this mode.
extending bu ers in this mode bovinspector will need the de nition position of the bu er that may over ow which can be fetched from the bu er over ow warnings .
but the bu er size is always program speci c and we will let the programmers con gure the bu er size.
.
implementation and ev aluation bovinspector is built on the llvm .
compiler infrastructure .
it is composed of four modules warning reachability analysis guided symbolic execution bu er over ow validation and bu er over ow repair as shown in figure .
warning reachability analysis module is implemented as a llvm pass to build control ow graph cfg of the program analyze the reachability of bu er over ow warnings in the graph and nally output warning path sets.
we extend the function of klee a state of the art symbolic execution engine to support guided symbolic execution module and bu er over ow validation module.
bu er over ow repair module is implemented as a python script with three repair strategies.
the static bu er over ow detector used in our experiments is hp fortify with version .
.
we provide interface to process warnings reported by fortify.
it is very straight forward to work with other static analysis tools.
to evaluate the capability of bovinspector we have conducted control experiments on a benchmark.
to prepare the benchmark we select programs from gnu coreutils utilities and real world open source programs such as sendmail .
.
gzip .
.
and so on.
and the programs 789table inspection and repair results on real program program bovposition bovcause fortify before bovinspectorfortify after bound checking api rep gzip .
.
gzip.c strcpy bov bov dangerous function nothing wwwcount .
main.c strcpy bov bov dangerous function nothing net tool .
netstat.c strcat bov bov nothing nothing table results of the bovinspector s repair and the o cial repair program bovposition bovcause bovinspector repair o cial repair gzip .
.
gzip.c strcpy1 if strlen iname sizeof ifname strncpy ifname iname sizeof ifname if sizeof ifname strlen iname man .5i2 man.c strcpy1 if strlen name0 sizeof ultname strncpy ultname name0 sizeof ultname if strlen name0 sizeof ultname wu ftpd .
.
ftpd.c strcpy1 if strlen mapped path sizeof path strncpy path mapped path sizeof path strncpy path mapped path size xmp .
.
dttload.c array if i sizeof pofs sizeof pofs if i mapserver5.
.
beta4mapserv.c 1334sprintf1 include my vsnprintf.h if my vsnprintf s s s.map mapserv map web.imagepath mapserv map name mapserv id sizeof bu er snprintf bu er sizeof bu er s s s. map mapserv map web.imagepath mapserv map name mapserv id snprintf bu er sizeof bu er s s s. map mapserv map web.imagepath mapserv map name mapserv id cgminer .
.
util.c sprintf1 include my vsnprintf.h if my vsnprintf s s url port sizeof address snprintf address sizeof address s s url port snprintf address s s url port are compiled into llvm bitcode by llvm gcc.
all experiments are conducted on a quad core machine with an intel core tm corei5 .10ghz processor and 4g memory running linux .
.
.
due to the page limit all the subjects and evaluation results of the automatic inspection are put online at the results of automatic repair are shown in table .
the given bovposition in table are all real bu er over ow vulnerabilities that have been validated o cially.
the bovinspector column shows that our bovinspector validates all these bu er over ow warnings reported by fortify as bu er over ow vulnerabilities.
after all the real vulnerabilities are repaired by bovinspector the program will be rescanned by fortify to verify bovinspector s repair ability.
and the results show that fortify will report no warnings on the programs repaired by bovinspector by adding boundary checks or replacing with a safer api.
and bovinspector s repair results are also validated by having a human review.
so our bovinspector can automatically and correctly repair the bu er over ow vulnerabilities that have been validated by itself.
to further illustrate the correctness of bovinspector s repair we select real world programs and compare the patches generated by bovinspector and the o cial manual repair.
and we obtain both the buggy and xed versions of programs that contain bu er over ow vulnerabilities.
by comparing the buggy and xed versions of a program we will know where the bu er over ow vulnerabilities are.
we add the above bu er over ow vulnerabilities positions into the bu er over ow vulnerabilities reports which will be used to guide the bovinspector s repair.
after using bovinspector to repair the bu er over ow vulnerabilities in the source code we will use fortify to perform a static analysis on the repaired source code.
meanwhile we analyze where and how the programmers repaired the bu er over ow vulnerabilities.next we compare with the di erences between the bovinspector s repair and the o cial repair.
table shows the results of the bovinspector s repair and the o cial repair.
the bovinspector repair column shows the results of two ways to repair bu er over ow vulnerabilities.
the rst method is adding boundary checks and the second method is replacing the buggy line with a safer api call.
we list both the two repair methods results to further show how bovinspector repairs bu er over ow vulnerabilities.
the results show that bovinspector s repair methods are very similar to the o cial repair methods namely similar to the human programmers repair habit.
.
related work static analysis approaches such as scan software source code to discover possible bu er over ows.
static analysis methods can achieve high level automation which makes them popular in commercial tools such as .
these static analysis tools are easy to use but they often report a large number of false warnings due to the lack of runtime information and adopted conservative strategies in static techniques.
in bovinspector the static analysis tool fortify is used as a pre processing tool to guide bovinspector s symbolic execution to only focus on the warning paths which will raise the e ciency of symbolic execution and bu er overow validation.
and bovinspector can inspect the fortify bu er over ow warnings as true warnings or false warnings to reduce its large number of false positives.
namely our method is complementary to the static analysis methods.
dynamic testing methods are commonly used during software deployment.
hossain et al.
propose a mutationbased testing technique to generate adequate test data set for bu er over ow vulnerabilities.
eric et al.
develop a tool that instruments programs to keep track of memory 790bu ers and checks arguments to functions to determine if they satisfy certain conditions and warns when a bu er overow may occur.
the testing completeness of these methods highly relies on the completeness of the test suite which cannot be guaranteed.
and without a target guidance these testing methods always generate a lot of test cases that cannot trigger a real vulnerability.
in bovinspector we use symbolic execution to automatically generate test cases that achieve high coverage on complex programs.
what s more we use guided symbolic execution to only focus on the bu er over ow warning paths reported by fortify to reduce the useless path execution and test case generation.
as high level automation has become a trend many methods and tools are proposed to perform automatic bug x. dira automatically instruments a network service program to detect control hijacking and record enough runtime information to generate the corresponding patch.
the patches are similar to our bovinspector except that dira will extend a bu er according its runtime information but the patch may be useless under another test case.
and dira detects control hijacking at runtime which depends on test cases to nd bugs.
bovinspector doesn t need the runtime information and it can inspect and repair bu er over ow vulnerabilities during software development.
tap is an automatic bu er and integer over ow discovery and patching system.
its application range is limited to those programs which contain incorrectly coded checks.
what s more it can only insert boundary checks to repair these bu er over ows.
our bovinspector s bu er over ow detection module does not require the program to contain incorrectly coded checks.
and bovinspector provides more ways to repair bu er over ow vulnerabilities for the programmers.
clearview reallocates the compromised local array as a global array and sandwiches it in a pair of write protected pages.
but its patches are not similar to those that human programmers write.
and our bovinspector s repair module is designed and implemented according to programmers suggested repair methods.
codephage automatically transfers correct code from donor applications into recipient applications that process the same inputs to successfully eliminate errors in the recipient.
codephage is di erent from bovinspector s repair method because it relies on the existence of a speci c donor application containing of the exact program logic to x an error.
.
conclusions in this paper we propose an automatic inspection and repair tool bovinspector for c programs.
for each static bu er over ow warning bovinspector rst performs warning reachability analysis and identi es reachable path segments for the reachable warning.
then it uses guided symbolic execution to explore all the reachable path segments regarding to the warning.
based on the bu er over ow model and runtime information collected during the symbolic execution the warning can be validated and classi ed as true warning false warning or undecidable warning.
finally each true bu er over ow vulnerability could be automatically repaired with three strategies.
the experimental results show that bovinspector can automatically and correctly inspect staticbu er over ow warnings and repair validated bu er over ow vulnerabilities.
.