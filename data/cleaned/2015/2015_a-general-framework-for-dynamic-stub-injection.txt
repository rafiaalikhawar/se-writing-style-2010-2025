a general framework for dynamic stub injection maria christakis microsoft research redmond wa usa mchri microsoft.compatrick emmisberger dept.
of computer science eth zurich switzerland empatric student.ethz.chpatrice godefroid microsoft research redmond wa usa pg microsoft.competer m uller dept.
of computer science eth zurich switzerland peter .mueller inf.ethz.ch abstract stub testing is a standard technique to simulate the behavior of dependencies of an application under test such as the file system.
even though existing frameworks automate the actual stub injection testers typically have to implement manually where and when to inject stubs in addition to the stub behavior.
this paper presents a novel framework that reduces this effort.
the framework provides a domain specific language to describe stub injection strategies and stub behaviors via declarative rules as well as a tool that automatically injects stubs dynamically into binary code according to these rules.
both the domain specific language and the injection are language independent which enables the reuse of stubs and injection strategies across applications.
we implemented this framework for both unmanaged assembly and managed .net code and used it to perform fault injection for twelve large applications which revealed numerous crashes and bugs in error handling code.
we also show how to prioritize the analysis of test failures based on a comparison of the effectiveness of stub injection rules across applications.
i. i ntroduction a notorious difficulty in testing is dealing with operations whose behavior is not determined by the test inputs.
such operations include certain system calls such as obtaining the current date accessing external components such as file systems and databases and non deterministic operations such as generating random numbers .
controlling the behavior of such operations is necessary to ensure that tests behave predictably and to increase test coverage.
the standard solution to this problem is to replace these operations by stubs or similarly fakes or mocks whose behavior can be controlled by the tester .
using stubs involves four main steps deciding which functions to replace by stubs.
for example for a file api testers might replace functions to read from a file but not functions to manipulate file names.
for each function to be replaced implementing one or more stubs.
these stubs could for instance provide deterministic behavior or simulate erroneous behavior.
for each callto a replaced function deciding whether to call the original function or a stub.
for instance it is useful to inject stubs for allcalls to a non deterministic function but to simulate erroneous behavior only for some calls to prevent the application under test from terminating early and thus exploring only shallow paths.
for each chosen call performing the actual stub injection.existing tools and frameworks automate some aspects of these steps but are often too restrictive.
for instance aspect oriented programming provides an elegant way of expressing the behavior of stubs and injecting them via aspect weaving.
however this approach prescribes the use of an aspect oriented programming language which limits its applicability.
mocking frameworks provide similar functionality but are typically language specific which hampers reuse of stub code across programming languages.
fault injection frameworks like lfi and jaca inject stubs that return error codes and set flags but they do not allow testers to inject arbitrary behaviors which is for instance necessary to simulate the behavior of external components.
several frameworks automate the actual stub injection but do not provide support for the first three steps above.
as a result testing with stubs remains a mostly manual and time consuming effort.
in this paper we present a framework for stub injection that supports all four steps outlined above.
at the core of the framework is a domain specific language dsl that allows testers to express the behavior of stubs as well as flexible strategies for injecting them.
our framework automatically implements the specified injection rules by dynamically altering the executable program.
a key virtue of this framework is that it is language independent stubs are expressed in a very large subset of c that gets interpreted rather than compiled they are then dynamically injected into binary code.
consequently our framework does not require source code which makes it widely applicable.
moreover the injection rules can be reused across languages for instance to test different clients of the same external component.
being able to reuse stub injection rules across applications does not only reduce effort comparing their effectiveness across applications also allows one to optimize both testing and debugging.
for instance a rule that leads to failures in most applications is likely to produce behavior that cannot exist without the injection and thus should be reviewed to avoid spurious errors.
in contrast a rule that hardly ever leads to a failure is very likely to have found a true bug when it does produce a failure.
hence failures produced by such rules should be given priority during the analysis of test results.
we capture the effectiveness of rules in finding ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
true bugs by an indicator that adapts engler et al.
s bugs asdeviant behaviors strategy from the context of static analysis and specification mining to automatic testing.
we illustrate the power of our framework by testing error handling code in mature applications such as microsoft notepad and excel.
we use our framework to inject faults in system calls and measure its effectiveness in finding bugs.
for twelve mature applications we were able to provoke over crashes we argue that they are due to real bugs.
this paper makes the following technical contributions a domain specific language that allows testers to specify flexible stub injection rules.
the rules express the behavior of stubs as well as injection strategies.
a novel technique and implementation for dynamic stub injection into binaries via instrumentation of both unmanaged assembly and managed .net code.
an extensive evaluation which uses our framework to perform fault injection for twelve mature applications including microsoft excel word and notepad and discovered over crashes and numerous bugs.
a methodology for prioritizing the analysis of program failures based on a comparison of the effectiveness of stub injection rules across applications.
outline.
the next section gives an overview of our framework.
sect.
iii presents our dsl while sect.
iv explains the code instrumentation.
we present our evaluation and indicator for the effectiveness of stub injection rules in sect.
v. we discuss related work in sect.
vi and conclude in sect.
vii.
ii.
o verview in this section we present an example for a stub injection rule and explain how it is applied by our framework.
various system functions take as argument a buffer that is being populated by the function and flag an error if the buffer is too small.
if the data to be copied into the buffer is not determined by the application under test but for instance by the file system then stubs can be used to provide the data or to simulate the case that the buffer is too small.
an example of such a function is getmodulefilenamew from the windows kernel32.dll .
it retrieves the fullyqualified path for the file that contains a specified module copies it into a specified buffer and returns the number of copied characters excluding the terminating null value .
if the buffer is too small the function truncates the string and sets the last error to error insufficient buffer .
in this case the returned value is equal to the buffer size whereas it is smaller in the successful case.
fig.
shows a stub injection rule that simulates the error case.
the rule first specifies the function whose behavior is altered line and the names of its arguments line such that the stub code can refer to them.
line specifies the injection strategy which in this case directs our framework1rule kernel32.dll!getmodulefilenamew hmodule lpfilename nsize 3frequency every 4after if nsize setlasterror error insufficient buffer result nsize figure an example stub injection rule.
to dynamically inject the stub for every other call to the function.
lines specify the stub behavior.
the after keyword line indicates that the stub will call the original function and perform additional operations after it has terminated.
here these operations lines set the error code and adjust the return value.
both adjustments are performed only if the provided buffer is smaller than the maximum path length in windows.
this rule illustrates several important aspects of our framework.
first stubs may have non trivial behavior.
for instance they may refer to function arguments which is crucial to specify accurate stubs and thus avoid false alarms.
they may also change the state in arbitrary ways here we set a global error flag but it is also possible to modify complex data structures.
moreover stubs may maintain their own data structures to implement complex behavior that spans multiple stub invocations.
we discuss such an example in sect.
v. second since the stub is implemented in an interpreted subset of c the rule is language independent.
it can be used to test clients of this function written in various languages.
third our dsl allows one to either replace or augment the behavior of the original function.
executing the original function is useful when only some aspects of its behavior need to be altered it is then not necessary to reimplement all other aspects in the stub.
in our example the original function will still populate the buffer and the stub only sets the error code and result value.
another rule for the same function could replace calls to the original function by code that populates the buffer itself.
to apply stub injection rules we use a custom loader for dynamic link libraries dlls that instruments the loaded dll to inject calls to our runtime component in the functions prescribed by the rules.
fig.
illustrates the workflow.
to use our framework the application under test is started through a dedicated launcher which instructs the windows loader to load our runtime component as the very first statically imported dll.
upon loading our runtime wraps the windows loader with our own dedicated loader which reads the stub injection rules from disk and instruments each subsequently loaded dll in memory .
once all dlls are loaded and instrumented the executor calls the main function of the application.
executing the application may authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
launcher framework runtimeloaderdlls on disk dlls in memoryexecutorconfiguration figure the workflow of stub injection.
trigger the loading of additional dlls which are handled analogously.
for each call to an instrumented function the executor dynamically evaluates the injection strategy and if required interprets the stub code.
performing the instrumentation dynamically on the level of binaries has several advantages first our framework does not need source code which makes it widely applicable.
second we instrument the code that is actually deployed which avoids potential issues with compilation and optimization.
third it is not necessary to know in advance which dlls will be loaded by an application.
fourth our approach handles complex invocation schemes including recursion reentrant calls and calls through function pointers these are difficult for approaches based on static rewriting.
iii.
a dsl for dynamic stub injection our dsl for writing stub injection rules allows testers to control the functionality of our framework.
the most interesting aspects of the grammar are presented in fig.
and explained below.
we omit some features such as the ability to import headers for brevity.
the configuration cof our framework consists of declarations of global and thread local variables and of a list of rule definitions.
the variables allow stubs to maintain data structures that persist across several stub invocations for instance to compare the results of two subsequent calls see sect.
v c for an example .
a rule rspecifies a set of target functions an injection strategy and a stub.
the set of target functions includes only dll exported functions and is determined by two patterns for module and function names mandf.
a pattern is either an identifier the name of the module or function a wildcard which matches anything or a regular expression.
regular expressions are useful to specify injection rules for a whole class of functions.
for example system functions whose name contains create typically return a handle to a newly created resource.
our dsl allows one to conveniently write one rule to inject stubs in all of them.
after these patterns the user may optionally specify the function parameters p which are used only to refer to them in the stub code.
the sets of target functions of different rules may overlap.
for any given call our framework applies the last rule in the configuration that matches the module and function name.configuration c global decls thread decls r rule r rule m!f is sb strategyis none stubsb depthdp depth all top frequency fr frequency every int probability float every probability int float repeatrp repeat infinity int beforebf before code afteraf after code variables vs call decls figure the most interesting aspects of the grammar of our dsl.
xdenotes a possibly empty list of symbols x. we omit the specification of optional type information.
as we will discuss in sect.
iv our framework uses the type information available in the debugging symbols to locate function entry points.
if the debugging symbols are not available testers may include both parameter and result types in the rules not shown in the grammar .
our framework instruments target functions with functionality that determines dynamically whether or not to inject a stub for any given call to the function.
this decision is prescribed via the injection strategy is which is defined as a combination of three filters stubs are injected only for calls that pass all three.
the depth filter dpfilters calls based on the call stack.
the option all retains all calls top drops calls that are called directly or transitively by an instrumented function for instance recursive calls.
the top option is useful to retain only calls at api boundaries but drop calls from within the api or an injected stub.
the frequency filter frand repeat filter rpselect calls based on the call history.
for the frequency filter the option every n retains every n th call to the same function and drops the others.
for convenience we support the option always as a shorthand for every .
the option probability p retains the call with probability p. we use never as a shorthand for probability .
finally every probability n p combines the every andprobability options.
it drops the call with probability p. out of the remaining calls to the same function it retains every n th.
finally the repeat filter rpretains all calls with option infinity or only the first ncalls to a function.
for convenience any of the filters may be omitted.
in this case we choose the most permissive filter as default that is depth all frequency always and repeat infinity .
as an alternative to the three filters the strategy iscan be set to none .
in this case the framework ignores the call authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
completely.
this option is useful to override earlier general rules in the configuration for specific functions.
our framework injects stubs for those instrumented calls that pass all three filters of the injection strategy.
the behavior of a stub sbis described via three components.
the before action specifies code that is executed upon entry to the stub.
if this code executes a return statement the stub terminates.
otherwise our framework automatically executes the original function for which the stub was injected followed by the code specified in the after action .
this structure allows stubs to either replace oraugment the original function.
replacing the original function is for instance useful when the stub simulates the behavior of an external component such as a database augmenting lets the stub reuse some of the original function s behavior as we illustrated in sect.
ii.
the before andafter actions are written in a large subset of c including while break continue return andif else statements but no for goto o r switch statements as well as no comma and ternary operators an extension is straightforward.
after actions may inspect the result of the original function via a predefined result variable.
the value of this variable is returned when the action terminates so after actions indicate their return value by assigning to result as illustrated in fig.
.
when stub code is split over two actions local variables declared in one are not in scope for the other.
to work around this issue the component vsallows the declaration of variables that are in scope of both actions of a stub.
iv .
i nstrumentation this section explains how our framework instruments the application under test to implement the injection strategy and inject the stubs described by our dsl.
we present solutions for both unmanaged assembly and managed .net code and discuss some of the technical challenges involved.
a. unmanaged code recall from sect.
ii that our framework uses a custom loader to instrument imported dlls according to the stub injection rules expressed in our dsl.
to perform this instrumentation for unmanaged code the custom loader creates a copy of each target function that is each function that matches a rule in the configuration for which the strategy is different from none .
we use an extension of the detours library for this purpose.
the loader then instruments the original version of the target function while the copy is still available and can be called from the stub.
fig.
shows the instrumentation of a target function foo.
its body is modified to start with a jump to a piece of assembly code that evaluates the injection strategy and if required executes the stub code.
modifying the code of the target function allows us to handle all calls including callsfoo jmp foo stub more instructions foo stub push information about foo call before event cmp eax jereturn call foo original push information about foo call after event return ret figure instrumentation of unmanaged function foo .
that involve function aliases function pointers or pointer arithmetic.
the assembly code foo stub in fig.
is generated for each target function.
it stores information about the target function foo and then calls the before event function of our framework.
this function determines based on the previously stored information about foo and the injection strategy of the rule whether a stub should be injected.
if so it interprets the code in the corresponding before action.
the return value of before event determines whether the before action replaces the original function or augments it.
in the former case foo stub terminates and the application under test continues after the call to foo.
in the latter case foo stub calls the copy of the target function we created earlier and then invokes the framework function after event to execute the after action if required.
the actual code is more complicated than shown in fig.
.
for instance it needs to pass along the result value of thebefore action handle the declaration of variables that persist across the entire stub component vsin fig.
and manage registers the stack pointer and any data on the stack.
we omit these technical details here and instead discuss our solutions to three more interesting technical challenges that arise in the context of unmanaged code.
type information.
when a rule targets multiple functions through a regular expression or wildcard in the patterns our framework needs to identify all dll exported functions to be instrumented.
dll export tables contain all exported symbols but do not specify which symbols refer to functions and which to variables.
hence they are not sufficient to determine where to apply the instrumentation.
our framework provides two solutions to this problem.
if the debugging symbols are available our framework can precisely determine the exported functions of a dll an address in a dll export table is a function entry point if and only if there exists a debugging symbol for a function starting at the same address.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
if debugging symbols are not available we determine the dll exported functions by consulting the dll section table.
this table contains information about which address ranges or sections contain executable code read write data and read only data.
this approach works well in practice although we have encountered a few dlls in which the executable sections also contain read only data such that the instrumentation may corrupt data.
in the absence of debugging symbols our framework requires the stub injection rules to include parameter and result types of target functions in order to determine the memory layout of the stack frame.
heap isolation.
our framework allocates memory to maintain internal data structures such as counters and also permits stubs to allocate memory.
this can lead to two problems first when the memory allocated by the framework and the memory allocated by the application are interspersed a buffer overflow in the application under test is likely to corrupt the memory allocated by our framework.
as a result testers observe behavior that they would not see without instrumentation which makes it difficult to reproduce and debug the error.
second the heap is a shared resource and a lock must be acquired for memory allocation.
this lock is exposed to applications and may in combination with locks that are introduced by our framework lead to deadlocks.
both memory corruptions and deadlocks occurred several times during our experiments before we implemented the following solution.
we avoid both problems by providing internal rules that redirect all memory allocation operations performed by our framework to a separate private heap.
this private heap has its own lock which avoids deadlocks between our framework and the application under test.
we attempt to keep a gap between the two heaps.
this gap shrinks as the application allocates more memory and eventually there may be a need for several such memory blocks each for the application and the framework.
nevertheless there are considerably fewer places where the heaps of the application and of the framework are adjacent which significantly reduces the risk of corrupting the memory of the framework.
code modification.
as shown in fig.
our framework modifies the implementation of function foo by replacing the first nbytes with an unconditional jump instruction for instance n on 32bit intel architectures .
this modification will handle calls to foo correctly but may lead to problems if the program tries to jump to an original instruction at address foo offset where offset n. since these addresses no longer contain a valid instruction the processor triggers an invalid instruction exception.
to avoid this problem our framework provides an internal rule for the exception dispatcher that undoes the instrumentation of function foo sets the injection strategy for foo to none to avoid the same problem in the rest of the execution and resumes execution of the process at address foo offset .void foo ... bool inject executor.mayinject foo bool augment false if inject augment before action if augment try original function body of foo finally if inject after action figure instrumentation of managed function foo .
these steps effectively disable rules targeting foo.
before implementing this solution we encountered this problem multiple times on 64bit architectures especially for functions that contain loops early in the function body such as some string functions.
b. managed code in the case of managed code the loader of our framework is notified of two kinds of events in the .net virtual machine.
first upon module loading the loader retrieves all target functions in the module.
since .net bytecode is typed this step is simpler than for unmanaged code.
second before each of these functions is jit compiled the executor changes their in memory bytecode representation through the .net profiling api as shown in fig.
.
the call to executor.mayinject evaluates the injection strategy and yields whether a stub needs to be injected.
if so we execute the before action.
its result indicates whether the original function should be augmented or replaced.
in the former case we execute the original function body and theafter action.
the try finally block ensures that theafter action is considered for all normal and abrupt terminations of foo s body.
as for unmanaged code we simplified the presentation by omitting several technicalities such as the handling of result values.
note however that the technical challenges discussed for unmanaged code do not apply to managed code the bytecode language is typed which makes it easy to identify functions the automatic memory management avoids problems with buffer overruns and the structure of the bytecode makes it easy to modify the function body.
v. e xperimental ev aluation we evaluated our framework on several large applications.
to have a simple and unambiguous definition of success and failure of a test we focus on a specific kind of stub here namely stubs that inject faults.
in the following we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
describe the design of our experiments present their results and suggest a methodology for prioritizing the analysis of crashes based on an indicator that predicts the effectiveness of a stub injection rule in finding real bugs.
a. design of experiments our experiments are defined by the applications under test the test scenarios to be executed and the stub injection.
we describe these three aspects in the following.
applications under test.
we selected twelve widely used commercial applications see first column in tab.
i .
we tested the latest version of all applications at the time of writing on a machine running windows .
test scenarios.
our fault injection will focus on system calls that request resources and access external resources such as the windows registry.
many such calls are made during the start up of an application hence we use the following simple steps as the test scenario for most applications start the application wait a fixed amount of time and close it.
only the test scenario for microsoft notepad was slightly more involved and included selecting file open and then cancel in the file browsing window.
although our test scenarios are seemingly simple they were sufficient for injecting faults in thousands of calls and detecting over crashes see tab.
i for more details .
our framework allows one to express test scenarios in xml combine them with different configurations for stub injection to obtain the concrete test cases and then automatically execute these test cases.
stub injection rules.
as we discussed in sect.
iii defining a rule consists of determining the target functions the injection strategy and the stub behavior.
target functions.
for our experiments we focus on two typical applications of stub testing functions that request new resources and functions that access resources external to the application under test.
to identify which functions to instrument we executed the test scenario for two of the target applications microsoft notepad and notepad selected at random and used our framework to record all function calls including their arguments and return values up to a certain number of pointer dereferences .
to identify functions that request resources we considered those functions among the recorded ones whose name contains the string create .
we then consulted the documentation for a random subset of these functions and selected those that indeed request resources.
we ended up selecting eleven functions with this approach.
an example iscreatefile from kernelbase.dll which creates or opens a file or i o device.
this function might fail for instance when access to the file or device is denied.
to identify functions that access external resources we considered those functions among the recorded ones that returned different values for the same arguments acrossat least two calls that is functions whose result depends on some state.
we over approximate the comparison of arguments for instance by dereferencing pointers a fixed number of times.
again we consulted the documentation for a random subset of these functions and selected those that access some external resource.
in the end we selected functions with this approach.
an example is function getenvironmentvariablew from kernelbase.dll which retrieves the content of an environment variable.
this content may change or the variables may get undefined between two calls to this function.
injection strategy.
we defined five different injection strategies called never always every other call once and fifty fifty.
the never strategy never injects a fault to a function call and is used to check that our instrumentation alone does not cause crashes in any of the applications we consider.
this was not the case in our experiments and hence the baseline strategy never is not shown in tab.
i. the always strategy injects a fault every time there is a call to a target function the every other call strategy injects a fault every other time there is a call to the function once injects it only the first time there is a call and fifty fifty injects a fault with a probability.
stub behavior .
fault injection requires rather simple stubs which typically return a value and set an error code to specify what error occurred.
we express these behaviors through after actions because for our target functions the stub behavior is more faithful to the actual behavior of the target function if we execute the original function first for instance to fill a buffer and then simulate that an error occurred.
in total we provided after and two before actions for the target functions we had selected.
when a system function fails in windows it typically returns an error code between and .
depending on the error code callers may handle each failure differently.
therefore to avoid spurious errors it is crucial that our stubs provide error codes which may actually occur.
for each of the functions that sets an error code we consulted the microsoft developer network msdn and stack overflow for error codes that have occurred in real situations.
for the remaining ten functions that access external resources we consulted the documentation to identify possible faults and corner cases.
e.g.
the stub for getsystemtime calls the original function and then sets the date to feb. in a leap year a corner case that has caused failures in zune and azure in the past.
in many other cases the stub returns null to indicate that the resource cannot be accessed.
in summary we defined rules target functions x injection strategies .
for stubs that set an error code this means that only one error code was tested per target function.
we then applied each of these rules in isolation to every target application for a total of runs rules x applications .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. results detecting crashes tab.
i reports the results of our experiments.
the first column of the table shows the application the second column the injection strategy the third column the number of crashes found in each application per injection strategy the fourth column shows the number of applied rules that is the number of target functions that are called at least once the fifth column shows the number of instrumented calls and the last column the number of these calls in which a stub was injected.
note that each table row shows the sum for the test runs per injection strategy.
the data shows that for ten out of the twelve target applications all but microsoft onenote launcher and microsoft paint our simple test scenario executes thousands of instrumented calls indicating that we are not testing shallow execution paths.
note however that none of the target functions were called in microsoft paint.
our evaluation focuses on windows applications.
however our target functions are system functions that exist in similar forms on all platforms e.g.
to access the file and window system .
moreover we selected a diverse set of classical desktop applications.
therefore our findings demonstrate the effectiveness of the framework in a large software domain.
comparing injection strategies.
all injection strategies detected crashes although the effectiveness differs between strategies.
across all target applications the always strategy detects the most crashes a total of followed by strategies fifty fifty and every other call which detect and crashes respectively.
the once strategy detects the fewest crashes a total of which is to be expected as it injects faults in the smallest number of calls.
even though always is overall the most effective strategy it is useful to be able to define and apply different strategies.
in the following we give two examples.
first for the same program execution that is for the same set of instrumented calls the always strategy will inject more stubs than fifty fifty and every other call.
nevertheless there are four applications in our experiments powerpoint publisher visio and notepad for which always injects significantly fewer stubs.
a likely explanation is that for these applications fifty fifty and every other call explore deeper paths and therefore encounter more calls to the target function.
hence these strategies have the potential to reveal deeper errors.
second the once strategy produces by far the most crashes per injected stubs over compared to at most .
for the other three strategies .
this suggests that the first call to a target function is particularly effective in detecting problems in error handling code.
this strategy is therefore useful to reveal such problems in executions that are shorter and thus easier to debug than executions that crash at a later call to the target function.uniqueness of crashes.
to determine whether the crashes found with different injection strategies overlap we manually inspected all detected crashes in notepad and visio.
we inspected the eight crash sites across injection strategies for notepad with a debugger and found that six of them are unique.
there were two duplicate crash sites between strategies every other call and fifty fifty.
one of them was caused by injecting faults in the exact same calls.
by inspecting the crash sites for visio we found that there are two duplicates one between strategies always and fifty fifty and one between every other call and fifty fifty.
both of these were due to the fact that faults were injected in the exact same calls by the two strategies.
this analysis provides another indication that it is indeed useful to apply different stub injection strategies because they are likely to produce different crashes.
different crash sites of course do not imply that the different crashes are caused by different bugs.
nevertheless having few duplicate crash sites reduces the debugging effort considerably.
rules triggering crashes.
as we described in the experimental setup we selected target functions based on the test executions of two applications and then applied the resulting rules to all twelve applications.
across all applications crashes were detected by applying rules with the always strategy with the every other call and fifty fifty strategies and with the once strategy.
note that the functions targeted by the rules of the always strategy do not subsume those of the other strategies.
for instance a rule does not lead to any crashes with the always strategy if the first call of the target function terminates the program normally fifty fifty might not inject a stub for that call and then crash on a later call.
overall injecting faults in target functions out of did not lead to any crashes with any strategy while injecting faults in the other led to some crash with some strategy.
performance overhead.
the runtime and memory overhead of our framework depends on three factors the number of loaded dlls that we instrument the injection strategy which determines how often stubs are executed and how computationally expensive the stubs are.
in our experiments we instrumented only one function per test run and all of our stubs were computationally cheap so the overall performance overhead was negligible.
c. results from crashes to bugs the crashes found with our framework are real bugs only if the stubs simulate behaviors that are realistic in practice.
the fact that our stub injection rules are reusable across applications enables one to derive a measure for the effectiveness of a rule and use it both to identify unrealistic stub behaviors and to prioritize crashes during the analysis of test results that are more likely to occur in practice.
we propose the following heuristic for predicting the effectiveness in detecting real bugs of stub injection rules.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
application injection strategy crashes applied rules instrumented calls stubbed calls internet explorer always every other call once fifty fifty microsoft excel always every other call once fifty fifty microsoft notepad always every other call once fifty fifty microsoft onenote launcher always every other call once fifty fifty microsoft outlook always every other call once fifty fifty microsoft paint always every other call once fifty fifty microsoft powerpoint always every other call once fifty fifty microsoft publisher always every other call once fifty fifty microsoft visio always every other call once fifty fifty microsoft word always every other call once fifty fifty notepad always every other call once fifty fifty skype for business always every other call once fifty fifty total table i the results of our experiments.
for each target function fiand each stub defined for fi w e compute the following real bug indicator across all injection strategies and applications rbi i number of crashes by stubbing fi number of stubbed calls to fi the indicator rbi ipredicts the likelihood of detecting real bugs when injecting the given stub in function fi.
a low value occurs if most stubbed calls lead to a crash.
that is most applications do not handle the stub behavior correctly thus making it more likely that this behavior cannot occur in practice otherwise we would expect more callers to handleit correctly.
conversely a high value occurs if relatively few stubbed calls lead to a crash.
in this case we conclude that it is possible to handle the injected stub behavior correctly such that failing to do so is most likely a real bug.
we propose to calibrate the real bug indicators for a set of rules by computing them for each combination of target function and stub across a set of applications and injection strategies.
the results can then be used in three ways first rules with a low indicator should be reviewed and if necessary revised.
second when the tests for an application produce more crashes than the developers can analyze priority should be given to those that were produced by rules with a high real bug indicator because they are more authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
.
25rbii fi figure the real bug indicators rbi ifor the target functions fithat lead to crashes.
likely to reveal real bugs.
third when the available testing time for a new application one that was not used during calibration does not allow one to apply all available rules testers should choose those that have a high indicator and have produced at least one crash during calibration that is the indicator is not trivially which could also be achieved by a stub that just calls the original function .
indicators in our experiments.
in our experiments out of rules led to a crash for at least one application and injection strategy.
fig.
shows the real bug indicator rbi i on the y axis for each of these target functions fi in decreasing order .
the indicators are high between .
and .
the indicator for the remaining target functions is since they did not lead to any crashes even though stubs were injected we omitted those in fig.
.
the high indicators for our target functions are not surprising given how diligently we defined the stubs.
consequently stubbed calls to these functions are handled correctly at most call sites in our experiments.
as an example we present below a bug found in excel where fault injection in one of the target functions leads to a crash only times out of .
these statistical outlier crashes point to client code where a realistic fault is not handled correctly.
overall it is likely that all crashes found in our evaluation are caused by real bugs because the stubs comply with the documentation of the target functions we inspected tens of crashes and found no false alarms and the stubs that led to crashes have high real bug indicators.
computing the real bug indicators per application can give an indication of how robust an application is against a set of rules.
for example notepad is more robust against our set of rules than excel as it crashed fewer times even though there are many more stubbed calls across all strategies.
in our experiments notepad was the most robust of all since it never crashed for any strategy even though we do inject faults.
therefore there exists at least one target application that is robust to this subset of applied rules.1for int c c c 2error regqueryvalueexw key ... buffer buffer size 4if error success error value ptr buffer break 8else if error more data error buffer.resize buffer size 12assert error error success figure snippet of code from microsoft excel.
example of a real bug found.
we manually inspected many crashes found during our experiments starting with those due to rules with high real bug indicators rbi i. here we present a sample bug found during this analysis.
function regqueryvalueexw from advapi32.dll retrieves and stores the data associated with a specified registry key in a given buffer.
if the buffer is not large enough to hold the data which can be of arbitrary length the function returns error more data .
in this case the required buffer size is stored in a variable and the contents of the buffer are undefined.
for our experiments we wrote a rule that simulates this behavior the rule with the sixth highest real bug indicator in fig.
.
when successful regqueryvalueexw returns error success .
fig.
shows a snippet of code from microsoft excel containing a call to regqueryvalueexw lines .
when the function returns successfully value ptr is initialized to point to the contents of the buffer lines .
if however the function returns error more data the buffer is resized to fit the data lines .
this logic is retried twice in a loop line although it might take more than two tries to succeed.
in other words this code incorrectly assumes that the data associated with the registry key key will not be modified between the two calls to regqueryvalueexw .
the assertion on line which is a part of the actual implementation makes this assumption even more explicit by aborting the application when the data has not been successfully retrieved after the loop.
however this assertion is not present in release code which may thus have unpredictable behavior when more than two tries are required.
indeed when testing excel with the rule for regqueryvalueexw and the always strategy an access violation occurs when value ptr is dereferenced much later in the code.
the rule is shown in fig.
.
we use two thread local variables to simulate that the buffer was not large enough to hold the data associated with a specific key for the first and second call.
note that our framework would also allow one to define a rule that tracks the number of calls per key by maintaining a global map from keys to counter values .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1thread last key void 2thread counter int 4rule advapi32.dll!regqueryvalueexw hkey ... lpdata lpcbdata 6before if last key !
hkey last key hkey counter else counter 14after if counter lpcbdata setlasterror error more data result error more data figure stub injection rule for regqueryvalueexw .
vi.
r elated work as we discussed in the introduction frameworks for writing stubs fakes or mocks typically target a particular programming language which prohibits reuse of stub code across multiple languages.
in contrast our framework injects stubs by dynamically altering an executable program independently of its source language.
aspect oriented programming aop provides features like advice and pointcut that are similar to our before andafter actions and to the use of regular expressions that match target functions in our rules respectively.
an aop framework for assembly would have simplified the implementation of our approach but to our knowledge such a framework does not exist.
frameworks that automate stub injection are usually tied to a particular runtime environment like detours for unmanaged code moles for .net and javassist for java.
we build upon and extend detours and the .net profiling api to support automatic stub injection for both managed and unmanaged code.
moreover our framework provides support for the process of writing stubs and injecting them in an application under test from start to finish.
error handling code has been targeted by numerous fault injection techniques.
in general software implemented fault injection comprises three categories .
data error injection performs low level data corruption.
techniques that inject code changes either simulate faulty instruction decoding or common error patterns.
interface error injection corrupts values passed between modules e.g.
a library and its client .
many prominent approaches in this category focus on testing the robustness of the callee e.g.
a library.
in contrast to these the lfi framework aims at finding bugs in clientsdue to imperfect documentation of libraries.
although our framework can also be used to perform fault injection its purpose is much more general.
any code may be injected to augment or replace the functionality of any call.
error handling code has also been targeted by various static analyses .
in contrast to that work our purely dynamic approach does not report any false positives as long as the defined stub behaviors are realistic.
moreover the detected crashes are reproducible and can be examined using standard debuggers.
a core originality of our approach is a domain specific language for expressing the behavior of stubs as well as injection strategies.
in comparison to related work our dsl is more human readable flexible and expressive.
although we do not infer the stubs there is related work that infers what faults to inject as well as error specifications .
we compensate by supporting reusable stubs and avoid any spurious errors due to inference by pushing the responsibility to write realistic stubs to the user.
our statistical methodology to identify crashes that are more likely to point to real bugs is inspired by engler et al.
and follow up work on specification mining and program repair .
their work applies to classes of bugs broader than those considered in sect.
v. however our more limited scope and dynamic approach allowed us to define a simple formula for determining the real bug indicator rbi i. this formula is also easy to compute automatically unlike for instance lfi s estimate which requires manual code inspection to determine false positives and negatives .
vii.
c oncluding remarks in this paper we introduced a general framework for dynamic stub injection.
our framework provides an expressive dsl for writing stub injection rules and implements a novel technique for dynamically injecting the specified stubs into both managed and unmanaged binaries.
in an extensive evaluation of several mature applications we used our framework to perform fault injection and discovered over crashes.
to prioritize the analysis of these crashes we devised an indicator that predicts the effectiveness of stub injection rules in finding real bugs.
we developed our approach for windows and .net but similar instrumentation techniques can be implemented for other platforms.
a promising direction for future work is to develop debugging support on top of our framework.
for instance debugging a crash caused by a stub injection might benefit from inspecting other calls that handle the same stub correctly.
given that our framework can automatically produce large numbers of correct and faulty executions one could also try to learn a likely program repair automatically.
moreover since an application might fail long after a stubbed call it would be useful to provide automatic support for determining the root cause of a crash for instance by comparing faulty and correct traces .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.