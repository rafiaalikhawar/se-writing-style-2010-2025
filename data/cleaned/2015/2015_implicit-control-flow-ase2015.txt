static analysis of implicit control flow resolving java reflection and android intents paulo barros ren just suzanne millstein paul vines werner dietl marcelo d amorim michael d. ernst federal university of pernambuco recife pe brazil pbsf damorim cin.ufpe.br university of washington seattle wa usa rjust smillst plvines mernst cs.washington.edu university of waterloo waterloo on canada wdietl uwaterloo.ca abstract implicit or indirect control flow is a transfer of control between procedures using some mechanism other than an explicit procedure call.
implicit control flow is a staple design pattern that adds flexibility to system design.
however it is challenging for a static analysis to compute or verify properties about a system that uses implicit control flow.
this paper presents static analyses for two types of implicit control flow that frequently appear in android apps java reflection and android intents.
our analyses help to resolve where control flows and what data is passed.
this information improves the precision of downstream analyses which no longer need to make conservative assumptions about implicit control flow.
we have implemented our techniques for java.
we enhanced an existing security analysis with a more precise treatment of reflection and intents.
in a case study involving ten real world android apps that use both intents and reflection the precision of the security analysis was increased on average by two orders of magnitude.
the precision of two other downstream analyses was also improved.
i. i ntroduction programs are easier to understand and analyze when they use explicit control flow that is each procedure call invokes just one target procedure.
however explicit control flow is insufficiently flexible for many important domains so implicit control flow is a common programming paradigm.
for example in object oriented dispatch a method call invokes one of multiple implementations at run time.
another common use of implicit control flow is in design patterns many of which add a level of indirection in order to increase expressiveness.
this indirection often makes the target of a procedure call more difficult to determine statically.
implicit control flow is a challenge for program analysis.
when a static analysis encounters a procedure call the analysis usually approximates the call s behavior by a summary which conservatively generalizes the effects of any target of the call.
if there is only one possible target as with a normal procedure call or a small number that share a common specification as with object oriented dispatch the summary can be relatively precise.
but if the set of possible targets is large then a conservative static analysis must use a very weak specification causing it to yield an imprecise result.
the imprecision is caused by a lack of information about possible call targets and about the types of data passed as arguments at each call.
the goal of this paper is to provide a sound and sufficiently precise estimate of potential call targets and of the encapsulated data communicated in implicit invocations in order to improve the precision of downstream program analyses.
our evaluation focuses on a particular domain android mobile apps in which implicit invocation significantlydegrades static analysis.
in our experience the largest challenge to analyzing android apps is their use of reflection and intents and this led us to our research on resolving implicit invocation.
we are not aware of a previous solution that handles reflection and intents soundly and with high precision.
reflection permits a program to examine and modify its own data or behavior .
our interest is in use of reflection to invoke procedures.
for example in java an object mof type method represents a method in the running program m can be constructed in a variety of ways including by name lookup from arbitrary strings.
then the java program can call m.invoke ... to invoke the method that mrepresents.
other programming languages provide similar functionality including c go haskell javascript ml objective c php perl python r ruby and scala.
android intents are the standard inter component communication mechanism in android.
they are used for communication within an app an app may be made up of dozens of components between apps and with the android system.
an android component can send or broadcast intents and can register interest in receiving intents.
the android architecture shares similarities with blackboard systems and other messagepassing and distributed systems.
by default a sound program analysis must treat reflection and intents conservatively the analysis must assume that anything could happen at uses of reflection and intents making its results imprecise.
we have built a simple conservative and quite precise static analysis that models the effects of reflection and intents on program behavior.
the key idea is to resolve implicit control and data flow first to improve the estimates of what procedures are being called and what data is being passed as a result those constructs introduce no more imprecision into a downstream analysis than a regular procedure call does.
both control flow and data flow are important.
for reflection our approach handles control flow by analyzing reflective calls to methods and constructors to estimate which classes and methods may be manipulated and it handles data flow via an enhanced constant propagation.
for intents our approach handles control flow by using previous work to obtain component communication patterns and it handles data flow by analyzing the payloads that are carried by intents.
we have implemented our approach for java.
we evaluated our implementation on open source apps in the context of three existing analyses most notably an information flow type system for android security .
most android apps use reflection and or intents so accurately handling reflection and 1our approach does not change the program s operations either on disk or in memory in the compiler see section iii b.intents is critical in this domain.
unsoundness is unacceptable because it would lead to security holes and poor precision would make the technique unusable due to excessive falsepositive alarms.
the reflection and intent analyses increased the precision of the information flow type system by two orders of magnitude and they also improved the precision of the other two analyses.
furthermore they are easy to use and fast to run.
our implementation is freely available in the sparta toolset including source code and user manual and the reflection analysis is also integrated into the checker framework the rest of this paper is structured as follows.
section ii presents two motivating examples.
sections iii and iv present our analyses that resolve reflection and intents.
section v formally analyzes the typing rules.
section vi evaluates how the reflection and intent analyses improve the precision of downstream analyses.
section vii shows how the type inference rules reduce programmer effort.
section viii discusses related work and section ix concludes.
ii.
m otivating examples our work improves the precision of a downstream static analysis by eliminating false positive warnings in cases of implicit control flows.
imprecision due to implicit control flow affects every static analysis.
for concreteness consider a noninterference type system which guarantees that the program does not leak sensitive data.
the noninterference type system distinguishes high securitylevel values from low security level values for brevity high and lowvalues.
the static property checked is that values in high variables are not assigned to lowvariables which would leak sensitive data.
variables and expressions marked high may hold a lowvalue at run time this is also expressed as low high where the symbol denotes subtyping.
to use this type system a user annotates each type with high orlow the default being low.
the type system is conservative if it issues no warnings then the program has no interference and running it does not leak any high data to lowcontexts.
when run on the android app aard dictionary http aarddict.org the noninterference type system issues false positive warnings due to its conservative handling of implicit control flows.
when our reflection and intent analyses are integrated into it the type system remains sound but no longer issues the false positive warnings.
the examples in this section use a noninterference type system but other type systems suffer similar false positives.
our reflection and intent analyses also help other downstream analyses as demonstrated in section vi d. a. reflection some calls to method.invoke return a high value at run time.
thus the signature of method.invoke line of figure must have a high return type any other return type in the summary would be unsound.
some calls to method.invoke always return a lowvalue.
the conservative signature of method.invoke causes false positive warnings in such cases.
figure illustrates the problem in aard dictionary .
the component articleviewactivity uses an actionbar which is a feature that was introduced in version of the android api.
in order to prevent run time errors for a user who has an older version of android and also to enable the app to compile when1 class articleviewactivity extends activity void oncreate bundle savedinstancestate if android.os.build.version.sdk int android version and later has action bar method getactionbar getclass .getmethod getactionbar low object actionbar getactionbar .invoke this ... library annotations class method high object invoke object obj object ... args ... class activity only exists in android sdk and above.
low actionbar getactionbar ... fig.
.
a noninterference type checker produces a false positive warning on line where the return type of method.invoke of type high is assigned to variable actionbar which has declared type low.
the call on line always returns a lowvalue at run time even though other calls to invoke may in general return a high value so the assignment is safe.
when the noninterference type system is augmented by our reflection analysis it no longer issues the false positive warning.
a developer is using an older version of the android api this app uses reflection to call methods related to the actionbar .
the noninterference type checker issues a false positive due to the use of reflection our reflection analysis section iii eliminates the false positive warning.
b. android intents an android component might send a high value via an intent message to another component therefore the summary for methods that retrieve data from an intent lines of figure must conservatively assume that the data is a high value.
this conservative summary may cause false positive warnings when the data is of type lowat run time.
figure shows another example from aard dictionary .
the components dictionarymain and wordtranslator use android intents to communicate.
android intents are messages sent between android components and those messages contain extras which is a mapping of keys to objects.
component dictionarymain creates an intent object i adds low security extra data to i s extras mapping and on line calls the android library method startactivity to send the intent.
the android system then calls wordtranslator.oncreate which is declared on line .
the noninterference type checker issues a false positive due to the use of intents our intent analysis section iv eliminates the false positive warning.
iii.
r eflection resolution reflection is a metaprogramming mechanism that enhances the flexibility and expressiveness of a programming language.
its primary purpose is to enable a program to dynamically exhibit behavior that is not expressed by static dependencies in the source code.
reflection is commonly used for the following four use cases among others.
provide backward compatibility by accessing an api method that may or may not exist at run time.
the reflective code implements a fallback solution so the app can run even if a certain api method does not exist e.g.
on older devices.
access private api methods and fields class dictionarymain extends activity void translateword int source int target string word intent i new intent this wordtranslator .class i.putextra source source i.putextra target target i.putextra word word startactivity i class wordtranslator extends activity void oncreate bundle savedinstancestate intent i getintent low int source i. getintegerextra source low int target i. getintegerextra target low string word i. getstringextra word showresult translate source target word string translate int source int target string word ... intent getintent ... void showresult string result ... library annotations class intent high integer getintegerextra string key ... high string getstringextra string key ... fig.
.
a noninterference type checker produces false positive warnings on lines where the return type of get extra of type high is assigned to variables with declared type low.
the calls on lines always return a lowvalue at run time even though other calls to get extra may in general return a high value so the assignments are safe.
when the noninterference type system is augmented by our intent analysis it no longer issues the false positive warnings.
which offer functionality beyond what is provided by the public api.
implement design patterns such as duck typing.
code obfuscation to make it harder to reverse engineer the program e.g.
code that accesses premium features that require a separate purchase.
the android developer documentation encourages the use of reflection to provide backward compatibility and for code obfuscation and of apps in the f droid repository use reflection.
not all uses of reflection can be statically resolved but our experiments show that many of them can.
whenever the developer runs a code analysis it is beneficial to the analysis if as much reflection as possible is resolved in order to reduce false positive warnings.
obfuscation is not compromised because analysis results annotations and other information that is used in house by the developer need not be provided to users of the software.
approach for reflection resolution without further information about what method is reflectively called a static analysis must assume that a reflective call could invoke any arbitrary method.
such a conservative assumption increases the likelihood of false positive warnings.
at each call to method.invoke our analysis soundly estimates which methods might be invoked at runtime.
based on this estimate our analysis statically resolves the method.invoke call that is it provides type information about arguments and return types for a downstream analysis.
the results are soundly determined solely based on information available at compile time.
the reflection resolution consists of the following parts reflection type system tracks and infers the possible names of classes methods and constructors used by reflective calls.
section iii a reflection resolver uses the reflection type system to estimate the signatures of methods or constructors that can be invoked by a reflective call.
section iii b a. reflection type system our reflection type system refines the java type system to provide more information about array class method and constructor values.
in particular it provides an estimate for each expression of those types of the values they might evaluate to at run time.
for expressions of type class there are two possible type qualifiers classval and classbound representing either an exact class value or an upper bound of the class value.
for example classval java.util.hashmap indicates that the class object represents the java.util.hashmap class.
alternatively classbound java.util.hashmap indicates that the class object represents java.util.hashmap or a subclass of it.
for expressions of type method and constructor the type qualifier indicates estimates for the class method name and number of parameters.
for example methodval cn java.util.hashmap mn containskey containsvalue np indicates that the method represents either hashmap.containskey orhashmap.containsvalue with exactly parameter.
likewise the methodval type may have more than one value for the class name or number of parameters.
the represented methods are the cartesian product of all possible class names method names and numbers of parameters.
for a constructor the method name is init so no separate constructorval type qualifier is necessary.
the methodval type is imprecise in that it indicates the number of parameters that the method takes but not their type.
this means that the type system cannot distinguish methods in the uncommon and discouraged case of method overloading.
this was a conscious design decision that reduces the verbosity and complexity of the annotations without any practical negative consequences.
in our experiments with more than lines of java code this imprecision in the type system never prevented a reflective call from being resolved.
our implementation caps the size of a set of values at .
this cap was never reached in our case studies.
if a programmer writes or the type system infers a set of values of size larger than then the type is widened to its respective top type.
a top type indicates that the type system has no estimate for the expression the type system s estimate is that the run time value could be any value that conforms to the java type.
the top type is the default and it is represented in source code as the absence of any annotation.
type checking the reflection type system enforces standard type system guarantees e.g.
that the right hand side of an assignment is a subtype of the left hand side.
these typing rules follow those of java they are standard for an object oriented programming language and they are familiar to programmers.
therefore we do not detail them in this paper.
the reflection type system and our implementation are compatible with all java features including generics type polymorphism .
type inference programmers do not need to write type annotations within method bodies because our system performs local type inference.
more specifically for local variables casts and instanceof expressions the absence of any annotatione string valis the statically computable value of e e stringval val e int valis the statically computable value of e e intval val e intval p new c arraylen p new c e1 ... en arraylen n fig.
.
inference rules for stringval intval and arraylen .
fqnis the fully qualified class name of c c.class classval fqn s stringval n class.forname s classval n fqnis the fully qualified class name of the static type of e e.getclass classbound fqn e classbound n e classval n s stringval p arraylen p e.getmethod s p methodval cn n mn np p e classval n p arraylen p e.getconstructor p methodval cn n mn init np p fig.
.
selected inference rules for the classval classbound and methodval annotations.
additional rules exist for expressions with similar semantics but that call methods with different names or signatures and for fields returns.
indicates that the type system should infer the most precise possible type from the context.
for all other locations notably fields method signatures and generic type arguments a missing annotation is interpreted as the top type qualifier.
the local type inference is flow sensitive.
it takes advantage of expression typing rules that yield more precise types than standard java type checking would.
a estimates for values of expressions we have designed and implemented a dataflow analysis that infers and tracks types providing an estimate for the possible values of each expression.
our implementation goes beyond constant folding and propagation it evaluates side effect free methods it infers and tracks the length of each array and it computes a set of values rather than just one.
for example arraylen indicates that at run time the array has length or .
figure shows selected inference rules.
the reflection type system builds on top of this dataflow analysis.
b inference of classval and classbound the reflection type system infers the exact class name classval for aclass literal c.class and for a static method call e.g.
class .forname arg classloader.loadclass arg .
.
.
if the argument has a sufficiently precise stringval estimate.
in contrast it infers an upper bound classbound for instance method calls e.g.
obj.getclass .
an exact class name is necessary to precisely resolve reflectively invoked constructors since a constructor in a subclass does not override a constructor in its superclass.
either an exact class name or a bound is adequate to resolve reflectively invoked methods because of the subtyping rules foroverridden methods.
c inference of methodval the reflection type system infers methodval types for methods and constructors that have been created via java s reflection api.
a nonexhaustive list of examples includes calls to class.getmethod string name class ?
... paramtypes and class.getconstructor class ?
... paramtypes .
for example the type inferred for variable getactionbar on line of figure is methodval cn articleviewactivity mn getactionbar np .
although figure uses raw non parameterized types our inference supplies the missing type argument information.
d inference of field types for private fields our type inference collects the types of all assignments to the field and sets the field type to their least upper bound lub .
if the lub is not a subtype of the declared type this step is skipped and a type checking error will be issued at some assignment.
the same mechanism works for non private fields but the entire program has to be scanned for assignments.
at the end of type checking the type checker outputs a suggestion about the field types.
the user may accept these suggestions and re run type checking to obtain more precise results we did so in our experiments.
field type inference works for every type system not just those related to reflection.
e method signature inference similarly to field type inference private method parameters are set to the lub of the types of the corresponding arguments and private method return types are set to the lub of the types of all returned expressions when those are consistent with the declared types.
for non private methods the entire program is scanned for calls overriding and the type checker outputs suggestions.
figure shows selected inference rules for the reflection type system.
b. reflection resolver prior work see section viii commonly re writes the source code or changes the ast within the program analysis tool changing a call to method.invoke into a call to the method that is reflectively invoked before analyzing the program.
this approach interferes with the toolchain preventing the code from being compiled or run in certain environments.
this approach is also at odds with the very purpose of reflection the program no longer adapts to its run time environment and loses properties of obfuscation.
a final problem is that an analysis may discover facts that cannot be expressed in source code form.
our reflection resolver operates differently it leaves the program unmodified but narrows the procedure summary the specification of parameter and return types used during modular analysis for that particular call site only.
when the downstream analysis requests the summary at a call tomethod.invoke it receives the more precise information rather than the conservative summary that is written in the library source code.
this transparent integration means that the downstream analysis does not need to be changed at all to be integrated with the reflection analysis.
c. example recall the example of figure .
when the noninterference type system analyzes getactionbar.invoke this on line it uses a method summary like a declaration to indicate the requirements and effects of the call.
ordinarily it would use the following conservative declaration for method.invoke high object invoke object recv object ... args however the reflection type system inferred that the type of variable getactionbar is methodval cn articleviewactivity mn getactionbar np .
in other words at run time the invoked method will be the following one from class articleviewactivity low actionbar getactionbar thus the noninterference type system has a precise type low for the result of the invoke call.
the reflection resolver provides the following precise procedure summary to the downstream analysis for this call site only low object invoke object recv object ... args as a result the type system does not issue a false positive warning about the assignment to variable actionbar on line .
the summary contains not just refined procedure return types as shown above but also refined parameter types enabling a downstream analysis to warn about clients that pass arguments that are not legal for the reflectively invoked method.
it would be possible to refine the java types as well as the type qualifiers for instance to warn about possible run time type cast errors or to optimize method dispatch but our implementation does not do so.
if the reflectively called method or constructor cannot be resolved uniquely the reflection resolver determines the least upper bound of all return values and the greatest lower bound of all parameter and receiver types.
iv.
a ndroid intent analysis an android app is organized as a collection of components that roughly correspond to different screens of an application and to background services.2some apps consist of dozens of components.
intents are used for inter component communication both within an app and among different apps.
intents are similar to messages communicated asynchronously across components.
sending an android intent implicitly invokes a method on the receiving component just as making a reflective procedure call implicitly invokes a method.
the use of intents is prevalent in android apps all top popular paid apps and top popular free apps from the google play store use intents the top most popular apps contain a total of intercomponent communication locations and intents are a potential target for attackers to introduce malware .
intents present two challenges to static analyses i control flow analysis or determining which components communicate with one another and ii data flow analysis or determining what data is communicated.
both parts are important.
an existing analysis epicc partially solves the control flow challenge.
section iv a describes how our implementation uses epicc to compute component communication.
our key research contribution is to address the data flow challenge which has resisted previous researchers.
section iv b presents a novel static analysis that estimates the data passed in an android intent.
the structure of android intents in addition to attributes that specify which components may receive the intent an intent contains a map from strings to arbitrary data called extras .
the extras map is used to pass additional information that is 2activity service broadcastreceiver and contentprovider are the four kinds of android components.
see fundamentals.html components.needed to perform an action.
for example an intent used to play a song contains the song s title and artist as extras.
an invocation of the putextra method adds a key value entry to the intent map which can be looked up via the getextra method call.
without loss of generality we will consider that every intent attribute is an entry in the map of extras.
the use of extras is prevalent in android of the apps in the f droid repository use intents with extra data.
figure shows the common use case of an android app sending and receiving an intent containing extras.
a. component communication patterns to precisely analyze the types of data sent through intents our analysis requires sendintent calls to be matched to the declarations of onreceive methods they implicitly invoke.
we express this matching as a component communication pattern ccp a set of pairs of the form hsendintent a i onreceive b j i. each pair in the ccp indicates that components aandb possibly from different apps may communicate through intents iand j which intuitively denote the actual arguments and formal parameters of the implicit invocation.
to precompute an approximated ccp our current implementation uses apkparser dare and epicc .
our implementation inherits epicc s limitations.
note however that epicc s limitations are not inherent to our intent analysis and they would disappear if we used a better analysis to compute ccp.
as better ccp techniques become available they can be plugged into our implementation.
ic3 is epicc s successor created by the same research group.
we attempted to use ic3 but we discovered a soundness bug dynamically registered broadcast receivers were not being analyzed.
the ic3 authors have confirmed but not fixed the bug3 so we used epicc instead.
we now discuss sources of imprecision and unsoundness due to epicc.
epicc s sources of imprecision.
epicc s lack of support for uris leads to imprecision since intents with the same action and category but different uris are conservatively considered equal.
as expected of a static analysis epicc also cannot handle cases where dynamic inputs determine the identity of receiver components.
epicc also handles this conservatively all components are considered possible receivers.
furthermore the points to and string analyses used by epicc are also sources of imprecision.
even with these limitations all mentioned in epicc reports precision in a case study with apps.
epicc s sources of unsoundness.
epicc unsoundly assumes that android apps use no reflection.
we used the type system of section iii to circumvent this limitation see section vi.
epicc also unsoundly assumes that android apps use no native calls a standard limitation of static analysis that is shared by ic3.
recall that while finding ccp is necessary it is not sufficient.
since acceptable solutions exist for finding ccp the focus of our intent analysis is the unsolved problem of estimating the payloads of intents which is discussed below.
b. intent type system this section presents a type system for android intents.
the type system verifies that the type of data stored within an intent conforms to the declared type of the intent even in the presence of implicit invocation via intents.
simplicity this paper abstracts all methods that send intents as the method sendintent and all methods that receive an intent as the method onreceive .
for example in figure startactivity called on line is an example of a sendintent method and the method getintent declared on line is an example of an onreceive method.
the type system verifies that for any sendintent method call and any onreceive method declaration that can be invoked by the call site the intent type of the argument in the sendintent call is compatible with the intent type of the parameter declared in the onreceive method signature.
intent types we introduce intent types which hold key type pairs that limit the values that can be mapped by a key.
syntax of intent types.
this paper uses the following syntax for an intent map type intent k1 !t1 ... kn !tn intent i ... where k1 .
.
.
kn is a set of literal strings and t1 .
.
.
tn is a set of types.
the type of variable iabove consists of a type qualifier intent ... and a java type intent .
the regular java type system verifies the java type and our intent type system verifies the type qualifier.
the actual java syntax used by our implementation is slightly more verbose than that in this paper intent entry key k1 type t1 ... entry key kn type tn intent i ... semantics of intent types.
if variable iis declared to have an intent type t then two constraints hold.
c1 the keys of ithat are accessed must be a subset of t s keys.
it is permitted for the run time value of variable ito have more keys than those listed in t but they may not be accessed.
it is also permitted for the run time value of variable ito have fewer keys than those listed in t any access to a missing key will return null.
c2 for every key kint either kis missing from the run time key set of i or the value mapped by kin the run time value of ihas the type mapped by kint.
this can be more concisely expressed as8k2domain t i t where indicates typing and null is a value of every non primitive type.
example.
the example below illustrates the declaration and use of intent types.
the symbols a b and cdenote type qualifiers such as high and low of the noninterference type system.
on the left is the type hierarchy of these type qualifiers.
c1 and c2 are the two constraints described above.
intent akey !
c intent i ... a a int e1 i.getintextra akey legal c int e2 i.getintextra akey legal b c b int e3 i.getintextra akey violates c2 i.getintextra otherkey violates c1 type system rules figure shows the typing rules for the intent type system.
these rules are organized into three categories according to their purpose.
subtyping rules define a subtyping relation for intent types well formedness rules define which constructions are acceptable and typing judgment rules define the types associated with different language expressions.
a subtyping st intent type t1is a subtype of intent type t2if the key set of t2is a subset of the key set of t1and for each key kin both t1andt2 kis mapped to the same type.
intent akey !t anotherkey !t intent i1 ... intent akey !t intent i2 ... intent anotherkey !t intent i3 ... i2 i1 legal i1 i3 illegalsubtyping st 8k2keys t2 k2keys t1 t1 t2 t1 t2 cp 8k2keys t2 k2keys t1 t1 t2 t1 copyable t2 well formedness or no precondition void onreceive ti typing judgments si 8onreceive b j hsendintent a i onreceive b j i2ccp i ti j tj ti copyable tj sendintent a i int pe1 e t v t k2keys t s stringval k e putextra s v t pe2 e t k 2keys t eis unaliased s stringval k e putextra s v t ge e t k2keys t s stringval k e getextra s t fig.
.
type system for android intents.
standard rules are omitted.
the mapped types must be exactly the same use of a subtyping requirement t1 t2 instead of equality t1 t2 would lead to unsoundness in the presence of aliasing.
the example below illustrates this problem.
on the left is the type qualifier hierarchy.
c string c a intent akey !
b intent i1 intent akey !
a intent i2 b c i2 i1 illegal i2.putextra akey c it would be incorrect to allow the assignment i2 i1 in this example even though the assignment is valid according to standard object oriented typing.
in this case the call to putextra would store in the object pointed by i1 a value of incorrect type at key akey.
this happens because the