call graph construction for java libraries michael reif michael eichberg mira mezini1 abstract today every application uses software libraries.
yet the research which targets the analysis oflibraries independent of any application is scarce.
this is unfortunate because for library developers e.g.
those of the java development kit jdk it is crucial that the library behaves as intended regardless of how it is used.
in this paper we discuss the construction of call graphs for libraries that abstract over all potential library usages.
unlike algorithms for applications call graph construction algorithms for libraries should distinguish between analyses w.r.t.
potential exploitable vulnerabilities and those related to general software quality attributes.
this distinction afects the decision about what constitutes the library private implementation which therefore needs special treatment.
thus building one call graph that satis es all needs is not sensical.
keywords call graph construction libraries java summary call graphs are a major building block of static analyses.
they are e.g.
directly used to identify dead methods or act as foundation for more complex algorithms such as solvers for data ow problems ow sensitive points to algorithms or security related analyses.
despite the the over all presence of libraries in software development a systematic discussion of constructing call graphs for libraries and their speci c needs is missing.
currently the gold standard for constructing library call graphs is to use a standard algorithm such as class hierarchy analysis cha or variable type analysis vta and to consider all non private methods as entry points.
however this ignores two properties that distinguish libraries from stand alone applications.
first libraries are not closed worlds they are extended by their users via inheritance.
second libraries consist of classes and interfaces that de ne the public api and those which belong to the library private implementation i.e.
the part of the library that is only used internally and cannot be accessed by the libraries users.
ignoring the rst property leads to call graphs that miss important edges ignoring the second property leads to call graphs with many spurious edges.
hence for security focused analyses everything that could be extended should be treated as extensible for software quality oriented analyses a ne grained identi cation of the library private implementation which takes generally accepted practices into account 1technische universit t darmstadt softwaretechnik hochschulstra e darmstadt germany reif eichberg mezini cs.tu darmstadt.de cbem.
tichy e. bodden m. kuhrmann s. wagner j. p. stegh fer hrsg.
se lecture notes in informatics lni gesellschaft f r informatik bonn 119should be performed.
consequently we argue that call graph construction algorithms for libraries must distinguish between two usage scenarios of the library.
in the rst scenario the library is assumed to be open i.e.
all non private classes elds and methods can be accessed non nal classes can be extended and non nal methods can be overridden.
we use the term open package assumption opa to refer to this assumption and corresponding call graphs represent the unrestricted usage scenarios of the library.
in the second scenario only the code that belongs to a library s public api is used or gets extended.
in java e.g.
a library s classes and methods with package visibility do not belong to the public api.
additionally all code that can only be reached via code that does not belong to the public api is also considered to belong to the library s implementation irrespective of its visibility.
we refer to this case as the closed package assumption cpa .
under cpa the public api re ects the usage interface that library designers intend to provide to users.
cpa directly re ects the generally accepted practice do not add code to the namespace of a 3rd party library which is already mandated by the rst versions of the java language speci cation .
since then libraries are generally developed based on this assumption which represents the intended usage scenarios of the library.
we argue that it is not possible to adequately address both scenarios by using the same callgraph algorithm any such algorithm would be either unnecessarily unsound or imprecise depending on the usage scenario.
as a result we propose and evaluate two call graph algorithms for libraries w.r.t.
opa and cpa.
both algorithms libcha opaand libcha cpa build upon the cha algorithm.
the rst algorithm libcha opa is sound under the open package assumption makes worst case assumptions and can be used to identify security e.g.
trusted method chaining attacks .
however the conservative algorithm may produce many spurious call graph edges under cpa.
this may lead to incorrect results false positives and false negatives when used for analyzing a library s implementation w.r.t.
general software quality attributes.
we provide the implementation and all related data of our approach here implemented within the opal project evaluation data via docker .