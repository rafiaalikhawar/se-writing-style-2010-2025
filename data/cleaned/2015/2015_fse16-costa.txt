tipmerge recommending experts for integrating changes across b ranch es catarina costa1 jair figueiredo1 leonardo murta2 anita sarma3 1federal un iversity of acre rio branco ac brazil catarina jjcfigueiredo ufac.br 2fluminense federal university niteroi rj brazil leomurta ic.uff.br 3oregon state university corvallis usa anita.sarma oregonstate.edu abstract parallel development in branches is a common software practice .
however past work has found that integration of changes acros s branches is not easy and ofte n leads to failures.
thus far there has been little work to recommend developers who have the right expertise to perform a branch integration.
w e propose tipmerge a novel tool that recommends developers who are best suited to perform merge s by taking int o consideration developers past experience in the project their changes in the branches and dependencies among modified files in the branches.
we evaluated tipmerge on projects which included up to merges with at least two developers and potentially conflicting changes .
on average of the top recommendations by tipmerge correctly included the developer who performed the merge .
best accuracy results of recommendations were at .
our interviews with developers of two projects reveal that in cases where the tipmerge recommendation did not match the actual merge developer the recommended developer had the expertise to perform the merge or was involved in a collaborative merge sess ion.
ccs concepts software and its engineering software configuration management and version control systems .
keywords version control branch merge expertise recommendation .
.
introduction parallel development is a common practice to manage time to market isolate new features from bug fixes segregate development teams implement customizations etc.
branching is the most commonly adopted mechanism to support parallel development for code u nder version control .
changes made in branch es need to be reintegrated periodically through a merge operation .
this operation comb ines two independent and usually long sequences of commits which can potentially hold numerous contributions from different developers .
for instance i n previous work we observe d a merge in the rails proje ct that included commits made by developer s in one branch and developers in the other .
in fact our data from projects show that on an average .
median .
of such merges involved changes from at least three developers.
and such merges occurred frequently around every days medi an .
moreover integrating changes across branches is not easy.
i n a stack overflow discussion a developer laments when trying to merge the changes on the trunk with a branch there are conflicts on different files which are authored and maintained by different developers .
merging branches is difficult because first conflicts can arise especially in long living branches .
shihab et al.
found that the adoption of branches cause integration failures due to conflicts or unseen dependencies.
secon d when conflicts do occur it is not always clear which changes to keep and which to reject.
the developer performing a merge might not fully understand the changed code or t he rationale behind the change or may not have the expertise to determine the impact of the change since they do not fully understand the dependencies in the project .
unfortunately existing support for integrating branches is rudimentary.
most tools usually detect only direct i.e.
textual conflicts and transfer the responsibility of resolving conflicts to the developer in charge.
in complex merge situations developers may not have the knowledge to make the right decision.
for instance a survey with developers showed that when performing a merge people frequently made decisions with which they were uncomfortable.
this is likely a reason for developers perform ing collaborative merge sessions .
however identifying the appropriate developers to perform a merge is no ntrivial too .
inviting all involved developers to a merge session is infeasible due to cost physical space and developer availability.
whereas inviting a few developer s to the merge session requires enough knowledge about the project to prioritize among developers who are aware of the project history the dependencies in the project and the changes in the branches.
recent work has investigated developer recommendations to analyz e pull request .
however these approaches fall short for branch integration.
while pull request s refer to remote lines of development that need to be merged these branches usually contain few commits by a single developer .
further the author of the pull request usually syncs their forked branch in advance to eas e reintegration maki ng the process more like a workspace commit .
in the case of long living branch integration we need to differentiate changes within and across branches and from history.
moreover multiple files change in parallel and multiple developers edit in a bran ch thus accruing varying expertise among artifacts and their dependencies.
we need to accommodate these differences in the knowledge of developers and their contributions which has not been done before .
in this paper we propose tipmerge a novel tool that identifies the most appropriate developers to merge branches .
for a given pair of branch es tipmerge first identifies key files and the developers who have made changes to them in each branch .
key f iles are files that are changed in parallel across the branches which can lead to direct conflicts or files that have changed in one branch but have dependencies with other changed files in the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
r equest permissions from permissions acm.org .
fse november seattle wa usa .
acm.
isbn ... .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
523other branch which can cause indirect conflicts .
tipmerge then identifies overall experience of developers with the key files based on the project and branch history .
after analyzing this information tipmerge recommends a rank ed list of developers who are best suited to integrate a pair of branch .
to empirically evaluate our approach we measure the accuracy of the recommend ations .
we use top and top accuracy as the likelihood that the correct developer is in the first k or recommendations.
we also measure the normalized accuracy improvement over the majority class the deve lopers who have done most of the merges.
we analyzed software projects which included merges with at least unique developers and potentially conflicting changes .
on average of the top recommendation s by tipmerge correctly included the developer who performed the merge.
the best accuracy was obtained in the diploma project.
moreover in of the merges tipmerge obtained higher accuracy than selecting the developer who performed most of the previous merges i.e.
the majority class .
to better understand the cases were tipmerge made incorrect recommendation s we interviewed developers from two of the projects.
in several of these cases the developers a greed that the tipmerge recommendation was also valid .
in some cases the developers ceded that tipmerge recommend ation was more appropriate.
in other situations we found that the recommended developer had in fact participated in a collaborative merge .
this paper makes the following contributions approa ch.
we present a novel approach that analyzes change history in branches file dependencies and the past history to recommend expert developers to merge branches.
implementation .
we implemented our approach in a tool that uses a medal based ranking system to recommend developers.
empirical evaluation .
we quantitatively evaluat ed realworld projects to show that tipmerge has high normalized accuracy improvement s over the majority class top recommendation in lantern .
and top recommendation s in diploma .
.
our qualitative data interview analysis show that different factors e.g.
development role skills past collaboration affect who actually performs the merge .
.
tipm erge the primary goal of tipmerge is to recommend developers with the expertise to merge changes across two branches by leveraging the project history.
our approach has the following steps .
extract data from the repository until the branch tips the two most recent commits of the two branches that will be merg ed.
.
detect dependencies among files by identifying files that were frequently co committed logical coupling .
we calculate dependencies from the data before the branch creation .
.
identify developers who edited key files files that were edited in both branches or had dependencies across branches see section .
.
we collect this information for changes in branches as well as previous history .
.
recommend a rank ed list of suitable candidates to perform the merge based on a medal count system see section .
.
.
scenario before describ ing our approach we present an intentionally simp le scenario to illustrate the use of branches.
let us consider a hypothetical project calculator which employ s a feature branch in parallel to the master branch to implement advanced operations.
figure presents a commit history that includes these two branches and four developers alice peter bob and tom.
let us assume that bob create s a feature branch from the master c50 and perform s three commits c51 c54 and c56 .
tom also commit s to this branch c57 .
alice and peter continue to work in the master branch in parallel.
alice perform s two commits c52 and c53 followed by two commits from peter c55 and c58 .
let us further assume that alice and bob chang e the same files quadraticequation and subtraction across the branches see table and table .
peter changed files multiplication and division in the master branch .
tom changed only file iequation in the feature branch.
however there is a logical dependency file quadraticequa tion depends on file iequatio n. figure .
example of merging branches in our example developers are unaware of changes made in anothe r branch.
therefore alice does not know about the parallel changes made by bob to quadraticequation and subtraction in the feature branch .
a merge of the branches will generate a merge error due to direct conflicts .
further tom changed iequation in the feature branch on which quadraticequation depends and is changed by alice in the m aster branch .
a merge of these branches can generate build or test failure due to indirect conflicts .
additionally table shows a hypothetical edit history of the project files before the branching .
alex had edited all the five files and anna four of the five files.
table .
commits in the master branch file name alice peter quadraticequation c52 c53 subtraction c53 multiplication c55 c58 division c55 c58 table .
commits in the feature branch file name bob tom quadraticequation c51 c56 subtraction c51 c54 c56 iequation c57 table .
contributions in history before branching file name alice bob tom alex anna quadraticequation subtraction multiplication division iequation we analyze information about changes across branches as well as the previous history because both are relevant for merging branches .
developers who have made changes in the branches know about recent changes that need to be integrated .
developers who have modified files in the past may know about the history and goals of the implementation.
.
data extract ion the first step in our approach is extracti ng the data about branches from the projects .
formal ly we can define a project p as a tuple f d c where f is a set of files d is a set of developers and c is a set of commits.
each commit ci c is a tuple fi ai pi where fi f is the set of files changed add remove or edit by ci ai d is the author of ci and pi c is the set of parent commi ts of ci figure .
figure simple versioning metamodel commits are organized in a directed acyclic graph e.g.
figure where the first commit of the project has no parent e.g.
commit c0 in figure revision commits have only one parent e.g.
commit c53 in figure and merge commits have two parents e.g.
commit c59 in figure .
all reachable com mits from ci form its history including ci itself and the transitive closure over its parents .
in figure c0 ... c51 c5 c56 c57 is the history of commit c57 .
the history of ci c is defined as hi c c c ci pj pj pi c hj two commits ci cj c that do not reach each ot her i.e.
ci hj cj hi are called variants e.g.
commits c57 and c58 in figure .
variants may have a common history which comprises all commits that exist in both histories .
in figure c0 ... c50 is the common histo ry of commits c57 and c58 .
the common history of ci cj c is defined as chi j hi hj the history of each variant also comprises commits that do not belong to the common history forming an independent line of development called branch history .
for example c51 c54 c56 c57 is the branch history of c57 when merging with c58 and c52 c53 c55 c58 is the branch history of c58 when merging with c57 figure .
as branches can be created from other branches the branch history may vary depending on the opposing branch as a consequence of different common histories .
the branch history of ci c when merging with cj c is defined as bhi j hi hj each branch history comprises a set of files changed by its commits.
the files changed in the branch history of ci c when merging with cj c is defined as fi j fk ck bhi j in addition file edited in the common history i.e.
fk ck chi j is extracted to determine expert ise over the key files.
currently we collect data of all past commits but the approach can be easily modified to only consider changes in a given time frame e.g.
past release to accommodate decay in experti se .
.
depen denc y detection next we identif y dependencies among files that are edited across branches.
this is vital since parallel changes to dependent files can cause indirect conflicts when the branches are integrated .
there are two different ways to identify dependencies using program analysis or logical coupling.
dependencies detected via program analysis typically ide ntify structural or syntac tic dependencies.
however such analysis techniques are language dependent .
logical coupling on the other hand detect evolutionary dependencies by identifying files or code that are frequently changed together and is language agnostic .
a majority of open source projects involve different languages and often times use a combination of different programming languages.
therefore w e use logical dependencies in our approach .
we use the edit history of the project before the branching occurred to determine d ependencies between pairs of files.
of course it is possible that these dependencies might change based on edits in the branches themselves.
however the past history provides us a baseline of these dependencies.
in future work we will investigate how de pendencies change from the baseline because of change in branch es and their effect on recommendation s. we only consider the impact of changes to dependent files across branches as we need to identify the expertise for branch merging.
we assume that all commits within the same branch have already been integrated in our scenario since peter and alice are working on the same master branch we assume that peter has integrated changes by alice prior to his commits.
to understand how we compute the logical dependenc ies across files let s assume that each file fl f has a set of dependencies depl f that are obtained by using an association rule mining technique .
an association rule is a pair x y of two disjoint entity sets x y f. in the notation x y x is called antecedent and y is called consequent .
it means that when x occurs y also occurs even if they are not structurally related .
however its probabilistic interpretation is based on the amount of evidence in the transactions which is determined by two metrics support the joint probability of having both antecedent and consequent and confidence the conditional probability of having the consequent when the antecedent i s present .
the confidence value can range from to where means that every time that the antecedent is changed the consequent is also changed.
in this case t he use of a threshold is necessary because low confidence implies low probability that changing a file causes impact in the dependent file.
therefore t he use of confidence instead of support allows us to define direction in the dependencies.
d evelopment team s have the freedom to decide the threshold above which a dependency becomes relevant.
our approach parameterizes the threshold and uses the value set by the user.
here after some empirical tests we have chosen a confidence threshold of .
to deter mine dependency.
in our scenario we have dependenc ies between the files quadraticequation and iequation .
iequation was changed in commits .
let us assume that of these commits also included changes to quadraticequation .
the confidence of the association rule iequation quadraticequation is .
.
based on a threshold of .
we say that quadraticequation depends on iequation .
as confidence is not symmetric the confidence value of the rule quadraticequation iequation can be different.
in our scenario quadraticequation was changed in commits and of these commits also included changes to iequation .
the conf idence of this rule is .
.
therefore iequation does not depend on quadraticequation .
.
key file author identification the next step in our approach is to identify the developers who have modified files that are relevant to the merging of the branc hes.
we term these files as key files which are defined as kfi j fk f fk fi j fj i fk fi j depk fj i fk fj i depk fi j fk depl fi j fl fj i fk depl fj i fl fi j key files are files changed in parallel in both branches e.g.
subtraction and quadraticequation or files that were changed in one branch e.g.
iequation but have a dependency with files that were changed in the other branch e.g.
quadraticequation both the dependen t and the file causing the dependency are considered as key files.
changes to the former class of files can cause a merge failure direct conflicts whereas changes to the latter 525class can potentially lead to test or build failures indirect conflicts .
o nly key files are relevant for us as all other files can be automatically merged safely.
files that were unchanged in either branch are irrelevant for the merge.
once we have identified the key files we identif y the developers who have changed these fil es in a branch which signals expert ise in the change or in the previous history which signals expert ise in the file .
in our scenario the key files are quadraticequation subtraction and iequation .
alice changed quadraticequation twice and subtraction once in the master branch .
bob changed the same files in the feature branch two and three times respectively .
moreover tom changed iequation once in the feature branch table and table .
in previous history alice changed quadraticequation bob changed subtract ion and tom changed iequation .
furthe r alex changed all the key files and anna changed two of them quadraticequation and iequation .
.
developer recommendation next we use an algorithm that counts the number and type of contribution changed in a branch or in the previous history to recommend a ranking of suitable candidates who can perform the merge.
we use a medal system to rank developers in the recommendation .
this is analogous to how countries are ranked in the olympic games based on medal counts .
the following rules define when developers receive gold silver and bronze medals .
a gold medal is awarded when a developer change s a key file in a branch.
the rationale is that the developer who changed a key file is the most know ledgeable about the change and its implications.
they probably are also well versed with the file in general and therefore likely to be able to perform additional edits during a merge if necessary .
gold medals are defined as gi j d fk kfi j ck bhi j ak d fk kfi j ck bhj i ak d a silver medal is awarded when a developer has changed a key file in the past.
developers who created or edited files in the past likely possess knowledge about the goals and requirements of these files which can be helpful .
silver medals are defined as si j d fk kfi j ck chi j ak d a bronze medal is awarded when a developer changes a file that depends on another file.
we assume that d evelopers who have changed a dependent file may have learned about the api or methods of the file that they are using.
consequently they may know the goals and expectations of such a file which may help in determining the impact of a change .
bronze medals are defined as bi j d depl fj i fl fk ck bhi j ak d depl fi j fl fk ck bhj i ak d we assign a medal for each file edited irrespective of the number of commits made.
in our scenario alice and bob each get one gold medal for subtraction even though alice committed the file once in the master branch and bob committed it three times in the feature branch.
similarly bob and alex each get one silver medal for subtraction because of their past changes before branching .
in our approach we assume that when a developer edits a file that developer has knowledge about the entire file.
while our approach can support a finer grained expertise calculation at the method level we leave it for future work.
our algorithm prioritizes developers with gold medals since they are the expert on the change and they have the most recent knowledge about the changed file.
in the case of a tie in the number of gold medals we use the number of silver medals to break the tie.
this is because everything being equal a developer who has more experience overall is likely to be more suitable in merging changes.
finally when there is a tie in the number of silver medals we consider bronze medals .
the notion is that if two developers have equal number of changes that they have made and equal knowledge of the project history a developer who has additional knowledge about another file is more suitable for the merge .
this medal ranking is formally def ined as ri j dr d gi j dr si j dr bi j dr gi j dr gi j dr gi j dr gi j dr si j dr si j dr si j dr si j dr bi j dr bi j dr table shows that alice and bob changed quadraticequation in the master and feature branches respectively earning them gold medals.
alice alex and anna also changed it in the previous history each receiving a silver medal .
subtraction was changed by alice and bob in the branches earning them a gold medal each.
bob and alex get si lver medals for editing subtraction file in the previous history .
only tom modified file iequation in the feature branch earning a gold medal and tom alex and anna changed this file in the previous history earning silver medals .
alice receives a bronze medal for iequation because she edited quadraticequation .
remember file iequation is a key file because quadraticequation depends on it and our assumption is that to be able to understand and edit the dependent file quadraticequation the developer must have some knowledge about the api of in this case the interface iequation .
table .
medals gold silver bronze file alice bob tom alex anna quadraticequation subtraction iequation by counting the medals and tie breaking when necessary we generate a developer ranking .
in our scenario alice has the same number of gold and silver medals as bob but she has a bronze medal which places her in the first position.
here t he first three candidates alice bob tom all have gold medals .
this implies that they each know about equal amounts of recent changes performed in the branches and the tie breakers involving dependency information or past changes differentiate them.
table .
ranking of candidates developer gold medal silver medal bronze medal 1st alice 2nd bob 3rd tom 4th alex 5th anna .
implementation tipmerge1 is implemented in java and is able to analyze project s versioned on git independently of their programming language2.
we adapted dominoes to identify logical dependencies among files across branches.
dominoes organizes data extracted from software repositories into matrices to denote relationships among software entities.
for e xample uff tipmerge 2tipmerge is language agnostic when analyzing expertise at the file level.
at the method level currently it only analyzes java projects.
526denotes the files that were changed by commits in the project.
these matrices are combined to depict higher order relationships such as logical dependencies among files t .
figure .
information about changes and dependencies to get the recommendation of developers to merge a pair of branches the user first selects two branches to merge figure a and triggers our recommendation analysis by clicking on the run button figure b .
once tipmerge analyzes the project information it shows for each developer the files that they have edited and the edit frequency in terms of commits figure c .
this information is provided for each branch both branches and previous history.
the user can also check the logical dependencies figure d by clicking at the see logical dependency button .
figure .
file dependencies and ranking in the dependencies analysis window figure the user can configure the confide nce threshold to determine logical dependencies among files figure a .
developer recommendation is obtained b y clicking in the get ranking button figure b .
figure .
recommendation ranks for the project calculator finally tipmerge generates a ranked list of developers figure .
for each developer and each file it lists the number of gold silver and bronze medals.
it also shows the branch in which the change was made.
further information can be obtained through a tool tip by hovering over the medal count.
figure a shows that alice received a bronze medal for file iequation because she changed quadraticequation in the opposite branch .
.
quantitative evaluation to evaluate the recommendation provided by tipmerge we calculate the accuracy of its top k recommendation where k and .
we select accuracy as the measurement metric since our oracle includes just one element the developer who actually performed the merge henceforth call ed merge developer .
assuming who actually performed the merge as an oracle has limitations .
as with any history based recommender systems we face the challenge of finding the gold standard .
past data only reflects what has occurred and not necessarily what should have occurr ed.
however performing developer interviews to get the gold standard relies on developers often fuzzy memory and is time intensive making it infeasible for a large scale evaluation .
it is also possible that our best recommendation is as good as that of an experienced developer.
however by automating the expert identification process we free valuable time of experts.
to evaluate the usefulness of our approach we compare the accuracy of tipmerge s top k recommendation with the accuracy of choosing t he top k developers who performed the most merges in the past the majority class as commonly referred to in machine learning .
the intuition is that we evaluate by how much our approach outperforms or underperforms as compared to a heuristic that picks the merge developer based on the total amounts of merges that a developer has previously performed.
.
materials and methods we selected the first unique projects from using the since parameter for pagination.
from this set we randomly selected projects for analysis.
for each project we check whether the project include s merges and whether it comprises a sole developer performing a majority of the merges .
the first criteri on is self explanatory .
the second crite rion is used to filter out those projects that either employ an integration manager or a small subset of developers who are responsible for performing the merge.
for instance the git project has one developer who performed out of merges .
.
such projects do not need a recommendation system and are filtered out from the dataset .
after applying these criteria we were left with projects see table .
in addition to these projects we included another project diploma.
although this project has a developer who has performed of the merges we keep this project as we had access to the development team which was useful for the qualitative analysis.
therefore o ur final dataset comprised of projects .
the median percentage of merges performed by the majority class in these projects was .
next we identify the merges that would require a merge developer recommendation.
that is the merge is not simple it includes two or more developers and it includes changes to key files.
merges with key files can lead to direct or indirect conflicts and therefore may req uire higher expertise from the merge developer.
for example in voldemort project of merges .
included key files and of these merges faced direct conflicts.
based on these two criteria we select merges from a set of total merges about .
next we ide ntify the merge developer for each of the merges in our dataset.
we then evaluate the prediction of tipmerge to see whether the merge developer featured in the recommendation ranking.
we specifically check 1st 2nd and 3rd 527position matches we also keep tabs of higher order rankings e.g.
top recommend ation or if the prediction completely missed the merge developer.
table .
selected projects project language developers branches majority class active merchant ruby .
akka scala .
amarok ruby .
angular typescript .
astropy python .
cassandra java .
comm central javascript .
diploma java .
errbit ruby .
eureka java .
falcor javascript .
firefox for ios c .
jquery javascript .
katello ruby .
khmer python .
lantern go .
maven java .
mct java .
nomad go .
perl5 perl .
phoenix java .
picongpu c .
priam java .
sapos ruby .
spree ruby .
sympy python .
typo3 php .
voldemort java .
table .
selected merge s project all merges selected merges percentage active merchant .
akka .
amarok .
angular .
astropy .
cassandra .
comm central .
diploma .
errbit .
eureka .
falcor .
firefox for ios .
jquery .
katello .
khmer .
lantern .
maven .
mct .
nomad .
perl5 .
phoenix .
picongpu .
priam .
sapos .
spree .
sympy .
typo3 .
voldemort .
we then calculate the accuracy of tipmerge recommendations for top and top recommendations.
we recommend more than one developer since the most appropriate developer may not always be available vacation extensive backlog etc.
or the merge developers may want to perform a collaborative merg e session.
we restrict ourselves to top positions since we do not want to overwhelm the user with too many recommendations.
note this makes our results conservative.
we then compare the tipmerge top k recommendations with the majority class based heuris tic.
that is we compare the accuracy of top recommendation of tipmerge with the accuracy of using the top majority class the developer who performed the most merges .
similarly we compare accuracies of tipmerge top recommendation s with the top in the majority class the most prolific merge developers .
we use majority class as a baseline because we are not aware of other approaches for recommending developers for merging branches.
moreover without any additional information a natural choice i s to select someone who did a similar task merges in our case in the past.
directly c omparing accuracies by the ir difference or direct proportion may lead to inflated results improvement therefore we use a measure for normalized improvement in accuracy.
figure shows two scenarios where the accuracy difference between tip tipmerge and mc majority class is .
in the first scenario figure a tip is more accurate than mc vs. .
in the second scenario figure b tip is just more accurate than mc vs. .
if we simply calculate the difference in accuracies it would indicate that both scenarios are equivalent.
on the other hand if we p erform proportional comparison of accuracies it would indicate a much higher increase in the first scenario vs. .
intuitively it is clear that creating an algorithm that improve s an already high majority class result by is much more difficult and useful than improving on a low majority class result by the same amount.
for instance the room for improving over mc in the first scenario is from to and tip only reached of this potential .
on th e other hand the room for improving over mc in the second scenario is only from to but tip achieved of this gain .
figure .
example s of improvement in accuracy we thus normalize the percentage of improvement in accuracy by considering the room for improve ment by using fp fp tipp mcp mcp if tipp mcp tipp mcp mcp otherwise eq.
where tipp represents the accuracy obtained by tipmerge top or top over project p and mcp represents the accuracy of the majority cl ass top or top of project p. .
results and discussion tipmerge has been designed for situations where there is no integration manager or integration team and the team would require recommendation about who should merge ranches.
therefore we classify the results of our study into three categories category i no integrators projects with majority classes top .
this shows that different developers perform the merge tasks.
this is the context our approach was mainly designed for as any developer is a potential candidate to merge branches .
mc tip mc tip a b 528category i i integration team projects with majority classes top and majority class top .
these projects don t have a single integrator top but they have a group who perform the majority of merges .
while not the primary audience of our approach these teams might benefit since we can prioritize the most appropriate developer s for the merge team .
category i ii integration manage projects with majority class top .
these project s have a developer performing a majority of the merges .
we can help by enabling the lead integrator find developers for collaborative merge or help in integration .
to be conservative in our approach we recalculate the majority class for the merges in our dataset and the percentage of merges performed by the majority class.
table lists the accuracy of the top recommendation by tipmerge and the accuracy of the top majority class.
we also list the normalized accuracy improvement eq.
by tipmerge.
table provides similar data but for top rankings.
these tables also colo r code the improvement in accuracy for easier comprehension.
category i tipmerge has very good accuracy for projects in category i for top and top recommendations except the angular project .
the project with the best improvement is lantern .
here tipmerge improves accuracy by .
and .
over selecting the majority class.
note that the top majority class performs .
of the merges which leaves about of other developers who perform merges.
even in such cases tipmerge outperforms predictions using the majority class .
accuracy improvements median for the top and top recommendations excluding the angular project discuss ed next are at and .
respectively .
this attests to the usefulness of tipmerge in projects where there is diversity among merge developers .
in the angular project tipmerge did worse than the prediction using the majority class top at .
top at .
.
indeed tipmerge correctly recommended only and merge cases out of total merges for t he top and top recommendations respec tively.
on further investigation we find that in of the incorrect recommendations tipmerge recommended the merge developer in other positions i.e.
we get an accuracy of if we consider top positions .
to better understand the project dynamics we investigate the merge developers forming the majority class .
the top merge developer alexeagle had continuous integration ci experience the second most prolific merge developer alexwolfe was the head of ux and the third yjbanov was a google employee who had been part of the project since the beginning.
therefore in this case it is likely that alexeagle did most of the merges because of his ci background alexwolfe and yjbanov probably because of their knowledge of the project history and for being part of the core t eam.
category ii tipmerge has high accuracy .
in of projects we get a higher accuracy than the majority class for top recommendation with median improvement of .
.
for top recommendations we have an improvement in out of projects median improvement is at .
.
we perform the best in the cassandra project with accuracy improvements at top and top recommendations at and .
respectively.
next we investigate the two cases where tipmerge had low accuracy firefox for ios and jquery.
in the former case we get a low accuracy .
for the top recommendation.
however we only have a decay of .
from the majority class as we get the correct merge developer in out of merge cases the majority class performed of the total merges in the project.
when considering the top recommendation s we have an accuracy of .
and an improvement of .
.
table .
accurac ies for the top recommendation project majority class tipmerge normalized improv .
accuracy category i lantern .
.
.
katello .
.
.
voldemort .
.
.
typo3 .
.
.
symply .
.
.
active merchant .
.
.
angular .
.
.
category ii cassandra .
.
.
eureka .
.
.
akka .
.
.
falcor .
.
.
perl5 .
.
.
sapos .
.
.
phoenix .
.
.
mct .
.
.
khmer .
.
.
nomad .
.
.
priam .
.
.
errbit .
.
.
spree .
.
.
amarok .
.
.
astropy .
.
.
comm central .
.
.
firefox for ios .
.
.
jquery .
.
.
category iii diploma .
.
.
maven .
.
.
picongpu .
.
.
table .
accurac ies for the top recommendations project majority classes tipmerge normalized improv .
accuracy category i lantern .
.
.
katello .
.
.
voldemort .
.
.
typo3 .
.
.
symply .
.
.
active merchant .
.
.
angular .
.
.
category ii cassandra .
.
.
eureka .
.
.
akka .
.
.
falcor .
.
.
perl5 .
.
.
sapos .
.
.
phoenix .
.
.
mct .
.
.
khmer .
.
.
nomad .
.
.
priam .
.
.
errbit .
.
.
spree .
.
.
amarok .
.
.
astropy .
.
.
comm central .
.
.
firefox for ios .
.
.
jquery .
.
.
category iii diploma .
.
.
maven .
.
.
picongpu .
.
.
529we investi gate further into the project to determine why we missed one of the top recommendation .
we see that the top merge developers majority class es in the project are st3fan wesj thebnich and they are all mozilla employees.
further st3fan is the most senior core developer in the team .
therefore it is likely that he possessed past project knowledge and had an idea about the project s future directions.
this might be the reason for hi s performing most of the merges which might not be reflected in our expertise calculation that weighs recent branch changes higher.
in jquery at the top recommendation we get an accuracy of .
.
decay .
as with firefox for ios we perform much better in the top recommendation s results .
accuracy a .
decay .
to better understand why majority class fares better we investigate the team s contribution structure.
the top merge developer is jeresig who was the founder and until recently had been the major contributor o f the project .
therefore it is likely that he was responsible for a large portion of the merges.
the other two developers in the majority class are dmethvin who is the president a member of the board of directors and a long term contributor to the project and jaubourg who is part of the core standards team.
therefore it is likely that dmethvin knew about the direction and goals of the project and was responsible for many of the merges whereas jaubourg was responsible for merges because of his role in the standards quality team .
category iii we did not expect good results from projects in category iii since they have a clear integrator.
tipmerge accuracies top for maven and picongpu were at .
and .
respectively.
while such accuracy results are good by themselves they are do not improve over the majority class predictions which are very high .
maven clearly has three developers responsible for merges with key files responsible for of the selected merges .
picongpu has one developer responsible for most of the merges .
and three developers responsible for almost all merges .
.
these results confirm our assumptions that tipmerge is not as useful when there are integrators.
diploma differed in this cate gory we have improvement in accuracy over the majority class .
and .
for top and top recommendations .
this project had a small development team five and the developers could physically meet with each which might have led to the positive results .
in summary our assessment indicate s that tipmerge provides very promising results for projects in c ategory i no integrators and category ii integration team .
when considering the top recommendations our approach has normalized improvements median of .
in accuracy over the majority class es in out of the projects .
we calculated spearman s rho between accuracy top and top and the number of commits number of unique developers per branch and number of developer.
we found strong correlation between each factor but weak correlation of these factors with accuracy.
we found negative correlation .
for number of unique developers in branch this is likely because the higher the number of developers i n a branch the harder it is to make a recommendation.
all other correlations were .
or less.
.
qual itative evaluation to understand better why tipmerge recommendations diverged we performed a qualitative evaluation with two projects one open source sapos and one proprietary diploma .
we identified a set of previous merges where tipmerge recommended a different developer than the person who performed the merge.
w e interview ed a few team members from each project to understand whether our recommendat ion was incorrect or if other circumstances affected the merge developer choice .
.
materials and methods we selected sapos and diploma as our projects since we had access to at least one team member who was extensively involved in branch merges.
diploma and sapos had a team of and developers respectively .
when considering merges with key files diploma and sapos contained and merges respectively.
from this set we selected for further analyses a set of merges which were complex and would cause a direct conflict.
we selected a set of merges where tipmerge provided an incorrect recommendation the merge developer was not in the top position and tipmerge recommendation was in the correct position .
this gave us and merge cases from diploma and sapos respectively.
for each of these merges we asked the interviewee to primarily reflect whether the merge developer was the most appropriate person in the project for the merge and evaluate the tipmerge recommendation top as well as the top .
.
results and discussion we interviewed one expert from diploma and two experts from sapos .
the se experts were the developers who performed the most merges the majority class in each project.
diploma is a proprietary project developed by a government company in brazil.
it started in and comprises developers the project manager who is also the technical lead and developer d1 the business analyst who is also a developer d2 and three other developers d3 d4 and d5 .
all team members work in the same building but have d ifferent physical offices.
we interviewed the developer who did the most merges d1 and asked him why the ir project uses branches and why he performed of the mer ges.
the project used branches to maintain system integrity.
four branches were specified development staging acceptance tests production and hotfix .
additional branches were used to implement new requirements or test new technolog y. regarding the merges that he performed d1 said i am the technical lead i hav e more working hours a nd i t ake care of approval and production.
i have to maintain the integrity of this structure.
i have to help the team .
he added that in case of conflicts where the re is no clear merge decision he contacts the developer who made the change and performs a collaborative merge.
besides that w hen another developer has difficult ies in merging d1 is always available to pair and provide support.
we presented to the devel oper tipmerge recommendations a two cases where the merge developer is in the 3rd position b two cases where the merge developer i s in the 2nd position and c one case where the merge developer in the 1st position .
table .
tipmerge ranking and the developer who merged in bold tipmerge position diploma sapos 3rd d1 d5 d4 d4 d5 d3 d4 d2 d1 d4 d5 d3 2rd d3 d2 d1 d2 d1 d3 d1 d2 d4 d1 d4 d1 1st d1 in the first merge case d4 performed the merge in bold in table but our approach placed d1 in the 1st and d4 in the 3rd position .
we asked d1 whether he could have performed th e merge .
he said it makes sense ... i help him in the merge.
.. d4 must have been the one to do the merge ultimately because he was the last to commit.
in the second case d1 performed the merge 530whereas our approach suggested d4 in the 1st and d1 in the 3rd position .
he d1 said d4 had changed two tasks but t here is a piece of code in the merge that only i know so ... but d4 would also have been able to perform it.
next we investigate instances where tipmerge recommended the developer who performed the merge in the 2nd place.
in one of the cases d2 performe d the merge but our approach had him in the 2nd place .
our interviewee d1 said they d2 and d3 were ...in parallel ...they had the same knowledge.
maybe i would have chosen d2 because he had made some of these changes with me...any of them would have been able to perform this merge .
in the fourth case d3 performed the merge whom we ranked in the 2nd place .
d1 said i would still have helped him in this merge.
while d3 could have perform i would have followed it closely.
note we ranked d1 in the 1st place.
in the last merge instance we selected a merge with a conflict that d1 performed and for which our approach recommended him in the 1st position.
we asked him to check whether he was in fact the only one who could have performed this mer ge.
he answered yeah as there were some parts of a legacy system and only i know this part i should indeed have done this merge .
in summary in cases where tipmerge recommendations were not in the top positions the merge decision could have been based on the person who had made the last commit and not necessarily with the most expertise special knowledge about a certain piece of code or parts of a legacy s ystem and personal preference because of having collaborated with someone in the past.
in some cases while the top recommendation by tipmerge was not officially the merge developer they were in fact involved in a collaborative merge.
in none of the cases did the interviewee say that the top recommended developer would have been unable to perform the merge.
finally the interviewee suggested that he would consider using tipmerge in his project.
sapos is an open source project targeted at the ma nagement of information related to graduate programs.
ten developers d1 ... d10 worked on the project at different time periods.
we interviewed the two developers who did most merges d1 and d3 .
in sapos we selected merge cases that had direct confli cts.
in of these merges our top recommendation was not the merge developer .
we randomly selected out of these cases for further analysis table .
in the first two cases the merge developer was ranked in the 3rd position and in the remaining cases in the 2nd position.
d3 performed the merges in the first two cases we ranked him in the 3rd position.
we interviewed d3 and asked him whether d4 top recommendation would have been appropriate in both merges.
he replied that d4 was actually the main author of these merges and they had worked collaboratively but using d3 s computer we did th ese merge s together in my office .
we interviewed d1 about the next four cases.
d2 performed the first of these two merges whereas we ranked him in the 2nd position .
according to d1 both of them d1 and d2 had worked together pair programed extensively in the past and thus they had equivalent knowledge of th e project.
therefore both were qualified to perform these merges.
d1 performed the other two merges and we ranked him in the 2nd position .
according to d1 in both cases a merge conflict occurred in the database schema file.
he was responsible for the me rge because he added a database migration file to the branch .
however he sa id that d4 would be able to do the merge by analyzing the database migration file he would need only to see the added and removed fields in each branch .
in summary in of the cases sapos developers have worked together in pairs during the merge and in the past .
it seems that collaborative practices like pair programming can effectively propagate knowledge among developers providing direct benefits for knowledge intensive tasks like merge .
.
threats to validity as in any study our study has limitations.
first in our evaluations we used the developer w ho had performed the past merge as our oracle the most appropriate developer .
this has been a common approach in work on expert identification .
however it is possible that that developer was not the most appropriate developer.
we ameliorated this issue by interviewing three developers from two projects to determine the appropriateness of our recommendation.
second o ur approach uses the committers git id to identify developers.
it is possible that developers use multiple aliases.
we manually verified the tipmerge ranking with the merge developer to fix possible mistakes by considering their id similarity.
although this suffices in most cases we may have missed some cases when the aliases are lexically different.
however note that if we did miss some aliases they would in fact decrease the accuracy of tipmerge results.
in our study we checked for merges with at least two unique developers to avoid case s where a single developer was making parallel changes.
however our dataset still contain s merges with only two unique developers .
in these cases the merge of the two branches is akin to a workspace merge which is a simple r scenario than branches with a large number of contributors.
in the future we plan to perform a sensitivity analysis to determine the effects of the number of developers in a branch and in a merge on the tipmerge recommendations.
although tipmerge was intentionally designed to suppo rt projects that do not have an integrator we could observe positive results even in this category .
moreover it is worth noting that o f the pre selected projects only have a n integrator responsible for more than of the merges category iii .
of them have a n integration team responsible for more than of the merges category ii and of them have neither an integrator nor an integration team category i .
in terms of generalizability of our results we had five projects in category i and we spoke to experts from two projects.
in the future we plan to replicate our results on a larger corpus and speak to more developers across different projects.
in projects with few merges our accuracy is not high.
we calculated spearman s rho between accuracy and the complex merges .
we get positive correlation s .
.
between complex merges and top top accuracy.
this is likely because higher number of training instances improve predictions .
.
related work to the best of our knowledge there is no work that addresses recommendation of developers to merge branches .
the more closely related works either provide awareness to developers during parallel work to reduc e the complexity of merges or support the identification of exper ts in software projects .
.
workspace awareness research on workspace awareness aims to notify developers about parallel ongoing work and emerging potential conflicts that developers will face when they synchronize their work with the main development .
approaches such as casi cloudstudio codesign crystal palan t r safecommit syde and wecode try to avoid conflicts by notifying the developers and prodding them to self coordinate .
one of the most recognized approach on awareness is palant r. it tracks workspace e dits to identify potential conflicts and notifies devel531opers of these conflicts as soon as possible.
similarly crystal integrates ongoing parallel changes extracted from local commits in git into a shadow master repository to identify potential conflicts.
cloudstudio allows a developer to select the type of information about parallel changes that they want to be notified about.
this helps with interruption management.
safecommit identif ies changes at different levels of safety will pass tests will pa ss merge etc.
thereby allowing developers the flexibility to choose which change sets can be safely integrated with the trunk.
even though these approaches play an important role in minimizing the incidence of conflicts they do not guarantee conflict free merges.
different factors may still lead to difficult merges even when these approaches are in place such as developers working on project forks that eventually need to be reintegrated the nature of some parallel changes e.g.
bug fix and new feature s over the same component and offline changes .
in these cases the integration process would impose challenges to the developers in charge and our approach would be useful .
.
identification of experts some approaches such as dominoes emergent expertise locator expertise browser and usage expertise aim to identify experts in software projects.
some of these approaches dominoes and emergent expertise locator are based on the approach by cataldo et al.
who developed a technique to measure task dependencies among people.
they use matrices to represent various dependency relationships.
from this they aim to answer who must coordinate with whom to get the work done.
dominoes allows different kinds of exploration s over matrices and it can be used to identify experts for a given project or software artifact.
dominoes is capable of using gpu for processing operations which enables the analysis of large scale data.
emergent expertise locator produces a ranked list of the most likely emergent team members with whom to communicate given a set of files currently deemed to be of interest.
expertise browser identif ies experts over regions of the code such as modules or even subsystems by using the concept of experience atoms eas which are basic units of experience in change management systems and the atomic change delta made to the source code or to the project s documentation .
finally the concept of usage expertise is introduced to recommend experts for files where the developer accumulates expertise not only by editing methods but also by calling using them.
all these approaches extr act information from the version control systems and issue tracking systems.
some of these systems are similar to tipmerge and are based on changes performed via commits others check for different kinds of information such as a method call s opened and closed issues etc.
while t hese approaches all identify experts they only take into consideration previous history and do not discern changes in branches.
as a result equal weights are assigned to all files .
however in our situation we know that change s across branches and their dependencies might have a bigger impact on the merge decision than prior changes alone .
other studies on identification of experts have focus ed on pull request assignment .
yu et al.
proposed an approach that combines information retrieval with social network analysis to help project managers find a suitable reviewer for each pull request.
jiang et al.
propose d coredevrec to recommend core members for c ontribution evaluation in github.
coredevrec uses support vector machines to analyze di fferent kinds of features including file paths of modified codes relationships between contributors and core members and activeness of core members .
de lima j nior et al .
proposed the use data mining to identify the most appropriate developers to analyze a pull request.
they use a set of attributes and clas sification strategies to suggest developers to analyze pull requests.
these works are closely related to the recommendation of developers for branch merging as they aim to recommend developers to verify the actual contribution and possibly merge it with the rest of the project.
nevertheless in general pull requests contain commits of a single developer and are small .
moreover the author of the pull request usually syncs their forked branch in advance to ease reintegration making the process more like a workspace commit.
in the more general case of merging branches the number of developers the syncing interval and the number of commits per branch is variable and can be high in some situations .
.
conclusions this work to the best of our knowledge is the first to make developer recommendations for integrating branches.
our approach implemented in tipmerge leverages historical information about changes in the branches as well as past history and the dependency among file s. we found that we perform the best in projects that either have no integrators category i or have an integration team category ii .
we obtain the best accuracy at for the top recommendation project eureka and a best accuracy at for the to p recommendation s project diploma .
when we compare our results top recommendation s with the majority class we get an improvement in predictions in most cases out of projects .
among the projects where we outperfo rm the majority class we ha ve a normalized accuracy improvement of .
median for the top recommendation and a normalized accuracy improvemen t of .
median for the top recommendation s. we further investigated the team contribution structures in the cases where tipmerge had a decay i.e.
was worse than the majority class .
our exploratory analysis suggests that the role of developers i.e.
core team member lead qa founder as well as their skills e.g.
continuous integration can affect who becomes responsible for the merge.
we performed interviews with three expert developers from two projects in our corpus.
from our interviews we found that factors like person performing the most recent change knowledge about specific parts of the code ba se and per sonal preference had an effect on who was eventual ly responsible for the merge.
in several cases where the top recommendation was incorrect th at developer had in fact participated in a collaborative merge or supported the merge developer in some fashio n. our results suggest that tipmerge can be further extended to incorporate the above factors into the analysis algorithm.
we also plan to run the analysis at a finer grain method level as this will provide a detailed understanding of file dependencies and developer knowledge about specific parts of the code base.
further we will extend the dependency calculation to also consider new dependencies added by changes in the branches.
finally we intend to replicate this analysis over a larger corpus of proj ects.
in conclusion our results suggest that tipmerge can be useful in not only predicting the most appropriate developer to perform the merge when there is no integrator in the team but also in recommending other developers who can support the integrato r. .