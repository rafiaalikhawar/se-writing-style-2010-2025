a comprehensive study of real world numerical bug characteristics anthony di franco hui guo and cindy rubio gonz lez department of computer science university of california davis usa acdifranco higuo crubio ucdavis.edu abstract numerical software is used in a wide variety of applications including safety critical systems which have stringent correctness requirements and whose failures have catastrophic consequences that endanger human life.
numerical bugs are known to be particularly difficult to diagnose and fix largelydue to the use of approximate representations of numbers such as floating point.
understanding the characteristics of numerical bugs is the first step to combat them more effectively.
in thispaper we present the first comprehensive study of real world numerical bugs.
specifically we identify and carefully examine numerical bugs from five widely used numerical software libraries numpy scipy lapack gnu scientific library and elemental.
we propose a categorization of numerical bugs anddiscuss their frequency symptoms and fixes.
our study opens new directions in the areas of program analysis testing and automated program repair of numerical software and providesa collection of real world numerical bugs.
i. i ntroduction numerical software provides the foundation for a wide variety of software applications including safety critical systems such as control systems for vehicles medical equipment and industrial plants.
libraries for machine learning e.g.
tensorflow scikit learn computer graphics e.g.
opengl computer vision e.g.
opencv and data analysis e.g.
pandas rely on numerical libraries such as numpy scipy and lapack to perform numerical calculations.
domainspecific languages such as gnu octave for scientific programming and r for statistical computing integrate numerical libraries to provide support for numerical computations.
numerical software relies heavily on floating point arithmetic which brings additional challenges in terms of software reliability and performance.
floating point is a widely used representation that approximates real numbers.
by nature floating point introduces imprecision in numerical calculations.
sources of numerical errors include extreme sensitivity to roundoff floating point exceptions such as overflow underflow and nonreproducibility across machines or even across runs on the same machine.
this has led in part to numerical bugs that have caused catastrophic failures .
numerical bugs are those related to either the finite approximate representation of real numbers or to mathematical aspectsof the computation.
techniques have been proposed to estimateroundoff error generate inputs that maximize errors or trigger floating point exceptions and to detect both authors contributed equally.accuracy and instability problems .
however there is a gap of knowledge in understanding the characteristics of numerical bugs in real world numerical software.
what are the most common numerical bugs?
how prevalent are these bugs?
are existing tools capable of detecting them?
how are such bugs fixed?
are existing program repair tools suitable to fix them?
this paper takes a first step towards answering these questions by conducting the first comprehensive study ofreal world numerical bug characteristics.
the goal of this paper is to study the causes symptoms and fixes of numerical bugs in numerical libraries and provide a high level categorization that can serve as a guide for researchers to develop tools for finding and fixing numerical bugs.
empirical studies of bug characteristics have been conducted in the past to learn about concurrency bugs performance bugs and error handling bugs among many others.
these studies have revealed patterns for both bug detection and bug fixing.
to the best of our knowledge no study thus far has focused on numerical bugs or has considered inspecting numerical libraries despite the reputation of being particularly subtle and error prone.
we faced a number of challenges while conducting this study.
first numerical bugs are not as numerous in generalpurpose applications which motivated us to focus our search on numerical libraries in particular numpy scipy lap ack the gnu scientific library gsl and elemental .
second examining bugs from these libraries was particularly challenging due to three main reasons the libraries use distinct version control systems and bug tracking systems if any the libraries range from to years old thus not all bugs are documented in the same manner the libraries are implemented in several different programminglanguages python c c and fortran often with severallanguages involved in the same library.
finally we found that in many cases examining and classifying numerical bugs required significant domain knowledge and understanding of the code under inspection.
we identify and carefully examine a total of numerical bugs.
we propose to categorize numerical bugs into accuracy bugs special value bugs convergence bugs and correctness bugs.
we find that correctness bugs are the most frequent in our dataset followed by special value bugs convergence bugs and accuracy bugs .
we discuss their characteristics including common symptoms and fixing .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research509 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
strategies and present real world examples.
finally based on our findings we discuss new research directions to develop tools to improve the reliability and efficiency of numerical software.
this paper makes the following contributions we identify and examine real world numerical bugs found across five widely used numerical libraries numpy scipy lapack gnu scientific library gsl and elemental sections iii and iv .
we present a categorization of numerical bugs and discuss their symptoms and fixes section iv .
we discuss new directions to test and analyze numerical programs section v .
the rest of the paper is organized as follows.
section ii presents background on floating point section vi discusses related work and section vii concludes.
ii.
f loa ting point preliminaries floating point is the most common representation of real numbers.
unfortunately floating point requires navigating many subtle tradeoffs and inevitably introduces semantics that differ from those of the reals.
indeed many of the difficulties faced by numerical programmers are inherent in the semantics of floating point.
here we review the ieee standard for floating point and its semantics.
afloating point value is one of the following anumber represented as scbqwhere sis the sign cis the coefficient orsignificand and qis the exponent.
the base orradix bis usually binary though the standard also describes a base decimal representation.
the significand is represented in the same base.
binary formats range in size from half precision bits to octuple precision bits in power of two bit widths.
most computations are carried out in single bit or double bit precision in practice.
the infinities representing infinite quantities.
the sign of an infinity will correspond to the signs of the operands used to produce it i.e.
and 0yield while and1 0yield .
thenan value representing a result that is not a representable number such as the result of an attempt to take the square root of a negative number.
nan s generally propagate through computations once they occur and come in quiet and signaling varieties to implement sensible exception generating behavior given this propagation.
because the significand is scaled by a function of the exponent the absolute precision of representable numbers varies with the exponent over their range.
the width of the interval enclosed by a number with its last significand bit set to zero and the same number with its last significand bit set to one is called a unit in the last place or ulp .
overflow underflow and subnormal numbers.
results of computations that exceed the greatest representable number in magnitude in the current precision are said to overflow and those that fall between zero and the smallest representable nonzero number are said to underflow.t able i floa ting point exception beha vior exception conditiondefault result underflowresult between smallest normal number and zerosubnormal number overflowresult larger than largestrepresentable number in magnitude inexactresult was not exactly representablerounded result invalidresult was indeterminateor not representable as a numbernan divide by zerofinite nonzero number is divided by zero asubnormal number uses an exponent of zero to indicate that the exponent is the lowest representable and that the significand contains leading zero bits.
this convention allows all remaining precision in the significand to be gradually exhausted as representable numbers approach zero.
roundoff and truncation errors.
converting from a higher to a lower precision requires truncating the representations of the significand and exponent to the lengths allowed by thelower precision which reduces both the available dynamic range and precision.
the loss of precision is called truncation error while the loss of dynamic range can result in overflow.
roundoff error is the consequence of needing to express the result of an operation in terms of representable numbers which due to varying absolute precision across the representable range and other effects incurs errors even for operations on numbers that are themselves representable.
roundoff error of basic arithmetic operations is specified to be at most one half of an ulp though some implementations that favor speed such as gpus violate this requirement.
floating point exceptions.
table i shows a summary of the floating point exceptions.
an underflow exception occurs when a result is too small to be represented by a normal number while anoverflow exception occurs when the result of an operation is too large to be represented.
an inexact exception occurs when the result of a floating point operation was rounded.
an invalid exception occurs when an indeterminate form such as0 is evaluated.
a divide by zero exception occurs when division by zero is attempted.
the environment may choose to mask exceptions in which case the appropriate subnormal numbers infinities or nan s are used to represent the results and no exception is raised.
catastrophic cancellation.
subtracting two nearly equal numbers means that most of the bits in their representations will cancel incurring a large risk that the result will denormalize underflow .
the resulting approximation error will then propagate through the rest of the computation.
two notable techniques intended to address the difficulties in dealing with the many undesired behaviors that can arise in computing with ieee floating point and to track the error that accumulates in the course of computation are interval authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
arithmetic standardized as ieee in and unum arithmetic .
interval arithmetic represents a compact set of real numbers by its bounds which allows tracking the set of possible solutions computed by a program whose size measures the error.
unum arithmetic is related and uses representations that partition the real line into exactly representable points and open sets between them.
in addition to building error tracking into the representations unum arithmetic improves the semantics of operations involving infinities or nan versus ieee floating point.
iii.
m ethodology this section describes the critera for selecting numerical libraries and the bugs to be examined and the threats to the validity of our study.
a. selection of numerical libraries we selected five representative numerical libraries for our study numpy scipy lapack gsl and elemental.
these libraries are characterized by their maturity to years old popularity used by thousands of projects and activedevelopment.
numpy and scipy are python libraries that combine python numerical code with wrappers for low level routines written in c and fortran targeting general numerical and scientific computing respectively.
lap ack is a c fortran library of low level numerical routines and a building block for many higher level libraries such as numpy.
gsl mainlyimplements special functions and probability distributions essential to scientific computing.
finally we searched for public github c repositories using keywords associated with numerical computation.
weranked the results by number of stars project popularity .
the elemental library was ranked first.
elemental is a library that provides efficient and general linear algebra routines suitable for numerical analysis scientific computing and work in theoretical mathematics via support for features such as arbitrary precision and large scale distributed computation.
for each library table ii shows its language of implementation the earliest date for which data is available whether itis hosted in github bug tracking system used current size loc number of commits contributors and releases.
b. selection and characterization of numerical bugs we chose to examine bug reports as opposed to commits to have access to more bug information that includes original reports from users and developer discussions.
we imposed a few requirements on our bug report selection to include bugs confirmed by developers e.g.
status is closed considered important e.g.
bug fix is available and more likely to be numerical bugs.
numpy scipy and elemental are hosted on github and use github s integrated issue tracking system.
this is often used by developers to track bugs enhancements and other tasks.
additionally it includes github pull requests.
pull requests are used by developers to contribute code after review and approval to a repository.
lap ack by contrast hosted its owndevelopment before version .
.
when it was migrated to github adopting github s issue tracking system .
thus there are two sources of bug reports for lapack the netlib page which lists the bugs filed between lap ack .
released in and lapack .
.
released in and the github repository s issue tracker since lapack .
.
.w e refer to these as lapack1 before github and lapack2 after github through the rest of the paper.
finally gsl maintains a savannah bug tracking system.
we found that all libraries except for lap ack1 and gsl make use of labels to classify issues.
in our selection we filteredout any issues with labels related to build issues documentation issues and feature requests.
after filtering out open issues issues without patches and issues without relevant labels the number of potentially interesting issues for numpy and scipy was still too large for manual inspection.
thus we applied two additional filters to these projects to further refine our selection.
first we searched issue titles and descriptions for the following keywords nan exception overflow underflow infinity infinite precision unstable instability ringing unbounded roundoff truncation rounding diverge cancellation cancel accuracy accurate.
second we randomly sampled from the resulting set of issues.
we manually examined the selected bugs by reading their descriptions comments and any associated commits or pullrequests to verify that they were numerical bugs of interest to our study.
then we made a second pass through all bugs that passed this final selection criterion and classified them according to the symptoms they displayed and the strategies used to implement their fixes.
c. threats to v alidity internal v alidity.
our findings depend entirely on the set of bugs we examine.
thus we ensured that the relevance of the initial bug selection was as high as possible by applying several filters.
first we made sure the issues and pull requests we selected were real bugs by choosing only accepted closed issues except for gsl where due to limited data we alsoexamined issues that were open but manually assured theyhad been confirmed before including them .
second whenavailable we used labels from the project bug tracker as part of the selection criteria to ensure that we examined bugs considered important by project developers.
third because we are also interested in bug fixing we selected bugs referenced by other bugs or commits when possible skewing our selectiontowards bugs with associated patches.
fourth if the number of selected issues was too large for manual inspection we used keywords indicative of numerical problems to select those bugs most likely to be relevant.
finally each bug was inspected independently by each author of this paper.
external v alidity.
the results presented in this paper are based on only five numerical libraries requiring special attention to select a representative sample to make generalization toother bugs in other software justified.
to address this challenge we selected representative mature and widely used numerical libraries.
our selection includes libraries implemented in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able ii numerical library informa tion library language start date github bug tracker loc commits contributors releases numpy python dec y github scipy python jan y github elemental c mar y github lapack1 c fortran may n website na lapack2 c fortran oct y github gsl c c dec n savannah t able iii numerical library issues and pull requests issues pull requests library all closed w patch label inspected all closed w patch label inspected total insp numpy scipy elemental lapack1 lapack2 gsl total t able iv ca tegoriza tion of numerical bugs library accuracy s v alues converg.
correctness total numpy scipy elemental lapack gsl total several of the most commonly used programming languages for numerical code and addressing a comprehensive range of subtypes of numerical code at levels of abstraction from lowlevel arithmetic and linear algebra to higher level large scale scientific computing and number theory.
iv .
n umerical bug study the main purpose of this numerical bug study is to answer the following research questions r1.
how frequent are numerical bugs?
r2.
how can we group numerical bugs into categories thatshare common causes and patterns and how frequently do bugs in each category occur?
r3.
what other characteristics of numerical bugs can we identify to inform building tools?
we examined a total of bugs issues and pull requests from five numerical libraries numpy scipy elemental lap ack and gsl .
table iii lists the total number of issues and pull requests prs per library.
the column closed refers to the number of issues prs with status closed.
the column w patch indicates the number of closed issues prs that include patches and the column label indicates the number of closedissues prs with patches that were selected based on their labels.
for scipy and numpy we provide two numbers.
the second number is the number of labeled issues prs in which relevant numerical keywords see section iii were found.
from these we randomly selected issues and prs from each of numpy and scipy.
we inspected all bug reports for gsl and all closed issues and prs for elemental.
in total we inspected issues and prs.
we use issues prs and bugs interchangeably in the rest of this paper.
we found numerical bugs in the bugs inspected and developed a categorization of numerical bugs that consistedof four groups accuracy special value convergence and correctness.
table iv shows the distribution of each kind of bug across the five libraries studied.
next we describe the characteristics of each bug category.
finding of the bugs examined are numerical bugs.
based on our observations we propose four categories for numerical bugs accuracy special value convergence and correctness.
a. accuracy bugs we classified bugs as accuracy bugs when precision loss due to rounding or truncation errors led to an incorrect result.
out of the numerical bugs we found accuracy bugs across four numerical libraries.
these bugs were found mostly in decomposition and eigenvalue computation routines inlapack and in the core components of gsl scipy andnumpy.
we found that accuracy bugs often fell into one of three subcategories insufficient precision data type.
to determine the precision of a variable one must take into account the range of values to be stored.
while using too much precision can cause performance degradation and or increase in memory usage using too little precision can cause precision loss that may lead authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
import numpy as n a n.ones dtype n.float32 .
a.min .
a.max .
a.mean .
fig.
.
numpy issue tests revealing accuracy bug due to insufficient precision data type.
double complex hyp0f1 cmplx double v double complex z ... double complex t1 t2 both v and z small truncate the taylor series ifzabs z 1e .
fabs v return .
z v z z .
v v .
ifzabs z 1e .
zabs v t1 .
z v t z z .
v v .
return t t fig.
.
scipy issue bug due to an inaccurate arithmetic expression.
to incorrect results.
fig.
illustrates an example of an accuracy bug due to insufficient precision data type found in the numpy library.
there the average of an array is well outside of the range between its minimum and maximum elements.
this is due to the accumulation of roundoff errors in the summation of the array elements.
the suggested fix proposes to use higher precision for the variable that stores the sum.
however some developers argued that higher precision would be too expensive to use and the issue was closed without applying the fix.
the bug is still present in the current version of the library.
inaccurate arithmetic expressions.
floating point arithmetic expressions must be carefully crafted to minimize thegeneration and propagation of roundoff errors.
fig.
showsan example where the order in which arithmetic operationsare computed leads to precision loss.
the bug is fixed by introducing two temporary variables and breaking the original arithmetic expression into three separate expressions to enforcethe required order of computation.
fig.
shows another example two expressions that suffer from catastrophic cancellation are replaced with different but equivalent expressions.
ill conditioned problem.
when a large numerical error is found in a result the issue may be inherent to the problem as it would appear regardless of the algorithm used.
the condition number of the problem is the key to make this distinction.
a large condition number indicates that the problem itself is sensitive to numerical errors.1fig.
shows an example of an ill conditioned problem.
after examining the computation order of an expression as shown in fig.
the developers discussed the problem further and recognized that the problem is ill conditioned its condition number is much larger than 1the condition number measures how sensitive a result is to small changes in the input.
a problem is ill conditioned when a small change in the input leads to a large change in the output magnifying the impact of errors.def cdf self x return norm cdf sqrt x equivalent to norm.sf sqrt x return special.erfc sqrt .
x def ppf self q val norm ppf q .
equivalent to .
norm.isf q val special.ndtri q return .
val val fig.
.
scipy issue bug due to inaccurate expressions.
scipy.special.hyp0f1 v z confluent hypergeometric limit function 0f1.
parameters v z array like input values.
returns hyp0f1 ndarray the confluent hypergeometric limit function.
the problem is ill posed the condition number is df dz z f v at v z .
small relative changes in input values cause large relativechanges in output.
fig.
.
scipy issue accuracy bug due to ill conditioned problem.
when vis much smaller than .
high precision data types would be necessary to achieve correct behavior.
detection and fixing automation.
in the bugs we examined backward error analysis was often used in the detection of accuracy bugs.
for example to test a division on floating point numbers q r divmod a b the accuracy of the quotient q and remainder rcan be determined by comparing q b r anda.
a similar technique can be used to test decomposition and eigenvalue computation routines.
in these cases the two resulting matrices should be orthogonal in theory.
a problem is revealed if their product greatly deviates from the unit matrix.
such techniques could be used for bug detection.
input generation is another important aspect in detecting accuracy bugs however we did not find any mention of input generation when examining the bug reports.
finally we found that the first two subcategories suggest strategies for fixing accuracy bugs switching to higher precision and transforming arithmetic expressions to improve their precision.
finding accuracy bugs are the least frequent numerical bugs in our dataset .
techniques such as backward error analysis could be used to automatically detect these bugs.
furthermore we identify two common strategies to fix accuracy bugs using higher precision and reordering arithmetic expressions.
input generation to detect accuracy bugs remains a challenge.
b. bugs related to special v alues in this paper we refer to signed zero subnormal numbers infinities and nan s not a number as special values.
unlike normalized floating point numbers special values are given a special encoding in the floating point representation system.moreover arithmetic operations on special values followirregular rules with subtle implications.
we denote a bug as authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
import numpy as np np.max np.array fig.
.
numpy issue test revealing a nan bug in function max.
g g g g 1d1 1d1 fig.
.
lapack bug an example of a special value bug.
the initial matrix in has all elements set to the singular value decomposition routine of lapack gesvd eventually produces a matrix that contains nans.
related to special values when its root cause is related to computation involving special values.
for example the program fails with nan inputs or it allows precision loss to proceed beyond the appearance of subnormal numbers and producing nan s later in the computation.
we found that out of numerical bugs are related to special values.
these bugs are distributed widely in different library components and cancause an algorithm to fail in various ways producing nan values producing incorrect results causing infinite loops etc.
next we describe two kinds of bugs in this category.
missing nan checks.
anan checking procedure checks the floating point inputs explicitly for nan values.
depending on the program s policy to deal with nan s inputs that contain nan s are either rejected ignored or masked.
some disagreement is observed among library developers with respect to whether nan checks should be enabled or not for certain inputs.
while enabling nan checks makes algorithms more robust these also add runtime overhead.
as a result nan checks are often added until a function is reported to be buggy onnan inputs.
fig.
shows a test that reveals such a bug in the max function from numpy.
the function returns an incorrect result when the input array contains a nan value.
in the example the function returns 2as the maximum value in the array .
this is due to the fact that any comparison against a nan evaluates to false .
in this case max checks whether 1is larger than nan which evaluates to false thus nan is larger.
then it checks whether nan is larger than which also fails and 2is returned.
to fix this bug a nan check is added to check the array for nan s. furthermore the function is modified to immediately return a nan if the input array contains a nan value.
overflow underflow.
another important type of specialvalue bug is overflow underflow which can lead to nan s. these bugs are caused by a variety of problems and often require domain specific knowledge for their detection.
fig.
describesan underflow bug in the lap ack library that results in nan s. a user reported nan values in the result when calling routine gesvd to compute the singular value decomposition of amatrix with all elements set to .
the input matrix leads to denormalized numbers when bidiagonalized in gesvd .
this matrix is eventually passed to routine lasq3 .i nlasq3 tis computed by taking half of z nn z nn z nn where nn is a local scalar underflowing and becoming .
nan values are then produced in swhen dividing t. a fix for this bug is proposed by strengthening the conditions for further computation on t i.e.
avoiding the computation of swhen tunderflows.
this fix required domain specific knowledge.
detection and fixing automation.
nan s are designed to denote the results of invalid floating point operations e.g.
without interrupting execution.
furthermore nan s are often used to represent missing data which can lead toambiguity.
both uses cause errors due to the idiosyncratic behaviors of computations on nan s and other special values and their non local propagation.
an approach to detect specialvalue bugs is to feed nan inputs to functions to observe where and how they subsequently fail.
this could be used to reveal problems with nan checks or their absence.
on the other hand generating inputs to reveal underflow overflow errors is however difficult to automate as it requires domain specific knowledge.
finally the main challenge in automating bugfixing is to determine when to check for special values and what to do in their presence.
finding we find that of the numerical bugs are special value bugs.
these bugs mainly involve nan checks and overflow underflow conditions.
an initial approach to detect missing nan checks is to use nan inputs.
generating inputs to expose overflow underflow remains a challenge.
c. convergence bugs we define convergence bugs as bugs where an iterative or series approximation diverges or converges too slowly due to numerical problems such as magnified roundoff or truncation errors.
this is related to numerical instability i.e.
theoutput is sensitive to small variations in inputs or intermediate quantities.
consequently small errors introduced by floatingpoint approximations drive the output far from the correct value.
this can be complicated by interactions with instability around conditional tests where vanishingly small differences in a quantity involved in a test can cause different control paths to be followed.
an example is the termination of a loop that intends to continue an iterative approximation until an error estimate goes below a given error tolerance.
we find that out of numerical bugs correspond to convergence bugs were found in gsl in lap ack and6 in scipy.
we did not find any convergence bugs in the sampled issues from numpy or elemental.
this was unremarkable in the case of numpy because numpy focuses mainly onlow level linear algebra data structures and operations on these are delegated to wrapped algorithms from other packages.
elemental includes support for arbitrary precision arithmetic.
arbitrary precision arithmetic avoids convergence issues by scaling precision according to the demands at each point in a computation.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
convergence bugs fall into one of the following scenarios the approximation algorithm uses a problematic approximation formula that yields a wrong result.
numerical issues in an iterative approximation cause an infinite loop that leads to a program crash.
special values such as nan s are involved in divergent behavior.
we classify this as a convergence problem yielding a wrong result rather than a special value issue because it is more specific to do so.
an example of a convergence bug is illustrated in fig.
.
a user noticed an error larger in magnitude than the result itself in the output of the hypergeometric special function in the regimeof large negative a positive b and large positive xparameters.
another user noted that the kummer transformation used for x returned correct results for larger xas well and proposed a fix to use it by default in this regime for all values ofx which was accepted.
in general the symptom revealing a convergence bug was usually the output of wrong results.
occasionally failure to converge would result in a non terminating loop hanging the program which we classified as a crash.
detection and fixing automation.
because failures to converge are due to issues in the quality of a numericalapproximation these require domain specific knowledge to address and fixes usually involve using a better approximation technique.
in principle running programs with arbitraryprecision arithmetic could help to automate finding such issues.
since these bugs are among the most common in scientificcomputing packages that implement special functions and probability distributions such a tool could be highly valuable.
unum arithmetic could be especially interesting in this context because it combines aspects of interval based error tracking with adaptive precision.
finding we found that of the numerical bugs are convergence bugs.
diagnosing convergence bugs requires domainspecific knowledge.
adaptive use of interval and arbitraryprecision should be investigated further.
in this context unum arithmetic is especially interesting since it combines a form of interval based error tracking with adaptive precision.
d. correctness bugs acorrectness bug is caused by any error in the implementation of an algorithm that have to do primarily with its mathematical or algorithmic structure.
correctness bugs are the most type of numerical bugt out of numerical bugs arecorrectness bugs.
correctness bugs have the greatest variety ofall types and ranged from typographical errors in transcribinga formula from a reference to using an approximation formula for a function outside the function s domain of definition to errors due to compiler optimizations violating the assumed semantics of mathematical operations.
to differentiate algorithmic correctness bugs that are specific to numerical code from correctness bugs in general purposecode we considered only bugs dealing with mathematical aspects of the computation or at least with the use of data typesint gsl sf hyperg 1f1 e const double a const double b const double x gsl sf result result ... else if a .
fabs x .
else if a .
fabs x gsl log dbl max use kummer to reduce it to the generic positive case... gsl sf result kummer 1f1 int stat k hyperg 1f1 ab pos b a b x kummer 1f1 int stat e gsl sf exp mult err e x gsl dbl epsilon fabs x kummer 1f1.val kummer 1f1.err result return gsl error select 2 stat e stat k ... fig.
.
gsl issue an example of a convergence bug.
or structures specific to numerical computation.
for example an error in a branch condition that resulted in the use of the wrong approximation formula for a special function at the given point in its domain would be classified as a numerical correctness bug while an error in a branch condition that resulted in the premature return of an uninitialized value would not be counted as a numerical correctness bug.
for another example a concurrency bug arising in distributing computation over a matrix that considers the structural features of that matrix would be considered a numerical correctness bug while a concurrency bug in general would not be.
correctness bugs were most prevalent in scipy and gsl.
we observe that scipy and gsl both focus on implementing special functions and probability distributions used for scientific computing and the numerical correctness bugs we found in them occur overwhelmingly in these features.
we classified correctness bugs into the following subcategories errors in the initialization or updates in iterative solvers that resulted in problems other than a failure to converge to the correct result.
errors in conditional tests that resulted in the wrong function approximation being used for the given point in the domain.
errors involving vector and matrix data data types such as element type errors and incorrect array dimension.
violations of assumed numeric semantics due to compiler optimizations.
fig.
shows an example of a numerical correctness bug related to error initialization found in scipy.
the bug is found in code wrapping a call to a fortran routine for sequential leastsquares programming where there is an erroneous attempt to use dummy values of 1e12for constraint bounds passed to the solver.
this resulted in scaling problems in the solver due to the large range of the constraints and also precluded finding solutions outside those bounds even when they existed in the given problem.
the underlying fortran routine in fact supported using nan in the place of bounds for unbounded authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
def minimize slsqp ... ... filter inf inf and nan values mark infinite bounds with nans the fortran code understands this infbnd isfinite bnds xl .0e12 xu .0e12 xl np.nan xu np.nan fig.
.
scipy pull request an example of a correctness bug.
problems and once that fix was made and an array bounds error introduced by the initial fix was then addressed the routine worked as expected.
detection and fixing automation.
correctness bugs were most often discovered through the symptom of an incorrect result being returned.
the majority of these were discovered by users noticing incorrect results in the course of their work and comparing the library results to other implementations of the same feature usually in less efficient but more rigorous packages that include such features as arbitrary precision arith metic for example p ari gp .
this suggests that differential testing against such a package could be an effective bug findingapproach.
a minority were discovered through test cases failing.
these were often platform or build specific and were the fault of the compiler violating semantic assumptions implicit in the code under certain conditions.
this suggests the approach of using a database of platform build and environment dependent behavior to scan code for instances of patterns that differ in their behavior across targets.
in general correctness bugs required the most domainspecific knowledge of all types to fix given that they were most related to the mathematical structure of the problem at hand and the idiosyncrasies of the language and environment.
finding correctness bugs are the most common numerical bugs with of numerical bugs falling into this category.
correctness bugs are extremely challenging to detect.
differential testing may be a good method to detect these bugs.
e. general bug symptoms and opportunities for automation we identified three common symptoms of numerical bugs wrong results crashes a n dbad performance.
table v shows their distribution across libraries.
we found that the majority ofnumerical bugs are revealed by producing wrong results.
this is followed by crashing the program and causing bad performance .
for all libraries except elemental producing wrong results was the most common symptom of a numerical bug.
the second most common symptom was program crashes for numpy and scipy and bad performance for elemental2 lapack and gsl.
we also classified bugs according to whether detection or fixing could be automated.
table vi shows our classification 2in the case of elemental this difference may be due in part to its use of arbitrary precision arithmetic which tends to convert precision loss problems into performance problems by dynamically extending the representation length on demand.t able v bug symptoms library wrong results crashes performance total numpy scipy elemental lapack gsl total and the distribution across libraries.
pattern describes bugs that could be detected or fixed by applying a simple pattern analysis refers to bugs that could be potentially detected or fixed automatically after non trivial analysis of the code and domain specific are bugs that require domain specific knowledge to be detected or fixed.
we found that veryfew bugs can be detected using simple patterns e.g.
matching small ast fragments to repair problematic order of operations .
however we found that a considerable number of bugs might be detected automatically with program analysis techniques e.g.
dataflow analysis to aid in estimating output error from intermediate roundoff errors .
in the case of automated bug fixing fewer bugs could be fixed by applying patterns or analyzing code a large majority of fixes were domain specific.
note that we considered only bug fixes in our study.
finding the most common symptom for numerical bugs is wrong results which is observed in of the bugs.
this is followed by crashes with and bad performance with .
about of the numerical bugs required domain specific knowledge to be fixed.
v. l essons learned frequency of numerical bugs.
even in the projects we examined which focus exclusively on numerical code of the reported issues were numerical bugs.
we speculate that this may be due to the relative maturity of these projects and that the essential functionality is already in place and thoroughly debugged.
because of the widespread use and maturity of these libraries and their tendency to be implemented by highly skilled experts we would also expect that the bugs mostrelevant to this study were discovered and fixed early in the project lifecycle if they appeared at all thus we may need to look for historical bug data that far predates the migrationof these projects to github if they appear on github atall.
finally numerical bugs can also be present in clientsof numerical libraries and other applications e.g.
.
it would be interesting to investigate whether our findings apply to code other than numerical libraries.
current tool usage.
we did not find any indication during our manual inspection that bug detection tools wereused by developers or users.
in most cases users seemed to find inputs that exposed unexpected behavior almost by chance.
there was also no indication that developers of these libraries authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able vi opportunities for automa tion bug detection bug fixing library all pattern analysis domain specific all pattern analysis domain specific numpy scipy elemental lapack gsl total had used any existing tools to test the libraries.
as future work it would be interesting to find whether specific existing tools e.g.
tools that find divergences are able to find the bugs we identified in this study.
usage of patterns.
although we identified a small number of bugs that could be detected or fixed by applying simple patterns such as expression rewriting we believe that there is still promise on applying such patterns to other code bases in particular to the numerous clients of these libraries.
also we could apply those patterns to detect unknown bugs in the libraries considered in this study.
tools such as herbie and precimonious could be applicable in these scenarios.
testing and input generation.
in our manual inspection we found a few users who determined that a library was producing an incorrect result because they had performed the same numerical operation in a more rigorous but lessefficient library and found a mismatch in the results.
this suggests that differential testing of numerical libraries couldbe particularly beneficial for numerical software for which oracles are often difficult to obtain.
this would be particularly useful to detect many of the bugs that we classified as requiring domain specific knowledge the majority in this paper .
even in the absence of a known good implementation differential testing of numerical libraries would help to detect many of the most difficult bugs by simply finding mismatching results across different numerical libraries taking advantage of the tendency of different implementations to fail in different ways in challenging tasks.
we also found that techniques for input generation e.g.
are in great need to uncover many of the problems described throughout this paper.
program analysis.
program analysis tools could be developed to automatically detect a good number of numerical bugs including special value bugs accuracy bugs and convergence bugs.
in particular current challenges in the estimation ofroundoff errors e.g.
treatment of loops in present interesting problems that will have a great impact on being able to find a variety of numerical bugs.
in the case of dynamic tools the main challenge will be to produce results that can begeneralized to many program runs while imposing low runtime overhead.
a delicate balance between static and dynamic approaches is needed.
automated bug fixing.
as with other kinds of bugs automated bug fixing of numerical bugs seems to be the most challenging.
the first step would be to apply the state of the art e.g.
in automated bug repair to see if any of the bugs we identified could be fixed.
for certain narrowly definedcases simple pattern matching may provide some low hanging fruit in the meantime.
vi.
r ela ted work empirial studies.
previous empirical studies have examined a variety of software systems and characterized their defects and associated information on various dimensions .
we summarize some of the most related studies that have inspired our work.
a study of performance bugs examined performance bugs from apache chromium gcc mozilla and mysql classifying them according to their root cause how the bug was introduced how it was exposed how it was fixed and its location in the code.
a more recent study examined fixed performance bugs in popular client side and server side javascript projects finding eight common root causes.
in our study we found that about of numerical bugs have performance related symptoms.
to the best of our knowledge previous studies on performance bugs did not find instances of numerical bugs causing performance problems.
similar studies have focused on other aspects of software.
for example dietz et al.
investigate integer overflow bugs in c c programs by performing dynamic checking on the spec cint benchmarks and also identifying undefined integer overflows in widely used open source software.
our study instead investigates floating point numerical bugs and inaddition to overflow and underflow develops a comprehensive categorization of bugs empirically.
in recent studies e.g.
the authors have developed tools to address specific bug types using pattern matching based detection and correction techniques informed by empirical analyses which in part motivated our empirical study.
tools for numerical code.
a variety of tools have been developed to improve the reliability and performance ofnumerical applications.
for example techniques have been devised to estimate roundoff errors.
fptaylor focuses on providing a tight overapproximate estimate on roundoff errors by rigorously handling the transcendental functions using symbolic taylor expansions.
darulova and kuncak present a programming model that provides real data type for programmers and guarantees a sound compilation to finiteprecision implementation that meets the desired precision.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
at the same time a series of dynamic tools have been developed to test and optimize numerical code.
for example techniques have been proposed to generate inputs that lead to large roundoff errors that can be used to test numerical code.
tools for precision tuning dynamically search over the types of variables or instructions to find a mixed precision configuration that produces an accurate result with respect to an error threshold and improves performance.
herbie rewrites floating point arithmetic expressions with mathematically equivalent alternatives in order to improve the accuracy of the computations.
though promising the above mentioned tools as many others remain narrow in scope and have not been adopted by real world applications.
we hope that our study on realworld numerical bugs can provide context to improve existing tools and to inform the design of future tools so that they engage better with the full depth and breadth of numerical programming problems in the real world.
vii.
c onclusions this paper presented the first comprehensive study of realworld numerical bug characteristics.
we examined issues and pull requests from a diverse set of numerical libraries numpy scipy elemental lapack and gsl.
from these we identified and carefully examined numerical bugs.
we found that numerical bugs can be largely categorized into four groups accuracy bugs special value bugs convergence bugs and correctness bugs.
correctness bugs with comprise the single most common category and are also the ones that require the most expertise.
correctness bugs are followed by special value bugs convergence bugs and accuracy bugs with and respectively.
we discussed the characteristics of numerical bugs.
we found that the most common symptom for numerical bugs are wrongresults followed by crashes and bad performance.
we discussedthe opportunities to automate detection and fixing of numerical bugs.
while merely using patterns applies to few bugs there is still promise in these being applicable to a large number of libraries and library clients.
we found that many bugs could potentially be detected using program analysis and that there may be opportunities in the area of automated bug fixing as well.
as for existing tools we did not find evidence that suggests the current use of testing analysis tools by library developers or users.
thus more work is also required to facilitate the adoption of numerical tools in the real world.