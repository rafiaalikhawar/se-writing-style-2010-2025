featured model based mutation analysis xavier devroey precise research center university of namur belgium xavier.devroey unamur.begilles perrouin precise research center university of namur belgium gilles.perrouin unamur.bemike papadakis snt serval team university of luxembourg michail.papadakis uni.lu axel legay inria rennes france axel.legay inria.frpierre yves schobbens precise research center university of namur belgium pierre yves.schobbens unamur.bepatrick heymans precise research center university of namur belgium patrick.heymans unamur.be abstract model based mutation analysis is a powerful but expensive testing technique.
we tackle its high computation cost byproposing an optimization technique that drastically speeds up the mutant execution process.
central to this approach is the featured mutant model a modelling framework for mutation analysis inspired by the software product line par adigm.
it uses behavioural variability models viz.
featured transition systems which enable the optimized generation configuration and execution of mutants.
we provide results based on models with thousands of transitions suggestingthat our technique is fast and scalable.
we found that itoutperforms previous approaches by several orders of magnitude and that it makes higher order mutation practically applicable.
keywords mutation analysis variability featured transition systems ccs concepts software and its engineering !software testing and debugging software product lines general and reference!performance .
introduction mutation analysis is an established technique for either evaluating test suites e ectiveness or supporting test generation .
it works by injecting artificial defects called mutations into the code or the model under test yielding mutants and measures test e ectiveness based on the number of detected mutants.
researchers have provided evidence that detecting mutants results in finding real faults and that tests de signed to detect mutants reveal more faults than other test fnrs postdoctoral researcher permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita tion on the first page.
copyrights for components of this work owned by others thanacm must be honored.
abstracting with credit is permitted.
to copy otherwise or re publish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
criteria .
this has been shown to be the case for model based mutation too aichernig et al.
report that model mutants lead to tests that are able to reveal implementation faults that were neither found by manual tests nor by the actual operation of an industrial system.
in addition model based mutation s premise is to identify defectsrelated to missing functionality and misinterpreted specifi cations .
this is desirable since code based testing fails to identify these kinds of defects .
despite its power mutation analysis is expensive due to the large number of mutants that need to be generated and assessed with the candidate test cases.
while this problem has been researched for code based mutation e.g.
it remains open in the model based context.
since typical real word models involve thousands of mutants and test suitesinvolve thousands of test cases millions of test executionsare needed.
addressing this problem is therefore vital for the scalability of mutation.
this a known issue that requires further research as pointed out in the surveys of jia and harman and o utt .
to address this problem we take inspiration from past research on software product lines spl .
as suggested in our vision paper we propose an approach to model mu tants as members also called variants orproducts o fa n spl.
considering mutants as part of a family rather than inisolation yields a considerable advantage shared execution at the model level .
this contrasts with existing spl approaches which require code and hence do notapply to model mutants.
the key idea of our approach is to encode the mutants as products of an spl.
to do so we use a feature diagram fd together with a featured transition system fts that represent the variations i.e.
applications of mutationoperators and the behaviour of the mutants respectively.
ftss have been proposed by classen et al.
to compactly model the behaviour of an spl.
they consist of a transition system ts where each transition has been tagged toindicate which products are able to execute the transition.we use fts to embed all the mutants in one model called thefeatured mutants model fmm .
to optimise test execution we rely on the fmm to i only execute tests with mutants that are reachable by the tests ii share common transitions among multiple executions and iii merge di erent executions that reach previously visited states.
therefore instead of performing mul tiple runs i.e.
executing a test against each mutant weperform a single execution of the fmm.
ieee acm 38th ieee international conference on software engineering we performed an empirical evaluation which demonstrated that fmm i yield significant execution speedups i.e.
from .
to times faster compared to previous approaches ii make mutation analysis applicable to models much larger than those used in previous studies and iii make higher order mutation feasible.
in summary the contributions of this paper are fmm a compact model which allows to easily generateand configure mutants of any order of a transitionsystem.
an implementation of fmm in the variability intensive behavioural testing vibes framework making it the first mutation testing tool for behaviouralmodels that supports higher order mutation.
our implementation is publicly available at info.unamur.be vibes .
a shared execution technique that allows executing tests with all relevant mutants in a single run.
tothe authors knowledge this is the first approach that optimizes model based mutation analysis.
an empirical evaluation on a mix of real world and generated models.
empirical results that contradict the general belief that higher order mutation testing is too computationally expensive to be practical .
instead they suggest that it can be applied to real world systems.
the rest of this paper is organised as follows section recalls the main concepts of mutation testing and variability modelling sections and present our approach and re sults respectively.
finally section discusses related workand section concludes the paper.
.
background .
transition systems in this paper we consider transition systems as a fundamental formalism to express system behaviour.
our definition is adapted from where atomic propositions havebeen omitted we do not consider state internals definition transition system ts .
at si sa tuple s act trans i where sis a set of states actis a set of actions trans s act sis a transition relation such that the ts is deterministic with s s2 2trans sometimes denoted s1 !s2 and i2sis the initial state.
as a convention we start and end executions in the initial state.
this ensure that they are finite.
fig.
a presents a simple example ts of a payment operation on a card payment terminal cpt .
the model starts in the initial init state where the card holder has to insert his card.
the cpt will select a means of payment e.g.
visa mastercard american express etc.
and negotiate with the card chip to agree on a protocol for the transaction.
transactions can be either performed on line or o line using a pin code ora signature.
once the card holder has been identified thecpt will perform the transaction o line or on line and in this case it will contact the card issuer to authorize the transaction and update the information on the card chip.table summary of model based mutation ap proaches for behavioural model.
reference yearemployed modelsav.
toolhom fabbri et al.
statechart o utt et al.
statechart belli et al.
2006finite state automata statechart belli et al.
2011finite state automata statechart x aichernig et al.
state machines x aichernig et al.
state machines lackner schmidt state machines aichernig et al.
state machines krenn et al.
state machines x this paper 2016transition systemsxx once the transaction has been completed or aborted the card holder may remove her card from the cpt.
in model based testing test cases are derived from such a model of the system.
for instance a test case is atc insert card select app negociate with card abort remove card for the ts of fig.
a .
test selection can be guided by coverage criteria.
for instance the all actions coverage criterion specifies that all the actions of the consideredts must appear in at least one of the selected abstract test cases.
in this paper we do not consider test concretization see e.g.
.
.
mutation testing in model based testing mutants are introduced based on model transformation rules that alter the system specifica tion.
these rules are called mutation operators .
an example of mutant obtained from the state missing operator applied on the go offline state of the cpt system is presented in fig.
.
there are two kinds of mutants first order mutants when the original and the mutant models di er by a single model transformation and higher order mutants derived from the original model after multiple transformations.
when a mutant is detected by a test case it is called killed.
in the opposite situation it is called live.
in our case a mutant is killed if a test case cannot be executed.for instance the test case tc insert card select app negociate with card check pin online goo ine update card info remove card will kill the mutant of fig.
b since it fails to execute completely.
a test case that can becompletely executed on a mutant will not detect kill it e.g.
the test case atcdefined in section .
will leave the mutant of fig.
b live because it can be executed com pletely.
to measure the adequacy of testing a standard metric called mutation score is used.
it is defined as the ratio of mutants killed by the test set under assessment to the total number of considered mutants.
to calculate the mutation score one has to execute the whole test set against everyselected mutant.
in our case we consider deterministic ts and stop the execution of a test case as soon as the ts is unable to fire the next action.
for the test case tcon the mutant in fig.
b the execution is stopped when it reaches 656init card in abortedinsert card abort remove card app uninitselect app app initnegociate with card abort ch verifiedcheck pin onlinecheck pin offlinecheck signature go online go offline no gono go go offline go onlineabort issuer respondedask issuer issuer rejects completedissuer accepts update card info accepted update card info remove card a original ts init card in abortedinsert card abort remove card app uninitselect app app initnegociate with card abort ch verifiedcheck pin onlinecheck pin offlinecheck signature go online no gono go go onlineabort issuer respondedask issuer issuer rejects completedissuer accepts accepted update card info remove card b state missing mutant figure card payment terminal the original system and a mutant state goo ine thechverified state as it may not execute the next action goo ine i ntc and the mutant ts is considered killed by tc.
the mutant would have been kept live if another test case tc0had followed the online path after chverified .
mutant execution is a time consuming task especially for large models.
in our experiments it took days to run the mutants of our model with states against each test case.
the times reported in table are for running one mutant against one test case.
in the following we will callthis approach of executing each test against each mutant model separately the enumerative approach .
related studies on model based mutation approaches for beahvioural model are briefly described in table publication year of publication model types used available tooland the use of higher order mutation hom .
in literature most of the existing approaches have been evaluated based on small models using a brute force technique that executesall mutants with all tests.
this results in extremely longexecution times and hinders scalability in space and or execution time .
we believe that tool scalability and the lack of available tools are the main reasons why there are fewmodel based testing studies and they mostly use small models.
in their recent survey jia and harman motivate the need for additional research on using mutation on program artefacts other than code.
we believe that since our tool is publicly available and scales well it will foster experimenta tion on model based mutation.
.
variability modelling spl engineering is a sub discipline of software engineering based on the idea that we can build products aka mem bers of the same family by systematically reusing software assets.
some assets are common to all members whereas others are only shared by a subset of the family.
such variability is commonly captured by the notion of feature defined as a unit of di erence between products.
individual features can be specified using languages such as uml and their relationships by feature diagrams fds .
an ex ample of fd is provided at the top of fig.
.
in this figure the root feature m has sub features smi aex wis connected using a xoroperator.
fds have their semantics defined in terms of valid products i.e.
legal combinations of features.
in the fd of fig.
a valid prod uct is m smi smi goo ine while the product m smi smigoo ine aex aexissuer accepts is invalid because it does not respect the xorconstraints.
fd semantics is formal and fds can be encoded as boolean constraints.thus sat or bdd solvers are commonly used to enumerate products or to check their validity.
the main challenge in spl engineering is to deal with the combinatorial explosion induced by the number of possible products nfornfeatures in the worst case .
ftss address this problem and enable the e cient behavioural model checking of spls .
ftss are transition systems tss where each transition is labelled with a feature expression specifying which products of the spl can execute the transition.
a fts is thus a compact representation of the behaviour of an spl definition featured transition system .
af e a t u r e dt r a n s i t i o ns y s t e m f t s i sat u p l e s act trans init d w h e r e s act trans are defined according to definition dis an fd trans7!
!
true false is a labelling function specifying for each transition which valid products may execute it this function is represented asab o o l e a ne x p r e s s i o no v e rt h ef e a t u r e so f d a n d init s7!
!
true false at o t a lf u n c t i o nt h a ti n d i c a t e si fa state i2sis an initial state for a product p2 s u c ht h a t for every product p2 there is exactly one initial state which allows one to model mutants that change the initialstate of the system.
a fts example is provided at the bottom of fig.
.
transition ch verifiedgoo ine smi goo ine !
goo ine may only be executed in products with a valid configuration where the smigoo ine feature is not selected.
657init card in abortedinsert card abort remove card app uninitselect app app initnegociate with card abort ch verifiedcheck pin onlinecheck pin offlinecheck signature go online go offline no gono go smi no go go offline smi go fflinego onlineabort issuer respondedask issuer issuer rejects completedissuer accepts aex issuer accepts update card info accepted update card info remove cardstatemissing smi actionexchange aex wronginitstate wismutant m xor smi go offline smi no goxor aex issuer accepts wis card in wis card inwis card in abort aex issuer accepts figure featured mutant model of card payment terminal .
compact mutants model the key idea behind our approach is to represent mutants asa family of variations of the system under test sut .
we model the sut s behaviour using a ts called the original ts to distinguish it from the mutant ts .
it is possible to model these variants as an fts and its corresponding fd where each feature corresponds to one application of one mutant operator on the original ts.
the fts and the fd represents all the possible mutants of an original ts and is called the featured mutants model fmm .
for example the fmm of fig.
has an fd at the top with mutation operators the state missing smi operator which produces a mutant where one state is missing the action exchange aex operator which produces a mutant where one transition has its action changed to another action and the wrong initial state wis operator which produces a mutant where the initial state has been set to another state.
in this instance of the fd the smi operator has been applied twice smi goo ine sminogo and the aex and wis operators have been applied one time each aex issuer accepts wiscard in .
this fd represents four mutants where at most one leaf feature is selected.
thefts at the bottom of fig.
represents all the possible vari ations corresponding to the four mutation operators of the original ts.
in order to derive one particular mutant ts from the fmm one may use the fts projection operator .
practically this operator will first need a valid product representing the desired mutant e.g.
p m smi smi goo ine then each feature expression of the fts is evaluated with features belonging to the product replaced by true and other features replaced by false finally transitions with a featureenumerative fmm input ts input ftsfmm s1a a b0 s1a a b output tsm output fts0 fmm s1a b b0 s1a 1a aex b aex b figure an example of mutation the aex operator expression evaluated to false i.e.
where p false are removed from the fts and the initial state is set to the only state such that the feature expression on the initial transition is true i.e.
where init i p true .
for instance the projection of the fmm of fig.
on pwill produce the mutant ts of fig.
b .
.
building the featured mutants model we rely on the state of the art operators proposed by fabbriet al.
to generate mutants from a ts smi state missing operator removes a state other than the initial state and all its incoming outgoing transitions wis wrong initial state operator changes the initial state aex action exchange operator replaces the action linked to a given transition by another action ami action missing operator removes an action from a transition tmi transition missing operator removes a transition tad transition add operator adds a transition between two states tde transition destination exchange operator modifies the destination of a transition.
each operator can be used to generate mutants using the enumerative approach where each mutant is formed as a new variation of the original ts possibly introducing non determinism with aex and tad operators or using the fmm approach where each mutant is an addition to the fd.
we detail hereafter the mutant generation procedures.enumerative approach in the enumerative approach each operator op is defined as a model transformation withinput a ts ts representing the behaviour of the sut.
it produces another mutant ts ts m representing the result of an operator on ts.
for instance aex operator shown on the left of fig.
replaces the action aon transition s1a !s0 byb.
algorithm details the enumerative approach where the set of mutants muts is produced by applying each op erator in ops with random parameters a number of times defined for each operator by the times function on the original ts line .
658algorithm mutant generation enumerative approach require ts s act trans i original ts ops the set of operators to use times op!n function specifying for each operator the number of applications ensure return muts set of produced mutants muts for all op2opsdo for all ibetween 1and times op do muts muts op random ts end for end for return muts algorithm mutant generation fmm approach require ts s act trans i original ts ops fmm set of operators to use times opfmm!n function specifying for each operator the number of applications ensure fmm ftsfmm fdfmm fmm representing the mutants t!true ftsfmm s act trans i fd fmm fdfmm m initialised to root feature m for all opfmm2opsdo for all ibetween 1and times op do fmm opfmm fmm end for end for return fmm fmm approach in the fmm approach an operator op fmm is defined as a model transformation of a fmm representing existing mutants that produces a fmm representing the previously existing mutants and the resultof the op fmm mutation on the original ts obtained in the fmm s fts by replacing the features by false in thefeature expressions .
for instance on the right of fig.
the aex fmm operator replaces the action aon transition s1a !s0of the base model by bas follows .adding the feature expression aex on transition s1 a !
s0 stating that s1a aex !
s0may be fired only if the aexmutation is inactive and if 2is true .adding a transition s1b aex !
s0 stating that the transition is fired with a baction only if the aexmutation is active and if 2is true .adding an aexfeature to fdfmm representing the mutation done by opfmm not shown in fig.
.
algorithm details the automated fmm building approach.we start with the original ts line and a function that labels each transition with a true feature expression line1 .
we then apply mutation operators ops fmm as p e c ified number of times times op line .
contrary to the enumerative approach the mutation operators are appliedon the fmm under construction which is reused in the next iteration line .
this is mandatory as the fmm contains all the previous mutations that are taken into account in the model transformations e.g.
the iexpressions in fig.
.
as we choose to only perform opfmm mutations on the originalalgorithm fmm mutant execution require fmm ftsfmm fdfmm fmm model tc .
.
.
n test case defined over the original ts ensure live feature expression representing the mutants live after executing tc live false paths i !
... n n !
i paths in ftsfmm for all p2paths do live live v i2p i end for return live ts this forbids operator composition on previously mutated elements.
so ensures that first order mutationmaps to only one edit of the original ts.
further detailsabout the operators and specificities of the transformations can be found on the vibes website in a technical note.
.
featured mutants model execution in our context test cases are defined as a sequence of actions in a ts ts such that one execution form a path starting from and ending at the initial state i tc .
.
.
n such that9 i !sk .
.
.
s l n !i .
recall that in the enumerative approach if a test case cannot be executed by the mutant denoted mtc or does not end in the initial state considered as the accepting state it is considered killed.
otherwise the mutant is considered live.
the set of live mutants according to tcand the mutant set muts i s defined as liveenum muts tc m2muts mtc in the fmm approach a test case can be executed on an fmm s fmm fts noted ftsfmmtc if there exists at least one mutant able to execute it.
the enumerative approach executes each test case on each mutant separately.in contrast one execution of a test case on the fmm explores all the reachable mutants identified by the collected feature expression .
the set of live mutants in the fmm approach is defined as livefmm fmm tc p2 fd fmm fts p fmmtc concretely all possible paths in ftsfmm starting from iand ending in iwill be considered which allows to deal with possible non determinism introduced by a mutation.
thelive mutants are those able to execute at least one of those paths i.e.
those for which the product psatisfies all the feature expressions on the transitions of the considered path.
for instance the test case tc insert card select app negociate with card check pin o ine goo ine update card info remove card 659executing the fmm of fig.
it will fire the following transitions wis card in !
init initinsert card !
card in card inselect app !
app uninit app uninitnegociate with card !
app init app initcheck pin o ine !
chverified chverifiedgoo ine smi goo ine !
goo ine goo ineupdate card info !
completed completedremove card !
init these transitions may only be fired by mutants for which all the features expressions are true.
in such a case mutants need to respect the following constraint wis card in smigoo ine all mutants in the fd of fig.
that satisfy this feature expression remain live after the execution of tc.
the set of mutants killed by the test case is computed using theconjunction of fd fmm and the negation of this feature expression fdfmm wiscard in smigoo ine which corresponds to the set of mutants m wis wiscard in m smi smigoo ine in practice livefmm fmm tc will produce a feature expression representing all the live mutants as detailed in al gorithm .
initially the algorithm computes all the paths infts fmm corresponding to the sequence of actions in tc line .
for one path the conjunction of the feature expressionsgives the mutants able to execute this path line .
e ort is saved this way by ignoring unreachable mutants and by sharing the execution of the common transitions.
this conjunction disjuncts with the conjunctions of the others paths to get the feature expression representing all the live mu tants line .
this step results in savings due to mergingof the considered executions.
for performance reasons thepaths variable uses a tree representation to merge common prefixes of di erent paths.
we implemented the di erent mutant operators described in section .
in order to perform classical mutation test ing enumerative approach as well as fmm generation and execution in vibes our variability intensive behavioural testing java framework .
.
fmms as higher order mutants model higher order mutants can be valuable since some of them tend to be hard to kill .
however the number of mutants grows exponentially according to the order nand explode the involved cost.
this is obvious in algorithm for the enumerative approach which generates all the n mutants to generate the n order ones.
using the fmm approach modelling higher order mutation comes at nearly no cost.
in a fmm fts fmm fdfmm the set of allowed mutants i.e.
variations in ftsfmm is represented by the feature diagram fd fmm .
for instance the constraints in the fdfmm of fig.
allows to have exactly one mutant at a time.
meaning that all valid mutants products of this fmm will have at most one variation from the original ts made by a mutation operator e.g.
fig.
b has figure the order fmm of the cpt example only smigoo ine feature active.
the norder mutants are represented by modifying the constraints on the fdfmm so that they have exactly nmutations at a time.
it means that generating the fmm using algorithm will also generate the fts which will be the same for order to nfmms.
for instance the card payment terminal has the same fts for all orders as shown in fig.
but di er on the fd that is described by fig.
by the group cardinality stating that exactly subfeatures have to be selected.
the fmm will compactly represent all the c4 order mutants.
all order mutants using the same argument we generalize to higher order mutants.
in this case the fmm represents a single model with all possible norders of mutants with nbetween and the number of possible mutants which is the number of leaf features in the fmm sfd .
by setting the group cardinalities of the fd in fig.
4to .
a valid product mutant of the fd will contain at least one applications of mutation operator e.g.
a product p m smi goo ine but also p0 m smigoo ine sminogo o rp00 m smigoo ine wiscard in etc.
in this case the fmm compactly represent all thep4 k 1c4 k n order mutants.
the number of live mutants after the execution of a test case tc on a fmm fmm can be obtained by counting the number of sat solutions i.e.
the number of possible assignments for each feature to fdfmm livefmm fmm tc .
where fdfmm is the fmm s fd encoded as a boolean formula i.e.
the disjunction of the mutation operator ops fdfmm w o2opso.f o r a test set ts the number of live mutants is computed by counting the number of sat solutions to o2opso!
tc2tslivefmm fmm tc !
.
.
evaluation we formulate our research questions as follows rq1 how does the fmm scheme compare with the enumerative approach in terms of execution time ?
rq2 is higher order mutation under the fmm scheme tractable?
.
setup we compare two test execution approaches the enumerative approach which is the classical mutation testing ap proach used by previous research where each test caseis executed against each mutant and the fmm approach where each test case is executed only once on the fmm.
models we consider models from di erent sources with varying size.
table details the employed models.
for each model we measure the number of states states the number of transitions trans.
the number of actions act.
the average degree of the di erent states that correspond to the average number of incoming or outgoing transitions per 660table models characteristics model states trans.
act.
avg.
deg.bfs heightback lvl tr.
s. v. mach.
.
minepump .
claroline .
105age rr .
elsa rr .
elsa rrn .
random .
state avg.
deg.
the maximal number of states between the initial state and another state when traversing the ts in breadth first search bfs height the number of transitions starting from a state and ending in another state with a lower level when traversing the ts in breadth first search back lvl tr.
.
our models are the soda vending machine model s. v. mach.
which is a small example modelling the behaviour ofa machine selling soda and tea the mine pump mine pump that models the behaviour of a pump which has to keep a mine safe from flooding by pumping water from a sink while avoiding methane explosions the claroline website claroline that represents the navigational usages of the online course management platform used at the uni versity of namur it has been reverse engineered from an apache log using a gram inference method the wordpress models age rr elsa rr and elsa rrn that represent the navigational usage of two di erent wordpress instances.
they are also reverse engineered using a gram inference method.
fortheage rr andelsa rr we considered only the request type e.g.
post get head and the requested resource e.g.
index.php in the sequences used.
for the elsarrn model we considered the request type the requested resource and the parameter names e.g.
?page in the se quences used as input of the gram inference method .
the random model has been generated based on the following procedure a we generate a set of random graphs basically directed arcs and nodes and compute the di erent measures from table except number of actions onthem b we selected those graphs that are likely to represent a real system according to pel anek i.e.
thosehaving a small average degree a large bfs height and a small number of back level edges in this order c we applied a random labelling multiple times and computed the occurrence probability i.e.
the probability of the labels toobtain a set of randomly generated tss d we selected the ts that had the following properties the probability of the most occurring label in the ts was less than or equal to6 and the cumulated probability of the most frequentlyoccurring labels was less than or equal to e w e ended up with one random model as recorded in table .
test cases for every model we generate one set of tests using random walks on the ts and one set satisfying the all actions criterion.
the test sets were then executed withthe enumerative and the fmm processes.
table records the average size and standard deviation of the randomly generated test cases the size of the generated all actionscoverage driven test set and the average size and standard 1these properties are likely to represent real systems table test sets characteristics model rand.
test set all act.
test set avg.
sizestd.
dev.nb.
t.c.avg.
sizestd.
dev.
s. v. mach.
.
.
.
.
minepump .
.
.
.
claroline .
.
.
.
age rr .
.
.
.
elsa rr .
.
.
.45elsa rrn .
.
.
.
random .
.
.
.
table mutant operators model wis tmi aex tde tad ami smi total s. v. mach.
minepump claroline age rr elsa rr elsa rrn random deviation of its test cases.
the size of the random test set is arbitrarily fixed to test cases.model mutants we used the operators presented in section .
.
operators modifying states wis andsmi or transitions tmi aex tde tad and ami resp.
were applied arbitrarily for of the number of states ortransitions resp.
in the model with as bottom value .since the operands are randomly chosen we forbid multiple applications of any operator on the same operands to avoid duplicated mutants .
table presents the number ofmutants generated per operator for the studied models.mutant execution to avoid execution time bias from the underlying machines we execute each test case times with each considered mutant for the enumerative version and on the fmm for the family version .
experimentation was performed on an ubuntu .
lts linux kernel .
machine with intel core i3 .10ghz processor and 4gb of memory.
the complete experiment took approximately weeks.
.
results and discussion fig.
presents the distribution of the test execution time in logarithmic scale on the yaxis for each studied model with a box plot.
the first two columns represent the to tal execution time taken by each test case when executed on the live mutants and on the killed mutants according to the enumerative approach.
the third box presents the execution time of the fmm fmm approach .
note that while the killed mutants do not require a complete execu tion in the enumerative approach it is required for the fmmmutants.
this might provide an advantage to the enumerative approach.
to assess this we consider the killed and the live mutants separately.
in all cases we measure only the execution of the models avoiding time bias due to i ooperations.
as the execution time of a test case partiallydepends on its size the high number of outliers in fig.
is explained by the variation of the test cases sizes.
tables and record di erent statistics over the execution time of the models in seconds.
for the enumerative approach executing a test case on mutants that will remain live takes more time than executing the same test cases on mutants that are killed.
this was expected since killed mutants do live killed fmm20 500s.
v. mach.time in microsec.
live killed fmm50 500minepump live killed fmm5e 5e 5e 5e 04claroline live killed fmm1e 1e 1e 06age rr live killed fmm100 50000elsa rrtime in microsec.
live killed fmm1e 1e 1e 1e 05elsa rrn live killed fmm1e 1e 1e 1e 06random figure execution time time required by a test case to execute with live killed mutants and the fmm mutants time is measured in sec.. not require a complete execution of the test case.
in both cases the fmm execution runs faster i.e.
running a test case on all the mutants at once is very fast despite themore complex needed exploration of the fmm s fts.
regarding rq1 the box plots of fig.
and the values of tables and confirm that the execution time requiredby the fmm approach is considerably lower than the timerequired by the enumerative approach.
the di erence escalates to several orders of magnitude when considering livemutants.
the di erence between family based and enumerative approaches increases with the size of the model indi cating the improved scalability of our approach.
to evaluate the statistical significance we use a wilcoxon rank sum test for the di erent models we considered we obtain a p value of .343e for the random model and p values smaller than .2e for the other models confirming the hypothesis that fmm significantly outperforms theenumerative approach when considering .
significance level.
.
.
all order mutation table presents the number of all order mutants for our models the number of mutants live after executing the ran dom and all actions test sets computed using sat4j .
.
and their mutation score.
mem.
overflow denotes an overflow during sat solving improving this step by for instance reducing the boolean formula to process is part of our future work.
columns and give the sat solving computationtime we set a timeout of hours .
overall our results suggest that higher order mutation under the fmm scheme is tractable answering positively torq2 .
in particular all order mutation achieves very good mutation scores ms .
when compared to first order mutation when this score can be computed.
in our future work we intend to i improve the scalability of mutation score computation and ii assess the practical relevance of higher order in test sets comparison.
only one mutant is live for the soda vending machine and the mine pump models.
this mutant is a first order mutant resulting from the tad operator.
indeed the tad operator adds new transition which cannot be detected by test cases solely generated from the original ts since this transition does not exist in this model.
all order mutation enables to quickly kill mutants of any order an to focus on the interesting ones from a selective mutation perspective.for example the remaining live mutants resulting fromthe execution of the all action test suite are relevant to studythe mutation operators involved.
of course they can also be 662table mutant 1st order execution time in seconds minimal maximal median mean standard deviation for every test case on all live and killed mutants of the enumerative method and of the fmm.
mutation score ms of the all actions and random test sets are provided for each model.
s. v. mach.
model all act.
ms .
random ms .
live m. killed m. fmm speedup min.
.
max.
.
median .
mean .
s.dev.
.
.1minepump model all act.
ms .
random ms .
live m. killed m. fmm speedup min.
.
max.
.
median mean .
s.dev.
.
claroline model all act.
ms .
random ms .
live m. killed m. fmm speedup min.
.
max.
.
median mean s.dev.
22age rr model all act.
ms .
random ms .
live m. killed m. fmm speedup min.
max.
84median mean .1e s.dev.
elsa rr model all act.
ms .
random ms .
live m. killed m. fmm speedup min.
.
max.
median mean s.dev.
84elsa rrn model all act.
ms .
random ms .
live m. killed m. fmm speedup min.
max.
.6median mean s.dev.
table mutant execution time in seconds random model all act.
ms .
random ms .
live m. killed m. fmm speedup min.
max.
median .3e mean .3e s.dev.
table all order mutation score.
for each test set and model the table records the number of possiblemutants mut.
the number of live mutants afterthe test set execution lv.
the mutations score ms and the sat computation time t in seconds.
model mut.
all act.
rand lv.
ms t lv.
ms t s. v. mach.
.
.
.
.
minepump .
.
.
.
claroline .49e timeout timeout age rr .71e timeout timeout elsa rr .46e .
.
.
.
elsa rrn .61e .
.
.
.
random .62e mem.
overflow mem.
overflow used to generate test cases killing them in order to augmentthe test suite.
exploring all order ms in selective mutation or test case generation scenarios are part of our future work.
.
.
threats to validity internal validity our experiments were performed on models academic examples the soda vending machine and the the mine pump larger real world models claro line age rr elsa rr and elsa rrn and a randomly generated one.
these models come from di erent sources and represent di erent kinds of systems embedded systems designed by an engineer and web based applications where the model has been reverse engineered from a running in stance.
the random model was built upon a set of generated tss in order to match the real system state space measures as described by pel anek .
construct validity we chose to apply mutants for of the states and or transitions of the mutated model.
thismight result in more or less mutants than needed for the larger models.
however this is expected when using mutation.
additionally since model based mutation is applied to the system s abstraction abstract actions represent many concrete actions.
it is therefore important to ensure a goodcoverage of most of the model actions.
ts and fts executions are di erent and do not use the same algorithms.
in order to decrease the bias in measuringexecution time both executions of the models have beendone using vibes our variability intensive behavioural testing framework java implementation.
the two execution classes are di erent but use a variant of the same algorithm described in section .
.
moreover we used the stopwatch java class to measure the call to the execute method i.e.
model loading and result writing time have been omitted .
finally we ran each test case times on each mutant model classical and fts to avoid bias due to process concurrency.external validity we cannot guarantee that our results are generalizable to all behavioural models.
however we recall the diversity of the model sources hand crafted reverse engineered and randomly generated to match realsystem state space as well as the diversity of consideredsystems.
.
related work program mutation was proposed as a rigorous testing technique .
the idea was then applied to test specifica tion models and recently to resolve software engineeringproblems such as the improvement of non functional properties locating and fixing software defects .
here we briefly discuss works related to model based mutation and testing and code based mutation.
.
model based mutation the idea of model based mutation has been elicited by gopal and budd who called it specification mutation .
specification mutation promises to identify defects related tomissing functionality and misinterpreted specifications .
this is desirable since these kinds of defects cannot be identified by any code based testing technique includingcode based mutation.
gopal and budd studied mutation for specifications expressed in logic.
similarly woodward mutated and experimented with algebraic specifications.
mutating models like finite state machines and statecharts has also beendone by fabbri et al.
.
hierons and merayo used probabilistic finite state machines.
all these studies suggested a set of operators and report some exploratory results.
amman et al.
suggested comparing the original and the mutated specification models using a model checkerin order to generate counterexamples.
these can then beused as test cases for the system under test.
black et al.
defined a set of operators based on empirical and theoretical analysis.
they also defined a process of using them based on the smv model checker.
contrary to our approach noneof these methods considers the mutation e ciency.
recent research focuses on mutating behavioural models.
aichernig et al.
defined uml state machines mutant operators and used them to insert faults in the models ofan industrial system.
these were used to design tests.
theapproach has a formal ground but neither considers optimising the test execution nor higher order mutation.
belli and beyazit compare event based and state based modelmutation testing.
both approaches were found to have simi lar fault detection capabilities.
the authors also report that it seems more promising to perform higher order mutation than first order mutation but did not provide evidence insupport of this argument.
krenn et al.
made available their momut tool but it is dedicated to test generation andnot mutant execution as our approach.
in their most recent work they use an idea similar to fmm by triggering mutations during exploration of the model avoiding execu tion of similar prefixes in di erent mutants.
additionally momut does not support higher order mutation.
other applications of model based mutation are to test model transformations and test configurations.
mottu et al.
defined a fault model relevant to the model transformation process based on which they propose a set of mutantoperators.
henard et al.
define mutant operators for feature models.
along the same lines lackner and schmidt define mutant operators for the mappings of features withother model artifacts.
finally papadakis et al.
demonstrated that model based mutation of the combinatorial interaction testing models has a higher correlation with the actual fault detection than the use of combinatorial interac tion testing.
thereby they provide ground to the argumentthat model based mutation might be more e ective than the other model based testing methods.
.
model based testing o uttet al.
define test criteria for state based specifications.
they also describe techniques to automaticallygenerate tests based on these criteria.
lackner et al.
suggested a test generation approach for product lines.
similar to our work they combine feature diagrams with state machines to handle the product line variability.
however their approach does not perform mutation and it is specific to software product lines.
briand et al.
proposed a technique for generating tests from statecharts.
their resultswere validated through code based mutation.
.
code based mutation in the context of code based mutation executable mutants are needed.
this introduces a compilation overhead which is proportional to the number of mutants.
to reduce this cost untch et al.
proposed mutant schemata an approach that replaces the program operators with schematicfunctions.
these functions introduce the mutants at runtime and thus only one compilation is needed.
ma et al.
suggested using bytecode translation a technique that introduces the mutants directly at the bytecode level and thusavoid multiple compilations.
to reduce the test execution overhead several optimizations have been proposed.
delamaro and maldonado suggested recording the execution trace of the original pro gram and consider only the mutants that are reachable byeach of the employed tests.
along the same lines mateo and polo suggested stopping mutant executions when they cause infinite loops.
jackson and woodward sug gested parallelizing the mutant execution process.
kapoorand bowen proposed ordering the mutants in such a way that the test execution is minimized.
papadakis and malevris used mutant schemata to identify mutants that are reached and infected by the considered tests.
they thenreduce test execution by considering only the mutants thatcause infection.
this technique was later evaluated by just et al.
who found that it reduces test execution by .
.
conclusion this paper presents a family based approach to modelbased mutation testing named featured mutant model.
itallows to generate mutants of any order and assess test effectiveness via an optimised execution scheme.
testing behavioural models with fmm is a completely automated process that involves no extra manual or computational e ort over previous approaches.
in short the use of fmm has the following benefits i it can easily reason about and generate behavioural mutants ii it can significantly speed up the evaluation of test suites against mutants up to times and iii it can e ciently perform higher order mutation.
but obviously thisis not the end of the story.
in our future work we will further investigate scalability issues regarding all order mutation analysis to be able tocompute mutation score for the largest models.
this implies the optimisation of the boolean formulas or approximate computation heuristics.
finally since mutants are a validsubstitute for real faults we envision to develop test case generation techniques based on mutation coverage of the fmm.