deep differential testing of jvm implementations yuting chen ting su zhendong su department of computer science and engineering shanghai jiao tong university china nanyang technological university singapore eth zurich switzerland university of california davis usa email chenyt sjtu.edu.cn tsuletgo gmail.com zhendong.su inf.ethz.ch abstract the java virtual machine jvm is the cornerstone of the widely used java platform.
thus it is critical to ensure the reliability and robustness of popular jvm implementations.
however little research exists on validating production jvms.
one notable effort is classfuzz which mutates java bytecode syntactically to stress test different jvms.
it is shown that classfuzz mainly produces illegal bytecode files and uncovers defects in jvms startup processes.
it remains a challenge to effectively test jvms bytecode verifiers and execution engines to expose deeper bugs.
this paper tackles this challenge by introducing classming a novel effective approach to performing deep differential jvm testing.
the key of classming is a technique live bytecode mutation to generate from a seed bytecode file f likely valid executable live bytecode files capture the seed f slive bytecode the sequence of its executed bytecode instructions repeatedly manipulate the control and data flow in f s live bytecode to generate semantically different mutants and selectively accept the generated mutants to steer the mutation process toward live diverse mutants.
the generated mutants are then employed to differentially test jvms.
we have evaluated classming on mainstream jvm implementations including openjdk s hotspot and ibm s j9 by mutating the dacapo benchmarks.
our results show that classming is very effective in uncovering deep jvm differences.
more than of the generated classes exposed jvm differences and more than triggered jvm crashes.
we analyzed and reported the jvm runtime differences and crashes of which have already been confirmed fixed including a highly critical security vulnerability in j9 that allowed untrusted code to disable the security manager and elevate its privileges cve .
keywords differential jvm testing live bytecode mutation semantically different mutants i. i ntroduction the java platform has been in widespread use and the java virtual machine jvm is its cornerstone to run java applications safely and portably .
defects in jvm implementations can lead to unexpected behavior or security breaches since a jvm implementation runs bytecode generated by java compilers but also any bytecode including bytecode engineered variants or even ones from attackers.
however few techniques exist to help systematically validate production jvms e.g.
hotspot ibm s j9 azul s zing and zulu and the jikes rvm and improve their robustness.
one promising approach is to differentially testing jvms running the same java bytecode .class o n different jvms to expose their differences.the state of the art technique is classfuzz which mutates java classes syntactically e.g.
by changing its modifiers or the type of a variable to differentially test jvms startup processes i.e.
loading linking and initialization .
despite its effectiveness in exposing differences in the jvms startup processes classfuzz cannot adequately exercise jvms bytecode verifiers and execution engines at the backend.
figure illustrates the high level process of how a jvm runs a class the bytecode verifier ensures that each class satisfies the necessary constraints at link time and subsequently the execution engine is responsible for just intime jit compiling and executing java bytecode .
few classfuzz generated classfiles can be used for deep jvm testing most of the mutated classes are rejected by the startup processes.
rarely can the accepted ones be used because the mutated program constructs variables and their types methods etc.
are likely dead i.e.
not reached during execution.
additional program constructs such as methods and call chains would need to be carefully designed for the mutated constructs to be involved during bytecode verification and execution.
to this end we introduce live bytecode lbc mutation a novel practical technique for generating valid executable bytecode from seed classes.
the key insight behind lbc mutation is to systematically manipulate and alter a bytecode file s live bytecode its sequence of executed instructions on a jvm.
deep jvm differences bugs can then be exposed using the resulting mutants since jvms may mistakenly analyze a mutant s dataflow during bytecode verification or verify bytecode with invalid stackmap frames1or execute uncommon bytecode instruction sequences in different manners.
two technical difficulties exist in realizing effective lbc mutation.
difficulty live mutant generation.
lbc mutation needs to be designed to generate live mutants for testing jvms.
a simple na ve strategy is to mutate a seed by arbitrarily inserting deleting or modifying instructions in its live bytecode.
however this leads to mostly illegal mutants i.e.
those rejected in a jvm s startup process as java bytecode needs to satisfy intricate syntactic and structural constraints.
for instance an invokestatic instruction should not be inserted unless its first operand refers to a static method etc.
1a stackmap frame defines the expected types of local variables and the operand stack of a method during the method s execution .
ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
simplified process of jvm running classes.
difficulty bytecode file selection.
for lbc mutation and effective jvm testing it is important to select suitable seeds and mutants.
in the case of classfuzz or other coverage directed fuzz testing techniques e.g.
afl it iteratively mutates a seed and retains a mutant if its coverage statistics on the target software system is unique.
however mutants cannot be similarly selected for testing jvms execution engines due to non determinism at runtime.
for instance a jit compiler allows methods to be compiled in parallel garbage can be collected as needed etc.
all these situations can occur in practice making the coverage statistics on a jvm s execution engine vary.
thus coverage uniqueness adopted by classfuzz is unsuited for our purpose.
this paper overcomes these difficulties by introducing classming a novel realization of lbc mutation for practical differential jvm testing.
it operates as follows.
first it records the seed classfile s live bytecode.
second it systematically manipulates and alters both the control and data flow in the seed s live bytecode to generate semantically different mutants from the seed.
finally the generated mutants are utilized for differentially testing jvms to expose their differences and thus potential defects.
more importantly classming takes an iterative process of mutant generation.
it iteratively generates classfile mutants and selects them using an acceptance choice .
the choice guides the whole process toward generating live diverse mutants.
in summary we make the following main contributions objective .
we tackle the challenge of deep validation of production jvms by testing their bytecode verifiers and execution engines.
different from classfuzz deep jvm testing requires abundant runnable diverse test classes.
our work is the first that aims at systematically generating such tests.
approach .
we introduce the lbc mutation approach and a novel practical realization classming for effective differential jvm testing.
given a seed classming can create a large number of test classes with diverse behaviors to help explore deep jvm differences.
evaluation and defect reporting .
we have evaluated classming on mature jvms such as openjdk s hotspot and ibm s j9.
using the 14dacapo benchmarks as seeds classming created about 70k test classes of which more than exposed jvm runtime differences and more than triggered jvm crashes.
we have analyzed andreported these differences and crashes of which have already been confirmed as jvm defects and fixed e.g.
dataflow may be incorrectly analyzed race conditions may prevent jvms from shutting down cleanly .
the ibm product security incident response team psirt has also confirmed a critical security vulnerability in j9 that allowed untrusted code to disable the security manager and elevate its privileges.
ii.
a nillustrative example this section uses a concrete example to motivate and illustrate lbc mutation which intervenes a class s normal execution by rewriting its executed bytecode.
our realization of lbc mutation classming employs the soot framework to analyze dataflow and bidirectionally transform between a class and its jimple code soot s intermediate representation of a java class transforming a classfile into its jimple code and dumping a jimple file into a classfile.
figure 2a shows the jimple code of a seed class seed .i n itsmain method entermonitor r0 line and exitmonitor r0 line denote respectively the monitor enter and exit on object r0 and synchronize the code block between them.
note that when entermonitor r0 is executed r0is null line .
when the class is run on hotspot and j9 both jvms strictly conform to the jvm specification and throw a nullpointerexception as the jvm specification states that if objectref is null monitorenter throws a nullpointerexception .
.
the instructions after line 8are nonlive that is the monitor on r0is not entered exited at runtime.
next we show three example mutants of seed .
each reveals a specific jvm difference when it is run on hotspot and j9.
mutant .
in the first example classming changes the control flow of the seed class thus altering its semantics.
as figure 2b shows two goto statements lines and are inserted into seed .
it is clear that the resulting class mutant1 is semantically different from seed .
in particular when entermonitor r0 is executed r0is an initialized object rather than null entermonitor r0 will be run for times while exitmonitor r0only once.
when it is run on hotspot and j9 mutant1 triggers a difference between the two jvms hotspot throws a runtime exception while j9 runs the class normally.
this difference is caused by the existence of structured locking which occurs during a method invocation when every exit on a given monitor matches a preceding entry on that monitor .
if a jvm enforces the rules on structured locking and if some rule is violated during invocation of the current method the return instruction throws an imse illegalmonitorstateexception .
in the jvm specification .
hotspot enforces the rules on structured locking throwing an exception because when main returns the number of monitor entries performed does not equal the number of monitor exits.
j9 does not enforce the rules and allows main to return normally.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1class seed 2public static void main string r0 r0 new string specialinvoke r0.
string void init r0 null entermonitor r0 code after is nonlive ... code block t o synchronize exitmonitor r0 return a jimple code of a seed class.
both hotspot and j9 throw a nullpointerexception for this class.1class mutant2 2public static void main string r0 r0 new string goto label1 specialinvoke r0.
string void init skip r0 null skip label1 entermonitor r0 ... exitmonitor r0 return c jimple code of mutant2 .
hotspot runs the class normally while j9 throws a verifyerror .
1class mutant1 2public static void main string r0 int loopcount loopcount r0 new string specialinvoke r0.
string void init goto label1 r0 null skip label1 entermonitor r0 ... loopcount loopcount if loopcount goto label1 exitmonitor r0 return b jimple code of mutant1 .
hotspot throws an illegalmonitorstateexception and j9 runs the class normally.1class mutant3 2public static void main string r0 r0 new string specialinvoke r0.
string void init goto label1 label2 r0 null goto label3 label1 entermonitor r0 ... goto label2 label3 exitmonitor r0 return d jimple code of mutant3 which causes hotspot to throw anillegalmonitorstateexception and j9 a nullpointerexception .
fig.
a seed class and its three classming generated classes.
mutant .
as figure 2c shows we create mutant2 by inserting agoto statement into seed at line .
in mutant2 when entermonitor r0 is executed r0is uninitialized.
when mutant2 is run on hotspot and j9 it triggers another jvm difference.
hotspot runs the class normally while j9 throws a verifyerror as j9 detects that r0 an uninitialized object reference is monitored.
the hotspot developers explained that it should be valid to allow an uninitialized reference to be monitored and there would no potential harm in invoking a monitorenter exit on an uninitialized instance although application developers may find the result confusing since the jvm specification states that the verifier rejects code that uses the new object before it has been initialized .
.
at the end the j9 developers agreed with this explanation and confirmed the difference to be a defect in j9 and fixed it.
mutant .
the final example is mutant3 .
as figure 2d shows after three goto statements lines are inserted theprogram invokes monitorenter on object r0 setsr0tonull and invokes monitorexit onr0.
hotspot and j9 throw different exceptions on mutant3 which can be propagated if the exceptions are caught and handled respectively.
j9 throws a nullpointerexception at line as the specification states that if objectref is null monitorexit throws a nullpointerexception .
.
hotspot on the other hand makes a rarely known optimization even to hotspot developers when the method completes abruptly and the rules on structured locking are violated the jvm throws animse and disposes the other exceptions.
summary.
the three illustrative examples clearly demonstrate the strength of lbc mutation.
mutating a seed class in particular changing its control and data flow can help create mutants with diverse semantics.
when run on multiple jvm implementations these mutants may expose jvm behavior differences and thus potential defects.
note that some differences can only be exposed by classes generated via two or more authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iterations of mutation assuming that each iteration inserts one goto statement.
our realization classming provides an iterative process in which live mutants can be continuously created for differential jvm testing.
iii.
a pproach classming takes an iterative process to generate test bytecode files.
as figure shows given a seed bytecode file f classming aims at creating a mutant of fby manipulating f s live bytecode section iii a and iteratively creates and selectively accepts f s mutants section iii b during each iteration an acceptance choice chooses either the resulting mutant or its seed for the next iteration.
the generated classfile mutants are then employed to differentially test jvms and uncover differences.
any jvm differences if exposed become oracles for finding flaws in the tested jvms.
interesting differences include jvm crashes verification differences e.g.
jvms verify mutant2 in section ii differently and execution differences e.g.
hotspot and j9 throw different exceptions for mutant1 .
a. live bytecode mutation live bytecode of a classfile frefers to when fis run on a jvm a sequence of executed bytecode instructions l i0 i1 ... im .
similarly we use live mutants and live methods to denote those that can be executed at runtime.
an lbc mutation is performed on fby instrumenting a hooking instruction hi at a program point before i0 i m.a s figure shows a hooking instruction hijacks control flow and alters f s execution to l prime .
here we call the program point after ii 1ahooking point hp and that before ijatarget point tp .
the resulting mutant say g with the live bytecode instructions l prime can become a corner case for triggering jvm differences since it may contain abnormal stackmaps or unusual dataflow that can confuse a jvm or even crash it at runtime.
algorithm shows a process of lbc mutation including three main steps select lbc mutators select methods to mutate and insert hooking instructions.
step select lbc mutators .
we leverage the five soot s jimple instructions goto return throw lookupswitch and tableswitch as his soot uses jimple instructions and only five can alter a program s control flow.
as lbcm utation in algorithm shows an lbc mutation picks up an hi by random and instruments it into the seed classfile altering the control and data flow at runtime e.g.
enforcing the execution to jump an exception to be thrown or an invoked method to return .
1loopcount m m is a positive integer ... 3label0 insert a label at a target point ... 5loopcount loopcount 6ifloopcount goto label0 insert an hi at a hooking point ...each hi as shown in the above code segment is supplemented with a condition e.g.
if loopcount which is to bound the possible iterations for each introduced loop.
this avoids the occurrences of infinite loops as well as enables additional altering of control flow.
an instrumented hi can also be deleted.
it helps create mutants with diverse hi combinations or prevent them from getting stuck e.g.
a mutant may be run slowly if it contains a computation intensive loop .
step select methods to mutate .
during each iteration classming selects one class method to mutate.
random selection offers no guidance some methods need to be more frequently mutated than others because of their more complex structures and richer instructions.
thus we select methods by a potential function potential m inst mutation where a method m s potential relies on its size inst and how many times it has already been mutated mutation .
intuitively the higher a method s potential the more likely it needs to be mutated.
a method s potential decreases after it is mutated.
to capture this intuition we choose methods with probabilities meeting a geometric distribution that allows methods with higher potentials to be selected with higher probabilities.
let mdenote an array where all the live methods in fare stored and sorted in descending order of their potentials.
let sizedenote the size of m. let the kthmethod in mbe chosen with probability p kp where pis the success probability.
obviously the sum of the probabilities needs to reach i.e.
p size .
here we let p size where is a very small value e.g.
.
.
a method can then be chosen from musing rand a random real value between .0and1.
.
the kthmethod is selected to be mutated when p k r p k since kis an integer denoting an array index we have k log rand size indicating that method selection relies only on rand .
step insert hooking instructions .
lbc mutation alters a program s dataflow which is carefully analyzed by jvms during bytecode verification.
here dataflow is mainly introduced via data dependencies established among variable definitions defs and uses uses .
select hooking points .
an hi deliberately destroys a seed s data dependencies for creating corner cases.
to simplify our discussion we assume that after an hi is instrumented all data dependencies i.e.
def use def def use use anduse def that pass through the hooking point will be intercepted which may result in abnormal data flow e.g.
a n object is redefined orundefined .
the more data dependencies are intercepted the more likely the mutant contains abnormal dataflow that a jvm may fail to analyze.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
an overview of the classming approach.
fig.
mutating a seed file with live bytecode lto a mutant withl prime.
in order to intercept as many data dependencies as possible classming selects a hooking point judiciously during each iteration.
as select hooking point in algorithm shows classming randomly chooses nprogram points as candidates in this algorithm n .
it then calculates the potential data dependency interceptions w.r .t.
these candidates respectively lines and chooses the one with the most interceptions as a hooking point line .
existing data dependencies are obtained by analyzing the seed s live bytecode.
select target points .
an lbc mutation can require one or more labels to be inserted into the bytecode along with an insertion of a goto or aswitch instruction.
in order to generate a mutant semantically different from the previously generated mutants classming favors inserting labels before instructions missed from previous runs.
as select target point in algorithm shows it chooses at random a target point candidate say tp and accepts tpif the successive instruction say i has never been hit in the previous runs accepts it with a high probability e.g.
.
if iis not hit by the last mutant or accepts it with a low probability e.g.
.
.
this strategy allows seed coverage a fitness function for guiding mutant acceptance see section iii b to increase during the mutation process.
b. mutant acceptance as explained in section i distinct coverage statistics w.r .t.
a jvm cannot be used to accept classfile mutants.
thus classming employs seed coverage as the fitness function and adopts the metropolis hastings mh algorithm for accepting mutants during the mutation process.
seed coverage .
seed coverage is a metric denoting how many instructions in the initial seed are covered by its mutants asthe fitness function for accepting mutants for further mutations.
this fitness function directs the mutation process in two respects mutants with different seed coverage values have different semantics runtime behaviors and live mutants can be more easily created from intermediate seeds with higher seed coverage.
to this end we record the live bytecode of each mutant.
assume fhas xinstructions yof which can be hit when a mutant say g is run on a jvm.
the seed coverage of gw.r .t.
fis calculated by cov seed g y x a sampling process .classming adopts the mh algorithm an mcmc markov chain monte carlo sampling method for selecting mutants as intermediate seeds.
the mh algorithm aims to accept a sequence of samples whose distribution closely approximates the desired distribution .
in our setting we let each sample be the seed coverage of a mutant and let the exponential distribution be the desired distribution.
the desired distribution facilitates choosing of mutants with high seed coverage for further mutations since these mutants have the more vitalities than those with low seed coverage.
a mutant with low seed coverage may easily lead to cases that cannot be further mutated.
for mcmc sampling we begin with a transformation of the fitness function into a probability density function p f zexp cov seed f where is a constant in our setting .
x and za partition function that normalizes the distribution.
we assume that the proposal distribution is symmetric.
classming uses metropolis choice for sampling acceptance a f g min p g p f min exp cov seed f cov seed g the metropolis choice directs the mutation process.
as algorithm shows we run and collect the seed coverage of each mutant and accept live diverse mutants using the acceptance probability lines we reject the nonlive authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm lbc mutation input f a seed classfile livecodeset l0 ... ln a set of live bytecode of the previously generated mutants output g a classfile mutant function lbcm utation f livecodeset method select method tomutate ln t select an lbc mutator by random iftis to instrument a goto instruction then hp select hooking point method ln insert if ... goto newlabel athp tp select target point method livecodeset insert newlabel attp else if tis to instrument a lookupswitch or a tableswitch instruction then ... similar to goto but with multiple target points else if tis to instrument a return or athrow instruction then ... similar to goto but without any target points else ... select from method a live hi and remove it g update f replace method infwith its mutant return g function select method tomutate ln m getlivemethods ln m sort m sort methods using their potentials rand new rand return m.get log rand size function select hooking point method ln letthe live bytecode on method be choose and compute i.e.
the data dependency interceptions w.r .t.
let a program point after ii be chosen sets0 s1 fori do def i anduse i compute the s0 s0 def i use i variables defined and used in i for i do respectively s1 s1 def i use i set s0 s1 ... choose and compute return .size .size?
function select target point method livecodeset while true do select tp a target point candidate before an instruction iinmethod ifi l0.asset ln.asset then return tp rand new rand ifi ln.asset rand probhigh then return tp ifi ln.asset rand problowthen return tp bytecode files line since it is unlikely to obtain a live bytecode file through mutating a nonlive seed.
all the generated mutants including those accepted and rejected and the nonlive ones will be employed as tests in differential jvm testing.
iv .
e v aluation we evaluated classming on two mainstream jvm implementations i.e.
hotspot and j9.
our evaluation is aimed at answering three research questions rq1 can classming generate sufficient valid test bytecode files for jvm testing?
rq2 how effective are the classming generated mutants in testing jvms?
rq3 what are the root causes of detected jvm differences?algorithm iteratively creating and selectively accepting mutants input f a seed bytecode file iter the number of iterations output set mutant acc rej nonlive mutant acc rej nonlive contains classfile mutants for jvm testing acc and rej contain live ones that are accepted and rejected respectively and nonlive contains nonlive ones rejected by a jvm s startup process.
mutant acc rej nonlive setlivecodeset f.livecode for i 1toiter do g lbcm utation f livecodeset if gis created successfully then mutant mutant g ifcov seed g 0then rand new rand ifrand a f g then acc acc g livecodeset livecodeset g.livecode f g else rej rej g else nonlive nonlive g return mutant acc rej nonlive a. evaluation setup approaches for comparison .
we compared classming with the following approaches to investigate the benefits of each of classming s strategies.
classfuzz is a mutant of classfuzz .
it alters classfiles using six instruction level mutators provided by classfuzz i.e.
inserting replacing deleting exchanging duplicating and cloning bytecode instructions .
note that classfuzz itself was not included in our evaluation since it does not aim for deep jvm testing.
clrandom manipulates at random control and data flow.
clgreedy employs a greedy strategy in accepting mutants a mutant is accepted only when it allows the accumulative seed coverage to increase.
the table below summarizes the differences of the four evaluated approaches including the mutators and the strategies for creating and accepting mutants.
approach mutatorshow to create a mutant?how to accept a mutant?
classming hi insertions deletions lbc mutation the mh algorithm classfuzz classfuzz mutators lbc mutation the mh algorithm clrandom hi insertions deletions random mutation the mh algorithm clgreedy hi insertions deletions lbc mutation a greedy algorithm benchmarks and configurations .
we mutated the dacapo benchmarks a collection of open source real world applications such as eclipse lusearch and pmd .
as table i shows for each benchmark classming mutated its initial classfile creating mutants of this benchmark.
note the non initial classfiles were not used as seeds as they are not definitely linked at runtime.
for each seed the number of iterations iter was set about of the lines of jimple instructions inst allowing the seed to be sufficiently mutated.
these benchmarks have been mutated for 88k times.
hotspot java was used as the reference jvm for generating classfile mutants and collecting coverage statistics.
hotspot build ea and j9 build .
were chosen for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i seeds iteration times and numbers of test classfiles generated.
in this table we use v land nto denote the numbers of generated mutants live mutants and nonlive ones respectively.
here we have v l n. benchmark initial class seed inst iter classming classfuzz clrandom clgreedy v l n sbr v l n sbr v l n sbr v l n sbr avrora ... avrora main.class .
.
.
.
batik ... rasterizer main.class .
.
.
.
eclipse ... eclipsestarter.class .
.
.
.
fop ... fop cli main.class .
.
.
.
h2 ... h2 tpcc.class .
.
.
.
jython ... python util jython.class .
.
.
.
luindex ... luindex index.class .
.
.
.
lusearch ... lusearch search.class .
.
.
.
pmd ... pmd pmd.class .
.
.
.
sunflow ... sunflow benchmark.class .
.
.
.
tomcat ... tomcat control.class .
.
.
.
tradebeans ... daytrader launcher.class .
.
.
.
tradesoap ... daytrader launcher.class .
.
.
.
xalan ... xalan xsltbench.class .
.
.
.
total .
.
.
.
differential testing.
the evaluation was run on the ubuntu .
machines with intel core i7 cpu .40hz and 8gb ram.
the time of executing each mutant was constrained within seconds.
metrics .
we repeated each approach five times and chose the test suite with the most mutants for comparison.
four metrics were taken to evaluate classming against the other approaches.
stillborn rate to quantitatively measure whether an approach can generate sufficient valid tests we computed the stillborn rate of each approach sbr mutant iter where mutant cf.algorithm is the test suite for jvm testing and mutant is its size.
this rate is widely used in mutation testing to evaluate the applicability and effectiveness of mutant generation techniques .
in this paper stillborn mutants are jimple files that are syntactically invalid and thus cannot be transformed into test classfiles.
the higher the rate is the more stillborn mutants are created.
accumulative seed coverage to measure whether a seed has been fully exploited for generating mutants we computed the accumulative seed coverage w.r .t.
a test suite mutant g1 g2 ... by running the mutants on a jvm e.g.
hotspot asc cov seed g1 cov seed g2 ... where is an operator that merges two mutants e.g.
g1and g2 seed coverages.
intuitively the higher the coverage the more thoroughly the original seed is exploited by its mutants.
jvm code coverage the seed coverage and jvm s code coverage are combined to direct exploring the input space and triggering jvms functionalities e.g.
error handling .
thus it is still interesting to investigate how the coverage is improved by the mutants.
we ran the seeds and the classming test suites on hotspot and collected their jvm statement coverage statistics say jcov .
we computed the coverage increment achieved by each test suite mutant using jinc jcov mutant jcov seed jcov seed where merges the coverage statistics.
jvm differences we counted the jvm differences found by each approach analyzed each difference we found and reported any potential defects to jvm developers.
b. rq1 sufficiency of classming generated mutants stillborn rate .
table i compares the sizes of the test suites.
in 88kmutations classming clrandom and clgreedy generated and 210bytecode files with the stillborn rates of .
.
and .
respectively.
in contrast classfuzz generated 163bytecode files with a stillborn rate of .
about higher than those of the other approaches.
table i clearly demonstrates that the lbc mutators taken by classming clrandom and clgreedy can help generate many more test bytecode files than the mutators taken by classfuzz .
the main reason is that bytecode mutation is performed on jimple code.
classfuzz manipulates a jimple file by inserting and or deleting some arbitrary instructions which frequently results in invalid jimple files that cannot be transformed into classfiles.
the lbc mutators on the other hand are less likely to destroy the file s syntactical integrity although .
.
of the resulting jimple files still violate soot s constraints e.g.
a method must return a value if it has a return type a label cannot be inserted before variable declarations etc.
.
these results lead to our first finding finding classming achieved a stillborn rate nearly lower than that of classfuzz the lbc mutators allow test bytecode files to be sufficiently generated.
c. rq2 effectiveness of classming generated mutants accumulative seed coverage .
table ii shows the seed coverage achieved by the test suites.
let the dacapo benchmarks be used as the baseline for measuring coverage improvement.
when the seeds were run 852of6 219statements were covered.
when the mutants were run the seed coverage could be improved by15 .
the improvement on seed coverage is obvious.
these approaches take mutators that can alter control flow and employ seed coverage as a guidance allowing nonlive bytecode instructions to be run and the accumulative seed coverage to increase.
however many test suites could not achieve of seed coverage as some seed methods may not be reachable.
furthermore the classming clrandom test suites obtained higher seed coverage than the clgreedy ones demonstrating authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii seed coverage achieved by the test suites and jvm differences uncovered by the four approaches.
here each number inside denotes the number of unique execution differences.
benchmark inst asc classming classfuzz clrandom clgreedy baseline classmingclassfuzz clrandom clgreedy crashes exec.diffs verif.diffs crashes exec.diffs verif.diffs crashes exec.diffs verif.diffs crashes exec.diffs verif.diffs avrora .
.
.
.
.
batik .
.
.
.
.
eclipse .
.
.
.
.
fop .
.
.
.
.
h2 .
.
.
.
.
jython .
.
.
.
.
luindex .
.
.
lusearch .
.
.
.
.
pmd .
.
.
.
.
sunflow .
.
.
.
.
tomcat tradebeans .
.
.
.
.
tradesoap .
.
.
.
.
xalan .
.
total .
.
.
.
.
that the mh algorithm works better than the greedy algorithm in exploring these seeds.
the greedy algorithm usually fails in constructing live bytecode for hitting deep instructions.
these results lead to our second finding finding the classming test suites achieved higher seed coverage than the clgreedy ones the mh algorithm enables more effective exploration of the mutant space w.r .t.
a seed than the greedy algorithm.
jvm code coverage .
in real circumstance it is expensive to run all of the mutants and collect their jvm code coverage.
thus we picked up the last classfiles in each classming test suite to compose a mini test suite and ran it to collect jvm code coverage statistics.
in the evaluation the initial classfiles i.e.
the seeds covered 118lines of jvm s source code.
comparatively the mini test suites covered 095lines of code with increments of lines 668lines on average .
it denotes that the mutants supplement the seeds in covering additional jvm s source code during testing.
although the coverage increments appear relatively low considering that hotspot has 260k lines of code the classming approach is promising in exploring jvm s code because only the initial classfiles were mutated and only a small number of mutants were run for coverage analysis.
additional seeds and techniques may be used to maximize jvm s code coverage which makes interesting future work.
table iii enumerates the top source packages that contribute to the coverage increment i.e.
lines on average .
the source packages w.r .t.
the optimizing jit compiler opto the shared objects libjvm objs and the bytecode verifier classfile contribute to .
of the coverage increment.
the results lead to our third finding finding the classming mutants indeed facilitate deep testing of jvms bytecode verifiers and execution engines.
jvm differences .
we used the test suites to differentially test jvms and summarized the jvm differences in table ii.
inthis table the accepted and rejected test classfiles generated from the benchmarks batik eclipse h2 lusearch pmd tradebeans tradesoap and xalan were not used in differential jvm testing.
the main reason for this is that user threads exist in these seed classfiles and differences if revealed may not expose jvm defects.
the results clearly demonstrate that classming and clrandom uncover more jvm differences crashes than classfuzz and clgreedy .
in addition only classming generated test suites revealed verification differences indicating classming is the most effective in creating classfiles having abnormal dataflow.
however the numbers of execution differences in table ii can be bloated if a seed can trigger an execution difference its mutants tend to trigger the same type of differences.
thereafter we counted the unique execution differences in this way let g be a mutant mutated directly from f. let gtrigger an execution difference say dif f when it is run on hotspot and j9.
dif f isunique iffcannot trigger dif f .
specifically we find that most of the execution differences uncovered by clrandom were redundant and the classming test suites triggered and4.
as many unique differences as those uncovered by the classfuzz and clrandom test suites respectively.
the results lead to our fourth finding finding only the classming test suites revealed verification differences they also exposed and4.
as many unique jvm differences as those exposed by the classfuzz and clrandom test suites respectively d. rq3 difference analysis and bug report we analyzed and reported a number of jvm differences to the jvm developers of which have been confirmed as jvm defects and or fixed.
we summarize below some typical defects and differences.
security vulnerability in j9 .
the ibm product security incident response team psirt has confirmed a critical security vulnerability in j9 that was easy to exploit and allowed untrusted code to disable the security manager and elevate its privileges a cve with a cvss base score .
.
next authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii top hotspot s source packages that contribute to the coverage increment.
package main use jinc opto opto compiler i.e.
the c2 compiler a highly optimizing bytecode compiler libjvm objs shared objects in libjvm.so classfile manipulation of java classes runtime vm s runtime management cpu x86 vm facilities for supporting the execution of jvm on x86 cpus201 c1 c1 compiler ci internal jvm compiler interfaces oops manipulation of objects utilities hotspot s source utilities code management of code stubs we present a simplified mutant that can expose this security vulnerability.
1abstract interface aextends java.lang.object public void go 4class search extends java.lang.object implements a public void go search r2 r2 this search ... j9 allows to use r2 here return public static void main search r2 r2 new search goto label1 ... r2 is i nitializ ed here label1 interfaceinvoke r2.
a void go in this program an insertion of an hi line leads to a use of an uninitialized object r2 at line .
j9 can run the class search normally which clearly indicates that its verifier fails to reject code that uses an object before it has been initialized.
more seriously this program shows that r2 can be transferred through invoking an interface method go line outside of main .
since a verifier verifies bytecode only at the method level assuming that all of the arguments transferred into a method have been initialized the verifier also fails to reject go e v e ni f r2 is used in it.
the jvm instruction invokeinterface corresponding to the jimple instruction interfaceinvoke becomes a backdoor that allows uninitialized objects to be transferred and used in other methods incurring high risks.
defects in bytecode verifiers .
j9 s verifier may miscalculate dataflow making it incorrectly accept or reject bytecode files.
for example j9 incorrectly throws verifier errors due to miscalculating local variables in stackmap frames.
j9 developers fixed the defect using a mutant of fop.
the patch is to ensure that the verifier checks long double type only when there are still local variables left in the stackmap frames.
j9 may incorrectly verify code with uninitialized objects.
for example section ii shows that j9 can mistakenly reject monitorenter monitorexit r0 when r0is uninitialized.
in some extreme cases j9 can make mistakes when verifying code segments containing instructions such as ifacmpeq ifacmpne ifnull ifnonnull andaastore .
for example j9 verifies the two code segments below differently but they are in fact semantically equivalent corresponding to if this o andif o this .
j9 may verify the next two bytecode segments differently while hotspot verifies them consistently.
new aload 0 aload 0 new if acmpeq if acmpeq jvm crashes .
j9 developers have fixed a race condition using a small test suite reported by us.
j9 can crash frequently with a report indicating there exists a double free problem.
j9 developers confirmed the cause of the crash to be a flaw in the jit compiler that prevented the jvms from shutting down cleanly.
the ibm developers also communicated to us that they used this test suite to expose a vm issue happening on old linux kernels.
j9 may crash when generating the messages for operand stack underflows.
its developers found that it would be too late to check stack underflow as they did before.
they fixed j9 by enforcing extra checking of stack underflow.
in addition j9 creates crash dump files when throwing outofmemoryerrors while hotspot does not.
other execution differences .
the execution differences revealed by the jython mutants see table ii have been eliminated since openjdk build was released.
in addition those revealed by the sunflow mutants were raised due to certain non determinism in the mutants.
v. r elated work we discuss two strands of related work jvm testing and mutation based fuzz testing.
jvm testing .
a number of test suites and benchmarks have been designed for jvm testing.
among them the suite most widely used is the java compatibility kit jck an extensive test suite provided by oracle to ensure the compatible implementation of the java platform.
jvms are required to meet jck in case of any changes or fixes.
many other java benchmarks such as the dacapo benchmark suite specjvm2008 specjbb2013 scimark .
cd x and stanford securibench have been developed for different purposes.
despite their importance in testing and regression testing these tests were not designed to expose defects in released jvms.
instead classming allows a large number of live tests to be created from existing classes and applications significantly enhancing jvm testing.
efforts have been spent on automated test generation for jvm testing.
sirer and bershad propose lava enabling users to use a production grammar to produce test classes .
yoshikawa et al.
propose to generate classes by producing a class s control flow and filling the bytecode into control flow edges .
freund and mitchell introduce a type system that can be applied to generate faulty classes and look for inconsistencies among bytecode verifiers .
calvagna et al.
model a jvm as a finite state machine for deriving classes .
compared with these techniques classming generates test authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv technical comparison among classming classfuzz and hermes .
technical difference classming classfuzz hermes .
the general process of test generation .
process an iterative mutation process an iterative mutation process a random mutation process .
how is the mutation process directed?mutants are selectively accepted.
mutators are selectively employed.
.
each iteration in the mutation process .
mutation objectivethe resulting mutant is live and semantically different from its seed.the jvm s startup processes for the resulting mutant and its seed are different.the resulting mutant is semantically equivalent to its seed w.r .t.
provided inputs.
.
type of seed mutant java bytecode file java bytecode file c source code .
mutatorsinserting deleting his for manipulating control and data flow in the seed129 mutators for mutating java bytecode syntacticallyinserting emi snippets fcb tg and tcb .
what needs to be altered?
live bytecode any construct of the seed live and dead code regions .
how is the resulting mutant accepted?mutant has high seed coverage and is semantically different from the seed.mutant is different from the seed in their jvm s code coverage.mutant is an emi mutant of its seed.
.
testing differential testing .
test subjects jvms verifiers and execution engines jvms startup processes c compilers .
test oracleverification execution differences among jvmsdifferences among jvms startup processesinconsistent outputs between a seed and its emi mutant classfiles by manipulating live bytecode of existing classfiles rather than leveraging grammars or formal models.
similar to classming classfuzz java fuzzer and dexfuzz advocate domain aware binary fuzzing to aid vm testing.
as we have observed classfuzz is effective in testing jvms startup processes but much less effective in deep jvm testing.
java fuzzer is also syntax directed aiming to generate tests that can cover more syntax features class inheritance complex loop patterns improved exception throwing patterns etc.
.
dexfuzz supports random alterations of a seed s control flow which is close to clrandom in our evaluation.
classming differs from these techniques in that it deliberately accepts live diverse class mutants.
mutation based testing .
program mutation which takes programs as seeds and then performs mutations becomes increasingly more important for validating compilers program execution engines and virtual machines .
le et al.
introduce the concept of equivalence modulo inputs emi for testing c compilers .
lidbury et al.
adapt emi to fuzz test opencl compilers .
sun et al.
propose hermes that creates equivalent modulo inputs on live code .
although classming also mutates live bytecode a mutant and its seed are enforced to be semantically different rather than equivalent.
table iv provides a detailed comparison among classming classfuzz and hermes .
clearly the three approaches take their respective strategies and follow their respective processes to generate program mutants.
as for the runtime optimization based jvms a set of live diverse tests can be much more suitable for deep differential testing them.
to the best of our knowledge classming is the first effort that systematically generates tests for this purpose.
american fuzzy lop afl is a well known security oriented fuzzer.
it employs compile time instrumentation and genetic algorithms to discover test cases that trigger new internal states in software binaries .
afl has been extended to fuzz execution engines.
skyfire leverages the vast amount of samples to learn grammar and semantic rules and then generates seed inputs that can be fed to afl to fuzz xslt xml javascript and rendering engines.
kelinci is an adapation of afl to fuzz java programs .
it may also be promising to adapt afl to fuzz jvms e.g.
by equipping it with domainspecific libraries such as asm and soot .
our work on classming still differs as it focuses on manipulating and altering control and data flow of seed classes.
the effectiveness of mutation based testing can be enhanced by the mcmc sampling methods .
in terms of jvm testing both classming and classfuzz adopt the metropolis hastings algorithm to guide their respective mutation processes.
the difference is that classfuzz utilizes the algorithm to prioritize its mutators while classming to effectively produce live diverse mutants.
vi.
c onclusion effective deep jvm testing is an important and challenging task.
we have presented lbc mutation and its realization classming to tackle this challenge.
the main objective is to generate abundant diverse executable classes and classming achieves this via novel systematic manipulation of the controland data flow of live bytecode.
our extensive evaluation results have clearly demonstrated classming s effectiveness and practicality in stress testing production jvms and exposing deep jvm differences defects.
besides continuing our own testing efforts we plan to make classming publicly available to aid jvm developers in their routine development.