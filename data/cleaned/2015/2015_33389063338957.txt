compiler bug isolation via e ective witness test program generation junjie chen college of intelligence and computing tianjin university china junjiechen9208 gmail.comjiaqi han peiyi sun hcst peking university moe china hanjiaqi spy pku.edu.cnlingming zhang university of texas at dallas usa zhanglm10 gmail.comdan hao lu zhang hcst peking university moe china haodan zhanglucs pku.edu.cn abstract compiler bugs are extremely harmful but are notoriously di cult to debug because compiler bugs usually produce few debugging information.
given a bug triggering test program for a compiler hundreds of compiler les are usually involved during compilation and thus are suspect buggy les.
although there are lots of automated bug isolation techniques they are not applicable to compilers due to the scalability or e ectiveness problem.
to solve this problem in this paper we transform the compiler bug isolation problem into a search problem i.e.
searching for a set of e ective witness test programs that are able to eliminate innocent compiler les from suspects.
based on this intuition we propose an automated compiler bug isolation technique diwi which proposes a heuristic based search strategy to generate such a set of e ective witness test programs via applying our designed witnessing mutation rules to the given failing test program and compares their coverage to isolate bugs following the practice of spectrum based bug isolation.
the experimental results on real bugs from popular gcc and llvm compilers show that diwi e ectively isolates .
.
bugs within top top compiler les signi cantly outperforming state of the art bug isolation techniques.
ccs concepts software and its engineering software testing and debugging .
keywords compiler debugging bug isolation test program generation this work is partially supported by the national key research and development program of china under grant no.
2017yfb1001803 the national natural science foundation of china under grant nos.
and it is also partially supported by nsf grants ccf ccf and amazon.
this work was done when he was in peking university.
corresponding author.
hcst is short for key lab of high con dence software technologies.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci c permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
reference format junjie chen jiaqi han peiyi sun lingming zhang dan hao and lu zhang.
.
compiler bug isolation via e ective witness test program generation.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa 12pages.
introduction software bugs in modern software systems can incur huge cost.
for example tricentis.com studied software bugs in companies all over the world and reported that these bugs incurred almost .
trillion cost and a ected over .
billion customers in .
among software bugs compiler bugs are especially critical since almost all software systems are compiled via compilers and a buggy compiler can potentially a ect all the software systems built on it.
therefore it is crucial to detect isolate and x compiler bugs.
although researchers have devoted dedicated e orts to compiler testing compiler bug isolation and xing are still a tedious and time consuming process since compilers are very complex and developers have to understand the root cause of a compiler bug and then determine the xing strategy.
in the literature lots of automated bug isolation techniques also known as fault localization e.g.
spectrum based techniques or sbfl slicing based techniques mutationbased techniques have been proposed.
however these techniques can hardly be applicable to compilers due to their scalability or e ectiveness problem.
first compilers like gcc are complex and large making it extremely expensive to perform advanced static dynamic analysis on a compiler.
therefore program analysis based techniques like slicing based techniques and mutation based techniques can hardly be used in compiler bug isolation.
for example we found that it can take over a month to execute only a limited set of gcc compiler mutants.
second due to the complexity of compilers the execution traces between passing and failing test programs tend to di er signi cantly.
therefore it is hard for sbfl which isolates compiler bugs by comparing coverage between passing and failing test programs to isolate compiler bugs e ectively which is also demonstrated in sections 2and5.
in other words automated compiler bug isolation is still challenging due to its inherent di culty.
given a bug triggering test program also called failing test program for a compiler developers need to manually isolate buggy compiler les i.e.
source les of compilers among all the touched compiler les when compiling the given failing test program.
however there are usually at least hundreds of compiler les involved in esec fse august tallinn estonia junjie chen jiaqi han peiyi sun lingming zhang dan hao and lu zhang the compilation.
all these les are suspects.
sbfl has demonstrated that passing tests can be regarded as witnesses to help reduce the suspicion of innocent program elements .
in this paper we call passing test programs that are able to eliminate innocent compiler les from suspects witness test programs .
however as demonstrated in sections 2and5 the widely used developer provided passing test programs are not e ective witnesses since they can hardly isolate compiler bugs e ectively.
therefore in this paper we aim to nd a set of e ective witness test programs.
with the set of e ective witness test programs and the given failing test program developers can automatically isolate buggy compiler les precisely.
with this intention we transform the problem of automated compiler bug isolation to a search problem i.e.
nding a set of e ective witness test programs to help isolate compiler bugs precisely.
however it is challenging to nd such a set of e ective witness test programs.
on the one hand each witness test program in the set is required to have a large witness capability i.e it can eliminate innocent compiler les as many as possible from suspects.
on the other hand the witness capabilities of di erent witness test programs in the set are required to be diverse i.e.
each of them can eliminate di erent innocent compiler les from suspects so that grouping them can be helpful to isolate the buggy compiler les precisely.
to solve this problem in this paper we propose the rst compiler bug isolation technique via searching for diversi ed witnesses called diwi diversi ed witnesses .
the main contribution of diwi lies in how to nd the set of e ective witness test programs.
to address the rst challenge we design a series of mutation rules for diwi to generate witness test programs via slightly mutating the given failing test program.
the key insight is that such minor changes are more likely to make the generated witness test program share a close compiler execution trace with the failing test program so that the generated witness test program can eliminate more innocent compiler les from suspects.
to address the second challenge diwi utilizes some heuristics to guide the construction of the set of e ective witness test programs.
more speci cally during the generation of each witness test program diwi considers the diversity of compiler execution traces between it and the already generated witness test programs so that these generated witness test programs can eliminate di erent innocent compiler les from suspects.
finally diwi ranks the les executed by the failing test program based on coverage comparison between the set of e ective witness test programs and the given failing test program like sbfl .
to evaluate the e ectiveness of diwi we constructed an extensive dataset including real world reproducible bugs from the popular gcc and llvm compilers.
the experimental results on all the studied bugs show that diwi e ectively isolates bugs out of within top buggy les signi cantly outperforming traditional sbfl.
as the core of diwi we investigated the contribution of our search based witness test programs compared with the developer provided test suite shipping with the buggy compiler which includes test programs passing on this compiler and the randomly generated passing test programs via csmith the most widely used random c program generation tool .
the results show that our search based witness test programs signi cantly outperform the latter two e.g.
isolating .
and .
more bugs than the developer provided passingstruct s1 intf0 intf1 intf2 a struct s1 b intc intfn1 if !c return b a return intmain struct s1 d a d a.f0 d.f2 fn1 a d if b.f1 !
builtin abort return a failingstruct s1 intf0 intf1 intf2 a struct s1 b intc intfn1 if !c return b a return intmain struct s1 d a d a.f0 d.f2 fn1 a a if b.f1 !
builtin abort return b passing 1struct s1 intf0 intf1 intf2 a struct s1 b intc intfn1 if !c return b a return intmain struct s1 d a d a.f0 d.f2 fn1 a d if a.f1 !
builtin abort return c passing figure llvm bug test programs and randomly generated passing test programs at the top position.
we also investigated the contribution of our heuristic based search strategy compared with the random search strategy during generation and explored the synthesis of diwi and developer provided test suites.
in summary this paper makes the following contributions idea.
an automated compiler bug isolation technique that transforms the problem of bug isolation to the problem of guided test program generation via search mutation.
implementation.
a practical open source tool implementing the proposed compiler bug isolation technique based on the llvm clang infrastructure.
benchmark.
an open source dataset containing reproducible real bugs from gcc and llvm compilers for future research on compiler bug detection isolation and xing.
study.
an extensive study on all bugs from our dataset demonstrating that the proposed technique is able to signi cantly outperform existing techniques our search based witness test programs the core of diwi have higher quality than the developer provided test suite and the randomly generated passing test programs for compiler bug isolation lastly components from developer provided test suites can further boost diwi e ectiveness.
motivation here we use an example to illustrate the motivation of this paper.
figure 1shows an example from llvm bug id where the left is the reported bug triggering test program.
when the buggy compiler revision in llvm trunk compiles the failing program it produces di erent outputs under the compilation options o1 and os .
the bug occurs at the le deadstoreelimination.cpp due to dead store elimination across basic blocks.
it is tedious for developers to manually nd the buggy le since this revision contains a large number of les i.e.
.
although traditional sbfl is reported to be e ective in other software systems it may not be e ective in compilers due to their characteristics.
we applied ochiai one of the most e ective formulae in sbfl based on the failing test program and the developer provided 224compiler bug isolation via e ective witness test program generation esec fse august tallinn estonia test suite and found the buggy le is ranked at the thposition out of les.
that is with traditional sbfl developers need to examine innocent compiler les before nding the buggy one indicating the inferior e ectiveness of traditional sbfl in compilers.
to isolate compiler bugs e ectively following sbfl instead of the developer provided passing test programs a set of e ective witness test programs are desirable.
intuitively witness test programs sharing similar execution traces except the buggy le with the given failing test program are more helpful to eliminate innocent les from suspects.
with this intuition we generated witness test programs by randomly introducing various minor changes into the failing test program making them share similar execution trace with the failing one.
then we compared their coverage to isolate the bug like sbfl .
in this way the buggy le is ranked at the th position demonstrating that these generated witness test programs by slightly changing the failing test program can help isolate the bug e ectively.
we further analyzed the isolation result using each witness test program and the given failing test program namely a pair of test programs to learn the performance of each individual witness test program.
among the pairs pair achieves the optimal result i.e.
top pairs rank the buggy le within the rst positions and pairs rank the buggy le after the thpositions.
overall there are many e ective pairs and a few low quality pairs by changing the failing test program minorly.
for example figure 1b shows the optimal witness test program that ranks the buggy le at the stposition which is generated by changing one variable of the failing test program in figure 1a while figure 1cshows a low quality witness test program that ranks the buggy le at the 33rdposition which is generated by replacing b.f1 with a.f1 .
since we use coverage comparison between test programs to isolate compiler bugs a witness test program eliminating more innocent les from suspects tends to mean that it shares a more similar compiler execution trace with the failing test program and also means that it has higher quality.
based on the above analysis we have the following observations first a set of high quality witness test programs can help isolate compiler bugs with the given failing test program second even if we change the failing test program minorly the obtained witness test programs are of various quality.
related work we discuss the most closely related work to compiler bug isolation.
automated debugging.
in the literature there are a huge amount of work on automated debugging e.g.
fault localization and program repair where our work targets the former.
as presented in section the existing fault localization techniques cannot work well on compilers.
in the literature there also exists mutation based fault localization which aims to mutate source programs to check the impact of each code element on the test outcomes.
however our work is to introduce the idea of mutation to slightly change test programs so as to generate a set of e ective witness test programs.
besides some work focuses on improving fault localization via test generation or test selection for ordinary programs.
however compiler inputs are programs and compilers are extremely complex and huge making none of theseexisting test generation and test selection techniques for better debugging directly applicable here.
in automated debugging our work is mostly related to compiler debugging .
most compiler debugging work focused on providing debugging messages visualization .
some work focused on reducing bug triggering tests to facilitate debugging .
in our work the provided bug triggering tests are already the reduced ones as required by compiler developers.
besides chen et al.
proposed a technique to rank test programs triggering bugs such that test programs triggering distinct bugs are early in the list.
holmes and groce further proposed a new metric to determine similarity of failing test programs to facilitate debugging.
in contrast our work aims to automatically isolate compiler bugs via e ective witness test program generation.
in particular zeller proposed to produce an entire cause e ect chain in gcc from input to result for facilitating compiler debugging.
actually cause e ect chain and our technique are complementary the former produces fault diagnosis information at the programstate level while the latter does this at the source code level the former manipulates in memory and may not handle external states the latter is more lightweight.
mutation testing.
mutation testing is one of the most e ective methods to measure test suite quality .
it deliberately seeds bugs into the original source program to simulate the bugs that developers often make in practice.
di erent from it our work aims to conduct test program mutation to generate a set of e ective witness test programs for facilitating compiler bug isolation.
here we both apply existing mutation rules from mutation testing and also design new mutation rules for compiler bug isolation.
compiler testing.
compiler testing usually happens before compiler bug isolation the target of our work .
most research on compiler testing focuses on test program generation test oracle construction and test execution acceleration .
the general idea of mutation is also applied to compiler testing which aims to generate di erent test programs as much as possible by faster diverging from the given seed program fordetecting deep compiler bugs .
di erent from them our work aims to utilize mutation for compiler bug isolation and the design goal of our mutation is to ip the compiler execution results i.e.
from failing topassing to generate a set of witness test programs close to a given failing test program .
to sum up the existing fault localization techniques cannot work well for large scale compiler systems while the existing applications of mutation cannot be directly used to solve the problem of compiler bug isolation.
therefore this work makes the rst attempt to isolate compiler bugs via search based mutation.
approach following the observations in section we propose a novel technique named diwi diversi ed witnesses to isolate compiler bugs.
in diwi we rst deliberately generate a set of e ective witness test programs and then compare them with the given failing test program like sbfl to isolate compiler bugs .
from section we know that it is hard to ensure each generated witness test program to be e ective and thus we use an aggregation mechanism to minimize the impact of low quality witness test programs in diwi.
therefore there are two key issues to the success of diwi.
first 225esec fse august tallinn estonia junjie chen jiaqi han peiyi sun lingming zhang dan hao and lu zhang a x n opua a1opaa2 b true false notb b1oplb2 a1opra2 s x a s1 s2 while b dos if b then s1elses2 figure syntax rules for the while language we need to carefully construct each witness test program to avoid introducing many low quality witness test programs otherwise we have too much noise.
second the witness test programs should evenly eliminate buggy suspects otherwise the aggregation process is prone to biases.
to help construct such a set of e ective witness test programs we de ne the following two criteria.
c1 each test program in the set of e ective witness test programs should share a similar compiler execution trace with the failing test program.
c2 test programs in the set of e ective witness test programs should have great diversity in their compiler execution traces.
however since the space of witness test programs is extremely huge in fact in nite to be precise e ciently generating such a set of e ective witness test programs satisfying the two criteria is challenging.
to satisfy the rst criterion we design a series of mutation rules for diwi to generate witness test programs by slightly mutating the failing test program.
intuitively such minor changes are likely to make the generated witness test program share a close compiler execution trace with the failing test program.
here we call our mutation witnessing mutation aiming to generate witness test programs with a large witness capability.
to satisfy the second criterion diwi utilizes some heuristics to guide the construction of the set of e ective witness test programs.
that is during the generation of a new witness test program diwi considers the diversity of compiler execution traces between the new one and the already generated witness test programs aiming to make their witness capabilities diversi ed .
in the following we introduce the designed witnessing mutation in section .
heuristic based witness test program construction in section .
and the aggregation mechanism for compiler bug isolation in section .
.
.
witnessing mutation as presented in section the existing applications of mutation cannot be directly used for compiler bug isolation.
in our context the goal of test program mutation is to introduce slightly di erent control and data ow information to ip the compiler execution results i.e.
from failing topassing to generate witness test programs.
therefore we design a series of mutation rules speci c to our mutation goal.
mutation rules.
to achieve the mutation goal of ipping the failing test program we manually analyzed historical compiler bugs to investigate why these test programs are able to trigger bugs and which characteristics of test programs can sensitively impact compiler execution results.
also to make the changes minor we design our mutation based on the learned knowledge at the level of ne grained program elements including variables operators and constants .
therefore we propose three mutation categories variable mutation operator mutation and constant mutation .
for variablemutation each program variable can potentially be changed into another compatible variable or type since program variables are the core of data dependencies and variable types can impact many compiler optimizations.
for operator mutation each program operator i.e.
arithmetic logical relational and unary can potentially be changed into another compatible operator since program operators can signi cantly impact data and control dependencies.
for constant mutation each program constant can potentially be changed into another value since many compiler bugs are triggered under some speci c values.
here we both apply existing mutation rules from traditional mutation testing and design new mutation rules for compiler bug isolation e.g.
variable type mutation .
more formally following the presentation of prior work w e view a test program as a syntactic skeletal structure pwith holes that can be con gured with various variables denoted as hole operators denoted as hole o and constant values denoted as hole c .
in this way we can ll each hole with mutated content to derive a new mutated program.
for the ease of presentation let us consider a while style language that has been widely used in the program analysis research .
the program syntax rules for the while style language are shown in figure .
in the rules non terminals a b and sdenote arithmetic expressions boolean expressions and program statements respectively terminals opa opl opr and opudenote arithmetic logical relational and unary operators respectively terminals xandndenote program variables and constants.
note that we use the while style language for the ease of presentation and our technique applies to a full edged language such as c. to obtain program mutations we recursively apply a mutation transformation to the while syntax rules.
figure 3presents the syntax rules for all our three mutation categories.
we denote all the three categories of transformations and program holes as jk and respectively i.e.
jk jk jko jkcand o c. in this way we formally de ne our mutation process.
d m s .
given any test program p we say pis amutation skeleton ofpi the abstract syntax tree denoted as tp ofpis the same as the transformed abstract syntax tree denoted as jtpk ofp i.e.
tp jtpk.
d f m .
given a test program p and its mutation skeleton p for all the nholes e.g.
... n within p rst order mutation lls each hole with the same content as pexcept lling one hole with a mutated content.
d h m .
given a test program p and its mutation skeleton p for all the nholes e.g.
... n within p high order mutation lls i i n holes with mutated contents while lling the rest holes with the same content as p. since we need diverse execution traces representing di erent ways to ip the failing test program for e ective compiler bug isolation for each mutation category we design a plurality of mutation rules.
the detailed mutation rules for each mutation category are shown in table .
based on the three types of holes we design speci c mutation rules in total and the full list can be found in the project webpage.
here we regard each speci c mutation operation on one type of program holes as an individual mutation rule e.g replacing x with y and replacing x with x are two di erent rules while replacing x 0with y and replacing x with z belong to the same rule.
226compiler bug isolation via e ective witness test program generation esec fse august tallinn estonia jak n opujak ja1k opaja2k jbk true false notb jb1k opljb2k ja1k oprja2k jsk jak js1k js2k while jbk dojsk if jbk then js1k elsejs2k a syntax rules for variable mutationsjako x n ojako ja1k oja2ko jbko true false notb jb1ko ojb2ko ja1ko oja2ko jsko x jako js1ko js2ko while jbko dojsko if jbko then js1koelsejs2ko b syntax rules for operator mutationsjakc x c opujakc ja1kcopaja2kc jbkc true false notb jb1kcopljb2kc ja1kcoprja2kc jskc x jakc js1kc js2kc while jbkc dojskc if jbkc then js1kcelsejs2kc c syntax rules for constant mutations figure skeletal program structures for the while style language table summary of mutation rules holes mutation rules inserting removing a quali er i.e.
volatile const and restrict inserting removing replacing a modi er i.e.
long short signed unsigned replacing a variable by another variable within the feasible scope oreplacing a binary operator by another binary operator within the same category e.g.
arithmetic relational and logical operators replacing removing a unary operator i.e.
pre x increment post x increment pre x decrement post x decrement and logical negation cchanging the value of an integer constant via a typical operation i.e.
value value value and value example.
we use an example to illustrate our witnessing mutation shown in figure .
figure 4ashows an original program p. figure 4b shows the mutation skeleton pofp.
figures 4cand4dshow two example mutated programs by lling holes in p where the former is a rst order mutation m1and the latter is a high order mutation m2.
the mutated holes have been highlighted within boxes.
mutation outcomes.
after generating a test program via mutation it is essential to judge whether it is passing or not.
there are two types of compiler bugs crash andwrong code bugs .
the former denotes that the compiler crashes when compiling a test program under some compilation options while the latter mainly denotes that the compiler miscompiles a program causing it to produce inconsistent execution results without any failure messages under di erent compilation options.
di erent types of bugs require di erent test oracles which determine whether a test program is passing or not.
if the given program triggers a crash bug the used oracle is whether the compiler crashes again under the same compilation options.
if the given program triggers a wrong code bug the used oracle is whether a generated program still produces inconsistent results across prior inconsistent compilation options.
diwi does not apply mutations on the code used as oracles e.g.
printf statements in c since it may cause the fake passing program problem i.e.
the constructed passing program via such mutations may not be really passing but the used oracle simply cannot reveal the bug.
more discussion about it is presented in section .
.
heuristic based test program generation due to huge search space and limited computational resources we cannot generate all witness test programs via mutation and then select a subset of e ective witness test programs from them.
one of the most cost e ective ways is that during each generation we generate a witness test program that di ers from existing ones as much as possible.
in diwi given a failing test program di erentintmain inta const int b if a intc a b c return a original pintmain c c if o c c o return c b skeleton pintmain inta int b if a intc a b c return c mutation m1intmain inta int b if b intc a b c return d mutation m2 figure example of witnessing mutation mutation rules are not equally e ective.
the mutation rules that more frequently generate diverse witness test programs should be selected with higher probability for further mutations.
based on this insight we propose our heuristic based test program generation in the following subsections.
in particular we use coverage distance to measure the diversity between test programs d c d .
the distance dist between two test programs p 1and p 2is the jaccard distance between their statement coverage where stmt p1and stmt p2represent the set of covered statements by p 1and p 2respectively dist p1 p2 stmt p1 stmt p2 stmt p1 stmt p2 during the process of constructing a set of e ective witness test programs diwi rst selects a seed test program to mutate described in section .
.
and then selects a mutation rule to apply described in section .
.
in each iteration.
.
.
seed program selection.
the initial seed test program is the given failing test program.
all witness test programs are derived from this initial seed test program by conducting rst order or high order mutations on it.
actually nth order mutations can be regarded as conducting rst order mutations on the programs generated by n th order mutations on the initial seed test program.
that is diwi also treats the generated test programs via mutation as seed test programs for following iterations.
here we can call the initial seed test program the 0th order mutation.
to reduce the risk of introducing failing test programs that are due to other bugs diwi rst selects n th order n failing test programs as seed test programs.
if it cannot construct any witness test program under the given terminating condition diwi then selects nth order n failing test programs.
the reason is that higher order failing test programs are more likely to incur other bugs.
moreover lower order failing test programs help control the trace similarity between the newly generated witness test program and the given failing test program.
please note that diwi rejects any newly generated witness test program without increasing diversity.
.
.
mutation rule selection.
based on a selected seed program diwi selects a mutation rule to mutate it.
however these mutation rules are not equally e ective to generate diverse witness test programs for a given failing test program.
also the same mutation rule 227esec fse august tallinn estonia junjie chen jiaqi han peiyi sun lingming zhang dan hao and lu zhang performs di erently for di erent initial failing test programs.
therefore we carefully design an adaptive procedure to select mutation rules for constructing a set of e ective witness test programs.
intuitively if a mutation rule can more frequently generate witness test programs that have greater diversity with the existing ones the mutation rule should be selected with higher probability for further mutations.
based on the intuition we compute a priority score for each mutation rule mrasscore mr m m i 1dist p pi rate s where mis the number of existing witness test programs in the set pis the new witness test program generated by using mr dist is the coverage distance computed by formula rate sis the success rate of generating accepted witness test programs i.e.
the ratio of the number of times the witness test program generated by mris accepted into the witness set to the number of times mris selected for mutations.
mutation rules can be ranked according to the descending order of the computed priority scores.
however we cannot directly select the mutation rule ranked at the stposition for next mutation since the ranking is based on historical results of these mutation rules and can hardly perfectly predict future results.
therefore each mutation rule should have some probability to be selected for next mutation and a mutation rule ranked higher in the ranking list should have a larger probability to be selected.
that is the problem of mutation rule selection in diwi can be regarded as the sampling problem from a probability distribution .
here since which mutation rule to be selected depends on the most recent behavior of each mutation rule it is actually a typical markov chain mc .
therefore to solve the sampling problem from a probability distribution diwi adopts the metropolis hastings mh algorithm the most popular markov chain monte carlo method as heuristic by assuming the desired distribution to be equilibrium distribution .
here mh obtains random samples from a probability distribution.
in our context it samples the next mutation rule denoted as mrb based on the current mutation rule denoted as mra according to a probability distribution.
if mrb is better than mra i.e.
the priority score of mrbis larger than that of mra mrbis de nitely accepted if not mrbstill has some probability to be accepted.
following the existing work we set the probability distribution to be the geometric distribution which is the probability distribution of the number xof bernoulli trials needed to obtain one success.
if the success probability on each trial is p the probability the kthtrial being the rst success can be computed as ps x k p k 1p.
during the process mutation rules are selected randomly and thus the proposal distribution is symmetric.
therefore the probability of accepting mrbgiven mrais computed as pa mrb mra ps mr b ps mr a p kb ka where kaandkbare the positions of mra andmrbin the ranking list of mutation rules according to the descending order of their priority scores.
please note that when mrb is better than mra i.e.
ps mrb ps mra pa mrb mra .
after acquiring the result of mrb i.e.
accept or reject diwi updates its score and re ranks these mutation rules for next iteration.
.
.
overall algorithm.
we formally present the generation process of diwi in algorithm .
the initial set of seed programs contains only the given failing test program pf and the priority score of each mutation rule is .
in this algorithm line randomly selectsalgorithm heuristic based test program generation input s seed test program set pf mr a list of mutation rules output p a set of witness test programs 1mra mri random ... 2s0 3while not termination do p select s select a program from s ka position mra getmra s position in mr do mrb mri random ... kb position mrb f random while f p kb ka p0 mutate p mrb ifp0is passing 8pi2p d p0 pi 0then p p p0 end ifp0is failing then s0 s0 p0 end updatescore mrb p0 p mr sort mr mra mrb 21end 22ifsize p 0then return p 24end 25else s s0 repeat from line 28end a mutation rule as the current one mra.
lines construct a set of witness test programs until achieving a terminating condition.
line selects a seed program pto mutate.
line gets the position of mra in the ranking list of mutation rules.
lines acquire the next mutation rule mrb.
line applies mrbto mutate pto generate a new program p0.
lines determine whether p0is accepted bypands0based on its execution results and coverage distances with the existing witness programs in p. lines update the score of mrband re rank these mutation rules for next iteration.
ifp0is accepted into p the score is updated by changing the two items in the formula score otherwise the score is updated by just changing the latter item in the formula score since the witness set and the coverage distances are not changed.
lines determine whether terminating the construction process.
if there is no witness program constructed via lower order mutation the construction process lines is repeated by using higher order mutation i.e.
using higher order failing programs as seed programs .
.
aggregation based compiler bug isolation after constructing a set of witness test programs diwi isolates compiler bugs by analyzing the set of witness test programs and the given failing test program.
following sbfl diwi computes the suspicious value for each statement within the touched code when compiling the given failing test program.
here diwi adopts ochiai one of the most e ective formulae in sbfl to compute the suspicious value for each touched statement.
the formula issus s efsp efs nfs efs eps where efsandnfsrepresent the number of failing test programs that execute and do not execute statement s and epsrepresent the number of passing test programs executing s. here we have only one given failing test program and just consider the statements touched by the failing test program and thus efsis and nfsis .
therefore sus s 1p1 epsin diwi.
228compiler bug isolation via e ective witness test program generation esec fse august tallinn estonia then similar to method level aggregation diwi computes the suspicious value of each le by aggregating the suspicious values of all the touched statements in the le.
when a failing test program is mutated to a set of witness test programs the coverage for the buggy le would be changed more than that for the bug free les on the whole.
therefore to compute the suspicious value of each le we use the formula sus f nf i 1sus si nf where nfis the number of touched statements when compiling the failing test program in the le f. evaluation in this study we address the following research questions rq1 how does diwi perform on compiler bug isolation?
rq2 do our search based witness test programs outperform the developer provided test suite and the randomly generated passing test programs?
rq3 does our heuristic based search strategy outperform the random search strategy during mutation?
rq4 can diwi take advantage of the developer provided test suite which is an exploration to further boost diwi ?
.
benchmark we used gcc and llvm as subjects which cover almost all popular c compilers used in the existing work .
to investigate the e ectiveness of diwi from the bug repositories of gcc and llvm we manually collected bugs in total each of which is required to satisfy the following conditions the bug has the equipped failing test program and the compilation options triggering it in the bug report the bug has been xed the bug can be reproduced in our experimental environment.
we manually collected bugs reported after following these conditions until we had bugs for each compiler since the manual process is costly.
also we manually identi ed the buggy locations i.e.
buggy les for each bug which serve as the ground truth to evaluate the e ectiveness of bug isolation in our study.
on average a gcc buggy version has les with 414k source lines of code sloc while a llvm buggy version has les with 431k sloc1.
we release the benchmark to facilitate the future research on compiler bug detection isolation and xing and welcome more researchers to contribute to this benchmark.
in our benchmark each bug has buggy compiler version failing test program compilation options for reproducing the bug buggy location xed version .
our benchmark and code are available at the project webpage .
.
implementation and con guration diwi utilizes clang libtooling library to parse a test program to an abstract syntax tree ast and then mutates it at the ast.
diwi utilizes gcov to collect compiler test coverage.
here we set the success probability of each bernoulli trial pin algorithm to be .
by satisfying the following conditions .
132 k p x k p p 1p where is a quite small deviation e.g.
.
.
we set the terminating condition of diwi to be one hour limit in our study.
for any technique involving 1since gcc and llvm are implemented using c and c respectively we consider all the c les for the former and c les for the latter.randomness we repeated it times and use the median results.
our study is conducted on a workstation with four core cpu 120g memory and ubuntu .
operating system.
.
measurements to evaluate the e ectiveness of bug isolation we measure the position of each buggy le in the ranking list produced by a bug isolation technique.
if more than two les have the same suspiciousness we use the worst ranking following the existing work .
we compute the following widely used metrics top n refers to the number of successfully isolated bugs within the top n position i.e.
n2 in our study in the ranking list.
larger is better.
mean first rank mfr refers to the mean of the rst buggy le rank for each bug.
this metric emphasizes fast isolation of the rst buggy element to ease debugging.
smaller is better.
mean average rank mar refers to the mean of the average rank of all buggy les for each bug.
di erent from mfr mar emphasizes precise isolation for all buggy elements.
.
compared techniques spectrum based bug isolation sbfl is the most widely studied bug isolation technique among traditional bug isolation techniques.
it is interesting to evaluate the e ectiveness of traditional sbfl on compilers.
it rst records the coverage status of each program element i.e.
each compiler le in the study during each test execution and the test outcomes i.e.
passing or failing .
then sbfl computes a suspicious value for each program element using some formula and nally ranks the program elements based on their suspicious values.
researchers have made dedicated e orts to design various formulae on suspiciousness computation.
we evaluated eight popular formulae following the existing work including sbi ochiai tarantula jaccard ochiai2 kulczynski2 op and d2 and found they achieved extremely similar results for compiler bug isolation in our study.
due to space limitation we use the most e ective ochiai as the representative.
for each compiler bug we use the given failing test program as the failing test program and use the developer provided test suite as the passing test programs.
as the core of diwi is to generate e ective witness test programs it is interesting to investigate the impact of generated witness test programs on bug isolation .
to achieve this goal we replace the set of our search based witness test programs with the developerprovided test suite and then use the aggregation based sbfl to isolate bugs.
we call this technique sbflde a. besides randomly generated test programs via test program generation tools like csmith have been demonstrated to be quite e ective for detecting compiler bugs .
therefore we also replace the set of our search based witness test programs with a set of randomly generated passing test programs via csmith and then use the aggregation based sbfl to isolate bugs.
similarly we call this technique sbflranda .
besides to investigate the impact of our heuristic based search strategy on bug isolation we replace this strategy with the random search strategy.
that is we do not have any guidance for constructing witness test programs via mutation.
we call this variant of diwi diwirand random search .
note that we used the same terminating condition for all compared techniques for fair comparison.
229esec fse august tallinn estonia junjie chen jiaqi han peiyi sun lingming zhang dan hao and lu zhang .
threats to validity first the ndings in this work may not generalize to other compiler bugs.
to reduce this threat we tried our best to construct a new dataset including real world compiler bugs.
note that the process was extremely time consuming and tedious to our knowledge this is the largest dataset for reproducible compiler bugs.
second besides the used two kinds of passing test programs there are other kinds of test programs e.g.
programs generated via swarm testing .
in the future we will use more kinds of passing programs for comparison.
third the settings e.g.
parameters in our searchbased strategy and terminating condition of diwi may impact our study.
in the future we will explore their impacts.
.
results and analysis .
.
overall e ectiveness of diwi.
rows diwi in table 2present the e ectiveness of diwi.
overall diwi successfully isolates bugs out of bugs within top buggy les demonstrating its e ectiveness on compiler bug isolation.
that is about .
and .
bugs are e ectively isolated within and compiler les respectively.
we further analyzed the e ectiveness of diwi for di erent compiler systems.
intuitively llvm has a much larger number of les shown in section .
and should be harder to perform bug isolation.
however interestingly shown in table diwi achieves quite similar e ectiveness on gcc and llvm and diwi even isolates more bugs within top on llvm than gcc.
moreover we nd that other studied techniques indeed perform worse on llvm than gcc.
therefore that demonstrates the scalability of diwi diwi s e ectiveness does not decrease dramatically when facing larger compiler systems.
we also analyzed the comparison e ectiveness between diwi and traditional sbfl shown in rows sbfl in table .
we nd that traditional sbfl performs poorly on the studied compilers.
for example sbfl ranks the gcc buggy les as the .
thposition while ranking the llvm buggy les as the .
thposition on average.
to our knowledge this is the rst study demonstrating that the intensively studied sbfl cannot scale to real world compiler systems.
on the contrary although equally simple and lightweight our diwi is able to signi cantly outperform sbfl.
on average diwi localizes compiler buggy les within .
mfr and .
mar outperforming sbfl by .
mfr and .
mar .
qualitative analysis.
we further conducted qualitative analysis using two examples.
figure 5shows an example llvm bug where the left is the failing test program and the right is one of witness test programs generated by diwi.
the test program in figure 5a is miscompiled by the llvm trunk revision at o1and above.
the bug occurs at the le scalarevolution.cpp which incorrectly promotes the bit addinto a bit add.
after just one mutation shown in figure 5b the mutated program does not trigger the bug demonstrating the power of our designed mutation rules.
we computed the coverage distance between the two programs and its value is only .
which con rms our assumption that minor changes are likely to make them share close compiler execution traces.
in particular diwi ranks the buggy le at the 6thof all les.
figure 6shows an example for a gcc bug.
the failing test program in figure 6ais miscompiled by the gcc trunk revision at osand above.
the bug occurs at the le tree ssa sink.c because it does not well handle the case where a second eliminatedunsigned short a intb intc intmain for c c c for b a break if b builtin abort return a failing test programunsigned short a intb intc intmain for c c c for b a break if b builtin abort return b passing mutation figure llvm bug intprintf const char ... inta b c d short e void fn1 intp b a intmain a if c e d e long long f e fn1 f printf d n b return a failing test programintprintf const char ... inta b c d volatile short e void fn1 intp b a intmain a if c e d e long long f e fn1 f printf d n b return b passing mutation figure gcc bug extension requires widening a copy created for elimination of a prior extension.
after adding volatile as shown in figure 6b the mutated program does not trigger the bug anymore.
we computed their coverage distance and its value is .
which is also very small.
in particular diwi ranks the buggy le at the 1stof all les.
furthermore diwi also brings extra bene ts.
that is these generated witness test programs via mutation provide some useful hints for the developers to facilitate bug diagnosis xing.
for example from figure the bug is not triggered again by replacing with which means that or has an impact on the bug.
that is true because incorrect promotion from bit addto bit addleads to incorrect widening from to .
.
.
diwi v.s.
sbflde av.s.
sbflranda.we compared diwi with sbflde aand sbflranda toinvestigate the impact of our searchbased witness test programs .
from rows diwi sbflde a and sbflranda in table diwi outperforms them in terms of all the used metrics.
for example diwi isolates .
.
.
.
more bugs than sbflde aand .
.
.
.
more bugs than sbflranda within top for all the studied bugs.
that demonstrates that diwi achieves much more precise isolation results than sbflde aand sbflranda.
in particular we conducted the wilcoxon signed rank test for their isolation ranks at the signi cance level of .
to determine whether there are signi cant di erences between them on all the studied bugs.
the p value is .
and .
respectively demonstrating that diwi does signi cantly outperform them.
these results indicate that our search based witness test programs are more powerful than both the developer provided and randomly generated via csmith witness test programs on isolating compiler bugs.
230compiler bug isolation via e ective witness test program generation esec fse august tallinn estonia table compiler bug isolation e ectiveness comparison subject technique top top top top top top top top mfr mfr mar mar gccdiwi .
.
sbfl .
.
.
.
sbflde a .
.
.
.
.
.
.
.
sbflranda .
.
.
.
.
.
.
.
diwirand3 .
.
.
.
.
.
.
.
llvmdiwi .
.
sbfl .
.
.
.
.
.
.
.
sbflde a .
.
.
.
.
.
.
.
sbflranda .
.
.
.
.
.
.
diwirand3 .
.
.
.
.
.
.
.
alldiwi .
.
sbfl .
.
.
.
.
.
.
.
sbflde a .
.
.
.
.
.
.
.
sbflranda .
.
.
.
.
.
.
.
diwirand6 .
.
.
.
.
.
.
.
columns present the improvement rates of diwi over a compared technique in terms of various measurements.
.
.
.
.
diwidevrandcoverage distance a gcc .
.
.
.
.
.
diwidevrandcoverage distance b llvm figure coverage distance between generated witness test programs and the given failing test program to further investigate why our search based witness test programs can signi cantly outperform the others we further quantitatively evaluated one basic assumption of diwi i.e.
minor mutation changes are likely to make them share close compiler traces.
we computed the mean coverage distance between the given failing test program and all witness test programs for each bug.
figure 7shows the coverage distance comparison among diwi our search based witness program generation sbflde a the developer provided test suite denoted as dev in this gure and sbflranda the csmith random program generation denoted as rand .
in this gure the violin plots show the density of coverage distances at di erent values and the box plots show the median and interquartile ranges.
from this gure we nd that our search based witness programs have much smaller coverage distances with the given failing test program than the developer provided witness programs and the randomly generated witness programs via csmith.
that validates our assumption.
interestingly in gcc there are some cases where the coverage distances are obviously larger than other cases.
we looked into the code and found that all these bugs are crash bugs and various code regions not executed by the failing test program due to crashes can be executed by the witness test programs.
.
.
diwi vs. diwirand.we also compared diwi and diwirand toinvestigate the impact of our heuristic based search strategy shown in rows diwirand in table .
from this table diwi outperforms diwirandfor both gcc and llvm in terms of all the used metrics.diwi isolates .
.
.
.
more bugs within top1 than diwirandfor all the studied bugs.
diwi performs .
and .
better than diwirandin terms of mfr and mar.
that demonstrates that diwi performs more precise than diwirand for isolating both gcc and llvm bugs.
we also conducted the wilcoxon signed rank test for the isolation ranks of diwi and diwirand.
the p value is .345e demonstrating the superiority of diwi over diwirand.
the results indicate that our heuristicbased search strategy outperforms random search.
to investigate why the heuristic based search strategy outperforms the random search strategy we quantitatively evaluated another basic assumption of diwi i.e.
witness test programs generated via our heuristic based search strategy should have great diversity.
we computed the coverage diversity among witness test programs.
here we rst computed the minimum distance for each witness test program with others and then computed the mean of all minimum distances for all witness test programs.
we nd that the mean coverage diversity of our heuristic based strategy is about .72x and .10x greater than that of the random search strategy for gcc and llvm respectively.
that is diwi indeed has greater diversity than diwirand validating our assumption.
.
.
exploring diwi with developer tests.
our search based witness test programs have been demonstrated to outperform the other two.
we further analyzed the cases where each type of witness programs performs well.
here we chose the bugs isolated within top to analyze.
we found although diwi isolates bugs within top sbflde aand sbflranda can also isolate additional bugs in total within top .
that is the developer provided programs and randomly generated programs via csmith can complement our search based witness programs to some degree.
if we can e ectively synthesize them the compiler bug isolation e ectiveness may be improved.
we analyzed why randomly generated programs can isolate additional bugs and found the reason to be that the tool csmith cannot cover all c language features causing some les always uncovered.
when the bug occurs at these les due to such an occasional factor the les are easy to isolate using csmith generated passing programs.
getting rid of this occasional factor we made the rst attempt in the direction by synthesizing our search based witness programs and the developer provided witness programs.
231esec fse august tallinn estonia junjie chen jiaqi han peiyi sun lingming zhang dan hao and lu zhang a add a intadd inta intb ... randomly selectcandidatepooldependent materialsblendintadd inta intb ... ...intnum a add a ......intnum ...diwigenerated program intadd inta intb ... ...intnum num add num ...renamea blended program figure test program synthesis for each search based witness test program by diwi the synthesis technique produces a blended witness program automatically as follows it treats all basic blocks statements in all developerprovided programs as a candidate pool it randomly selects a candidate block statement from the pool and collects its all dependent materials e.g.
method declaration and header le it randomly inserts the candidate block statement and its dependent materials to the search based witness program and conducts refactoring for new variables in the block statement to make the blended program valid i.e.
renaming them to the variables occurred in the original program with compatible types.
figure 8shows the process of generating a blended program.
we used clang libtooling library to conduct such synthesis at the ast and the whole process is fully automated.
we repeated the above steps for each search based witness program until a blended witness program is produced.
in this way we get a set of blended witness programs.
we then used the aggregation mechanism to isolate compiler bugs based on the given failing program and the blended witness programs.
we evaluated whether the synthesis can further improve diwi.
from the results among compiler bugs the synthesis improves the isolation e ectiveness for bugs out of and reduce the e ectiveness for only bugs.
also such synthesis e ectively isolates .
and .
more bugs within top and top les than diwi respectively.
its improvement rates of mfr and mar are .
and .
respectively compared with diwi.
this is because the synthesis provides more possibilities for diwi to nd e ective witness test programs by augmenting the mutation space demonstrating a promising future to further explore e ective ways for blending test programs from di erent sources.
discussion what developers want.
to investigate the practicability of diwi we conducted a survey by communicating with compiler developers sending out requests in total from international companies building their own compilers including the llvm team .
developers con rmed that their compiler bug debugging process starts from buggy les identi cation and this step is time consuming indicating the necessity of compiler bug isolation at the le level.
moreover developers think the e ectiveness of diwi shown in our study is practical and show strong desire for diwi by using the words can t wait to see during the communications.
even the developer who does not rst identify buggy les when debugging also expresses his her willing to improve the debugging process by using diwi.
in the future we will improve diwi at ner granularity such as the method level.intprintf const char ... inta intb intc intmain for c c if a a b printf d n b return a failingintprintf const char ... inta intb intc intmain for c c if a a b printf d n c return b fake pass 1intprintf const char ... inta intb intc intmain for c c if a a b printf d n b return c fake pass figure example of test oracle challenge gcc bug test oracle challenge.
we present the used test oracles to determine whether a mutated program is passing in section .
.
however such oracles are not absolutely precise especially for wrong code bugs.
diwi treats the mutated program producing consistent results as a passing program but it may still trigger the bug.
for example figure 9ashows a failing program where the outputs of b under o0and o1are di erent.
the other two gures are two mutated passing programs under the used oracle.
however both of them arefake passing programs.
in figure 9b the variable binprintf statement is mutated to be c. it still triggers the bug but it is regarded as a passing program since cprints the same results under o0and o1.
in figure 9c the value of b i.e.
is mutated to be which is equal to the initial value of b. such mutations make the output always the same i.e.
causing the used oracle to miss the bug.
fake passing programs may impact the isolation e ectiveness.
however it is challenging to solve this oracle problem.
to reduce its impact diwi avoids the mutations that directly change the oracle i.e.
print statements but cannot deal well with other cases such as figure 9c.
in the future we will introduce advanced data and control ow analysis to address this challenge.
unde ned behavior challenge.
another challenge lies in unde ned behaviors for compilers which mean the semantics of certain operations are unde ned in the programming languages standards .
if a program contains unde ned behaviors compilers may produce varied results.
identifying unde ned behaviors is a di cult challenge in compiler research .
it is also a threat in our work since our mutation may introduce unde ned behaviors.
however unde ned behaviors tend to impact bug detection since di erent results of a failing program may be caused by real bugs or unde ned behaviors.
in diwi we only kept the passing programs with the same results to isolate bugs and thus the threat may be not serious.
we will relieve this problem by adopting existing light weight methods for identifying unde ned behaviors.
conclusion in this paper we propose a novel compiler bug isolation technique diwi which proposes a heuristic based search strategy to carefully generate a set of e ective witness programs by performing our designed witnessing mutation rules on the given failing program.
the results on real bugs for gcc and llvm show diwi isolates .
of the studied bugs within compiler les signi cantly outperforming state of the art sbfl.
diwi is general and not limited to compilers we plan to apply it to other systems taking structurally complex test inputs e.g.
operating systems and browsers.
232compiler bug isolation via e ective witness test program generation esec fse august tallinn estonia