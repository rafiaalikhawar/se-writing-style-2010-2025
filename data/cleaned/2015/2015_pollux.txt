pollux safely upgrading dependent application libraries sukrit kalra iiit delhi indiaayush goel iiit delhi indiadhriti khanna iiit delhi india mohan dhawan ibm research indiasubodh sharma iit delhi indiarahul purandare iiit delhi india abstract software evolution in third party libraries across version upgrades can result in addition of new functionalities or change in existing apis.
as a result there is a real danger of impairment of backward compatibility.
application developers therefore must keep constant vigil over library enhancements to ensure application consistency i.e.
application retains its semantic behavior across library upgrades.
in this paper we present the design and implementation of p ollux a framework to detect applicationaffecting changes across two versions of the same dependent nonadversarial library binary and provide feedback on whether the application developer should link to the newer version or not.
pollux leverages relevant application test cases to drive execution through both versions of the concerned library binary records all concrete effects on the environment and compares them to determine semantic similarity across the same api invocation for the two library versions.
our evaluation with 16popular opensource library binaries shows that p ollux is accurate with no false positives and works across compiler optimizations.
ccs concepts software and its engineering software maintenance tools software testing and debugging dynamic analysis software evolution software libraries and repositories keywords software maintenance library upgrade dynamic binary analysis.
.
introduction in current times library driven software development is a reality and use of third party libraries is central to the development of a large number of applications.
however this software reuse comes at a cost the included libraries can severely impact the maintainability of software systems.
evolution of third party libraries may not always ensure backward compatibility and may introduce new functionalities altering existing apis across both authors contributed equally.
static void dump double value string out char buf snprintf buf sizeof buf .17g value out buf if std isfinite value char buf snprintf buf sizeof buf .17g value out buf else out null figure dropbox s minor fix could break applications.
major upgrades.
thus developers must keep constant vigil over library enhancements to ensure application consistency i.e.
the application retains its semantic behavior across library upgrades.
a seven year study of library release history in maven central involving 150k binary jar files revealed that one third of all releases introduced at least one change that broke backward compatibility.
this figure remained unaffected whether the library release was a major or a minor upgrade.
thus choosing to update the library dependencies of an application is a double edged sword and demands thorough assessment of the effort needed to update the dependencies and the potential benefits achieved by updating.
for example according to the json standard the values nan andinfinity should be serialized to null .
however dropbox s json11library which provides json parsing and serialization usedsnprintf in itsdump function to emit a string that was not compliant with the json standard.
thus a minor fix as shown in fig.
emitted significantly different json output for several applications potentially breaking some functionality.
this paper tackles the problem of whether a developer can safely upgrade a dependent library without affecting application functionality.
prior work has acknowledged the importance of dependencies in software management and has empirically studied the effects of update lag freshness quality and popularity on dependency management.
teyton et al.
study library upgrades for j ava software but focus entirely on reasons and frequency of upgrades.
however none of the prior work focuses on the application developer s dilemma of whether library upgrades would break critical application functionalities.
also most prior work rely on the analysis of source code which may not even be available for several third party libraries.
in this work we present p ollux a framework that detects application affecting changes across two versions of the same library binary and provides feedback on whether the application developer should link to the newer version.
p ollux builds upon the observation that any critical functionality affecting api change in the newer version would manifest as a new or distinct concrete effect such as memory writes and system calls.
in absence of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
290any such differences the api invocation in the newer version is semantically similar to the older version.
in other words if the test cases elicit the same concrete effects upon invocation of the apis across both versions the execution is functionally similar thus migrating to the newer version will not impact the application.
pollux leverages relevant application test cases or the exhaustive library test suite if it is open source to drive execution through both versions of the concerned library binary and records all concrete effects on the environment.
p ollux then uses a custom algorithm to compare these effects and determines the behavioral similarity across the same api invocation for the two library versions.
in case of any dissimilarity p ollux lists the offending api call in the newer version .
while p ollux is generic and applicable to all binaries it is specific to libraries in the way that it assumes consistency of api interfaces across releases.
pollux is not a binary differencing tool its goal is to detect semantic incompatibilities resulting from library upgrades.
note that p ollux s effectiveness is contingent upon the exhaustiveness of the test suite that drives it.
test suite expansion will monotonically increase the differentials discovered by p ollux .
further any code path either added removed or modified if not traversed by the test suite will result in p ollux missing the changes.
in general determining behavioral differences across binaries is challenging for two major reasons.
first binaries might be obfuscated or compiled with separate optimization levels say o0 and o3 resulting in different binaries.
thus graph isomorphism based techniques relying solely upon structural similarities in control flow also fail in light of these optimizations.
second issue of scalability is ever present.
static and symbolic execution techniques perform precise semantic analysis but suffer from issues of scaling to large binaries.
pollux overcomes these challenges using a path sensitive dynamic binary analysis technique to identify behaviorally similar code segments in a library binary.
specifically p ollux generates a dynamic call graph for all library functions traversed during each library api invocation for both versions of the library.
it then populates each node in the call graph with metadata to reflect concrete effects of execution associated with that function call i.e.
writes to stack and heap and system calls observed during that specific function invocation.
p ollux aggregates these concrete effects into a function signature i.e.
a minimal set of concrete effects uniquely identifying the function invocation even across multiple executions for the same given inputs.
pollux leverages these function signatures to correlate similar functionality traversed during the api execution across the two library binaries.
any pair of non matching function nodes indicates changes in either structural i.e.
code refactoring and or semantic functionality across the two binaries.
p ollux collates all such functionality changes for the given application library and notifies the application developer what specific api functionality is affected by linking to the newer library binary.
we have implemented a prototype of p ollux for x86binaries using intel s pin dynamic binary instrumentation framework .
we have applied it to 16popular open source libraries and our evaluation shows that p ollux correctly identifies semantic differences with no false positives for libraries under consideration.
pollux s core signature extraction algorithm reports a precision of on call graphs generated for library apis corresponding to adjacent versions for all 16open source libraries.
this paper makes the following contributions we provide a practical design for p ollux along with its novel dynamic binary analysis framework which is robust accurate and precise.
int main int ptr ptr int malloc sizeof int ptr printf d ptr free ptr return figure example source code.
push rbp mov rsp rbp sub 0x10 rsp mov 0x4 edi callq malloc plt mov rax 0x8 rbp mov 0x8 rbp rax movl 0x19 rax mov 0x8 rbp rax mov rax eax mov eax esi mov 0x400709 edi mov 0x0 eax callq 4004e0 printf plt mov 0x8 rbp rax mov rax rdi callq 4004c0 free plt mov 0x0 eax leaveq retq nopw 0x0 rax rax a example compiled w gcc o0.
push rbx mov 0x4 edi callq malloc plt mov 0x19 edx mov rax rbx movl 0x19 rax mov 0x400719 esi mov 0x1 edi xor eax eax callq printf chk plt mov rbx rdi callq 4004e0 free plt xor eax eax pop rbx retq b example compiled w gcc o3.
figure example code depicting challenges in binary analysis.
we implement p ollux for x86binaries and evaluate it on16open source libraries to show its effectiveness in determining functional similarity across library versions.
.
motiv ation and overview in this section we motivate the need for p ollux .
first we discuss two concrete scenarios describing the possible incompatibilities arising due to library upgrades.
second we discuss the issues involving precise binary analysis that make the problem of detecting semantic differences challenging.
libxml crash libxml v .
.6encountered a segmentation fault with the upgraded zlib v .
.
.5because of a complete re write of the gz apis which read and write gzip files .
the fix to libxml is to check the version of zlib and to use the current code for zlib vernum less than0x1230 .
however since both libxml and zlib are widely deployed and numerous applications link to them dynamically older versions of libxml and also other applications without this fix will fail with newer versions of zlib.
winamp crash winamp v .666build3516 crashed due to a buggy component plugin in mp .dll .
the bug in the newer version of the plugin was an unintended consequence of fixing an older bug in the metadata editor.
the proposed solution involved roll back of the plugin to build .
the above examples highlight two issues commonly observed in software evolution.
first dependent api changes cascade all the way down to the application which might crash if the appropriate changes are not handled gracefully.
second feature enhancements in third party components specially libraries and plugins can easily introduce bugs leading to software crashes.
while newer technologies like docker do remedy problems introduced by dependencies they are aimed primarily for software distribution alone.
the core dependency issues as discussed above still remain unsolved in the context of system software thereby motivating the need for p ollux which provides feedback 291to the developer on whether a dependency upgrade would affect or preserve the application s semantic behavior.
key challenges .precise analysis of generic software binaries poses several major challenges .
binary formats do not strictly differentiate between code and data making their analysis difficult.
moreover function boundaries are not well marked because return instructions are not mandatory.
binaries lack rich data types available in the source and may also lack symbolic information in release versions.
symbols and types can otherwise be used to improve precision of the analysis.
modern microprocessor instruction sets are large and complex and many instructions have subtle differences which if ignored can make an analysis unsound.
in addition presence of indirect jumps that calculate targets on the fly and overlapping instructions that get resolved at runtime can make the analysis incredibly hard.
the basic purpose of call andret instructions is to execute a function call and a return respectively.
however their usage to perform indirect jumps is abusive and can confuse the analysis.
lastly some machine architectures allow self modifying assembly code that can overwrite earlier code at the same address.
thus the actual instructions executed may not be even present in the static disassembly of the binary.
overview .consider the example code shown in fig.
2where memory is allocated for an integer updated to the value and finally deallocated.
the compiled output under optimizations o0 and o3 are shown in fig.
3aand 3b respectively.
despite significant syntactic differences among the two versions writes to memory such as movl 0x19 rax and system calls malloc printf andfree are preserved along execution paths.
p ollux computes the signature of each function invocation in an execution of the program by capturing the set of memory writes and system calls performed by the function.
the write set is a singleton set containing write of 25to an address stored in rax register.
the set does not change across compiler optimizations the optimizations can be thought of as idempotent operations with respect to the function signature set.
p ollux traverses through the call graph obtained from a program execution and performs the said activity repeatedly.
at the end of the analysis if no two function nodes are found to be behaviorally dissimilar p ollux declares the two versions to be behaviorally similar.
.
formal overview a software binary can be considered to be a finite set of ordered pairs of inputs and execution traces where trace is a sequence of events executed under the input formal definition of a trace is presented in the ensuing text .
let this set be denoted by b. for the purposes of this paper the regression test suite or applications invoking libraries under test lut define the domain of the input set denoted by i. thus for each input i i we denote a set of execution traces of the program to be bi an bracketle ti an bracketri ht b .
such a definition subsumes alterations to the program via semantically equivalent code refactorings compiler optimizations speculative out of order execution semantics of the hardware and in the case of concurrency runtime scheduling.
the set of all traces is denoted byt.
for each execution trace an output value is produced.
since iandtare finite sets and assuming programs to be deterministic the set of output values is also finite.
given two binaries b b of a software and a fixed regression suitei we wish to discover whether for each b an bracketle ti an bracketri ht b wherei i t there exists a b an bracketle ti an bracketri ht b where i i t such that bandb have the same output and samestate of system memory.
this is commonly referred as input output equivalence in the literature.
there are a few scenarios relating to the above discussion that are relevant to the context of our problem i.e.
differential analysis of libraries output of bandb is same for a given iand then clearly semantics have remain unchanged across the two versions output of bandb is same for a given i however ne ationslash then it mandates further analysis while it is possible that the output of two traces is equivalent the side effects of traces may differ leading to different states of the system memory altogether.
discovering precise side effects is a hard problem in the average case while undecidable in the worst case setting and output of bandb is not same for a given i in such a case the application developer must be notified that it may not be entirely safe to upgrade the lut.
.
concrete semantics we begin by defining a simple low level language that captures the essence of this work.
the language uses pcas the program counter note that we interpret pcto be pointing to the location of the instruction under execution a finite set of integer registers r r1 rn a store m that returns the contents at the memory location of the argument.
the set of expressions in the language is denoted by exp .
for simplicity we do not specify the expressions in this language although the expressions are allowed to contain pc r andm the set of program statements is denoted bystmt .
a statement s stmt can be one of the following a variable assignment ri ewithri r e exp a memory access m e2orr2 m e1 e2 exp a guarded jmp jmp e e2 wheree1 e2 exp which jumps thepcto the address evaluated from e2given the guard e1 evaluates to zero a procedure call p .
a statesof a program defined in the above language is given by a triple an bracketle tm l fr an bracketri htwherem an bracketle t an bracketri htcaptures the state of system s memory.
function r zprovides valuations to the registers n zprovides the contents of the memory addresses l nis the current address at which the control is and fr xi xmax is the sequence of addresses indicating the frame structure of the stack.
xmax is the maximum address to which stack can grow and xiis the least address on the stack stack grows downwards .
a state transitions to a new state upon the execution of a statement in the following manner t s s s t s s s t e2 s s s mapsto s t s braceleftbigg s if s ne ationslash s s otherwise we assume that s is a deterministic evaluation function of statement ein states.t s is essentially a state transformer function that produces a resultant state when statement eis executed from state s. the map mapsto updates adds specific entries within a state.
finally t s is modeled by register assignment statements modeling two important aspects of the function call stack frame allocation and deallocation.
the body of the procedure qis modeled by statements of the language.
at the time of allocation the stack is extended by the frame size of q .
thus for stack allocation 292t s s rfpis the register reserved for storing current frame pointer.
similarly after the execution of the body of the function the current stack frame at state swould be deallocated with fr xi c xi xmax t s s a trace of a program is a sequence of states s0 sn 1with s0as the start state.
we assume that there exists function that maps program behaviors to outputs o b z. we define the notion of behavioral equivalence of two traces by the following definition def.
.
.
two traces arestrictly similar when on input ithe state of memory is equal at their final states sn s n i.e.
sn m s n m ando b o b whereb an bracketle ti an bracketri htandb an bracketle ti an bracketri ht.
although observing the output of a trace is self evident observing the effects of a library code execution on system s memory is not straightforward.
for instance programs could legitimately be writing addresses of memory locations as values into registers or memory locations.
such memory address writes are bound to change even when the same program is executed multiple times.
on account of such complexity we define the notion of similarity of behaviors as opposed to strict equivalence as defined above .
the motivation behind similarity is to accommodate such address based writes to registers locations.
let w s s s t e2 s s be the multiset of values written into memory in the trace .
further letw qbe the projection of writes performed by the procedure qcalled in .
register writes are not taken into account since we assume that often local or temporary values are written to registers.
even if that were not the case scalability of p ollux s analysis demands that we drop tracking writes to registers per .
def.
.
.
two behaviors b b from binaries b b respectively on a given input iare similar when the following conditions hold o b o b and w w w w .
we denote similarity of behaviors by a relational operator ifb b are similar then b b .
for a given input i we abuse the notation and apply it for traces when behaviors are found to be similar.
note that def.
.2reduces to def.
.1when .
.pollux keyidea.pollux relies on a key observation that any critical or functionality affecting change in third party code is accompanied by corresponding side effects such as additional memory writes or system calls.
in other words key semantic behavior such as memory writes external to the stack frame and system call sequence remains unchanged despite compiler optimizations.
pollux takes as input the two library binaries and a test suite to drive execution of those binaries.
for every test case p ollux generates a call graph with additional metadata characterizing the signature for each function invocation.
next p ollux uses a custom algorithm that analyzes the two execution traces to identify semantically similar execution fragments.
execution segments that do not match are reported to the developer.
.
execution driver the execution driver executes the test suite for both versions of the binaries.
specifically it invokes the trace collector to start recording the effects of execution of each test case in the test suite.
once execution with the first binary is complete the execution driver i serializes the recordings to external storage ii dynamically links the test cases to second binary and executes them and iii signals the trace collector to start recording again.
.
trace collector out of the several possible function level features such as count of memory reads and writes system calls branching instructions and indirect jumps only critical functionality preserving memory writes and sequence of system call invocations remain unchanged in face of different compiler optimizations o0against o3 .
this unambiguity is because both these features abstract out all the syntactic sugar or operational mechanics and are tightly linked to the functionality or semantics itself.
hence p ollux uses these two features to determine semantic similarity.
the trace collector is responsible for detecting and recording these two effects upon each test case execution.
while it may be best to passively monitor these side effects it is not possible to do so for all effects like writes to the memory.
recording such effects would entail instrumenting the entire execution environment which would be prohibitively expensive.
thus p ollux leverages dynamic binary instrumentation for capturing effects of interest at a fine grained level.
this instrumentation preserves the intended execution effects of the binary while also executing the hooks to capture additional metadata.
while binary instrumentation frameworks provide both coarseand fine grained hooks p ollux instruments the given binary at a per instruction level granularity thereby sacrificing low execution overhead in favor of high accuracy.
for each instruction p ollux records the x 86instruction and the corresponding data address values.
thus the instrumented binary upon execution enables pollux to keep precise track of data addresses written to memory with distinction between stack and heap system calls invoked along with their arguments calls to other imported library functions via the procedure linkage table plt and function return values if available.
at the end of test suite execution the trace collector serializes the recorded values and trace analyzer is invoked which is described next.
.
trace analyzer the trace analyzer takes as input the serialized recordings for test suites corresponding to both library binaries and determines semantic similarity using a layered two phase analysis.
first pollux deserializes each trace and creates a call graph with each node decorated with function level metadata corresponding to memory writes and system call invocations.
p ollux then computes a precise signature for each function using metadata on memory writes and asynchronous system call invocations and matches these function call nodes across the two execution traces for structural similarities based on i caller callee relationship and ii potential code refactoring.
second if no dissimilar call nodes are observed then p ollux determines the execution sequences to be semantically similar iff the sequences of synchronous system call invocations observed across both the executions are same.
call graph construction .pollux determines call context per instruction and groups instructions with the same context to build nodes in the call graph.
thus while distinct invocations of the same function generate distinct nodes in the call graph a recursive invocation generates a single node in the graph.
293graph match a b matchset input a b call nodes in execution graph of current library.
matchset set of all matching node pairs.
output matchset set of all matching node pairs.
matchset matchset angbracketlefta b angbracketright a a b b b a ca c hildren a cb c hildren b foreach x ca y cb node match x y angbracketleftx y angbracketright negationslash matchset do matchset g raph match x y matchset end foreach x ca node match x b angbracketleftx b angbracketright negationslash matchset do matchset g raph match x b matchset end foreach y cb node match a y angbracketlefta y angbracketright negationslash matchset do matchset g raph match a y matchset end foreach x ca y cb angbracketleftx angbracketright negationslash matchset angbracketleft y angbracketright negationslash matchset do angbracketleftp q angbracketright find x y matchset g raph match p q matchset end find a b input a b call nodes in execution graph for current library.
output o set of matching node pairs from the two graphs initialize o .
ifnode match a b theno o angbracketlefta b angbracketright foreach x a children a y b children b do if angbracketleftx y angbracketright negationslash angbracketlefta b angbracketrighttheno o find x y end graph similarity r r matchset input r r root node in library l and l respectively.
matchset set of all matching node pairs.
output res boolean variable for match or no match initialize matchset res false .
foreach angbracketlefta b angbracketright find r r do matchset matchset graph match a b matchset end if matchset tv r r then res true algorithm match nodes with code refactoring.
.
.
function level similarity pollux constructs precise call graphs from deserialized recordings using a shadow execution context and updates it on every new call instruction encountered in the trace.
simultaneously it populates the nodes in the call graph with function level metadata such as writes to memory and asynchronous system call invocations.
p ollux considers an asynchronous system call equivalent to a memory write due to its non blocking nature.
additionally it maintains graph level metadata that includes the exact sequence of synchronous system calls.
the key observation here is that asynchronous system calls can be reordered with other operations but synchronous calls must occur in sequence.
thus semantic similarity must ensure that the sequence of synchronous system calls is preserved across both the executions.
any out of order synchronous system calls which are blocking in nature unlike an asynchronous call could potentially indicate a different behavior and hence is not semantically similar.
algorithm 1depicts the steps p ollux uses to determine function level similarity across two call graphs.
p ollux leverages node metadata to compute a signature for every function in the two call graphs.
it then uses the s rensen dice index sv and an empirically determined threshold to determine a partial match between two call nodes.
p ollux also considers code refactorings such as node splitting and inlining while evaluating a functionlevel match.
observe that s rensen dice index is essentially an instance of similarity as noted in def.
.
.
function signature .the signature of a function must i be unique and ii encapsulate semantic functionality.
it follows linearly from def.
.2that function signature of procedures must factor in the writes performed by it.
it may not always be possible to track writes writes performed by system calls hencewe conservatively treat asynchronous system call invocations as writes.
thus for procedure q its function signature is q w q an bracketle t hatwiderw q sq an bracketri ht where hatwiderw qis the multiset of all the memory writes of qthat are observable and sqis the multiset of system call invocations in q. the function signature for a specific call site however contains values which are execution dependent such as addresses generated due to dynamic memory allocation this introduces significant problem in deterministically assigning function signatures that do not fluctuate across repeated executions of the program.
this problem stems from the fact that at the instruction level p ollux cannot distinguish between concrete data values and memory addresses and accumulates both of them in the same write set.
keeping just the concrete data value and removing the addresses from the set of all memory writes would eliminate significant randomness in the function signature.
also note that a function must export values out of its scope to perform useful functionality which means the writes to function local variables result in no critical semantic behavior.
thus p ollux leverages process maps to determine address ranges for the current stack frame and discards all write values within this range.
subsequently function return values via the stack and registers refer are not included in the function signature.
prior work also notes that return values do not contribute significantly to the function signature.
signature match .a desirable signature matching scheme must ensure i few or no false negatives and ii low false positives.
however an exact signature match solely from can potentially result in high false positives in case of compiler optimizations since these transformations may change the set of concrete data values produced by the function.
thus p ollux leverages a similarity based match between the write sets generated by two functions aandb based on the s rensen dice index sv a b a b where set operators are applied separately to hatwiderw xandsq x a b. we consider similarity of functions only when the index is greater than a certain threshold r .
the caveat is that due to reliance on a threshold value it is possible that the value is not sufficiently high leading to false negatives i.e.
functions that should match but did not or sufficiently low leading to false positives i.e.
functions that should not match but did .
pollux uses function names if available to further improve the precision of the matching scheme.
we observe that in a nonstripped binary where the symbol names are present overloaded functions have different names.
furthermore in c a function name is a mangled version of its class hierarchy and its parameters which entails that every function name in the binary is unique.
thus in a non adversarial setting where symbols may be present pollux utilizes the function names in addition to s rensen dice index to match functions across binary executions.
finally it is common for library developers to refactor code i.e.
inline or outline functions or split a function into several smaller units.
prior art has used function names as a heuristic in specific cases and p ollux can leverage any of these more sophisticated techniques as its precision isn t contingent upon function names.
note that with such function splitting matching with function names is futile.
in addition the refactored functions make s rensen dice index ineffective since the index is based on function similarity rather than inclusion relationship.
in such cases using s rensen dice index may lead to several false negatives.
in order to make signature matching more meaningful in the context of inclusion relationship we introduce a new index tv a b min a b for functions aandb this index incidentally 294also captures the results with the same precision as the s rensendice index would have for cases where inclusion relationship was absent.
thus finally the node matching function is defined as node match a b braceleftbiggtrue tv true a b tv false otherwise where xreturns the name of the function x. whentv by a small margin i.e.
then function names are matched.
refactoring suggests that our matching mechanism should be capable of performing partial signature matches and also matches with the remainder of the signatures after a partial match is performed.
in order to deal with partial matching and to maximize structurally meaningful matching p ollux uses the notion of residual signatures .
specifically whenever p ollux matches the signatures of two functions it also updates their current signatures with residual signatures to be used for further matching as follows a a band b b a. inlining outlining library functions are often inlined to achieve better performance.
a function that is inlined adds its memory writes and asynchronous system calls data to its caller s signature i.e.
if function ahas its callee function binlined in a newer version it will result in the following signature of the new function a w a w b. similarly a function that is outlined as bin a newer version will have an opposite effect on the signature of the counterpart of b s caller function aas follows a w a w b. the inclusion index tvcaptures this inclusion relationship allowing nodes to be matched correctly.
splitting combining to achieve stronger cohesion and better maintainability developers split functions.
splitting functions have an impact on the signatures and matching which is similar to outlining.
more formally when a function fthat is split combined into from nfunctions f1 ... f n the following relation holds f w f1 ... w fn.
empirical threshold .pollux randomly selects test cases for apis that remain unmodified across the two neighboring versions of the library corroborated by the commits and determines tviteratively till the number of unmatched function nodes across the call graphs corresponding to the two library executions is less than .
in other words at least function nodes must match at this tv.
this final value of tvis the threshold .
the above iterative approach has the benefit that for most common cases reflects the lower bound of similarity between semantically similar functions.
any value of tv that causes the number of unmatched function nodes to increase above indicates with a high probability that the functionality has indeed changed.
.
.
graph level similarity in order to demonstrate similarity of two call graphs p ollux additionally handles the case when there are blocking system calls issued.
it uses function x an bracketle tsi ... s j an bracketri htandsi ... s jis the sequence of synchronous system calls observed in the execution.
.
diagnosis in case of dissimilar nodes p ollux traverses the function signature to determine the cause as either an extraneous data address value or system call or their order .
in each case the application developer receives a feedback indicating the offending api invocation along with the entire call sequence leading up to the function responsible for the unmatched data address value or system call that caused the dissimilarity.
comparison with prior art .pollux s signature for matching functions across two execution graphs is robust andeffective as will be shown later in .
unlike prior art pollux leverages a layered approach to determining semantic similarity and uses only the most critical side affecting features i.e.
memory writes and system calls which remain constant even across various compiler optimizations.
like blex pollux also leverages dynamic binary analysis but uses far fewer features to create succinct signatures.
additionally blex aims for instruction coverage and generates random inputs for differential analysis that is not path directed thereby exploring infeasible paths and leading to several false positives.
unlike bindiff and which use graph isomorphism techniques p ollux does not rely upon structural similarity and function names alone.
thus pollux s signature built using dynamic mechanism is robust even under various compiler optimizations.
unlike where a function signature includes allvalues read or written and are humongous p ollux uses only concrete data values and system call sequence to generate crisp function signatures.
.
compiler optimizations compiler optimization levels such as o3 are extremely aggressive and typically generate an execution graph that is significantly different from the one generated at level o0.
in fact optimization o3 is akin to code refactoring at the assembly level.
however no amount of optimization should alter the functionality critical memory writes and sequence of system call invocations.
in the absence of any structural similarity p ollux discards the function level signature matching and instead compares the aggregate set of write and sequence of system call invocations.
pollux leverages the index tvfor comparison across optimization levels.
since level o3 discards several intermediate memory writes a bfor two binaries aandbcompiled for the same source code with levels o3 and o0 respectively.
in other words tv 1indicates semantic similarity between binaries aandb.
note that p ollux s target is primarily application developers who include benign third party libraries and typically developers do not change compiler optimizations frequently for productionlevel code.
thus matching semantic similarity across optimization levels is not the common case for p ollux .
.
implementation we implemented a prototype of p ollux based on the design described in .
while the trace analyzer and collector were automated and required lines of c to implement the execution driver was triggered manually.
we leveraged the intel pin dynamic binary instrumentation framework v .
because of its ease of use in instrumenting the library binaries and recording execution side effects.
we wrote a minimal pintool which is code that the pin framework injects dynamically at selected points during instruction sequence to extract relevant execution metadata and build a call graph for the given execution.
call graph construction .
in assembly function transitions i.e.
invocations and returns happen via the call jmp andret family of instructions.
p ollux maintains a shadow stack of call context by leveraging pin apis to extract the function name at each transition instruction.
however we observed that a few functions did not have an explicit retinstruction leading to anomalous call graphs.
p ollux overcomes this challenge by discarding the use of instruction level instrumentation and switching to instrumentation at the granularity of a t race1.
since a t race is part of exactly 1a t race is a straight line instruction sequence with exactly one entry point.
it usually ends with an unconditional branch such as a call return or unconditional jump.
however a t race may include multiple exit points 295one function invocation p ollux invokes pin apis at the start of each t race to determine the function name which helps to reliably maintain the shadow stack of call contexts.
note that pin cannot reliably instrument functions in the presence of tail calls or when return instructions cannot reliably be detected .
thus we did not use pin s function level instrumentation.
detecting writes to stack data values written to the stack mostly correspond to non critical function local operations.
hence it is important to discard them so that the function signature uniquely identifies only critical functionality.
thus p ollux determines the address range available to the current process for writing to the stack frame and removes from its write set any value written to an address within this range.
to do so p ollux determines the process id for the currently executing test case and reads the corresponding process maps from the proc file system to determine the permissible stack range.
pollux leverages several optimizations to speed up the overall analysis and improve precision.
trace level instrumentation instruction instrumentation incurs significant overheads due to dynamic code injection before every instruction for call graph construction and also induces anomalies in construction as discussed earlier.
p ollux s use of pin s t race level instrumentation not only improves accuracy but also reduces the number of instrumentation points which speeds up analysis by an order of magnitude.
pruning the call graph p ollux prunes the call graph for faster analysis.
specifically the call graph starts at the api entry point and continues till the execution hits any glibc method invocations like those corresponding to memory allocation and management system calls etc.
the key observation here is that glibc and other system libraries like ldlinux provide access to fairly low level functionalities to several system components which change much less frequently compared with application libraries.
furthermore a change in system libraries often necessitates upgrading the entire system and its dependencies.
not traversing the call graph before the api entry point and after the glibc function invocations significantly reduces the size of the call graph to be analyzed for semantic similarity.
improving signature precision as explained in .
.
pollux identifies function local writes to memory to remove noise from the function signature.
to further improve the signature pollux executes each test case twice linked to the same library binary and takes an intersection between the side effects observed across the two executions.
the intuition here is that functionality preserving side effects such as writes and system calls would remain unaffected and be present in the intersection.
.
ev aluation in .
we evaluate p ollux for accuracy of detecting semantically relevant changes across several macrobenchmarks consisting of user applications.
in .
we determine the precision of p ollux s signature matching algorithm.
in .
we determine the effectiveness of the various optimizations described earlier in .
in .
we check p ollux s robustness across compiler optimizations.
lastly in .
we present our experiences with pollux and demonstrate its utility in diverse conditions.
experimental setup .all experiments were performed atop a vm having 4vcpus at .50ghz provisioned with 8gb of ram and running 64bit ubuntu v .04with intel pin v .14installed.
as long as they are conditional.
if pin detected a branch to a location within a trace it will end the t race at that location and start a new t race .data set .we chose 16popular open source c c libraries from github repositories see table and randomly selected commit versions along with their test suites.
we then manually inspected source code and the release notes corresponding to these commit versions and corroborated each such change.
while pollux s analysis is entirely automatic this manual involvement to validate our results limits the number of libraries analyzed.
empirical determination of thresholds .
we empirically determined the thresholds and for each library as described earlier in .
.
we observed that at .
the fraction of unmatched nodes was across all libraries in our data set.
higher value of means a stricter check and would increase the fraction of unmatched nodes while a lower value of indicates a more relaxed check and would have fewer unmatched nodes.
note that for a different corpus of libraries might vary.
we further selected .
.
.
accuracy we determine p ollux s accuracy when one or more dependent libraries for a user application have changed.
we consider pollux s output as accurate if it correctly determines changes in library code based on unmatched function nodes in the call graphs and system call order which must be preserved for semantic similarity.
we capture ground truth for the concerned scenarios using commits from the open source corresponding repositories.
we observe that barring a few security updates where code may get removed as in the heartbleed bug most bug patches and feature enhancements either add new code or alter existing library code syntactically.
we leverage the library test suites since the existing application test suites may not cover the entire gamut of functionality and run the suite with the two different versions.
if the fraction of unmatched nodes is greater than at .
or there was a change in the system call order or count p ollux concludes a semantic change in the existing library version.
table 1reports our results.
we observe that p ollux manages to capture even subtle changes such as in json where a mere line change in the dump function see fig.
introduced significant changes across several other api executions leading to unmatched nodes across the test suite.
pollux correctly detects semantic changes in 28out of the 30scenarios tested.
p ollux reports false alarms for some capstone andvalijson test cases.
on manual inspection of the commit logs we observed that the capstone library did not have a test case that traversed the modified code.
since p ollux leverages dynamic analysis paths not traversed in the code are not validated for semantic changes.
hence p ollux reported no change in semantic similarity across the two capstone versions.
invalijson we observed that the modified api introduced no extra nodes.
furthermore the code introduced only a conditional statement which was not traversed by any of the test cases similar to thecapstone ppc scenario.
thus p ollux correctly reports semantic similarity in each of the 30cases thereby having a accuracy for libraries under consideration.
.
precision we determine the precision of p ollux s function signature matching algorithm under the setting where there are no semantic differences for a given library api across the two versions.
in such a scenario we define precision as n n wherenis the total number of nodes in the call graph and nis the unmatched nodes across the two versions of the library.
we select test cases for each library where the api does not change semantically across the two versions.
we corroborate this 296table p ollux accuracy across patches minor and major revision changes for various libraries at .
.
note that p ollux detects a semantic change if unmatched nodes are and system call order is not preserved.
indicates all apis in the test suite.
application library apiversion commit nodes system callsdetectionold new total unmatched preserved armexec capstone arm .
.
.
.
.
armexec capstone mips .
.
.
.
.
armexec capstone ppc .
.
.
.
.
armexec capstone x86 .
.
.
.
.
armexec capstone xcore .
.
.
.
.
visual studio catch .
.0build451.
.5latest .
gazebo devil .
.
1f0d1.
.
.
tensorflow eigen .
.
.
.
.
tensorflow eigen .
.
.
.
.
tensorflow eigen .
.
.
.
boost fit e3bf390 52b54cd .
boost fit 52b54cd 66976be .
sagemath gsl .
.
.
sagemath gsl .
.
.
nodejs http parser parse url ab0b16 7d75dd .
nodejs http parser execute ab0b16 7d75dd .
dropbox json11 dump 0e8c5b .
dropbox json11 parse 0e8c5b .
cmake libarchive .
.
.
.
.
alsaplayer libcurl .
.
.
.
.
alsaplayer libcurl .
.
.
.
.
deluge libtorrent .
.
.
aisoy onion response new c812b35 88a659 .
quinoa pegtl .
.
.
.
.
quinoa pegtl .
.
.
.
.
cbdm spdlog c7864ae e248895 .
puppet valijson b241b37 e9b5016 .
openssh zlib 2689b c58f7a .
openssh zlib .
.
.
.
.
openssh zlib .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1pollux precision theta libarchive libcurl libtorrent valijson zlib a variation in precision with .
.
.
.
.
.
capstonecatchdevileigenfitgslhttp parserjson11libarchivelibcurllibtorrentonionpegtlspdlogvalijsonzlib of total matchesfrequency b frequency of node matches at .
.
100000match time ms nodes in call graph .
linear fit c variation in graph comparison time.
figure variation in p ollux s precision and other properties.
table p ollux precision with 16libraries at .
.
libraryversion commit nodesprecisionold new total unmatched 1capstone b560c2c508c456076 .
2catch ae5ee2cf895e0d27753 .
3devil .
.
cdc31.
.
c806 .
4eigen a1430dd08e2e06 .
5fit 953b721 ec7a043 .
6gsl 5c14 002f .
7http parser bee48 4e382f72537 .
8json11 a6a66 e1d5b .
9libarchive .
.
.
.
19f215222 .
libcurl 3c2e e506 .
libtorrent .
.
.
.
.
onion d7eb5b7801bb9b4540 .
pegtl 02ba 9e3b .
spdlog c0c5c01a6a661e587 .
valijson 1ade1c5b241b37 .
zlib .
.
.
.
.
.
.
api similarity by inspecting commits to the library repository.
we run p ollux for these test cases and measure the number of nodes that match across the api call graphs for the two executions.
weobserve that on average p ollux reports a high precision .
across all test cases see table .
we also note that libtorrent reports a high number of unmatched nodes because the particular test case downloads a file and thus several operational parameters such as available network bandwidth and bytes downloaded change significantly across two execution traces thereby causing pollux to report the high number of unmatched nodes.
variation in precision with we select five libraries from our data set and plot the variation in p ollux s precision for different values of .
.
.
and1.
.
fig.
4aplots the results.
we observe that as increases precision decreases because in a stricter setting fewer function nodes match.
frequency of node matches we measure the frequency of matches for nodes whose function signature matched to determine the aggressiveness of p ollux s signature matching algorithm.
fig.4bplots the results for all libraries in our data set at .
.
the y axis in the graph starts at .
.
we observe that across all libraries p ollux correctly matches .
of nodes which 297table effect of pruning glibc nodes at .
.
libraryversion nodes w o opt.
nodes w opt.
savings old new total unmatched total unmatched 1gsl5c14002f25966 .
2json11a6a66e1d5bc7814 .
3oniond7eb5801bb725 .
4pegtl02ba9e3b53621 .
5zlib1.
.
.
.
.
.
.
table effect of re execution on signature size .
.
libraryversion avg.
signature size savings commit w o opt.
w opt.
capstone b560c2 .
.
.
eigen .
.
.
.
.
fit 9e132 .
.
.
onion 801bb .
.
.
libtorrent .
.
.
.
.
table effect of re execution on precision at .
.
libraryversion total unmatched nodes savings old new nodes w o opt.
w opt.
eigen a1430 08e2e2323 .
libarchive 19f215222 .
libtorrent .
.
.
.
.
onion d7eb5801bb4540 .
pegtl 02ba9e3b44078 .
indicates the effectiveness of the algorithm.
only catch eigen libarchive andzlib had minuscule number of nodes with multiple matches due to sparse or common function signatures.
variation in graph comparison time we determine variation in the match time with increase in nodes in the call graph.
fig.
4c plots the results for all libraries except gsl andlibarchive at .
.
we observe that in general as the nodes increase the match time increases exponentially.
however both gsl and libarchive show much higher matching times than normal which is possible since matching also depends on the structure of the graph.
code refactoring can also alter the graph structure.
.
effectiveness of optimizations pruningglibc nodes we selected five libraries and executed their entire test suites with and without this optimization enabled.
table 3lists the results.
we observe that pruning glibc nodes alone not only decreases the number of unmatched nodes but also significantly reduces the graph size by an average of across the five libraries under consideration.
library re execution we selected five libraries and executed their test suites twice with p ollux .
we then took the intersections of the signature values to determine the function fingerprints and subsequently the improvement in precision with and without this optimization enabled.
the rows in tables 4and5indicate that the intersection of function signatures from two executions provides significant savings and reduces function signature by an average of .
across the five libraries.
further this optimization decreased the unmatched nodes by across the libraries.
.
compiler optimizations we run p ollux against five library test suites dynamically linked with corresponding libraries compiled with o2 and o3 compiler optimizations and measure its effects on p ollux s precision.
table 6lists the results.
we observe that even across the two optimization levels p ollux retains reasonable precision for most libraries except zlib .
however it drops significantly from per .
observed when determining semantic similarity for binaries with the same optimization level.
note that o3 is an aggressive optimization level and includes function inlining unswitching loops among others.
thus .
whichtable effect of optimization on precision at .
.
libraryversion nodes unmatched precision commit o2 o3 nodes o2 http parser 5651a72455 .
json11 afcc87803 .
libcurl .
.
.
onion 51ceb .
zlib .
table tvacross o0and o3compiler optimizations library versionavg.
signature size signaturetv o0 o3 intersection capstone d17fc399613 .
eigen .
.
.
fit 9e132 .
http parser 5651a758369 .
json11 afcc8d78758 .
libtorrent 508cc .
onion 51ceb .
spdlog c6f8f .
valijson e9b50435678 .
zlib .
indicates an error margin of just in similarity is insufficient across optimization levels.
we therefore need to recalibrate for detecting semantic similarity across optimization levels.
we now briefly compare p ollux s effectiveness with bindiff and blex .
since bindiff is a proprietary tool and blex s source and binary are unavailable we use accuracy numbers available in .
since p ollux s signature matching is ineffective across huge structural changes it leverages mechanism as described in .5to detect semantic similarity across optimization levels.
table 7liststvobserved for 10libraries from our data set across o0and o3compiler optimization levels.
we observe that p ollux determines semantic similarity with .
accuracy on average across the 10libraries.
in contrast blex and bindiff report an accuracy of across the same optimization levels per thereby making p ollux s accuracy comparable to both blex and bindiff.
.
case studies json11 json11is an open source c library from dropbox.
commit0e8c5bafixes a bug where values like nanandinfinity were serialized to non compliant values by snprintf causing the deserializer to fail.
the fix involved adding a condition which would return null if the number failed the std isfinite check.
even this small fix resulted in an increase in the number of unmatched nodes especially in test cases concerning numbers.
a test case traversing the true branch of the conditional had 25of 286nodes or .
left unmatched in the call graph.
in contrast thefalse branch had 11of235nodes or .
left unmatched.
we observed that across the entire test suite nodes were generated of which were unmatched or .
.
also a change in the total number of nodes was observed only for test cases that executed the changed code path.
zlib zlib is a hugely popular library used by git rsync libpng etc.
commit c58f7abreplaced unsafe functions like strcpy with safer alternatives like snprintf .
such changes wherein a function has been replaced results in significantly different memory writes.
for example the return values of the two functions although unused are totally different.
strcpy returns the destination character array while snprintf returns the number of bytes written.
also unlike strcpy snprintf appends a null byte to the buffer.
p ollux detects this change and reports 93out of1648 nodes or .
as unmatched in the graph.
http parser http parser is a dependent library for nodejs.
commit4e382f9had only minor changes to the documentation 298and did not modify the source code.
p ollux generated a total of nodes for the entire test suite that match perfectly at .
thereby indicating semantic similarity.
commit7d75dd73introduced support for zone id in ipv 6scoped addresses in the http parse host api.
only one test case test parse url in the entire test suite invoked this api.
this test case generated a total of 99nodes of which 2were unmatched .
causing p ollux to flag the change.
for all other test cases a total of nodes were generated that matched perfectly at .
thereby pin pointing the modified api.
commit0097dechanged the way the tokens are parsed by the library shttp parser execute api.
across the test suite tests did not invoke this api and generated a total of nodes that matched completely.
further 6tests generated a total of nodes 10of which were unmatched .
causing p ollux to conclude that they did not traverse the affected code path.
lastly 2tests that traversed the changed code path generated nodes of which6300 were unmatched .
indicating changes to the api.
further decreasing to0.9caused all nodes to match.
capstone capstone is a disassembly framework popular in the reverse engineering community.
commit c508c4a0added support for the travis ci build system and did not affect the source code.
p ollux reported a near perfect match across the entire test suite.
of the nodes generated only 16were unmatched .
indicating a trivial change.
across a minor release upgrade from v .
.3to v3.
.
seven cases in the test suite had only .
unmatched nodes indicating insignificant changes to these modules.
the remaining 5test cases for the arm mips x 86and xcore modules generated nodes of which 385were unmatched .
.
all changes except those in the powerpc module were correctly detected by pollux .
upon further inspection we observed that additional error checking conditions were introduced.
however the test cases did not traverse this newly introduced code change and thus pollux reported a false positive for powerpc.
.
limitations and future work pollux cannot handle multi threaded interleaved executions.
this limitation stems from its design which requires deterministic comparison of side effects resulting from individual test case executions.
in contrast multi threaded executions introduce significant non determinism in the set of captured side effects.
since p ollux leverages test suites for its dynamic binary analysis it cannot detect changes in code paths not traversed by the test case.
for example p ollux cannot detect bug patches that comment out an entire code path such as the openssh bug where the vulnerable code in the client was completely disabled.
like prior work pollux cannot reliably detect semantic similarities where side effects involve random numbers time of day etc.
however in our observation most critical features in mature libraries do not involve significant randomness.
pollux does not include writes to registers or stack in its function signatures.
thus it may miss values passed via stack or when entire function computation leverages registers alone.
there can be several programmatic ways to encode the desired functionality.
for example a multiplication operation might be achieved using repeated additions or just bit shifts.
p ollux in its present form cannot detect such semantic similarity since it leverages side effects which could be significantly different for both mechanisms.
in future we plan to augment p ollux with symbolic execution capabilities to detect such semantic similarities.
pollux s function signature matching is o n2 and requires significant computation for comparing graphs with several hundred thousand nodes.
we plan to optimize it as part of future work.
.
related work general purpose platforms .bitblaze is a binary analysis platform that leverages static and dynamic analysis techniques dynamic symbolic execution and whole system emulation and binary instrumentation.
phoenix requires debugging information and thus unlike bitblaze is not a binaryonly analysis platform.
both bitblaze and phoenix can also be used to detect changes to binary dependencies.
however they employ heavy machinery to achieve the desired result.
in contrast p ollux uses light weight and robust dynamic binary analysis techniques.
static analysis .there exist several static binary analysis platforms such as bap codesurfer x and jakstab .
codesurfer x 86and jakstab first disassemble binary code reconstruct call and control flow graphs and then perform static analysis over the reconstructed control flow.
bap lifts the instructions to an intermediate language il and then performs analysis at the il level.
in contrast p ollux leverages dynamic binary analysis to develop an execution call graph and examines it to determine semantic dissimilarities.
dynamic analysis .pollux is most closely related to blex which observes the side effects of function execution under a controlled randomized environment.
two functions are deemed similar if their corresponding side effects are similar.
pollux also uses the notion of similarity in side effects but unlike blex does not require any controlled environment.
like blex p ollux is also robust to compiler optimizations but is significantly more light weight in its approach.
additionally pollux like zhang et al.
and nagarajan et al.
augments its call graph analysis with features such as intermediate values to fingerprint functions across binaries.
symbolic analysis .
several frameworks such as binhunt bouncer bitfuzz fuzzball and mcveto operate solely on binaries.
binhunt is similar to pollux in spirit and determines semantic differences in binary programs.
however unlike p ollux binhunt detects semantic similarity using control flow analysis using graph isomorphism technique symbolic execution and theorem proving mechanisms.
brumley et al.
use symbolic mechanisms to determine whether different implementations of the same specification are semantically similar or not.
graph isomorphism .unlike p ollux bindiff and binslayer use graph isomorphism techniques that performs extremely well in both correctness and speed if the two binaries are similar.
however graph isomorphism in general does not perform well when the change between two binaries is large.
.
conclusion we present the design and implementation of p ollux a framework that leverages relevant application test cases to drive execution through two versions of the concerned library binary records all concrete effects on the environment and compares them to determine semantic similarity for the same api invocation across the two library versions.
our evaluation of p ollux with16opensource libraries confirms its utility and also indicates both high accuracy and precision even in the face of compiler optimizations.
.