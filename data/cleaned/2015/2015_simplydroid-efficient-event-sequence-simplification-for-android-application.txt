simplydroid efficient event sequence simplification for android application bo jiang yuxuan wu teng li school of computer science and engineering beihang university beijing china jiangbo wu yuxuan liten g buaa.edu.cnw.k.
chan department of computer science city university of hong kong hong kong wkchan cityu.edu.h k abstract to ensure the quality of android applications many automatic test case generation techniques have been proposed.
among them the monkey fuzz testing tool and its variants are simple effective and widely applicable.
however one major drawback of those monkey tools is that they often generate many events in a failure inducing input trace which makes the followup debugging activities ha rd to apply.
it is de sirable to simplify or reduce the input event sequence while triggering the same failure.
in this paper we propose an efficient event trace representation and the simplydroid tool with th ree hierarchical delta debugging algorithms each operating on this trace representation to simplify crash traces.
we have evaluated si mplydroid on a suite of real life android applications with crash traces.
the empirical result shows that our new algorithms in simplydroid are both efficient and effective in reducing these event traces.
index terms test case reduction delta debugging event sequence reduction android i. introduction the mobile internet industry has witnessed an explosive growth in recent years.
both the number and the complexity of mobile applications have increased rapidly.
according to gartner the android os has taken .
of the smart phone market share in the rd quarter of .
in google play there are more than .
million android applications .
to increase the satisfaction of end users mobile application developers must improve the quality of their applications.
mobile testing is one important measure to achieve this goal.
different kinds of testing techniques have been proposed to test android applications including fuzz testing gui traversal based testing and search based testing .
fuzz testing is represented by the family of monkey tools which includes the built in monkey tool of android os and its improved versions by third party.
owing to their simplicity effectiveness and wide applicability the improved monkey tools are widely adopted by cloud based mobile testing platforms .
a major limitation of these fuzz testing techniques is that they often generate a large number of input events before triggering a failure which makes follow up debugging tasks hard to apply.
in such scenarios simplifying input event sequence that triggers the same failure is desirable.
delta debugging dd has been applied to perform such test input reductions on traditional applications web applications and compilers etc.
there are also research works on reducing input event sequences for android applications with the emphasis on handling execution non determinism based on the idea of dd .
nonetheless in general dd techniques are slow to generate the reduced input.
the problem with the dd strategy is that its partition strategy is unaware of the presence of interaction sessions of input events with end users which may lead to large number of unsuccessful trials i.e.
fail to trigger failure in the reduction process.
hierarchical delta debugging improves the efficiency of dd by revealing the hierarchical structures of test cases and applying dd according to such st ructures.
we observe that an android input event sequence can be structured hierarchically based on interaction sessions and sub session with users.
our insight into the events trace reduction problem is that a long input event sequence of ten contains sub sequences representing small interactive sessi ons with the end users.
these sessions of events forms a natural boundary for reduction as they can often be reduced together with high probability.
we further observe that the relationship of input events is reflected in the hierarchical relationship of their corresponding gui states.
thus we seek to find the hierarchical relationships between input events by building and analyzing the gui state hierarchy tree as trace representation.
based on the trace reprsentation we further propose an input event sequence simplification tool simplydroid which contains a family of three test case reduction algorithms based on the notion of hierarchical delta debug ging coined as hierarchical delta debugging hdd bala nced hierarchical delta debugging bhdd and local hi erarchical delta debugging lhdd each operating on the a bove trace representation.
the hdd algorithm is an adaption of the existing notion of hierarchical delta debugging to show the applicability of our trace representation.
both bh dd and lhdd are our new hdd algorithms that use the structural property of the trace representation to improve the reduction efficiency without significant loss of reduction effectiveness.
we have used input traces with crash occurrences from real life android applications with real and seeded faults to evaluate the simplydroid tool.
the experimental results show this research is supported in part by nsfc project no.
the research fund of the miit of china project no.
mj y the rgc grf of hksar project nos.
and and the research fund of the state key laboratory of virtual reality technology and systems.
correspondence author .
c ieeease urbana champaign il usa technical research297 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that all the three techniques have improved reduction efficiency over the classic dd technique without loss of effectiveness.
furthermore lhdd is signifi cantly more efficient than dd hdd and bhdd which makes it competitive to apply.
the contribution of this paper is three fold.
first it presents a novel gui state hierarchy tree representation to model an android input even t trace.
second it proposes the first family of efficient hdd algorithms for simplifying android input event traces.
third it reports the firs t comprehensive experiment on crash traces of real world andr oid applications that evaluates the effectiveness and efficiency of our family of hdd algorithms and trace representation.
the organization of the remaining sections is as follows.
in section ii we present a motivating example to illustrate our key ideas.
in section iii we present our tool simplydroid as well as the family of input sequence reduction algorithms.
section iv reports a comprehensive experimental study in which we have evaluated the effectiveness and e fficiency of our family of hdd algorithms operating on our trace re presentation followed by the related work in section v. finally we conclude our work in section vi.
ii.
m otivating example this section presents a motiv ating example of our work.
a. gui state hierarchy tree as trace representation to understand the hierarchical structure of gui input events we have to build a partial gui state hierarchy tree and map the input events to it.
here partial means the gui hierarchy tree only reflects those parts of the gui hierarchy related to the current input event seque nce for simplification.
fig.
shows the gui state hierarchy tree built fro m a real crash trace from the android application dalvikexplorer .
when building the gui state hierarchy tree we use the hierarchical relationship of gui states to identify the hierarchical relationship of their corresponding events.
in this state hierarchy tree each node with number i not only represents the event i in the crash trace but also represents the gui state before processing the event i. an edge in the gui state hierarchy tree represents the parent child hierarchical relationship between the two corresponding gui states.
if a new node n with a state different from any nodes on the path from the root node to its previous node then the node n is defined as a child node of its previous node otherwise the node n is defined as a new and right sibling node of the equivalent node having the same state as n. in fig.
within the state hierarchy tree we use the same color to represent equivalent states sibling and the last node without any index to stand for state crash .
with the gui hierarchy tree construction process new events will always grow at the rightmost sub tree.
thus the crash node i.e.
the last event of the event sequence is always the rightmost node at the bottom level of the rightmost sub tree of the whole tree.
furthermore the parent and the ancestors of the crash node are always the last nodes in their corresponding levels.
we have built an enhanced monkey tool to log the application gui states during testing.
the definition of gui state can have different granularities.
in the current version of simplydroid we use an activity id to represent a gui state which is a lightweight solution.
using a finer level of gui state e.g.
gui structure definition may lead to different reduction results whose tradeoff is interesting to explore in the future.
therefore our crash traces contain not only the sequence of input events but also the co rresponding gui states.
more specifically our crash trace of events is in the form e e2 ... en and it corresponds to the gui state trace s1 s2 ... s n sn crash state .
upon recei ving event ei the state si transits to si .
the gui state hierarchy tree is constructed as follows.
for each state si and event ei with the same number i a new node n is constructed.
then node n is compared with each node state m from root to its previous node si in turn.
if s i is equal to any node m node n is added as a sibling node of m. otherwise n is added as a child node of node si .
the tree construction algorithm will be presen ted in section iii.
fig.
gui state hierarchy tree of an exemplified trace b. the reduction process of classic dd the delta debugging dd algorithm makes no use of the hierarchical relationships of gui states .
it partitions an input event sequence into subseq uences with equal size and performs reduction with increasingly finer granularity.
for the exemplified crash trace of length in our experiment the dd algorithm used trial executions by spending minutes and seconds before getting the final reduced test input sequence .
we observed that many of these trial executions generated invalid tr aces which wasted efforts.
c. the reduction process of hdd fig.
intermediate reduction attempts of hdd the idea of hdd is to perform the reduction from a higher level to a lower level on a gui st ate hierarchy tree.
in this way the sub trees of a node can be reduced together leading to the simplydroid tool is open source at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
higher reduction efficiency.
within each level the reduction strategy of hdd is similar to dd.
fig.
shows the reduction attempts of hdd within level .
while processing level hdd equally partitions the node set shown in fig.
into two parts and .
it tries to remove one part or the other.
as a result the result for the first round of reduction is shown in fig.
a .
we can see that those nodes and their sub trees are all eliminated in one round.
then the node set becomes the input for the next iteration of reduction.
this node set is again partitioned into two parts and for reduction.
the result for the second round of reduction is shown in fig.
b .
the reduction at level stops because there is only one node numbered rema ined.
then the reduction at levels and continue iteratively.
finally hdd used trial executions by spending seconds to get the same reduction result as dd.
we can see from the reduction process that hdd is more efficient than dd.
d. the reduction process of bhdd bhdd is based on the insight that many gui state hierarchy trees in real world scenarios are imbalanced sub trees with more nodes tend to stay at one side.
these trees may make hdd to spend more execution trails on reducing small node sets.
bhdd takes the size of whole sub tree rooted at each node into consideration and thus has the potential to reduce more nodes in each round of execu tion trial than hdd.
as shown in fig.
we label the size of the sub tree for each node at level .
the partition strategy of bhdd tries to make the total number of nodes in each partition as clos e as possible.
thus the first round of partition for bhdd generates node sets and .
the former has a total of nodes and the latter has a total of nodes.
in this way for an imbalanced tree bhdd may reduce more events in each round.
for the example trace bhdd us ed seconds with trial executions to get the same reduction result as dd.
fig.
partition strategy of bhdd e. the reduction process of lhdd as discussed in section ii a the parent and the ancestors of the crash node are always the last nodes e.g.
node and in their corresponding levels.
we can see from the gui hierarchy tree of the example that these ancestor nodes of the crash node e.g.
node and are critical because at these nodes the application under test tr ansits to the next level of gui state closer to the crash node.
based on this observation the lhdd algorithm adopts a heuristic reducing the sequence of events as long as the transition from the last node of one level to the first node of its next level is preserved.
for the exemplified gui tree in fig.
we need only to check whether the transition is successful at blue level fig.
b and the transition is successful at orange level .
at the bottom level lhdd chec ks for crash occurrence.
in this way we effectively convert the reduction process from a global optimization problem into a partial local optimization problem.
by local we mean that the reduction process needs not check the sub tr ee of the last node and by partial we mean that the subtre e of nodes other than the last node should still be checked.
for example when reducing at level blue nodes lhdd does not include the subtree rooted at node for checking i.e.
lo cal but includes the subtrees rooted at and for check ing i.e.
partial local .
in our experience the subtree of the last node is often large in size.
in such scenarios intuitively lhdd saves a lot of time.
to further optimize the local reduction process lhdd adopts another heuristic before performing the dd reduction at each level.
since the reduced ev ent sequence at current level must include the last node it incrementally selects nodes events with number equal to power of from the last node to front for trial execution and stops when it finds the first sub sequence of events th at can still reach the first node in the next level.
as shown in fig.
a the pre selection process will try event sequence and in turn until the ev ent sequence is accepted by the local reduction criteria.
finally lhdd used only seconds with trial executions to get the same reduction result which is much more efficient than the previous three dd algorithms.
iii.
our efficient event trace reduction framework in this section we first present the overall design of our event trace reduction system.
then we pr esent three test case reduction algorithms hdd ihdd and lhdd.
fig.
pre selection and local reduction strategy of lhdd fig.
design of simplydroid android device testing host adb enhanced monkey with state logger states log test case reduction engine simplydroid testing results application monkey scripts reduced test case test case crash trace results checker android os authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a. design of simplydroid the overall design of simplydroid is shown in fig.
.
the input of simplydroid is the original test case i.e.
the original crash trace while the output is a finally reduced test case.
the simplydroid tool consists of cooperating modules colored blue the test case reduction engine the result checker and the enhanced monkey with application state logger.
the test case reduction engine is the core of the simplydroid tool which realizes the sets of test case reduction algorithms.
the reduction process is iterative where the test case reduction engine repeatedly sends reduced monkey events to the application under test.
the enhanced monkey in turn sends the inputs in the script to the application under test.
we also enhanced monkey to record the state of the application i.e.
activity id upon sending each event.
at the end of a test script execution the result checker ch ecks the results by comparing exception messages and the stack traces outputted by monkey.
then the test results and the gui state log is feedback to the reduction engine to continue the delta debugging cycle.
finally the reduced test case is outputted.
b. building gui state hierarchy tree as shown in table the algorithm builds the gui state hierarchy tree from the crash tr ace containing the input events and states.
as discussed in section ii the crash trace of states is in the form s s2 ... s n crash state where si represents states.
note there is a corresponding events trace e1 e2 ... e n where each event ei triggers the transition from state s i to s i .
the algorithm builds a new node for each state si line to .
then it is compared with the nodes states from its previous node si to the root node line to .
if si is equal to any node it is added as a sibling node to it.
otherwise it is added as a child node of its previous node line .
table .
the gui hierarchy tree construction algorithm procedure build s in put s the se quences of activit y state lo gged.
out put r the root node of gui tree built.
begin n new node n0 is an em pty node for i to len gth s n i new node si the state of node ni is si n s n i start com parison from previous node while ns !
n0 if ni.state n s.state find a node with same state as ni set ni as a siblin g node of n s break n s n s.parent walk u p the tree end while if ns n no node in the path to root have same state set ni as a child node of ni end if end fo r return n0 return the root node en d c. hierarchical delta debugging algorithm hdd as shown in table the hdd algorithm is a realization of the idea of existing hierarchical delta debugging but operating on our tree based representation of a trace.
table the hdd algorithm procedure hdd e r input e the sequence of even ts logged.
input r the root node of the gui state hierarch ytree.
output er the sim plified event se quence.
begin m.add r m is a global vecto r storin g the reduced events n o deseq em pty nodse q stores the reduce d nodes at each level n e m pty n stores the se quence of nodes in next level add to nthe child nodes of each node in m d o if nis not em pty inlevel hdd n reduction in current level for each node niin n m now contains the reduce devents if m.contain ni update nodese q with m no deseq.inser t ni else remove node ni and its subtree from the tree rooted at r end fo r end if nis not em pty n.clear clear nto be em pty add to nthe child nodes of each node in m update n while nis not em pty note eris updated in checkevents on tri ggering bug return er en d procedure inlevel hdd n0 p input n0 t h e s e quence of nodes need to sim plify at current level input p the number of partition in this sim plification.
begin if length n0 p return partition n0into psubse quences n1 n2 ... np partition n0 p evtse q nodes2events nodeseq map nodes states to events for each node n jin group np test np first evtse q.insert eventsinsubtree nj inserts events in subtree end fo r if checkevents evtse q execute evtse q for checkin g m np record current reduction resul t inlevel hdd np continue finer reduction return successful reduction from n p return for i p 1to check the com plement of the other p partition evtse q nodes2events nodeseq for each node n jin n1 to np exce pt ni evtse q.insert eventsinsubtree nj if checkevents evtse q m mer ge n1to np exce pt ni inlevel hdd m p return successful reduction from com plements end fo r fail at current granularit y reduction at finer granularit y inlevel hdd np min p length np return en d procedure checkevents e0 in put e0 t h e s e quence of even ts need to execute on the a pplication.
ou tput res whether this se quence can re produce the crash.
begin if e0can tri gger crash on execution er e0 update er on successful tri ggering crash return true end if return false events cannot tri gger crash en d authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
this algorithm starts by invoking hdd .
owing to one one correspondences between input events and nodes states in the tree the algorithm simplifies the nodes states level by level from top to bottom line to .
within each level the in level node simplification procedure inlevel hdd is called line .
m is a global vector storing the current successfully reduced events which is updated in inlevel hdd line and .
the nodseq stores the reduced nodes at current level and is updated by m line .
and n stores the next level of nodes for reduction.
the inlevel hdd realizes the idea of hier archical delta debugging within one level until a simple st node sequence is found.
it partitions the event sequences line checks the last partition and performs recursive reduction if successful line .
otherwise it tries to reduce the complement of other partitions line to with recursive calls.
if it still fails it performs finer level reduction line .
the procedure checkevents is responsible for execute event sequences check whether the crash is triggered and update e r the final simplified event sequence line to .
there are three subroutines wh ose implementation is omitted for brevity which we explain as follows partition line whose function is to partition node sequence into subsequences with equal number of nodes.
nodes2events line maps the sequence of nodes to the corresponding sequence of events.
eventsinsubtree line whose function is to return all events in the subtree of a node.
d. balanced hierarchical delta debugging algorithm bhdd the algorithm of bhdd optimizes the hdd algorithm by changing the subroutine partition i.e.
line of hdd algorithm .
the partition of bhdd is to divide node sequence in the current level into partitions with equal number of nodes by counting the number of nodes in their sub trees.
we omit its detailed implementation for brevity.
e. layed hierarchical delta debugging algorithm lhdd as shown in table the algorithm lhdd is based on hdd except with two optimizations.
the first optimization is to add a process of pre selection line to within which more nodes are selected until the selected sequence of events that can trigger a transition to next level of activity is found.
the second optimization is to only checks the successful transition from the last node in the local level to the first node in the next level of activity in checkevents .
this saves the execution of the events in the subtree of the last node.
the procedure inlevel hdd of lhdd is the same as that of hdd algorithm so we omit it for brevity.
however there are some procedures called in inlevel hdd that is changed for lhdd algorithm which we detail them here.
first the function eventsinsubtree for lhdd is the same as that for hdd except that if a node is the last node it adds only the node itself without adding events in its subtree.
second the function partition for lhdd is the same as that of bhdd by considering of number of nodes of the subtrees except that the size of the last node in n is counted as .
the difference in these two procedures essentially reflects the local reduction logic the sub tree of the last node in the current level is not considered during reduction.
table the lhdd algorithm procedure lhdd e r input e t h e s e quence of even ts logged.
input r the root node of the gui state hierarch ytree.
output er the sim plified event se quence.
begin m.add r m is a global vecto r storin g the reduced events n o deseq em pty nodse q stores the reduce dnodes at each level n em pty n stores the se quence of nodes in next level add to nthe child nodes of each node in m d o if nis not em pty prelen perform preselection start at get the current preselected node se quence ns ns n while prelen len gth n evtse q nodes2events nodese q to event se quence for each node niin group ns add sub tree of selected nodes exce pt the last node evtse q.insert eventsinsubtree ni end fo r if checkevents evtse q preselection is successful break exit preselection else try pre selection with double size prelen min prelen length n ns n end of while preselections sto ps inlevel hdd ns performin g in level reduction for each node niin n if m.contain ni update nodse q with m no deseq.inser t ni else remove node nand its subtree from gui tree rooted at r end fo r end if n is not em pty n.clear clear nto be em pty add to nthe child nodes of each node in m update n while nis not em pty reduce at all levels eris updated in checkevents on tri ggering bug return er en d procedure checkevents e0 in put e0 t h e s e quence of event need to execute in the a pplication.
output res whether this sequence can trigger the crash at last level or transit to next activit ysuccessfull y at middle level begin if e0contains the last event of e last level testin g for crash if e0can tri gger crash er e0 update erwith the se quence e0 return true else not last level testin g for transition if e0can transit to the first node in the next level of activit y return true return false events can neithe r trigger crash no rtransition en d finally the procedure checkevents called in both lhdd and inlevel hdd is also changed line to which differentiates local check at intermediate levels and the final check in the last level.
for the local check the algorithm only checks the successful transition to the next activity.
for the final check in the last level the al gorithm checks whether a crash is triggered.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iv.
experiment and results analysis this section presents our experiment and data analysis.
a. research questions rq1 are hdd bhdd and lh dd effective to reduce the size of android input event sequence?
rq2 are hdd bhdd and lhdd efficient when performing test case reduction?
rq3 if lhdd is efficient which of the two optimizations contributes more to its performance improvement.
b. experimental setup we used a lenovo laptop v4400 as our testing host.
the laptop was equipped with intel i7 and 16gb memory.
the operating system was windows and the integrated development environment was eclipse.
we used the monkey tool as our testing engine.
on the phone model mi1 the interval between sending two events was set as 500ms and on mi5 the interval was set as 800ms to make sure that there was enough time for each event to be processed.
c. subject program and crash traces we have selected real life subject programs for our experimental study.
the descriptive statistics of the subject programs is summarized in table .
we have listed the program name a brief description of the application the application version the android os version the type of fault within the application the device hardware model used to run the tests the types of exceptions captured upon crash the number of crash traces for each application and th e range of the length of the traces in the table.
for example yahtzee was a mobile game application whose program version is .
.
the application was running on mi5 phone with android os version .
.
.
we injected mutant faults within the application to generate crashes of type arithmeticexception and the number of events within the crash trace ranges from to .
the other subjects can be interpreted similarly.
all the subjects were all real life mobile application that had evolved for many years.
furthermore the released versions were often quite stable while unstable commit versions were often hard to acquire.
as a re sult finding crash traces in application releases with mo nkey was not an easy task.
for dalvikexplorer weightchart and ringdroid we were lucky enough to find crash traces with real faults.
for the other subjects we had to manually create mutants by injecting faults frequently found in mobile applications.
we inserted removed or modified statements to inject faults.
we got another crash traces from the mutant programs.
our algorithm only worked on deterministic traces so we examined these crash traces to check whether they can replay stably.
we manually ex ecuted each crash trace times.
then we compared their excepti on messages and stack traces in the output to confirm reproducibility.
we removed traces which cannot be replayed by monkey stably due to non determinism in its execution.
we removed a subject called sanity and its crash traces because replaying it stably requires resetting its data before each ex ecution which was not supported by the current implementation of simplydroid.
we removed versions of whohasmystuff because the interaction with the application may sometimes activate the soft input keyboard which changed the layout of the gui.
as a result the coordinate sensitive monkey cannot replay them.
finally the crash traces left were all used in our data analysis.
to facilitate identification of the gui state hierarchy we had also enhanced monkey tool to log the application gui states i.e.
activity id in this work during testing.
therefore our crash traces contained not only the seque nce of input events but also their corresponding gui states.
d. experimental procedure we also realized the classic delta debugging dd algorithm as a benchmarking technique for comparison.
we performed test case reduction on all the crash traces with dd hdd bhdd and lhdd algorithms.
we logged the size of the reduced test cases as well as the time for reduction for each technique on each trace.
since th ere are two major optimizations in the lhdd algorithm i.e th e pre selection and the local reduction we wonder which optimization contributes more in its performance improvement.
so we turned off the pre selection optimization in the lhdd i.e.
using the local reduction optimization only to form a new technique lhdd nopre for comparison with lhdd.
we also used lhdd nopre to perform test case reduction on the crash traces and log their reduction results.
e. experimental results and analysis in this section we present our experimentation results followed by detailed results anal ysis for each research question.
answering rq1 in this section we would like to know whether our proposed hdd techniques are effective to reduce th e size of android input event sequence.
table subject programs subject subject description program version android versionfault typedevice exception type number of crash traces crash trace length yahtzee game .
.
.
mutan t mi5 arithmeticexception k9mail mail .
.
mutan t mi5 nullpointerexception dalvikexplorer system information viewe r .
.
.
real mi1 activitynotfound outofmemoryerro r11 weightchart weight recorde r .
.
.
.
real mi1 activitynotfound ringdroi d ringtone edito r .
.
.
real mi1 runtimeexception tippy calculato r .
.
.
.
mutan t mi5 arithmeticexception syncmypic photo synchronize r .
.
.
mutan t mi5 arithmeticexception whohasmystuff item lending helpe r .
.
.
.
mutan t mi5 runtimeexception authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we have shown the length of the crash traces after reduction by each technique in table .
fo r each trace we show its number the original length of the cras h trace before reduction and the length of the reduced crash trace for dd hdd bhdd and lhdd each in one row.
since there are too many traces in total to be shown we have to wrap around the results at number within the subject dalvikexplorer .
we also listed the results of lhdd without pre selection lhdd nopre in the last row for comparison purpose which we will discuss when answering rq3.
when compared with the original crash trace length all the techniques achieve significant test case reduction rates.
except for a few outlier cases most of these techniques achieve reduction rates of more than .
furthermore the actual length of crash traces after reduction is small for most of the cases.
thus we can answer rq1 that the hdd techniques are effective to reduce the size of crash.
there are crash traces no.
and no.
of k9mail no.
of weightchart in grey where the family of hdd techniques generate larger redu ced test case than dd technique.
we have inspected these crash traces carefully and found that this is due to the imprecise logging of application states in our enhanced monkey.
for k9mail a popup window interferes with the current activity for weightchart a system activity misleads our logger.
we will improve our state logger in future work.
despite these exceptional cas es the family of hdd techniques hdd bhdd lhdd in general has statistically comparable reduction effectiven ess as the dd technique.
we have performed anova test to check whether the different techniques dd hdd bhdd lhdd have significant difference from each other.
the anova return a p value more than .
which cannot reject the null hypothesis at .
significance level.
therefore th ere is no significant difference among these techniques in terms of reduction effectiveness.
answering rq2 in this section we would like to know whether the family of hdd techni ques is efficient such that developers need not to wait for a prolonged period to get a reduced test case .
the test case reduction time for the subject programs are shown in fig.
to fig.
.
within each figure the x axis shows the crash traces number and the y axis shows the test case reduction time in seconds.
for some progr ams the differ ence in reduction time between different crash traces is so big that we have to show the results in the log scale for y axis.
we can see from the plots that in general the lhdd algorithm performs the best while the dd algorithm performs the worst.
in fact for majority of crash traces the time saving of the lhdd technique compared to the dd technique is significant.
for example for crash trace no.
of weightchart dd takes hours seconds whereas lhdd takes only less than minutes seconds .
when averaged over the crash traces hdd bhdd and lhdd save .
.
and minutes over dd per trace respectively.
in total hdd bhdd and lhdd save around and hours of debugging time over dd on all crash traces respectively.
table summary of test case reduction efficiency dd hdd bhdd count percenta ge count percenta ge count percenta ge hdd bhdd lhdd the reduction efficiency fro m dd to hdd and then to bhdd and finally lhdd appears to increase gradually.
for each pair of techniques we have computed the number and percentage of crash traces where the former uses less test case reduction time in other words better than the later as shown in table .
hdd is more efficient than dd on out of cases.
the percentage of crash traces where bhdd is more efficient than dd and hdd are and respectively.
lhdd is more efficient than dd hdd and bhdd on and of the crash traces respectively.
table length of crash trace test case after reduction subjects yahtzee k9mail dalvikexplorer no.
original dd hdd bhdd lhdd lhdd nopre subjects dalvikexplorer weightchart ringdroid tippy syncmypic whohasmystuff no.
original dd hdd bhdd lhdd lhdd nopre authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
test case reduction time for dalvikexplorer fig.
test case reduction time for weightchart fig.
test case reduction time for ringdroid fig.
test case reduction time for tippy fig.
test case reduc tion time for syncmypic fig.
test case reducti on time for whohasmystuff fig.
test case reduction time for yahtzee test case reduction time seconds crash traces dalvikexplorer dd hdd bhdd lhdd nopre lhdd test case reduction time seconds in log scale crash traces weightchart dd hdd bhdd lhdd nopre lhdd test case reduction time seconds crash traces ringdroid dd hdd bhdd lhdd nopre lhdd test case reduction time seconds crash traces tippy dd hdd bhdd lhdd nopre lhdd test case reduction time seconds in log scale crash traces syncmypic dd hdd bhdd lhdd nopre lhdd test case reduction time in log scale crash traces whohasmystuff dd hdd bhdd lhdd nopre lhdd test case reduction time seconds crash traces yahtzee dd hdd bhdd lhdd nopre lhdd authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
there are a few exception cases where lhdd is slower to perform reduction than dd.
we have examined those cases to understand the reasons behind.
for example the crash trace no.
and no.
of ringdroid optionally popped up an alertdialog which hided the underlying activity.
this situation made our monkey tool unable to log the correct gui states.
similarly the crash trace no.
and no.
of k9mail popped ups floating windows during execution which made our monkey tool unable to log the same gui states each ti me.
this in turn disrupted the reduction process of lhdd.
despite those exceptional cases we can see from our results that this family of hdd techniques increasingly improves the efficiency of dd where lhdd bhdd hdd dd without significant loss of reduction effectiveness.
answering rq3 for our lhdd algorithm there are two optimizations to improve its performance.
in this section we would like to find out how much each optimization has contributed to the overall optimization.
to perform the comparison in the experiment we turned off the pre selection optimization in lhdd so that we can see the impact of each factor with comparison.
in table the rows of lhdd nopre show the reduction results of lhdd without pre selection.
we can see that in general the reduction effectiveness of lhdd nopre is close to lhdd.
a further anova analysis also confirms that there is no significant difference between lhdd nopre and lhdd in terms of the size of reduced test case.
however as shown in fig.
to fig.
the test case reduction time of lhdd nopre is larger than lhdd on most crash traces.
we further count the number of crash traces where lhdd performs better than lhdd nopre .
we found that there are out of the i.e.
crash traces on which lhdd performs better.
furthermore if we compare lhdd nopre with its base technique bhdd note their partition routine is the same there are out of the i.e.
crash traces on which lhdd nopre outperforms.
this result shows the performance of lhdd nopre lies in between bhdd and lhdd.
therefore we can answer rq3 that both optimizations local reduction and pre selection contribute to the performance improvement of lhdd.
f. threats to validity we focused on improving the efficiency of test case reduction technique rather than dealing with the impact of nondeterminism in execution.
therefor e we selected stable crash traces to perform test case reduction.
we leave the handling of non deterministic crash traces as a future work.
the definition of state equivalence also has an impact on the test case reduction.
currently ou r trace representation uses the activity id to represent the gui state which is a lightweight solution.
using a finer level of gui state equivalence to build the gui hierarchy tree may lead to different test case reduction results.
however the logging of state will also become expensive.
we will leave the exploration of this trade off in future work.
we use java to realize our simplydroid tool.
we have carefully performed code review and testing on our implementation to ensure their correctness.
we used subjects and crash traces to evalua te our simplydr oid platform.
additional studies on more real life crash traces will further strengthen the validity of our study.
in our experiment we removed sanity and its crash traces because replaying it stably require s resetting its data before each execution.
to enhance the applicab ility of simplydroid we may perform reinstallation of the application or reload a system snapshot with the emulator before each execution.
v. r elated work in this section we will briefly review related works including debugging techniques android testing techniques and test case reduction techniques.
fig.
test case reduction time for k9mail test case reduction time seconds in log scale crash traces k9mail dd hdd bhdd lhdd nopre lhdd authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a. debugging techniques fault localization is a time consuming.
program slicing can confine the search range to a program slice instead of the entire program.
a program slice can be obtained statically or dynamically .
spectrum based fault localization correlates failures against problem spectra which provides correlation information on program entities for users to review.
there are other techniques for fault localization such as statistical methods to locate bugs with instrumented predicates state based methods that use variables and values and even machine learning based techniques that train neural networks to construct models for fault localization .
b. android application testing technique there are also many tech niques proposed for android application testing.
model based testing techniques first build a model for the application under test and then generate test cases based on the model .
amalfitano et al.
proposed a crawler based technique to build a gui model and generate input events.
puma is a dynamic analysis framework and test case generation tool with generic design.
choi et al proposed the swifthand tool to minimize the number of application restart during testing.
azim et al.
proposed the a3e tool with two complementary gui traversal st rategies a3e depth first and a3e targeted.
monkey is a well known android application random testing tool developed by google and has been widely adopted in stress testing and reliability testing .
dynodroid is another automated testing tool with strategy similar to monkey yet with more sophisticated strategies .
sapienz is a multiobjective and search based android application testing tool whose optimization goal includes both code coverage rate and fault detection rate .
there are also several test de velopment platforms such as monkeyrunner robotium and uiautomator for developers to write customized test scripts.
c. test case reduction the goal of test case reduction or minimization is to find a minimal subset of inputs that can still produce the same failure.
delta debugging is a method to automate the debugging of programs using the hypothesis trial result loop .
simplification and isolation are two major algorithms of delta debugging .
ddmin is direct realization of simplification algorithm whose goal is to find a minimal subset of inputs that each element of it is necessary for reproducing the failure so that it cannot be removed.
for test case reduction of android application clapp et al.
proposed the non deterministic delta debugging minimization nd3min algorithm.
nd3min improved the ddmin algorithm by handling the non deterministic execution of android input event sequence.
it adopts a probability approach by executing each candi date reduction many times and only considers this candidate successful if its success rate exceeds a threshold.
our simp lydroid tool differs from nd3min in two aspects.
first they have different reduction goals.
simplydroid tries to reproduce a crash or failure while nd3min tries to find a minimal event trace that can reach a given target activity.
second simplydroid mainly addresses the problem of test case reduc tion efficiency whereas nd3min mainly addresses the problem of non deterministic execution.
d. simplification of test case with structures ddmin is based on test cases of string input so that the minimal independent element of simplification is a single character.
based on ddmin the berkeley delta algorithm uses a line of text as the basic unit in reduction.
c reducer can simplify large c programs .
it shares the same basic idea with delta debugging but uses a modularized strategy of deletion and simplification based on the grammar tree representation of the program source code .
apart from c c programs ther e are also many test cases artifacts with explicit hierarchical structur e characteristics such as html and xml files.
misherghi and su proposed the original hierarchical delta de bugging algorithm to realize the simplification of c c programs and html xml files .
utilizing the hierarchical structure information of the test input their hierarchical delta debugging algorithm can be much more efficient than the st andard dd algorithm.
vi.
c onclusion and future work there are many automated test case generation techniques to ensure the quality of android applications.
the monkey fuzz testing tool and its improved versions are simple effective and widely adopted in the industry.
the test cases generated by monkey often contain a large number of input events which are difficult to be used by developers in debugging.
it is desirable to simplify the input event sequence as small as possible while triggering the same failure.
however the traditional delta debugging technique is slow to perform such simplification.
we observe that the events within a failure inducing trace have hierarchical relationships in the form of user interaction sessions that can be reduced together with high probability.
in this work we have proposed simplydroid a crash trace simplification tool for android applications.
we have proposed a novel gui state hierarchy tree as trace representation and a family of hierarchical delta debugging algorithms to operate on this trace representation.
our experiments on crash input traces on eight real life android applications show that techniques in this family are increasingly more efficient to perform test input reduction.
for future work we will further study the non deterministic execution problem in th e context test case reduction.
we will also perform empirical study to explore the impact of state equivalence on test case reduction.
r eferences h. agrawal j. r. horgan.
dynamic program slicing.
in proceedings of the acm sigplan conference on programming language design and implementation pp.
white plains new york .
d. amalfitano a. r. fasolino p. tramontana b. d. ta a. m. memon mobiguitar a tool for automated m odel based testing of mobile apps.
ieee software .
t. azim i. neamtiu targeted and de pth first exploration for systematic testing of android apps.
in pr oceedings of the acm sigplan authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
international conference on object oriented programming systems languages applications oopsla new york ny usa acm pp.
.
l.c.
briand y. labiche x. liu.
using machine learning to support debugging with tarantula.
in proceedi ngs of the 18th ieee international symposium on software reliability pp.
trollh attan sweden .
y. brun m. d. ernst.
finding latent code errors via machine learning over program executions.
in proceedi ngs of the 26th international conference on software engineering pp.
edinburgh uk .
y. chen.
improving the utility of compiler fuzzers utah usa the university of utah .
w. choi g. necula k. sen guided gui testing of android apps with minimal restart and approximate lear ning.
in proceedings of the acm sigplan international conference on object oriented programming systems languages a pplications oopsla2013 new york ny usa acm pp.
.
shauvik roy choudhary alessandra gorla and alessandro orso.
automated test input generation for android are we there yet?
e .
in proceedings of the 30th ieee acm international conference on automated software engineering ase ase .
ieee computer society washington dc usa .
l. clapp o. bastani s. anand a. aiken.
minimizing gui event traces.
in proceedings of the th acm sigsoft international symposium on foundations of software engineering fse .
acm new york ny usa .
.
m. c. gaudel.
testing can be formal too.
in p.d.
mosses m. nielsen m.i.
schwartzbach eds.
tapsoft theory and practice of software development.
lecture notes in comp uter science number springerverlag heidelberg pp.
.
t. gyimothy a. beszedes i. forgacs.
an efficient relevant slicing method for debugging.
in proceedings of 7th european software engineering conference and 7th acm sigsoft international symposium on foundations of software engineering pp.
toulouse france september .
s. hao b. liu s. nath w. g. halfond r. govindan puma programmable ui automation for large scale dynamic analysis of mobile apps.
in proceedings of the 12th annual international conference on mobile systems applications a nd services mobisys2014 new york ny usa acm pp.
.
j. a. jones m. j. harrold.
empirical evaluation of the tarantula automatic faultlocalization techni que.
in proceedings of the 20th ieee acm conference on automated software engineering pp.
long beach california usa .
b. korel.
pelas program error locating assistant system.
ieee transactions on software engineering .
b. korel s. yalamanchili.
forwar d computation of dynamic program slices.
in proceedings of the acm sigsoft international symposium on software testing a nd analysis pp.
seattle washington .
b. liblit m. naik a. x. zheng a. aiken m. i. jordan.
scalable statistical bug isolation.
in proceedings of the acm sigplan conference on programming language design and implementation pp.
chicago illinois usa .
a. machiry r. tahiliani m. na ik dy nodroid an input generation sy stem for android apps.
in proceedings of the 9th joint meeting on foundations of software engine ering esec fse new york ny usa acm pp.
.
k. mao m. harman y. jia.
sapienz multi objective automated testing for android applications.
in proceed ings of the 25th international symposium on software testing and analysis issta2016 acm new york ny usa pp.
.
g. misherghi z. su.
hdd hierarchi cal delta debugging.
in proceedings of the 28th international conference on software engineering.
shanghai china acm pp.
.
j. regehr y. chen p. cuoq e. eide c. ellison and x. yang.
test case reduction for c compiler bugs.
in proceedings of the acm sigplan conference on programming language design and implementation beijing china acm pp.
.
m. renieris s. p. reiss.
fault localization with nearest neighbor queries.
in proceedings of the 18th ieee international conference on automated software engineering pp.
montreal canada october .
t. reps t. ball m. das j. larus.
the use of program profiling for software maintenance with applications to the year problem.
in proceedings of the 6th european so ftware engineering conference pp.
zurich switzerland september .
m. weiser.
programmers use slices when debugging.
communications of the acm .
m. weiser.
program slicing.
ieee tran sactions on software engineering se .
a. zeller.
yesterday my program worked.
today it does not.
why?.
in acm sigsoft software engineering notes pp.
volume issue .
a. zeller.
isolating cause effect chains from computer programs.
in proceedings of the 10th acm sigsoft symposium on foundations of software engineering pp.
ch arleston south carolina usa .
a. zeller r. hildebrandt.
simplif ying and isolating failure inducing input.
ieee transactions on software engineering .
x. zhang r. gupta y. zhang.
pr ecise dynamic slicing algorithms.
in proceedings of the 25th ieee international conference on software engineering pp.
portland oregon usa .
android uiautomator.
eloper.android.com tools help uiautomator index.html.
c reduce.
last access .
delta.
last access .
delta debugging a.org wiki delta debugging last access .
garnter.
worldwide smartphone sales to end users by operating system in 3q16.
google play.
the google play application market.
mobile testing center of baidu.
h ttp mtc.baidu.com last access .
monkey runner.
com tools help monkeyr unner concepts.html.
robotium.
statista.
number of available applications in the google play store from december to december .
testin.
last access .
the monkey ui android testing tool.
m tools help monkey.html.
utest platform of tencent.
last access .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.