statically checking web api requests in javascript erik wittern annie t. t. ying y unhui zheng julian dolby jim a. laredo ibm t. j. watson research center y orktown heights ny usa email witternj aying zhengyu dolby laredo us.ibm.com abstract many javascript applications perform http requests to web apis relying on the request url http method and request data to be constructed correctly by string operations.
traditional compile time error checking such as calling a nonexistent method in java are not available for checking whether such requests comply with the requirements of a web api.
in this paper we propose an approach to statically check web api requests in javascript.
our approach first extracts a request s url string http method and the corresponding request data using an inter procedural string analysis and then checks whether the request conforms to given web api specifications.
we evaluated our approach by checking whether web api requests in javascript files mined from github are consistent or inconsistent with publicly available api specifications.
from the requests in scope our approach determined whether the request s url and http method was consistent or inconsistent with web api specifications with a precision of .
.
our approach also correctly determined whether extracted request data was consistent or inconsistent with the data requirements with a precision of .
for payload data and .
for query data.
in a systematic analysis of the inconsistent cases we found that many of them were due to errors in the client code.
the here proposed checker can be integrated with code editors or with continuous integration tools to warn programmers about code containing potentially erroneous requests.
keywords static analysis javascript web apis i. i ntroduction programmers write applications using a growing variety of publicly accessible web services.
catalogs such as ibm s api harmony mashape s publicapis or programmableweb list thousands of web application programming interfaces web apis exposed by these services.
applications invoke web apis by sending http requests to a dedicated url using one of its supported http methods required data is sent as query or path parameters or within the http request body.
the url http method and data to send are all basically strings constructed by string operations within the applications.
figure shows an exemplary excerpt of such a javascript application performing these actions.
when a request targets a url that does not exist or sends data that does not comply with the requirements of the web api a runtime error occurs.
this prevalent calling mechanism for web apis which relies on a string url a http method as well as string input and output does not allow type safety checking.
in other words checks for traditional compile time errors are not available for programmers writing code calling the author names were sorted alphabetically.
the authors contributed equally to the work.web apis.
a recent study found that a significant number of analyzed mobile applications will fail in light of changes to the web apis they consume .
the situation is worsened as web applications are increasingly developed using dynamic languages like javascript which generally also have minimal static checking.
as an example of resulting errors we found code in github that mistakenly attempts to make a request to spotify.com v1 seach as opposed to invoking the correct url ending with search .
another example we found figure attempts to invoke the deprecated google maps engine api.1a programmer wishing to avoid these errors can manually assess the correctness of web api requests by consulting the api s online documentation or formal web api specifications.
such specifications like the openapi specification formerly known as swagger the name we will use for the rest of the paper can be created by api providers or third parties to document valid urls http methods as well as inputs and outputs that a web api expects.
tools that can automate this manual and thus error prone and tedious checking should have two desirable features such tools should statically analyze javascript source code to automatically identify http requests and retrieve the related url http method and data which are all encoded as strings and created using typical string operations like concatenation.
in addition the analysis must be inter procedural as the strings can be assembled across functions.
as input such tools should make use of available specifications like swagger for the definitions of valid urls http methods and data.
such tools can report errors either real time as a programmer is writing the application or during continuous integration.
in addition they can help api providers to monitor usages of their apis in publicly available code.
in this paper with these two features in mind we propose an approach that takes as input swagger specifications and statically checks whether the web api requests in javascript code conform to these specifications.
our approach first extracts the url string http method and the corresponding data from a request using an inter procedural static program analysis capable of extracting strings and then checks whether the request conforms to publicly available web api specifications.
for the initial implementation we chose to handle requests ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
written using the jquery framework due to its popularity reportedly of websites use the jquery framework .
the main contribution of our approach is in leveraging existing work in making static whole program analysis possible for framework based javascript web applications i.e.
and applying it to a new problem of checking whether a request is consistent with a web api specification.
we evaluated our approach by checking whether web api requests from over javascript files on github2were consistent or inconsistent with publicly available web api specifications provided by the apis guru project .
from requests for which we had web api specifications available our analysis achieved a precision of .
in correctly extracting and determining that the url and http method in a request is consistent or inconsistent with the corresponding web api specification.
our approach also correctly extracted and determined whether the request data was consistent or inconsistent with the data requirements with a precision of .
for payload data and .
for query data.
we systematically examined all the urls and payload data that were inconsistent with any specification cases and found that many of these inconsistencies were due to errors in the client code including calls to deprecated apis errors in the urls and errors in data payload definitions.
in only five of the cases limitations in our static analysis affected the matching of a request to a url endpoint in the specification to the point of incorrectly flagging requests as mismatches.
these limitations also extended to four out of 18cases where request payloads were mistakenly flagged as mismatches and two out of41 cases where query parameters were mistakenly flagged as mismatches.
these results show that the static analysis is precise enough to be used in our proposed checker for checking an application under development or for checking the validity of web api usage in existing source code in case a web api undergoes changes.
the remaining of this paper is organized as follows after illustrating an example section ii we describe our approach the static analysis section iii and the checker section iv .
we then present the evaluation section v related work section vi threats section vii and conclusion section viii .
ii.
b ackground and example in this section we first introduce concepts and terms regarding web apis and their specifications.
we then demonstrate through an example the two steps of our approach how we use static analysis to extract the strings constructing a web api request section ii a and how we check the results of the static analysis against swagger specifications section ii b .
web apis are programmatic interfaces that applications invoke via http to interact with remote resources such as data or functionalities.
resources are identified by urls while the type of interaction e.g.
retrieval update deletion of a resource depends on the http method .
following previous 3consider the high number of changes reported for various apis at https function updatelocation feature .
var location feature.getposition .
var mutation .
features .
id feature.attributes.id .
geometry .
type point .
coordinates .
columnname geometry .
.
properties .
.
.
var url .
v1beta2 tables aid .
features batchpatch .
sendrequest url mutation handleeditresponse .
.
.
function sendrequest url request done error .
jquery.ajax .
type post .
url url .
datatype json .
data json.stringify request .
success function inner done .
return function data .
requestcomplete data inner done .
.
done .
error function inner done .
return function data .
requesterror data inner done .
.
error .
.
url url urlmutation requestmutation requesturl g2 g1 g5 g3 g11 g3 g1 g6 g7 g9 g12 g2 g1 g4 g9 g8 g11 g10 g9 g7 g1 g6 g7 g9 g12 fig.
code excerpt of a request to the google maps engine api source 469bd9516c71d33b5b27e0f0ae map playground playground.js work we refer to the combination of a url and http method as an api endpoint .
to be successfully invoked some endpoints depend on additional data for example the id of a resource being sent as a path parameter within the url or a new updated state of a resource being sent in the body of an http request.
application developers can learn the usage of the endpoints of an api either by consulting its online documentation typically presented in html or by relying on a formal web api specification.
specifications define among other things an api s endpoints as well as the data required for and returned by requests.
the openapi specification swagger is one of these specifications which enjoys broad industry support .
figure shows an excerpt of a swagger document describing the instagram api.
it defines for example the schemes of the api its host andbasepath which together form the api s base url in this case .
swagger defines the different endpoints of an api in thepaths property using url templates possibly containing path parameters i.e.
tag name in the path tags tag name media recent and supported http methods.
per endpoint swagger provides a human readable description definitions of the parameters path and query parameters as well as required http bodies definitions of possible responses as well as security requirements.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
entries in the definitions property describe the structure of data to send to or receive from endpoints using jsonschema notation or a xml object notation that is specific to swagger.
data definitions can be referenced from endpoint definitions as is exemplary shown for the tagmedialistresponse definition in figure .
a. determining the content of a request in javascript code the first step of the checker is to extract the specifics of web api requests in the code.
our approach employs an interprocedural static analysis to extract url and input strings from a web api request in javascript code.
recall the code in fig.
as an example.
focusing on the url variable we can see that it is composed from two constant strings and the aid variable in the function updatelocation .
the value of url is then passed to sendrequest where it flows into the jquery.ajax call.
the value of aid is a parameter and could be different in multiple runs.
hence when we aim to extract the url used in this request we denote aid as a symbolic value aid using curly braces indicating that the value is not known statically.
overall the url extracted for the shown request is v1beta2 tables aid features batchinsert .
as this example shows a simple textual search like grep would not be effective because the call site of the request e.g.
sendrequest in figure can be different from the definition of the url string updatelocation in figure .
in addition given a url string can be assembled across multiple functions and lexical scopes e.g.
the url tag name me dia recent which our static analysis correctly extracts from the code excerpts in figure resolving such an url string requires non trivial data flow analysis.
the same holds for the http method or request data values which may be created within multiple functions.
b. checking a request against a web api specification the second step of our approach checks whether the extracted information from the web api requests conforms with web api specifications.
consider for example the url searchhashtag media recent?client id 1e3... extracted by our static analysis from the code excerpt in figure .
our check would start by determining whether it together with the associated method targets an actual endpoint defined in the swagger specification of the instagram api including thesearchhashtag path parameter.
in addition we can check whether the client id parameter is expected by the endpoint or if there are other query parameters required which are missing in the url.
finally we can check if the data sent in the request body adheres to the data definitions in the swagger specification.
another option to check whether a web api request is correct would be to perform a dynamic analysis .
however invocations of web apis often require authentication for example using api keys so that a system using dynamic01.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.swagger .
schemes https host api.instagram.com basepath v1 paths tags tag name media recent get description get a list of recently tagged media.
parameters description the tag name.
in path name tag name required true type string description count of tagged media to return.
in query name count required false type integer responses description list of media entries with this tag.
schema ref definitions tagmedialistresponse definitions tagmedialistresponse properties data description ... type array items ref definitions mediaentry fig.
excerpt of a swagger specification for the instagram api highlighting the get tags tag name media recent endpoint .
document .ready function .
var clientid 1e31ec2d23d0411c94d896c5f5d75886 .
var searchhashtag .
submithashtag .click function .
searchhashtag searchtag .val .
searchinstagram searchhashtag .
.
.
function searchinstagram tag .
.ajax .
type get .
datatype jsonp .
cache false .
url tag .
media recent?client id clientid .
success function data .
for var i i data.data.length i .
if data.data .location !
null .
data.data .
.
.
.
.
.
tag tag searchhashtagclientid clientid g2 g1 g4 g3 g8 g3 g1 g5 g6 g7 g9 fig.
code excerpt of a request to the instagram api source master app assets js app.js analysis would need to provision keys to register and even agree to the terms of service.
typically terms of service are not easy to understand by a layman and are much less likely to be encoded in a machine readable form to allow a program to decide whether or not to comply with the terms.
finally even if the key provisioning issue was addressed ensuring dynamic analysis has the proper code coverage is challenging.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g1 g1 g3 g10 g7 g1 g13 g25 g14 g17 g16 g1 g5 g20 g16 g22 g15 g2 g13 g12 g28 g16 g15 g1 g4 g12 g22 g22 g1 g6 g27 g12 g25 g19 g1 g3 g30 g20 g22 g15 g16 g27 g1 g11 g16 g13 g1 g9 g16 g26 g30 g16 g28 g29 g1 g7 g24 g14 g12 g29 g24 g27 g1 g8 g14 g27 g14 g12 g15 g24 g19 g23 g26 g1 g13 g11 g9 g2 g5 g19 g20 g16 g1 g3 g12 g14 g21 g31 g12 g27 g15 g1 g10 g22 g20 g14 g16 g27 g1 g17 g24 g27 g1 g9 g16 g26 g30 g16 g28 g29 g1 g8 g12 g27 g28 g19 g12 g22 g20 g23 g18 g1 g4 g14 g20 g20 g1 g1 g6 g24 g14 g23 g18 g1 g12 g26 g14 g26 g16 g21 g16 g22 g26 g1 g9 g19 g25 g26 g1 fig.
web api usage extractor overview.
iii.
w eb api u sage extraction a fundamental part of our approach is to detect and extract web api usages from javascript source code.
figure shows the web api usage extractor pipeline.
the input is a javascript file.
the output is web api usage including urls and request payloads in json format.
the decision to have a single javascript file as input i.e.
setting the analysis scope to the file level as opposed to the program level is based on our initial observations that the input strings are often in the same file as the requests.
this decision also supports an analysis light weight enough to be used repeatedly during development.
for the rest of this section we describe the three main components in the pipeline field based call graph builder the extractor takes a javascript file as input and parses the script excluding files with syntax errors.
the analysis then translates the script into the intermediate representation and builds an approximate call graph called a field based call graph .
a field based call graph is a statement level call graph that uses one abstraction for all instances of each property used in the program as opposed to one abstraction for each property of each abstract object as in traditional call graphs this has been shown to scale well for framework based javascript web applications even in the presence of javascript s dynamic features .
in our implementation we used the field based call graph construction available in w ala .
for optimization this call graph construction in w ala used to ignore all data flow that does not involve functions.
to support our string analysis we extended the data flow analysis in the call graph construction to also track data flow of strings in the program.
we take all functions in the script as entry points for the call graph.
standard approaches take event handlers and top level blocks as entry points.
however if we were to use the same approach our analysis with the scope at the file level could miss entry points if functions are registered as event handlers in a script beyond the analysis scope.
web request locator to identify api invocations we look for framework specific patterns in the call graph.
for jquery we handle the most common patterns i.e.
function calls to .ajax .get and .post .
we note instructions that make such calls and use them as the seeds for the inter procedural data flow analysis the next component in the pipeline.
when a script does not contain a matched invocation statement our analysis does not produce any output and the pipeline01.
request .
cache false .
success anonymousfunctionid .
datatype jsonp .
type get .
url .
media recent?client id d1e31ec2d23d0411c94d896c5f5d75886 .
fig.
extracted api usage for the example in figure .
terminates.
backward slicer for request marshaling in this step we extract the statements that contribute to the input of the web api invocations.
starting from each request function call captured in the previous step we apply standard interprocedural backward slicing to narrow down the subset of statements of the program that affect the statement containing the request.
in our implementation we used the w ala backward slicer .
to get the actual strings pertaining to the url and other parameters in a request we recover all possible data flows that lead to the request.
string values that cannot be determined until runtime are represented by symbolic values e.g.
the value of searchhashtag in figure is retrieved from the front end in line .
for strings with symbolic values we model common string operators i.e.
concatenations and encodeuri .
for constant strings we model additional string operators including substring replace and indexof .
currently research on robust and scalable modeling of string operators with symbolic values is still ongoing .
however we believe these cases are not significant in the web api usage extraction.
this assumption is also supported by the observations in the experiment we only found two cases where this limitation led the checker to incorrectly flag a string url as a mismatch to the specification section v b .
we assume all execution paths leading to the request are feasible and we thus perform path insensitive data flow analysis.
it is possible that a variable has multiple definitions from different paths.
for example figure shows two common patterns where multiple urls can be extracted from a request.
in figure 6a variable query in line 7can have different values depending on the predicate in line .
in figure 6b function changedisplaystuffs can be invoked with different parameter values in line 8and9.
for such cases we take the union of all possible values.
finally we output the analysis result in json format.
the analysis output for the example shown in figure is presented in figure as an example.
the extracted data contains the retrieved url and http method as well as all other properties passed to the .ajax function.
iv .
c hecking procedure the goal of the checking procedure is to match the information produced by the static analysis against formal web api specifications.
the procedure reveals inconsistencies between the request implementation and the specification.
in general the information about each request consists of one url of the web api to invoke including the path identifying the endpoint and possibly a query string the http method and when required data being sent in the payload body authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
var query track ... artist ... .
if query.split .length forbidden character .
query query.split query.split .
.
.
.ajax .
url query type track .
... .
a multiple paths source master script.js .
function changedisplaystuffs trackid .
.ajax .
url trackid .
... .
.
.
.
changedisplaystuffs 1hbcclmpw0q2wdwpdgckds .
changedisplaystuffs 79qlnzupzzzexlior0zdtz b multiple callers source ricedemocraticdj blob master song 20viewer js create search.js fig.
code excerpts exemplifying the extraction of multiple urls for one request.
of the request.
due to the nature of the analysis though in practice multiple url values http methods and payload data can be retrieved for a single request because the static analysis considers all possible execution paths to the invocation as mentioned previously in section iii .
we designed the checking procedure to compare any possible combinations of these data points against a web api specification.
if any combination matches a specification no error is reported so as to not annoy users with false positives.
a. checking endpoints the first part of the procedure aims to match a request to an endpoint defined in an api specification.
the procedure starts by checking whether any of the urls for a given request begins with any of the base urls of the known api specifications.
if an api specification contains more than one base url for example as it defines schemes http and https all versions are checked.
furthermore it is possible that multiple specifications are found to match to a request for example because multiple specification versions exist for the same api or because the static analysis reports multiple urls for the request.
if no specification can be matched the procedure reports an error instructing users to check whether the base url is defined correctly.
next the procedure attempts to match a request s urls to paths defined in the api specifications.
to match a path the procedure takes every url of a request and compares it against the path definitions in every specification previously matched to that request.
every path definition of the request s url strings is retrieved by truncating the base url defined in the specification and the query string if it exists.
the remaining path strings are then compared against the path definitions in the specifications by checking whether every path component separated by matches.
this matching considers that both the path strings from the urls and the swagger path definitions may contain variables denoted by curly brackets.
the procedure treats these path components as wild cards.
multiple path definitions may be matched to asingle request because multiple specifications can be matched and because a request may contain multiple urls.
finally the procedure determines if the http method matches the specification.
if the static analysis does not report an http method the method is assumed to be get .a n y method determined by the static analysis is checked against all methods defined in all matched specifications and all matched paths.
b. checking request data for requests that can be matched to an endpoint definition in an api specification the procedure additionally checks the validity of request data if it exists .
request data is either the data sent in the payload body of a request typically of post put o r patch requests and the data sent within a query string.
checking payload data data sent in the payload body of an http request can be in any format.
as the static analysis focuses on javascript and because its the prevalent data format in web apis we focus on data in the javascript object notation json .
swagger specifications allow the expected payload data to be defined either for certain paths across all methods or for specific endpoints an endpointlevel definition overrules a path level one .
payload data definitions can be specified in place or by referencing definitions in the central definitions section of the specification.
the procedure considers all these ways to define payloads and if needed resolves conflicts of definitions on different levels.
if any of the matched specifications defines a payload schema in any of the matched endpoints the procedures determines if the payload data reported in the request information adheres to that schema or not.
a possible violation is that a property marked as required in the schema is not present in the data.
checking query parameters the query data is encoded in key value pairs.
within api specifications query parameters can be defined as either optional or required.
the checking procedure then can determine whether all required query parameters are present in a request.
again the procedure considers definitions of query parameters from different locations in a specification and to resolve possible conflicts between definitions on different levels.
to check the query parameters the procedure parses the query strings of all urls reported for a request.
it then checks whether any of the found parameter sets matches the parameter definitions found in any of the endpoint definitions matched for the request.
v. e v alua tion to evaluate the web api request checker described in sections iii and iv we applied it to the problem of identifying and checking whether javascript web apis requests are consistent or inconsistent with a api specifications.
the input of the checker is a set of javascript code mined from github as well as a set of swagger specifications section v a .
for the evaluation we are interested in two research questions authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
rq1 given javascript code describing a web api request to what degree can the analysis correctly determine whether the request is consistent with an endpoint in given swagger specifications?
see section v b rq2 for a request consistent with an endpoint in the swagger specifications to what degree can the analysis correctly determine whether the request data the payload and the query parameters is consistent with specifications?
see section v c and section v d for both of these questions we first determined quantitatively how consistent were the information extracted from the static analysis compared to swagger specifications.
to obtain this quantitative information we count positive matches as well as errors reported from our checking procedure.
for the set of requests that does not match endpoints or request data requirements of a specification we determined if each of the inconsistent instances was legitimate or due to deficiencies in the approach.
to ascertain the cause of each of these inconsistencies we performed a qualitative analysis.
for example the analysis determined that the endpoint is inconsistent with the swagger specification of the instagram api because the specification does not contain a subscriptions path.
the qualitative analysis determined that this particular path was deprecated from instagram s api.
with the result of the qualitative analysis we tabulated the number of instances where the approach correctly identifies endpoints and request data as consistent or inconsistent.
a. data collection the evaluation requires two types of input data first we obtained web api specifications to compare against information produced by the static analysis using the checking procedure.
second we mined javascript source code that likely contains requests to the apis for which we have specifications.
api specifications from apis guru for the swagger specifications we made use of a community maintained collection of specifications from the apis guru repository .
the repository contains specifications either provided by api providers or third parties or generated using dedicated scripts.
at the time of performing the experiments we collected specifications which pertain to apis with some apis having specifications for multiple versions .
these specifications act as a source of ground truth to indicate whether requests in the source code invoke the api correctly.
we discuss threats to this ground truth in section vii.
javascript files from github to increase the generalizability of the results we aimed to collect a large set of javascript files containing web api calls.
we obtained such a set by querying github using its search capabilities.4each search query targets the domain name of an available swagger specification from apis guru and javascript instances that send requests using the jquery function .ajax though handle additional ways to make requests i.e.
.post and get .
we thus used the search queries of the form extension js .ajax domainname .
to automate the data collection we used selenium to invoke the github code search and crawled the search result to obtain links to javascript files.
the files returned by the search may not necessarily contain requests to the target domain.
for example the domain name may be in a comment and the script still matches the search criteria.
from these queries we obtained javascript files from which we extracted web api requests.
for this evaluation we focused on the requests that matched a specification i.e.
a request url matching the base url of a specification including matching the schemes domain and the basepath .
we removed the remaining requests from our evaluation with of the requests were safe to remove these requests neither contained web api calls 5nor were the requests the github search intended to target i.e.
requests that did not match the domain of any of the evaluated apis .
the remaining requests corresponded to urls that could not be resolved by our static analysis e.g.
containing symbolic values in the base url.
some of the symbolic values were global variables that could have been resolved if the analysis scope were expanded beyond the file level while other symbolic values were not typically possible to be resolved by static analysis e.g.
values provided to the application at run time by a user or a configuration file .
the strength of our approach is that our analysis does not raise a false alarm on these cases.
b. endpoint results for rq1 the goal was to determine what percentage of the request endpoint urls extracted from code was correctly flagged as consistent or inconsistent with the swagger specifications i.e.
the precision of the approach.
the javascript files obtained from github as described in section v a contained requests in which the endpoint of a url matched one of the swagger specifications i.e.
matches the base url including matching the defined schemes http orhttps domain and the basepath.
overall we found the precision of matching the endpoints of requests to be .
which was tabulated from requests that were flagged consistent and were actually consistent requests in the upper left cell in figure 7a and requests that were flagged inconsistent and were actually inconsistent requests in figure 7a .
in addition to matching the base url in a swagger specification a request is a valid endpoint when it satisfies two conditions the url matches an endpoint path which can contain path variables e.g.
repos owner repo and the http method matches e.g.
get .
5of the requests requests contained urls targeting internal endpoints including relative urls localhosts ip addresses not web apis requests only contained empty strings null values or numeric values and182 requests contained urls matching the domain but not the base path likely to be targeting static web pages or data.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g31 g32 g33 g34 g34 g35 g31 g34 g36 g37 g38 g38 g39 g38 g40 g41 g38 g39 g37 g40 g42 g31 g42 g31 g43 g35 g43 g35 g37 g40 g38 g38 g37 g38 g40 g39 g38 g37 g38 g40 g38 g41 g40 g44 g44 g45 fig.
distribution of the extracted endpoint invocations for the requests that did not match to a valid endpoint and the flagged as inconsistent row in figure 7a we qualitatively determined if the static analysis checker correctly identified a legitimate inconsistency or not.
we found that a significant fraction of these requests were true negatives due to errors in the actual urls from the javascript code .
and incomplete missing or erroneous swagger specifications .
together pertaining to requests in figure 7a .
the remaining requests were false positives in figure 7a due to deficiencies in the static analysis .
and in the checking procedure .
.
for the rest of section v b we present the qualitative analysis of the results on these true negatives and false positives.
endpoint results true negatives requests that were correctly flagged as inconsistent fall into two categories definite or potential errors in the code and erroneous and incomplete specifications.
for the first category we found that requests contained an erroneous url from the javascript code that we correctly flagged as inconsistent accounting for .
of the requests figure 7b .
of the requests 23were attributed to deprecated calls and programming errors that were definitely erroneous deprecated apis 16requests were inconsistent because a url corresponded to a call to an api that were deprecated entirely or calls to subset of an api that happened to be deprecated.
for example the request to bob dylan was to the google s freebase internet marketing api which has been deprecated since june .
documented programming errors in two cases we found evidence e.g.
in the form of a question posted on a forum that the urls in the code were erroneously because of errors in interpreting api documentation.
typographical errors in five cases the requests contained obvious typographical errors.
for example did not match the endpoint search in the swagger specification of the spotify api because of the typographical error in seach .
in another case the checker reported that the extracted url string playlists playlistid tracks a string that looked like a syntax error because of the absence of quotes surrounding playlists did not match any endpoints in the spotify api even though there was an endpoint userid play lists playlistid tracks in the spotify s swagger specification.
one could argue that the checker flagging this case as a mismatch was a mistake because at runtime playlists without the quotes actually evaluates to the string playlists as playlists is interpreted as a regular expression.
however we argue that marking this case as a mismatch is legitimate because it is likely that the author of the code intended to include the quotes playlist but this potential error was not caught by the javascript interpreter nor testing.
in addition we found requests with potential errors http method i n cases the url was using the wrong http method e.g.
using get instead of post as specified in a swagger specification.
of these cases were get requests to info that should be post according to the swagger specification and online api documentation even though the server accepts the get call.
we categorized these cases as potential errors because even when an api provider may accept such calls it is still worth while to warn a programmer that the call is not consistent with the definition of the api.
port number we observed four requests in which a url contained port numbers.
these cases may be problematic because port numbers are seldom in any publicly advertised base urls.
for the four cases involving port numbers one could argue that it was worth issuing a warning to a programmer because port numbers are unlikely to be in a legitimate base url.
with the static checker that could flag that a url in the requests were consistent with a basepath but not any of an endpoint a programmer authoring code containing these cases could potentially made aware of these bugs.
for the second category of the true negatives we found how to get user email from google plus oauth authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that requests or .
figure 7b corresponded to invocations that were not matched with any endpoint of the corresponding swagger specifications.
from a manual inspection on the documentation on the api being invoked in the requests we found that the mismatch was due to erroneous and incomplete swagger specifications errors in swagger specifications we determined that cases due to errors in the swagger specifications.
these erroneous requests were because a base path had been refactored to include a version number e.g.
the .
path segment in send.json but the swagger specification was not updated.
missing endpoints in swagger specifications f o r requests in which a url found by the static analysis and verified by us as valid calls a corresponding endpoint definition with the assumed path was missing from the swagger specifications.
these requests corresponded to endpoints across four apis reactome slack trello and google apis.
missing authorization urls in swagger specifications eight urls relate to endpoints for authentication purposes e.g.
and .a complete swagger specification should include such necessary authentication urls.
however in these cases those authentication urls were missing in the specifications.
as it turned out the requests flagged by the checker as inconsistent with the swagger specification were actual errors in the swagger specification.
upon informing apis guru of these errors we learned that these specifications were already corrected.8this scenario demonstrates a potential use case for using the checker on a large repository of api usage for identifying missing or erroneous information on a given set of swagger specifications.
endpoint results false positives there were two sources of mistakingly flagging a request to be a mismatch deficiencies in the static analysis and deficiencies in the checking procedure.
for the first source of errors we found that only five out of the cases were due limitations in the static analysis which is surprising given the challenges in analyzing javascript and that the analysis scope was within a file.
there were two types of deficiencies limitation of the analysis scope in three cases because the analysis scope was within a file the analysis failed to construct a valid url because the code contains variables or function calls defined outside the file.
html handling string library functions in two cases the requests used the library function split .
in the static analysis we explicitly model other more common string operations i.e.
string concatenations and encodeuri a s we described in section iii.
currently handling a more complete set of string library functions with symbolic values is an active research topic .
we could leverage such research and model more string operators in the future.
the few deficiencies caused by the static analysis show that our technique and the chosen analysis scope are feasible for the problem of extracting requests.
due to deficiencies of the checking procedure our approach mistakenly determined that requests were inconsistent with swagger specifications.
there are two main causes of these mistakes conservative matching we designed to checker be confident in flagging requests as consistent with the swagger at the risk of flagging legitimate urls as potentially inconsistent.
in consequence we found requests that the procedure mistakenly flagged as inconsistent with any of the swagger specifications.
for example the code page.config.baseurl tags term media recent?client id page.config.clientid should have matched the endpoint tags tag media recent .
however the checking procedure requires that the variable is constrained to a single path segment i.e.
characters without a in it.
missing authorization urls in five cases the requests were for authorization.
these urls are defined in a swagger file but the checker does not currently check for such urls.
overall using the checker for determining whether an invocation of an web api endpoint corresponds to a valid one in a swagger specification yielded a promising result with .
of the endpoint invocations correctly flagged as consistent or inconsistent with the swagger specifications.
c. payload data results for rq2 we focused on how well the analysis correctly determines whether the request data is consistent with web api specifications.
we present the results for the payload data in this section v c and query data in section v d. to assess the approach s ability to check for correct payload data we first determine how many of the requests for which we can match an endpoint have a payload schema definition in any of the corresponding api specifications.
we only consider requests for which the payload definition is mandatory i.e.
if the request matches multiple specifications or multiple endpoints as described in section iv they all need to denote a payload definition.
we found that overall requests have a mandatory payload definition see figure 8a .
out of these cases we found that requests contained data extracted from the static analysis that adheres to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g31 g32 g33 g34 g35 g33 g36 g31 g37 g36 g36 g36 g31 g37 g36 g36 g36 g35 g33 g36 g38 g36 g33 g34 g35 g33 g36 g37 g36 g36 g36 g39 g31 g31 g31 g31 g31 g40 g31 fig.
rq2 results for payload a and query data b the required payload.
of the 18payloads that did not adhere to any of the specifications we qualitatively ascertained whether the approach correctly determined the mismatches i.e.
true negatives which correspond to in figure 8a or not i.e.
false positives which correspond to .
tabulating the matched cases with the true negatives yields a precision of .
.
payload data results true negatives the single true negative case is caused by an error in the code while the analysis reports a required data property to be sent in a query parameter the specification requires it to be sent in the payload body.
payload data results false positives the17false positive cases are explained by deficiencies in the static analysis.
in 13cases the static analysis does actually report data that upon manual inspection does match with the data schema in the specification.
however in these cases the data is present as a json encoded string in the request source code rather than a json object so our checking procedure fails to correctly match it.
in four other cases the analysis reports a variable to be replaced by a global json string which cannot be resolved statically.
d. query parameter results regarding the query parameters we first determined how many of the requests for which we could match an endpoint have query parameters defined in the api specifications.
like in the case of the payload data we only considered requests that match an endpoint that has a mandatory query parameter definition of which we found .
figure 8b presents the breakdown of these requests.
we found that of the requests complied with their corresponding query parameter definitions.
we qualitatively analyzed the cases in which our approach reported a mismatch of which 39weretrue negatives and were false positives .
the precision is .
taking into account the matches and the true negatives .
query parameter results true negatives the cases in which our approach correctly detects an inconsistency between source code and specification fall into two categories errors in the specification cases concern get requests to the .. repos owner repo contributors path of the github api.
according to the api specification a query parameter anon is required to indicate whether to list anonymous contributors.
invoking this endpoint test wise reveals that requests also succeed without that parameter in the request pointing to an error in the specification.
errors in the code w efi n d cases where required data is sent in the wrong place.
in cases get requests to the .. artists id top tracks path of the spotify api miss a country query parameter which is required according to the api s specification and online documentation.
interestingly though all11 requests send a country data property in their payload body.
similar cases can be observed for five get requests to the .. artists path and two get requests to the .. me following contains and .. me tracks contains paths where again required query parameters are sent in the payload body instead.
similarly in four post requests to the instagram api oneget request to the slack api and one get request to the buffer api query parameters which are required based on the specification are sent in the payload body instead.
query parameter results false positives we observe two cases where the static analysis misses to report an inconsistency because the extracted urls end with a variable.
the variable spans across parts of the endpoint path and possibly the query parameters.
thus in this cases the analysis fails to report required query parameters.
overall out of the 39reported query parameter mismatches 15cases are explained by errors in the specification required parameters are actually not necessary for a successful request.
in24 cases query parameters that are required according to the specification are sent in the payload body of the request instead which is in most of these cases in conflict with both the api specification and online documentation.
only in two cases do we find mismatches due to our approach s failure to report needed information.
vi.
r ela ted work our work on checking javascript code with respect to web api specifications is similar in spirit to a range of work on checking and bug finding approaches such as typescript authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and jshint respectively.
due to the dynamic nature of javascript and the extreme difficulty of providing precise analysis such languages and tools tend to be lenient rather than attempting to be complete they work by partially enforcing type rules or using a set of patterns that can be tuned to provide some level of feedback without overwhelming their users with a large number of false reports.
our work shares that approach our analysis is biased to only report issues that are fairly likely to be real.
however our approach differs from other bug finding tools for javascript by being based on interprocedural static analysis and relying on traditional techniques such as inter procedural slicing and string analysis.
halfond et al.
introduce static analysis techniques for understanding web api usage in java applications .
one technique focuses on how apis are used in html code that is dynamically generated as part of a java web application .
the work focuses on first approximating the html and then extracting invocations from it.
this approach works well when the logic creating the request is on the server side it does not target api calls generated in javascript on the client side which is our focus.
other work introduces symbolic execution to improve results once again focusing on java web application .
in the context of javascript related work has shown that understanding api specifications can make dynamic testing more effective .
in contrast to this work we focus on static analysis rather than on dynamic testing.
our work also relates to checking javascript function calls.
safe w api analyzes javascript and checks function calls against the web idl specifications of those functions.
safe wapp models the web application execution environment e.g.
dom and checks function invocations against ecmascript rules.
in comparison we check web api requests which is not a language construct in javascript.
in addition resolving the targets endpoints and parameters requires string analysis.
multiple works have been proposed to check web apis for compliance with best practices .
these works currently take as input observed web api requests or human readable documentations but could be adapted to work on top of api specifications.
in contrast to checking specifications we here propose to check the adherence of source code with given specifications.
vii.
t hrea ts to validity by considering the url http method and request data our approach covers important parts that determine whether a request contains any errors or not.
however our approach currently does not examine request headers which can for example contain authentication information that affects the validity of a request.
despite this limitation our approach is still a valuable first step towards a wider coverage of errors on web api requests.
a threat to validity of our evaluation is in the way we retrieved source code from github see section v a .
our data collection relies on the code search facilities provided bygithub.9github only provides limited insights into the search algorithm for example that characters like .
or will be ignored and that only small repositories less than kb and less than files are indexed.
the api specifications we used in our experiments may contain errors similar to any other type of documentation.
however we consider apis guru to be one of the most reliable sources of api specifications.
they have a policy in place to validate specifications that are not updated within hours.
in addition apis guru reports the origin of specifications which typically stem from api providers or the developer community .
finally a threat to the validity of our experiments is that we manually analyze the errors reported by our checking method.
we performed this analysis to shine a light on the sources of errors and took care to cross validate among multiple sources as much as possible.
viii.
c onclusion in this paper we have leveraged existing research in static analysis scalable to framework based javascript web applications and created an analysis capable of extracting strings pertaining to web apis requests.
we used these extracted request data as input to a checker that determines whether the requests are consistent or inconsistent with formal web api specifications.
a qualitative analysis of the results from our checker on requests shows that most of reported inconsistencies were due to errors in the client code calls to deprecated apis errors in the urls errors in data payload definitions and incomplete swagger specifications as opposed false positives.
quantitatively we found that the approach can correctly determine whether a request is consistent or inconsistent with web api specification with a high precision of96.
for endpoint checking .
for payload data checking and .
for query parameter checking.
these results point to the promise in creating tools that are capable of warning programmers of source code containing inconsistent web api requests that can be potentially erroneous.
as such this approach can be integrated with existing tools that support developers in using web apis .
our proposed checker can also be employed with continuous integration for checking the validity of web api usage in case a web api undergoes changes.
furthermore our work can lead to tools to help api providers to monitor usages of their apis in publicly available code or integrate with third parties change monitoring sites such as api changelog.11as for future work on the checker itself we aim to extend the scope of our static checking method to consider additional aspects of web api requests like header information http response codes or the structure of returned data.
in addition based on the positive results with jquery we want to extend our implementation to handle other web frameworks.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.