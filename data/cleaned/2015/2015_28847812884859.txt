type aware concolic testing of javascript programs monika dhok indian institute of science monika.dhok csa.iisc.ernet.inmurali krishna ramanathan indian institute of science muralikrishna csa.iisc.ernet.innishant sinha ibm research india nishant.sinha in.ibm.com abstract conventional concolic testing has been used to provide high coverage of paths in statically typed languages.
while it has alsobeenappliedinthecontextofjavascript js programs we observe that applying concolic testing to dynamicallytyped js programs involves tackling unique problems to ensure scalability.
in particular a naive type agnostic extension of concolic testing to js programs causes generation of large number of inputs.
consequently many executions operate on undefinedvalues and repeatedly explore same paths resulting in redundant tests thus diminishing the scalability of testing drastically.
inthis paper we address this problem by proposinga simpleyeteffective approach that incorporates type awareness intelligently in conventional concolic testing to reduce the number of generated inputs for js programs.
we extend our approach inter procedurally by generating preconditions for each function that provide a summary of the relation between the variable types and paths.
employing the function preconditions when testing reduces the number of inputs generated even further.
we implement our ideas and validate it on a number of open source js programs and libraries .
for a significant percentage on average of the functions we observe thattype aware concolic testing generates a minuscule percentage less than of the inputs as compared to conventional concolic testing approach implemented on top of jalangi .
on average this approach achieves over of line coverage and over of branch coverage for all the functions across all benchmarks.
moreover the use of function preconditions reduces the number of inputs generated by .
we also demonstrate the use of function preconditions in automatically avoiding realcrashes due to incorrectly typed objects.
ccs concepts software and its engineering software testing and debugging software reliability keywords dynamic analysis javascript testing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c circlecopyrt2016 acm.
isbn .
.
.
.
introduction dynamic typing in javascript js enables modifications to the object properties during runtime and helps reduce development time .
however the lack of compile time warnings increases the possibility of dormant bugs resulting in many type errors in the field .
hence effective testing frameworks are essential to reduce the maintenance cost for js based applications .
these approaches are targeted towards testing various facets of js applications event driven and string intensive web applications can employ symjs security vulnerabilities can be detected using kudzu web specific features pertaining to manipulation of domandajaxcan be tested using artemis etc.
unfortunately there is limited support to generate high coverage test cases for purejs programs e.g.
nodejs programs where input types are complex objects instead of events or strings.
in practice for programs based on statically typed languages concolic testing helps achieve high coverage.
broadly this involves a combination of concrete and symbolic execution which generates a collection of symbolic constraints on execution paths .
different paths in a program are covered by negating collected branch constraints appropriately and solving the resultant collection.
when constraints cannot be solved symbolically concrete values are provided to ensure completion of the process.
the approach is designed to avoidredundant exploration of paths.
when conventional concolic testing is applied to js as in we observe that twokinds of constraints are generated.
constraints that correspond to program branch conditions labeled branch constraints e.g.
z these constraints may be flipped to execute hitherto unexplored paths.
constraints that restrict variable types are calledtype constraints e.g.
typeof z number .
testing differentcombinationsofbranchconstraintshelpexploredifferent paths in the program.
in contrast type constraints ensure that the variables are well typed which in turn provides the basis for assigning correct values to them.
when applying concolic testing to js we encounter an unexpected stumbling block to scalability highly redundant input generation.
redundant inputs are inputs that do not achieve new code coverage with respect to existing tests.
we observe that many of these tests predominantly contain variables that have not been assigned any value.
such variables are recognized as undefined in js.
if undefinedness is expected explicitly execution of a program in the presence of undefined values can help achieve more coverage.
otherwise thisleadstogeneration ofinputswhichareafeworders of magnitude more than the actual number of normally ter2016 ieee acm 38th ieee international conference on software engineering minating paths.1this is mainly because a large number of type constraints along with branch constraints are created.
treating the branch and type constraints equivalently causes this redundancy.
the problem is further exacerbated for inter procedural testing.
in this paper we address the problem of generating redundant inputs while performing concolic testing of js programs.
we propose a simple yeteffective approach that incorporates type awareness to minimize the generation of redundant inputs by distinguishing branch and type constraints.
in particular our approach groups the type constraints together and infer the types for all the relevant variables in a single attempt without trying all possible type assignments.
branch constraints are handled as usual by exploring all paths based on all combinations of branches.
we extend our approach to handle inter procedural js programs in a scalable manner.
we achieve this by deriving type preconditions for each function fsuch that each precondition summarizes the correct types of input parameters inf.
creating call graphs for js programs is non trivial due to its dynamic nature .
therefore we use a combination of top down testing and memoization to create call graphs incrementally.
more specifically when concolic testing is performed on a function fwhich invokes a function gwhose precondition is unavailable then the precondition gforg is derived on demand.
then gis utilized during analysis forfto restrict the type of variables in f. thiscompositionof the function preconditions allow us avoid redundant execution failures inside nested function calls.
wehaveimplementedourapproachon jalangi adynamic analysis framework and incorporated our design for two variants of concolic testing depth first and breadthfirst .
evaluation on multiple open source js programs and libraries reveal that for a majority of the tested functions our approach generates only5 of the inputs generated by the conventional concolic testing in .
employingpreconditionsduringinter proceduraltestingreducesthe number of inputs by across multiple benchmarks.
wealsoimplementaclientanalysis toavoidcrashes dueto type related failures in js.
our analysis monitors the types and values of parameters for different method invocations.
if we detect the absence of any property field function etc with the help of the derived function precondition we automatically insert a dummy property and record the problem.
this helps in ensuring that the programs do not crash during runtime.
we demonstrate the efficacy of the analysis by applying it on known real issues.
the paper makes the following technical contributions we propose a simple yet effective approach that incorporates type awareness to scale concolic testing for js programs.
we implement two variants of type aware testing algorithm depth first and breadth first .
we extend the approach to handle testing interprocedurally by deriving and composing function preconditions incrementally.
we validate the scalability of our approach by applying it on multiple open source js programs and libraries and compare with conventional concolic testing implemented onjalangi .
1we consider paths that do not trigger runtime exception in a function as normally terminating paths.
.
motiv ation in this section we motivate the need for our approach by usingareal example from hapi v8.
.
apopular library with 99k downloads in the month of july that provides a rich framework for building js applications and services.
it is also under active development with commits releases and contributors.
figure presents a simplified implementation of two functions marshal and streamify fromresponse.js in the library.
thenumberofintra proceduralcontrolflowpathsare and respectively.2the function marshal takes one parameter invokes streamify conditionally depending upon the presence of the field processors in the invoking object which should not contain the property marshal lines .
meanwhile the function streamify checks the type of the first parameter and considers the fields present in the passed object to perform various operations lines .
overall an invocation of marshal on a malformed object can result in a failure at any one of lines and in the presented code.
o1.
marshal function next var self this if !this.
processors.marshal return this.
streamify this.source next this.
processors.marshal this function err source ... o1.
streamify function source next if source instanceof stream var stream source.socket source if stream.
readablestate.objectmode return next boom.badimplementation error this.
payload source return next ... figure motivating example.
initially when concolic testing is applied to marshal the receiver this does not have field processors causing a crash at line .
this results in the inference that it has a field processors which can be dereferenced and added appropriately.
when re executed the absence of marshal in processors results in the invocation of streamify at line .
the check at line will fail because the receiver does not havesource.
consequently a new input is generated where the receiver has sourcewhich is an instance of stream.
the absence of socketinsourcecausesthis.source to be assigned to streamat line .
then the execution crashes also referred to as exceptions again at line due to the absence of readablestate .
with a re execution where this.source has readablestate the absence of objectmoderesults in condition at line to be false and execution of lines and .
this completes the execution of an entire path.
the inference due to the execution will cause objectmodeto be added as a field default value is zero causing lines and to be re executed.
the value of objectmode is made non zero to cover the other branch.
2line is treated as a conditional.
169there are two problems even when an execution completes e.g.
return at line and is free of crashes.
firstly all objects are not well formed e.g.
this.source.socket andthis.
processors.marshal are undefined .
secondly these undefined variables can introduce redundancy to the entire process.
more specifically when the approach backtracks to fix the undefined this.source.socket at line and assigns a zero to it the constraints pertaining to readablestate andobjectmode due to line are eliminated.
also the assignment leads the execution along the previously explored path.
this causes the re executions torepeatpreviously seen crashes and inferences at line albeit with this.source.socket .
similarly when this.
processors.marshal is fixed the redundancy is furthermagnified due to repetition of previously seen crashes and inferences in streamify at lines and albeit withthis.
processors.marshal .
in summary the problems with existing concolic testing for js are execution of program in the presence of undefined variables does not help achieve more coverage unless undefinednessis expectedexplicitlyin aconditional orthevariable type cannot be inferred.
defining the undefined variables incrementally results in repeated exploration of the same paths.
the redundancy is magnified for inter procedural testing.
when we test marshal in conjunction with streamify concolic testing generated more than inputs in hour.
a variant of the testing which employs a depth first version to explore paths implemented in jalangi generates inputs.
this difference in the number of generated tests is mainly because of the way branches are explored.
in contrast we design an approach based on type aware concolic testing which generates only8 inputs without loss of coverage.
these inputs are also sufficient to generate effective type preconditions for the tested functions.
there are multiple benefits that accrue due to function preconditions.
apart from their use in interprocedural testing these can help avoid potential crashes due to invocations with malformed objects.
for example the derived function precondition of streamify specifies thatthis.source.
readablestate should be present when this.source is an instance of streamto avoid the crash at line .
this need not always be followed e.g.
see issue inhapi .
the derived preconditions can be used to monitor the type of this.source and readablestate can be inserted whenever absent during an invocation to avoid potential runtime crashes .
.
design we now present the design of type aware concolic testing of js programs.
initially we present the definitions in section .
that are used in the rest of the section.
we explain the extension of conventional concolic testing to js using algorithm which uses a algorithm and to add constraints on the execution stack and b algorithm to flip the constraints on the stack for new input generation .
in section .
we explain type aware intra procedural concolic testing.
we design a modified flip procedure algorithm to resolve type and path constraints separately.
subsequently we discuss type aware inter procedural testing procedure in algorithm .
.
preliminaries for ease of presentation we consider a subset of js jslite over the following grammar ap accesspath v v.f e expr ap callap uop e1 e1bop e2 s stmt v e if e gotol where v var bop ... uop !
... access paths include variables v and one level dereferences to the variables v.f .
an access path v.f.gcan be represented as a composition of multiple access paths.
the variables are from a set of symbolic variables var .
expressions include the access paths invocations of functions expressions involving unary uop and binary bop operations.
statements correspond to assignments or conditional branches.
we maintain the state as a five element tuple an bracketle t t c s stack an bracketri ht where is the function name tmaps variables to concrete type values candsmap variables to concrete and symbolic values respectively and stack maintains an ordered list of constraints.
we consider the following concrete types in the language number string object function null undefined .
.
concolic testing of javascript algorithm runconcolic input t c s stack stackpos while i nextinstruction exception halt do switch ido case ap e ap eval ap s e eval e s addc e t stack addc ap t stack update ap e t c s case if b then goto l addtc b t stack if eval b c thenc eval b s elsec neg eval b s if stackpos stack.length then stack.push constraint c isbranch flipped increment stackpos by one if stack.length then flip stack t c s solve stack runconcolic an bracketle t t c s stack an bracketri ht the procedure runconcolic in algorithm presents concolic testing algorithm for js.
it takes as input a fivetuple state where t candsare initialized to value undefined for all access paths and the stack is empty.
in runconcolic nextinstruction executes the instructions in the function until it encounters a haltinstruction or a crash due to an exception .
we describe runconcolic for the intra procedural case where we ignore all the other function invocations inside that procedure.
the return values of this function is considered as seed input for better coverage.
runconcolic makes use of two standard auxiliary functionsevalandupdatefor expression evaluation and heap update respectively whose descriptions we omit for brevity.
given a program term tand a mapping from access paths to values eval t evaluates the term tin to a value.
if is concrete i.e.
contains only constant values then eval 170returns a constant value else a symbolic term is returned.
theupdate l v t c s updates the heap reference corresponding to expression lwith the value of expression vin bothcandsand also the concrete type of lint.
to evaluate expressions in assignments line runconcoliccreatestypeconstraints to make sure that expressions are well typed using addc algorithm .
addcderives the type of a given expression eas either object line function lines or the operator type lines and computes a type constraint c using the uninterpreted functionty.
based on the current concrete type of expression e computed using the map t theaddtc algorithm adds either corneg c lines to the stack.
it also records that the constraint is not a branch constraint.
we write type constraints of form ty x numasx num.
algorithm addc input expression e concrete type map t stackstack switch edo recursively case v.f addtc t v ne ationslash object ty v ne ationslash object stack case callap addtc t ap ne ationslash function ty ap ne ationslash function stack case uope1 uopis unary operator t getoperandtype uop addtc t e1 ne ationslash t ty e1 ne ationslash t stack case e1bope2 bopis binary operator handled similar to unary operators algorithm addtc input boolean value b constraint c stack stack if stackpos stack.length then if b thenc neg c stack.push constraint c isbranch flipped increment stackpos by one for the conditional statement in algorithm at line it evaluates the condition bin concrete value map cand depending upon the result it adds a branchconstraint c corresponding to bevaluated in symbolic map s to the stack using lines12 .
ifthecurrentstackpointeris notbeyond the top of the stack then the constraint already exists in the stack applicable for subsequent runs of the algorithm and need not be added.
otherwise the constraint cis pushed on the stack along with the annotation flipped which tracks whether chas been flipped or not.
we also add an annotation denoting cis a branch constraint.
after collecting all the constraints algorithm calls flip procedure at line .
this procedure is used to flip i.e.
negate the constraint on the top of the stack to explore a new path.
this procedure algorithm describes the conventional flipping procedure first it pops out all constraints that are already flipped from the stack.
then the unflipped constraint at the top of the stack is negated.
the constraints remaining on the stack are solved using a constraint solver the function solve at line .
this results in updated concrete maps t andc runconcolic is invoked on the state consisting of the updated maps and the stack.
algorithm flip input stack stack while e stack.top e.flipped dostack.pop if stack.length then e.constraint neg e.constraint e.flipped 1idi p x y z o constraints x ne ationslash n y ne ationslash n z ne ationslash n x ne ationslash n y ne ationslash n z n z ne ationslash x ne ationslash n y ne ationslash n z n z o ne ationslash o x ne ationslash n y ne ationslash n z n z o o o.bar ne ationslash f x ne ationslash n y ne ationslash n z n z o o o.bar f x ne ationslash n y n z ne ationslash n x ne ationslash n y n z n z ne ationslash x ne ationslash n y n z n z o ne ationslash o x ne ationslash n y n z n z o o o.bar ne ationslash f x ne ationslash n y n z n z o o o.bar f x n y ne ationslash n z ne ationslash n x n y ne ationslash n z n z ne ationslash ... ... ... table inputs and constraints for the example.
.
.
redundant input generation algorithm does not differentiate between a type constraint and a branch constraint.
however in the context of dynamically typed js programs this results in the generation of a large number of redundant inputs thus drastically diminishing the scalability of the testing algorithm.
we demonstrate the drawback using the following example function foo x y z o var d x y if z o.bar d there are four inputs to function fooand applying algorithm1generates more than20inputstocoverthe twopaths in the function.
table presents the inputs generated and the constraints generated for the corresponding execution.
for ease of presentation the stack is shown as a sequence.
initially all inputs are undefined .
here we refer to types number object and function by n o and f respectively.
when the first input is executed the assignment d x yis considered at line of algorithm .
applying addcon the rhs results in addition of the type constraints x ne ationslash num andy ne ationslash num.
subsequently when z is evaluated the constraint z ne ationslash numis also added and because zis undefined currently the conditional in foois not satisfied and the execution terminates.
a state is added to the precondition and because the stack length is greater than currently the constraint at the top of the stack is flipped.
this causes z ne ationslash numbeing negated and the constraints on the stack are solved using solveat line .
consequently the input is generated to satisfy the constraints and runconcolic is invoked at line .
the remaining rows in the table are computed similarly.
for the constraints generated due to execution of foowith the fifth input the last four constraints are removed from the sequence as their corresponding negations are already solved inputs and respectively .
the resultant last constraint y ne ationslash numis negated to generate the sixth input.interestingly not only does it lose the knowledge on inferred types of z oando.barbeingnumber objectand function respectively but also the generated constraints do not expose any new fact.
the exploration repeatsup to the tenth input without exploring a newer execution path.
the process repeats all over again for x .
not differentiating the type and branch constraints results in this unnecessary generation of inputs.
.
type aware concolic testing we address this fundamental drawback by proposing an approach that differentiates between the branch and type x ne ationslash n x ny ne ationslash nz ne ationslash n y nz nz ne ationslash 1o.bar ne ationslash f bar x ny no ne ationslash o z z nz z n x ny no oo.bar f o o x ny nz nz a merged stackmerged stackz nz ne ationslash 1x ny n z nz ne ationslash 1x ny no ne ationslash o z ne ationslash nz 1o o y n x n z ne ationslash z n z ne ationslash n z nz ne ationslash bar o.bar f o o y n z z n z nz 1x ny no o x no.bar f b figure inputs and constraints for the illustrative example constraints.
this is achieved by flipping the set of type constraints simultaneously.
for this purpose we propose a modified version of the flipping algorithm in algorithm that can be used instead of algorithm .
algorithm flip2 input stack stack while e stack.top e.flipped dostack.pop if stack.length e.isbranch then e.flipped e.constraint neg e.constraint else pos stack.length while pos stack .isbranch do c stack c.flipped c.constraint neg c.constraint pos pos initially flip2eliminates all constraints that are already flipped line .
subsequently if it finds a branch constraint at the top of the stack it negates the constraint and returns lines .
this is because of the invariant that all the type constraints beneath the branch constraint are already flipped.
otherwise it identifies all the non branch constraints using is branch negates themandmarks themas flipped lines .
when algorithm is executed after this the type constraints that are seen previously are guaranteed to be flipped and hence need not be solved incrementally.
figure?
?fig intra presents the inputs and constraints generated by incorporating the new flip2algorithm in runconcolic at line .
the first input and the associated constraints are similar to the existing concolic testing algorithm.
however unlike the previous algorithm we flip the type constraints simultaneously and solve them.
this results in the types of x yandzto benumand a default value of is assigned to them resulting in the second input.
when executed the condition z is not satisfied and a branch constraint is added accordingly.
subsequently the constraint at the top of the stack is flipped and the third input is constructed with zequals .
this results in a crash due to a dereference of oas it is still undefined.
the dereference causes it to be considered as an object resulting in the generation of theconstraint and consequently thefourth input.
the example demonstrates that solving the type constraints simultaneously ensures significant reduction in the number of inputs generated and is closer to the number of normally terminatingpathsintheprogram.
ourapproachis able to completely cover all the paths with just five inputs as compared to more than inputs by existing concolic testing.
by applying this technique we avoid generation of the same pattern of malformed inputs by fixing the inputs after the execution crashes.
executingthe program with the fixedinput avoids the crash at the same point.
for instance in table for inputs and program crashes at the same pointrepeatedly.
however input doesn t add any additional information.
as shown in figure ?
?fig intra our approach exposes the crash oncewith input reducing the redundancy.
.
.
differentiating branch and type constraints our algorithm relies on how we carefully define and distinguish between branch and type constraints.
branch constraints correspond directlyto the branch condition expression type constraints are implicitly generated at multiple places including assignment call and branch statements.
for example the statement if x generates a type constraint x num and a branch constraint x .
this distinction between the constraints allows us to apply our type aware exploration to programs where the branch constraint may restrict the type of the variable but is not collated with the type constraints.
if typeof x number ... else if typeof x string ... in the above code we treat the constraints generated on xas branch constraints.
thus we can explore both paths without losing coverage.
otherwise if these are considered as type constraints then flipping them together and solving will lead to an infeasible execution and hence loss of coverage.
note that for buggy programs a programmer may erroneously assume inconsistent types for a variable xalong some path of execution p. in such cases we detect that type constraints are unsatisfiable together on pand abort testing.
.
inter procedural testing extending runconcolic algorithm to an interprocedural setting involves a number of challenges to avoid path explosion.
for example if a function f callsfin the program under test the inputs to fmay be undefined or ill typed causing the execution to crash in f. to handle the crashes we need to call fwith well typed values after detecting each abort.
repeating this exercise for each call tofand execution path inside fcan lead to a severe blowup in the number of input tests generated thus diminishing the scalability.
we propose to address this problem by generating input preconditions forfduring testing.
we use these preconditions to avoid invoking fwith ill typed values.
function preconditions are generated during the process of performing concolic testing of a function .
it is achieved by updating runconcolic algorithm between lines and with following.
if i halt stack 172in other words when an execution halts in we add the stack from the termination state to the set of preconditions for .
the preconditions generated for the method foo fromtheillustrativeexampleisshownintable2 constraints are represented as a comma separated list .
it has two entries that corresponds to the two normally executing execution paths due to condition z .
each precondition contains the relevant type constraints as well as branch constraints on inputs of foo.
because the number of preconditions may be quite large in worst case equals the numberof paths executed in we represent the set compactly using atriedata structure ordered by formal parameter names for efficient lookup and reuse see below .
id precondition 1x n y n z ne ationslash 2x n y n z o o o.bar f table preconditions of foo.
.
.
employing function preconditions algorithm shows how to handle function call statements call ap in algorithm by using previously generated preconditions.
here let apevaluate to a callee function and as before the caller function is .
algorithm call input caller callee t c s stack ifall type constraints in stack are not flipped then foreach unflipped type constraint cinstackdo c.constraint neg c.constraint c.flipped solve stack runconcolic abort if does not exist then formal parameters of t c undefined p s p p runconcolic an bracketle t t c s an bracketri ht an bracketle t t c s stack an bracketri ht for each in do unify doabort false if ne ationslash then doabort true stack stack foreachcin doc.flipped stack .push c t c s solve stack runconcolic an bracketle t t c s stack an bracketri ht ifdoabort then abort the procedure first flips all type constraints on the stack before calling and re run runconcolic lines in algorithm while aborting the current execution.
this ensures that the variables passed to are restricted by the types in the current execution prefix.
to avoid exploring redundant inputs callfirst computes lines the preconditions for if it doesn t exist and then reuse one or more precondition entries of lines .
to compute the preconditions we define a new set of type concrete and symbolic maps t c s for the formal parameters of and apply runconcolic to .
the completion of this step ensures the generation of the precondition for .
in order to reuse pre computed preconditions calluses an auxiliary procedure unify which tries to unifythe current execution state in with some precondition entry recall that each entry is a list of type and path constraints .
unification is based on the following rule if constrains a variable xwith value v then .c x v. similarly if constraints the type of xtot then either .t x isundefined or t. if unification succeeds it returns set of constraints possibly empty to update with.calladds these constraints to .stack and solves for new inputs which satisfy these constraints the current execution is aborted.
we will illustrate the use of preconditions in interprocedural concolic testing algorithm using the example that invokes the method foodiscussed in section .
.
function baz x y z o if z foo x y z o else foo x y z o o.z z figure 2b presents the inputs and constraints generated with the use of preconditions from table .
initially the inputs are undefined resulting in the constraint z ne ationslash number.
because z ne ationslash fooin theelse branchis called.
atthis point because the type constraint in the caller is not flipped we negate the constraint solve it and generate the second input suchthat zisanumberandassign itthedefaultvalue zero .
whenfoois invoked in the else branch the stack contains a path constraint z ne ationslash .
the precondition entry for foo that is feasible on this path is the first entry in table .
the constraints are placed on the stack and flipped value of these constraints is set to one as specified in algorithm line .
this ensures that newly generated input will follow the path corresponding to the chosen precondition.
the merging of the two stacks is shown next to the second input.
when the third input is generated to satisfy the constraints the execution crashes at o.zando ne ationslash objis added.
the constraint is flippedtogenerate thefourth input with which execution halts.
all the constraints that are flippedonthestackareeliminated andthebranchconstraint z ne ationslash is flipped.
when foois invoked in the ifbranch the constraints that correspond to the feasible path are added see table .
the constraints are solved to generate the sixthinputwhichwhenexecutedreaches endofpath.
unlike theelsebranch executing the ifbranch will ensure that o.zdoes not crash in the first attempt as the precondition offooensures that ois an object.
.
implementation the concolic testing approaches can be classified as typeagnostic and type aware approaches.
for each classification there are two variations of exploring the paths in the program dfs and bfs.
the only difference between these strategies is the order in which constraints are solved.
overall we consider the following variants .bfs existing concolic testing implementation in .dfs implementation of alg.
that uses alg.
.ta bfs type aware variant of bfs and .ta dfs implementation of alg.
that uses alg.
.
test driver to perform concolic testing it is essential that a proper environment be setup with initial seed inputs and variables and the function under consideration is invoked.
we statically parse the programs and setup the environment to perform concolic testing on each function.
we consider global variables detected by jshint as seed inputs.
the seed inputs are initialized with undefinedvalues to enable coverage of all possible types.
path sensitivity the existing implementation of typeagnostic bfs is path insensitive and generates inputs considering properties on objects accessed on irrelevant paths.
173benchmark idprogram classvlocfta bfs ta dfs coverage minmaxtotalminmaxtotalstatement branch function sunspider b13d cube .
.
.
sunspider b23d raytracer .
.
.
sunspider b3access nbody .
.
box2d b4b2mat22 .1a12911395231053100 box2d b5b2mat33 .1a11311326743287799.
.
v8b6splay .
.
.
.
v8b7raytrace .
hapi b8response .
.
.
.
.
hapi b9connection .
.
.
.
.
.
.
hapi b10validation .
.
.
.
.
.
table benchmark information and results.
v version f number of functions ta type aware.
because this unnecessarily increases the redundancyof generated inputs we made it path sensitive.
the dfs variants are also implemented to be path sensitive.
consequently the number of entries in the preconditions is few reducing the lookup time during inter procedural testing.
handling function calls constructing call graph requiredfor inter proceduraltesting for dynamicallytypelanguages is difficult and the absence of type information of input objects makes the task more difficult.
we address this by generating the preconditions of the callee functions on demand.
these preconditions are derived in a contextinsensitive manner.
for example if a function fooinvokes bar it is discovered at runtime.
we stall the execution of fooand compute the precondition of bar.
for subsequent invocations of bar we reuse the computed preconditions.
k level inter procedural challenges inthe case of interprocedural testing we save the state of the current function i.e.
symbolic and concrete values and stack when the preconditions for the callee are being derived.
since the preconditions are generated on demand the process can be performed in a nested manner until no more functions are invoked.
because saving the state at each level is complex we parameterize the approach to handle k levels of nesting.
arrays loops and recursions the existing implementation of bfs testing does not handle arrays which can affect coverage.
therefore for an array access we ensure that the type of the index is set before setting the type of the array object.
for loops we discard the constraints generated beyond a specified limit.
we arbitrarily break recursions based on the order of function invocations.
.
experimental results we evaluate the benefits of type aware concolic testing across various dimensions.
we use a bit core ubuntu13.
desktop equipped with an intel core i7 processor and 16gb ram to run experiments.
we applied our approach on various open source js programs andlibraries .
weconsider the following benchmarks sunspider programs used to measure performance of javascript box2dprograms that are part of the octane benchmark suite v8programs used for tuning the performance of v8 and hapi libraryclasses thatformaframework forbuildingapplications and services.
table presents the benchmarks their version lines of code and number of functions in the programs classes analyzed.
we associate an identifier with each benchmark b1 tob10 and henceforth will use them for reference.
the loc ranges from for b5to for b7and the function count ranges from to .
we designed our experiments to answer the following research questions .rq1 is type aware intra procedural concolic testing more beneficial than existing type unaware approaches?
.rq2 does type aware intra procedural concolic testing help achieve more coverage?
.rq3 do preconditions reduce the number of generated inputs for inter procedural testing?
.rq4 can preconditions be used to handle type related crashes?
.
rq1 benefits of type aware testing initially we study the benefits of type aware intraprocedural concolic testing.
we analyze each function in an isolated manner without providing the implementation of its callees.
the goal is to demonstrate the ability of the generated tests to achieve high coverage.
if we consider the callee implementation achieved coverage will be limited by the existing program structure.
for each function we analyze it with four variants of concolic testing as described in section .
the statistics pertaining to the number of inputs generated by ta bfs and ta dfs is given in table includingtheminimumandmaximumnumberofinputsgenerated across all functions in abenchmark.
for example when the functions in b9are tested the number of inputs generated for the different functions in it using ta bfs range from to .
the total number of inputs required to cover the paths in all the functions is also presented.
the overall number of inputs required to cover the paths in all the functions analyzed across all the benchmarks ranges from to using ta bfs and to for ta dfs.
figure presents the improvements due to type aware concolic testing.
more specifically we compute the percentage of number of inputs generated using type aware testing compared to that generated by the existing approach.
since the existing approach can generate large number of inputs we bound the input generation to per function.
out of functions that are tested across all benchmarks bfs and dfs approaches reach the upper bound of inputs for and functions respectively.
in other words concolic testing these functions can be significantly longer due to redundant exploration of paths.
figure 3a presents the comparison between ta bfs and bfs.
in the figure segment shows the percentage of functions for which type aware testing generated less than of the inputs as compared to the original shows thepercentageoffunctionsfor whichtype awaretestinggenerated to of the inputs generated by the original approach and so on.
we observe that for a significant percentage of functions ta bfs generates less than inputs as compared to bfs.
for example b2has approximately of the functions that is present in this category.
more174 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10percentage of functions benchmarks12 a ta bfs.
b1 b2 b3 b4 b5 b6 b7 b8 b9 b10percentage of functions benchmarks12 b ta dfs.
inputs inputs inputs inputs figure distribution of functions demonstrating the improvement due to type aware concolic testing.
label above bar is overall function count time out functions count .
.
.
.
.
.
.
.
b1b2b3b4b5b6b7b8b9b10exception ratio benchmarksta bfs ta dfs figure normalized exception ratios w.r.t the original approaches.
.
.
.
.
.
.
b1b2b3b4b5b6b7b8b9b10ratio of inputs benchmarksta bfs ta dfs figure representative number of inputs.
.
.
.
.
.
.
.
b1b2b3b4b5b6b7b8b9b10time ratio benchmarksta bfs ta dfs figure normalized time w.r.t the original approaches.
over of the functions analyzed for b2 functions timed out reached the upper bound using bfs.
even for the remaining functions that did not go beyond 1k inputs the percentage of inputs generated with ta bfs is quite low.
there are a few functions across benchmarks for which input generation is not significantly affected due to typeawareness e.g.
of the functions in b1 b2andb3 .
our manual inspection shows fewer property accesses in these functions.
consequently they do not expose the potential problem with type agnostic approaches.
even when there are a significant number of such functions e.g.
b4and b5have approximately few functions exist for which input generation reaches the upper bound.
in these scenarios ta bfs out performs bfs and reduces the number of inputs generated.
figure 3b presents the corresponding improvement for the dfsvariants of concolic testing.
here the overall numberof functions that reach the upper bound is lower as compared to bfs .
this is because of the difference in the way constraints are solved in both the approaches.
even with the reduction the number of inputs generated by dfs is nontrivial.
by employing ta dfs for of the functions we reduce the number of inputs generated by on average .
in figure we present the ratio of number of exceptions e.g.
an exception will happen when o.x is executed and o is undefined during an execution when type aware testing is employed to the exceptions in the original version.
based on figure we expect thenumber of exceptions tobe quite low here less than .
when executing with ta bfs.
similarly the ratio of the number of exceptions is also low with ta dfs.
this is a consequence of reducing the redundancy.we tabulated the ratio of the representative inputs compared to total inputs that are generated for the type aware variants.
we define representative inputs as the inputs that do not encounter exceptions during an execution and therefore can contribute to the function precondition.
figure presents the ratios for ta bfs and ta dfsand are comparable for both the variants.
broadly they range from .
for b4to .
for b2.
this shows that the functions that are considered havemany properties that cause executions on many inputs generated by type aware approaches to have exceptions.
for b4andb5 we verified that even though there are many functions with few inputs the representative inputs is still lower than the overall inputs because of the exceptions.
figure presents the normalized execution time of the type aware approaches with respect to the original approaches.
the time taken which ranges from .
to three seconds per function is significantly lower than the original approaches.
interestingly even though the exceptions for b9 are relatively less the time ratio of ta dfs is nevertheless high.
this is because of the actual time taken to execute the different functions in it is higher.
type awareintra proceduralconcolic testingresultsinthe generation of fewer inputs and takes lesser time than existing approaches.
.
rq2 coverage of type aware testing in this section we show that coverage is uncompromised due to type awareness.
we use istanbul a js code coverage tool to track statements branches and functions executed.
table shows the coverage data for the benchmarks.
b1 b2 b3 b4 b5 b6 b7 b8 b9 b10average number of inputs benchmarkswith callee impl no preconditionswithout callee implwith callee impl use preconditions figure average number of inputs generated.
b1 b2 b3 b4 b5 b6 b7 b8 b9 b10average number of exceptions benchmarkswith callee impl no preconditionswithout callee implwith callee impl use preconditions figure average number of exceptions.
the number represents the average coverage achieved using intra procedural type aware concolic testing for that benchmark.
for example in 3d cube program .
statement coverage is obtained after testing functions.
as shown in table for a majority of the benchmarks the achieved coverage is closer to .
however for b2 b9 b10 following are the reasons for poor coverage presence or return of a function definition within a function body and presence of constraints involving strings array properties and complex expressions.
since the statements in the function definition cannot be counted as part of the encompassing function which is tested we obtain code coverage closer to after discarding these statements as shown in the parenthesis in table .
the problem with unsolvable constraints exists even for existing type agnostic approaches and is orthogonal to the proposed approach.
though it is hard to get coverage numbers for bfs and dfs in many cases we believe that the coverage remains unaffected since the search strategy remains the same.
in addition to demonstrate that the ability of concolic testing to find bugs is not diminished in the proposed approach we inserted defects randomly across all the benchmarks.
after performing concolic testing we observe that both existing and type aware concolic testing detected defects.
for the remaining three defects the defect was introduced at unreachable source locations e.g.
inside a condition with unsolvable constraint .
as mentioned earlier this is an orthogonal to the problem addressed in this paper.
type aware concolic testing helps achieve high coverage.
.
rq3 inter procedural testing wealsostudythebenefitsofemployingfunctionpreconditions in reducing the overall number of test inputs.
for each benchmark we pick three functions randomly such that it has at least one invocation to some other function.
we perform concolic testingoneachfunctionusingta dfs.thisis because the experimental results in section .
demonstrate thatthedfsvariantofconcolic testingis comparablybetter than dfs and bfs.
we perform the testing as follows test the function with the implementation of its callees but without using preconditions and test the function in isolation without providing the implementation of its callees test the function with the implementation of its callees and use the preconditions for the callees in section .
.figure presents the comparison of the average number of inputs generated across the three dimensions for all the benchmarks using ta dfs.
the average number of inputs generated when the callee implementations are provided without preconditions is approximately twice the number of inputs generated when implementations are not provided.
moreover for most of the benchmarks using the preconditions of the callees reduces the number of inputs generated by half as compared to when the preconditions are not used.
as expected these numbers are slightly more than the scenario when no callee implementations are provided.
we observe an interesting aspect pertaining to the results ofb7andb10.
the number of inputs generated is lower while using preconditions as compared to when the implementation is not provided.
upon closer examination we identify that having the callee implementation ensures that types of objects are determined and testing does not result in an exception in other parts of the caller function.
however when the implementation is not provided these types are unavailable resulting in more exceptions in the caller.
another interesting data point is the result on b3in figure .
the number of inputs generated when the implementations are providedis independentofwhether preconditions are used.
this is because the normally terminating paths in the function is equal to the number of entries for the callee precondition.
therefore employing preconditions does not reduce the number of inputs generated in that scenario.
figure presents the average number of exceptions and provides a comparison under the three scenarios.
in general the results validate our expectations in that the use of callee preconditions reduce the exception count.
for b8 when the implementation is not provided an exception happens in the caller because the callee is not recognized.
on the other hand when preconditions are provided even this exception disappears resulting in the absence of any exceptions with the use of preconditions for it.
the number of exceptions is also a function of the number of entries in the function preconditions.
for example for b4 we observe that the number of exceptions is more with preconditions than without the callee implementation.
this is because of multiple entries corresponding to the same function in the preconditions.
on the contrary when multiple invocations are made without the callee implementations each invocation will result in an exception.
the derivation of function preconditions reduces the number of inputs generated for inter procedural testing.
.
rq4 handling type related crashes apart from using function preconditions in the context of inter procedural concolic testing the generated conditions can also be employed in automatically fixing ill typed objects being passed to methods during a method invocation.
we now demonstrate the use of the preconditions in automatically fixing malformed inputs.
broadly the idea is similar to failure oblivious computing where the the crash is avoided by manufacturing values whenafailure is expected.
uses thisstrategytoenhance server availability whereas we propose to use this strategy to avoid crashes in js applications.
consider a function foo defined in section .
and corresponding preconditions in table .
when foo is invoked we can avoid the crash by using the second precondition in table .
this is achieved by introducing a dummy barfunction in the object o i.e.
last parameter during runtime.
library file issuemissing property e hapi response.js readablestate hapi handler.js isboom pm2childprocess.js close pm2 monit.js cpu mocha mocha.js callback table real crashes in js programs.
e number of entries in the precondition.
table presents a sample of real crashes reported on different js programs.
typically these crashes happen when the method is invoked with malformed objects.
therefore a dereference on such an object for a specific property results in the crash.
for the purpose of detecting the correctness of the objects passed to a method it is essential that function preconditions are available.
as our experimental results demonstrate deploying existing concolic testing approaches to derive preconditions can be infeasible due to the number of inputs generated.
on the other hand our type aware approach generates the preconditions effectively.
moreover because the preconditions are path sensitive we fix malformed objects along feasible paths.
we are able to generate preconditions for all the problematic functions reported in table .
the associated numberof entries in the preconditions is also shown.
for example for classchild process the number of entries in the precondition for function onexitis .
in this case when an input with an object that does not havethe property closeis used to invoke the method we lookup the entries in the precondition and detect that the feasible path for the corresponding path requires the receiver to contain close.
applying a variant of the procedure described in algorithm to fix the receiver ensures that the execution does not crash.
the function preconditions can help avoid crashes due to malformed objects.
.
related work several approaches for automated test generation have been proposed .
sen et al.
implement a multi path symbolic execution and variant of concolic testing to generate test inputs for js programs.
we show that generates redundant inputs even for small programs.
in this paper we propose an approach that builds on top of jalangi to reduce the redundancy bydistinguishing type constraints and branch constraints.
automatic testing of such applications has beenstudiedextensively.
symjs containsasymbolicengine for javascript and an automatic event explorer for web pages using taint analysis.
mirshokraie et al.
present a technique to automatically generate test cases for individual javascript functions and event sequences to maximize function coverage.
wassermann et al.
use finite state transducers to solve string constraints and use real values when constraint resolution is incomplete.
while the focus of these approaches is to generate proper event sequences or inputs for complex strings we are generating minimum number of test inputs to cover js programs.
various typeinference techniques are proposed to generate optimized code or to detect type inconsistencies.
hackett and guo generate fast js code by using derived type information.
ahn et al.
propose inline caching mechanisms for faster property look ups.
pradel et al.
use type inference to detect inconsistent types to expose optimization opportunities.
these techniques perform type inference during jit compilation.
our aim is to derive the appropriate types of variables starting from executions with undefined types.
also due to imprecision existing static type checkers e.g.
flow are not suitable for our approach.
typescript extends javascript with type annotations to prevent typeinconsistencies.
feldthaus et al.
propose anapproachtoautomatically detecterrorsinthetypescript declaration files for javascript libraries.
rastogi et al.
improve soundness of typescript by enforcing stricter type checks to minimize performance overhead of runtime checks.
our work differs from these approaches as our technique does not require any programmer interference.
several static analysis tools are proposed to improve the reliability of javascript programs.
jensen et al.
propose a static analysis infrastructure that can infer detailed andsound typeinformation usingabstract interpretation.
kashyap et al.
developed an efficient abstract interpreter that takes care of several features including configurable sensitivity.
previous approaches either ignore or make assumptions about dynamic behavior.
since we employ testing we do not suffer from these drawbacks.
.
conclusions we observe that conventional concolic testing approaches arenotscalable for testing js programs.
this is a consequence of treating branchandtypeconstraints equivalently.
we address the problem by proposing an effective approach that introduces type awareness to reduce generation of redundant inputs.
we extend the approach for inter procedural testing by incorporating preconditions appropriately.
we perform elaborate experimentation and demonstrate the scalability of type aware concolic testing approaches over existing approaches.
we also show the usefulness of the derived preconditions in avoiding crashes.