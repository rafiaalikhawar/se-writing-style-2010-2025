automating non blocking synchronization in concurrent data abstractions jiange zhang university of colorado at colorado springs co usa jzhang3 uccs.eduqing yi university of colorado at colorado springs co usa qyi uccs.edudamian dechev university of central florida orlando fl usa dechev cs.ucf.edu abstract this paper investigates using compiler technology to automatically convert sequential c data abstractions e.g.
queues stacks maps and trees to concurrent lock free implementations.
by automatically tailoring a number of state of the practice synchronization methods to the underlying sequential implementations of different data structures our automatically synchronized code can attain performance competitive to that of concurrent data structures manually written by experts and much better performance than heavier weight support by software transactional memory stm .
i. introduction the advent of the multi core era has brought multithreaded programming to the mainstream and with it the challenges of managing shared data among the threads.
compared to traditional lock based mechanisms non blocking synchronization offers lock free progress guarantees and better fault tolerance but at the expense of requiring much more extensive modifications to the sequential code limiting their wide spread use.
this paper aims to ameliorate this difficulty.
nowadays lock free synchronization is programmed either by manually following various construction methods or automatically by using the higher level interface supported by software transactional memory stm .
this paper presents an alternative approach to stm by using sourceto source compiler technology to automatically convert sequential c data abstractions e.g.
queues sets and trees to lock free concurrent implementations to relieve developers from the error prone task of low level concurrent programming.
our compiler supports the synchronization of a single abstraction and therefore is not as general purpose as stm which supports the synchronization of whole software applications.
however a key insight from our work is that by restricting the scope of synchronization to a single self contained abstraction and thereby selecting the best synchronization strategy to tailor to the underlying sequential implementation runtime overhead of synchronization can be significantly reduced resulting in much better performance scalability than using existing heavierweight stm implementations to support all synchroniza tion needs.
we show that by automatically weaving synchronization schemes with sequential implementations of data structures many efficient lock free data structures can be made readily available with performance competitive to that of the manually crafted ones by experts.
the key technical difference between our work and existing stm research is that we support multiple synchronization strategies and automatically select the best strategy for each piece of code at compile time.
no existing compiler for stm supports automatic tailoring of synchronizations to what is needed by different pieces of code.
the compiler algorithms we present are the first to do this.
while we mostly rely on standard compiler techniques e.g.
pointer and data flow analysis the problem formulations and solution strategies do not yet exist in any compilers.
our programming interface is easy to use as it does not require the user to declare anything in contrast stm requires all shared data