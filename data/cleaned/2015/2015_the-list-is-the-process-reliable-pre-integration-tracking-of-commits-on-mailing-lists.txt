the list is the process reliable pre integration tracking of commits on mailing lists ralf ramsauer daniel lohmann and wolfgang mauerer technical university of applied sciences regensburg university of hanover siemens ag corporate technology munich ralf.ramsauer othr.de lohmann sra.uni hannover.de wolfgang.mauerer othr.de abstract a considerable corpus of research on software evolution focuses on mining changes in software repositories but omits their pre integration history.
we present a novel method for tracking this otherwise invisible evolution of software changes on mailing lists by connecting allearly revisions of changes to their final version in repositories.since artefact modifications on mailing lists are communicated byupdates to fragments i.e.
patches only identifying semanticallysimilar changes is a non trivial task that our approach solvesin a language independent way.
we evaluate our method onhigh profile open source software oss projects like the linuxkernel and validate its high accuracy using an elaborately createdground truth.
our approach can be used to quantify properties of oss development processes which is an essential requirement forusing oss in reliable or safety critical industrial products wherecertifiability and conformance to processes are crucial.
thehigh accuracy of our technique allows to the best of ourknowledge for the first time to quantitatively determine if anopen development process effectively aligns with given formalprocess requirements.
i. i ntroduction software patches may have come a long way before their final integration into the official branch known as mainline or trunk of a project.
there are many possible ways of integration.
among others the origin of a patch can be a merge from other developers repositories i.e.
integration of branches or patches from foreign repositories pull requests on web based repository managers such as github or gitlab vendor specific patch stacks or mailing lists mls .
especially mls have been in use for software development processes for decades .
they have a well known interface plain text emails and come with an absolute minimum of tool requirements i.e.
a mail user agent .
because of their simplicity scalability reliability and interface robustness they are still widely used in many open source software oss projects.
in particular mailing lists are a core infrastructurecomponent of long lasting oss projects such as low level systems software e.g.
qemu u boot grub etc.
operating this work was supported by siemens ag corporate research the idev40 project and the german research council dfg under grant no.
lo .
the idev40 project has received funding from the ecsel joint undertaking ju under grant no.
.
the ju receives support from the european union a zs horizon research and innovation programme.
it is co funded by the consortium members grants from austria germany belgium italy spain and romania.systems e.g.
the linux kernel or foundations e.g.
apache gnu mailing lists form the backbone of their development processes .
they are not only used to ask questions file bug reports or discuss general topics but implement a patch submit review improve strategy for stepwise refinement that is typically iterated multiple times before a patch is finally integrated to the repository cf.
figure .
therefore mls contain a huge amount of information on the pre integration history of patches.
a commit in a repository may be the outcome of that process while all intermediate steps leave no direct traces in the repository.
mailing lists allowus to analyse development history and code evolution but also enable us to inspect reviewing and maintenance processes.
they further allow inferring organisational and sociotechnical aspects of software development.
this all is possible because mls contain information on interactions between developers.
nowadays open source components are routinely deployed in industrial fields and their use is increasingly explored insafety critical or mixed criticality appliances such as medical devices or in automotive products.
especially for core components of a system that implement business wise non differentiating features such as the system software stack or middleware oss provides adequate solutions that have already proved to be reliable in other non critical application domains.
however non functional aspects like evidences of quality assurance are also a crucial factor for industry.
deploymentof software in safety critical environments requires conformance with international standards such as iso iec or iec .
this demands certified development processes that implement high standards regarding traceability and auditability of all development decisions including code writing reviewing deployment and maintenance activities the rationale for strict process compliance is to achieve and prove high product quality .
compared to conventional orthodox proprietary industrial software oss exhibits different dynamics and often requires fundamentally different development processes because of project size and a high number of massively geodispersed stakeholders.
because of this nature of oss projects do not necessarily meet certification criteria .
nevertheless vendors across different industrial sectors share similar concerns on the use of oss components ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure typical workflow a patch gets resubmitted and improved for two times before its integration oss projects are community driven.
hence their established processes can only be applied to a certain degree.
quantitative ex post analyses of processes are required to investigate conformance.
statistical methods are necessary to judge the applicability of oss components in different scenarios.
this makes it possible to reconstruct process operations and use them to draw conclusions on processes with quantitative software engineering techniques.
however how to do this is an unsolved issue in industry .
to assess non formal oss development processes mapping patches on mailing lists to repositories is a key requirement because the mails contain the facts they are the artefacts of the development process.
together with the outcome of the process the repository this forms a solid base for further analysis.
patches that appear on mailing lists are manually selected cherry picked by the maintainer before integration into the repository.
they are also routinely combined squashed and modified amended on the fly which is convenient for developers but complicates tracking.
either way a direct connection between the history on the mailing list and the repository commit is lost in the process .
we present a method accompanied by comprehensive automated tool support1that allows us a to track several revisions of a patch on a mailing list and b to map those patches on the list to upstream commit hashes if the patch was integrated.
we identify and formalise the problem as cluster analysis and provide an in depth evaluation of our and other approaches.
both problems are reduced to finding similar patches.
we quantify the accuracy of the approaches with elaborate external validation measurements based on a ground truth in section iv.
we claim the following contributions a novel highly accurate methodology to reconstruct the missing link between mailing lists and repositories on noisy real world data.
a precise formalisation of the problem together with a previously unavailable elaborate external validation of our algorithm based on a proper ground truth together with a qualitative evaluation of other approaches.
1published under the gplv2 license at industry grade fully published and extensible framework that allows for further in depth analyses and scales to handle the world s largest software development projects.
results of the evaluation of the linux kernel and its principal ml underline the high accuracy of our approach.
ii.
r elated work i a patch consists of an informal commit message that describes the changes of the patch in natural language and annotations of the modifications to files of a project.
first and foremost patches modify source code but also documentation build system tools and any other artefacts of a project.
a single patch may modify several files.
within the context of a file chunks also known as hunks are segments that describe changes to a certain area within a file.
figure illustrates the typical structure of patches on the ml a b and in the repository c .
we need to find similar patches to track patch evolution.
jiang adams and german present a coarse grained checksum based technique for mapping emails that contain patches to commits.
after trimming whitespaces they calculate md5 hashes over chunks of the patch.
two patches are considered similar if they have at least one checksum in common i.e.
share one equivalent chunk .
in another work the authors refine their technique and present further approaches a plus minus line based technique and a clone detection based technique.
the plus minus line based technique weights the fraction of equivalent lines of two patches.
this includes insertions and deletions .
the clone detection based technique incorporates ccfinderx a code clone detector.
they evaluate their three techniques and conclude that the plus minus line based technique is performing best.
this evaluation is based on the f score that depends on the precision and recall of the actual algorithm.
in contrast to measuring the precision the f score requires a ground truth for determining the recall.
as a ground truth is hard to obtain authors use the concept of relative recall that provides a qualitative approximation.
we presented a method and a tool to identify similar patches in different branches of a repository .
they use their authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
method to quantify integration efforts of huge software forks like the preempt rt real time patch for the linux kernel or hardware vendor specific forks of the linux kernel.
the problem is to find patches that first appeared in a development branch and were later applied to the master branch of the project.
yet this work misses a proper quantitative evaluation and only operates on commits within a repository.
iii.
r esearch methods from an analytical standpoint the downside of patch submission on mailing lists is asynchronicity as there is no direct connection between the mailing list and the software repository.
maintainers manually integrate patches from the list and commit them to the repository.
this process is typically assisted by tools provided by the version control system.
during this process the connection of the email with the patch identified by the unique message id header of the mail and the commit in the repository usually identified by a commit hash is lost.
other difficulties are contextual divergences and textual differences .
the commit in the repository may significantly vary from the patch on the mailing list as other patches between submission and integration might have affected the patch.
additionally maintainers may introduce additional changes to the patch.
there is also no connection between several revisions of a patch within the mailing list.
a patch undergoes a certain evolutionary process between revisions hence patches of different revisions may significantly differ as well while they still introduce the same logical change.
a. code submission workflow independent of the type of submission a patch pis formally defined as a tuple that consists of a commit message and a diff.
while the commit message informally describes the changes the diff annotates the actual modifications insertions and deletions surrounded by a few lines of context.
context lines ease the understandability of the patch for human review.
patches can also include meta information such as the author of a patch or the timestamp of its creation author date .
not all types of patches contain the same set of metadata.
emails with patches contain several mail headers while those headers are removed when the patch is applied to the repository.
repositories in contrast contain information on the exact spatial location of the patch.
metadata may also change over time even the author of a patch may change.
therefore we intentionally do not consider metadata in our similarity analysis.
mapping patches on mailing lists to commits in repositories requires to understand common workflows in projects when the author of a patch wants his or her patches to be integrated in the project they need to send their patch or patch series to the mailing list of the project.
2e.g.
git am apply mail from mailbox or git cherry pick apply the changes introduced by some existing commits message id git send email tias ulyssis.org date sun jun to discussion and development of busybox busybox.busybox.net from tias guns tias ulyssis.org subject android use bb additional path signed off by tias guns tias ulyssis.org include platform.h file changed insertions diff git a include platform.h b include platform.h index d79cc97..f250624 a include platform.h b include platform.h typedef unsigned smalluint define maxsymlinks symloop max endif if defined android defined android define bb additional path system sbin system bin system xbin endif who misses what?
.
.
a in a series the author adds some conditional preprocessor definitions message id git send email tias ulyssis.org date sun jun to discussion and development of busybox busybox.busybox.net from tias guns tias ulyssis.org subject android fix ionice add ioprio defines patch inspired by busybox patch v1.
vitaly greck signed off by tias guns tias ulyssis.org include platform.h file changed insertions diff git a include platform.h b include platform.h index f250624..ba534b2 a include platform.h b include platform.h typedef unsigned smalluint if defined android defined android define bb additional path system sbin system bin system xbin define sys ioprio set nr ioprio set define sys ioprio get nr ioprio get endif .
.
b in a series the author adds further definitions under the same condition commit 3645195377b73bc4265868c26c123e443aaa71c6 author tias guns tias ulyssis.org date sun jun platform.h android tweaks ioprio defines bb additional path signed off by tias guns tias ulyssis.org signed off by denys vlasenko vda.linux googlemail.com diff git a include platform.h b include platform.h index d79cc97..ba534b2 a include platform.h b include platform.h typedef unsigned smalluint define maxsymlinks symloop max endif if defined android defined android define bb additional path system sbin system bin system xbin define sys ioprio set nr ioprio set define sys ioprio get nr ioprio get endif who misses what?
c maintainer squashed both mails to one commit and amended the commit message figure example of two mails and one commit that were automatically found and linked by our tool authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a patch series is a cohesive set of mails that contain several logically connected patches that in the big picture introduce one logical change that is split up in fine granular steps.
figure a and b show two successive mails in a patch series.
the submission of a patch or patch series is typically tool assisted by the version control system.
after patches are submitted reviewers or any subscriber of the list may comment on them.
this is done by starting a free form textual discussion by replying to a mail.
inline comments refer to the related code lines.
concerning change integration the reviewing process may end up in the following scenarios the maintainer decides to integrate commit the patch es the maintainer decides to reject the patch es the patch es need further improvement and need to be resubmitted to the list.
it is not unusual that is repeated several times.
in this case further revisions of the patch are typically tagged in the email subject header with prefix where n denotes the the revision round.
this iterative process of resubmitting further revisions of changes is a fundamental aspect of the development process and makes it necessary that a patch on a mailing lists must not only be linked to the repository but also against other revisions of the patch in order to track its evolution.
figure illustrates a typical workflow a patch was resent two times v2 and v3 before being integrated to the repository.
once maintainers decide to accept a patch they may still amend the commit message or the code.
depending on the submission process of the project maintainers or other persons working on the patch add additional tags to the commit message such as acked by mail tested by mail signed off by mail among others.
reviewers that vote for inclusion of the patch reply to it with a mail that adds an acked by where mail contains the email address of the person who acknowledged the patch.
anyone who successfully tested a patch may send their tested by .
the signed off by tag indicates that the patch conforms with the developer s certificate of origin4.
maintainers pick up mails with such tags i.e.
mails in reply to the initial patch and append them to the commit message before integration.
a patch on a list may significantly differ from its final version in the repository which makes it hard to link them.
figure demonstrates the complexity of finding similar patches.
this examples contains two patches that appeared on the mailing list of busybox and the eventual commit in the repository.
in this case the maintainer denys vlasenko heavily changed the original patches authored by tias guns that were sent to the project s mailing list he picked up both mails consolidated them to one commit known as squashing patches and additionally changed the commit message.
during this process metadata changed as well the author date of the commit message is neither related to nor to .
still both emails are related to the commit 3e.g.
git format patch in combination with git send email 4see linux s documentation process submitting patches.rstin the repository and mails and commit were automatically linked by our tool.
the complexity of finding similar patches is aggravated by the fact that patches are relative to a specific state of the code base determined by the commit where the patches base on.
when the latter changes between the time a patch was submitted and it was integrated as other patches had been applied meanwhile the version control system tools try to semi automatically adopt the changes which leads to different context information despite identical changes.
if automatic methods fail merge conflicts must manually be solved by humans.
multiple maintainers may commit the same patch to their own branch.
in this case a patch occurs multiple times on the master branch of the repository once those branches are merged.
those and other facts underline that similar patches can not be simply linked against each other by examining their textual equality.
b. linking similar patches we use and extend the method that we presented in to work on mailing lists.
letcbe the set of all patches commits in a software repository andmbe the set of all patches on a mailing list mails containing patches .
the universe u m c forms the set of all patches.
in its most general form the informal equivalence relation s patches are semantically similar can be defined as s u u .
this covers all eventualities including situations like patch committed twice in the repository orpatch went through several rounds of review before integration .
the algorithm in is able to quantify the similarity of two patches within a repository by four parameters explained in section iii c that influence the sensitivity of the algorithm.
it measures the similarity of two patches sim tf th dlr w u u where denotes complete dissimilarity i.e.
no commonalities and denotes complete equivalence on a textual level.
note that symmetry a b u sim tf th dlr w a b sim tf th dlr w b a and reflexivity a u sim tf th dlr w a a hold.
letv u be the set of all vertices of the undirected graph g v e .
every edge in econnects two patches that exceed the threshold ta e a b u sim tf th dlr w a b ta the connected components of gform subgraphs of similar patches that divide uinto disjoint partitions.
those partitions induce equivalence classes s y v x gy authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
where gdenotes reachability.
we use sto denote the corresponding equivalence relation and can use sim to determine all equivalence classes by pairwise patch comparison in a process that iteratively merges equivalence classes where the similarity of two patches exceeds a certain threshold ta cf.
figure .
section iii d describes how we overcome resulting combinatorial explosion.
from another perspective the partition of the equivalence relationscan also be seen as an unsupervised threshold based flat clustering ofu .
in section iv we will use this fact to evaluate the accuracy of the approach with external evaluation methods for clusterings.
with this we reduced the problem of finding clusters of similar patches to a function sim which rates the similarity of two patches.
in the following we will introduce sim the function that scores the similarity of two patches and its set of parameters that control the sensitivity of the function.
rating similarity of two patches as mentioned above patches evolve over time.
while the commit message and the code may change they still introduce the same logical change.
as the commit message and diff may evolve independently we calculate two independent scores that quantify the similarity of the two commit messages and the similarity of the two diffs rmsg rdiff .
again 0means no commonalities while means equivalence on a textual level.
a similarity of commit messages maintainers may amend or reword commit messages before they integrate the patch.
they can also rearrange or reformat the patch to make it easier to understand or to avoid ambiguities.
nevertheless keywords that are used in those messages tend to remain the same.
before comparing commit messages we remove all tags that were added by maintainers as they do not appear in the initial patch.
the next step is to tokenise and sort all words in a commit message.
the tokens are separated by whitespaces.
we then pairwise compare them against each other by using the levenshtein string distance .
we select the closest match for each token.
the arithmetic mean over all matches forms the scorermsg.
we chose the levenshtein string distance together with tokenisation as it respects restructured messages as well as minor changes in wording such as typo fixes.
b similarity of diffs even if code changes or evolves over time we observed that different versions of a patch very likely still affect the same code paths and files and use similar keywords or variable names.
we compare diffs in an iterative process.
a single patch may modify several files.
when comparing the diff component of two patches we only consider changes to files with similar filenames.
the threshold of the levenshtein similarity for filenames is determined by the parameter tf which must be exceeded if the diff of two files is considered for actual comparison.
a diff of a given file may consist of several hunks which describe changes to a certain section within the file.
hunks are annotated with the line number within the file and a hunk header that describes the context of the change cf.
figure .
they display the nearest unchanged line that precedes each hunk .
we pairwise compare all hunks of the two diffs against each other but abkbh biv m2irq f s ibibqmb q7 bbkbh t i ?2bu u?
h yx3j yxndyx3ryxneyxn3yx33 yxnjyx33yxnk yxn9yxne yx3e yx3e yxnkyx3k yx3n yx3nyx3d yxnj yx3kyx3k yxnyyxd8 yxdk yx8d yx9ryxydyxedyxdjyxrj yxknyxde yxeeyx8j yx8kyxrd yxrd figure sim determines the similarity edge weights of patches.
dashed edges remain below the threshold ta .
.
connected components above the threshold form equivalence classes of similar patches.
green and orange vertices exemplarily denote patches on ml and commits respectively.
only consider hunks with hunk headers that exceed a certain similarity th.
hunks for which a mapping can not be established are ignored as the hunk might have been added or removed in one of the patches.
to compare those hunks we disregard context lines as they might have changed in the meanwhile compare insertions only against insertions and deletions only against deletions.
therefore we again tokenise deletions resp.
insertions and use the levenshtein string distance to compute a score for the hunk.
the arithmetic mean of scores of all hunks provides the similarity score for the diff rdiff.
c. parameters the extensive use of string metrics for measuring the similarity of different parts of a patch opens a wide spectrum for different thresholds of similarity.
additional parameters tf th dlr w ta investigate the structure of the patch and control the sensitivity of the comparison.
a tf filename threshold a file might have been renamed in the time window between the submission and acceptance of a patch.
as mentioned above we only consider the pairwise comparison of files with a similar filename.
the filename threshold tf denotes a similarity threshold for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
filenames that must be exceeded if two files shall be considered for comparison.
b th hunk header threshold within a file the location of a hunk might have moved in the time window between submission and acceptance of a patch.
either the author moved the location of the hunk the upstream location changed or a maintainer moved the code.
hunk headings try to ease the readability of the patch.
regular expressions backward search for anchor lines that will appear in the hunk heading such as e.g.
function names.
the hunk heading threshold th denotes the similarity of two hunk headings of hunks that must be exceeded if two hunks shall be considered for comparison.
c dlr diff length ratio similar patches only slightly differ in size.
it is unlikely that a patch that modifies one single line is related to a patch that affects hundreds of lines.
because of this patches are considered dissimilar if the diff length ratio dlr which is the fraction of the number of changed lines of the smaller patch by the number of lines patched by the bigger patch is not exceeded.
d w commit diff weight since we calculate two independent scores for the commit message and for the diff a heuristic factor w weights the relative importance of rdifftormsgand denotes the overall similarity sim tf th dlr w a b 0ifmin a b max a b dlr w rmsg a b w rdiff a b else e ta auto accept threshold the auto accept threshold ta denotes the required score for patches to be considered similar.
patches are only considered similar if sim tf th dlr w a b ta section iv investigates the significance of the chosen set of parameters.
the selection of these metrics is based on domain specific expert knowledge of the authors which is provided by participation and contributions in a range of oss projects and during the development of our tool.
we observed some peculiarities of patches that can be used to parameterise the comparison files may be moved in the repository between submission and acceptance of a patch.
files in the repository may undergo other changes between submission and acceptance of a patch.
this might lead to merge conflicts that have been resolved.
merge conflicts change the context of a patch.
it is unlikely that small patches e.g.
one liners are related to a huge patch e.g.
feature introducing patches that add thousands of lines .
different projects have different maintenance strategies.
in some projects maintainers heavily modify commit messages see figure in other projects maintainers might leave the commit message as it is but modify the code.d.
reduction of problem space and clustering patches the major practical challenge of our approach is scalability.
consider a huge project like the linux kernel.
our mailing list archive reaches from and contains .
106mails where m .
105mails contain patches.
the corresponding upstream range v2.
.
v4.
contains c .
105commits.
this leads to a patch universe of u .
106entries with a total number of u .
pairwise comparisons.
in a preevaluation phase we drastically reduce the impractical number of pairwise comparisons.
first and foremost we only consider pairs of patches for comparison within a certain time window.
two patches will only be considered for similarity rating if they were submitted within a time window of one year.
in the evaluation we show that this covers .
of all patches.
secondly two patches can not be similar if they do not modify at least one common file.
this fact can be used for further optimisation we select only pairs of patches that modify at least one similar file.
in addition to that we first determine clusters of similar patches for emails m m .
at the beginning of the evaluation every email is assigned to its own single element cluster.
we successively merge clusters in an iterative process by comparing representatives of clusters against each other.
a representative of a cluster is the patch with the youngest submission date.
we choose this patch as representative as it will have the closest similarity with further revisions or with the commit in the repository if it was integrated.
after the creation of the clusters for emails representatives of those clusters are compared against the commits in the repository.
e. working with mailing list data the first step of the process is the acquisition of mailing list data.
this can be done by subscribing to mailing lists and collecting data historic data can be received from archives of a list.
the second step is to filter relevant emails containing patches and to convert them to a unified format that can be used for further processing .
there are plenty of methods how a user may send a patch or how the mail user agent mua may treat the message.
our parser is able to identify the most commonly used methods.
it respects patches in attachments mis encoding and different mail parts.
iv .
e v aluation the results of a heuristic method depend on the chosen set of parameters.
in the following we identify significant predictors from the available set of tuneables and further evaluate the algorithms accuracy for the optimal choice.
to establish a ground truth we chose a one month time window may a typical month of linux kernel development without any exceptional events of the high volume linux kernel mailing list5 lkml .
we extracted mails with patches 5linux kernel vger.kernel.org authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i set of parameters result used for evaluation parameter description interval step tf threshold filename .
th threshold heading .
dlr diff length ratio .
w message diff weight .
ta threshold auto accept .
and manually compared them against a three month time window in the repository in an elaborate and time consuming task using interactive support of our tool.
the creation of a sound ground truth requires domain specific knowledge to judge the relationship of patches which is available by some of the authors active involvement in the respective communities.
we then analysed the same data with our automated approach under permutation of parameters in a reasonable range as shown in table i. prior to choosing the exact parameter ranges we performed a coarse grained analysis to roughly estimate the influence of parameters.
the chosen domains result in different analysis runs.
in the observed time frame the list received emails.
among these we identified containing patches .
.
assisted by our tool and supported by an interactive interface that ensures a swift workflow the patches were compared against all commits between linux kernel versions v3.
andv3.
commits .
those commits are within the time window see section iv b for a justification of this choice .
the ground truth consists of clusters of patches where clusters are linked to at least one commit in the repository.
clusters contain more than one email e.g.
multiple revisions of a patch clusters more than two emails and more than three emails.
clusters contain exactly one email which means the changes were immediately accepted after their initial submission without further refinements.
the ground truth is then compared against all clusters from the permutation of parameters as shown in table i. in other words we compare the ground truth against the results of our tool.
a. external evaluation external evaluation methods quantify the similarity of two clusterings .
while there are many standard evaluation methods available the correct choice relies on the structure of the clustering .
in contrast to typical clustering problems where a large number of elements e.g.
documents is distributed to a small number of clusters e.g.
document types our problem entails a large number of clusters similar patches with only few elements patch revisions and commits in repositories per cluster.
this inherently implies a considerable number of true negatives tn since two randomly chosen elements are assigned to two distinct clusters with high probability.
for a sufficiently large number of clusters any random clustering will exhibit a high number of tns.
we tested several external evaluation methods for their suitability mutual information score purity v filename similarity threshold hunk header similarity threshold .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
thresholdfowlkes mallows index figure boxplot of irrelevant parameters filename and hunk header threshold have no substantial influence.
autoaccept threshold diff lines ratio message dif f weight .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
thresholdfowlkes mallows index figure illustration of the influence of autoaccept threshold diff length ratio and the message diff weight connecting lines in all figures are used to guide the eye .
measure and the fowlkes mallows index .
purity is not suitable for our problem because it intrinsically produces good results for large cluster count.
a high number of clusters always implies good purity .
the v measure is the harmonic mean of two other measures completeness and homogeneity and also produces good results when many clusters are present.
we consequently choose the fowlkes mallows index since it is not sensitive to the number of tn and shows robust results for clusterings with a high number of clusters.
the fowlkes mallows fm index is defined as fm tp tp fp tp tp fn where tp denotes the number of true positives and fp and fn provide the number of false postives and negatives respectively.
a way to confirm the validity and suitability of an index is to compare it against an unrelated clustering .
therefore we compare the ground truth against a random clustering while maintaining the structure of the clustering that is the number of clusters and the number of elements per cluster.
compared authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
against the ground truth this reveals a bad fowlkes mallows index of .
.
since the results for our analyses lie within the interval this indicates a high validity of the chosen index.
to identify parameters with a relevant influence on the result we compute the fowlkes mallows index for each of the clusterings against the ground truth.
this provides a similarity score for clusterings for each combination of parameters.
to draw conclusions on the significance of a parameter we selectively observe the distribution of the fowlkes mallows index for each parameter.
figure illustrates the fowlkesmallows index for different values of the filename threshold resp.
the hunk header threshold.
we found that different settings for tf and th have little influence on the results.
instead best results are achieved for the boundary setting in both cases we analyse the reason for the behaviour section v .
for the further analysis we only regard the subset of our results with tf 1andth 1due to their lack of significance.
this requires to consider clusterings.
figure shows the plot of the mean of the fowlkes mallows index for autoaccept threshold diff length ratio and messagediff weight.
having the filename and hunk header threshold set to our approach performs best with a autoaccept threshold of .
a diff length ratio of .
and a message diff weight of .
.
with this combination it achieves a fowlkes mallows index of .
on the selected time window.
to confirm the universal validity of those parameters for the whole project we cross check the parameters with another mailing list the linux commits tip mailing list.
every patch that is committed to the linux tip repository is automatically sent to the linux commits tip mailing list by the tip bot.
in contrast to standard emails they contain the commit hash in the corresponding repository in their header.
this allows for simple cross validation of the best parameter set.
the list can be used to prove the general functioning of the approach as the analysis should lead to an exact match of all patches.
using a sample of emails from linux tip commits ml compared to the linux tip commits repository we obtain a fowlkes mallows index of .
.
some minor mismatches are caused by very close but still dissimilar patches that are erroneously considered similar and induced by technical corner cases where the diff for a patch being sent to the mailing list produces different output as the diff in the repository e.g.
mode changes of files or moved files .
in sum there were tps fps and fns.
note that there are more tps than actual emails because some clusters correctly contain more than one email or more than one commit a correct cluster withnelements contains n tps.
once more these numbers underline the high accuracy of our approach.
b. example duration of patch integration comparing patches is a computationally intensive task.
the number of comparisons can be reduced if potential comparison candidates are restricted to patches within a certain time window as less patches are considered for the eventual cost .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
integration duration in daysamount of patches being accepted within x days figure empirical distribution function of the integration duration of patches on the lkml intensive comparison.
our tool already provides a set of qualitative analyses such as the integration duration of a patch.
to determine the size of this window we re run the analysis on the whole lkml and the whole repository with the determined optimal set of parameters.
we define the time interval between the date of the latest revision of a patch i.e.
email submission date and the date of integration in the repository i.e.
the commit date as integration duration.
figure shows the empirical distribution function of the integration duration of all patches of the .
quantile of all patches.
interestingly within the outliers beyond that quantile we found patches that took indeed five years for integration.
.
of all patches were integrated within one year of all patches within days of all patches within one week.
c. comparison to other approaches in jiang and colleagues also present a method for mapping patches on mailing lists to repositories.
their plusminus based approach assigns each tuple of changed line and filename to a set of ids where the id can either be a message id or a commit hash.
they then search for patches that contain sufficient identical changes.
a threshold between determines the fraction of the number of identical changes that needs to be exceeded if patches are considered similar.
we used their original implementation to evaluate it against the time window of our ground truth and vary their threshold setting in the range .
figure shows the results of the analysis.
the threshold has no significant impact on the accuracy within the range .
the best fowlkesmallows index of .
that we could reach with their method is observed at threshold .
.
v. d iscussion we previously showed the high accuracy of our method and quantitatively compared it with other existing techniques methods.
we will now turn our attention to interpreting the meaning of the optimal set of tuneable parameters further authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
.
.
.
.
.
.
.
.
thresholdfowlkes mallows indexplus minus line based approach figure evaluation of the plus minus based approach highest fm index at .
while the threshold only has little influence between discuss other methods and examine the performance and thus practical applicability of our approach.
a. our algorithm in section iv we found that both filename and hunk header threshold produce best results for the boundary value .
.
a filename threshold of .
implies that patches on the list will not be associated with a commit in the repository if affected files were renamed between submission and integration of the patch and the hunk header threshold of .
disregards relocations of a hunk within a file.
the rationale for these extreme settings is that both file moves and relocations within a file do not occur frequently in real world development.
it is unlikely that a patch hits this exact window.
while a lower threshold improves recall it disproportionally decreases precision since more patches are erroneously considered similar when relocations occur.
in contrast to filename and hunk header threshold other parameters significantly influence the results auto accept threshold diff length ratio and message diff weight.
as expected too strong or too weak thresholds lead to overand underfitting.
the diff length ratio of .
is reasonable because it allows for instance an initial two line patch to expand into five line patch in a future revision but filters for strongly imbalanced sizes of patches.
it is for instance unlikely that a one line patch will evolve into a line patch in a future revision.
a message diff weight of .
underlines the importance to consider both commit message and diff with a slight bias towards the code.
it also stresses that involving actual code for analyses is vital.
b. plus minus based approach while not explicitly mentioned in their paper the authors of chose a threshold of .
for their algorithm based on their experience and intuition .
our evaluation of the plusminus based approach shows evidence that this threshold is within a range where the algorithm performs best.the authors determine the accuracy of their approach based on the f score defined as f precision recall precision recall.
it requires knowledge of precision andrecall.
while calculating precision is straightforward i.e.
counting the number of true and false positives a solid ground truth is required to determine the exact recall of an algorithm as the recall requires to know the number of false negatives.
they argue that it is hard to determine such a ground truth a statement that we fully agree with and therefore employ the concept of relative recall .
the relative recall incorporates results of the checksum based technique and the clone detection based technique.
the accuracy of these approaches is not known and therefore relative recall only forms an approximation with unknown quality.
hence we think that our determined ground truth leads to more precise results.
c. performance performance is an important factor for real world practicability.
in particular a well performing implementation is required for the evaluation of the optimum parameter set as it requires to run several analyses.
therefore we massively parallelise steps of the analysis.
the full analysis of the linux kernel v2.
.
v4.
against the whole ml with our method requires hours on a machine equipped with two xeon e5 processors cores threads using the optimal thresholds derived in section iv.
this includes run once preparation steps like converting mailing list data to a suitable format parsing mailing lists for patches or creating caches.
we were not able to run the full analysis of the linux kernel with the plus minus line based approach because of limitations of their implementation.
nonetheless we found that the plus minus line based approach is considerably more performant than our approach.
for the one month test set the approach takes seconds on the same machine as mentioned before and only consumes one single cpu core.
our approach takes between two and eight minutes to analyse the same set depending on selected thresholds.
the comparison of textual equivalence used by the plus minus line based technique is less computation intensive than our use of levenshtein string distances.
yet our approach is applicable for real world use cases and its best fowlkes mallows index is higher than the best score achieved by the plus minus line based approach.
vi.
t hreats to validity a. external v alidity we focus on the linux kernel for the evaluation which has strict submission guidelines such as requiring detailed commit messages.
patches must be structured in a fine grained fashion and must only introduce one small change.
other projects established different strategies such as less verbose commit messages or larger patches.
because of this fact our set of parameters that we found in the evaluation are therefore thresholds that suitlinux but are not necessarily applicable to other projects.
as a consequence this demands to repeat the evaluation when analysing other authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
projects that the linux kernel in order to determine its proper set of thresholds.
however numerous other low level systems that are object of our analyses adopted the submission guidelines of the linux kernel that are known as best practises in the communities.
while not mentioned in this paper due to its length the same set of parameters lead to high accuracy in other such projects e.g.
qemu busybox u boot ... .
b. internal v alidity other than a perfect gold standard a manually created ground truth underlies some uncertainties.
the creator may be biased or misjudge decisions and there is always a certain degree of subjectivity.
the creation of our ground truth judging similarity of patches was carefully done by an experienced developer with domain specific knowledge and a track record of active participation in several open source communities including the linux kernel and we are confident that our ground truth contains negligible faults.
c. construct v alidity working with mailing lists requires handling noisy data.
bird et al.
found that .
of the apache http server developer mailing list contains malformed headers.
we need to filter emails on such lists and consequently use a custom best effort parser adapted to handle these difficulties.
since authors may submit their patches in many ways finding all patches cannot be guaranteed though.
based on the knowledge in the ground truth the amount of patches that are not captured is insignificant.
additionally the revision control system git that is widely used for linux kernel development provides tool support to prevents common mistakes in emailbased patch flows which reduces the number of unparseable emails.
following op.
cit.
we deem this threat minor.
vii.
r elated work ii finding similar patches needs to be distinguished from detecting similar code.
code clone detection ccd is a well researched topic mainly driven by revealing code plagiarism or redundancy reduction .
the underlying problems of detecting similar patches and detecting similar code are related but differ in one decisive property code clone detection analyses a certain snapshot of the code while detecting similar patches requires analysing a diff which comprises only fragments detached from the code base.
additionally a patch also contains an informal commit message that is not considered by ccd.
many ccd techniques use language dependent lexical analysis and analyse similarities of abstract syntax trees .
since patches only provide differences between syntactically incomplete fragments of code and may also modify non code artefacts ccd techniques are typically inapplicable in our scenario.
another approach uses locality sensitive hash functions for quantifying code similarity .
such hash functions produce similar output for similar input.
arwin et al.
proposedalanguage independent approach that analyses intermediate code produced by the compiler.
this is not applicable to our problem since the aforementioned analysis of documentation scripts build system artefacts etc.
needs to be independent of any language restrictions.
bacchelli et al.
link emails to source code artefacts in a repository.
in contrast to our work they focus on discussions and conversations instead of analysing mails with patches.
naturally informal conversations have a different structures than patches.
however our approach of linking patches on mailing lists to repositories allows us to transitively link followup discussions of a patch since the message id of the initial patch remains in the reference header of responses.
viii.
c onclusion f uture work the industrial deployment of oss is often hindered by required certification of their non formal development processes according to relevant standards such as iec for safety critical industrial or iso for safety critical automotive software.
even though the open and communitydriven development process of oss provides full traceability of its development most of the information is not explicitly contained in the repository but implicitly hidden in semi formal discussions on mailing lists.
we presented a method that is able to reliably link emails with patches to commits in repositories with high accuracy.
additionally we formalised the mathematical background of the problem and identified it as a clustering problem.
based on this an elaborate evaluation built upon a solid ground truth quantifies the high accuracy of our approach.
the ground truth and our framework can be used to evaluate the accuracy of other approaches and the fully published framework allows for independent industrial evaluation required in certification efforts.
the evaluation verified that the presented approach performs better than existing work.
for linux and the lkml we achieve a larger fowlkes mallows index of .
than the best score achieved by the previously best plus minus line based approach.
from the technical and methodological side future work will focus on improving the performance of our approach by using hybrid evaluation techniques.
this is intended to combine the performance of fast algorithms with lower accuracy with the high accuracy of our computationally intensive approach.
other upcoming work will focus on assessing of non formal oss development processes.
our tool provides the basis for such analyses as it systematically makes the history of the process accessible.
its accuracy makes it suitable for further qualitative software analyses.
ix.
a cknowledgements we thank bram adams for kindly sharing the original implementation of the plus minus based approach that made the comparison against our technique possible.
we also thank julia lawall and lukas bulwahn for helpful comments on the manuscript.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.