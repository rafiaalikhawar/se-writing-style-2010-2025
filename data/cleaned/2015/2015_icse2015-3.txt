regular property guided dynamic symbolic execution yufeng zhang y zhenbang chenyx ji wang y wei dongyand zhiming liuz state key laboratory of high performance computing national university of defense technology changsha china ycollege of computer national university of defense technology changsha china zcentre for software engineering birmingham city university birmingham uk email fyufengzhang zbchen wj wdong g nudt.edu.cn zhiming.liu bcu.ac.uk xcorresponding author abstract a challenging problem in software engineering is to check if a program has an execution path satisfying a regular property.
we propose a novel method of dynamic symbolic execution dse to automatically find a path of a program satisfying a regular property.
what makes our method distinct is when exploring the path space dse is guided by the synergy of static analysis and dynamic analysis to find a target path as soon as possible.
we have implemented our guided dse method for java programs based on jpf and wala and applied it to real world open source java programs a total of 225k lines of code for extensive experiments.
the results show the effectiveness efficiency feasibility and scalability of the method.
compared with the pure dse on the time to find the first target path the average speedup of the guided dse is more than 258x when analyzing the programs that have more than paths.
i. i ntroduction a regular property of a program can be represented by a finite state machine fsm .
the fsm is an abstract model of the executions of the program.
a label or event of a transition corresponds to the execution of one or more statements in the program relevant to the property .
fsm can describe many kinds of program properties including resource usage e.g.
file usage memory safety e.g.
memory leak communication protocol etc.
in software engineering regular properties and fsms are widely used in different techniques such as model based testing typestate analysis and specification mining and synthesis .
these techniques encounter the common problem of checking whether there exists a path of a program that satisfies a regular property .
therefore finding effective solutions to this problem and their implementations are essential to many applications.
static analysis and dynamic analysis are the two effective approaches used for checking regular properties.
static analysis e.g.
usually enjoys the advantage of high coverage and good scalability.
but its users are often bothered by false alarms due to the extra behaviors introduced by over approximation.
the dynamic approach has the advantage of no false alarm and can provide precise information such as the input for replay.
however it is confined by the problem of limited input coverage as only the program executions of the selected inputs can be checked.
for example traditional software testing has low coverage.furthermore techniques pursuing coverage such as automatic test generation are difficult to scale up.
dynamic symbolic execution dse enhances traditional symbolic execution by combing concrete execution and symbolic execution.
dse repeatedly runs the program both concretely and symbolically.
after each run all the branches off the execution path called the off pathbranches are collected and then one of them is selected to generate new inputs for the next run to explore a new path.
hence dse improves the coverage through symbolic execution and avoids false alarms by actually running the program.
more importantly dse can use information of the concrete execution to simplify symbolic reasoning and handle environment modeling.
when dse is applied to checking a program against a regular property an execution path satisfies the property if the sequence of the events in the path is accepted by the fsm of the property and we call this path an accepted path .
however the number of paths is exponential with the number of branch statements executed during dse which brings the path explosion problem.
therefore how to guide dse to find a path satisfying the regular property as soon as possible is a challenging problem.
we propose a novel dse approach called regular property guided dse to find the program paths satisfying a regular property as soon as possible.
our approach is based on the key insight that only the paths with specific sequences of events can satisfy the regular property.
the portion of the accepted paths is often very small.
it is desirable not to explore the irrelevant paths i.e.
the paths not containing any event in the fsm and the relevant paths not satisfying the property.
however it is impossible to avoid all these paths.
what we propose is to explore the off path branches along which the paths are most likely to satisfy the property.
the novelty of the guided dse is the design of the algorithm to evaluate the possibility of an off path branch along which there exists an accepted path.
to this end the evaluation uses the history and future behaviors of the off path branch.
for an off path branch b the history ofbis described by the states of the fsm that the current execution path has reached up to b. the future ofbis described by the states of the fsm from which the final state can be reached by the execution of theprogram after b. we calculate the history in the dse process and the future statically using backward dataflow analysis.
if the intersection of the history and future of bis not empty there is likely a path along bsatisfying the regular property.
we have implemented the guided dse for java programs based on jpf jdart and wala .
the tool is applied to analyze real world open source java programs a total of 225k lines of code against representative regular properties.
the experimental results indicate that the guided dse is more efficient than the pure dse with a lower time overhead and an acceptable memory overhead.
the main contributions of this paper are as follows the algorithm for guiding dse with respect to regular properties with the synergy of static analysis and dynamic analysis the algorithm can find the program paths satisfying a regular property effectively and efficiently.
the prototype tool of the guided dse for java programs it is applied successfully to analyze real world java programs with respect to regular properties.
extensive experiments the results show that the guided dse has an average 1880x speedup on the iterations needed to find the first accepted path and an average 258x time speedup for finding the first accepted path on the programs whose path space is bigger than .
furthermore for out of the programs guided dse successfully finds an accepted path in one hour reproducing a known typestate bug whereas the pure dse fails for these programs in hours.
the rest of this paper is as follows.
section ii motivates our approach.
section iii elaborates the details.
section iv presents the implementation and evaluation.
we discuss related work in section v and conclusion in section vi.
ii.
m otivating example to motivate the guided dse fig.
shows a program that uses an inputstreamreader to read a file.
procedure foo has three integer parameters and two loops in lines and lines respectively.
if tag is the reader w an instance ofinputstreamreader is closed before the second loop line and a java.io.ioexception may be thrown at line .
for a reader we are concerned with the regular property that method read is performed after method close .
fig.
is the fsm denoted by mr of this property where init object initialization e.g.
line close andread method invocations are the events.
we suppose that an event is atomic i.e.
no other events can be observed during its execution.
consider the initial input i1 m n tag .
the first iteration of dse is shown by fig.
.
in the first execution path shown by the leftmost path of the graph the body of each loop is executed once only.
this execution path generates the sequence init read read of events driving mrto state q1.
for this path the path condition pc 1is the conjunction of five conditions m m tag6 n 0andn denoted by c1 c5.
here c1 andc2are from statement st1while k m c3from st21int foo int m int n int tag q0 file file new file ... q0 inputstreamreader w new inputstreamreader new fileinputstream file q1 q2 q3 int result q1 q2 q3 int k q1 q2 q3 while k m q1 q2 q3 q1 q2 q3 int i w.read q1 q2 q3 if i break q1 q2 q3 result i q1 q2 q3 q1 q2 q3 if tag q1 q2 q3 q1 q2 q3 w.close q2 q3 q2 q3 k q2 q3 while k n q2 q3 q2 q3 int i w.read q2 q3 if i break q2 q3 result i q2 q3 q3 return result fig.
.
an example program q0 start q1 q2 q3initread close readclose read closefig.
.
the fsm specifying the bug postset q1 q2 q3 st1 c1 m 0preset q1 ......st1 c2 m ......st2 c3 tag!
...... postset q3 st3 c4 n ...... postset q2 q3 st3 c5 n ......selected in dfs strategyselected in regular property guided dsei r ri init rr e a db1 b2 b3 b4 b5preset q1 postset q1 q2 q3 preset q1 postset q1 q2 q3 preset q1 preset q1 fig.
.
difference between guided dse and pure dse if tag andc4 c5from st3while k n .
let b1 b 5be the corresponding off path branches of c1 c respectively.
clearly to reach state q3ofmr we need an input that can steer the execution to cover line which lies immediately after b3.
we can see b3needs the least iterations to get an accepted path.
with depth first search strategy b5will be selected and we havepc0 hm m tag6 n n 1i.
consider the generated input from pc0 1isi2 m n tag .
then in the second iteration the path condition ishm m tag6 n n n 2i andthe body of the second loop is executed twice.
similarly in the subsequent iterations the second loop would be unrolled repeatedly until the upper bound is reached.
this implies that line will not be executed until the conditions from the second loop line are drained.
if we use breath first search strategy we still need many iterations before reaching line .
the reason is that the two loops generate a plenty of conditions during dse and the search procedure does not know it is necessary to execute the statement at line to reach q3.
with the same initial input the guided dse needs only two iterations to find the target path.
the guided dse first calculates the future behavior information denoted by postset of each program point ptusing a context sensitive dataflow analysis.
for each state qinpostset there exists at least one static path1along ptthat can drive the fsm from qto a final state.
we use the comment of a line in fig.
to show the postset of the program point below that line.
for example the comment in line indicates that the program after line not including line may reach q3from state q1 q2orq3.
also the guided dse calculates the history behavior denoted bypreset of an off path branch b. the preset ofbcontains the states of the fsm that can be reached by the execution up tob.
fig.
shows the preset ofb3isfq1g.
this is because the event sequence init read before b3reaches state q1.
fig.
displays the preset andpostset ofb1 b .
the guided dse uses preset andpostset to select the off path branch to explore preferentially.
if the intersection of thepreset andpostset of an off path branch bisempty there will be no accepted path along b and b is given a low priority to be selected for exploration2.
for example b5is not selected for the next iteration as the preset andpostset of b5arefq1gandfq2 q3g respectively.
in the case when the intersection of the preset andpostset ofbis not empty the paths along bare possible to satisfy the property.
for different bandb0 if the interaction of the preset andpostset ofbcontains a larger number of states than that of b0 the guided dse assigns a higher priority to b. when the interactions of the postset andpreset ofbandb0 have the same number of states a higher priority is given to the deeper branch to limit the repetition of path exploration.
in our example b3is selected and pc0 hm m tag 0i.
the execution with the new input generated by solving pc0 1covers line to find an accepted path in only two iterations.
iii.
r egular property guided dse in this section we elaborate the details of regular property guided dse.
a. dse algorithm algorithm shows the worklist based search procedure.
the inputs are the target program p the fsm mpand the initial input i0.
the algorithm explores the path space of pto find the paths that can be accepted by mp.
1a static path is only a static path segment but not necessarily feasible.
2in section iii b we explain why bis not deleted.algorithm regular property guided dse data program p fsm mp initial input i0 1begin worklist i i0 computepostset p m p while true do runandmonitor i m p ifreach final state then report path saveoffpathbranches worklist ifworklist then exit pc getfirstsat worklist i solver pc the worklist stores the off path branches that are yet to be explored in order.
initially the worklist is empty and the input iis set to the initial input i0 which is generated randomly or manually line .
the function computepostset p mp line computes the postset of each location in pagainst mp elaborated in section iii d .
function runandmonitor i feeds pwith input iand executes pboth symbolically and concretely line .
during the execution mpis used to check whether the sequence of the events in the execution path satisfies the regular property.
when a final state of mpis reached the current input iand the path being explored are reported line .
since dse executes the program concretely algorithm does not generate false alarms.
then the function saveoffpathbranches worklist saves all the off path branches toworklist in the order of their priorities discussed in section ii and elaborated in section iii b .
the function getfirstsat worklist fetches the first feasible off path branch from worklist according to which the next input is generated.
the while loop from line to line iteratively explores different paths until worklist is empty line .
more details such as divergence handling are omitted for brevity.
the main procedure of algorithm differs from the standard worklist based search procedure of dse.
firstly each execution is monitored to check whether the current path can be accepted by mp.
secondly the preset for each off pathbranch is calculated and maintained during execution.
thirdly the evaluation of an off path branch is new which is discussed in the following subsection.
b. evaluation function to find the paths that can be accepted by mpwith the least number of iterations the evaluation function should be designed to assign the highest priority to the off path branch bsuch that there is a path along bthat can be accepted by mp and the distance measured by the number of branch statements between band the final event before reaching the final state is the shortest.
there are two difficulties in deciding the priority of an off path branch b. the first difficulty is how to evaluate thehistory of b. if we consider all the possible sequences of the events in the static path prefix of b the history of b contains all the states that can be reached by the sequences of the events.
we use preset ideal ptb cb to denote this ideal history where ptbandcbare respectively the program point and the call string of b. however it is in general too costly to compute the ideal history for an off path branch.
we decide to compute an approximation denoted by preset ptb cb by only considering the current execution up to b obtained in the dse procedure elaborated in section iii c .
the other difficulty is to evaluate the future of b. in theory computing the future behavior after arbitrary branch bcan be reduced to the halting problem.
inspired by static typestate analysis we propose an efficient and yet precise enough method.
as for the history we define postset ideal ptb cb to be the set of the states in mrfrom which a final state of mrcan be reached by the execution of the program after bunder the context cb.
let h ptb cb jpreset ideal ptb cb postset ideal ptb cb j then h ptb cb 0iffthere exists at least one path along b that can be accepted by mp.
we can prune bifh ptb cb .
therefore h ptb cb reflects the possibility of the paths along bto be accepted by mp.
note that for two off pathbranches b1andb2 h ptb1 cb1 h ptb2 cb2 does not mean less iterations are needed to explore b1.
this is because we do not know how many iterations after b1orb2are needed to find an accepted path.
aspostset ideal ptb cb is in general not computable we compute an approximation denoted by postset ptb cb .
for this we use a call strings based context sensitive and interprocedural dataflow analysis elaborated in section iii d .
let h ptb cb jpreset ptb cb postset ptb cb j static analysis does not consider the feasibility of a path.
thus postset ptb cb may contain the states that do not occur in postset ideal ptb cb and h ptb cb 0does not guarantee the existence of an accepted path along b. we tend to compute an over approximation for postset i.e.
postset ideal ptb cb postset ptb cb .
however due to the limitations of static analysis used in our approach we cannot guarantee the result is always an over approximation.
to ensure the soundness we assign ba very low priority if h ptb cb instead of pruning it for possible exploration.
another factor affecting the priority of an off path branch bis the distance between band the target point where a final state of mpcan be reached.
for b2andb3in fig.
we have h ptb2 cb3 h ptb3 cb3 .
but the distance between b2and the statement whose execution can drive mrto the final state line in fig.
is larger.
thus it would be better to select b3overb2 as the search procedure is likely to need fewer iterations to reach the target.
if h ptb cb h ptb0 cb0 the deeper branch is assigned a higher priority.
this strategy is based on the fact that in many cases a deeper branch is a descendant of the branch with a shorter depth.based on the above analysis we define the evaluation function h b cb h ptb cb depth b max where depth b represents the depth of b and max is a large constant that is greater than the depth of any branch.
note that depth b max is less than thus the depths of branches decide the priorities of bandb0when h ptb cb h ptb0 cb0 .
algorithm decides the order of worklist .
the priorities of elements in the worklist are based on h b cb and the strategy discussed earlier.
algorithm compare the evaluation value data off path branches b1 b2with program points ptb1 ptb2 and call strings cb1 cb2 1begin h1 jpreset ptb1 cb1 postset ptb1 cb1 j h2 jpreset ptb2 cb2 postset ptb2 cb2 j ifh1 h 2then return b1 ifh1 h 2then return b2 else return depth b1 depth b2 ?b1 b2 c. computing preset thepreset is computed on the fly during dse.
we use the fsm of the regular property in the same way as a monitor in runtime verification .
the monitor inspects the sensitive objects that are the runtime objects of the class or interface specified in the fsm.
when a sensitive object is created its corresponding monitor will also be initiated.
when a method of the object is invoked an event is generated if the invocation corresponds to an event in the fsm and the event is sent to the monitor for carrying out a state transition.
without loss of generality we suppose that there is only one regular property that is analyzed at a time.
we maintain a map d sd!sidfrom the identities of sensitive objects to the identities of the monitor instances.
an event from a sensitive object ois only monitored by the monitor instance identified byd o .
for example when monitoring the property in fig.
the events of different objects of inputstreamreader are monitored separately by their corresponding instances of mr. in correspondence preset ptb cb is represented as a set of pairsfsjs id q g where idis the identify of the sensitive object created when the execution reaches ptbin the context of cb and qis the current state of the monitor identified by d id .
for example the preset ofb3in figure isf idw q1 g where idwis the identity of the object created at line .
d. computing postset we now describe how to compute the postset .
we use a backward dataflow analysis to check a regular property on the control flow graph cfg of the program.
inspired by the backward analysis in we use the reversed fsm as the monitor during the backward dataflow analysis.letmbe an fsm and lbe the language accepted by m. the reverse of m denoted by m accepting the mirror language of lis obtained as follows first swap initial and final states and reverse all the edges and then determinize the fsm .
note that one state of mmay correspond to a set of states in m. fq3g start fq2 q3gfq1 q2 q3gfq0greadcloseread close initread close fig.
.
the reversed fsm of mrin fig.
for example fig.
shows mrofmrin fig.
.
the second state in mrisfq2 q3g which means executing event read from q2orq3can reach a final state of mr. in general when we carry out the backward dataflow analysis for a program against an fsm m mis used to monitor the state of a static object calculated by pointer analysis until a fixed point of postset is reached.
thepostset ptb cb is represented by a set of pairs id q where idis the identity of a static object and qis the state in mfrom which the execution of the program after ptbunder the call string cbcan reach a final state of m. for example the program in fig.
has only one static object ofinputstreamreader line .
we denote its identity by or and use mas the corresponding instance monitor.
in the initial configuration of the backward dataflow analysis the monitor mis in statefq3g.
this is because the execution of line does not involve any event of m. when the first iteration of dataflow analysis procedure progresses to the statement at line the state of the monitor changes to fq2 q3g and the state information at the location between line and line becomes stable with postset f or q2 or q3 g. when the dataflow analysis reaches the branch statement at line the two branches are merged by a join operation to change the postset of the program point above line to f or q1 or q2 or q3 g. note that the program in fig.
is not interprocedural.
for an interprocedural program we use the ifds framework to encode our problem to enable an interprocedural backward dataflow analysis.
e. ifds encoding for the dataflow analysis of a program with method invocations ifds works on the interprocedural control flow graph icfg of the program that connects the cfgs of the individual procedures.
in ifds the semantics of each node in icfg is interpreted as a flow function whose input is the facts that hold before the node and output is the facts that hold after executing the statement of the node.
in principle ifds converts an interprocedure dataflow analysis problem to a graph reachability problem with a polynomial time solution.
encoding an ifds problem contains the definitions of four kinds of flow functions call to start exit to return call toreturn andnormal functions.
for more details about the ifds framework readers can refer to .
in the calculation of postset for a program and an fsm m a dataflow fact is an element in d o s where ois the set of the identities of the static objects in the program and s is the state set of m. note that dis finite.
the dataflow facts are mainly manipulated by the call to return flow functions.
letfcrbe the call to return function of a method invocation statement objectref.methodname ... denoted by m .
if the execution of mdoes not correspond to any event of m fcris the identity function.
otherwise let embe the event executing m omthe set of the identities of the static objects of the reference objectref calculated by pointer analysis init the initial state of m and succ q e the successor of state qin mby the transition made by the event e. then fcr d!dis the smallest function that satisfies the following three conditions for each o q 2domain fcr ifo 2om o q range fcr otherwise o succ q es 2range fcr .
this means the events of a static object change the state of the monitor.
ifsucc init e m exits we have o succ init e m range fcr for each oinom.
this implies a new monitor instance is created for a static object o. ifobjectref points to multiple static objects i.e.
jomj domain fcr range fcr .
alias is handled conservatively by keeping all the possible facts.
all normal functions and exit to return functions are the identity function because their corresponding statements do not affect dataflow facts.
if the execution of an invocation statement smis an event the call to start function fcsofsm iskillall which is a special flow function that kills all the facts .
the reason is that an event is atomic and there is no need to analyze the internal statements.
if the execution of smis not an event fcsis the identity function.
the flow functions defined above are distributive over the union operator on sets of facts which is an essential requirement of ifds framework .
after getting the dataflow facts we can directly transform the facts to the corresponding postset by using the state mapping between mandm.
for example the set of dataflow facts between line and line in fig.
is f os fq2 q3g os fq1 q2 q3g g and the corresponding postset isf os q1 os q2 os q3 g. in theory for a call strings based context sensitive dataflow analysis a larger bound of call string improves the precision but also increases the overhead of the analysis.
a practical analysis often seeks an appropriate bound to get a balance between precision and efficiency c.f.section iv c .
furthermore there is no accepted path of the program when an over approximation is obtained by the analysis and postset pte does not contain the initial state of m wherepteis the start point of the program and is the empty call string.
in this case there is no need to perform dse anymore.
however due to the limitations of static analysis it is sometimes hard to get a non trivial over approximation.
f .
discussion our guided dse combines the complementary advantages for precision and scalability.
the static analysis phase mainly contains the two procedures that construct icfg and compute postset respectively.
the former is commonly used and the latter is essentially the static typestate checking by backward dataflow analysis .
the worst complexity of the algorithm solving ifds problems is o jej jdj3 wherejejis the number of the edges in icfg and jdjis the size of the fact domain.
the dynamic analysis uses the object sensitive runtime checking in runtime verification.
our approach has the following advantages scalability the main procedure of our approach is dse which is more scalable than traditional symbolic execution because of utilizing concrete execution.
the dynamic and static analyses for calculating guiding information are also scalable.
absence of false positive compared to static analysis techniques our approach does not produce any false alarm since dse executes programs concretely.
replay our approach can generate the paths satisfying the regular property while static analysis does not.
there are sources of imprecision in the guided dse the imprecision of preset andpostset in comparison with preset ideal andpostset ideal and the imprecision of the interoperation of dynamic and static analyses.
the imprecision will be empirically evaluated in section iv c. when evaluate the history of an off path branch b we actually use the prefix of the current path up to b rather than that of an unexplored path along b. this may cause imprecision when the event sequence in the prefix varies with the input.
the source of the imprecision of postset includes the following three aspects the current state of art of static analysis e.g.
complex mechanisms of programming languages bring obstacles to static analysis the intrinsic imprecision of dataflow analysis where the feasibility of paths is not considered the static analysis for postset does not consider the return values of invocations for efficiency.
consider the program in fig.
.
the next method may be inappropriately invoked when the hasnext invocation returns false .
however our static analysis considers that the program obeys the contract of iterator i.e.
anext invocation should be preceded by an invocation of hasnext withtrue return value.
1boolean result iterator.hasnext 2result result ... 3if !result iterator.next fig.
.
example of the unsoundness of static analysis the interoperation of dynamic and static analyses is also imprecise.
preset is calculated for runtime objects whilepostset for static objects.
in equation a runtime object and a static object are considered as equivalent if they originate from the same statement.
however an object creation statement inside a loop may create multiple runtime objects all of which are related to one static object in static analysis.
iv.
e valuation we evaluate the guided dse on the following two questions effectiveness and efficiency .
can the guided dse effectively find the paths satisfying a regular property?
how efficient is it compared with the pure dse?
overhead .
is it costly to compute the information for guiding dse?
the overhead should be acceptable compared with the resources needed for dse.
a. implementation we have implemented the guided dse for java programs based on the dse engine jpf jdart jdart for short and the static analysis platform wala .
our implementation has improved many modules of jdart including the core control module the core data structures etc.
these improvements substantially enhance the efficiency scalability feasibility and robustness of jdart.
for example we use a tree to store the explored part of the path space and glazed lists library to implement the worklist.
to enhance the feasibility of jdart further we have integrated jpf nhandler into jdart which helps spf jpf to handle the environment problem automatically.
in the implementation of the static analysis the values of postset are stored in a cache so that they can be obtained instantaneously during dse.
the dynamic analysis is implemented as a listener in jpf.
b. experimental setup table i lists the programs in our experiments.
the thirteen programs are all real world open source java programs.
the number of lines of code loc is counted by metrics .
table i the programs used in the experiments program loc brief description rhino a javascript interpreter schroeder sampled audio editor soot c static analysis tool toba s java bytecode to c compiler jlex lexical analyzer bloat java bytecode optimization bmpdecoder bmp file decoder ftpclient ftp client in java htmlparser html parser in java fastjson json library from alibaba udl udl language library jep mathematics library sixpath xpath library total open source programs the first four programs rhino a schroeder soot c andtoba s are from the ashes suite3benchmark.
jlex is a lexical analyzer for java.
bloat is from the dacapo .
bmpdecoder is a widely used java library for decoding bmp files in which many bit operations are used.
ftpclient is an ftp client program with often used parameters of ftp operations.
the rest of the programs are library programs such as htmlparser for parsing html pages and fastjson for json strings.
table ii bug properties used in the experiments property meaning enumeration call hasmoreelements before nextelement iterator call hasnext before next reader do not read a closed stream writer do not write a closed stream socket do not use a closed socket the regular properties in our experiments can be classified into two categories.
the properties in table ii are for bug finding noted as bug regular properties in the rest of this paper .
we use these properties to check the first eight programs listed in table i. these properties are also widely used in the literature on typestate analysis.
the second category of properties are application specific and defined manually.
for example for htmlparser we specify a user defined regular property that requires the input to be a jsp string i.e.
formatted as ... .
we create a test driver for each library program to provide the entry point for analysis.
the initial inputs for dse are constructed randomly.
for soot c bloat andftpclient we set the input arguments to be symbolic variables.
this is why the path spaces of these three programs are small.
for the other programs we set each input byte to be symbolic.
for each program property combination we carry out both the pure dse and the guided dse for the purpose of comparison.
since exploring all the paths of each program is usually infeasible we limit the time for each analysis to hours .
all the experiments are carried out on a server with 256gb memory and four .13ghz xeon cpus using jdk .
.
we run each analysis with 10gb heap memory of jvm.
c. effectiveness and efficiency table iii shows parts of the experimental results of both the pure dse denoted as pure in the table and the guided dse denoted as guided in the table .
the iters column shows the number of the iterations for finding the first accepted path the time s column shows the time needed for finding the first accepted path where the numbers in the brackets are the time for static analysis.
the four columns in the paths column show the numbers of the accepted paths the relevant paths with ratio the irrelevant paths and the total paths explored during each analysis respectively.
we have automatically found two known typestate bugs in rhino a andbloat which are reported originally in and as potential bugs but confirmed manually.
for the other six programs checked against bug properties we find no bug within hours.
since the violations of the properties listed in table ii are often serious bugs.
we believe that most of these bugs are fixed during development where our tool can be used appropriately as a bug finder.to evaluate our approach further we randomly inject bugs into the target programs as follows.
we collect all the branch statements that make the execution tree of a program during the pure dse then we randomly select three branches to inject an event statement with respect to the property e.g.
an invocation of method close for socket property.
in table iii programs with injections are tagged with bugx .
in fact an injection may not cause a bug.
this is also validated by the experimental results e.g.
schroeder bug3 andtoba s bug2 .
the programs without bugs are not displayed in the table.
table iii shows for out of combinations .
the guided dse successfully finds at least one path satisfying the property while the pure dse fails for combinations in hours.
for jlex bug3 both methods fail to find a bug.
this result shows the effectiveness of our guided dse in finding the paths satisfying a regular property.
table iii also shows that out of the program property combinations need the same or fewer iterations for the guided dse to find the first accepted path.
for the combinations on which an accepted path is found the average speedup of the guided dse on the number of the iterations for finding the first accepted path is more than 1880x.
the time used for static analysis ranges from .24s bmpdecoder to .5s soot c .
the speedup on the time for finding the first accepted path of the programs whose path space contains more than paths is more than 258x in average.
for those programs with small path spaces such as bloat soot c andftpclient the guided dse does not outperform the pure dse.
this is because the path spaces is so small that the static analysis dominates the time of the whole analysis.
overall compared with the pure dse in finding the first accepted path the guided dse needs much less iterations and is much more efficient on the analysis time for programs with large path spaces.
we further inspect the guiding ability of the guided dse from the following three perspectives the percentage and the distribution of the relevant paths during analyses.
we not only want to explore more relevant paths but also earlier.
the number of state transitions along a path.
if there are no state transitions along a path the path will not be accepted even if there are sensitive objects created along the path except for the trivial case in which the initial state is also a final state .
the shortest distance to the final state at the end of a path.
to some extent this perspective reflects how close a path is to be accepted.
the distance is if a path is already accepted 1if there is no sensitive object generated during the path and otherwise the shortest distance from the current state to the final state of the monitor when the path is finished.
table iii lists the numbers of different kinds of paths explored during analysis and the percentage of the relevant paths in each analysis.
for out of the programs the guided dse has a higher percentage of relevant paths thantable iii experimental results s.a. static analysis programmodefirst path paths property iters time s s.a. accepted relevant ratio irrelevant total rhino a enumeration pure 24hours .
guided .
.
.
bloat iterator pure .
guided .
.
schroeder bug1 reader pure .
guided .
.
schroeder bug2 reader pure .
guided .
.
soot c bug1 writer pure .
.
guided .
.
.
soot c bug2 writer pure .
.
guided .
.
.
soot c bug3 writer pure .
.
guided .
.
.
toba s bug1 reader pure .
guided .
.
toba s bug3 reader pure .
guided .
.
jlex bug1 reader pure .
guided .
.
jlex bug2 reader pure .
guided .
.
jlex bug3 reader pure 24hours guided 24hours .
bmpdecoder bug2 reader pure .
guided .
.
bmpdecoder bug3 reader pure .
guided .
.
ftpclient bug1 socket pure .
guided .
.
ftpclient bug2 socket pure .
guided .
.
htmlparser userdefined pure .
.
guided .
.
.
fastjason userdefined pure 24hours .
guided .
.
udl userdefined pure .
.
guided .
.
.
jep userdefined pure .
.
guided .
.
.
sixpath userdefined pure 24hours .
guided .
.
.
the pure dse.
the only two exceptions are htmlparser andjep for which the percentage of relevant paths of our method is slightly lower.
in addition to the percentage we also want to explore relevant paths earlier so that the target paths can be found earlier.
for this we select the program property combinations for which a plenty of relevant and irrelevant paths are explored and observe the distribution of the relevant paths in the first hour of analyses.
the guided dse explore relevant paths earlier than irrelevant paths.
fig.
shows the distribution of the relevant paths during the first one hour.
the x axis represents the time in seconds during analysis.
the y axis represents the number of the relevant paths that are explored at each second.
we can see that the guided dse explores more relevant paths at thebeginning and the number starts to decrease from about seconds.
in contrast the number of the relevant paths explored by the pure dse increases after seconds.
besides fig.
also shows the guided dse tends to explore more relevant paths than the pure dse.
fig.
shows the difference between the numbers of state transitions of the guided dse and the pure dse.
the x axis represents the order of the paths in which they are explored and y axis is the difference between the numbers of state transitions of the path under the guided dse and that of the path under the pure dse.
for the ith path pi the value on y axis of piis calculated as follows.
v alue i x c2combinationsstc g pi x c2combinationsstc p pi 3500number of relevant paths time s pure guidedfig.
.
relevant path distribution where stc g pi andstc p pi are the numbers of the state transitions in piwhen analyzing combination cwith the guided dse and the pure dse respectively.
fig.
shows the results of the first thousands paths.
for .
of the first the guided dse causes more state transitions than the pure dse.
although for some of the rest paths the pure dse causes more state transitions there are still .
of the points above on fig.
.
this shows the guided dse causes more state transitions.
10000state transition difference path order fig.
.
state transition difference in each path we also inspect the guided dse from the perspective about the shortest distance in a similar way.
fig.
displays the sum of the distance of the ith path in each combination.
we can see for .
of the paths the distance to the final state under the pure dse is larger than that under the guided dse.
this indicates the guided dse tends to explore the paths that drive the fsm closer to a final state.
call string bound.
in theory the larger the bound of the call string the more precise the analysis result will be.
in our experiments we have tried different call string bounds to for all the combinations.
one of the findings shows that to complete the analysis in an acceptable time the call string bounds are often confined to be less than due to the scale of the programs.
for example for soot c and 10000shortest distance to the final state path orderpure guidedfig.
.
shortest distance of each path udlparser the static analysis phase does not finish in one hour if the call string bound is larger than .
another result of the experiment shows that the guided dse gains no improvement in the analysis precision with increased call string bounds.
the reason is that real world programs usually have complex call graphs.
hence in our experiments the call string bounds are set uniformly to .
the precision of guiding .
we evaluate the precision of the guiding information as follows.
during dse we directly prune away the off path branches for which the intersections ofpreset andpostset are empty and compare the results with those in table iii.
we can see the same results for out of the combinations.
this indicates that the guiding information for dse is pretty precise for the combinations.
d. overhead in general the time memory overhead varies with the scale and complexity of the target program.
compared with the pure dse the time overhead of the guided dse is mainly caused by the static analysis.
in our experiments the time overhead is very low less than for most programs.
for programs soot c bloat andftpclient however the time overhead is bigger than .
the reason is that static analysis dominates the whole analysis time due to the small path spaces of these programs.
the extra memory overhead consists of the memory used for static analysis and the memory used to store the call string and preset for each off path branch during dse.
for we use jconsole to monitor the memory overhead during static analysis.
the memory used for static analysis ranges from 461mb schroeder to 2gb soot c .
it is necessary to point out this result may change under a different configuration because of the memory management mechanisms of jvm.
for we calculate the memory for storing call string and preset by the memory size calculation tool jamm for java.
the results show this part of memory overhead is less than 55mb in most cases.
the only exception isschroeder bug2 which needs 580mb.
the reason is that too many symbolic variables are introduced during dse.
overall the memory overhead is acceptable.e.
threats to validity the threats to the validity of our experiments are mainly external because of the limited samples of program property combinations.
we have used real world open source java programs and the locs of these programs vary from .5k to 45k.
five of these programs are from java program analysis benchmarks and these five programs are also used in the existing work of static typestate analysis .
these programs cover different types of applications and libraries including parsing optimization network etc.
some of these programs are used widely such as fastjson .
these programs are quite representative for evaluating dse methods.
in addition although our target programs in this paper are java programs our approach can be used for analyzing the programs in other languages such as c and c .
for the properties used in the experiments the properties in table ii are representative contracts of java libraries and are also frequently used in typestate analysis.
the application specific user defined properties are defined by ourselves.
these properties are not complex fsms and are easy to define.
we believe that user defined properties are an important part during the application of our guided dse in practice.
v. r elated work the methods of guiding symbolic execution have been proposed for different goals including improving coverage reaching a statement checking a rule and exploring the difference between versions of a program etc.
both approaches presented in and slices programs or paths against a rule to prune paths during symbolic execution.
the method in first slices the program after the instrumentations for checking a regular property and then feeds the sliced program into klee for symbolic execution to detect bugs.
hence there is no guiding support during the symbolic execution for checking the regular property.
the ruledirected symbolic execution is most related to our work.
there path slicing is used to slice the irrelevant parts of the current path to prune irrelevant paths or the relevant paths equivalent to the current.
the guided dse and the path slicing based approach in complement to each other.
our guided dse can provides a priority order for the off path branches to be explored whereas the slicing based approach prunes redundant off path branches.
in addition when the current explored path is irrelevant the approach in prunes the offpath branches along which there will be no event.
the guided dse not only gives a lower priority to the pruned branches but also gives different priorities for the remaining branches.
in our experimental results c.f.table iii the portions of the irrelevant paths in many programs under the guided dse are not low.
the existing work for guiding symbolic execution toward reaching one statement uses the information of the distance to the target statement for guiding.
in a backward symbolic analysis method is proposed to infer the weakest precondition for reaching a statement.
the work in proposes a static analysis method to generate a shortest path to cover multiple statements as more as possible.
our work can be used to achieve the same goal of reaching one or multiple statements because fsm is expressive enough to specify reachability properties.
the methods for statically analyzing programs against regular properties differ mainly in soundness precision and scalability.
sound methods usually used for verification abstract the target program using different abstract domains to have a tradeoff between precision and scalability.
some methods e.g.
are neither sound nor complete but they have been validated to perform well on bug finding.
dynamic methods such as runtime verification complements the static methods by improving scalability and precision but with the sacrifice of soundness.
we combine static analysis and dynamic analysis to analyze a program against regular properties.
finally the tools of software model checking such as slam use static analysis to extract a model from a program and check the model against regular properties to find bugs or verify the program.
yogi improves slam by the synergy of dse and predicate abstraction to make the analysis faster .
compared with the work in yogi the guiding method of our guided dse uses a static analysis with a polynomial complexity which leads to a better scalability.
vi.
c onclusions and future work this paper proposes a new dse method called regular property guided dse to automatically find the program paths satisfying a regular property.
with the synergy of static analysis and dynamic analysis the guided dse is effective and scalable in finding the paths satisfying a regular property.
we have implemented the guided dse for java programs.
the results of the extensive experiments on real world programs show that our method is highly efficient for steering dse against regular properties.
future work will be in several directions until now no regular property involving multiple objects is supported.
we will investigate how the guided dse can be extended to solve this problem.
we are also interested in developing a guiding method for other types of properties such as context free properties.
the precision and efficiency of our guiding method can be improved by using more advanced alias analysis techniques .
furthermore we plan to work on the applications and optimizations of our method on some specific software engineering topics e.g.
typestate analysis and path oriented test case generation.