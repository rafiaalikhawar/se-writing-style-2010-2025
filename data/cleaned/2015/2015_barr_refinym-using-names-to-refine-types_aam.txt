refinym usingnames to refine types santanu kumardash universitycollegelondon london uk santanu.dash ucl.ac.ukmiltiadisallamanis microsoft research cambridge uk miallama microsot.comearlt.barr universitycollegelondon london uk e.barr ucl.ac.uk abstract source code isbimodal it combines a formal algorithmic channel andanaturallanguagechannelofidentiiersandcomments.inthis work we model the bimodality of code with name lows an assignment low graph augmented to track identiier names.
conceptual types are logically distinct types that do not always coincide with program types.
passwords and urls are example conceptual types that can share the program type string.
our tool refinym is an unsupervised method that mines a lattice of conceptual types from namelowsandreiiesthemintodistinctnominaltypes.for string refinym inds and splits conceptualtypes originally mergedinto a single type reducing the number of same type variables per scope from .
to .
while eliminating .
of scopes that have more thanonesame typevariableinscope.thismakesthecodemore self documenting and frees the type system to prevent a developer from inadvertentlyassigning data acrossconceptualtypes.
ccs concepts softwareanditsengineering datatypesandstructures keywords type reinement information theoreticclustering acmreference format santanu kumar dash miltiadis allamanis and earl t. barr.
.
refinym using names to reine types.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november 4 9 lake buena vista fl usa.
acm new york ny usa 11pages.htps introduction during development programmers tend to use imprecise types especiallyundertimepressure.forexample theymightcombine conceptuallydistincttypeslikepasswordsorlastnamesintoasingle built intypelike string.workingwithasimplertypehierarchy helps rapidprototyping but comesat a cost.the members ofthis coarse grainedtypelatticeoftendonotnaturallybelongtogether and are a source of bugs at deployment.
for example if a program this research was funded by the engineering and physical sciencesresearch council epsrc grant ep p005314 .
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forproitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation ontheirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspeciicpermission and or a fee.
request permissions from permissions acm.org.
esec fse november 4 9 lake buenavista fl usa copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
htps config.
et fxcm server ... 2varterminal config.
et fxcm terminal ... 3varusername config.
et fxcm user name ... 4varpassword config.
et fxcm password ... 6vardownloader newfxcmdatadownloader server terminal username password 9foreach varticker in tickers 10if downloader.hassymbol ticker ... figure motivating example from the lean c project we lightlymodiied thecodeto it.
uses only built in types then invalid or dangerous operations like cost distance orstring.concat password lastname are type correct.thisisawell documentedproblemcalled primitive obsession thatoccurswheneveradeveloperavoidsdeiningbespoke types .
figure 1shows a classic example of primitive obsession in lean commithash f574bfd7 anopen sourcealgorithmictradingenginewritteninc .thissnippetconnectstoadataproviderforforeignexchangecapitalmarkets fxcm andsearchesfortickersymbols.
using it requires logging in through the fxcmdatadowloader class.thisclasstakesinfourarguments.allfourargumentsareannotated as strings intermixing disparate concepts such as server addresses terminals usernames and passwords with each other and plain text strings.
accidentally using the password in place of theusernamewould nottriggeratypeerrorandgounnoticeduntil theattacksurfaceisexploitedatruntime.robinmilnerfamously observed well typed programs don t go wrong .
here we see an example ofcode that typechecksbut isnot well typed.
conceptual types are the types the developer had in mind while writingaprogram.oftentheycoincidewiththeprogram stypes but sometimes as with primitive obsession they are not explicitly deinedandarelatenttoaprogram sexplicittypehierarchy.inthis work wecombatthisproblem includingprimitiveobsession by assisting developers to identify reinements of a program s type lattice we mine conceptual types then suggest their reiication intoactualtypes.todiscoverlatentconceptualtypes weintroduce refinym atoolthatautomaticallyminesconceptualtypes then presentsthemtodeveloperstohelpthemdeineamorespeciictype thatsurfacesdistinctconceptualtypes theirvaluesandbehaviours tothetypechecker.
refinym usesdatalowandnameinformation todetectconceptualtypes.in figure1 refinym suggestsseparating allfourvariables server terminal username andpassword intodistincttypes sothatthetypecheckercanpreventadeveloper from carelesslydirectlyassigning between them.
we formulatetheproblem ofreining atypein ac program s typelatticeasasearch basedsoftwareengineeringproblem andsearchforvalidandcoherenttypelatticeswhoseelementsareaesec fse november4 9 lake buena vista fl usa santanu kumardash miltiadis allamanis andearl t.barr mixofexplicitandconceptualtypes.informationwithinidentiiers in the code and assignment lows between them constrains the search.
our approach is bimodalbecause it intermixes semantic information lows andsyntacticinformation names .ourmethod exploits lexical similarities to build a conceptual type lattice using theinformation theoreticprinciplethatacandidateconceptualtype is good if it minimizes the shared information distance between namesandtypes givenaconceptualtype thenamesofthevariables ofthattypeandnamesof themethodsthatreturnthattypeshould havelowentropy i.e.bepredictable givenavariableormethod name its conceptualtype should be easyto predict.
refinym constructs a name low graph section .
from a program that type checks.
a name low graph contains all the type constraints imposed by assignment lows in the program across variables and parameter bindings.
refinym then uses variation ofinformation aninformation theoreticobjective to clusterthe nodes of the name low graph subject to c s subtype rules section2.
.theseclustersarecandidateconceptualtypes.
refinym generates fresh names for these clusters and suggests them as type reinements.
if a developer accepts one refinym rewrites its input to use that type section .
refinym inds reinementsfor an existing program type so as asanitycheck weartiiciallycreateconceptualtypesbymerging user deined types then ask refinym to reconstruct them.
refinymexactlyreconstructed62 ofthesetypes section4.
.we haveequipped refinym witharewriterthatautomatesrefactoring acodebase to use its suggestedreinementsfor c asyntactically rich industrial language section .
software engineers care about howcodeevolvesinresponsetotheirneeds.someofthesechanges worsenthecodebase movingittowardacriticalpointwherefurther changescancascadeintoerror.ascopeinwhichtwoconceptual types share a primitive is such a critical point.
in these critical scopes the type system cannot prevent a developer from mistakenlyassigningvaluesfrom oneconceptual type totheother.over ourcorpus refinym automaticallyeliminates21.
onaverage of these critical scopes section .
while reducing the potential of inadvertently introducing cross conceptual type lows within scopesbydrasticallyreducingthenumberofsame typevariables perscopefroman averageof8.7to2.
therebyenablingthetype systemto betterprotectthe developer from herownmistakes.
contributions.
ourcorecontributionsfollow a wepresentan information theoreticnominaltypereinementmethodthatuses identiier names and datalow to mine conceptual types b we presentrefinym a practical c tool that implements our method and c we comprehensively evaluate refinym on real world open sourceprojectsandshowthatiteliminates21.
onaverage of potentialinadvertentlows.
refinym andour evaluationartifacts are available at htp github.com askdash refinym .
inferring conceptualtype lattices thelatenttypesinaprogramoftendiferfromthetypelatticein theprogramthedeveloperexplicitlydeinedwithtypeannotations.
we call these latent precise types conceptual types .
these types grouprelateddataandoperations.theyaresimilartoguo s et al.
s abstracttypes exceptthattheyarenotalwaysmoreabstract thanthetypesintheprogram stypelattice.weareinterestedin exepath filedir file c1 f filepath filedir path c2 dir path file str c3 str val val s str id c4 id figure conceptual clustering of a name low graph for string a node is a variable or a function while edges are assignments or actual to parameter bindings section .
.
refinym clusters nodes into conceptual types such as the shadowed areas.
here c1represents ile path c2general paths c4identiiers and c3arbitrary strings.
usingnamestoinferconceptualtypes thenlookforreinements that bring a program s explicit type lattice closer to its implicit conceptualtype lattice bysplitting the mergedconceptualtypes.
modernsoftwareengineeringpracticeunanimouslyagreeson theneedforwell namedidentiiers.indeed mostdeveloperschoose nameswithgreatcare .forexample namesofvariablesand functionsare selected insuch away that theyrelect their semantic role and function.
the correspondence between names and semanticsisa crucialcomponentwhenunderstanding code since developersthinksemanticallyaboutcodeandrepresentativenames facilitate this process .
for these reasons our core intuition is that variable and method namesareoftensemanticallyrichandcloselyrelecttheiridentiier s functionality and therefore provide strong information about an identiier s conceptual type.
speciically we observe that names tend to low into names that describe similar concepts following the general covariance and contravariance principles.
for example a numeric variable named distance sometimes lows into a numeric variable with a more abstract name like value but rarely the other way around.
therefore a program s data low imposes is a relationships among the names of the variables and methodsand consequently totheconceptstheydescribe.wecapture these relationships in a name low graph described next.
to recognize salient conceptual types we cluster the graph such that the inferred clusters along with the original unreined type as top and the standard bottom form a lattice figure .
in this work we focus on using discrepancies between the program s implicit concept type lattice and its explicit type lattice to ind and suggest typereinements.forexample whenthe stringclassholdsboth passwordsandsurnames refinym willsuggestdistinctsubtypes likepasswordstring andsurnamestring .
if a developer adopts these suggestions the type checker can then prevent the developer from mistakenlysharingdata between thesetypes.
.
the name flowgraph for each variable we need to collect the names whose values low intothatvariable.tothisend weaugmentastandardconstraintbasedtypesystemtocapturesingle stepnamelow thenbuilda graphforthevariable vwhosetraversaldeinestheinlowname closure of v. for the type correct program p letvbe its variables lbe its literals and mbe its method names.
for the function v refinym using namesto refine types esec fse november4 9 lake buena vista fl usa v 1 k 2 2 1 v v k l v k unit assignl v 1 v 2 2 1 v v v v v v unit assignv v 1 m e 2 2 1 v v m m v m e unit assignm e nelementl v m v 1 e 2 2 1 n names e v v n label n v e unit assigne e0 0mtype m p 0 e p p1 a1 pi ai pn an e0.m e invoke figure a constraint based system for typing variables augmented to update v the set of names whose values low into v our additions to standard rules are boxed invokemake formal to actual parameter bindings explicit for matchingby theassignment rules.
2v 2l 2m v is all the names that low into vvia an assignment or a formal to actual binding.
the names in v are type compatible under the assumption that ptype checks.
returns an elementfromadisjointunion where vtagsvariables ltagsliterals andmtags methods.
figure 3shows extensions to standard rules for typing variables that are relevant to refinym.refinym identiies reinement types for variables bound only to irst order terms.
therefore we only discuss the subset of rules related to variables invokeand the four rulesforcollecting constraintsfromexplicit assignments.
assignl assignv assignm andassigne handle assignments from constants variables methodreturns andallotherexpressions respectively.
in our irst order setting we handle method types by projecting them onto their constituent parameter and return types.
asusual theassertionsin figure3areoftheform v where is the type environment that maps types to terms in the calculus.
forsimplicityandwithoutlossofgenerality werestrict itoscalars.
we could have modiied all expression judgments to collect names but forbrevity focusedonassignment.alloftheassertionsinthese rulesarestandardwiththeexceptionoftheboxedassertionineach rule s conclusion and the e nelementl v minassigne.
the boxed assertionsusedisjointuniontoextend .ininvoke mtypereturns thetypeofamethod m p inaclass 0.theadditionalconstraint onassigne prevents its redex from overlapping those of the other assignment rules and is consequence of our decision to modify only assignment judgments.
we augmented invoketo convert m s parameter list pinto an explicit sequence of assignments to which our four assignments rules apply and collect name lows from actuals into m sformals.
assigne relies on two helper functions labelthat distinguishes literal variable and method names and namesthat extracts namesin the expression ethat are type compatible with vand adds them to the name low for v. consider intx strlen str y .
because of the assignm does not match strlenand we fall throughto assigne whichapplies names.thisfunctioncollectsall theassignmentcompatiblenamesfromanexpression here strlen andy.assigneaddsthesenamesto xinthename lowgraph.the methodnamesignoresstrbecause it is a parameter of strlen in otherwords methodinvocationsaresinksforthename lowsof theirparameters.
after building refinym uses it to construct the name low graphg n e .thenodesin narefullyscope qualiiedvariable method orformalnames.anedgeconnectstwonamesintwocases whenthesourcenameisontherhsofanassignmentandthe targetisonthelhsor2 whenthesourcenamestheactualboundto theformalname i.e.thetarget.the labelfunctionlabelseachedge.
because we collect name lows alongside type constraints onlyfor assignments and parameter bindings the name lows from literals variable and method returns are type compatible by construction thenamelowsfromthenamesusedinotherexpressionsmayor maynot be dependingonthe implementationof names .
infigure3 theboxedassertionsthatcollectnamesinto areindependentoftheunderlying standardconstraint basedtypechecking.
thus they can be adapted to other type systems including type systems that support partially typed programs via an any type wildcard.
figure4showshow evolvesacrossfunctionapplications.at thetopleftoftheigure wehavethe calcclasswhichhasamethod addthat takes two integers xandy as inputs.
maininvokesadd twice on lines and .
in each case invokeandassignm type the assignment expression.
for brevity figure 4merges the updates to these two rules make.
there are two dotted arrows leading to the type rulefor the twoassignment operations.
the solidarrows annotated withcircled numbers indicatehow changes as the two type rules are applied.
before line in main xandydo not have any name lows coming into them.
this is indicates by a in their s. the execution of line assigns the variablefsttoxandsndtoy.additionally throughtheassignment operator line also binds sumto the result of c.add.
in the conclusion of type rule we update s forx yandsumwith the informationabove.theassignmentinline7issimilarexceptthat itbindsyto aliteral.
.
clustering thegraph inthiswork weareinterestedinpartitioning clustering thenodes in a name low graph ginto clusters that form a lattice over the graph.theseclustersrepresentminedconceptualtypes.conceptual typesnameprogramvariablesthatshareacommonpurposeand identify operations over them figure .
precisely because they shareapurpose weexpecttheirnamestorelectthatpurposeto reminddevelopersaboutitandtheconstraintsitimposes.thus we expect names and conceptual types to be mutually informative.
to clusterg wethereforeexploittheinterplaybetweennamelows ingandthenamesofthevariablesandmethodsbyclustering.for example two variables that are not closely related in gbut share a name have a high chance of being related while two variables that haveverydiferentnamesbutwithverysimilarnamelowsarealsoesec fse november4 9 lake buena vista fl usa santanu kumardash miltiadis allamanis andearl t.barr c calc mtype add x y calc int int int fst int snd int p x fst y snd x x fst v y y snd v sum sum c.add m c.add fst snd int1public class calc 2publiccalc 4public int add intx inty 5returnx y 1public static void main ... 2calc c newcalc 3intsum fst 4intsnd fst 6sum c.add fst snd 7sum c.add sum x y fst fst l snd snd fst v sum x x fst v y y snd v fst fst l snd snd fst v sum sum c.add m x x fst v x sum v y y snd v y l fst fst l snd snd fst v sum sum c.add m c calc mtype add x y calc int int int sum int int p x sum y x x sum v y y l sum sum c.add m c.add sum int1 figure anexample ofhow which mapsdirectvalue exchangesbetween nodes evolvesovermethod invocations.
probablyrelated.toextractmaximalsignalfromnames weexploit theirinternal structure andextracttheirsubtokens equation3 .
the key problem then is to exploit these names to automatically ind groups of nodes in gthat are conceptually similar.
to achieve this we design a novel non parametric clustering method over graphsthatisbasedoninformation theoreticconcepts wedescribe itbelow.figure 2showsasample depictionofthe task.
intheclusteringmethodwepresenthere names e assigne infigure .
we made this choice because name lows across operators mustbe selective.
someoftheselowswouldconlate conceptual types.
thus handling operators would unnecessarily complicateour model so here we treatoperators as namelow breaks just asassignetreats functions.
to illustrate the problem imagine the concatenation of two strings of diferent conceptual types.
the outputmightbeyetanotherconceptualtype.forexample concatenating a username string with a delimiter string could result intoa csv string.correctlyaddressingthisproblemwouldrequire teaching the clustering method to be aware of operators polymorphic over conceptual types.
by excluding the cross operator name lowsthat assigneadds ourclusteringmethodcan inferthetypes of all involved terms by learning from their names and all other usages essentiallycircumventingthisproblemwithminimalloss ofinformation.further refinym toleratesinformationlossfrom notaddingcross operatorlowsthatdidoccurbecauseitusesprobabilisticmethodsthatrobustlyhandlenoiseandextrapolatefrom missingdata.notation.
letg n e be a name low directed graph.
let c partition nandci cbe a part of c. we equip each partition c with the function parentc c 2c.
its application parentc ci returns c n0 n1 e n0 c n1 ci alltheclustersof cthat contain a node directly connected to a node in ci.
we overload the notation for cto imply both the partition and the random variable of selecting some ci c since the intended meaning is clear from context.ncontains fully scope qualiied names but here we are only interested in the unqualiied name because the namespace preix adds noise for our task.
we use the function nameto extract the unqualiied name from a node.
as with c we overload nto referboththenodesin gandtherandomvariableofselectingsome name from name n n n .
finally we refer to cieither as a part oras acluster.
objective.
for the purpose of this explanation irst consider the case where we ignore the structure of gand simply partition n. saywecluster nsuchthateachpart cicontainsonlysimilarnames.
in the limit this would yield uninformative partitions that contain nodes with identical names.
instead we choose to minimize the variationofinformation1 vi betweennodenamesandparts.
vi naturallyrepresentsthetensionbetweencreatingtoomanyclusters thatdonotdifersigniicantlyortoofewthatarenotinformative abouttheirelements andisdeinedas vi c n h c n h n c h n c i n c 1viisalso known as shared information distance .refinym using namesto refine types esec fse november4 9 lake buena vista fl usa wherecandnare the random variables of the nodes cluster labelsandnames h a b istheconditionalentropyof agivenb h a b is the joint entropy of aandb andi a b is the mutual information between aandb.viis a true metric it obeys the triangular inequality.
computing h c n andh n c requires computing p c n andp n c .wediscussthemodelingchoices we madetoformulatetheseprobability distributions atthe end of this section.
intuitively tominimize equation1 wesimultaneouslyrequire positive answers to two questions given the name of node n can we easily predict the cluster part it came from i.e.p c n has lowentropy ?
and givenacluster canweeasilypredictthename of each node i.e.p n c should have low entropy ?
.
thus the goal is to pick a sweet spot among these two conlicting goals.
this sweet spot corresponts to the clustering that provides the conceptual types.
viselects a single trade of valuing h c n and h n c equally.ifweminimized h c n andh n c separately i.e.asamultiobjectiveoptimizationproblem wewouldretrievea paretofront ofoptimal solutions.
we choose vias our metric for three reasons.
first it is nonparametric it does not require us to specify the number of clusters upfront incontrast to methodslike k means .second it relies on information theoreticprinciplesthatcaptureourcoreintuitionthat conceptualtypesandnamesrelecteachother.finally itisatrue metric so we know that the theoretical optimalsolution yields a vi of0.
sofar wehaveignoredthestructurewithinthegraphandtreated each node separately.
however we want to cluster or partition or color gso that the parts form a lattice i.e.there is a well deined ordering relation r c deined by the transitive closure of cj parentc ci cj ci.
thus we formulate our clustering problem as c argmin cvi c n s.t.
r c .
although the evaluation of equation has not changed our search space allpossiblepartitioningsof gthatformalattice imposes avery strongconstraintonour method.
optimization.
tominimize equation2 weneedtoiterateover all partitions ofgthat maintain the lattice property on cand pick onethatminimizesvi.however thereisnoobviouswaytoenumerate allsuch partitions of gand even ifthere were the space is prohibitively large.
since we are unaware of existing methods for minimizing equation we resort to the greedy heuristic in algorithmalgorithm .
we start fromgand assign all disconnected componentstodiferentclusters.then weuniformlysamplearandom permutation over pairs of clusters in cand try to merge each pair.the predicate lattice?
checks r c i.e.alatticeorderingexistsover c.thesecondloopuniformlyatrandomenumerates clusters for splitting.
after a candidate merge or split lattice?
ilters out those partitions that violate the lattice constraint.
otherwise weapplyvitodeterminewhetherthenewpartitionimproves onthecurrentpartition.thevimeasurementsintheinnerloops considertwopartitionsthatdiferbyonlyasinglesplitormerge operation so we need only compute vi on the changed part s cluster s signiicantly speeding upthe computation.algorithm1 greedy optimization of equation2 .
thishelperfunctionapplies eithermergeorsplit tothe currentcluster candeachelementofalisttoformanewcluster then checks whether the new cluster is better under vi.
in the caseofmerge thelistelementsarepairsofclusters for split the elements contain asinglecluster.
function improvecluster list c nb improved false while!improved !list.empty?
do c list.next c continueif !lattice?
c ifvi c nb vi c nb then c c improved true returnc improved function optimizevi g n e c disconnectedcomponents g nb basenames n repeat improved false pairs samplea permutation over pairs of clusters in c c improved improvecluster pairs c nb merge if!improved then parts sampleapermutationover clustersin c c improved improvecluster parts c nb split until!improved max number of iterations returnc algorithm algorithm doesnotenumerate all sequences of split mergeoperations somevalidclusteringsthatmaintainthelatticeorderingcannotbereachedbycombiningsinglenodesplit merges.
nonetheless weindthat forpracticalnamelowgraphs wereach goodsolutions.furthermore theirststepofalgorithm algorithm1 helpsavoidlocaloptimabyirstsplitting gintoitsdisconnected components.
as we discuss later in section we empirically ind that our methodusuallyconvergestothesameor highlysimilarsolutions acrossallrandomrestarts.thissuggeststhatthestructureofour problemallowsustoreachasimilarsolutionsdespiteusingagreedy approximation.
modeling p n c andp c n .to compute the conditional entropiesin equation1 weneedtocomputetheconditionalprobabilitiesp c n andp n c .computing p n c isintricate sowe explainitindetailhere.oncewehave p n c computing p c n is straightforwardthankstobayes rule.tocomputetheprobabilityof aparticularname wecouldusetheempiricaldistributionofnames i.e.theircount withinacluster c.however wewanttotakeadvantageoftheinternalstructureofthenames thesubtokenspresent insourcecodeidentiiers.weuseasimpleregularexpressionfor pascal case orcamelcase to split each name into subtokens.
let ttokenize a name using this regular expression then t n is the multiset of subtokens for n. letsn s s t name n n n .
then wedeine psn s asamultinomialdistributionoverallthe subtokens across the set nof all node names in a cluster.
formally for each possible subtoken s sn we associate a probability wsesec fse november4 9 lake buena vista fl usa santanu kumardash miltiadis allamanis andearl t.barr such that summationtext sws 1andws .
then psn n productdisplay s t n ws.
similarly tocompute pscforacluster wecouldcounttheempirical frequency of the subtokens within the cluster i.e.insc .
however computing the maximum likelihood estimate for each cluster is prone to overitting.
to partially overcome this issue we resorttobayesianstatistics.wespecialize equation3 foreachclustercby redeining wcs as follows we introduce a dirichlet prior wc dir d so for asubtoken sat acluster c we have wc s count s c ds summationtext icount si c where is the importance we assign to our prior and dis weightsofthepriordistribution.inthiswork weset dtotheempirical frequency of the subtokens within g relecting our prior beliefthatthesubtokenswithinaclusteraresimilartothesubtokensthroughouttheprogram.if weretrievetheempirical subtoken distribution within the cluster c. adding this prior biasesthesubtokendistributionwithinaclustertowardtheempirical globalsubtokensdistributionandallowsourobjectivetocreatenew clustersonlywhenacluster ssubtokendistributionsigniicantly difersfromtheglobalsubtokendistribution.italso smooths small diferences between clusters allowing them to merge when their diferences are small.
implementation refinym usesthe.netcompilerframework roslyn tocollect name lows.
our source code is written in c language version .
andourruntimeversionis4.
.theroslyncompilerthatweused for our experiments is version .
.
refinym s clustering module learnsconceptualtypesfromname lowsharvestedthroughroslyn usingthetechniquesdescribedin section2.
.therewritingmodule thenmodiiestheprogramautomaticallytointroducethelearned conceptualtypes intothe originalprogram.
refinym sclusteringalgorithmisimplementedinc usingstandard.netlibraries.tospeed uptheimplementationofalgorithm we make extensive use of caching.
at each iteration only two clusters will be merged or only one will be split.
consider two clusterings that difer only in a single merge m c0 c1 or splits c1 operation.
algebraically the diference in the vi of these two clusterings depends only on the two merged clusters or the single split cluster independent of the rest of the clusters in each clustering.
because computing vi is so expensive we cache the vi diferences of these operations keyed by the operation and its operand s i.e.m c0 c1 then check the cache when evaluating vi c nb vi c nb in algorithm .
furthermore computing the viimprovement over potentialsplit mergeoperations isembarrassinglyparallel.
refinym srewritertranslatesthelatticeformedbytheclustering approachdescribedin section2.
intoc code.todothis wedeine latticepointsasuser deinedtypesandsubtypingrelationsbetween the points as type casts.
additionally we need two other forms of implicit casts from a primitive type to a conceptual type and back.
for deining these casts we use the implicit operator keywords in c .
an implementation of a conceptual type with conversions to and from the stringtype is shown in figure .1classword 2publicword strings val s 3private readonly stringval 4public static implicit operator string word w returnw.val convert word to a string 7public static implicit operator word strings return new word s convert string to a word figure auto castingbetween aclass wordand strings here valstoresthevalueboundtotheoriginalprimitivetype.the methods with implicit operator qualiiers cast a stringto the learnedconceptualtype wordandback.
c is an industrial language with many features.
refinym s rewriter supports a large subset of all rules in c s grammar.
refinymhandles pass by value and by reference.
for the latter refinympassesareferencetothe valinsideaconceptualtypebound totheprimitivetype.forexample in figure5 refinym replaces alloccurrencesofthequaliiedtype ref string x withref word x.val.
for library calls where refinym cannot rewrite the source code it upcasts arguments that are conceptual types into the originalprimitivetype.similarly itdowncastsreturnvaluesfromthe librarycallsthatareofprimitivetypestoconceptualtypes.itappliesthesametechniquewhencallingamethodthatisdeinedonly for a primitive type and when indexing collections of primitive typessuchasarrays.
refinym currentlyabstainsfromrewriting primitive types that have type qualiiers such as constto preserve program semantics.
details can be found in the source code at htp github.com askdash refinym .
atestamenttotheversatilityand utilityof refinym s rewriter is the fact that it onlymakes errors per 10kloc on our corpus which covers diverse application domains.
all of these errorsareduetothefactthat refinym doesnotyetcoverallterms inthe c grammar like its higher order functions.
deployment.
refinym isfullyautomatic.itcanbeeasilymerged intoworklowswithlittleintegrationoverhead.althoughwedemonstratetheutilityofourtoolusingc asanexample ourtechniques andthecore ofour learningframework isprogramminglanguage agnostic.
we harvest name lows though assignments and our tool canleverageanylowanalysisframeworkforanylanguage.forc we have implemented our toolasa command linetoolthat canbe usedatdevelopment time.theprogrammercanselectaprimitive orauser deinedtype udt andinvoke refinym toautomatically collectname lowsforvariablesofthattype identifypotentialconceptual type through the clustering and rewrite the syntax tree to automatically introduce these conceptual types.
after rewriting the syntax tree is automatically recompiled and the tool reports the efect of the rewriting by echoing roslyn s messages including compilation errors to the plugin sconsole.
whileinferringtheinitialclusteringisanovernighttask once a clustering is inferred it could be eiciently updated given incrementalchanges sinceonlythepartsofthegraphthatchange needto be checked forpotential splitormergeoperations with otherclusters.furthermore givenastaticclustering classictype inference methods can be used to infer the conceptual types of newlyintroducedcode elements.refinym using namesto refine types esec fse november4 9 lake buena vista fl usa figure validating refinym viatype reconstruction.
refinym facilitates a developer s exploration of type lattices.
conceptualtypesandprogramtypescandivergeduringdevelopment.
developers are focused on bug ixing and rapid prototyping butnoton type constraints.for adeveloper merging changesupstream through branch promotion is natural time to address the divergencebetweenprogramtypesandconceptualtypes.thisis whererefinym can be an excellent aid.
developers can install and useitlocallyontheirmachinestoreviewtheiruseoftypeswithout impactingotherdevelopersorneedingtosecurepermissionfrom management.webelievethatself vettingpriortobranchpromotionisause casefor which refinym isparticularlywell suited.
evaluation here weevaluatehowwell refinym identiieslatentconceptual types by applying itto the task of reconstructing user deinedtype after they have been artiicially merged section .
and how well it combats primitive obsession section .
.section .
closes with acasestudy ofthe clusters refinym produces.
initially we used the nancyfx project as our development set for constructing refinym.
to evaluate refinym we turned to realworldopen sourceprojects systematicallyselectedasfollows.first we selectedtop c github projectsand removed projects thatwe couldnotcompile.wealsoselectedascientiicorphysicslibrary called bepuphysics a 3d real time physics simulator to show howrefinym reiies types for variables that represent physical quantitiesorunits.
table1showsdetailsofthese14c projects.our experimentswereperformedona2.7ghzintelcorei7machine with16gbofmemory running osx version10.
.
.
.
reconstructing udts toassesshowwell refinym infersconceptualtypes weartiicially createamismatchbetweenaprogram sconceptualtypesandits program type lattice.
essentially we monotype user deined types udts inthe program.
werestrictour attentiontoudtsbecause theytendtobepreciseandnotsubjecttoprimitiveobsession.restrictedtoaprogram sudtsub lattice werewritealludttype annotationsto i.e.objectinc .figure6showstheprocess.the resultisaprogramwithamaximaldivergencebetweenitsprogram latticeanditsconceptualtypelatticeforudts aprogramforwhich we know the ground truth assuming the correctness of the originalprogramtypeudtsublattice.recoveringtheoriginaludts from this program is the udt reconstruction problem .
this problem isparticularlychallengingfor refinym becauseitmonotypesall udts not a small subset of them.
then we ran refinym on the monotyped program and ask how well does refinym recover the originalprogram s udts?
.
to assess the quality of refinym s reconstructionof udts we computehomogeneityhandcompleteness .homogeneitymeasuresthediversityoflabelsacrossallclusters lowdiversityimplies high homogeneity completeness measures the extent to which0.
.
.
.
.
cluster purity score101102frequency log scale a purity distribution0 cardinality0.
.
.
.
.
.0cluster purity score b cardinality vs.purity figure refinym s performance at udt reconstruction.
figure 7a shows the distribution of cluster purity over our corpus noticelog scalein yaxis refinym perfectly generating purity clusters reconstructs of udts.
figure 7b showsthedistribution ofcluster purity vs.size.
clusters contain all elements of a label.
like the more familiar precisionandrecallfrominformationretrieval homogeneityandcompleteness are in tension increasing homogeneity tends to decrease completeness as you may lose elements of a target label when shedding elements with an undesirable label.
for a set of elements for which cis a clustering and kis a labeling homogeneity h is h c k ifh c k h k c h c otherwise wherehis the shannon entropy.
completeness is h k c .h rangesfrom0to1.highhomogeneitymeansthatthelabeldistribution ofelementswithina cluster is skewed toward one label i.e.
the conditional entropy h k c isclose to zero.
astable 1shows refinym averages a homogeneity score of .80andacompletenessscoreof0.91ontheudtreconstruction task.thebalancebetweenthesetwoaveragesshowsthat refinym isefectivelyextractingsignalfromnamestogroupthemajority of related names to achieve high completeness without simultaneouslyadding manyunrelated names therebymaintaininghigh homogeneity.
homogeneityand completeness are globalmeasures ofa clustering.refinym equatesclusterswithconceptualtypes.thus to understand refinym sperformanceatconceptualtypeinference we must assess its performance at the granularity of individual clustersandlookatitspurity.for refinym toperfectlysolvethe udt reconstruction problem each cluster must exactly coincide withconceptualtypes.the purityofaclusteristheproportionof its dominant label.
the objective of the type reconstruction here is to segregate nodes in the name lows into pure clusters those that contain only names of the same type.
this is not enough however becauseanoriginaludt stypecouldbefragmentedinto kdiferent clusters eachofpurity1.
figure7a showsthedistributionofpurityscores.thekeyinding here is that at this very hard udt reconstruction problem of the types clusters refinym inds have purity .
this means that refinym rewritercould reifythemintheprogram andtherewritten program would still type check.
since refinym s clustering module is unaware of the types for which the lows have been harvested thispurityresultalsoveriieshowmuchsignalidentiiers carry about their type.
we now consider the fragmentationesec fse november4 9 lake buena vista fl usa santanu kumardash miltiadis allamanis andearl t.barr table1 c corpusfromgithub.homogeneityandcompletenessscoresforreconstructeduser deinedtypes udt .righthand columns report the reduction in the number of co occurrences of the the type stringin the same scope by running refinym with theexceptionofbepuphysics that containsno string variables.
same typevariables per scope removed name sha description ksloc homogeneity completeness before after critical mean median mean median scopes bepuphysics 2f05f5e3 3d physics simulation library .
.
.
commandline 451be765 commandlineparser .
.
.
.
.
.
commonmark e94800e6 markdown parser library .
.
.
.
.
.
hangire ffc4912f background jobprocessing library .
.
.
.
.
.
humanizer cc11a77e string manipulationlibrary .
.
.
.
.
.
lean f574bfd7 algorithmictrading engine .
.
.
.
.
.
nancy e589dc9b http service framework .
.
.
.
.
.
newtonsoft.json 372c396e jsonlibrary .
.
.
.
.
.
ninject 1c84b358 codeinjectionlibrary .
.
.
.
.
.
nlog applicationlogginglibrary .
.
.
.
.
.
quartznet b33e6f86 scheduler .
.
.
.
.
.
ravendb 9d9ed290 database .
.
.
.
.
.
restsharp 70de357b rest and http api client library .
.
.
.
.
.
wox cdaf6272 windows applicationlauncher .
.
.
.
.
.
average .
.
.
.
.
.
.
.
of these pure clusters relative to the ground truth udt labels.
oftheudtsmaptoexactlyone fragment meaningthat refinym perfectlyreconstructs the type of their udt!
of the udts have 4orfewerfragmentsandthemaximumnumberoffragmentsfor audtis30.datasparsity whichweexplorebelowwhenanalyzing the impure clusters accounts for some fragmentation.
other fragmentationmayarisebecause refinym iscorrectlyseparating mergedconceptualtypes deinednext despiteourfocusonudts.
impureclustersappeartoresultfrominsuicientdata figure7b is scatterplot of purity vs.size and shows that smaller clusters for which we have fewer data points tend to be impure while bigger clusters tend to be pure.
manual inspection of mid sized clusters shows that misclassication tends to occur when the namelowgraph issmall andtherefore refinym reliestoo muchnames alone.forexample configurationitemfactory andlogfactory are instances of the factory design pattern in our data set.
their variablesdonotlowintoothervariables so refinym clusterstheir variablesintoasingleconceptualtypebecauseoftheirlinguistic similarity.thesecondclassoferrors refinym makesisthemerging of an uncommon type and its subtype e.g.loggingrule and consolerowhighlightingrule innlog intoonecluster.thisis duetodatasparsityagain refinym assumesthatthediversityof thesenames does not warrantcreating anewtype.
.
combatingprimitiveobsession2 merged conceptual types mct are distinct conceptual types that sharethesameprogramtype.mergedconceptualtypesmayhold very diferent data.
a program may store both passwords and usernamesin string.whenvariablesofthesemergedconceptualtypes share a scope the type system cannot warn the developer if she mistakenlystoresapasswordintoaname.examplesofsuchscopes whichwecall critical inourcorpusinclude figure1inwhichserver address terminal username and password conceptual types share string.asecond example fromtheravendb projectisshown in 2arguably primitive obsession is a misnomer especially when applied to strings in c because strings are built in types not primitives.
throughout this paper we use primitive obsession to refer to the overuse of either the primitive or built in types of a language notincludingthetypesinalanguage sstandardlibrary althoughonecould argue for theirinclusion .1varjson ravenjobject.fromobject backuprequest .tostring 2varurl admin backup 3varreq createrequest url post 4req.writeasync json .wait figure primitive obsessioninravendb.
figure 8where the url and the request json are conlated into thestringtype.
refinym canidentifysuchscopes suggestnewtypeannotations thatseparatetheirmcts and automatically rewritetheprogram to use these new types when the developer accepts a suggestion section .
here we ask how many critical scopes does refinym eliminate?
.toanswerthisquestion weran refinym onourcorpus toreinestringandindthat21.
ofcriticalscopesareeliminated i.e.scopesthatcontainedmctvariablesbeforerunning refinym but contains reiied variables of a given reined type after acceptingrefinym sreinements.inallthesescopes refinym has freedthetypesystemto potentially unwanted lows across conceptual types.
for every critical scope we alsoreportthe numberof mctvariableswhich are potential sources of confusion that result in no type errors.
table shows that on average refinym reduces the number of same type variables in each scope from .
to .
.
this shows that refinym s suggestions reduce the possibility of inadvertently introducing cross conceptual type lows.
.
casestudy we have just shown that refinym efectively identiies conceptual types through its performance at reconstructing udts and then showedhowacceptingitsreinementscanreducethenumberof scopes in which a developer could introduce an unwanted low.
here we manually delve intoandanalyze someof its results.
refinym s primitive reinements.
we ranrefinym over our corpus reining stringfor all projects except bepuphysics where we reined float.table 2andtable 3present a selection of the namesrefinym clusteredintointoconceptualtypesfor nancyand bepuphysics .naturallanguageutterancesortextcanbediverse refinym using namesto refine types esec fse november4 9 lake buena vista fl usa table conceptual types from stringreinements in nancyfx aframeworkforbuildinghttpbased services.
full nameof nodesorconstantvalues 1path originalrequestpath modifiedrequestpath contentpath emailconstraint basepath iviewenginehost expandpath aspnetrootpathprovider etrootpath owinrequestpath diagnosticsconfiguration etnormalizedpath path nancycontext tofullpath modulepath 2defaultculture defaultculture cookieculture cultureletters name 3earlyexitreason requires any claim requires claims requires authentication accept 4iobjectserializer serialize defaultobjectserializer serialize jsonobject tostring simplejson serializeobject httpqscollection tostring 5method method put post patch options head et delete 6value cookievalue sourcestring somevalue cookievalueencrypted attemptedvalue decryptedvalue defaultvalue 7password password realpassword plaintext password 8httputility urldecode httputility urlpathencode url path httputility urlencodeunicode redirecturl fallbackredirecturl 9header accept language accept encoding accept charset x custom content disposition vary etag exhibiting correct variation or noisy exhibiting erroneous variation.
here we discuss refinym s robustness to natural language s diversityandnoise.
unsurprisingly mostclusterscontainlexicallysimilar evenidentical names because we expect similar or identical names to low into each other.
for example all names in cluster of table containthesubtoken path.inthiscluster pathappears73times althoughwe showeachnameonly onceinthetables.cluster2in table3containsmanynamesrelatedtodistance suggestingthat refinym not only inds similar or identical names but copes with the diversityofreal world names.
refinym alsoindsclustersthatincludelexicallydissimilarelements because of noise.
for example cluster in table 2predominantly contains the subtoken password but also the badly named variableplaintext .
we deem this name noisy because it has no textual similaritywith theother elements.indeed manualinspection reveals that plaintext is always used to represent passwords inthemethod byte eneratesaltedhash string plaintext byte salt thatgeneratesahashforstoringpasswords.clusteringplaintext together with password wouldnothave been possible if refinym only considered names and not the lattice constraint over the name low graph.
the interplay ofthe lattice constraint and names allows refinym to tolerate noise and to generalize conceptual types across synonyms alternative names even typos.
for example in wox not shown we ind a cluster that contains both pythondirectory andpythondirecotry misspelled .
refinym also includes literals in g. their values are notused duringclustering sincevaluesinstantiatetypes i.e.areelements of types and therefore we expect little textual similarity between literal values and variable or method names.
however given the latticeconstraint wecanstill clusterthem togetherwith other literalsandvariables.anexampleofasuccessfulclusteringofliterals andvariablesiscluster5in table2.itshowsaconceptualtypethat corresponds to http methods.
reining this conceptual type is straightforward requiringtheintroductionofanenumerationtype whichcan preventbugs triggered when a random stringis passed as an http method.
refinym also mined a conceptual type for httpheaders cluster9in table2 .table sample conceptual type cluster nodes for float type inbepuphysics aphysics simulation c project.
fullnameof nodes orconstantvalues 1damping suspensiondamping starchdamping dampingconstant angulardamping lineardamping 2currentdistance distance3 candidatedistance pointdistance distancefrommaximum grabdistance variablelinearspeedcurve etdistance tempdistance 3goalvelocity drivespeed oalspeed 4minradius minimumradius radius minimumradiusa wrappedshape computeminimumradius topradius maximumradius graphicalradius transformableshape computemaximumradius 5blendedcoefficient kineticfriction dynamiccoefficient kineticbrakingfrictioncoefficient 6angle mymaximumangle minimumangle currentangle maximumangle steeringangle mathhelper wrapangle 7targetheight height proneheight crouchingheight standingheight 8mass effectivemass newmassa newmass 9m22 m11 m44 resultm44 m43 intermediate m31 x y z inferring unit types.
units of measure and unit types are important in numericalcomputation.
they can prevent a wide range oferrors suchasperforminginconsistentoperationsonphysical quantities e.g.adding velocity to an angle or adding two variables of the same physical quantity that are nevertheless measured on a diferent unit e.g.adding radians to degrees.
the well known nasa smars climate bug exempliiestheir importance.
refinym s focus is proposing nominal type reinements not unit types.
nevertheless it distinguishes physical quantities and coeicientsassigningthemtodiferentconceptualtypes.
table3 showsaselectionofclustersof floatvariables refinym indsin bepuphysics a physics simulation project.
cluster represents speed relatednodes cluster8containsmass relatednodes andcluster6 refers to angles.thus refinym canhelpdevelopersidentify unittypes alleviatingthe burden of manual annotation.
sincerefinym infersalatticeofconceptualtypes itdetectsunitless coeicients such as damping cluster and friction cluster factors.althoughallunitvariablesmaylowintogenericvariables refinym clusters such variables to appropriate supertype clusters.
for example cluster represents a common supertype of many numericalquantitiesandincludesgeneric orconceptless variables such as elements of a matrix e.g.m11 or generic vector coordinates x y z .
again the reader may notice that cluster table contains highly diverse names with no textual similarity.
these namesareneverthelessclusteredtogetherthankstotheconstraints imposedbythe refinym slattice constraint.
qualitativeerroranalysis.
likeallmachinelearning refinym doesnotyieldperfectresults.here wequalitativelydiscusscommon errors we observed and speculate about their causes.
refinym smostcommonerroristoconlatenodesthatarelinguisticallysimilar butrepresentdistinctconceptualtypes.manualinvestigation reveals that most of these errors arise because these nodesbelongtodisconnectedcomponents so refinym couldnot collect name low constraints among them.
this commonly occurs inlibrarieswhichprovideexternalapistotheiruserswithoutusing them internally.
these unused public methods i.e.the library apis break the low in the name low graph resulting in disconnectedorlooselyconnectedcomponents.inthefuture aggregating information from external uses of a library may alleviate this issue.esec fse november4 9 lake buena vista fl usa santanu kumardash miltiadis allamanis andearl t.barr refinym also generates superclusters that contain alarge set of mostlyunrelatednodes.
refinym may be creatingthese superclusters because of the incompleteness of its split merge operators andthegreedyheuristic alg.
.thesesuperclustersmaynotbe errors.
they suggest that our information theoretic objective does notconsider further splitting to be statistically important or useful.
so even though these superclusters may seem erroneous to humans it may be that refinym is inding base types in them that arenotworth reining.
this suggests an interesting new empirical research direction doesvicorrelate with the usefulness of a program s type lattice?
starting from a monotyped program vi improves as the type lattice becomes more ine grained.
when the type lattice becomes too ine grained vistarts worsening again.
thisphenomenonmayalsoberelatedtotheincreasingburdenof gradually more complex type annotations inaprogram.
related work typesinprogramminglanguagesarerecognizedfortheirabilityto providereasonableguaranteestoaprogrammer givenawell typed program.
this worksrests on theobservation that theconceptual typesdevelopershaveinmindandthetypestheyactuallyreifyina programcandiverge.aninstanceofthisisthe primitiveobsession codesmell whichpractitionersacknowledge.this smellisbadpracticeofusingprimitiveorbuiltintypesforelements ofdistinctconceptualtypes.primitiveobsessionmergesconceptual types like the use of intfor both ids and counts that may lead to a type correct addition of an id and a counter.
refinym uses code sbimodalitytoindtypereinementsthatalignsconceptual andprogramtypes surfacinglatentconceptualtypestothetype systemandalleviatingprimitive obsession.
inferenceofabstractdatatypes adt isrelatedto refinymsince both methods can be used to reine a program s types bylearningvariousformsofadts.lackwit staticallyinfers adtsbyusingthelowofdataandassigningadtstoasetofvariablesthatcanlowamongeachother.however lackwitsolelyuses data low.
in contrast to refinym lackwit cannot ind conceptual types that share lexemes but whose variables have no low and thereforesufersfromlowprecision .refinym avoidsthisissue byexploitingtherichnaminginformationinsourcecodetoprovide precise and consistent adts.
guo et al .
inferred adts from primitives by dynamically observing the interactions only among variable values without learning or reining a type lattice.
their approach is dynamic requiring a representative set of run time data and broad code coverage.
in contrast our method is based on purelystaticinformationandaimstoreineaprogram stypes.haq etal.
usedynamicadtinferencetoindvariablesthatinteract.
then they use variable names and a heuristic name similarity metrictodetectundesiredvariableinteractions byclusteringthe names within each adt.
in contrast refinym reines types based onsignalfromnames ratherthanusingnamesinapost processing step.furthermore ourunsupervisedinformation theoreticmethod circumventsspecifying apriorithe number ofclusters.
refinym makesheavyuseofcodebimodality i.e.theproperty that human written code contains two modalities one for communicating with the hardware and one for communicating among humans.bimodalityextendstheobservationsofhindleetal .
whofoundthatcodeis natural .withthisintuition alargecorpusof work has followed .
central to our work are the source code identiiers of variables and methods.
identiier names have been found to have a profound efect on code readability and developers greatly care about the names used within source code .
badvariablenameshavebeenusefulfordetectingbugs and are treated as anti patterns in software development .refinym isbasedonthisintuitionandthatdevelopersmakegreatefortto pickgoodnamesandthereforecanprovidevaluableinformation tobothhumansandmachinelearningmethods.ofcourse types and identiier names are intricately connected since they both aim to disambiguate entities something that we explore inthis work.
the notion of types appears in natural language processing through the concepts of hypo hypernymy the identiication of namedentities andsemanticparsing .althoughconceptuallythisnotionoftypeissimilartotheoneusedinprogramming languages a softer non discrete approximation is used given the ambiguous nature ofnaturallanguage.
clustering is a common topic in unsupervised machine learning and datamining thataimstoinferthestructureofsomedata in an unsupervised way.
common machine learning methods such ask meansclusteringandgaussianmixturemodels gmm makestrongparametricassumptionsandaremostlyusedtocluster individualindependentelements.non parametricmethods suchas dpgmm and information clustering do not require to deinethenumberofclustersapriori.information theoreticclustering whichweuseinthiswork isanattractivesetofmethods since it makes no assumptions about the underlying data.
our core noveltyovertraditionalnon parametricclusteringmethods including information theoretic methods is that our method operates on graph structures andinfersclustersthat have alattice structure.
finally the problem of grouping elements of a graph resembles the idea of community detection in social network analysis .
there thegoalistodetectcoherentcommunitiesinthenetwork.in contrastto refinym suchmethodsmostlyrelyondetectingtightly connected regions within a graph based on its structure without consideringadditionalconstraintsoverthecontentofeachnodeor the structure relationship of eachcommunity cluster.
conclusion in this work we presented refinym a method for mining conceptual types from existing source code.
to achieve this we cluster over source code elements such as variables methods and literals exploiting the interplay of their names and the structure of assignment lows.
through this process we retrieve a ine grained implicit conceptual type lattice that we use to suggest reinements.
wepresentedquantitativeandqualitativeevaluationofourmethod thatshowthe promisesof thisdirection inding thatthe proposed reinements related strongly with conceptual types and can be useful for assisting developers to deine more explicit type lattices.
inthefuture webelievethatthebimodalityofsourcecode i.e.
its natural languageaspectsand its rich structure can be exploited to ofer improved software engineering tools and assist program analyses.
this requires to develop new techniques that bridge programming language concepts with machine learning methods and preserve code semantics.refinym using namesto refine types esec fse november4 9 lake buena vista fl usa