autotap synthesizing and repairing trigger action programs using ltl properties lefan zhang weijia he jesse martinez noah brackenbury shan lu blase ur department of computer science the university of chicago lefanz hewj jessjmart brackenburyn shanlu blase uchicago.edu abstract end user programming particularly trigger action programming tap is a popular method of letting users express their intent for how smart devices and cloud services interact.
un fortunately sometimes it can be challenging for users to correctlyexpress their desires through tap .
this paper presents autotap a system that lets novice users easily specify desired propertiesfor devices and services.
autotap translates these properties tolinear temporal logic ltl and both automatically synthesizesproperty satisfying tap rules from scratch and repairs existingtap rules.
we designed autotap based on a user study aboutproperties users wish to express.
through a second user study we show that novice users made significantly fewer mistakeswhen expressing desired behaviors using autotap than usingtap rules.
our experiments show that autotap is a simple andeffective option for expressive end user programming.
keywords end user programming trigger action programming program synthesis program repair i. i ntroduction end user programming enables users without programming experience to customize and automate systems.
an approach that is particularly popular for automating iot smart devicesand online services is trigger action programming tap which is supported by ifttt mozilla s things gate way samsung smartthings microsoft flow openhab home assistant ripple zapier andothers.
some of these tap services are widely used .
in tap users create event driven rules of the form if atrigger occurs then perform an action.
for example if a sad song comes on then turn the lights blue.
unfortunately while novice users are able to successfullyexpress many automation behaviors using tap interfaces attempts to express more complex yet commonly desired behaviors often contain bugs .
these bugs encompasstiming errors issues with control flow conflictingbehaviors and incorrect user expectations .
as aresult an important open question is how to help userswith no programming experience and therefore no debuggingexperience correctly express their wide variety of desired behaviors in tap .
otherwise users will encounter frustrationand experience safety threats from buggy tap rules.
for example imagine the simple and sensible desire to keep the window closed when it is raining.
with current interfaces a user might create the straightforward tap rule if it beginsto rain then close the window figure 1a .
unfortunately this rule is insufficient.
for example while it is raining adifferent rule might be triggered and open the window or an a a buggy tap rule.
b a proposed tap property.
fig.
the tap rule a cannot guarantee the property b .
oblivious person might open the window manually.
to fullyexpress this desire therefore requires a complex set of rules.
to address this open question we present autotap a system that provides easy end user programming for smart devicesand online services with fewer chances for human mistakes.autotap expands tap to allow users to specify throughgraphical interfaces not only rules but also properties about the system that should always be satisfied.
for example fromthe running example one could express the desired propertythat it is currently raining and the window is open shouldnever occur together figure 1b .
in other words instead ofrequiring users to explicitly write event driven rules defininghow devices should behave we let them simply specify whatproperties the system must satisfy.
if no relevant rules are provided autotap automatically synthesizes property satisfying tap rules from scratch.
forexample given the property in figure 1b autotap willautomatically synthesize two tap rules to satisfy this property ifit begins to rain while the window is open then close the window ifthe window opens while it is raining then close the window if initial rules are provided alongside the desired property autotap will automatically check these rules and if necessary repair them to prevent the system from violating the property.autotap thus minimizes the opportunity for tap mistakes.the following two key components of autotap work togetherto achieve the above functionality a novel property specification interface the key goal of tap is to empower novice users without programming knowl2812019 ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
an overview of autotap which takes user specified properties and optionally user specified tap rules to auto matically generate a set of tap rules that satisfy the properties.
edge to automate and customize their devices and services.
autotap therefore needs an interface that is both a expressive allowing users to specify most of their desired properties forsmart device systems and b easy to use requiring minimal training for non technical home users to use correctly.
to this end we first conducted an online user study in which current users of smart devices each provided infree text ten properties they would want their devices tosatisfy section iii .
we qualitatively coded their responses finding that nearly all the desired properties followed one ofseven templates.
subsequently we implemented a graphical click only interface that mirrors the design of popular taprule specification interfaces .
this interface enables usersto specify properties following these seven templates withoutrequiring any text input.
autotap then directly translatesproperties specified in this interface to formulas in lineartemporal logic ltl that can be used by autotap s other components section iv .
while prior work has proposedinterfaces for property specification no prior efforts fullysatisfy our requirements in the unique context of smart devicesystems section viii .
novel synthesis techniques for tap rules we want all programs synthesized by autotap to be a propertycompliant guaranteeing the programmed devices satisfy thespecified properties b accommodating not disabling any device behaviors that originally satisfy the properties cru cial for human centric systems and c valid following the syntax of tap rules and physical constraints of smart devices.for example given the property in figure 1b generating onlyone of the two tap rules presented earlier is accommodating yet non compliant.
generating tap rules that prevent thewindow from ever opening even in sunny weather is compliant yet not accommodating.
generating tap rules that prevent rainis impossible and therefore not valid.
to achieve these goals autotap takes three steps as shown in figure .
first it automatically builds a b uchi automaton to formally model desired properties and the smart device systemitself including any existing tap rules.
at this step thenovel techniques we introduce simplify models and properlyrepresent time related properties section v a .second autotap leverages a unique feature shared by all ltl safety properties to design a simple algorithm that iden tifies b uchi automaton edges whose removal guarantees the compliant and accommodating goals of synthesis sec.
v b .
third autotap designs an algorithm to systematically synthesize valid new tap rules or rule changes to remove automaton edges identified above while making a best effort tokeep rules simple and thus intelligible for users section v c .
these techniques are general.
they are not limited to any specific patch template.
they apply to any ltl safety property not just those that can be expressed using autotap s currentproperty creation interface.
furthermore while our interfacedesign focuses on smart devices the same techniques applyto online services such as the hundreds ifttt supports .
these techniques are also novel.
we cannot use previously proposed synthesizers which do not satisfy therequirements discussed above in the unique context of smart device systems section viii .
a small but quickly growingliterature has begun to apply formal methods to tap .
our techniques move beyond this work in both thetarget and the solution.
some of this work only aims to detectproperty violations while others only repair existing rules by editing or adding conditions or triggers .our techniques are the first to also synthesize new rules from scratch and to provide the accommodating guarantees notdisabling any device behaviors that originally satisfy the de sired properties a crucial feature for human centric systemsthat fundamentally cannot be provided using the fixing by counterexample approach of previous work .
our evaluation of autotap includes several parts section vi .
we conducted a second user study in which 78participants were randomly assigned to use either a traditionaltap rule interface or our autotap property interface.
theyused their assigned interface to express behaviors randomlyassigned from a larger set of .
for all14 behaviors a larger fraction of participants using the autotap property interfacecorrectly expressed the behavior than those using the tradi tional tap rule interface.
we also benchmarked autotap sperformance synthesizing tap rules from scratch using thesets of correct properties collected in our study.
autotapsuccessfully generated patches for of these sets.
to encourage replication and adoption we are opensourcing the code for both autotap and our rule and property specification interfaces.
we are also releasing the anonymizeddata from our two user studies with the permission of both ourirb and participants and our full survey instruments.
all ofthese are available at ii.
b ackground a. trigger action programming tap in recent years tap has received a great deal of academic attention in multiple areas usability novelinterfaces measurement deployment correctness and security .
furthermore tap has been deployed by microsoft mozilla ifttt samsung and others.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
systems generally follow one of two tap rule structures .
the simpler variant connects a single trigger to a single action if event then action .
each such statement is a tap rule and a collection of rules forms a tap program .
events include state changes for devices services and sensors e.g.
it begins to rain .
actions are actuations of devices e.g.
open the window or services e.g.
send an sms .
the more expressive variant differentiates events actions or state changes that occur in a moment such as it begins to rain and states conditions that remains true false over time such as it is raining .
in this variant triggers are a single event optionally conditioned on one or more states as follows if event occurs while devices are in a given state then fire action shortened as if event while state s then action .
in this paper we use this more expressive eventsta te action variant also called event conditionaction which balances usability and expressiveness.
this variant is used in samsung smartrules stringify home assistant and academic studies .
b. transition systems and linear temporal logic ltl autotap formally models smart devices and tap programs as transition systems .
every transition system consists of a set of states s a set of events e typically called actions in tap that change the system from one state to another s1e e s2 and a set of atomic propositions ap that reflect detailed properties of a state with l s denoting the set of atomic propositions associated with state s. a valid execution is an infinite sequence of states s0s1... sk sand every transition from one state to the next is valid siei e si .
ltl formulas can represent a wide variety of execution properties and are widely used in formal verification .
an ltl formula is constructed from atomic propositions with some operators t r u e ap 1 2 x 1u 2. informally xandurepresent not and next and until respectively.
in addition to these basic operators f gand w are common derived operators.
given an execution e s0s1...of a transition system esatisfies atomic proposition apif and only if the initial state of eis associated with ap i.e.
ap l s0 .
a transition system ts satisfies property ts if all possible executions in ts satisfy .
iii.
u ser study m apping desired properties to understand what types of properties users commonly desire for smart devices we conducted an online user study.
methodology we designed a survey asking people who had experience with iot smart devices in their own homes to write free text properties they would want their devices and home to satisfy.
specifically we asked them to write statements about internet connected household devices that you believe should be effective at all times with only occasional exceptions if any.
to encourage diversity we asked participants to imagine their house was filled with smart devices we listed.
we asked for ten statements preferably five that should always be true and five that should never be true in their smart home.we recruited participants on amazon s mechanical turk who reported having an internet connected household iot device and living in the usa.
we compensated for the study which also included a section on experiences with buggy behaviors in smart homes that is outside this paper s scope.
through qualitative coding we analyzed and grouped these free text desired properties into templates.
members of the research team read through responses and iteratively proposed templates.
two coders then independently categorized each response .
and met to resolve discrepancies.
to encourage complex and diverse properties we randomly assigned half of participants to see four example properties e.g.
the temperature in my bedroom should never be below degrees while the other half did not see any examples.
while both participants who did and did not see examples wrote properties following six of the seven templates the proportion of properties matching a given template differed significantly between these two groups 2 p .
.
thus we always first report the percentage among properties written by participants who did not see examples followed by the percentage from those who did.
results we received responses discarding four who gave off topic responses or reported having no smart devices.
of the resultant participants identified as male and as female.
the median age range was and were age .
among participants reported a degree or job in cs or technology.
participants most frequently reported having internet connected cameras of participants lights thermostats cooking devices door locks and outdoor devices .
we found that seven templates captured the vast majority of desired properties participants expressed.
we differentiate them based on whether they are conditional i.e.
conditioned on at least one other clause whether they rely on a duration i.e.
expressing temporal bounds and whether they are described based on states and or events.
the small number of remaining properties were either out of scope e.g.
requesting new features or too ambiguous to analyze reliably.
below are the seven templates each with the proportion of responses that fit that template from participants who did not see examples and those who did respectively.
we also provide a sample response from participants for each template.
a one state unconditional .
.
smart refrigerator should always be on.
b one event unconditional .
.
my thermostat should never go above degrees.
c one state duration .
.
my smart lights should stay on for at least seconds each time.
d multi state unconditional .
.
never run the washing machine and the dish washer at the same time.
e state state conditional .
.
the stove should always be off if no one is home.
f event state conditional .
.
my smart window should never be opened while the ac is on.
g event event conditional .
.
my smart door lock should always lock after i come in.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i autotap s property templates.
g f x and ware always globally eventually in the future next and weakly until ltl operators.
state is a user specified atomic proposition or its negation.
and relate to timing sec.
v a .
property type input template ltl formula one state unconditional should be active g state should be active f state one event unconditional should happen f event one state duration should be active for more than g state state wtime state should be active for more than f time state multi state unconditional should occur together f !
state ... staten should occur together f state ... staten state state conditional should be active while g state ... staten state should be active while f state ... staten state event state conditional should happen when g x event state ... staten should happen when f state ... staten x event event event conditional should happen within after g event time event 2w event should happen within after f time event x event interface entry property type multi state unconditional one state unconditional one state duration state state conditional one event unconditional event state conditional event event conditional fig.
templates in autotap s property specification ui.
iv .
a uto tap property specifica tion interface autotap aims to synthesize tap programs satisfying userspecified properties.
this section discusses our design of a property specification user interface that aims to be expressive easy to use and also compatible with ltl allowing an easy translation from every specified property into an ltl formula.
property types table i summarizes the seven property types we commonly observed in our first user study.
they differ along three dimensions whether the subject was a state or an event whether something should or should not happen and whether the desire was conditional or unconditional.
we note that any state state conditional property can be written as an equivalent multi state unconditional property.
further some one state duration properties have equivalent event event conditional properties.
however to better match users mental models we chose not to merge these types.
every type of property in our interface has a straightforward translation to an ltl formula as shown in table i. the example in figure 1a corresponds to a state state conditional property the should always be closed when israining .
it corresponds to an ltl formula g weather.raining window.closed .
interfaces for property specification to not overwhelm users autotap lets them first pick from three template cate gories as shown in figure and then customize that template by selecting items from drop down lists of devices states or events.
users also select whether they desire certain situation to always occur or never occur.
this interface provides users with the same vocabulary about devices states and events as traditional tap rule interfaces as in figure .
autotap s user interface design focuses on common user desires.
it does not aim to cover all possible properties a user might think of or all properties autotap synthesis can handle.
as an alternative autotap also allows expert users to specify safety properties directly in ltl.
for example imagine someone has a smart light bulb and wants the red color to always be followed by green or yellow.
this desire is not supported by the user interface above yet can be described in ltl as g color.red x color.green color.yellow and thus can be handled by autotap.
v. a uto taptap synthesis problem statement informally speaking smart devices continuously interact with unpredictable human users and environments.
naturally some interactions sequences might cause undesirable device states or state sequences.
autotap aims to automatically synthesize tap programs or program patches so that all desirable situations remain intact i.e.
being accommodating and all undesirable situations become disabled or transient i.e.
being property compliant .
straw man one potential solution is to repeatedly attempting the following two steps as illustrated by the dashed lines in figure propose a tap program patch try to prove that this program guarantees satisfaction of the desired properties returning to step if not.
the second step can be done through model checking which typically uses a finite b uchi automaton to represent all possible executions of the system checking if all these executions satisfy a property by analyzing the automaton graph.
unfortunately given the large search space of potential tap programs particularly when we synthesize programs from scratch how to conduct the first step is unclear.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
autotap approach vs. straw man approach autotap approach autotap takes a unique approach to solving this problem in a general and systematic way.
as illustrated in figure it does not require iterative retries.
step turn the given smart device system tap rules if any and the desired property into a b uchi automaton a accepting violating executions like what traditional model checkers do internally.
step figure out how to modify aso that all satisfying executions are kept which guarantees being accommodating and all originally accepted i.e.
violating executions disappear which guarantees being property compliant.
step find valid tap program s that can make the automaton changes suggested at step .
the first step is largely straightforward but we need to carefully model timing related properties and avoid unnecessarilylarge automata.
section v a explains how we do so.
the second step is very challenging at first glance.
there are innumerable ways to change an automaton a. it is hard to know which changes are compliant accommodating and valid e.g.
changes that require modifying property and device specifications are invalid .
section v b will present a simplealgorithm that identifies such compliant accommodating andvalid changes i.e.
a set of edges to cut in a leveraging a unique property of ltl safety properties.
as section ivexplained the desired properties we commonly observed inour first user study all map directly to ltl safety properties.
the third step finding valid program changes 1that correspond to a given automaton change is challenging forgeneral programming languages.
however as we will explainin section v c it can be done in a systematic way for tap .
a. step model construction autotap s inputs are safety properties in ltl obtained through the user interface presented in section iv tap rules if any specifications for every smart devicein the form of a transition system as defined in section ii b.we expect device specifications to be provided once by device manufacturers or tool developers like us yet used by alldevice users.
our experiments used the specifications from samsungsmartthings .
autotap s baseline model construction follows traditional model checking techniques .
first a transition system isbuilt for a set of devices together with their tap rules ifany e.g.
figure .
some events in the transition system are 1autotap does not differentiate program synthesis from patch synthesis as the former is a special case of the latter when the original program is null.
fig.
transition system for rain and a win dow.
statements in parentheses are atomic propositions held in each state.
controllable e.g.
turn on the light while others are not e.g.
stop raining .
this distinction is kept by autotap forits synthesis phase.
2then this transition system is turned into ab uchi automaton asthat accepts all executions allowed in the smart device system e.g.
figure 6b .
next autotapapplies spot to the ltl formula representing to get ab uchi automaton a that accepts all executions violating e.g.
figure 6a .
finally asanda are combined into a b uchi automaton athat accepts all violating executions in the smart device system e.g.
figure .
our discussion below focuses on two techniques we developed for autotap beyond typical baseline modeling.
device selection to avoid unnecessary complexity autotap selects devices drelated to the given property to model.
to do so autotap first initializes dwith all the devices that appear in .
autotap then iteratively expands dwith devices that can affect any device already in duntil reaching a fixed point.
here autotap considers one device to affect anotherdevice if these two both appear in a tap rule r with the former in the trigger and the latter in the action.
model timing information autotap extends baseline models to support timing related propositions like event e happened within the past t seconds denoted as t e and ap has been true for at least t seconds denoted as t ap.
autotap s property specification interface supports both.
autotap first adds a count down timer attribute timer t e ortimer t ap into the transition system.
the countdown starts att whenehas just occurred or when a system state associated with aphas just appeared.
it ends at indicating ehas occurred or aphas been true for at least tseconds.
when the system reaches a state no longer associated withap thet aptimer immediately flips to .
consequently a state is associated with a t e proposition if the corresponding timer is positive.
it is associated with t ap if the corresponding timer is0.
then autotap introduces an environmental event tick that counts down every positive timer uniformly.
when tick is applied to a state s autotap finds the smallest value of all the positive timers associated with sand counts down every positive timer by that value.
for example if a state isassociated with three timers with values one tick will direct the system to a state with these timers being and another tick will set all three timers to .
this count down scheme helps autotap avoid unnecessary state2the device specification we used contains such information capabilities with commands are controllable while others can only be sensed.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a ltl property g rain.on w in.closed b device system window rain fig.
b uchi automata of our running example.
space explosions without losing accuracy as counting down timers by smaller values will not change any timing related propositions e.g.
and will have the same set of time related propositions .
here autotap uses its own design to handle timing related propositions for simplicity reasons since autotap only cares about two simple timed propositions t eandt ap using more complicated timing logic like mtl and more complicated timed automata will only add unnecessary complexity to autotap property checking and rule synthesis.
b. step patching the automaton the first step builds a b uchi automaton athat accepts all violating executions on smart devices.
if no execution can be accepted by a users desire is already guaranteed.
otherwise this second step figures out how to change a. task we first clarify autotap s task at this step by reviewing some related background on b uchi automata.
by definition an execution is accepted by a b uchi automaton if and only if its corresponding path on the automaton visits every accepting node set an infinite number of times.
for example the automaton in figure 6a has one accepting set that consists of exactly one node the double circled one.
it accepts every execution with a prefix ending in a state whererain.on and !win.closed are true which guarantees visiting the double circled node an infinite number of times.
consequently autotap must figure out how to change a so that all and only those paths that infinitely visit a s accepting node set disappear.
there are several challenges.
first the change has to be valid doable through possible additions or revisions of tap rules.
naming accepting nodes as un accepting is invalid.
deleting an edge in ais usually valid as discussed in the next sub section.
second for arbitrary i t is difficult to tell which edges we should cut.
this edge cutting must not only eliminate every path that visits the acceptingnode set infinitely i.e.
property compliant but also keeps intact every path that originally does not visit the acceptingnode set infinitely i.e.
accommodating .
observation autotap s algorithm is based on a key observation as long as is an ltl safety property ahas no edge connecting an accepting node to an un accepting node.
this observation holds because as long as is an ltl safety property we can always find an a whose only accepting node has a single edge pointing to itself with condition .
fig.
combined b uchi automaton of the running example.
the top is the original.
the bottom is after adding a rule.
once a path reaches this node it will be stuck in this node infinitely 3just like the double circled node in figure 6a.
this property of a then leads to the above observation ofa.
the reason is that by combining the smart device automaton asand the property automaton a every node in ais a cartesian product of two nodes nsinasandn ina .
the accepting node set of aconsists of every node whose corresponding node in a is an accepting node.
furthermore if there exists an edge from n1ton2ina there must exist an edge from n1 ton2 ina .
consequently since there is no edge connecting the accepting node back to any unaccepting nodes in a there must be no edge connecting accepting nodes back to un accepting nodes in aeither.
algorithm autotap identifies all the edges that connect an un accepting node to an accepting node in a informally referred to as bridge edges and suggests cutting all of them like the two edges in the middle of figure .
this algorithm is simple with complexity linear in the number of edges in a. this algorithm is compliant preventing any property violations.
the reason is that after cutting all bridges no execution can ever touch accepting nodes not to mention infinitely.
consequently all violating executions are eliminated.
this algorithm is also accommodating preserving all the system behaviors that do not violate .
recalling section v b satisfying executions will not go through any bridges.
since our algorithm only removes or redirects bridges yet not other edges those executions are untouched.
c. step tap synthesis at this third step autotap needs to identify additions of or revisions to tap rules that can delete the bridges in a identified in step .
mapping a b uchi automaton change to a program code change is challenging for most imperative programming languages but is fortunately tractable for tap .
task we first clarify autotap s task by reviewing some background on b uchi automata.
ina which is combined by the smart device automaton asand the property negation automaton a every edge e 3due to space constraints we cannot include a complete formal proof.
informally given a b uchi automaton of an ltl safety property all nodes corresponding to the last state of a violating prefix of the property can be replaced with an accepting node with an edge 1pointing to itself.
those nodes can be combined giving us the b uchi automaton a we desire.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
device automaton a changed to b by adding a rule.
n1ap n2is combined by an edge es n1saps n2sin asand an edge e n1 ap n2 ina .apis an atomic proposition ap set describing what is accepted by e andeonly accepts what is accepted by both esande .
ifapsconflicts with ap edgeewould disappear from a. to ease the discussion we will informally refer to apas the post condition of n1and the pre condition of n2.
since the property and the corresponding a cannot be changed autotap changes every bridge e s corresponding edgeesinas which we also refer to as a bridge removing esor changing its apsso thatecan disappear from a. example before presenting autotap s general algorithm we use a concrete example to demonstrate how adding atap rule can change the smart device automaton a sand correspondingly make some edges disappear in a. figure 8a is part of the automaton asin figure 6b that models the weather rain and a smart window win withno tap rules.
we can focus on node circlecopyrt.
its preceding edge indicates a pre condition when it was not raining and the window was open.
its succeeding edge circlecopyrt rain on rain.on win.open circlecopyrt indicates that the rain starts rain on with the postcondition being raining and window staying open.
note thatthis post condition ap set is the same as that of the bridgeina illustrated in figure 6a.
consequently circlecopyrt circlecopyrtis a bridge in asthat contributes to the red bridge edge in the combined automaton ain figure .
figure 8b shows the effect of adding a tap rule.
as highlighted in the figure this rule s triggering state rain.off and win.open exactly matches the pre condition of node circlecopyrt.
its triggering event rain.on and rule action win.off exactly match the events associated with edge circlecopyrt circlecopyrtand edge circlecopyrt circlecopyrt respectively.
consequently immediately after circlecopyrt circlecopyrttakes place this rule would automatically push the system through the circlecopyrt circlecopyrtedge essentially making the circlecopyrt circlecopyrtedge transient marked by t in figure .
by changing the nature of circlecopyrt circlecopyrt its ap set no longer matches with that of the bridge edge in figure 6a.
consequently thecorresponding bridge edge in a i.e.
the red edge in figure will disappear.
autotap fixing algorithm we first consider a simple case where the bridge edge e sinashas only one predecessor and one successor as in figure 9a.
to cut its correspondingbridgeein the combined automaton a we simply need to add a tap rule if e 1whileap 1thene2 where e1is the event associated with the bridge ap1is the pre condition of fig.
generalization of adding tap rules.
the bridge and e2is the event associated with the succeeding edge.
like the example in figure this new rule will makestates associated with e stransient no longer able to combine intoe.
that is bridge einawill be successfully cut.
refine trigger state the baseline algorithm uses ap1 the bridge s pre condition as the trigger state of the synthesizedrule.
in fact it does not have to be.
we want the new ruleto be triggered at an original bridge edge but not at any non bridge situations.
the former implies that the rule strigger state condition should be weaker than the bridge spre condition.
for example since the bridge s pre conditionin figure is rain.off and win.on the trigger state can be rain.off o rwin.on o rtrue.
the latter implies that in other places where the trigger event could happen the pre conditions should conflict with the rule s trigger state preventing the rule from being unnecessarily triggered.
to achieve this goal autotap processes not only the bridge s pre condition ap but also pre conditions ap prime iassociated with all other cases where the trigger event couldoccur.
when there are multiple expressions satisfying theabove requirements we turn this into a hitting set problem.we use a greedy algorithm to find the smallest one.
refine the triggered action the baseline algorithm uses e 2as the action of the synthesized rule because the bridge edge only has a single successor and hence e2is the only possible action taken in figure .
when the bridge has multiplesuccessors with multiple possible succeeding actions autotapfilters out two types of actions actions that cannot beinitiated by smart devices i.e.
non controllable events like stop raining discussed in section v a and actionscausing other property violations.
if multiple actions pass theabove filtering the only ranking autotap does currently isto downgrade an action that reverts the trigger event.
forexample if the trigger event is turning on the air conditioner ac autotap will not suggest a rule that turns off the acunless there are no other choices.
revise existing rule when the bridge edge e sis associated with an event that is automatically triggered by an existingtap rule r the baseline patch would immediately trigger one tap rule after another.
a better solution is to revise rso thatris no longer triggered in this bridge situation yet is still triggered in other situations.
to achieve that we split thegeneral rule rinto many edge specific tap rules by narrowing r s triggering state to only accept the pre condition of every specific edge.
then we simply delete the edge specific ruleassociated with the bridge edge and keep the remaining ones authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
assuring minimum impact to the system s behavior.
rule merging autotap can merge tap rules with the same trigger event and rule action or even similar trigger states to make the program easier to understand without changingsystem behaviors.
we omit the details due to space constraints.
vi.
e v alua tion a. user study specifying rules vs. specifying properties to evaluate usability questions regarding whether autotap s property driven approach enables novice users to express theirintent correctly and easily we conducted a second onlineuser study.
in this study we compared participants abilityto express a series of reference tasks as tap rules usinga traditional rule based interface and participants ability toexpress the same series of tasks as properties using autotap sinterface .
we chose a rule based tap interface as our pointof comparison because such interfaces are widely used andprior usability studies have shown that even novice users cancreate tap rules successfully .
methodology we again recruited participants from the usa on mechanical turk though for this study we did notrequire that they had previously used a smart device.
werandomly assigned each participant to one of the followinginterfaces which they used for the duration of the study rules participants created tap rules using a web inter face modeled closely after ifttt see figure 1a .
properties participants created properties using auto tap s interface see figure 1b .
the interfaces used identical events and states.
in other words if the rule interface had an it begins to rain event groupedunder weather so did the property interface.
participants began the study by completing a short tutorial on their assigned interface.
the tutorial explained keyconcepts e.g.
the difference between events and states andincluded attention check questions.
these questions automat ically pointed out the right answer for anything participantsanswered incorrectly.
we designed the two tutorials to haveparallel structure and share examples as much as possible.
participants then used their assigned interface to complete tasks randomly selected and randomly ordered from a largerset of .
we developed each of the tasks based on desiredproperties expressed in study .
however we rewrote the tasksso that the wording of the task would not make obvious whichproperty template should be used.
an example task follows y ou have a roomba robotic vacuum cleaner in your home and you ve given it a schedule for when it should clean the floor.however when the curtains in your home are open the drawstringlays on the floor and often causes the roomba to get stuck onthe string.
y ou want to make sure this does not happen again.
4at the time of the study our interface let users specify positive event state conditional properties through an event eshould always happen while state sis true template.
afterwards we replaced always with only to avoid ambiguity as shown in table i and figure .
for participant answers using this always template we interpret them as e should be triggered while s becomes true in this way judging three participants answers to be correct.
fig.
correctness of properties and rules by task.
p values are from holm corrected 2tests comparing the proportion of statements correct when written using rules versus properties.
this task could be completed successfully with the rules if roomba becomes on while the curtain is open then close the curtain i f curtain becomes open while roomba is on then turn off roomba or the property roomba is on should never be active while curtain is open .
we constructed the set of tasks so that at least two tasks could be completed witheach of the property templates.
since many properties canbe expressed in multiple ways though most templates couldbe used for more than two tasks.
after each task participants rated their confidence in their submission and perception of how difficult it was to completethe task on five point scales.
they also had the opportunity toexplain in free text any corner cases they had considered.after completing all tasks they filled out demographicsquestions and the standardized system usability scale.
we analyzed our data as follows.
since many tasks could be completed in multiple ways two researchers indepen dently coded each response as correct partially correct or completely incorrect meeting to resolve discrepancies.the partially correct category was used when a response didnot address a corner case.
to compare categorical data e.g.
the distribution of correct incorrect responses we used the test.
to compare ordinal data e.g.
confidence we used themann whitney u test.
to correct p values for multiple testing we used the holm method within each family of tests.
a key limitation is that the tasks were not intended to be a representative sample of all desired behaviors in tapsystems.
because the tasks were based in part on study they likely over represent behaviors that can be expressed asproperties.
while our study can show whether some tasks areeasier to express as rules or safety properties the proportionof tasks for which this is the case is not generalizable.
results a total of mechanical turk workers participated in study .
three gave nonsensical free response answers leaving valid participants.
for all tasks the percentage of correct responses was higher for autotap s property creation interface than for the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
tap rule interface.
this difference was statistically significant for five of these tasks the bolded p values in figure .
the tasks for which we observed significant differences generally required multiple rules to capture all corner cases.
for example in the aforementioned roomba task task in figure only one property is needed the window curtains are open should never be active while the roomba is on .
autotap automatically generates rules to satisfy this property in all situations.
however two rules are required.
one possibility is a rule closing the curtains whenever the roomba turns on and another turning off the roomba whenever the curtain is opened.
under of participants wrote both of these rules.
while over of participants who used the property interface solved this task one particular error appeared commonly.
the property the curtain is open and the roomba is on should alw ays occur together inadvertently binds the two states causing the roomba to start anytime the curtain is opened misinterpreting the intent.
participants often performed similarly with the rule and property interfaces when both a single rule and a single property sufficed.
for example task preventing a room from getting too hot required only one of each.
participants performed similarly with either interface.
autotap s property interface was more successful when multiple rules were needed to capture corner cases.
two tasks caused participants great difficulty even for properties.
task required either two properties or six rules.
all participants missed corner cases.
task dealt with delaying vacuuming when guests were over requiring either two properties or two rules.
most participants neglected to start the vacuuming after a delay.
we compared the system usability scale scores provided by users to the rule interface and autotap property interface.
we found both interfaces to be usable with mean scores of .
and .
respectively.
this difference was not statistically significant mann whitney u .
p .
.
b. tap program synthesis we further check if autotap can synthesize tap rules from scratch to accomplish all tasks in this user study.
in a less challenging version one of the authors representing an expert user wrote properties for every task and autotap successfully synthesized tap rules for all tasks.
in a more challenging version we used allthe correct properties written by user study participants sets of properties in total with each from one participant targeting one task .
sets contain .83properties on average.
these properties were transformed into ltl formulas following table i. autotap successfully generated tap programs for out of the property sets and all are guaranteed to satisfy corresponding properties.
the only set that autotap failed to synthesize is for when bobbie is in the kitchen the oven door should be closed and when bobbie is in the kitchen the oven door should be locked.
if bobbie enters the kitchen when the oven door is open the system needs to trigger two actions immediately both closing and locking the oven door.
autotap fails to find a solution because it currently only considerstable ii how autotap fixes buggy tap programs.
subscripts are the of cases autotap patches revert the mutation.
source buggy tap sets successful fixing mutation change trigger event mutation add condition mutation change condition mutation change action mutation delete rule total using a single action to redirect each bridge edge in the b uchi automaton.
future work can extend autotap to consider using multiple actions to redirect a bridge addressing this limitation.
we also checked how many tap program candidates autotap generates for one property set.
on average autotap generates .13candidates for one set with a median of .
the largest set contains 27candidates.
this is a special case as the program consists of three rules.
for every rule the potential action could be opening any one of three windows in a house.
even in this case end users will not face 27candidates at once.
they will only need to make a one out of three choice three times.
as all candidates satisfy users desires autotap can also randomly pick one candidate.
c. tap program fixing we randomly take 10correct tap program written by userstudy participants and apply a wide variety of mutations to them as shown in table ii.
autotap successfully fixes the buggy tap program to satisfy the given property in out of cases showing its generality across different types of tap bugs.
the two cases where autotap fails are like the following.
the task is the thermostat should never be above f and the rule is if thermostat goes above f then set thermostat to f with the action randomly mutated from set thermostat to f .
since the buggy rule triggers itself recursively and autotap does not regard intermediate triggering states as violating properties autotap could not identify the bridge edges and hence did not repair the program.
as also shown in table ii autotap often generates a patch to revert the add condition mutation or the delete rule mutation but not for all types of mutations.
the reason is that autotap only fixes the part of a tap program that violates the safety property.
if a rule becomes a non violating different rule after mutation autotap will not revert the mutation back.
d. handling multiple properties properties that share the same capabilities of devices sometimes interfere with each other.
we evaluated autotap on 7scenarios where such things happened with each scenario combining different property sets in our user study together.
for example one scenario could contain two properties the living room window the bedroom window and the bathroom window should never be closed together and the living room window should always be closed while it is raining .
autotap simply combines different properties and together as .
it successfully handles all scenarios by authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generating tap programs to satisfy every multi property scenario unless the properties conflict with each other.
in the latter case autotap correctly reports that no tap rules can possibly guarantee all the properties.
one example of conflicting properties is the window should always be open and the window should never be open when the air conditioner is on.
vii.
t hrea ts to auto tap svalidity autotap is not guaranteed to generate patches for every ltl safety property.
patches are generated by the current prototype of autotap when bridge edges are found and the bridge can be cut with a single tap rule.
the out of cases where autotap fails to synthesize a tap program in section vi b violates the second assumption.
the out of cases where autotap fails to fix a tap program in section vi c violates the first assumption.
both limitations can be fixed by future extensions to autotap.
furthermore the first assumption does not hold if every state is accepting meaning that no matter what actions we take in the system we cannot prevent it from triggering a violation.
the second assumption does not hold when there are no controllable actions to escape from a property violation.
that is only events out of our control e.g changing the weather help.
these scenarios occur when the system lacks critical functionality or the property itself is conflicting which is out of scope for autotap.
we focus on tap instead of other smart device languages mainly because tap is widely used and easy for endusers to understand .
autotap is not limited to tap .
cutting bridge edges that cause property violations can be accomplished in other automation languages too.
in fact we feel that some bridges might be better fixed by disabling rules that can conditionally disable actions.
autotap currently does not consider issues like actions failing to complete or not taking effect immediately .
handling these issues requires device manufacturers to provide a more accurate model of the system.
furthermore users can still make mistakes in writing properties.
their properties might not reflect their real intent.
properties could even conflict with each other which autotap does not currently resolve.
viii.
r ela ted work tap program bug detection and fixing autotap is inspired by previous work that applied formal methods to detect violations to ltl or ctl policies in tap programs.
previous work searches potential tap patches by changing trigger states of existing tap rules in three ways deleting a conjunction clause adding a conjunction clause that appears in the ltl ctl policy or modifying numerical parameters.
consequently they cannot synthesize patches that change tap rules trigger events or rule actions not to mention creating new tap rules from scratch.
the end user propertyspecification interface of previous work only accepts shall not happen missing many common desires.
triggen detects a specific type of bug in openhab tap programs missing triggers.
it works by checking what events not included in the trigger could possibly affect therule conditions.
researchers have also developed techniques for either crowdsourcing tap rules or synthesizing tap rules from natural language .
our synthesis and repair techniques are complementary to those techniques.
program synthesis using formal methods synthesizing a program from a formal specification or ltl synthesis has been an open problem .
most work in this area synthesizes reactive systems based on formal specifications .
autotap is related to but also fundamentally different from such work.
autotap needs to synthesize tap rules not just finite state models and needs to accommodate for an existing finite state model i.e.
the smart device system model .
degiovanni et al.
proposed an algorithm that synthesizes control operation programs which have similar syntax as taps to satisfy formal requirements .
due to the different usage contexts their algorithm which uses sa t solvers to iteratively resolve counter examples by changing existing rules trigger states cannot add new rules or preserve existing property compliant behaviors.
property specification interfaces past work in requirements engineering investigated how to let engineers specify desired software properties.
kaos provided guidelines that helped engineers gradually summarize or break down vague requirements into deployable specifications .
pspwizard provided an interface where developers could choose from a comprehensive list of templates fill in the blanks of the chosen template and then have their inputs translated into formal specifications .
in contrast with those efforts we employed a user study to identify commonly desired properties in smarthome scenarios.
we then designed property specification templates for expressing those properties through a compact graphical interface.
autotap users specify properties through only mouse clicks which is suitable for non technical users.
ix.
c onclusions with the wide adoption of smart devices helping users correctly express their intent for how these devices should interact is crucial.
autotap helps users by allowing them to directly specify properties they wish to hold rather than writing rules for exactly how devices should behave in order to satisfy those properties.
to achieve this goal we first conducted a user study to map the properties users commonly desire.
we then designed an easy to use interface for property specification and a technique supported by formal methods to automatically synthesize tap programs or program patches that guarantee the system satisfies the specified properties.
x. a cknowledgments this material is based upon work supported by the national science foundation under grants ccf oac1835890 cns cns cns and iis as well as gifts from the ceres center.
we thank abhimanyu deora for help with the user interface and roshni padhi for help with the user studies.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.