ufo predictive concurrency use after free detection jeff huang parasol laboratory texas a m university jeff cse.tamu.edu abstract use after free uaf vulnerabilities are caused by the program operating on a dangling pointer and can be exploited to compromise critical software systems.
while there have been many tools to mitigate uaf vulnerabilities uaf remains one of the most common attack vectors.
uaf is particularly difficult to detect in concurrent programs in which a uaf may only occur with rare thread schedules.
in this paper we present a novel technique ufo that can precisely predictuafs based on a single observed execution trace with a provably higher detection capability than existing techniques with no false positives.
the key technical advancement of ufois an extended maximal thread causality model that captures the largest possible set of feasible traces that can be inferred from a given multithreaded execution trace.
by formulating uaf detection as a constraint solving problem atop this model we can explore a much larger thread scheduling space than classical happens before based techniques.
we have evaluated ufoon several real world large complex c c programs including chromium and firefox.
ufo scales to real world systems with hundreds of millions of events in their execution and has detected a large number of real concurrency uafs.
ccs concepts software and its engineering software testing and debugging security and privacy browser security keywords uaf concurrency vulnerabilities ufo acm reference format jeff huang.
.
ufo predictive concurrency use after free detection.
in icse 40th international conference on software engineering may june gothenburg sweden.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
introduction programs written in unsafe languages such as c c are prone to memory errors.
among them use after free uaf vulnerabilities are a severe threat to software security.
just a few years back uaf vulnerabilities have become the most exploited memory errors in both windows vista and windows and many zero day cyber attacks targeting web browsers and network servers have been launched through uaf vulnerabilities .
a uaf occurs when the program accesses data via a dangling pointer a pointer which points to an invalid object i.e.
the memory that stored the object has been deallocated and or reallocated for storing another object.
uafs are particularly difficult to detect in concurrent programs in which multiple threads may interleave when accessing memory via pointers.
due to different thread schedules a program can execute in many different ways even with exactly the same program input.
when the useandfreeof a certain pointer happen in different threads and are not properly synchronized they may constitute a uaf that can rarely manifest in the testing phase because the particular thread schedule thattriggers the uaf is difficult to occur.
however the uaf has a much larger chance to happen in production runs where there is a large user base to exercise different schedules and worse the schedules may be controlled by attackers .
existing techniques are very limited in detecting such concurrency uafs .
most dynamic tools e.g.
addresssanitizer and kasan are evidence based such that they can only detect a uaf when it actually happened.
otherrecent techniques such as dangsan dangnull and freesentry are effective in preventing uaf vulnerabilities by tracking pointers at runtime and nullifying them before the pointed objects are destroyed but they cannot defend uaf vulnerabilities that are not observed.
web browsers are one of the hardest hit areas of concurrency uaf vulnerabilities.
browsers are often built fromcomponents using different memory management methods.for example in google chrome and firefox javascript objects are garbage collected xpcom objects are referencecounted and the layout engine uses manual management.
this mixture makes it extremely difficult to reason about objects shared between codes using different memory management methods.
figure shows a priority most urgent bug that affects the recent chrome browser on linux and os x as well as chrome os.
in this bug client is a midimanagerclient object and it is managed by a renderer process send thread is owned by the browser process which is independent of any renderers.
it is possible that the client is freed when the corresponding renderer process acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jeff huang midimanageralsa dispatchsendmididata ... send thread .message loop posttask from here base bind midimanagerclient accumulatemidibytessent base unretained client data.size ... figure a real world concurrency uaf in the chrome browser dies but the tasks are still in the message loop.
when the task starts it calls midimanagerclient accumulatemidibytessent on the client which is already freed.
this bug is a typical concurrency uaf and can be exploited to escape the sandbox .
in this paper we present a novel technique called ufo uaf finder optimal for detecting concurrency uafs.
a salient feature of ufois that it can predict uaf vulnerabilities that are unseen from the observed execution but guarantee to happen in an alternative run of the same program with a different schedule.
moreover every reporteduaf by ufomust be real and reproducible with a corresponding schedule to manifest it.
such an ability which we callsound predictability is unique for concurrent programs because alternative thread schedules can be inferred from anobserved execution based on a sound thread causality model such as the classical happens before model or the more recent maximal causality model maxmodel .
ufois underpinned by the maxmodel discussed in more detail in section .
a key strength of maxmodel is that given an observed execution trace i.e.
t h eseedtrace it can capture the maximal set of feasible traces that can be inferred from the seed trace.
however maxmodel is blind to semantic properties such as uafs.
by extending maxmodel with additional useandfreeevents to support uaf detection ufois empowered with the maximal predictive power ufo detects all possible and real concurrency uafs based on an observed seed trace and it is impossible to precisely detect more concurrency uafs than ufobased on the same seed trace1.
in other words any new uaf that is not detected by ufobut detected by another technique on the same observed execution could be a false positive.
moreover we introduce a novel constraint encoding for uafs.
this is challenging because of the uaf semanticsand memory reuse section .
.
.
by encoding both theuaf violations and the extended maxmodel as first order logical constraints over the observed events in the execution and solving the constraints with a high performance smt solver ufodetects a maximal number of real uafs from the observed traces.
1to clarify ufomay still miss real uafs under a different seed trace e.g.
one generated from a different program input.we have implemented ufofor pthread based multithreaded c c programs based on threadsanitizer and evaluated it on several large real world concurrent systems including the chromium and the firefox web browsers.
our experimental results show that ufois powerful in detecting uafs and can scale to real world program executions with hundreds of millions of critical events.
ufodetected many uaf vulnerabilities that industrial strength tools such as addresssanitizer dr.memory and valgrind all fail to detect.
at the time of writing ufohas detected uafs in chromium and in firefox.
in summary this paper makes the following contributions we present ufo a powerful predictive detection technique for concurrency uaf vulnerabilities.
to our best knowledge ufois the first concurrency uaf detection technique with sound predictability i.e.
i tc a n precisely predict a maximal set of uafs from a multithreaded program execution trace while the predicted uafs are all real and can be reproduced.
we implement and evaluate ufoon both popular benchmarks and real applications.
experiments show that ufocannot only detect known uaf violations but also new uafs that cannot be detected by industrialstrength tools.
moreover with numerous performance optimizations ufoscales to large complex programs such as chromium and firefox.
ufois open source .
motivation in this section we show how ufocan predict uafs from an observed execution why it has a higher detection capability than other uaf detectors and why it is precise i.e.
every reported ufois real.
initially x 0p malloc q malloc thread1 .
start t2 .
lock l .
free q .
unlock l .
lock l .x .
unlock l .
free p .
join t2 thread2 .
lock l .
q .
if x .
p .
unlock l figure motivating example.
figure shows a simple example illustrating the uaf problems in a multithreaded program.
the program contains two possible uafs the pointer dereference at line executed after free q at line which is a real uaf that can occur under certain thread interleavings a potential uaf between lines and which in fact can never occur.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ufo predictive concurrency use after free detection icse may june gothenburg sweden suppose that the program is executed following the schedules0denoted by lines s0 the evidence based uaf detectors cannot find the real uaf because it does not occur in the observed schedule.
the classical happen before based data race detectors can neither find this uaf because at the time when the free q operation is executed threads and are happens before synchronized by the unlock l operation at line and the lock l operation at line .
in other words there is a determined happen before edge from the event at line to the event at line .
however it is possible that thread acquires the lock lfirst and frees the memory pointed byqat line before the pointer access at line following the schedule s1 s1 which manifests the uaf .
how about the uaf between lines and ?
it should be noticed that in the example above the read xat line can read different values depending on the execution of line .
in other words the pointer dereference at line is control dependent on line .
if the free p operation at line is executed before line then line will read value on x and hence line will not be executed.
thus the uaf is a false positive.
ufocan detect the real uaf and at the same time precisely determine that the uaf is not possible hence prevents from reporting any false positives .
the basic idea of ufois to infer other feasible schedules based on an observed execution trace and to detect uafs in all the inferred schedules in addition to the observed schedule.
ufois inspired by early work on predictive race detection which proposes a maxmodel to capture a maximal set of feasible schedules from a trace.
by encoding all potential pointer uafs as additional constraints to the maxmodel ufois able to verify all feasible uafs that can be inferred from an execution.
the key technical novelty of ufois extending the maxmodel to support uaf detection which requires both extending the original trace model and efficiently encoding uaf constraints while ensuring every detected uaf is real and no uaf is missed.
moreover we develop two practical optimizations to improve the runtime performance of ufo.
in the rest of this paper we first introduce the maxmodel in section and then present the design and technical details ofufoin section .
we present the implementation of ufo in section and evaluation results of ufoin section .
maximal causal model taking as input an observed execution trace of a multithreaded program the maxmodel captures the largest set of feasible traces that can be inferred from the observed trace.
this allows us to detect all potential uaf vulnerabilities captured by the maxmodel that are also real for every detected uaf there exists a valid execution that manifests it possibly via an alternative schedule .a trace is a full sequence of events which are operations performed by threads on concurrent objects.
for example a write event to memory location xwith value vby thread t is denoted as write t x v .
a full sequence means that all events on concurrent objects are included i.e.
no critical event is missing.
the following common types of critical events by a thread t are considered in the original maxmodel read t x v write t x v read write xwith value v lock t l unlock t l acquire release lock l start t t fork a new thread t prime join t t block until thread t primeterminates.
begin t end t the first last event of thread t these are extra events introduced to capture the happensbefore relation between threads.
when a multithreaded program pis executed a set of finite traces of events will be produced called p feasible traces.
there are two important properties held by the sets ofp feasible traces prefix closedness andlocal determinism .
the former says that the prefixes of a p feasible trace are also p feasible.
the latter means the execution of a concurrent operation is only determined by the previous events in the same thread.
more specifically prefix closedness p feasible is prefix closed if 1 2 p feasible then 1 p feasible.
prefix closedness ensures that the events are generated in execution order with the possibility of interleaving in between any of them.
local determinism each event is determined only by the previous events in the same thread and not other events of other threads and can occur at any consistent moment after them.
in addition to the two basic axioms defined above the sets ofp feasible traces must also obey a memory consistency model i.e.
which value a read can return.
note that the event valueis also a part of the definition.
for example if the value returned by a read is changed it becomes a different read event such that a conditional after the event may produce a different trace.
the original maxmodel focuses on sequential consistency and has also been extended to relax memory models such as tso and pso .
in this paper we follow the original maxmodel for sequential consistency only.
together maxmodel enables associating a maximal set of traces maxmodel to any consistent trace which comprises precisely the traces that can be generated by any program that can generate .i ti ss h o w ni n t h a t maxmodel is both sound and maximal any program which can generate can also generate all traces in maxmodel and for any trace primenot in maxmodel there exists a program generating which cannot generate prime.
in contrast traditional happens before causal models consisting of all the legal interleavings of are not maximal.
in other words there are feasible traces that are captured by maxmodel but not by the happen before model.
example consider the example in figure again.
the trace 0as shown in figure will be generated following the schedule s0.
note that the original maxmodel does not model pointer useandfreeevents.
for illustration purpose authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jeff huang trace 0 .
start t1 t2 begin t2 lock t2 l read t2 q q write t2 q read t2 x read t2 p p write t2 p unlock t2 l end t2 lock t1 l read t1 q q write t1 q .
unlock t1 l .
lock t1 l .
write t1 x .
unlock t1 l .
read t1 p p .
write t1 p .
join t1 t2 trace .
start t1 t2 lock t1 l read t1 q q write t1 q .
unlock t1 l begin t2 lock t2 l read t2 q q write t2 q read t2 x read t2 p p write t2 p unlock t2 l end t2 .
lock t1 l .
write t1 x .
unlock t1 l .
read t1 p p .
write t1 p .
join t1 t2 figure traces for the motivating example.
we use two events a read and a write to model each pointer use and free.
for example p 0at line corresponds toread t2 q q andwrite t2 q i nw h i c h q denotes the left value of the pointer q i.e.
the address of memory location storing the pointed value .
in the next section we will extend maxmodel to support uaf detection.
from 0 the trace 1 which manifests the uaf can be inferred by the maxmodel .
however this trace is not allowed by the traditional happens before model because there is a happens before edge from the unlock t2 l event at line to the lock t1 l event at line .
on the other hand there is no way to generate a trace in maxmodel that can put the event at line after the event at line which could manifest the uaf because that would violate the local determinism and memory consistency model of maxmodel .
more specifically if line is after line then the value of x will be set to by the write event at line first and the read event at line will return the value instead of as that in 0 .
because the read event at line is now a different event it is possible that the event at line becomes infeasible e.g.
due to a ifbranch as in the example program .
predictive uaf detection the maxmodel allows us to define a maximal notion of uafs a trace has a uaf iff there is some prime maxmodel which contains a read or a write to a memory region that has already been deallocated.
in this section we first extend maxmodel to support concurrency uaf detection by introducing new types of events.
then we present our algorithm for detecting uafs by encoding both the extended maxmodel and the uafs as first order logical constraints.
.
extended maxmodel we introduce three additional types of events into the model malloc t addr size allocate a new memory region from the address addrtoaddr size use t addr range read write the memory region from address addrtoaddr range free t addr size deallocate the memory region from address addrtoaddr size such that it can be reused.
these events are relevant to the uaf detection and all their attributes can be obtained at runtime.
a malloc event corresponds to allocating a dynamic memory on the heap e.g.
creating a new object.
the addrandsizecorrespond to the return value and the calling parameter respectively of the malloc size t size function or calloc new .
when memory allocation is done the actual heap space allocated is one word larger than the requested memory.
the extra word is used to store the size of the allocation andis later used by free.auseevent is an ordinary read or write event that accesses a memory region.
the addrand range correspond to the beginning address of the accessed memory and the bit length of the accessed data.
a free event corresponds to a memory deallocation function free delete o r realloc and the attributes addr andsize correspond to the beginning address and the size respectively of the deallocated memory.
.
the ufoalgorithm given an observed trace with all the events in the extended maxmodel included our basic idea for detecting uafs is to generate maxmodel and the uaf conditions among the events in both are encoded as constraints.
by solving the conjuncted constraints with an smt solver we can determine if there exists any trace prime maxmodel in which a free event is executed before a useof the same memory region and the memory address of the use is originated from the samemalloc corresponding to the free.
we introduce an order variable oifor each event eiin and construct a formula over these variables in which oi ojmeans that the event eihappens before the event ej.
is a conjunction of two sub formulas max uaf where maxencodes the maxmodel and uafencodes each potential uaf.
in the rest of this section we present max and uafin detail.
.
.
maxmodel constraints.
maxis constructed by a conjunction of two sub formulas sync rw where sync denotes the inter thread order constraints determined by synchronization events and rwthe data validity constraints over read and write events.
synccan be further decomposed as mhb lock the conjunction of the must happen before constraints mhband the lock mutual exclusion constraints lock.
must happen before constraints mhb .the must happenbefore mhb constraints reflect a subset of the classical happens before relation ensuring a minimal set of ordering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ufo predictive concurrency use after free detection icse may june gothenburg sweden relations that events in any feasible interleaving must obey.
specifically mhb requires that the total order of the events in each thread is always the same a beginevent can happen only after the thread is started by another thread ajoinevent can happen only after the endevent of the joined thread.
clearly mhb yields a partial order over the events of which must be respected by any trace in maxmodel .
we denote mhb by which will be used later.
we can specify easily as constraints mhbover the ovariables we start with mhb trueand conjunct it with a constraint oe1 oe2whenever e1ande2are events by the same thread ande1occurs before e2 o rw h e n e1is an event of the form start t t prime ande2of the form begin t prime etc.
lock mutual exclusion constraints lock .the locking semantics requires that any two code regions protected by the same lock are mutually exclusive i.e.
they should not interleave.
lockcaptures the ordering constraints over lockand unlock events.
for each lock l we extract the set slof all the corresponding pairs ea eb o flock unlock events on l following the program order locking semantics the unlock is paired with the most recent lockon the same lock by the same thread.
then we conjunct lock truewith the formula logicalanddisplay ea eb ec ed sl oeb oec oed oea data validity constraints rw .the data validity constraints ensure that every event in the considered trace is feasible.
note that in constructing mcm for an input trace the considered trace does not necessarily contain all the events in but may contain a subset of them so that all the trace prefixes corresponding to partial executions of the program are considered as well.
for an event to be feasible all the events that must happen before it should also be feasible.moreover every read event that must happen before it shouldread the same value as that in the input trace otherwise the event might become infeasible due to a different value read by an event that it depends on.
each read however mayread a value written by any write as long as all the other constraints are satisfied.
let edenote the set of events that must happen before an event e. consider a read event rin e read t x v w e letwxbe the set of write x events in denotes any value and wx vthe set of write x v events in .
the data validity constraint of an event e rw e is defined as logicalandtext r e value r where value r logicalortext w wxv rw w ow or logicalandtext w negationslash w prime wx ow prime ow or ow prime the constraint rw e enforces that every read that musthappen before eshould read the same value as that in the input trace.
the constraint value r v enforces the read eventr read t x v to read the value vonx written by anywrite eventw write x v inwr v subject to the condition that the order of wis smaller than that of rand there is no interfering write x in between.
in addition witself must be feasible which is ensured by rw w .since the maxmodel models all the partial traces as well the data validity constraint rwis thus satisfiable if any event in the input trace is feasible written as a disjunction of the feasibility constraints of all events in rw logicalordisplay e rw e it is worth noting that each solution of the order variables to maxcorresponds to the schedule of a trace in maxmodel .
the size of maxmodel may be huge as the number of unique solutions to can be exponential.
in practice however we do not need to directly solve maxto produce all the schedules in maxmodel .
for example when used for checking uafs it suffices to find one schedule that satisfies the uaf condition.
.
.
uaf constraints.
in large programs memory allocation and deallocation requests from function call such as malloc andfree can be very frequent because the application memory is heavily reused.
it is common that the memory region returned for one malloc request overlaps with a previousmalloc request which has been freed .
when a useevent accesses a memory region that overlaps with another memory region that has been freed before it does not necessarily mean a uaf because the memory region may have beenreused.
to illustrate this problem consider the example in figure thread1 .
p1 malloc address .
free p1 .
p2 malloc address ... .
p thread2 ... .
free p2 .
p3 malloc address thread3 ... .
free p3 figure a memory access event matched with multiple malloc and freepairs.
there are three malloc andfreepairs pair1 withmalloc at line and freeat line pointed by p1 pair2 with malloc at line and freeat line pointed by p2 pair3 withmalloc at line and freeat line pointed by p3.t h e corresponding memory regions are and .
the write event at line writes to the address and it happened in parallel with pair2 andpair3 .
because it is unclear from the generated event trace where authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jeff huang p4is derived from it is hard to determine whether the write should be matched with pair1 pair2 o r pair3.
to address this problem we propose three solutions no memory reusing pointer origin tracking and purely constraint solving.
the first solution is simple do not really perform the free.
we modify the memory allocator such that upon a free we only record the free operation in the trace but do not free the actual memory.
this works well for test runs with small inputs as long as the memory is not exhausted but may not work for production with long running executions.
the idea of origin tracking is to associate each useand freeevent with a corresponding malloc which the used memory address propagates from.
this solution produces simple constraints because each usecan be match with a unique free according to their associated malloc event.
the downside is that it requires data flow tracking on pointers at runtime which incurs extra performance overhead.
the third solution does not require pointer tracking but generates more constraints.
the basic idea is that when there are multiple malloc free pairs that a usemay match with although it is unknown which pair the useshould be matched with there must be a uaf if the use can be matched with more than one pair.
the reason is that a safe usecan be matched with one and only one malloc free pair.
otherwise it means that the memory address of the useoriginated from one malloc is used to access a memory region allocated by another malloc.
we next present these two solutions in more detail.pointer origin tracking .
this approach tracks the origin of the pointer address in the useevent i.e.
w h i c hmalloc event it corresponds to.
similarly for each freeevent we track its corresponding malloc event which allocates the memory region that the freeevent deallocates.
the difference is that amalloc event is expected to have a unique corresponding freeevent.
otherwise if there is more than one the program has a double free error and if there is none the program has a memory leak.
since we focus on detecting uafs only we assume there is a one to one mapping from malloc tofree events.
we hence perform an online data flow analysis on pointer variables to record the malloc event of the pointer address that is used by each useevent and each freeevent.
more specifically for each p malloc size operation we call the corresponding malloc event as the origin of the pointer p. if the value of pflows to another pointer p then the malloc event of pis also the origin of p .
when p is used in a use orfreeevent we can connect the useorfreeevent with the origin i.e.
t h emalloc.
after matching each useandfreewith the malloc event we can encode the uaf constraint as follows for each free event efree and for each useevent euse that has the same origin as efree we add the constraint uaf euse efree.
if uaf maxis satisfiable it means that there exists a schedule of the program which produced in which euse happens after efree.
in other words the useof a pointer happens after the freeof the memory pointed by the pointer.purely constraint construction .
consider a useevent euseand suppose it has three potentially matching malloc free pairs p1 em1 ef1 p2 em2 ef2 and p3 em3 ef3 .
ideally we would construct three constraints om1 ouse of1 om2 ouse of2andom3 ouse of3 and count the number of solutions.
if at least two of these three constraints can be satisfied conjuncted with the constraints generated from maxmodel theneusewith one of the two freeevents whose constraints are satisfied constitutes a real uaf.
however solving such constraints requires computing the number of solutions for individual constraint clauses which isnot well supported by existing high performance smt solvers s u c ha sz .
we hence develop a sub optimal solution for this problem but generates simple constraints.
it is suboptimal in that it does not encode all possible uafs but only a subset of them.
the key idea is that all malloc free pairs with overlapping memory regions must be globally ordered i.e.
all these malloc andfreeevents must be synchronized.
if a usecan happen outside of all its potentially matching mallocfree pairs then it must be a uaf.
in other words suppose the three malloc free pairs p1 p2 p3 are globally ordered as em1 ef1 em2 ef2 em3 ef3in the observed trace.
then if in a certain schedule the useeventeusecan be executed in the gap between any freeand its next malloc then the eusemust be involved in a uaf.
the constructed constraints can be written as of1 ouse om2 of2 ouse om3 of3 ouse .
mhb o1 o ... o o10 o ... o o1 o o14 o lock o4 o o14 o o4 o o14 o rw o12 o uaf1 o3 o uaf2 o8 o figure the encoded constraints for the motivatingexample in figure .
.
example figure shows the constructed constraints for the two possible uafs and in our motivation example in figure .
for the uaf constraint is written as o3 o because theuseevent at line and the freeevent at line have the same origin which is the malloc event corresponding to the statement q malloc .
similarly the uaf constraint for is written as o8 o .
figure also shows the constructed constraints for max.
for example o1 o 2is included in mhbbecause the event at line should always happen before the event at line and o1 o 10because the first event of thread2 should happen after its starting event by thread1 at line .
mhbis written as o4 o o14 o o4 o o14 o authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ufo predictive concurrency use after free detection icse may june gothenburg sweden because the three lock regions protected by lock unlock event pairs at lines and cannot overlap.
rmis written as o12 o because the read event on xat line returns the value in the observed trace and to ensure the consistency of this read event and the feasibility of the other events following it the write event at line which writes toxmust happen before it.
next we employ an smt solver to solve each formula max uaf1and max uaf2.f o r the solver returns a solution in which o1 o2 o3 o4 o5 o6 o7 o8 o9 o10 o11 o12 o13 o14 corresponding to the schedule .
hence we find a real uaf vulnerability free q line can be executed before q line following the schedule above.
for however the formula is not satisfiable so it is not a real uaf.
ufo implementation we have implemented ufobased on threadsanitizer and the z3 smt solver for pthread based multithreaded c c programs with around 12k additional code.
ufo consists of two main phases online program tracing and offline predictive trace analysis.
.
trace generation we modified threadsanitizer to generate the trace containing events defined in our extended maxmodel .
to generate memory access events we first instrument the target program with an llvm pass and record each load or store instructions on anon local variable as a tuple angbracketlefttid pc addr iswrite value pc angbracketright .
for implicit events through function calls e.g.
free delete memcpy andstrcmp we wrap these functions during linking.
when these functions are invoked at runtime we intercept the call and generate an event from thefunction type and parameters.
for example memcpy a b by thread twill generate two events range read t b andrange write t a .
to map the events back to the source code when reporting uaf violations besides the memory access and thread interaction information we store in the events the pc which is the code address of the load store instruction or the called function as well as the address and offset of each module loaded by the target program.
all events are encoded in a compact format and are written to files for offline predictive analysis.
at runtime a huge number of events will be generated in a very fast way around twenty million events per second and the normal execution of an application may be blocked for a relatively long time when flushing events to disk.
to reduce the runtime perturbation from the tracing library we allocate a thread local buffer for each live thread such that events are buffered first.
when a thread local buffer is full it is flushed to a global buffer queue such that the application thread can continue executing without being blocked.
a worker thread running the background is invoked once a local buffer is flushed andcompresses the data in the queue using snappy and flushes it to disk asynchronously.
for multiple process programs e.g.
chromium andfirefox we store the trace of each process in separate directories and invoke the analyzer for different processes in parallel to improve the performance.
in addition because uafs cannot happen in a single thread we do not start tracing until the first child thread has been forked by the main thread.
.
trace analysis in the trace analysis phase we build the maxmodel constraints from the thread local traces.
then we search for malloc andfreepairs and the conflicting memory accesses.
in our implementation we only consider concurrency uafs i.e.
theuseandfreeevents are from different threads.
for each pair of useandfreeevents that have overlapping memory region we first run a fast happens before algorithm to identify candidate uafs.
if the useandfreedo not happen before each other by inter thread synchronization we consider them as a candidate uaf.
for each candidate uaf we proceed to build the constraints uaf maxand invoke z3 to solve them.
the default constraint solving time is set to two minutes for each invocation.
if the solver returns a solution we report the uaf as well as the schedule that can manifest it.
to report the detected uafs we first retrieve the pcs of the call stacks from the trace and calculate the offset address of each pc from the stored module information.
we theninvoke a symbolizer e.g.
llvm symbolizer oratos to map the uaf to the source code.
for long running programs the size of the generated trace could be very large and it is difficult to even load andprocess the whole trace.
in addition long traces lead to a huge number of constraints which are difficult to solve in a reasonable time.
previous predictive techniques propose a windowing strategy which splits the whole trace into pieces and analyzes only a limited number of events each time.
in ufo we design an adaptive windowing algorithm that loads events based on the number of threads alive in that specific window the fewer threads the more events we load.
for example in a period of execution if there are more threads interacting with each other the number of events loadedfrom each thread is decreased.
one limitation of splitting the trace is that if the conflicting useandfreeare loaded in different windows some real uafs may be missed.
evaluation in this section we aim to answer the following two questions uaf detection effectiveness can ufodetect real uafs in real world applications?
if so how effective is it?
performance what is the runtime overhead of ufo?
what is the trace size and how efficient is the offline analyzer?
can it scale to read world large programs?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jeff huang table experimental results on pbzip2 and httrack.
programtrace uaftime threads events read write sync malloc use free candidate real pbzip2 14s httrack .7m .6m 4m .9k .6m .8k 9s .
methodology we evaluated ufoon four real world open source programs including two popular benchmarks with known uafs pbzip2 or concurrency bugs httrack collected from and two popular web browsers chromium andfirefox .f o r chromium andfirefox we conducted a set of real user interactions and generated a collection of traces.
we set the timeout period for analyzing each trace to two hours and the adaptive window size to 100k.
for performance evaluation we collected three popular web benchmarks octane sunspider and dromaeo and measured the runtime overhead and trace file size by running the ufoinstrumented browsers with these benchmarks.
for encoding the uaf constraints we evaluated all the three solutions recall section .
.
.
we found that the simple no memory reusing solution works well for our uafdetection tests but it does not work for the performance tests because the memory can be quickly exhausted .
both the pointer origin tracking and the purely constraint construction solutions work for performance tests but purelyconstraint construction works better it detects the same number of unique uafs as that by the pointer origin track ing solution.
however it is more efficient at runtime because tracking the dynamic flow of pointers is expensive e.g.
i t incurs around 4x additional runtime overhead.
the uafdetection data reported in section .
corresponds to thesimple solution and the performance data in section .
corresponds to the purely constraint construction solution.
all experiments were conducted on an core .60ghz intel i7 machine with 24gb memory running ubuntu .
.
.
uaf detection effectiveness .
.
pbzip2 and htt rack.
table summarizes the results onpbzip2 andhttrack .
overall ufodetected real uafs in pbzip2 a n d4i n httrack .
we note that every report uaf by ufohas a unique signature we remove those dynamic uafs from the same program source locations .
we also tested these two benchmarks with addresssanitizer dr.memory and valgrind .
none of the other tools reported any uaf violations in normal executions of these programs because no real uaf actually happened in the observed trace.
pbzip2 is a frequently studied parallel compression tool containing known uafs .
to decompress a file it first loads the file into memory and stores the chunks in a fifo list and then starts several new threads to operate on the fifo list.
however due to the lack of proper synchronization itis possible that the fifo list is deleted by the main thread before the other parallel tasks finish.
the observed tracecontains four thread with a total of events including reads or range reads writes or range writes and synchronization events thread fork join mutex lock unlock etc.
.
there are malloc free and use events.
in total ufodetected candidate uafs i.e.
pairs ofuseandfreeevents accessing overlapping memory regions but are from different threads .
among them are verified to be real i.e.
the solver returns solutions to the generated constraints .
for example ufodetected six real uafs in pbzip2 for each file operation there are six accesses to the fifo list in the void consumer void function which are not properly synchronized with the freecall from the main thread.
the total offline analysis time is 14s.
httrack is an offline browser utility that can download a web site to local directory.
it has a known order viola tion concurrency bug between creation of a global data structure global opt and the use of it which may result in null pointer dereference and hence program crashes.
however it was unknown if this program has uaf vulnerabilities or not.
ufoconfirmed that httrack does have uaf vulnerabilities.
the observed trace contains two threads performing more than 27m events in total including .6m reads 4m writes synchronization events 39k malloc free and .6m useevents.
in total ufodetected candidate uafs among which uafs are verified to be real.
the total offline analysis time is 9s.
.
.
chromium and firefox.
we evaluated ufoonchromiumandfirefox both built from trunk as of july .
to generate traces that contain risky useandfreeevents we manually checked their issue trackers and analyzed the current unresolved issues.
we found that the pdf module and the printing facilities in chromium are more prone to bugs than other components.
several unresolved issues are related to actions related to pdf and printing.
in our experiments we conducted a number of browser actions related to pdf and printing open five pdf files including one that triggered a uaf vulnerability in mupdf print these pdf files cancel printing jobs close files before printing finishes etc.
in addition we opened several rich web pages such as youtube andfacebook and performed actions related to multimedia and printing.
in total chromium forked processes with threads together firefox forked processes with over threads.
ufotook hours to analyze the 162gb compressed traces and detected uafs in chromium and in firefox in four processes.
the results are reported in table .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ufo predictive concurrency use after free detection icse may june gothenburg sweden table experimental results on chromium and firefox.
program pidtrace uaftime threads events read write sync malloc use free candidate real chromium 222m 140m 80m 446k 655k 220m 545k 469s 268m 170m 90m 340k 650k 266m 530k 108s firefox 520m 370m 148m 740k 965k 518m 660k 1323s 145m 110m 34m 180k 225k 144m 147k 83s table performance evaluation on chromium and firefox.
benchmark chromium firefox original scoreufo original scoreufo score event trace size score event trace size sunspider .1g gb .4g .4gb octane .9g .5gb .8g .0gb dromaeo js .4g .5gb .1g .7gb dromaeo dom .1g .8gb .8g .7gb for instance for a chromium process pid the trace contains threads performing 220m events in total including 140m reads 80m writes 450k synchronization events 660kmalloc 550k free and 220m useevents.
ufodetected candidate uafs among which uafs are verified to be real by z3.
the total offline analysis time is 469s.
for the firefox process pid the trace contains threads performing around 520m events in total including 370m reads 148m writes 740k synchronization events around 1m malloc 660k free and 518m useevents.
in 1323s ufo identified candidate uafs and verified that uafs are real.
many uafs share the same free site but with different use sites.
we have also manually inspected these uafs and reported them to the developers.
however due to complexity of these two projects developers are still in the processof confirming them.
many uafs found in chromium are under the base message loop package where a pointer freed by a child thread we believe it is a render thread in theincoming task queue.cc can be used by the main browser thread.
most uafs in firefox were found in the javascript engine.
for example a pointer freed in js lifo alloc freeall can be referenced by several methods in js jit backtrackingallocator .
we have filed bug reports in the chromium bug database and mozilla bugzilla .
more uafs will be disclosed at our open source repository once they are confirmed and fixed.
.
ufoperformance table reports the runtime performance results of ufoon the two browsers.
for sunspider and octane the scores are the time in ms to perform the benchmark computation.
the lower the better.
for dromaeo the scores are the number ofruns per second.
the higher the better.
the average runtimeoverhead of ufois 11x without pointer origin tracking and050000100000150000200000250000 candidate uafs formula variables figure tradeoff between offline analysis perfor mance and the detection ability by the window size.
it does not impose significant slowdown for normal interaction between application and users thus indicating that ufo can be used for in house testing for applications as largeas desktop web browsers.
for the javascript engine bench marks ufointroduced overhead on average.
this is because javascript is compiled by the jit compiler and is executed without ufoinstrumentation.
for html rendering benchmarks the average slowdown of ufois 26x.
the runtime performance of ufois determined by the amount of traced events and the offline analysis time of ufo is highly influenced by the window size.
figure shows the correlation between window size and the number of constraint variables and the number of candidate uafs for analyzing a trace in chromium.
as the window size become larger the number of constraint variables grows linearly and the number of candidate uafs also increases.
however there exists atradeoff between ufooffline analysis performance and the detection ability which can be tuned by the window size.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jeff huang related work researchers have proposed several types of approaches for detecting uaf vulnerabilities including dynamic detectors static detectors as well as hybrid techniques .
for example undangle is a hybrid detection tool that combines runtime tracing and offline analysis.
in general static detectors are imprecise while existing dynamic techniques suffer from limited code coverage or inability to handle concurrent programs.
ufois distinguished by the ability to precisely and maximally predict uafs that are unseen from the observed multithreaded dynamic execution.
gueb is a static tool that detects heap uaf vulnerabilities on binary code.
the key idea is that for a program path with uaf vulnerabilities three events will happen orderly allocating heap memory free memory and accessing the heap memory.
gueb tracks heap operations and address transfers pointer assignments and discovers which program location allocates or frees which heap memory.
then it analyzes the resulting graph to identify uaf vulnerabilities.
gueb provides better coverage of uaf detection than dynamic tools.
however due to the imprecision of points to analysis guebis neither sound or precise.
also the path analysis and value set analysis performed by gueb are expensive and difficult to scale to large programs.
uafchecker is a static uaf detector.
it applies the inter procedure analysis to make the result more accurate.
it uses function inlining and function summary to perform the inter procedure analysis.
uafchecker builds a finite statemachine to model the uaf vulnerabilities.
this step mayreport many candidate uaf vulnerabilities.
uafchecker then uses symbolic execution to check the satisfiability of path constraints of the candidate vulnerabilities and eliminate the false positives.
doubletake detects three types of memory errors uaf heap buffer overflow and memory leak.
at runtime the program execution is divided into epochs each ends with an irrevocable system call.
at the beginning of an epoch doubletake checks program state registers and all writable memory .
at the end of an epoch doubletake checksprogram state again to see if any memory errors have oc curred.
if so it rollbacks current epoch and re execute the epoch with additional instrumentation to pinpoint the exact locations of the error.
doubletake replaces the system memory allocator with a deterministic allocator given the same sequence of malloc and free requests it must provide the same addresses for allocated objects.
during re execution doubletake utilizes the hardware watchpoints to pause the program when the memory error happens.
addresssanitizer is a popular dynamic memory error detector that detects a wide range of runtime memory errors including uafs and memory leaks.
to find uaf vulnerabilities addresssanitizer uses shadow memory to record whether each byte of application is accessible and instruments the program to check the shadow memory on each store or load.
to compact the shadow memory addresssanitizer encodesthe state accessibility of every byte sequence of heap memory into one byte and uses a direct mapping to translate an application address to its shadow memory.
the average overhead is .3x.
addresssanitizer may miss uaf if a larger memory e.g.
mb has been allocated and deallocated between the freeand the following use.
similar to addresssanitizer kasan is a dynamic memory error detector for finding use after free and out of bounds bugs in the linux kernel.
many uaf vulnerabilities are explored by crafting bogus virtual table of the c code.
t vip tackles such problems by instrumenting binary code and adding runtime policy enforcements to prevent uafs.
ironclad c tries to address this problem by augmenting existing c programs with additional pointer library in a semi automatic way.
dangull and freesentry try to prevent uafs from happening by tracking object pointers at runtime and nullifying them when the object is destroyed.
dangsan i s a more recent system that significantly improves the runtime performance of uaf detection by optimizing the detection workloads.
it scales to programs with large numbers of pointer writes and many concurrent threads.
however although it can efficiently detect uafs in concurrent programs it does not have the predictive power.
conclusion concurrency use after free uaf vulnerabilities are a rising threat to software security.
we have presented ufo a new technique that can effectively and precisely predict concurrency uafs based on a single execution trace even though the uafs do not happen in the observed execution.
thefoundation of ufois the maximal thread causality model maxmodel which we have extended to encode uaf vulnerabilities as first order logical constraints.
by formulating uaf detection as a constraint solving problem and leveraging the power of the maxmodel ufoenables maximally verifying all real uafs that can be inferred from an execution.
experiments on real world applications demonstrate that ufo can detect new uaf vulnerabilities that cannot be found by existing industrial strength uaf detection tools.
moreover ufoscales to large complex applications such as chromium and firefox and has detected many concurrency uafs.