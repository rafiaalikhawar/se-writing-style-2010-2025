correctness witnesses exchanging verification results between verifiers dirk beyer1 matthias dangl2 daniel dietsch3 matthias heizmann3 1lmu munich germany2university of passau germany3university of freiburg germany abstract standard veri cation tools provide a counterexample to witness a speci cation violation and since a few years such a witness can be validated by an independent validator using an exchangeable witness format.
this way information about the violation can be shared across veri cation tools and the user can use standard tools to visualize and explore witnesses.
this technique is not yet established for the correctness case where a program ful lls a speci cation.
even for simple programs it is often di cult for users to comprehend why a given program is correct and there is no way to independently check the veri cation result.
we close this gap by complementing our earlier work on violation witnesses with correctness witnesses.
while we use an extension of the established common exchange format for violation witnesses to represent correctness witnesses the techniques for producing and validating correctness witnesses are di erent.
the overall goal to make proofs available to engineers is probably as old as programming itself and proofcarrying code was proposed two decades ago our goal is to make it practical we consider witnesses as rst class exchangeable objects stored independently from the source code and checked independently from the veri er that produced them respecting the important principle of separation of concerns.
at any time the invariants from the correctness witness can be used to reconstruct a correctness proof to establish trust.
we extended two state of the art veri ers cpachecker andultimateautomizer to produce and validate witnesses and report that the approach is promising on a large set of veri cation tasks.
ccs concepts software and its engineering !formal software veri cation keywords correctness witness witness validation software veri cation program analysis model checking1.
introduction the omnipresent dependency on software in society and industry makes it necessary to ensure reliable and correct functioning of the software.
this trend will continue and become even more important in the future.
during the last decade various conceptual breakthroughs in veri cation research were achieved and as showcased by the annual tacas international competition on software veri cation sv comp many successful software veri ers were developed.
recently the problem of false alarms that veri cation tools sometimes produce has been addressed formerly a veri cation tool reported found bugs as counterexample traces in a tool speci c manner those counterexamples were often not readable and therefore hardly usable.
determining whether the reported bug was a false alarm or described an actual programming error that needed to be xed was a tedious manual process for the user.
exchangeable violation witnesses resolve this issue because the general syntax allows new tools for presentation to be developed and used .
witnesses should be considered as rst class objects that have much more value than the actual veri cation result true orfalse .
a veri cation result should be trusted only if the reason for the result is provided and the result can be re established with the additional information.
the process of witness validation is fully automatic.
this paper complements our previous work on violation witnesses by a method for producing and validating correctness witnesses .
the most recent edition of the tacas international competition on software veri cation revealed that soundness is a big issue ten out of participating veri ers in the category overall reported wrong correctness claims for veri cation tasks with known speci cation violations.
one of the submissions was even claiming safety for out of veri cation tasks that were known to contain a bug.
this rather embarrassing situation of the state of the art in software veri cation can be xed by producing correctness witnesses and letting a witness validator con rm the result.
the result should be trusted only if it can be con rmed by at least one other veri er.
we propose that a veri er should be required to augment a veri cation result with a machine readable and exchangeable witness such that both bug alarms and claims of safety may be validated.
with this technique a trusted validator establishes trust in the veri cation results produced by an untrusted veri er and even in the absence of a trusted validator the user s con dence in a veri cation result can be permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
artifact evaluated by fse 3261extern unsigned int nondet void 3int main unsigned int x nondet unsigned int y x while x x x y y valid safety property if x !
y error return return a safe programq0 true q1 x y q2 true q3 true q4 true5 enterloophead o w o w then else o w o w o w8 enterloophead b witness automaton1extern unsigned int nondet void 3int main unsigned int x nondet unsigned int y x while x x x y x bug invalid safety property if x !
y error return return c unsafe program figure example c programs a c and a potential correctness witness b increased by applying di erent validators to a veri cation witness.
witnesses can be read by humans perhaps using a visualization or inspection tool or by a witness validator.
this paper reports our experience with implementing two di erent witness producing veri ers and two di erent witness validators for correctness witnesses.
on the syntactic level we use xml more speci cally graphml as a language to represent correctness witnesses.
on the semantic level we use the standard concept of non deterministic nite automata to represent correctness witnesses.
a correctnesswitness automaton observes the program locations along the control ow that the veri er explores and provides invariants that hold at the locations that the veri er visits.
a correctness witness is valid if its predicates are invariants for the program and a validator should reject witnesses with incorrect invariants.
the strength of the invariants determines the quality of the witnesses but no particular strength is required.
witness validation can be more e cient than veri cation because it might be easier to re verify that invariants indeed hold while the veri cation needs to come up with the invariants.
the task of nding useful invariants is in general considered one of the key challenges in software veri cation.
generalizing this approach allows for a lot of exibility because the more helpful the candidate invariants are the less work has to be performed by the validator.
example.
we illustrate the idea of correctness witnesses using two short c programs and an example witness automaton.
the rst of the two c programs is listed in fig.
1a.
it is taken from the category loops of the benchmark set of the tacas international competition on software veri cation2 .
it contains two unsigned integer variables xand y. variable x is initialized to a non deterministic value in line and yis set to the value of xin line .
lines contain a while loop that increments both variables in each iteration while the value of xis less than .
in the lines the safety property is asserted which requires that xequals y. while the safety property trivially holds before the rst execution of the loop body a veri er has to nd out that x yis a loop invariant in order to prove that the safety property holds after the loop.
because the loop invariant x yis inductive it is easy to prove that it holds.
therefore proving c loop acceleration multivar true unreach call1.ithe whole program correct is easy if the loop invariant x y is given but nding such a loop invariant is in general hard and depends on the employed veri cation strategy it is the critical step in verifying this program.
a veri er that successfully proves the safety property for the program may then export a correctness witness.
if the correctness witness contains the invariant x y a witness validator should be able to easily con rm the correctness witness.
figure 1b displays a graphical representation of such a correctness witness which is actually produced by our implementation in cpachecker for the program listed in fig.
1a we reduced it to the most important parts for readability .
our implementation in ultimateautomizer produces a very similar witness.
the witness uses the same type of syntactic guards as the violation witnesses that we introduced in a previous work to match automaton transitions with program operations.
the automaton starts in an initial control state q0.
the witness assigns the invariant true to control state q0.
it is allowed to proceed to state q1if the controlow enters the loop head.
as long as this transition is not possible the automaton remains in state q0via the self transition otherwise o w .
fromq1 the automaton can proceed to state q2if the condition of the while loop in line is true the then case or to state q3if the condition in line is false the else case .
as long as none of these transitions are possible the automaton remains in state q1via the self transition o w. the automaton proceeds from state q2 toq4on the program operation in line and from there back to stateq1after the program operation in line .
as long as these conditions are not met the automaton will stay in each of the control states via their self transitions o w. if the automaton is in state q3 it will stay there forever.3statesq0 q2 q3 andq3contain the trivial invariant true.
stateq1 speci es the invariant x y. because state q1describes the loop head a validator is able to prove for example by induction that the invariant holds at this program location and can then use the invariant to prove the correctness of the program thus validating the witness.
the second program in fig.
1c is almost identical to the program in fig.
1a with the critical di erence that there 3the rest of the exploration does not matter for the witness because the sole purpose of the witness is to attach the invariant at the right program location.
327is a bug in line which causes the safety property to be violated after each iteration the value of yequals x instead of x. due to the structural similarity between the two programs the witness in fig.
1b can also be matched with the second unsafe program.
a validator that checks the loop invariant x ywill fail to prove its invariance and thus will reject the witness.
because each validation of a correctness witness also implicitly uses the safety property as an invariant the validator could alternatively also reject the witness by nding a counterexample to the safety property in lines before disproving the loop invariant x y. related work.
the exchange format for correctness witnesses and the corresponding techniques for communicating veri cation witnesses across veri cation tools are based on previous work on violation witnesses .
while the tasks of producing and validating correctness witnesses as well as the involved concepts are di erent from those for violation witnesses we were able to reuse the exchange format for violation witnesses with only minor extensions namely adding tags for location invariants and a new syntactic guard to identify loop heads.
the stability of the format is important because it may incite developers of other veri ers which perhaps already support violation witnesses to support correctness witnesses as well.
analogous to the concept of stepwise testi cation of violation witnesses a correctnesswitness validator becomes a correctness witness testi er if the validator itself documents its reasoning again in a correctness witness.
before the common exchange format violation witnesses were used only based on proprietary formats within particular tools.
for example esbmc was extended to reproduce errors via instrumented code and cpachecker was used to re check previously computed error paths by interpreting them as automata that control the state space search .
the competition on termination uses cpf to store termination proofs for term rewrite systems.
proof carrying code pcc .
ideas on proof witnesses have previously been explored in the context of proof carrying code .
pcc is a mechanism where an untrusted source supplies both an executable program and a proof witness that can be checked against the program and speci cation by a trusted validator to establish trust in the program.
intermediate results during the veri cation procedure can be used by certifying model checkers to compose and dump full proofs as proof certi cates .
the two implementations of correctness witness validation that we provide and the presented exchange format for correctness witnesses enable the mechanism of proof carrying code for real world c programs and allow further veri cation tools to adopt the technique.
the main di erence of our work to proof carrying code is that we do not strictly require the witness to contain a full proof.
we found that in practice a full proof for even small programs may become very large in size unless a considerable amount of additional e ort is spent on simplifying formulas.
especially for larger programs it is often neither wanted nor even feasible to deal with such a full proof as in math good lemmas or proof sketches are of essence.
therefore we support exibility the better the witness the more likely it is that the witness validator will quickly con rm it a less detailed witness may also succeed in guiding the validator to the proof but in turn may require more e ort from the validator.
in addition we do not use the program to carry the proof but consider thewitness separately as an own rst class object separation of concerns exibility maintainability .
certi cates.
correctness certi cates have long been used for increasing the trust in code generated from some form of formal description or model e.g.
.
those correctness certi cates are complete proofs of functional correctness.
our exchange format can also be used as correctness certi cate and to represent a full proof but this is not required a correctness witness can more generally be a partial proof of correctness.
reusing reachability graphs.
many model checkers materialize the intermediate results produced by their state space exploration as an abstract reachability graph arg .
the arg which is the basic data structure in tools like slam blast and cpachecker can be used to extract invariants of the program which in turn can be used for pcc or for extreme model checking which checks if a previously computed arg is a safety proof for the given slightly changed input program.
slab is a certifying model checker that produces a proof certi cate for the abstract model of a program in smt lib format.
such a certi cate can easily be checked using an smt solver but mapping it back to the original program to validate that it indeed certi es the correctness of the original program is non trivial.
as a result the user can only assume that the certi cate faithfully refers to the original program.
search carrying code scc .
the approach scc uses search scripts to guide a model checker along paths of the arg.
search scripts and correctness witnesses share the important idea of guiding a validator through the state space in order to reconstruct the correctness proof.
search scripts can be seen as a special case of correctness witnesses where the invariants are omitted witnesses support branching as well .
correctness witnesses overcome three limitations of search scripts cf.
sect.
.
in i the exchange format is independent from the veri cation approach not bound to explicit state model checking ii the approach works across di erent veri ers even if built on di erent technologies as shown in our evaluation with cpachecker andautomizer and iii the approach allows a exible mapping from program operations to the veri er speci c states and transitions that is more tolerant to code reduction which was already used by violation witnesses and is supported by many veri cation tools .
we found these extensions are essential for practical impact.
proof programs and con gurable certi cation.
one aspect of pcc is the idea that validation should be much faster than veri cation.
in programs from proofs correctness certi cates take the form of new behaviorally equivalent programs that are generated by a predicate analysis.
those new programs can then be e ciently veri ed by a dataow analysis alone although they may be exponentially larger in terms of lines of code.
as their controlow is necessarily di erent they may exhibit completely di erent run time behavior.
certi cates for con gurable program analysis represent all reachable states of a program as correctness certi cate which is comparable to a correctness witness with an invariant for each program location.
then in order to speed up the validation various size reducing techniques are applied.
because correctness witnesses can contain partial proofs a validator may choose to complement a partial proof with its own veri cation strategy or even perform the full 328veri cation of a veri cation task itself the validator never assumes that a correctness witness constitutes a complete proof.
therefore the validation of these witnesses does not consistently exhibit a speedup.
nevertheless similar techniques can be applied if one assumes that the witnesses represent complete proofs.
because both implemented witness producers cpachecker andautomizer restrict themselves to loop invariants and procedure post conditions the size of the witnesses is not an issue.
partial veri cation.
veri ers have three possible outcomes a veri er either nds a bug proves correctness or fails.
error witnesses and correctness witnesses improve the rst and second case respectively.
conditional model checking cmc improves the third case by advocating reports of partial veri cation results.
the output condition describes the result of an incomplete veri cation attempt which part of the state was successfully veri ed and the input condition instructs a model checker to only partially verify a system which part of the state space is to be veri ed .
subsequent veri cation runs with a di erent approach can be used to complete the veri cation.
witnesses can be used to complement cmc by describing a invariants in correctness witnesses that were used to verify the part of the system that was successfully veri ed and b paths in violation witnesses that hindered a complete veri cation.
.
correctness witnesses the goal of our work is to represent veri cation results in such a way that they are reproducible machine readable and exchangeable between di erent veri ers.
this paper focuses on correctness witnesses i.e.
witnesses that provide evidence that the given program satis es the given speci cation.
we use witness automata to represent witnesses.
for the theoretical foundation of our work we refer the reader to our concepts for violation witnesses .
here we only explain the di erence and give an informal motivation.
we restrict our presentation to a simple imperative programming language that contains only assignment and assume operations and where all program variables are integers.
our implementations are based on cpachecker and ultimateautomizer both of which support c programs.
we use controlow automata cfa to represent programs.
acontrolow automaton consists of a set of program locations modelling the program counter the initial program location program entry and a set of controlow edges each of which models an operation that is executed during the ow of control from one program location to another.
acorrectness witness automaton is an observer automaton and a correctness witness analysis can be formalized using the notion of con gurable program analysis cpa resulting in an observer cpa for a correctness witness automaton which runs as one component cpa of a composite program analysis in parallel to other component cpas.
in contrast to the control automata that we use for violation witnesses correctness witness automata do not restrict the exploration of the program s state space but only observe the statespace exploration.
while a violation witness automaton may restrict the successor states to those successor states that lead the exploration to the speci cation violation a correctness witness automaton has abstract successor states for all concrete successor states.
the correctness witness automaton annotates each abstract program state ewithan invariant i.e.
a predicate that holds at eon every program path that passes e. the program analysis of a witness validator checks if the given invariants indeed hold at their corresponding abstract program states a witness is rejected if the predicate for an abstract program state is not con rmed.
there are only two di erences between violation witnesses and correctness witnesses a violation witness has assumptions at the witness automaton s transitions that restrict the state space a correctness witness does not restrict the state space but contains a state invariant at each control state in the witness automaton.
a validator for a violation witness tries to replay an error path through the program while a validator for a correctness witness tries to replay the correctness proof i.e.
checks for each invariant whether all reachable program states are covered by the invariant and that no error state is contained in the state space that the invariants de ne.
exchange format for correctness witnesses.
our exchange format for correctness witnesses is an extension of our earlier format for violation witnesses .
the format is based on graphml where a graph contains nodes representing states and edges representing transitions of a witness automaton.
the format supports adding attributes to the states for example to mark them as initial state or error state or to annotate invariants to a state.
transitions can also be labeled with guard attributes like line numbers and assumptions which can be used by witness validators to match the witness to the program and for violation witnesses to constrain the state space of the program.
in order to be able to express correctness witnesses we extend the format as follows graphs can now be labeled with the attribute witness type for which correctness witness or violation witness are valid values.
if omitted the witness is assumed to be a violation witness.
states can be labeled with the additional attribute invariant which has to be a boolean c expression that is valid in the scope given by invariant.scope .
the attribute invariant represents an invariant that is required to hold at the program location that is represented by the state.
if the witness type is correctness witness transitions are not allowed to have the attribute assume because correctness witness automata are observer automata which do not restrict the search space of the program.
if the witness type of is correctness witness marking states as violation states with the attribute violation is not allowed because that would contradict the intention of the correctness witness.
the syntactic guard enterloophead matches automaton states to loop heads in the control ow.
the decision to restrict invariant attributes to c expressions is based on the idea that it should be as easy as possible to extend an existing veri cation tool for c such that it can produce or validate correctness witnesses.
nevertheless c is not suitable to express all aspects of invariants that are commonly used like quanti ers