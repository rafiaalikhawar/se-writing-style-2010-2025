stochastic optimization of program obfuscation han liu chengnian sun zhendong su y u jiang ming gu jiaguang sun school of software tsinghua university beijing china university of california davis usa liuhan12 mails.tsinghua.edu.cn cnsun su ucdavis.edu jy1989 guming sunjg mail.tsinghua.edu.cn abstract program obfuscation is a common practice in software development to obscure source code or binary code in order to prevent humans from understanding the purpose or logic of software.
it protects intellectual property and deters malicious attacks.
while tremendous efforts have been devoted to the development of various obfuscation techniques we have relatively little knowledge on how to most effectively use them together.
the biggest challenge lies in identifying the most effective combination of obfuscation techniques.
this paper presents a unified framework to optimize program obfuscation.
given an input program pand a set tof obfuscation transformations our technique can automatically identify a sequence seq angbracketleftt1 t2 tn angbracketright i .ti t such that applying tiin order on pyields the optimal obfuscation performance.
we model the process of searching for seq as a mathematical optimization problem.
the key technical contributions of this paper are an obscurity language model to assess obfuscation effectiveness optimality and a guided stochastic algorithm based on markov chain monte carlo methods to search for the optimal solution seq.
we have realized the framework in a tool closure for javascript and evaluated it on most starred javascript projects on github 19k lines of code .
our machinery study shows that closure outperforms the well known google closure compiler by defending of the attacks initiated by jsnice.
our human study also reveals that closure is practical and can reduce the human attack success rate by .
keywords program obfuscation obscurity language model markov chain monte carlo methods i. i ntroduction software obfuscation is a deliberate act to hide the intention and logic of programs by obscuring source or executable code with semantics preserving program transformations.
it is a common approach against reverse engineering and serves multiple purposes in practice e.g.
protecting intellectual property deterring malicious attacks.
in this paper we refer to any attempt to reverse engineer obfuscated code as an attack.
to defend against potential adversaries decades of research has been devoted to developing various obfuscation techniques .
some of these techniques manipulate the syntactical representation of programs e.g.
renaming variables changing format while other advanced techniques complicate the control and data flow of programs under obfuscation.
these obfuscation techniques can be effective in deterring human adversaries who attempt to manually crack the obscurity by reading the code directly or with the help of static dynamic analyzers.
however they might not be sufficient for deterring y u jiang is the corresponding author.learning based computer adversaries a new and promising class of deobfuscators.
these adversaries leverage coding features mined from a large corpus of source code to recover useful information e.g.
identifier names types from obfuscated programs.
their evaluation results have demonstrated the potential of this class of deobfuscators at attacking obfuscated code.
the threat posed by learning based adversaries motivates us to revisit the research of obfuscation.
although already having a large number of obfuscation techniques we have little knowledge on how to coordinate them to produce better obfuscation result.
therefore in this paper we propose an automatic approach to optimize the obfuscation performance for a program.
specifically given an input program pand a settof obfuscation transformations our technique identifies a sequence seq angbracketleftt1 t2 tn angbracketright i .ti t such that applying tiin order on pyields the optimal obfuscation performance.
we refer to this sequence as a configuration of obfuscation transformations.
we model the process of searching for seq as a mathematical optimization problem i.e.
finding an optimal configuration from all available configurations.
specifically we face the following challenges.
challenge .
we need an objective function to measure the obscurity of obfuscated programs.
it is used to compare configurations in terms of obfuscation performance and navigate the search process towards the optimal configurations.
however there is no explicit precise definition of such a function yet since a number of factors can affect program obscurity such as syntax semantics and structure of programs and even experience of adversaries.
challenge .
the search space for the optimal configuration is unbounded.
it is infeasible to enumerate every configuration during the optimization process.
the state of the art obfuscators such as google closure compiler specify a fixed order of obfuscation transformations for all programs.
however our evaluation in vi shows that such a statically specified configuration cannot always yield good obfuscation results for various programs.
challenge .
different obfuscation transformations might conflict with each other on the same source code causing the obscurity to degrade e.g.
v listing 5a 5b and 5c .
given an obfuscation transformation t instead of applying tto the whole program p it is ideal to apply tto the rightful code regions in p so that multiple obfuscation transformations can ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
be coordinated to achieve the optimal obscurity.
guided obfuscation optimization.
to overcome the three challenges we propose a novel framework which automatically optimizes obfuscation for an input program.
obscurity language model olm first we propose an obscurity language model to assess the obfuscation.
in particular it measures obscurity based on the code perplexity of the obfuscated program against a large corpus of source code e.g.
all the unobfuscated source code available on the web .
mcmc based search second we realize the optimization process by using markov chain monte carlo mcmc methods to search for the optimal configuration of obfuscation transformations.
our search strategy can efficiently sample the huge search space so that within a bounded period of time we can find an optimal configuration .
program decomposition lastly we stochastically decompose the large input program into fine granularity units e.g.
functions optimize the obfuscation for each unit individually and then compose the obfuscated units back into a whole program.
this decomposition process can decrease the likelihood of conflicts between obfuscation transformations.
we have realized the framework and instantiated it for javascript programs into a tool closure .
the evaluation on real world popular open source projects over 19k lines of code demonstrates the ability of closure at combating the state of the art deobfuscator jsnice .
in particular closure outperforms google closure compiler closure by in obfuscation performance namely closure protects more information from being recovered by jsnice than closure.
in cases where closure can already obfuscate the source code well closure can still achieve improvement.
in order to ensure reproducibility we have open sourced closure at .
contribution.
we summarize our contributions as follows.
we propose an obscurity language model the first practical metric to assess the obscurity of obfuscated programs.
we propose an effective and efficient mcmc based algorithm to optimize program obfuscations.
the comprehensive evaluation results demonstrate the effectiveness of our proposed technique.
compared to google closure compiler our realization for javascript programs exhibits and improvement on deterring learning based and human attacks respectively.
paper organization.
the remainder of the paper is organized as follows.
ii introduces necessary background knowledge.
iii presents the overall framework.
iv details the obscurity language model and v elaborates the guided obfuscation optimization.
we present our evaluation of closure in vi and survey related work in vii.
viii concludes the paper.
ii.
b ackground a. program obfuscation program obfuscation is a set of semantics preserving program transformations to conceal programming intentions.
it makesprograms difficult to be understood by manual and automatic analyses.
in this subsection we describe the most common obfuscation transformations in the literature.
name obfuscation.
this category of obfuscation transformations replaces identifier names e.g.
variables functions classes with meaningless or misleading ones.
take a declaration var len as an example.
it is straightforward to conjecture that this variable is related to length .
however if the variable name is obfuscated to a it will take more efforts to make the same conjecture.
data obfuscation.
this category obfuscates data flows in programs via reusing variables inlining variables value encoding etc.
.
for example with var max f arr display max we can easily figure out that the code is to select and display the maximal item in an array.
but with the variable max inlined as display f arr we can hardly speculate the intention.
control flow obfuscation.
this category obfuscates the control flows of programs.
typical operations include inserting opaque predicates whose value is hard to infer flattening and function inlining which can complicate the control flow and delay human understanding.
layout obfuscation.
this category removes formatting e.g.
indentations line breaks and compresses the source code to reduce the readability and size of the code.
b. learning based adversary traditional adversaries of obfuscation aim at manually cracking the program obscurity but they are limited by human experience.
with the rapid development of machine learning techniques and accessibility of high quality opensource projects adversaries resort to learning based attacks.
generally such attacks try to recover information from obfuscated program elements e.g.
giving a variable a meaningful name to expose its functionality.
usually the attack involves two phases.
first a knowledge model is built from a large corpus using machine learning algorithms.
the model is able to estimate the probability for a program element to occur in the corpus.
for example the model can tell that file open log w is more likely to occur in a python program than a open log w .
next the adversary deobfuscates a program by querying the model annotating program elements e.g.
assigning meaningful names and optimizing the annotations so that the deobfuscated program is most similar to the corpus.
we take jsnice as a powerful instance.
for name obfuscation as in ii a jsnice can correctly predict .
of the obfuscated names making the obfuscation greatly compromised.
figure 1a shows an obfuscated code with very short argument and variable names which is difficult to understand.
however after jsnice recovers the names as shown in figure 1b we can easily know the function is copying an input string by iteratively retrieving its substrings.
even for complex large programs jsnice can recover sensitive code elements within an acceptable time bound .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
function chunkdata e t var n i var r e.length for i r i t if i t r n.push e.substring i i t else n.push e.substring i r return n a before attackfunction chunkdata str step var colnames i var len str.length for i len i step if i step len colnames.push str.substring i i step else colnames.push str.substring i len return colnames b after attack fig.
a code snippet deobfuscated by jsnice.
c. language model language models lm assign probabilities to different sequences of words .
the probabilities in turn indicate how likely the sequence is to occur.
in the context of programming languages researchers have investigated such probabilistic nature called naturalness of programs and highlighted its promising potential in handling traditional software engineering tasks e.g.
for code completion given code snippet for the lm can predict for int i i is the most possible code to follow.
for a token sequence s t1t2 tn its lm probability is p s p t1 n producttext i 2p ti t1 ti .
each conditional probability determines how likely a subsequence is to follow its prefix.
in practice estimating the conditional probability is usually difficult or even infeasible due to the huge number of prefixes.
a practical approximation is the n gram model which assumes that the occurrence of a token is dependent on a limited prefix with length n. this way p ti t1 ti is approximated to p ti ti n ti which is computed by counting the occurrences below p ti t1 ti count ti n ti ti count ti n ti n gram given a program s t1t2 tn to better interpret its naturalness based on an lm m we use the measurement perplexity or its log transformed version cross entropy defined as hm s nlogpm t1 tn .
based on the ngram n k the formulation accordingly amounts to hm s nn summationdisplay 1logpm ti ti k ti perplexity commonly code with high perplexity is oddly written.
in our setting such oddness is likely a result of obfuscation.
a well designed lm should be able to identify to what degree a program is obfuscated via the perplexity measurement.
iii.
p roblem formula tion o verall framework in this section we formulate the problem of obfuscation optimization and briefly introduce the workflow of our proposed approach.
a. problem f ormulation generally obfuscation refers to program transformations without changing the program s behavior.
although already having a large number of obfuscation techniques we havelittle knowledge on how to coordinate them to produce better obfuscation result.
therefore in this paper we propose an automatic approach to optimize the obfuscation performance for a program.
definition .
obfuscation optimization given an input program pand a set tof obfuscation transformations the problem of obfuscation optimization identifies a sequence seq angbracketleftt1 t2 tn angbracketright i .ti t such that applying tiin order on pyields the optimal obfuscation performance.
configuration.
we refer to the sequence seq as a configuration of obfuscation transformations.
the state of the art obfuscators enforce a statically determined configuration for every input program.
their belief behind is works for one works for all .
our technique distinguishes itself from those by applying input dependent obfuscation transformations.
that is for each input program we aim to find the most suitable configuration.
measuring optimality.
the optimality of a configuration measures the degree of difficulty for an adversary to deobfuscate an obfuscated program.
as stated in challenge in i there is no explicit precise definition of such a measure yet.
therefore in this paper we propose an obscurity language model olm detailed in iv to measure the optimality by analyzing the structural similarity between an obfuscated program and a large corpus of programs that are available online.
specifically this is done by computing the perplexity equation perplexity .
the higher perplexity an obfuscated program has the odder it is w.r .t.
the corpus and the harder it is for an adversary to deobfuscate the program.
b. w orkflow as aforementioned we model the search process for the optimal configuration of obfuscation transformations as a mathematical optimization problem.
that is we iteratively explore the obfuscation space to find better configurations such that the obscurity of programs is improved.
in particular we designed a search algorithm based on markov chain monte carlo methods which steers the search process towards the optimal configuration with the guidance of the obscurity language model.
the general workflow of our framework is shown in figure .
it takes as input the source file for obfuscation and the settof available obfuscation transformations and outputs an obfuscated program by an optimal configuration.
the obfuscation process can be divided into the following four components.
parse at first the input source file is parsed into an abstract syntax tree ast .
the other components all work on asts.
search we decompose the original program at function level.
the obfuscation engine then randomly selects a set of functions to form a partition and generate a configuration to obfuscate it.
assess we enclose the obfuscated code by the search component into a query to the olm.
then olm computes the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
obscurity lmparsesearch search codefinalize partitions configuration original source code obfuscated source code assess scoretransformations astobfuscation engine fig.
the workflow of the proposed obfuscation framework.
perplexity of the code against a corpus of programs and returns it as a score to the obfuscation engine.
finalize after a parameterized number of iterations of search and assess e.g.
10k iterations we choose the iteration with the highest perplexity score and output the obfuscated program in that iteration as the final result.
in a nutshell our framework iteratively searches for more effective configuration that produces better obfuscation result.
the search process is guided by the olm so that it can eventually converge to an optimal configuration .
iv .
o bscurity language model this section describes the general process to build a language model for software engineering tasks difference and challenge of building an obscurity language model and how we address the challenges.
a. building a general source code language model as stated in building a general language model for source code aims at capturing the statistical regularities of code.
this model is then used for software engineering tasks at the source code level such as code completion.
therefore in order to build such a model a program is first tokenized and represented as a sequence of lexemes.
finally an n gram model is built by computing the conditional probability of a lexemetigiven its prefix angbracketleftti n ti angbracketrightwith the formula in equation n gram.
recent techniques can build better language models to capture the regularities of programs by either associating the lexemes with semantic information or taking the localness of lexemes into account during the model training phase.
however both still work on the lexeme level.
b. challenges of building obscurity language models different from a traditional language model for software engineering tasks at unobfuscated source code level e.g.
code completion our olm aims to capture the remaining regularities of software after obfuscation.
in other words the olm measures the perplexity between the obfuscated program and a large corpus of programs.
however if we use the traditional language model an obfuscated program is inherently perplex as its variables are renamed to short meaningless names and data control flowsare altered.
our olm should be resilient to the perplexity induced by obfuscators and should be able to measure the remaining regularities induced by the source code itself.
the fewer regularities of the original source code remain i.e.
higher perplexity the better the configuration that obfuscates the program is.
therefore in this case representing programs with sequences of lexemes is insufficient and even impractical.
we detail the challenges in the following.
inherent perplexity of obfuscated programs an obfuscated program has short and meaningless variable names which results in an inherently high perplexity if it is measured by the traditional software engineering language model over the lexeme based program representations.
an illustrative example which contains two obfuscated versions of jquery1is shown in figure .
function clonecopyevent e a var t s d n r v i c if a.nodetype if predicate e n g0.access e r g0.set a n c n.events delete r.handle r.events for bca t s c d jquery.event.add a d c g1.hasdata e v g1.access e i jquery.extend v g1.set a i a v ariable renamingfunction clonecopyevent d e var b f a c if e.nodetype if predicate d c g0.access d b g0.set e c c c.events delete b.handle b.events for bca a b c f jquery.event.add e a c g1.hasdata d a g1.access d a jquery.extend a g1.set e a b v ariable renaming and reusing fig.
inherent perplexity due to obfuscated names figure 3a is obfuscated with variable renaming and figure 3b is obfuscated with variable renaming and reusing.
both code snippets have high perplexity when they are measured with the original source code as their lexeme based representations are very different from that of the original one namely all local variables and function arguments have different names lexemes .
thus the traditional language model cannot differentiate which version is better obfuscated.
however figure 3b is better obfuscated as its data flows are also obfuscated by reusing of the local variables in figure 3a.
using jsnice as an automatic adversary to attack the two code snippets also confirms this.
specifically variable is obfuscated in figure 3a and variables are obfuscated in figure 3b.
figure 3b outperforms figure 3a by protecting more information.
our olm is expected to differentiate the superiority of figure 3b in terms of obfuscation quality.
c. obeme based obscurity language model to address the challenges above we use obemes to build an olm instead of lexemes.
generally an obeme is an enhanced representation of a token by considering its lexeme type and variable ordering.
its advantage is the capability of handling inherent obscurity of obfuscated source code.
given a token tk l t wherelis the lexeme and tis the token type then authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
a simple function and its corresponding ast.
its obeme is defined as follows.
obeme tk v order t k is a variable or an argument t tk is a literal e.g.
string l otherwise variables and arguments.
if the token tkis a local variable or a function argument we use its variable ordering in its scope as its obeme.
given the abstract syntax tree ast of a program we define the order nof a local variable to be the relative position in the sequence generated by an ast traversal.
specially the order of a function argument is set to be the top within the function scope according to its relative position in the argument list.
an example is shown in figure .
the function sum has two arguments min and buf and one local variable total .
under pre order traversal min buf and total are visited in turn.
thus their orders are and respectively.
to avoid name clashing with integer literals we prefix the order with a marker string v to form an obeme .
in this way variables are evaluated for perplexity based on the program structure rather than their names.
literals.
for literals in programs e.g.
strings numbers characters we use their token types as their obemes as we focus on structural similarity between obfuscated programs and program corpus and any difference between literals has little impact on the structural similarity.
others.
for other types of tokens e.g.
key words parentheses brackets we use their lexemes as the obemes.
d. obfuscation assessment after training an olm from the obeme based representations of a program corpus we can quantitatively measure how obscure a program is with its perplexity.
the measurement serves as the guidance in each optimization iteration described in iii steering the search process towards better obfuscation configurations that can produce more perplex obfuscated programs.
a key property of the obscurity lm is the highly positive correlation between perplexity and program obscurity which we have validated empirically in vi d. v. g uided obfusca tion optimiza tion this section details the mcmc based obfuscation engine and our main strategy to eliminate conflicts between obfuscation transformations at the function level.a.
mcmc based obfuscation optimization given a program pto obfuscate an olm m built from a corpus of programs a set t of available obfuscation transformations and a configuration seq the perplexity of p prime that is obfuscated from pbyseq i.e.
p prime seq p is denoted as p seq m hm seq p objective function as aforementioned the perplexity measures the obscurity and serves as the objective function for optimizing obfuscation.
therefore the goal of the obfuscation optimization can be formally expressed as seq a r g m a x p seq m that is find an optimal configuration seq such that maximizes the perplexity of the obfuscated version of p. in this paper we employ mcmc sampling to find seq .
mcmc has been proved and demonstrated to be effective at estimating a target probability distribution for which the direct sampling is difficult.
for example in the setting of obfuscation the space of configurations is unbounded if we allow duplications of obfuscation transformations in a configuration.
in such cases mcmc can mitigate the complexity by sampling more often in the region of configurations which yields better perplexity.
specifically we use the metropolis hastings algorithm to sample a sequence of configurations angbracketleftseq0 seq1 ... seqn angbracketrightin the configuration space.
the target probability distribution from which we draw samples is defined as p seq m zexp p seq m as described in is a constant and zis a partition function that normalizes the target distribution.
a significant property of is that higher perplexity leads to higher probability.
suppose seq primeis the proposed candidate sample the sampling process accepts the candidate and moves to seq primewith a probability as below a seq seq prime p m m i n p seq prime m p seq m particularly metropolis hastings algorithm enables us to accept a new sample without computing the partition function zin equation since zis canceled out by the division.
the overall mcmc based optimization process is shown in algorithm .
on line the initial sample is a configuration obtained by shuffling all the transformations in t. then at each iteration of the optimization we propose a new sample based on the current sample.
this is realized by the function mutate on line .
specifically the mutation is done by updating a random small number of transformations in the current configuration .
the update can be removal insertion and substitution.
next we evaluate the new sample by querying the acceptance function and choose to replace the current sample with the new one line .
after the optimization iteration we reproduce the recorded best obfuscation and output the obfuscated program.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm mcmc based obfuscation optimization.
input pis the input program.
tis the set of obfuscation transformations.
m is the language model trained as in iv.
nis the number of iterations.
output the obfuscated version produced by the optimal configuration.
1seq shuffle t seq seq generate mcmc samples.
2fori 1tondo seq prime mutate seq rand simulates the uniform distribution.
ifrand a seq seq prime p m then seq seq prime if p seq m p seq m then seq seq reproduce the best obfuscation.
8return seq p b. conflicting function optimization as introduced in i our framework is able to identify the rightful code regions to apply the suitable obfuscation transformations.
this is motivated by an observation we found in the very beginning of this project that a configuration sometimes fails to improve the obscurity of multiple functions at the same time.
an example figure shows a real world example.
the code snippet is extracted from the popular open source javascript project jade2 which is a widely used stars on github templating language for producing xml like documents.
in the example we consider the obfuscation transformation folding constants foldconstants .
when enabled foldconstants recognizes and evaluates constant expressions and uses the values to replace the expressions.
figure 5a shows the original source code two functions handletemplatecache andbracketexpression .
existing obfuscators apply transformations on the whole program i.e.
for this example both functions.
by disabling and enabling foldconstants t w o obfuscated programs are generated in figure 5b and 5c respectively.
for example undefined is folded to 0in figure 5c.
then we employ jsnice to recover names for local variables and function arguments.
the recovered names are shown in comments before each function.
we found that when foldconstants is disabled function handletemplatecache is well protected variable obfuscated but bracketexpression is not variables obfuscated when foldconstants is enabled bracketexpression is well protected variable obfuscated while handletemplatecache is not variables obfuscated .
that said the two functions have different optimal configurations .
an intuitive fix for this conflict is to enable foldconstants for one and disable foldconstants for the other.
therefore it is ideal to identify the suitable obfuscation transformations for the rightful code regions.
obfuscation optimization with partitioning we address this challenge by iteratively decomposing the program pand find the optimal configuration for each partition.
specifically obfuscation optimization with partitioning.
input pis the input program.
tis the set of obfuscation transformations.
m is the language model trained as in iv.
nis the number of iterations.
npart is the number to partition p output the obfuscated version produced by the optimal configuration.
1fobf forig p 2forp 1tonpart do seq shuffle t seq seq ftest fori 1tondo ifp npart then partition forig else partition random sample forig p fobf partition f orig partition seq prime mutate seq rand simulates the uniform distribution.
ifrand a seq seq prime p prime m then seq seq prime if p prime seq m p prime seq m then seq seq ftest partition fobf fobf seq ftest forig forig ftest 16return fobf given a number npart to partition pat the function level we call algorithm npart times.
one call produces a partition i.e.
a set of functions with its optimal configuration.
the subsequent call produces another partition containing functions that are not covered by the partitions produced in previous calls.
let the program p i.e.
a set of functions be represented as a triple fobf f test f orig wherefobfis the set of functions inpthat is already optimally obfuscated ftest is the set of functions that is being obfuscated and forig is the set that has not been obfuscated.
given an obfuscation configuration seq then the semantics of seq p is refined as follows seq p seq fobf f test f orig fobf seq ftest forig which can take as input either a set of functions or a triple of sets.
algorithm details the partitioning process with mcmc search for optimal configurations.
the general idea is that we gradually obfuscate the program pin at most npart steps in each of which a partition of pis obfuscated.
c. runtime performance optimization generally the automatic optimization is a tradeoff between obscurity and execution performance.
in order to balance the tradeoff we design several heuristics to reduce unnecessary search optimization.
first we exclude small functions which have a very small number of local variables and arguments and functions whose bodies mainly call apis because there is little improvement room for obfuscation in such functions.
second we dynamically record how perplexity changes over optimization iterations.
if the change is tiny we terminate further search to save time.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
function handletemplatecache options str var key options.filename if options.cache exports.cache return exports.cache else if str undefined str fs.readfilesync options.filename utf8 var templ exports.compile str options if options.cache exports.cache templ return templ function bracketexpression skip skip skip var start this .input if start !
start !
start !
throw new error unrecognized start character var end var range characterparser.parsemax this .input start skip if this .input !
end throw new error start character start does not match end character this .input range.end return range a original source code jsnice a options b source c path d fn function handletemplatecache a b var c a.filename if a.cache exports.cache return exports.cache else if b undefined b fs.readfilesync a.filename utf8 var d exports.compile b a if a.cache exports.cache d return d jsnice a start b skip c range d end function bracketexpression b b b var a this .input if a !
a!
a!
throw new error unrecognized start character var d c characterparser.parsemax this .input start b if this .input !
d throw new error start character a does not match end character this .input return c b foldconstants isdisabled .
jsnice a options b str c path d root function handletemplatecache a b var c a.filename if a.cache exports.cache return exports.cache void b b fs.readfilesync a.filename utf8 var d exports.compile b a a.cache exports.cache d return d jsnice a unclock b skip c range d cache function bracketexpression b b b var a this .input if !
a !
a !
a throw error unrecognized start character var d c characterparser.parsemax this .input start b if this .input !
d throw error start character a does not match end character this .input return c c foldconstants isenabled fig.
a real world example of conflicting functions vi.
i mplement a tion and ev alua tion a. instantiation for javascript we instantiated the proposed framework for javascript js and developed the closure tool.
the implementation includes loc nodejs loc python and loc java.
we made it publicly available at .
b. experimental setup all the experiments are performed on a ubuntu .
virtual machine with dual intel core i5 processors 10gb ram and 128gb ssd.
in evaluation the obscurity lm is configured to be gram using kenlm .
the number of partitions npart .
as for the adversary to closure we use the unuglifyjs front end and the nice2predict underlying machine learning engine which are both from jsnice .
we use top active open source javascript projects from github.
most of the projects are selected from the moststars list.
from the perspective of the adversary jsnice the experimental projects can be classified into two categories.
we use the term normal to refer to projects which are included in the training data of jsnice while obfuscated is used for others.
inherently jsnice should perform better attack on normal input than obfuscated ones.
we check how our approach responds to attack on both types.
one of the major features of jsnice is to assign meaningful names to variables.
therefore after the mcmc search iteration we apply jsnice to attack the obfuscated file and quantify the obfuscation by counting the number of variables which are correctly recovered.
we believe this makes sense for two reasons.
first the quality of jsnice prediction is dependent on connecting the program to its training corpus which means that obscurity of the program can be reflected by how variables names are predicted.
second people leverage much on names to understand code.
more variables are predicted with meaningful names less difficult the program is to be well understood.
baseline obfuscation.
we selected google closurecompiler as a contrast for closure .
the main contribution of this work is to optimize obfuscation or transformations in general by searching for an effective configuration which is orthogonal to the underlying obfuscators.
while featured as an optimizer for javascript such tools are characterized as a form of obfuscators by jsnice they used uglifyjs which is similar to closure .
moreover closure excels at limiting the code size and runtime overhead making it suitable for real world usage.
we have conducted a preliminary study to compare closure with commercial obfuscators available at showing that closure generates smaller but equally obfuscated code compared to commercial tools.
lastly closure is open sourced enabling us to flexibly generate random configurations .
c. research questions in this paper we present the insight of input dependent program obfuscation and its optimization can be modeled as an optimization task to search for highest perplexity .
we intend to address the following research questions rq .
can the obscurity language model capture the obscurity?
rq .
can the mcmc random search optimize obfuscation?
rq .
does the optimization give us practical benefits?
d. results and discussions now we present the evaluation results and multi dimensional in depth analysis as well.
to begin with we try to investigate the quality of the obscurity language model figuring out whether the measurement perplexity is consistent with the obscurity of programs.
towards this goal we monitor the obfuscation optimization process to record the intermediate output at each iteration.
specifically we rank those files on both perplexity and obscurity which is inversely proportional to the number of correctly recovered variable names and calculate their rank distance .
given an input program and the number of iterations n the ranks on perplexity xiand obscurity yi at iteration i i n satisfy that xi yi .
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
rank distance diis defined as di xi yi .
accordingly di .
overall the monitoring leads to records with a distribution shown in figure .
fig.
rank distance between perplexity and obscurity.
there are no iterations with rank distance larger than observed within the overall monitored records.
table i on the different order of the lm.
ard average rank distance.
coef the correlation coefficient.
n gram ard coef .
.
.
.
.
.
the definition of rank distance delivers the message that smaller distance indicates better consistency between perplexity and obscurity vise versa.
in our setting perplexity calculated by the obscurity lm is used to identify the obfuscation improvement and drive the optimization.
that said we rely on the rank of perplexity rather than its absolute values.
in that sense rank distance is sufficient for characterizing the efficacy and sensitivity of the obscurity lm.
as figure shows most iterations close to generate a zero distance which means that perplexity is perfectly consistent with obscurity.
furthermore distance and distance cumulatively increase the ratio to almost .
larger distances e.g.
from to which expose non negligible inconsistency rarely occur in the records.
from the global picture figure gives us an intuitive confidence that our lm is consistent.
to be more precise we further calculate two support indicators in table i the average rank distance and the correlation coefficient which illustrates a quantitative measure of correlation and dependence valued from 1to1.
while both indicators describe the quality of an obscurity lm coefficient is of the most practical use via mirroring the capability of the lm to locate a powerful obfuscation.
in the setting of figure which uses gram the obscurity lm shows strong consistency in all the indicators.
the .
coefficient further confirms that perplexity and obscurity are close to a total positive correlation.
if we modify the order of n gram n the consistency decreases slightly in terms of coefficient which suggests that the gram lm fits our setting the best.
based on the observation above for rq1 we believe that the language model we built is quite capable of capturing obscurityduring the optimization.
in another word it is reasonable to rely on it to guide the obfuscation process.
table ii obfuscation efficacy of closure compared to closure on normal and obfuscated projects.
total column refers to the number of all variables considered including local variables and function arguments .
closure and closure columns list the number of variables which are attacked correctly recovered by jsnice which means that smaller value amounts to better obfuscation.
improve column calculates the relative improvement of closure over closure.
project total closure closure improve normal angular meteor react obfuscated greedy conflict next we compare the obfuscation between closure and closure simple mode which is the default setting .
the detailed statistics is displayed in figure and table ii.
to be specific files with core functionalities from the normal projects are selected as in left of figure .
clearly closure outperforms closure for the major portion of the files.
in terms of the rest closure is able to achieve the same obfuscation as closure.
the red arrow demonstrated the maximal improvement where the optimized obfuscation protected more variables from attack.
considering all the normal projects we calculated the relative improvement over closure in table ii.
under the attack of jsnice closure optimized the obfuscation of closure by protecting more variables.
we also listed results for top three popular projects angular meteor and react which have github stars on average.
likewise closure exhibits an average optimization.
similarly we carried the experiments on obfuscated projects3.
from right part of figure we find that the maximal improvement involves variables .
according to table ii closure managed to reduce the number of recovered variables from in closure to .
although the absolute improvement is not as big as in normal projects the relative improvement tends to be close .
the achieved optimization can be seen as effective transformations to confuse the attacking process making adversaries to infer in a wrong direction.
in addition we run our sampling with greedy strategy and without conflict removal last two rows in table ii .
the optimization decreases to and respectively which embodies the necessity of our mcmc random search with conflicting function elimination.
we also conduct the wilcoxon signed rank test over obfuscation results from closure and closure to validate the statistical significance.
with the .
z score which does not exceed the critical value .
according to the optimization is statistically significant.
in general our findings 3obfuscated projects are those on which jsnice can only recover small number of variables.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
obfuscation optimization on part of normal projects left and obfuscated projects right .
arrow pointing down means closure is better up means closure is better.
the longer an arrow is the greater the optimization is.
answer rq2 in the affirmative and also convince us that the efficacy of closure is not limited in the training corpus of the obscurity lm.
on the other hand the optimized obfuscation transformations is not always the same configuration as closure particularly some use fewer while some use more.
this also hints us that the assumption adding a transformation is always good may not hold.
fig.
for attacks on closure and closure left shows the number of successful defence.
for those failed defence right summarizes how much extra delay closure and closure can incur.
in real world applications a major strength of obfuscation is the incurred delay on possible malicious use.
to further exploit the practical benefits of the optimized obfuscation we investigate how much extra difficulty is added compared to closure in terms of manual attacks.
we deliver obfuscated files loc from closure or closure of meteor project to programmers phd and master both have at least year javascript programming experience asking them to identify the core functionality related variables by assigning given meaningful names.
the accuracy and delay on the tasks which interpret the practical benefits are summarized in figure .
here we count how many attacks are successfully defended using closure and closure respectively how long is the delay on effective attacks.
clearly closure shows better defense by blocking more for closure attacks in total.
with respect to other misses closure is also able to increase the attack delay by on average.
with the growth on file size this advantage can be amplified disabling more potential attacks.
in sum we believe closure offers complementary power to defend practical attacks on obfuscation which is probably relied on human understanding and learning basedtools as well.
therefore we can reply to rq3 with a positive answer.
in the future intensive experiments are planned on more professional attackers.
fig.
execute different numbers of iterations to evaluate the achieved obfuscation improvement.
furthermore we analyzed how the number of iterations affected obfuscation improvement.
we randomly select files and employ different numbers of iterations for obfuscation.
the tuning process is shown in figure .
in principle obfuscating larger programs should be more difficult than small ones since it is harder to locate a good obfuscation within bounded search.
generally the obfuscation improvement grows fast with the increase on number of iterations when the total number is small n .
however for large numbers n the observed improvement remains at a similar level.
the trend can be explained as the obfuscation is optimized when the obfuscator is able to locate suitable transformations.
commonly the effective configuration combines specific set of obfuscation transformations.
thus if the sampling is inefficient there is little possibility to hit a good solution.
conversely if the sampling already offers enough chances to the obfuscator increasing iterations displays little impact.
y et there are also cases which achieve a high improvement with a small number of iterations.
that is because those files match to a single transformation to the most.
in that case even an inadequate sampling can uncover the best.
this observation opens the possibility for closure to infer a good configuration of specific files so as to enforce an efficient iteration.
e. threats to v alidity construct validity.
this threat concerns the relation between theory and experimental observations.
in our case we focus on authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
optimizing the obfuscation to improve the obscurity.
to measure obscurity we turn to calculate perplexity count the number of recovered variables and efforts cost in manual attack.
the most possible threat is that the measurement cannot truly capture obscurity.
as a response we clarify that quantifying obscurity is not our goal instead we try to identify good obfuscations from poor ones.
from this point our measurement is useful which is confirmed in the evaluation where the guided optimization weakened the adversary and deterred practical attacks.
on the other side we also agree on the significance of more advanced connections between obscurity and program information to which the proposed framework can flexibly interface.
external validity.
this threat focuses on to what degree our approach can generalize to applications outside the scope in this paper.
there indeed exists the potential threat that the proposed obfuscation framework may not adapt to most or all types of programs since our instantiation is for javascript and experimented on open source projects.
however the threat is mitigated by the fact that our framework is not language dependent and can be instantiated in other language domains and open source projects share a considerable group of common elements with other non public ones.
thus we believe the found trend should be general.
vii.
r ela ted work in this section we discuss on the related works.
to optimize program obfuscation we take a novel position to effectively employing well designed transformations.
the key idea is a combination of stochastic search techniques and language model of source code.
code obfuscation.
program obfuscation has been extensively studied to make reverse engineering or human understanding harder .
theoretically it is claimed that no perfect obfuscation exists .
despite of the impossibility barak suggested indistinguishability obfuscation .
garg and brakerski further presented obfuscators for polynomial size circuits .
barak described a simplified variant to achieve protection against algebra attacks .
sahai proposed punctured programs for cryptographic problems .
goldwasser proposed to identify the best possible obfuscation which leaks as little information as other programs with the same functionality .
other works were advanced in pursuit of better efficiency .
for practical software use collberg proposed the opaque predicate to obfuscate the program by inserting boolean valued expressions whose values are known to obfuscators but difficult to analyze for automatic tools .
sharif employed the conditional code obfuscation at compilation phase to transform input dependent branch conditions and encrypt the body .
regarding program slicing as the adversary drape transformed code so that the orphaned slices code left after the slicing are minimized .
differently linn presented a complement to thwart disassembling process which translates machine code to assembly code .
considering semantics researchers viewed program analyses as adversaries and identify a set of transformations to make the analyses as much imprecise aspossible.
regarding abstract interpretation giacobazzi leveraged interpreter distortion to generate obfuscated code with the notion of incompleteness .
on the other side preda investigated the concrete program semantics instead of abstract semantics to guide the obfuscation process .
compared to previous works we focus on the emerging learning based adversaries.
moreover we proposed to search for effective obfuscation transformations for a given program which results in an input sensitive optimization.
languagem models of source code.
due to the fact that software is repetitive and not unique language models can be built for source code to capture regularities.
based on the classical n gram model hindle exploited the naturalness of software which proved code to be predictable and led to a programming suggestion engine .
nguyen extended the model with sememes to involve semantic information other than lexemes .
moreover the localness is further enriched by tu via proposing a cache language model to absorb local constructs for predicting programs .
in terms of method sequence raychev built the language models on call sequences .
the language model can synthesize method calls based on context and fill program holes across various objects with arguments.
towards the application of suggesting names allamanis and raychev addressed the naming for variables while allamanis handled methods and classes as well .
in our setting we built an obscurity language model to capture the remaining regularities of obfuscated programs.
to this end we built the language model with obemes which is different from lexemes based techniques.
viii.
c onclusion verifiability.
the replication package of closure is at .
conclusion.
in this paper we have proposed a novel language model based obfuscation framework.
two key insights behind the framework are we have built a language model for obfuscated programs and validated that perplexity helps capture obscurity and we employ stochastic search like mcmc to effectively identify powerful obfuscation configurations for diverse source programs.
generally the framework can be regarded as a dynamic guided combination of existing obfuscation techniques and techniques from the nlp community.
we have realized the framework as closure for javascript programs.
evaluated on top active github projects closure is shown to outperform state of the art obfuscators and support diverse programs.
the achieved optimization can help deter advanced practical attacks.
we believe that the presented framework highlights a new perspective on program obfuscation and complements existing work.
acknowledgment we thank the anonymous reviewers for the constructive comments.
this research is sponsored by nsfc program no.
no.
national science and technology major project n0.16zx010 miit it funds research and application of tcn key technologies of china and national key technology r d program no.2015bag14b01 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.