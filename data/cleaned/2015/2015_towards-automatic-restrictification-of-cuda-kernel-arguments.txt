towards automatic restrictification of cuda kernel arguments rokiatou diarra satie univ.
paris sud univ.
paris saclay gif sur yvette france rokiatou.diarra u psud.fr abstract many procedural languages such as c and c have pointers.
pointers are powerful and convenient but pointer aliasing still hinders compiler optimizations despite several years of research on pointer aliasing analysis.
because alias analysis is a difficult task and results are not always accurate the iso c standard 99has added a keyword named restrict to allow the programmer to specify non aliasing as an aid to the compiler s optimizer and to thereby possibly improve performance.
the task of annotating pointers with the restrict keyword is still left to the programmer.
this task is in general tedious and prone to errors especially since the c does not perform any verification to ensure that restrict keyword is not misplaced.
in this paper we present a static analysis tool that i finds cuda kernels call sites in which actual parameters do not alias ii clones the kernels called at such sites iii after performing an alias analysis in these kernels adds the restrict keyword to their arguments and iv replaces the original kernel call by a call to the optimized clone whenever possible.
ccs concepts computing methodologies parallel programming languages graphics processors software and its engineering automated static analysis source code generation keywords gpu cuda restrict compilers program optimization aliasing acm reference format rokiatou diarra.
.
towards automatic restrictification of cuda kernel arguments.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa pages.
https problem today variants of the c language such as cuda and opencl are still used to program on multicore or gpu machines.
one of the most important characteristics of languages such as c is the existence of pointers.
pointers are powerful and convenient but they can also hinder compiler optimization.
indeed it is hard to know permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn .
.
.
.
pointers are pointing and compilers must be conservative in their presence.
consider the example provided in listing without further knowledge or special hardware support the compiler must assume that a qandpmay refer to the same memory region or overlapping regions so that the loop cannot be parallelized or software pipelined because it has to be ensured that an update of q is performed before the next value of p is loaded for example.
this constraint also prevents the compiler from generating loads for multiple array elements of aandpat the same time since the subsequent store to q may modify elements of arrays aor p. because the compiler must conservatively assume the pointers alias it will compile this code inefficiently even if the programmer knows that the pointers never alias.
vo id vectmatmul f l o a t a f l o a t q f l o a t p f o r i n t i i ni i f o r i n t j j nj j q a p listing a vector and matrix multiplication example to ensure that the correct code is generated in the presence of aliases compilers have to perform an alias analysis to determine the aliases in the program.
although the literature of alias analysis is abundant and much work e.g have been done in the last few decades the research community has not yet solved pointer alias analysis satisfactorily.
many alias analyzer are implemented in mainstream compilers but the results of these analyzers are often inaccurate.
pointer analysis imprecision is a severe problem while it prevents the compiler from optimizing some code where there is no aliasing.
to mitigate the problem posed by pointers some programming languages furnish developers with high level constructs that they can use to tell compilers that variables do not alias each other.
therefore the c programming language since the c99standard features the restrict keyword that can be used by the programmer to give the compiler information about aliasing.
in fact it is applied to a pointer pto say that only por a pointer derived from it can access that memory region during its lifetime.
hence if pis a restricted pointer then any access to pthrough any other means may result in undefined behavior.
therefore if the arguments of example routine in listing have been annotated with the restrict qualifier thereby allowing the compiler to perform more aggressive optimization such as instructions scheduling loop invariant code motion redundant load store elimination etc.
although the restrict keyword has been available for several years already it remains less used by programmers and its insertion is left to the programmer.
the task of inserting the restrict qualifier is in general tedious and prone to errors especially since the c does not perform any verification to ensure that restrict keyword is not misplaced.
although many work have been done on alias analysis authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france r. diarra fewer have been done on automatic insertion of restrict keyword.
while nvcc the nvidia compiler supports restricted pointers via the restrict keyword we propose a new static analysis tool that i finds cuda kernels call sites in which actual parameters do not alias ii clones the kernels called at such sites iii after performing an alias analysis in these kernels adds the restrict keyword to their arguments and iv replaces the original kernel call by a call to the optimized clone whenever possible.
background in this section we provide some background about pointer alias analysis and cuda programming model.
.
pointer alias analyzer characteristics a pointer alias analysis attempts to determine when two pointer expressions refer to the same storage location .
for instance if two pointers pandqboth reference the same memory location then pandqare said to alias.
there are many challenges for alias analysis including the complexity the scalability and the precision of the analysis.
alias analysis can be classified as flow sensitive or flow insensitive depending on whether statements order information is used during the analysis.
by not considering the order of statements and therefore computing a conservative summary a flow insensitive analysis can be more efficient but less accurate than a flow sensitive analysis .
in addition to flow sensitivity there are several other design options including context sensitivity if different calling contexts are considered the analysis is contextsensitive otherwise it is context insensitive and structure modeling treat structures elements as individual locations field sensitivity or treat entire structure as a single location field insensitivity ?
.
.
cuda programming model cuda is a parallel computing programming model that fully utilizes hardware architecture and software algorithms to accelerate various types of computation.
in cuda the programmer writes device code in functions called kernel .
a kernel will be executed by many gpu threads.
during kernel execution threads have access to different types of memory on the gpu.
before launching kernels data must be transfered to gpu memories.
to obtain optimized code the programmer must understand well gpu architecture and cuda optimization strategies like memory coalescing access efficient usage of shared memory or tiling technology.
listing shows a simple cuda kernel example.
while nvcc the nvidia compiler supports restricted pointers we can add the restrict type qualifier to our pointers declaration.
g l o b a l v oi d gemm f l o a t r e s t r i c t a f l o a t r e s t r i c t b f l o a t r e s t r i c t c f l o a t alpha f l o a t b e t a i n t j b l o c k i d x .
x blockdim .
x t h r e a d i d x .
x i n t i b l o c k i d x .
y blockdim .
y t h r e a d i d x .
y i f i ni j nj c b e t a f o r i n t k k nk k c a l p h a a b listing simple gemm kernel example in cuda3 previous work in this section we review some previous work about alias analysis and static analysis of cuda programs.
.
pointer alias analysis alias analysis is one of the most used techniques that aim to optimize languages with pointers.
it is no surprise that this topic has received much attention in many fields including compilation and program verification.
the literature of alias analysis is abundant.
for a quite exhaustive