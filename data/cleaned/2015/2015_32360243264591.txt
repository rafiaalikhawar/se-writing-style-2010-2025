a formal verification tool for ethereum vm bytecode daejun park university of illinois at urbana champaign usa runtime verification inc. usa dpark69 illinois.eduyi zhang university of illinois at urbana champaign usa runtime verification inc. usa yzhng173 illinois.edumanasvi saxena university of illinois at urbana champaign usa runtime verification inc. usa msaxena2 illinois.edu philip daian cornell tech usa ic3 usa runtime verification inc. usa phil linux.comgrigore ros u university of illinois at urbana champaign usa runtime verification inc. usa grosu illinois.edu abstract in this paper we present a formal verification tool for the ethereum virtual machine evm bytecode.
to precisely reason about all possible behaviors of the evm bytecode we adopted kevm a complete formal semantics of the evm and instantiated the kframework s reachability logic theorem prover to generate a correctby construction deductive verifier for the evm.
we further optimized the verifier by introducing evm specific abstractions and lemmas to improve its scalability.
our evm verifier has been used to verify various high profile smart contracts including the erc20 token ethereum casper and dapphub makerdao contracts.
demo video url ccs concepts software and its engineering software verification keywords ethereum smart contracts formal verification k framework acm reference format daejun park yi zhang manasvi saxena philip daian and grigore ro s u. .
a formal verification tool for ethereum vm bytecode.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction smart contract failures have caused millions of dollars of lost funds and rigorous formal methods are required to ensure the correctness and security of contract implementations.2the smart contract is permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
written in a high level language such as solidity3or vyper4 and then it is compiled down to the ethereum virtual machine evm bytecode5that actually runs on the blockchain.
in this paper we present a formal verification tool for the evm bytecode.
we chose the evm bytecode as the verification target language so that we can directly verify what is actually executed without the need to trust the correctness of the compiler.
to precisely reason about the evm bytecode without missing any evm quirks we adopted kevm acomplete formal semantics of the evm and instantiated the k framework s reachability logic theorem prover to generate a correct by construction deductive program verifier for the evm.
while it is sound the initial outof box evm verifier was relatively slow and failed to prove many correct programs.
we further optimized the verifier by introducing custom abstractions and lemmas specific to evm that expedite proof searching in the underlying theorem prover.
we have been using the evm verifier to verify the full functional correctness of high profile smart contracts including multiple erc20 token contracts ethereum s casper6contract and dapphub s makerdao7contract.
our verification tool and artifact is publicly available at .
contributions.
we describe our primary contributions we present a formal verification tool for the evm bytecode that is capable and scalable enough to verify various highprofile safe critical smart contracts.
moreover our verifier is the first tool to the best of our knowledge that adopts a complete formal semantics of evm being able to completely reason about all possible corner case behaviors of the evm bytecode.
see section for comparison to other tools.
we enumerate important concrete challenges in verifying the evm bytecode and propose evm specific abstractions and lemmas to mitigate the challenges.
section we present a case study of completely verifying high profile erc20 token contracts.
we enumerate divergent behaviors we found across these tokens illuminating potential security vulnerabilities for any api clients assuming consistent behavior across erc20 implementations.
section esec fse november lake buena vista fl usa d. park y. zhang m. saxena p. daian and g. ros u evm verification challenges verifying the evm bytecode is challenging especially due to the internal byte manipulation operations that require non linear integer arithmetic reasoning which is undecidable in general .
here we provide a few examples of the challenges.
byte manipulation operations.
the evm provides three types of storage structures a local memory a local stack and the global storage.
of these only the local memory is byte addressable i.e.
represented as an array of bytes while the others are word addressable i.e.
each represented as an array of byte words .
thus a byte i.e.
bit word needs to be split into chunks of bytes to be stored in the local memory and those chunks need to be merged back to be loaded in either the local stack or the global storage.
these byte wise splitting and merging operations can be formalized using non linear integer arithmetic operations as follows.
suppose xis a bit integer.
let xnbe the nthbyte of xin its two s complement representation where the index refers to the least significant bit lsb defined as follows xndef x 256n mod letmerge be a function that takes as input a list of bytes and returns the corresponding integer value under the two s complement interpretation recursively defined as merge xi xj 1xj def merge xi xj xjwhen i j merge xi def xi where and are multiplication and addition over words modulo .
if the byte wise operations are blindly encoded as smt theorems then z3 a state of the art smt solver times out attempting to prove x merge x31 x0 .
the smt query can be simplified to allow z3 to efficiently terminate for example by omitting the modulo reduction for multiplication and addition in merge with additional reasoning about the soundness of the omission.
despite these improvements the merge operation still incurs severe performance penalties as solving the large formula is required for every load store into memory an extremely common operation.
arithmetic overflow.
since evm arithmetic instructions perform modular arithmetic i.e.
mod detecting arithmetic overflow is critical for preventing potential security holes due to an unexpected overflow.
otherwise for example increasing a user s token balance could trigger an overflow resulting in loss of the funds as the balance wraps around to a lower than expected value.
there is no standard evm level overflow check so the overflow detection varies across compilers and libraries.
for example the vyper compiler inserts the following runtime check for an addition a b over the bit unsigned integers aandb b a b a where represents addition modulo .
it seems straightforward to show that the above formula is equivalent to a b where is the pure addition without modulo reduction but it is no longer 8it is also possible to formalize the byte manipulation using the bit vector theory but the formalization using the mathematical integer theory has an advantage of the functional specifications being succinct.
indeed the kevm semantics adopted the integer formalization because of the advantage.trivial once the above is compiled down to evm.
the compiled evm bytecode of the above conditional expression can be encoded in the smt lib format as follows not chop bool2int b bool2int chop a b a where chop x denotes xmod and bool2int x is defined by ite x .
however z3 fails timeout to prove that the above smt formula is equivalent to a b .
hash collision.
precise reasoning about the sha3 hash9is critical.
since it is not practical to consider the hash algorithm details every time the hash function is called in the evm bytecode an abstraction for the hash function is required.
designing a sound but efficient abstraction is not trivial because while the sha3 hash is not cryptographically collision free the contract developers assume collisions will not occur during normal execution of their contracts.10a naive way of capturing the assumption would be to simply abstract the sha3 hash as an injective function.
however it is not sound simply because of the pigeonhole principle and thus we need to be careful when abstracting the hash function.
evm specific abstractions k s reachability logic theorem prover can be seen as a symbolic model checker equipped with coinductive reasoning about loops and recursions refer to for details of the underlying theory and implementation .
the prover in its current form often delegates domain reasoning to smt solvers.
the performance of the underlying smt solvers is critical for the overall performance.
the domain reasoning involved in the evm bytecode verification is not tractable in many cases especially due to non linear integer arithmetic.
we had to design custom abstractions and lemmas to avoid the non tractable domain reasoning and improve the scalability.
abstraction for local memory.
we present an abstraction for the evm local memory to allow word level reasoning.
as mentioned in section since the local memory is byte addressable the load and store operations involve the conversion between a word and a list of bytes which is not tractable to reason about in general.
our abstraction helps to make the reasoning easier by abstracting away the byte manipulation details of the conversion.
specifically we introduce uninterpreted function abstractions and lemmas for word level reasoning as follows.
the term nthbyteof v i n represents the ithbyte of the two s complement representation of vinnbytes being the most significant bit with discarding high order bytes when vdoes not fit in nbytes.
precisely it is defined as follows nthbyteof v i n nthbyteof v i n when n i nthbyteof v i n vmod when n i however we want to keep it uninterpreted i.e.
do not unfold the definition when the arguments are symbolic to avoid the expensive non linear arithmetic reasoning.
we introduce lemmas over the uninterpreted functional terms.
the following lemmas are used for symbolic reasoning about mload 10the assumption is not unreasonable as virtually all blockchains rely heavily on the collision resistance of hash functions.
913a formal verification tool for ethereum vm bytecode esec fse november lake buena vista fl usa andmstore instructions.
they capture the essential mechanisms used by the two instructions splitting a word into a list of bytes and merging it back into the word.
first we have the bound of nthbyteof v i n by definition nthbyteof v i n .
then we have the following lemma for the merging operation merge nthbyteof v n nthbyteof v n n v if0 v 28nand1 n refer to for the other lemmas of the memory abstraction.
abstraction for hash.
we do not model the hash function as an injective function simply because it is not true due to the pigeonhole principle.
instead we abstract it as an uninterpreted function hash that takes as input a list of bytes and returns an unsigned integer hash n note that this abstraction allows the possibility of hash collision.
however one can avoid reasoning about the potential collision by assuming all the hashed values appearing in each execution trace are collision free.
this can be achieved by instantiating the injectivity property only for the terms appearing in the symbolic execution in a way analogous to universal quantifier instantiation.
arithmetic simplification rules.
we introduce simplification rules specific to evm that capture arithmetic properties which reduce a given term into a smaller one.
these rules help to improve the performance of the underlying theorem prover s symbolic reasoning.
for example we have the following simplification rule x y y xify where is the integer division.11we also have a rule for the masking operation 0xff f n as follows m n nifm logmand0 n m where is the bitwise and operator and mdenotes a bitmask 0xff f. refer to for other simplification rules.
case study erc20 verification we present a case study of completely verifying high profile practically deployed implementations of the erc20 token contract one of the most popular ethereum smart contracts that provides the essential functionality of maintaining and exchanging tokens.
.
formal specification the erc20 standard informally specifies the correctness properties that erc20 token contracts must satisfy.
unfortunately however it leaves several corner cases unspecified which makes it less than ideal to use in the formal verification of token contracts.
we specified erc20 k a complete formalization of the highlevel business logic of the erc20 standard in the k framework.
erc20 k clarifies what data e.g.
balances and allowances are handled by the various erc20 functions and the precise meaning of those functions on such data.
erc20 k also clarifies the meaning of all the corner cases that the erc20 standard omits to discuss such as transfers to itself or transfers that result in arithmetic overflows 11note that z3 fails to prove this seemingly trivial formula at the time of this writing.
indeed this issue has been fixed in the develop branch once reported by the authors of this paper calldata abicalldata transfer address to uint256 value statuscode evmc success output asbytestackinwidth log ... .
abieventlog from transfer indexed address from indexed address to uint256 value storage hashedlocation balances from bal from bal from int value hashedlocation balances to bal to bal to int value ... requires andbool from int to andbool value int bal from andbool bal to int value int int calldata abicalldata transfer address to uint256 value statuscode evmc revert output log ... storage hashedlocation balances from bal from hashedlocation balances to bal to ... requires andbool from int to andbool value int bal from orbool bal to int value int int figure formal specification of transfer function following the most natural implementations that aim at minimizing gas consumption.
the complete specifications are available at .
figure for example shows part of the simplified specification of transfer .
it specifies two possible behaviors success and failure.12for each case it specifies the function parameters calldata the return value output whether an exception occurred statuscode the log generated log the storage update storage and the path condition requires .
specifically the success case denoted by specifies that the function succeeds in transferring the value tokens from the from account to the toaccount with generating the corresponding log message and returns i.e.
true if no overflow occurs i.e.
the from account has a sufficient balance and the toaccount has enough room to receive the tokens .
the failure case specifies that the function throws an exception without modifying the account balances if an overflow occurs.
.
formal verification for this case study we consider three erc20 token implementations the vyper erc20 token13 the hackergold hkg erc20 token14 and openzeppelin s erc20 token15.
of these the vyper erc20 token is written in vyper and the others are written in solidity.
we compiled the source code down to the evm bytecode using each language compiler and executed our verifier to verify that the compiled evm bytecode satisfies the aforementioned specification.
12transfer admits four possible behaviors success and failure of regular transfer i.e.
from to and success and failure of self transfer i.e.
from to .
here we omit the self transfer behaviors due to space limit.
refer to for the complete specification.
solidity compatible erc20.vy standardtoken.sol token erc20 standardtoken.sol 914esec fse november lake buena vista fl usa d. park y. zhang m. saxena p. daian and g. ros u table verification time secs of erc20 token contracts vyper hkg zeppln.
vyper hkg zeppln.
totalsupply .
n a .
approve .
.
.
balanceof .
.
.
transfer .
.
.
allowance .
.
.
transferfrom .
.
.
during this verification process we found divergent behaviors across these contracts that do not conform to the erc20 standard.
due to the deviation from the standard we could not verify those contracts against the original erc20 k specification.
in order to show that they are correct w.r.t.
the original specification modulo the deviation we modified the specification to capture the deviation and successfully verified them against the modified specification.
table provides the performance of the verifier.
below we describe the results.
vyper erc20 token.
the vyper erc20 token is successfully verified against the original specification implying its full conformance to the erc20 standard.
hackergold hkg erc20 token.
in addition to the well known security vulnerability of the hkg token 16we found that the hkg token implementation deviates from our specification as follows no totalsupply function no totalsupply function is provided in the hkg token which is notcompliant to the erc20 standard.
returning false in failure it returns false instead of throwing an exception in the failure cases for both transfer and transferfrom .
it does not violate the standard as throwing an exception is recommended but not mandatory according to the erc20 standard.
rejecting transfers of values it does not allow transferring values returning false immediately without logging any event.
it is notcompliant to the standard.
this is a potential security vulnerability for any api clients assuming the erc20 compliant behavior.
no overflow protection it does not check arithmetic overflow resulting in the receiver s balance wrapping around the bit unsigned integer s maximum value in case of the overflow.
it does not violate the standard as the standard does not specify any requirement regarding it.
however it is potentially vulnerable since it will result in loss of the funds in case of the overflow as the receiver s balance wraps around to a lower than expected value.
openzeppelin erc20 token.
the openzeppelin erc20 token is a high profile erc20 token library developed by the security audit consulting firm zeppelin17.
we found that the openzeppelin token deviates from the erc20 k specification as follows rejecting transfers to address it does not allow transferring to address throwing an exception immediately.
it does not violate the standard as the standard does not specify any requirement regarding it.
however it is questionable since note that the token contract had been manually audited by zeppelin but they failed to find the vulnerability which implies the need of the rigorous formal verification.
there are many other invalid addresses to which a transfer should not be made it is not clear how useful rejecting a single invalid address is at the cost of the additional gas consumption for every transfer transaction.
related work while there exist several static analysis tools tailored to check certain predefined properties here we consider due to space limit only the verification tools backed by a full fledged theorem prover that allows to reason about arbitrary full functional correctness properties.
specifically bhargavan et al.
and grishchenko et al.
presented a verification tool based on the f proof assistant and amani et al.
presented a tool based on isabelle hol.
these tools however adopt only a partial incomplete semantics of evm and thus may miss certain critical corner case behaviors of the evm bytecode which could undermine the soundness of the verifiers.
our evm verifier on the other hand is a verification tool derived from a complete andthoroughly tested formal semantics of evm for the first time to the best of our knowledge.