efficient scalable verification of ltl specifications luciano baresi mohammad mehdi pourhashem kallehbasti and matteo rossi politecnico di milano dipartimento di elettronica informazione e bioingegneria via golgi milano italy emails luciano.baresi mohammadmehdi.pourhashem matteo.rossi polimi.it abstract linear temporal logic ltl has been used in computer science for decades to formally specify programs systems desired properties and relevant behaviors.
this paper presents a novel efficient technique for verifying ltl specifications in a fully automated way.
our technique belongs to the category of bounded satisfiability checking approaches where ltl formulae are encoded as formulae of another decidable logic that can be solved through modern satisfiability solvers.
the target logic in our approach is bit vector logic.
we present our novel encoding show its correctness and experimentally compare it against existing encodings implemented in well known formal verification tools.
i. i ntroduction linear temporal logic ltl has been used in computer science for decades .
its applications include the specification and verification of possibly safety critical programs and systems test case generation run time verification planning and controller synthesis .
in addition ltl or its expressively equivalent variants can be used as underlying formalism to capture the semantics of semi formal notations like uml to perform formal verification on them as we showed in .
however for an ltl based approach to be effective in practice there must be techniques and tools that allow users to check big ltl specifications in a short amount of time.
in this paper we focus on the problem of performing formal verification on systems described through a set of ltl formulae.
these ltl descriptions could be the outcome of systematic requirements elicitation or formal specification but they could also be the output of tools producing ltl formalizations from more informal languages such as uml.
in fact one of the driving factors that led us to pursue the work presented in this paper was the necessity of formally verifying larger uml models than those that can be managed by the tool introduced in .
formal verification of ltl specifications can be carried out through tools capable of determining the satisfiability of sets of ltl formulae.
various techniques have been developed in the past based for example on automata construction .
in this work we pursue an approach based on the notion of bounded satisfiability checking a variant of bounded model checking that focuses on the satisfiability of temporal logic formulae.
in bounded satisfiability checking approaches ltl formulae are suitably translated into formulae of another decidable logic such as propositional logic which precisely capture ultimately periodic models of the original formulae of length up to a bound k produced formulae arethen fed to a solver for the target logic e.g.
a sat solver for verification.
the first question tackled by this paper is thus how can we analyze bigger models?
we studied a way to allow a bounded satisfiability checker to work on both more complex formulae and larger bounds k. the proposed solution eschews the usual propositional logic as target logic and encodes ltl formulae into formulae of bit vector logic which can be efficiently analyzed by modern satisfiability modulo theories smt solvers such as the well known z3 .
we implemented the encoding in a plugin called bvzot of our zot tool .
even if the initial results were very encouraging with respect to both improvements on previous versions of zot and our goal of being able to analyze larger uml models we wanted to move a step further and try to generalize them.
our second research question was then how can we compare these results against the state of the art in the field and understand how good in general they are?
this is why we started using nusmv which is one of the reference tools for bounded model checking techniques.
the paper thus presents the promising results we obtained by comparing the performance of nusmv and bvzot on several case studies with different characteristics two of them are well known benchmarks while a third one comes from one of our uml specifications since we also wanted to relate these results to our original problem.
to summarize the contributions of this paper are twofold.
first we introduce a novel translation of ltl formulae into formulae of bit vector logic.
second we provide a systematic comparison of our verification tool with the reference tools in the field which shows that bvzot compares favorably to them.
the rest of this paper is organized as follows.
section ii provides a brief introduction to ltl and presents the classic propositional logic based encoding of ltl formulae which is then used to demonstrate the correctness of our own encoding.
section iii summarizes the key elements of bit vector logic and proposes the encoding we devised in addition it studies the correctness and complexity of our encoding.
section iv presents the toolset we used for evaluation the experiments we carried out and the results we obtained.
section v surveys related approaches and section vi concludes the paper.
ii.
b ackground a. linear temporal logic ltl is a widely used specification logic.
in this paper we focus on the version with both future and past temporal operators.
in fact although past operators do not increasethe expressiveness of the logic they are advantageous for compositional reasoning .
in addition ltl with past operators is exponentially more succinct than its future only counterpart .
an ltl formula is defined over a set of atomic propositions ap.
the syntax of ltl is defined by the following grammar pj j jx jy j u j s wherep2ap xanduare the next and until future operators whereas y yesterday and s since are their past counterparts.
the semantics of ltl is given in terms of infinite sequences of sets of atomic propositions or words .
a word n!2ap assigns to every instant of the temporal domain n the possibly empty set of atomic propositions that hold in that instant.
we can think of a word as an infinite sequence of states s0s1s2 where each state is labeled with the atomic propositions that hold in it.
we say that a word satisfies formula at instanti written ij if holds when evaluated starting from instant iof .
the following is the usual formal semantics of the satisfiability relation for ltl ij p p2 i forp2ap ij i6j ij ij 1and ij ij x i 1j ij y i 0and i 1j ij 1u 9j is.t.
jj and8ns.t.i n j nj ij 1s 9j is.t.
jj and8ns.t.j n i nj we say that a word satisfies ltl formula when it holds in the first instant of the temporal domain i.e.
when 0j .
in this case we will sometimes write j .
a word that satisfies is amodel for .
starting from the basic connectives and operators it is customary to introduce the other traditional boolean connectives ... and temporal operators as abbreviations.
in particular the eventually in the future f globally in the future g and release r operators and their past counterparts eventually in the past p historically hand trigger t are defined as follows f u g f 1r 1u p s h p 1t 1s b. bounded satisfiability checking the principle that underlies both bounded model checking bmc and bounded satisfiability checking bsc techniques is given formalizations of the system sand of the property that should hold for the system to look for an infinite ultimately periodic execution s0s1 sl slsl sk !
ofsthat violates wherekis a parameter.
if a counterexample witnessing the violation of the property exists then the propertydoes not hold for s. if no counterexample of length up to k is found then the property holds for sprovided that kis big enough .
both techniques can be used to check whether an ltl formula is satisfiable or not.
at the core of both bmc and bsc is the idea of translating an ltl formula into a formula of propositional logic that represents ultimately periodic models of .
then its verification is performed by feeding the translated formula to a solver.
in the following we briefly describe the classic technique for encoding ltl formulae into propositional logic introduced in which is at the core of bsc.
to this end one only needs to represent states s0 sl sk and then the fact that the state after sk saysk is in fact slagain.
hence the bounded encoding captures finite sequences of states of the form s s where s0s1 sl sl sk and s sl sk .
the encoding is defined as boolean constraints over socalled formula variables j ji.
these are boolean variables which are used to represent the value of all subformulae of the ltl formula to be checked for satisfiability in instants k .
more precisely given an ltl formula and a boundk the encoding introduces for each subformula of k 2formula variablesj j0 j j1 j jk 1which capture whether is true or not at the various instants in .
in addition the encoding introduces k loop selector variablesl0 l1 l k which are fresh boolean variables such thatllis true iff the loop starts at position l hence ifllis true thensl sk at most one of l0 l1 l kcan be true.
other boolean variables are introduced for convenience the k variablesinloop i with i k are such that inloop i is true iff position iis in the loop i.e.
l i k .
finally variableloopexists is true iff the desired loop exists.
in the rest of this section we present the constraints that are imposed on the boolean variables introduced above to capture the semantics of ltl formulae.
the following table defines a set of constraints called jloopconstraints jk base l0 inloop i k li si sk inloop i inloop i 1 li inloop i li loopexists inloop k they essentially define the semantics of booolean variables fligi2 finloop igi2 andloopexists e.g.
the existence of at most one loop .
in addition as mentioned in they impose that the same atomic propositions that hold in state skalso hold in state sl which has been shown to improve the efficiency of the model search.
the following table shows jlaststateconstraints jk.
base loopexists j jk i kli j jk j ji they define that the subformulae of that hold in sk 1are the same as those that hold in state sl.
this effectively defines that after state skthe bounded trace loops back to state sl.the subsequent constraints define the semantics of the propositional connectives and of the temporal operators.
the next table introduces the set of constraints jpropconstraints jk which capture the semantics of propositional connectives i k pj ji p2 i pj ji p i 2j ji j ji j ji 1 2j ji j ji j ji for example jpropconstraints jkstate that the value of j jiandj jicapture whether propositional letter pholds at instantior not.
the definitions of j jand ofj j are straightforward.
notice that the boolean encoding was defined for ltl formulae in positive normal form pnf i.e.
in which negations can only appear next to atomic propositions.
this can save some formula variables but the encoding can be easily generalized to formulae that are not in pnf.
the next tables define the semantics of the temporal operators both future x uandr and past ones y sandt .
we call this whole set of constraints jtempconstraints jk.
the semantics of uandris defined through their standard fixpoint characterization i k x j ji j ji 1u 2j ji j ji j ji j ji 1r 2j ji j ji j ji j ji the definition of the semantics of uand ris completed through the introduction of the set of constraints jeventualitiesjk which are presented in the following table base 1u 2loopexists j jk hhf 2iik 1r 2loopexists j jk hhg 2iik 1u hhf 2ii0 ?
1r hhg 2ii0 i k 1u 2hhf 2iii hhf 2iii 1 inloop i j ji 1r 2hhg 2iii hhg 2iii inloop i j ji these constraints are used to make sure that if 1u holds insk then 2occurs infinitely often that is it occurs somewhere in the loop.
similarly if 1r 2occurs insk then either 2holds throughout the loop or at some point of the loop 1holds.hhf 2iiiandhhg 2iiiare auxiliary variables required for capturing these constraints.
hhf 2iii holds if position ibelongs to the loop and 2holds in at least one position between landi.
accordingly hhf 2iikmeans that 2holds somewhere in the loop.
therefore constraint loopexists j jk hhf 2iik does not allow 1u 2to hold atk if 2does not occur infinitely often.
similarly hhg 2iikholds iff 2holds everywhere in the loop.
then constraint loopexists j jk hhg 2iik forcesj jkto hold if 2holds from position lon.the next table defines the semantics of the past operators y sandt which is symmetrical to their future counterparts.
i k y j ji j ji z j ji j ji 1s 2j ji j ji j ji j ji 1t 2j ji j ji j ji j ji it also defines operator z which is necessary for formulae in pnf which is simply a variant of ysuch that z holds in no matter .
since the temporal domain is mono infinite i.e.
it is infinite only towards the future there is no need to impose eventuality constraints over past operators.
however we must define the value of past operators in the origin .
this is done through the constraints of the following table.
base y j j0 z j j0 1s 2j j0 j j0 1t 2j j0 j j0 finally given an ltl formula its boolean encoding bis given by the conjunction of the constraints in setsjloopconstraints jk jlaststateconstrants jk jpropconstraints jk jtempconstraints jk and jeventualitiesjk plus the statement that holds in the origin i.e.j j0.
iii.
b it vector based encoding a. bit vector logic this section briefly presents the operations on bit vectors that are defined in bit vector logic and that we use in our encoding.
a bit vector is an array whose elements are bits booleans .
in bit vector logic the size of a bit vector number of bits is finite and can be any nonzero number in n. for the bit vector xwith sizen we use the notation x or simply xwhen the size is not important or can be inferred from the context.
furthermore x stands for the ithbit in the bit vector x where bits are indexed from right to left.
accordingly x is the leftmost and most significant bit and x is the rightmost and least significant bit.
for constants we use the notation c which is the two s complement representation of integer covernbits for example is1110 .
bit vector logic offers a wide range of operators.
the two core operators are concatenation and extraction .concatenation x y is a bit vector z such that z y and z x .
for example .extraction x is a bit vector z where z x and z x which can be defined through concatenation as x i k jx .
for example .arithmetic operators addition and subtraction throw away the final carry bit and the resulting bit vector has the same size as the operands.
unsigned shift to the right left throws away he rightmost leftmost bit and inserts zero from the left right.
for example and .
we also use bitwise operators like negation !
conjunction disjunction j and reduction and .
the reduction and operator is defined as x n i x i.e.
it is the and of all the bits in x .
the size of the resulting bit vector is one.
the bit corresponds to the minimum value in x in other words it is equal to oneif all the bits of the bit vector xare one zero otherwise.
bit vectors or parts thereof can be compared using the usual relational operators and formulae of bit vector logic can be built using the usual boolean connectives .
b. encoding similarly to the classic boolean encoding of section ii b our encoding uses a bit vector of size k 2to represent the truth values of each subformula of from 0tok .
however we only introduce as many bit vectors as the number of atomic propositions in the formula and describe the values of the nonatomic subformulae as transformations on the former vectors.
more precisely for each p2ap we introduce a bit vector p i.e.
of sizek such that p withi2 captures the value of proposition pat instanti.
recall that p is the right most least significant bit in p and p is the left most most significant one.
in addition we introduce a bit vector loop that contains encoded in binary the position of the loop in interval i.e.
the position of the first state sin s s .
for the sake of uniformity in using bit vector logic operators to capture the semantics of ltl formulae we encode ?
false as i.e.
a sequence of zeros and true as i.e.
a sequence of ones so the size of all bit vectors used in the encoding is k .
to introduce the bit vector based encoding of ltl formulae it is useful to first define some auxiliary operators on bit vectors that will be exploited in the following.
these operators are defined below.
operator definition rev x k i x xunl y yj x !rev rev xj y rev y rev xreverses the order of the bits in bit vector x. xunl yproduces a bit vector say z such that if one takes xand yto represent the values of some formulae x y in then zcorresponds to the value of xuywhen one considers only finite models i.e.
there is no loop hence the subscript nl .
later in this section we give an example of computation of xunl y. in the bit vector based encoding of ltl the bit vector capturing the value of a formula in is obtained by recursively performing operations on the bit vectors corre sponding to the subformulae of .
the operations performed depend on the structure of .
the next table shows the case in which the main connective in is a boolean one.
bit vector encoding !
1 1j for example if is of the form then its corresponding bit vector is obtained by applying bit wise negation to the bit vector corresponding to subformula .
similarly for the other cases.
the next table shows the transformations in the case of both future x u and past y s temporal operators.
bit vector encoding x 1u 1unl 1unl y 1s 2j !
1j we illustrate the cases for the past operators first which are a bit simpler and then we focus on the future ones.
yesterday .
given the semantics of formula y where y holds atiiff holds ati the bit vector for y is the one for but shifted to the left from i 1toi recall that position in bit vectors is the rightmost one .
note that by definition of shifting to the left the rightmost bit of is which is consistent with the semantics of y in the origin.
table i shows an example of calculation of the bit vector for 1s given bit vectors 1and .
table i an example of calculation of bit vector for s. bit vector 1j bv1 1j bv2 !
bv1 bv3 bv2 1s bv3j since .
first of all recall that informally 1s 2holds at iiff either 2holds ati or 1holds ati i until an instanti0 iin which 2holds 1can hold ini0or not .
said in another way if 2holds ini0 then 1s 2holds there and in all instants i0 i0 in which 1holds consecutively.
we use addition to capture this mechanism through which the truth of s carries to the left from when 2holds as long as 1holds.
consider term 1j whenever 2is this generates a carry since both bits are which propagates as long as 1is as between bits and in table i. the net effect is that in the sum the bits from i0until stops holding are set to and the others are set to we do not delve into the details of some special cases which are covered by the correctness proof of section iii c .
starting from this basis the rest of the operations are necessary to set to exactly all the bits in which sholds notice that in this case 1s 2holds not only where 1j 2is but also at position where 2holds .
more precisely the result of 1j 2is bit wise complemented to bring the 0s to 1s it is then filtered against 1with a bitwise and to eliminate those cases in which the result of the sum is because both 1and 2are and there is no carry from i 1s 2does not hold there finally the bit wise or with 2sets to all those positions in which 2holds since 1s 2holds there.
we now illustrate the encoding of the future operators x u. next .
the encoding of formula x is essentially dual to that ofy i.e.
a bit wise shift to the right of bit vector .
in fact x holds atiiff holds ati .
however a true right shift would always introduce a at position k which would be incorrect.
in fact recall that in bounded encodings such as the classic one presented in section ii b we need the state to repeat at positions k 1andl with the latter corresponding to the position of the first sin s s which in the bit vector encoding is represented by the value of bit vector loop.
hence the value of x at positionsk 1andlmust be the same this is also true for y but it is achieved in a different way than forx as it will be explained later .
note that the value of x at positionlis the same as at positionl hence the bit vector corresponding to x is obtained by concatenating with .
until .
the bit vector corresponding to 1u 2is computed by exploiting the operator unlintroduced above.
in fact the operations performed by unlare the same as those for the computation of 1s but carried out left to right instead of right to left.
to achieve this bit vectors xj yand yare reversed through rev before being added together and the result is also reversed.
as mentioned above the operations performed by operator unlare the same as those for the encoding of 1s but carried out in the reverse direction.
hence they produce from bit vectors xand y a bit vector that corresponds to the truth ofxuyevaluated over finite models whereby xuyholds at positionk 1iffyholds atk .
however when finite traces of the form s s are used to represent ultimately periodic models one must take into account that in the encoding 1u 2can hold ink i.e.
states also if 1holds there and 2holds somewhere in with 1holding in the prefix of until then .
since the states in positions k 1andlare the same they are boths this is the same as saying that in position l 1u holds in the finite model that is the l th bit of 1unl is .
if conversely the l th bit of 1unl 2is then thereis no point in in which 2holds with 1holding until then so 1u 2does not hold in state s at position lor at positionk .
finally to correctly compute the bit vector corresponding to 1u we compute 1unl take itsl th bit to determine whether 1u 2holds ins then use bit vector 1unl as the second argument of unl in fact as mentioned above by definition the value of xunl yat a positionk 1is iff y .
whereas the functions computing bit vectors for future operators x uby construction impose that the value of the subformula in positions landk 1is the same the same does not happen for the functions that compute the bit vectors for past operators y s. these so called last state constraints see also section ii b are easily included in the encoding by adding for each formula y the constraint and similarly mutatis mutandis for each formula 1s .
the last state constraints must be added for all subformulae including propositional letters so for each p2ap we also include the constraint p p .
notice that it is not necessary to include the last state constraints for each subformula of the form 2and 1 as they are automatically guaranteed recursively.
we indicate this set of constraints asjbvlaststateconstraints jk.
finally the so called loop constraints see section ii b are easily imposed by adding for each p2ap the constraint p p .
we name this set of constraints jbvloopconstraints jk.
then given an ltl formula the complete bit vector based encoding called bv is given by the setjbvlaststateconstraints jk which includes constraints for each p2ap and for each past formula y and 1s the setjbvloopconstraints jk which includes a constraint for each p2ap constraint where is the bit vector obtained through the transformations above.
for example consider formula xp quyp .
its complete encoding is given by the following formula p p q q p p p p q q !
p p j qunl qunl p p as remarked in section ii a it is customary to define the other temperal operators from the basic ones as abbreviations.
in some cases we can use the abbreviation to further simplify the encoding of these operators by exploiting the properties of bit vector operations.
first of all we can introduce operators xrnl yandfnl y shown below whose definitions correspond respectively to the simplified versions of xunl y and unl y.operator definition xrnl y y xjrev rev !
xj!
y rev !
y fnl y yj!rev rev y using these operators we can in turn simplify the encoding of derived temporal operators randfas shown below.
similarly for the encoding of operators tandp.
bit vector encoding 1r 1rnl 1rnl f fnl fnl 1t 1j !
1j!
!
p j!
w k finally the encoding of always written w which is defined as w g h can be simplified as shown above by considering that its value is throughout if has value everywhere otherwise its value is at every position.
we conclude this section by remarking that if one wants to consider formulae in pnf see section ii b which entails that operator zbe introduced the semantics of z is simply captured by the transformation j .
c. correctness of the encoding in this section we show that the new bit vector based bounded encoding of ltl formulae is equivalent to the classic boolean one introduced in section ii b. to show the equivalence it is natural to consider a bit vector x of sizen whose bits are x x as a set of nboolean variables j j0 j jn .
an operation on bitvectors e.g.
returns a bit vector which corresponds to its own set of boolean propositions hence for example bitvector x obtained by shifting xto the left comprises n bits x x which in turn correspond to boolean variables j j0 j jn .
recall that given an ltl formula we indicate by bthe set of formulae that correspond to the boolean encoding of and by bvthe ones of the bit vector based encoding of see sections ii b andiii b for the definitions of band bv .
we have the following result.
theorem given an ltl formula the encoding bis equivalent to the encoding bv.
proof we prove the equivalence by showing that every constraint in bcorresponds to a constraint in bvand viceversa.
first of all we remark that the bit vector encoding assumes the existence of a loop starting at position l so we focus on this case for the proof.
this is without loss of generality as it is always possible to extend an aperiodic trace with a dummy loop at the end in which nothing happens.
notice also that since lis the position of the first sin s s we have that l k .
let us first consider the jloopconstraints jk.
it is easy to see that they directly correspond to jbvloopconstraints jk which in fact impose that for each p2ap in the corresponding bit vector pit holds that p p .
given the correspondence between bits of bit vectors and propositional letters introduced in the boolean encoding this is the same as saying for each p2ap thatj jl j jk.
we will tacklejlaststateconstraints jkat the end of the proof.
we now focus on the encoding of propositional connectives i.e.jpropconstraints jk.
the bit vector of formula 2is simply that is for each bit i2 we will deal with the k th bit in the jlaststateconstraints jk it is iff which corresponds to boolean constraints j ji j ji j ji i.e.
jpropconstraints jk for the connective.
similarly for the connective.
as far as the connective is concerned recall that the boolean encoding assumes formulae in positive normal form pnf an optimization for saving intermediate boolean variables which we do not pursue in the bit vector based encoding.
even in the boolean encoding the optimization could be eliminated without impacting on the correctness of the encoding by introducing a boolean variablej jfor each formula of the form with the constraint that j ji j ji.
then it is obvious that such a constraint corresponds to the semantics of the bit wise negation !
iff .
let us now focus on jtempconstraints jk starting from those regarding past operators yands.
the semantics of y is captured by the transformation which by definition means that for all i2 it holds that .
this corresponds to the constraint that for i k j ji j ji .
in addition by definition of which corresponds to the constraint j j0 that appears in the boolean encoding.
the encoding of 1s is trickier.
in the boolean encoding we have that for i2 j ji j ji j ji j ji with the additional constraint that j j0 j j0.
to show how this is equivalent to the bit vector encoding in which the bit vector representing 1s 2is 2j !
1j we need to show that for i2 if and then !
1j is iff 1s 2holds in i if i.e.
j jiis true or i.e.
j ji is false the boolean and bit vector encodings clearly yield the same result .
then we need to determine when 1j provided and .
notice that if and then 1j iff there is a carry from i .
this occurs recursively iff either and there is a carry from i or .
by inductive reasoning for 1j to be there must be i0 iin which and for all i i00 i0it is and .
in other words 1s 2holds ini .
if on the other hand 1s 2holds ini there must be i0 iwhere and for alli i00 i0it is .
in this case in i0 1j generates a carry which propagates to the left until in iit produces a .
notice that since in position there can be no carry 2j !
1j iff which corresponds to the boolean encoding of 1s 2in .
let us now focus on the future operators xandu.
since the bit vector for x is fori2 we will deal with the case i k when focusing onjlaststateconstraints jk we have that which corresponds to the boolean encoding of x i.e.
j ji j ji .
the encoding of urelies on operator unl whose definition coincides with that ofs except that the arguments are reversed before applying the sum and reversed again after having applied it.
as a consequence the properties of unlare the same as those of the encoding of s except that the bit vectors are considered in reverse order.
then we can conclude that for i2 xunl y iff there isi i0 k 1such that y and for all i i00 i0 x holds.
in addition xunl y iff y .
the boolean encoding ofudiffers from that of sbecause unlike the latter where the value of 1s 2in depends exclusively on the value of 2there in the former the value in kdepends on whether there is a position in the loop i.e.
in the part s of the trace where 2holds as defined by constraints jeventualitiesjk.
given the properties of operator unl and in particular the fact that xunl y iff y the value of 1unl 1unl is iff either or and 1unl .
in both cases there must be a position in the loop in which 2holds the first is evident that position is k the second derives from the fact that by the properties of unl 1unl 2is inliff there isl i0 k in which 2holds notice that as it will be shown below it is guaranteed that .
finally we need to show that the jlaststateconstraints jk are also captured by the bit vector based encoding.
to this end recall that for propositional letters and past operators yand sthe following constraints are explicitly introduced p p and 2j !
1j 2j !
1j .
these are trivially equivalent to boolean constraintsj jl j jk j jl j jk 1and j jl j jk .
in the case of xanduoperators the constraint is enforced in the construction of the corresponding bit vector.
more precisely we have recall that l k .
as far as the uoperator is concerned 1unl 1unl iff thek th bit of the second argument is i.e.
1unl 1unl 1unl .
if 1unl then there isl i0 k such that and for alll i00 i0.
ifi0 k it is easy to see that 1unl 1unl 1unl 1unl 1unl .
if instead i0 k then 1unl so 1unl and again 1unl 1unl 1unl 1unl 1unl .
if 1unl then there is no l i0 k 1such that and for alll i00 i0.
then a fortiori also 1unl so again we have the equality of thel th andk th bits in 1unl 1unl .
finally the fact that jlaststateconstraints jkhold also for formulae of the form 2and 1 2can be easily shown by induction where the base cases are those already tackled above.
to conclude the proof we remark that the classic boolean encoding natively defines the semantics of operators randt.
in our bit vector based encoding instead the encoding of these operators exploits their definition as abbreviations for formulae involving uands hence the correctness of the encoding in this case derives directly from that of the encoding of formulae 1u 2and 1s .
d. complexity as remarked in section iii b in the bit vector based encoding of an ltl formula we introduce a number of bit vectors of lengthk 2that is equal to the number of propositional letters appearing in .
in the boolean encoding instead k propositional letters are introduced for each subformula of hence the bit vector encoding is more compact from this point of view.
the size of the constraint which relies on the transformations captured in section iii b to build the expression of is linear in the size of the formula if we introduce one bit vector for each subformula.
in fact in this case if nis the number of subformulae of for each subformula we build a transformation of bit vectors according to the tables of section iii b whose size is constant hence the total size of constraint iso n .
since the number of propositional letters appearing in is bounded by the size of the latter and since the size of the loop constraints of the form p p is constant with respect to n the size of jbvloopconstraints jkis alsoo n .
finally one element of jbvlaststateconstraints jkis introduced for each subformula whose principal operator is a past one.
for example if subformula yypappears in constraints p p and p p both belong tojbvlaststateconstraints jk.
ifm nis the number of past operators appearing in the size ofjbvlaststateconstraints jkiso mn hence it is quadratic in the worst case.
regarding the size of jbvlaststateconstraints jkhowever we remark that it can be easily made o n as in the boolean encoding by introducing for each subformula of or at least for each past subformula of a fresh bit vector in this case for example thejbvlaststateconstraints jkfor formula yyp would be after having defined bv1 pand bv2 bv1 bv bv and bv bv .
however if the number of past subformulae is small with respect to n then it might be more efficient to avoid introducing additional intermediate bit vectors and exploit the effective simplification algorithms implemented in solvers of bit vector logic to handle the constraints effectively.iv.
i mplementation and evaluation the bit vector based encoding has been implemented as a plugin in the zot tool called bvzot .
zot is an extensible bounded model satisfiability checker written in common lisp.
more precisely zot is capable of performing bounded satisfiability checking of formulae written both in ltl with past operators and in the propositional discrete time fragment of the metric temporal logic trio which is equivalent to ltl but more concise.
in fact trio formulae can straightforwardly be translated into ltl formulae so we use the two temporal logics interchangeably.
the verification process in zot goes through the following steps i the user writes the specification to be checked as a set of temporal logic formulae these formulae could also be produced automatically as in and selects the plugin and the time bound i.e.
the value of bound k to be used to perform the verification ii depending on the input temporal logic trio or ltl and the selected plugin zot encodes the received specification in a target logic e.g.
propositional logic or bit vector logic iii zot feeds the encoded specification to a solver that is capable of handling the target logic iv the result obtained by the solver is parsed back and presented to the user in a textual representation.
zot supports both sat solvers e.g.
minisat for propositional logic and smt solvers e.g.
z3 for bitvector logic and decidable fragments of first order logic.
to evaluate the bit vector based encoding we compared it against three other encodings available in the literature the classic bounded encoding presented in the optimized encoding presented in which has been further improved in and made incremental in and the encoding optimized for metric temporal logic presented in .
the first two encodings are implemented in the well known nusmv model checker in fact nusmv implements an optimized incremental version of the classic encoding of whereas the third is implemented in the meezot plugin of the zot tool.
in the rest of this section we will label the experiments carried out with the classic encoding implemented in nusmv asbmc those performed with the optimized encoding of assmbc those with the incremental version of sbmc presented in as sbmc inc1 and those performed with the metric encoding implemented in zot as meezot all these labels come from the commands used in nusmv and zot to select the encodings .
note that both nusmv and zot support other encodings for ltl trio we have chosen those mentioned above because further experiments not reported here have shown them to be on average the most efficient ones for the two tools.
to test the relative efficiency of the four encodings we applied them to the verification of three case studies two from the literature and one from previous work of ours.
the case studies were chosen mostly for their complexity to highlight the 1while conductiong the sbmc inc experiments we did not activate the completeness checking option since it often slows the verification down as shown in .relative strengths and weaknesses of each tool.
these three case studies employ a bsc approach that is they use temporal logic to describe both the system under verification and the properties to be checked.
in all three cases we performed two kinds of checks.
first we took the temporal logic formula sdescribing the system and we simply checked for its satisfiability.
this allowed us to determine whether the specification is realizable or not.
as a second type of check we also provided a logic formula pcapturing the property that the system should have satisfied and we fed the bsc algorithm with formula s p to determine whether the property holds for the system or not.
we also experimented with different bounds kto analyze how the tools behave when kis increased.
we now briefly introduce the three case studies interested readers can refer to the cited literature for their details.
kernel railway crossing krc .
the krc problem is frequently used for comparing real time notations and tools .
a railway crossing system prevents crossing of the railway by vehicles during passage of a train by controlling a gate.
a temporal logic based version of the krc was developed in for benchmarking purposes.
it describes one track and one direction of movement of the trains and it considers an interlocking system.
we experimented with two sets of time constants that allow different degrees of nondeterminism hereafter denoted as krc1 andkrc2 .
the level of nondeterminism is increased by using bigger time constants e.g.
the time for a train to go through the railway crossing which increase the number of possible combinations of events in the system.
we also carried out formal verification with two properties of interest a safety property that says that as long as a train is in the critical region the gate is closed p1 and a utility property that states that the gate must be open when it is safe to do so i.e.
the gate should not be closed when unnecessary where the notion of safe is captured through suitable time constants p2 .
fischer s protocol .
this is a classic algorithm for granting exclusive access to a resource that is shared among many processes.
fischer s protocol is a typical benchmark for verification tools capable of dealing with real time constraints.
the version we used for our tests where the specification of the system is described through temporal logic formulae is taken from it includes processes and the delay that a process waits after sending a request which is the key parameter in fischer s protocol is time instants.
we performed formal verification of a safety property that states that it is never the case that two processes are simultaneously in their critical sections p1 .
verification of uml diagrams .corretto2is the toolset we developed to perform formal verification of uml models .
corretto takes as input a set of uml diagrams and produces their formal representation through formulae of temporal logic.
in our tests we used the example diagrams introduced in which describe the behavior of an application that pings two servers and then sends queries to the server that responds the model comprises a loop and we performed tests on two versions of the system called sdserverl2 and sdserverl3 where the number of iterations in the loops is and respectively.
we also performed formal verification on the example system using property p1defined in to which we refer the reader for further details on this case study.
to compare the performances of the bmc sbmc sbmc inc meezot andbvzot encodings we built a simple translation tool that converts specifications written in the zot input language such as those used in and into the input language of nusmv .
bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot sat 30 p1 30 p1 60 p1 90 time sec time memory bvzot sf sf sf bvzot bvzot bvzot memory mb fig.
.
time memory comparison for krc1 sat and p1 .
bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot p2 30 p2 60 p2 90 time sec time memory memory mb sf sf sf to to bvzot bvzot bvzot fig.
.
time memory comparison for krc1 p2 .
figures show the time in seconds and memory in mbs consumed in each of the experiments we performed.
note that if no bar is visible and no error tag is reported this means that the number is very small.
for example figure shows the time memory consumption for each encoding bmc sbmc sbmc inc meezot and bvzot for the various checks on example krc1 simple satisfiability checking with maximum bound k sat 30 and verification of property p1with maximum bound k p1 30 k p1 60 andk p1 90 respectively.
the role of 3interested readers can refer to kallehbasti icse .php for the complete and detailed data about the experiments.
bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot sat 30 p1 30 p1 60 p1 90 time sec time memory sf sf sf sf to sf he memory mb bvzot bvzot bvzot bvzot fig.
.
time memory comparison for krc2 sat and p1 .
bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot p2 30 p2 60 p2 90 time sec time memory memory mb sf sf sf sf mo sf he bvzot bvzot bvzot fig.
.
time memory comparison for krc2 p2 .
the maximum bound is the following for a given maximum boundk the tools iteratively possibly incrementally try to find an ultimately periodic model !where the length of is1 k .
as soon as a model is found the search stops and the model is output if no model is found for any bound up tok the search stops at kand the formula is declared unsatisfiable.
all the runs reported in figures had a time limit of hour and a memory limit of 4gb ram that is if the verification took longer than hour or occupied more than 4gb of ram it was stopped.
hence the possible outcomes of a run are satisfiable unsatisfiable out of time to and out of memory mo .
in addition in some cases the tool stopped with a segmentation fault sf error and in others with heap exhausted he while pre processing the specification to produce the encoding.
all the experiments were carried out on a linux desktop machine with a .
ghz intel r coretmi7 cpu and gb ram4.
the nusmv version was .
.
.
the sat and smt solvers used with zot were respectively minisat version .
and z3 version .
.
.
as the figures show among the algorithms implemented in nusmv sbmc inc is the most memory efficient while 4bvzot along with the code for all the experiments is available on the zot repository bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot sat 30 p1 30 p1 60 p1 90 time sec time memory memory mb mo mo bvzot bvzot bvzot bvzot fig.
.
time memory comparison for fischer sat and p1 .
bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot sat 50 p1 30 p1 45 p1 60 time sec time memory memory mb sf sf sf sf sf sf he he mo he sf bvzot bvzot bvzot bvzot fig.
.
time memory comparison for sdserverl2 sat and p1 .
sbmc is the fastest.
there are six models that sbmc inc can afford to verify while sbmc fails.
however for the models both encodings can afford sbmc is faster than sbmc inc .
when performing checks that require small bounds such as the satisfiability checks bvzot is only occasionally more efficient than the other tools.
however as the models and bounds5grow in size bvzot demonstrates its strengths.
for example when proving properties for the krc version with the highest level of nondeterminism i.e.
krc2 bvzot is the only tool able to explore all the bounds up to and it is faster than the others when the time bound is kept smaller or .
similar results hold for the verification of properties on the uml diagrams whose formalization in temporal logic is in fact the biggest specification that we have tested due to the necessity of capturing all the possible sequences of events in the sequence diagram.
however we must highlight that in the case of fischer s protocol sbmc is the most efficient encoding time wise whereas bvzot is often the one with the least memory consumption.
all in all we can conclude that the experimental results show a promising ability by bvzot to scale up as the size of the specification and of the time bound increase.
further gains 5for each satisfiability experiment the length of the smallest model found was the same for each tool for the krc examples the execution in which nothing happens that is no train enters the crossing is admissible for fischer s protocol for sdserverl2 and for sdserverl3 .
bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot bmc inc sbmc inc sbmc meezot bvzot sat 60 p1 30 p1 45 p1 60 time sec time memory memory mb sf sf sf sf he he he he sf sf sf mo bvzot bvzot bvzot bvzot fig.
.
time memory comparison for sdserverl3 sat and p1 .
could also be obtained by adapting some of the optimizations presented in in bvzot .
v. r elated work there are essentially two approaches to the problem of satisfiability checking of ltl formulae bounded and automatabased ones.
this paper pursues a bounded approach and section iv compares it against similar ones and in particular those presented in and .
rozier and vardi carried out a comparison of satisfiability checkers for ltl formulae based on the translation of ltl formulae into b chi automata.
rozier and vardi also propose a novel translation of ltl formulae into transitionbased generalized b chi automata inspired by the translation presented in .
such automata are used by spot which is claimed to be the best explicit ltl to b chi automata translator for satisfiability checking purposes based on the experiments carried out in .
li et al.
present a novel on the fly construction of b chi automata from ltl formulae that is particularly well suited for finding models of ltl formulae when they exist.
given the different nature of our approach with respect to automata based ones however we did not compare our approach against them and focused on similar bsc based approaches instead.
finally an exhaustive evaluation of several techniques and tools including some that are not based on translation to b chi automata or on bounded approaches can be found in .
vi.
c onclusions and future work this paper presents a novel efficient technique for verifying ltl specifications implemented in the prototype tool bvzot .
obtained results show the ability of this solution to scale up and be usable for analyzing complex ltl specifications efficiently.
in classic boolean encodings all the constraints are fed to the solver at bit level which makes the solver blind to their relations at any higher level.
our encoding introduces the constraints at word level and exploits the ability of modern solvers to work on word level simplifications.
as for future work we plan to keep refining the encoding and identify further challenging case studies and competitors.