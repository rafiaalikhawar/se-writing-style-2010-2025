field exhaustive testing pablo ponzio znazareno aguirre zmarcelo f .
friasyzwillem visserx departamento de computaci n universidad nacional de r o cuarto argentina pponzio naguirre dc.exa.unrc.edu.ar ydepartamento de ingenier a de software instituto tecnol gico de buenos aires argentina mfrias itba.edu.ar zconsejo nacional de investigaciones cient ficas y t cnicas conicet argentina xdepartment of computer science university of stellenbosch south africa wvisser cs.sun.ac.za abstract we present a testing approach for object oriented programs which encompasses a testing criterion and an automated test generation technique.
the criterion that we call eldexhaustive testing requires a user provided limit non the size of data domains and is based on the idea of considering enough inputs so as to exhaustively cover the extension of class elds within the limit n. intuitively the extension of a eldfis the binary relation established between objects and their corresponding values for eld f in valid instances.
thus a suite sis eld exhaustive if whenever a eld frelates an object owith a value v i.e.
o f v within a valid instanceiof size bounded by n thenscontains at least one inputi0covering such relationship i.e.
omust also be part ofi0 ando f vmust hold in i0.
our test generation technique uses incremental sat solving to produce small eld exhaustive suites eld exhaustiveness can be achieved with a suite containing at most f n2inputs where f is the number of elds in the class under test.
we perform an experimental evaluation on two di erent testing domains drawn from the literature implementations of data structures and of a refactoring engine.
the experiments show that eld exhaustive suites can be computed e ciently and retain similar levels of code coverage and mutation killing as signi cantly larger bounded exhaustive and random suites thus consuming a fraction of the cost of test execution compared to these automated testing approaches.
ccs concepts software and its engineering !software testing and debugging keywords software testing automated test generation sat solving1.
introduction testing is a powerful and widely used technique for software quality assurance .
it essentially consists of assessing the quality of a piece of code by executing it under a number of particular inputs which are a de ning part of test cases .
for a set of test cases to be adequate these generally need to exercise the software under varying situations.
this of course increases the chances to detect bugs since the software being assessed is more thoroughly examined.
software testing criteria de ne concrete mechanisms to decide when a set of tests or suite is adequate or su ciently thorough in the examination of the software under evaluation .
most testing criteria have been de ned under the assumption that tests including test inputs are manually written.
thus even for sophisticated criteria such as some white box criteria like condition coverage and mc dc modi ed condition decision coverage suites with very good levels of coverage can be achieved while keeping the size of the suite small which of course requires in many cases signi cant efforts from the testing engineers.
with the advent of automated test generation techniques testing approaches that are impractical with manual testing though feasible through automated testing are emerging.
relevant cases of this are bounded exhaustive testing a black box criterion which proposes to test programs on allvalid inputs bounded by a user provided bound and random testing a well known testing approach proposing to test programs on randomly generated inputs .
these approaches have proved to be e ective in various testing domains .
however bounded exhaustive test suites are inherently combinatorial in size and randomly generated suites typically have to be composed of large test sets to achieve good coverage levels.
this fact makes the execution of such suites prohibitively expensive in many situations especially when they need to be repeateadly used e.g.
in regression testing contexts.
in this paper we present a testing criterion for object oriented programs that we call eld exhaustive testing which requires a user provided limit non the size of data domains.
this criterion is based on the idea of considering enough inputs so as to exhaustively cover the extension of class elds within the provided limit n. intuitively the extension of a eldfis the binary relation established between objects and their corresponding values for eld f in valid instances bounded by n. thus a suite sis eld exhaustive if whenever a eld frelates an object owith a value v i.e.
o f v within a valid instance iof size bounded by n thenscon tains at least one input i0covering such relationship i.e.
o must also be part of i0 ando f vmust hold in i0.
we also present a technique that automatically generates eldexhaustive suites using incremental sat solving .
we perform an experimental evaluation on two di erent testing domains drawn from the literature the implementations of data structures and of a refactoring engine that show that eld exhaustive suites can be e ciently produced and if symmetry breaking is imposed our automatically generated eld exhaustive suites are small while retaining similar levels of code coverage and mutation killing as signi cantly larger bounded exhaustive and random suites.
moreover we prove that eld exhaustive suites can be achieved with at most f n2inputs where fis the number of elds in the class under test and nthe user provided bound on the size of data domains.
this implies that in many cases eldexhaustive suites can be executed at a fraction of the cost of test execution of bounded exhaustive or random suites to achieve comparable coverage or mutation score.
.
background given a program and a test suite for it a testing criterion enables one to assess how well the suite exercises the program.
there exist two broad testing criteria categories white box and black box .
white box criteria take into account the structure of the program under test while black box criteria deal with the program as a black box and may only examine its speci cation .
an example of a whitebox criterion is statement coverage which requires each program statement to be executed by some test.
an example of a black box criterion is equivalence partitioning which divides the state space of inputs of the software under test into equivalence classes and requires each equivalence class to be covered by some test in the suite.
most prevailing testing criteria have been devised under the assumption that test suites are produced manually and thus can be satis ed with a relatively small number of test cases.
advances in automated testing are enabling novel criteria whose applicability strongly depends on testing automation both at generation time and at execution time.
an example of such a testing technique is random testing a wellknown testing approach proposing to test programs on randomly generated inputs .
while random testing originally applied to programs with inputs of basic datatypes and simply resorted to random number generators for input generation more recently the approach has been successfully extended to complex inputs e.g by randomly producing sequences of methods that construct the inputs and exploiting feedback of previously generated cases to avoid redundancies or employing user provided input generators to randomly create test cases .
random testing can generate very good test suites e.g.
suites with high coverage or good mutation killing scores very e ciently but at the expense of producing large suites with large tests composed of large sequences of methods usually constraints have to be imposed during generation e.g.
maximum test length maximum generation time or maximum size of test suite to limit the size of the produced suites and therefore the time for testing and a compromise has to be established between the test suite sizes and quality of the suites.
another important testing technique that can be e ectively applied thanks to automation and is strongly related to the technique we present in this paper is bounded exhaus tive testing .
bounded exhaustive testing produces for a given program and a user provided bound non the size of inputs called the scope all valid inputs whose size is bounded byn and then tests the program using the produced test suite.
for instance bounded exhaustively testing a routine manipulating binary search trees de ned by the classes in fig.
for a scope of up to nodes and key and size values from to consists of checking the routine on allvalid search trees that can be built using at most nodes with values of keys and size within .
this testing technique has proved useful in some testing contexts in particular for testing code that manipulates complex data structures or programs that deal with source code such as compilers and refactoring engines.
the rationale behind the approach is based on the small scope hypothesis many bugs in programs manipulating complex data can be reproduced using small instances of such data.
thus by testing the program on all possible inputs bounded in size by some relatively small scope one would be able to exhibit most bugs.
the scope establishes a maximum number of objects in the heap e.g.
binary search tree object t0 node objects n0 n1 n2 n3 and a domain for each eld of each of these objects e.g.
for a node n0 according to its type eld n0.left can be assigned either null or one element from fn0 n1 n2 n3g the nodes available in the heap .
a speci cation of the valid structures e.g.
a representation invariant for search trees such as the one in fig.
distinguishes between well formed bounded structures and ill formed ones that can be disregarded for testing.
a crucial mechanism that tools for bounded exhaustive testing base their e ciency on is the ability to remove disregard and avoid visiting a particular kind of redundant instances during generation.
these are the so called isomorphic instances i.e.
instances which only di er in the object identi ers assigned to their composing nodes.
consider for instance the two binary search trees in fig.
.
these two trees are exactly the same hold the same information but their nodes identi ers di er.
in fact one is a permutation of the other.
intuitively these identi ers correspond to memory locations and therefore these trees di er in where their nodes are located in the heap.
such di erence is irrelevant in most applications and thus one may want to avoid generating both cases since one represents the other.
symmetry breaking approaches allow us to deal with this issue by enforcing a canonical order in nodes and thus allowing for only one canonical representative for all isomorphic instances.
for example korat s symmetry breaking approach is based on a rule enforcing that while repok the operational implementation of the representation invariant is generating a candidate structure during the search for valid structures when attribute fis dened for node ni its valueni fmust be either null or must be within the set fn0 n1 n mg wheremis the smallest identi er not already used.
notice that for the repok routine in fig.
the rst tree in fig.
is accepted while the second is not.
a similar symmetry breaking approach employed by some tools based on declarative logical languages for invariant speci cation such as taco and fajita is based on the addition of further logical restrictions imposing that when a structure is traversed in breadth rst order node identi ers are sequentially labeled.
.
motivating example let us consider again binary search trees already em public class binarytree private node root private int size ... public class node private int key private node left private node right ... setters and getters of the above fields ... figure java classes de ning binary search trees.
ployed for illustration in the previous section.
the representation invariant for this structure states that the linked structure formed from the root node following the left and right elds must be acyclic that each node in it except the root which must have no parent must have exactly one parent and that the tree must be ordered.
this invariant can be captured operationally as in the repok java predicate shown in fig.
or logically declaratively as shown in fig.
in this case expressed using alloy s relational logic other logical formalisms such as jml can be also employed to declaratively capture the invariant .
a userprovided scope de nes a nite set of possible structures but only a portion of these are valid i.e.
satisfy the representation invariant.
for instance for up to nodes sizes and keys within ranges and respectively a total of structures can be built but only satisfy the invariant.
notice that the stronger the representation invariant the smaller the set of valid structures.
symmetrybreaking also has a signi cant impact on the number of valid structures out of the valid structures for the above scope only are non isomorphic.
moreover symmetry breaking also impacts test input generation s e ciency for instance the bounded exhaustive testing tool korat takes a third of the time to produce the non isomorphic structures compared to the time it takes to produce the structures when symmetry breaking is disabled.
despite the improvements in suite s size and generation time that symmetry breaking provides bounded exhaustive suites inherently grow combinatorially as the scope increases even for strong representation invariants.
this fact makes it costly to compute bounded exhaustive suites for larger scopes and the corresponding large testing times makes it often prohibitive to use bounded exhaustive testing especially when these suites are incorporated into processes that require their repetitive use along the development process as in regression testing.
a similar case can be made for other automated generation techniques random testing in particular.
for our running example for instance randoop can achieve a similar mutation killing score and branch coverage as the bounded exhaustive suite of scope only after producing tests see section on validation .
again such test suite sizes make the use of the produced test suites impractical in many situations.
our proposal is related to bounded exhaustive testing in the sense that it requires a user provided scope.
but as opposed to bounded exhaustive testing our approach is based on the observation that while the scope determines a set ofpublic boolean repok if root null return true if !isacyclic return false if !isordered root return false return true private boolean isacyclic set visited new hashset visited.add root linkedlist worklist new linkedlist worklist.add root while !worklist.isempty node current node worklist.removefirst if current.getleft !
null if !visited.add current.getleft return false worklist.add current.getleft if current.getright !
null if !visited.add current.getright return false worklist.add current.getright return true private boolean isordered node n int min int max if n.info return false if min !
n.getkey min max !
n.getkey max return false if n.left !
null if !isordered n.getleft min n.getkey return false if n.right !
null if !isordered n.getright n.getkey max return false return true figure operational version of the representation invariant for binary search trees.
2leftright13n0rootn1n22leftright13n1rootn2n0 figure two isomorphic binary search trees.
possible target values for each eld of each heap object this target domain may be restricted to a smaller set of feasible values both by the representation invariant and symmetrybreaking predicates and a smaller set of valid instances may be needed to cover these feasible values.
as an example let us consider again the previously mentioned scope and let us concentrate for the moment on the values of eld left for node n0.
this eld s type and the scope de ne fn0 n1 n2 n3 nullgas the range set of the eld but we know that there are only two possible values for n0.left namely null and n1.
any other value is forbidden either by the representation invariant or by symmetry breaking.
let us call thenfnull n1gtheextension ofn0.left .
following a similar reasoning the extension of eld n0.right isfn1 n2 nullg and so on.
field exhaustive testing as opposed to bounded exhaustive testing requires considering enough inputs so that the extension of every eld within a given scope is covered .
for instance for the above scope all n node n in thiz.root.
left right implies no n.left .
left right n.right .
left right null no node can be reached along two different paths and n !in n. left right the structure is acyclic and all m node m in n.left.
left right implies gt left sorted and all m node m in n.right.
left right implies gt right sorted and thiz.size thiz.root.
left right field size is well defined figure logical invariant for binary search trees.
leftrightn0rootn1n2leftn3rightn0n2rightn1rootrightn0n3rightn1rootleftn2 n2rightn0leftn1rootrightn0n2rightn1root n3rightn2rightn0leftn1rootleftn3root figure field exhaustive suite for binary search trees with scope keys ignored .
inputs su ce to achieve eld exhaustiveness whose shapes are shown in fig.
we ignore key values for presentation purposes as opposed to the non isomorphic instances that constitute the bounded exhaustive suite for the same scope.
this di erence is more pronounced as the scope increases for instance for scope nodes size within keys within eld exhaustiveness can be achieved with instances while non isomorphic instances constitute the bounded exhaustive suite for the same scope.
randoop still needs to produce more than tests to achieve the same mutation killing and coverage as the eld exhaustive suite composed of structures.
in the next section we formally introduce eld exhaustive testing while in section we concentrate on a technique to automatically build eld exhaustive suites.
.
field exhaustive testing in this section we formally de ne eld exhaustive testing as a testing criterion.
let us assume without loss of generality that the testing subject is a collection c1 c nof classes where c1is the main class.
each class cide nes a setfci fci l ci of elds whose types are among c1 c n and primitive datatypes.
the scope characterizes nite sets of objects for each of the involved classes and nite rangesfor basic datatypes.
we often simplify the scope as a numberk typically referring to the number of node objects and de ne ranges for primitive types as a function of k. the set of possible structures or instances is composed of all possible assignments of values within the scope for elds of the scope s objects respecting the elds types.
we also assume that a predicate inv o de ned on instances of the main classc1 is provided.
this speci cation de nes the valid instances ofc1 and for a given scope k identi es a subset of the possible structures the valid structures.
given a valid instancecofc1 we say that cinvolves an objecto ifois reachable from cin the memory heap.
de nition .
letciandcjbe classes involved in a testing subject ka scope de nition and ci cjobjects of classes ci cj respectively within scope k. given a eld fof type cjin classci we say thathci cjiisfeasible forfwithin scopeki there exists a valid structure oofc1 i.e.
inv o holds that involves ci and such that ci f cj.
we refer to the set of all feasible tuples for eld fwithin scope kas the extension off for scopek .
as an example clarifying the above de nition let us consider again binary search trees with a scope of binary search tree object nodes size ranging within and keys ranging within .
assuming that invis in this case the representation invariant of binary search trees supplemented with symmetry breaking as previously described hn0 n1i is feasible for left within the scope the rst tree in fig.
witnesses this feasibility and fhn0 nulli hn0 n1i hn1 nulli hn1 n2i hn1 n3i hn2 nulli hn2 n3i hn3 nullig is the extension of eld left for the given scope.
notice how the breadth rst ordering on node identi ers imposed by symmetry breaking prevents pair hn0 n2ifrom being part of the extension of eld left.
de nition .
given a testing subject c1 c n a scope k and a set s fo1 o xgof objects of class c1within scopek we say that sachieves eld exhaustive coverage for scopeki for every feasible tuple hci cjiof every eld f there exists an object oinsthat involves object ciand such thatci f cj.
that is a set sof objects is said to achieve eld exhaustive coverage for a given scope i the extension of each eld if covered by s. two examples of eld exhaustive suites for the previously mentioned scope are the suite composed of objects in fig.
with respect to left and right keys are ignored and thebounded exhaustive suite for the same scope it contains allvalid instances therefore it satis es eld exhaustiveness .
although we do not do so in this paper quantitative variants of this criterion s satisfaction are straightforward to de ne.
for instance we may say that a suite ssatis es eld exhaustiveness by a n for a given scope kifn of the feasible tuples for scope kare covered by s. it is worth noticing that symmetry breaking plays an important role on the size of suites that achieve eld exhaustiveness.
for instance if symmetry breaking is disregarded we then need at least test inputs to achieve eld exhaustiveness for scope on binary search trees as opposed to the that su ce with symmetry breaking .
.
automated generation of fieldexhaustive suites we now turn our attention to automatically producing eld exhaustive suites.
while any mechanism capable of building bounded exhaustive suites achieves by de nition eld exhaustiveness our motivation is to avoid the large size of such suites and the associated limitations such sizes bring into the testing process.
therefore we aim at producingsmall eld exhaustive suites.
in this section we present a technique that in practice produces eld exhaustive test suites that are signi cantly smaller than bounded exhaustive suites for the same scope and randomly generated suites of similar quality coverage mutation score .
this technique is based on the use of incremental sat solving.
our procedure to compute eld exhaustive suites requires inv the speci cation of valid instances to be expressed in a language amenable to satis ability analysis in our case via sat solving.
while we use invariants expressed in alloy s relational logic other languages may be employed for instance invariants speci ed in jml can be automatically translated into sat as described in and operational invariants such as those used in korat can also be automatically translated into propositional formulas for a given scope following translations such as those embedded in tools like cbmc and dynalloy .
let us then assume that invis expressed as or can be translated into a propositional formula.
moreover let us further assume that invsubsumes a symmetry breaking predicate forcing canonical orderings of heap nodes in structures this is without any loss of generality since as described in such symmetry breaking predicates can be automatically built .
intuitively the propositional encoding of heap structures captures values for object elds through propositional variables.
that is given a eld f c!c0 an object aof class chaving value bof classc0ina fin a heap structure is characterized through the validity of a variable varf ha bi in a satisfying valuation of the propositional encoding of heap structures.
then in order to produce new test inputs that contribute to eld exhaustively covering fwe may feed the sat solver with a clause a c b c0 varf ha bi notice then that the satis ability of implies that there exista candb c0such that variable varf ha bi evaluates to true in a satisfying valuation or in other words such asa f bin a corresponding heap structure.
to guarantee that such structure indeed contributes to eld exhaustively covering f we need to ensure i that some satis ed varf ha bi corresponds to a pair ha binot yet covered and ii that varf ha bi indeed characterizes a feasible value for eld f in a valid heap structure of class c1 the main class of the testing subject .
the rst property can be guaranteed by keeping track of those pairs that have already been covered and restricting the above disjunction only to pairs not previously covered.
the second requirement is achieved by enforcing the validity of varf ha bi only in valid heap structures that involve aandb captured by formula varf ha bi o c1 inv o areachable fromo ha bi2f notice that since instances are bounded by the scope k reachability is expressible in propositional logic see for instance the translation of transitive and re exive transitive closure operators into propositional logic employed by the alloy analyzer tool .
formula states that variable varf ha bi encodes the feasibility ofha bias part of the extension of fin valid canonical structures.
thus by considering formula in case the satis ability verdict for a variable varf ha bi is true the returned valuation corresponds to a valid instance containing that tuple.
furthermore since the valuation encodes a valid instance we can retrieve for each eld fthe pairs of object identi ers infin that particular instance.
for example if we require var left hn0 n1i to hold the rst binary search tree in fig.
ful lls the requirement.
as a side e ect of selecting this instance we may conclude that besides pair hn0 n1i also pairhn2 n3ibelongs to the extension of eld left.
we use the above introduced variables to automatically produce eld exhaustive suites by incrementally calculating eld extensions within a provided scope and collecting the instances obtained in this process.
suppose that f1 f m is the sequence of all elds in the testing subject.
our algorithm to produce eld exhaustive suites will maintain partial extensions for elds f1 f min a vector whose i th position for i m stores a partial extension for fi.
in this way our algorithm works on a vector curr sets consisting ofmsets the current partial eld extensions for f1 f m .
the algorithm makes use of an incremental sat solver represented by a module solver with the following routines load receives as arguments a formula capturing the invariant and other constraints and a scopes de nition for the domains involved in the speci cation.
it generates a propositional formula in conjunctive normal form representing the satis ability of formula within the provided scopes and loads it into the solver.
addclause incrementally adds a clause to the current formula in the solver for future solving invocations.
solve calls the sat solving procedure which decides whether the formula currently loaded in the solver is satis able or not.
getinstance if the formula is satis able it retrieves a satisfying instance from the valuation produced by the sat solver.
finally vectors of partial eld extensions support a routine extend which receives as a parameter a heap instance algorithm field exhaustive suite computation algorithm function compute suite inv scopes solver new solver solver load inv scopes curr sets suite while true do solver addclause w j21 m ha bi2dom fj ncurr sets varfj ha bi !
ifsolver solve then curr sets extend solver getinstance suite add solver getinstance else break end if end while return suite end function and augments the current eld extensions with the eld tuples contributed by the provided instance that are not yet present in the current eld extensions .
our algorithm initializes curr sets as a vector of empty sets which are iteratively augmented according to heap instances computed via calls to the sat solver collecting the instances obtained in the process.
the execution terminates when curr sets cannot be augmented any further in which case as we will prove below the collected instances form a eld exhaustive suite.
pseudocode for the algorithm is shown in algorithm .
it takes as inputs the invariant of the testing subject assumed to include symmetry breaking predicates and the scopes for which the eld exhaustive suite is to be computed.
the algorithm begins by creating a solver and loading it with the invariant translated for the given scopes as a propositional formula lines .
it then initializes the partial eld extensions with empty sets for each of the heap elds line and the suite as the empty set line .
the while loop in lines augments the eld extensions while collecting instances until they cannot be further increased.
at this point the vector holds full eld extensions the suite achieves eld exhaustiveness and it is returned by the algorithm as its result line .
a crucial step in our algorithm is performed at line where the formula currently loaded into the sat solver is extended exploiting incremental sat solving with a progress ensuring constraint on heap eld extensions.
variable varfj ha bi in this line see formula denotes the propositional variable that after translation to a sat problem models the membership of pair ha bito eldfi.
the purpose of this constraint is then to ensure that instances returned by solver solve contain at least one pair that does not belong to the partial eld extensions already held in curr sets .
intuitively by adding the clause in line the call to solver solve in line can be interpreted as nd a valid instance of the structure that can be used to augment at least one of the current eld extensions in curr sets .
if such an instance exists curr sets is augmented line .
the extending clause at line is a crucial element in the design of our algorithm to compute eld exhaustive suites.
more precisely by encoding the new constraint as a clause we enable the possibility of using incremental sat solving a feature supported by many modern sat solvers including minisat the one we use in our experimental eval uation for eld exhaustive suite computation.
essentially incremental sat solvers allow one to append further constraints written in conjunctive normal form after each satisfying valuation is found.
these constraints are conjuncted to the main formula and used in computing the next satisfying instance incrementally from a currently computed one without having to restart the solving process and therefore exploiting already learnt clauses a critical part of sat solving based on con ict analysis and clause recording .
notice that if the new constraints are not in the right format the whole resulting formula has to be translated to conjunctive normal form and the sat process restarted from scratch.
the formula added in line is indeed a clause and thus it is written in conjunctive normal form allowing us to employ incremental sat solving.
theorem proves that our algorithm terminates and returns a eld exhaustive test suite.
theorem .algorithm terminates and returns a eld exhaustive suite.
proof.
termination easily follows from the following two facts i for given partial eld extensions of the testing subject whose sizes are limited by a scope the number of pairs that can be added to a eld s extension is nite and ii each while loop iteration either adds at least an extra pair to the partial eld extensions or otherwise returns unsat in which case the loop terminates.
to prove that the algorithm yields a eld exhaustive suite we must prove that the computed suite covers the extension of all the elds.
let us assume this is not the case and arrive to a contradiction.
assume algorithm terminates and there is a eld fand a pairha biin the extension of f that was not covered.
let us focus on the last iteration of the loop prior to termination of the algorithm.
since pair ha bi was not yet covered propositional variable varf ha bi must be one of the disjuncts in the clause fed to the solver in line .
since this is the last loop iteration the solver call in line must return an unsat verdict which contradicts the fact ha biis in the extension of eld f. the contradiction arises from assuming eld exhaustiveness was not achieved.
while our algorithm produces eld exhaustive suites that are signi cantly smaller than bounded exhaustive suites see the evaluation in section this algorithm does not necessarily compute minimal eld exhaustive suites.
as an example consider again the binary search tree case and the suite for scope in fig.
.
suppose that structures are produced in the order shown in the gure.
then the second and fourth structures do not contribute new tuples to the extensions of elds left and right if the remaining structures are included in the suite.
since we are concerned with producing small test suites this negative result stating that eld exhaustive suites computed by our algorithm may not be minimal needs to be further examined.
as we will prove in theorem eld exhaustive suites computed by our algorithm are bounded by the size of eld extensions.
theorem .let us consider a testing subject c1 c n. letf s i nffci fci l ci gbe the set of class elds in the testing subject.
given a scope k for eachf2flete f be the extension of eld fin scopek.
let e f be the number of pairs in e f .
then the size of the eld exhaustive test suite produced by algorithm is at mostp f2f e f .proof.
each iteration of the loop in lines covers at least one new pair in the extension of some eld f2f.
therefore in at mostp f2f e f iterations the loop must terminate.
since each iteration adds one new valid instance to the suite the size of the resulting eld exhaustive test suite must be at mostp f2f e f .
notice that for every eld f c!c0 its extension in scopekis a subset of the set of all binary tuples formed with objects of type cand objects values of type c0 in scopek.
since both these sets are bounded by k the extension offis bounded by k2 and therefore according to theorem eld exhaustive suites computed by computesuite can have at most f k2 for scopek.
.
evaluation in this section we perform an experimental assessment of eld exhaustive testing and the algorithm for automatically computing eld exhaustive suites.
all experiments were run on a workstation with intel core i5 processor 6mb cache .2ghz .
turbo and gb of ram.
the rst part of the evaluation compares eld exhaustive test generation with bounded exhaustive test generation and random test generation in various aspects such as size of suites generation and testing times as well as the quality of the obtained suites in terms of mutation score and branch coverage a mutant is considered killed if when run on an input violates the corresponding method postcondition which includes the structure s invariant .
we do so on a number of data structure implementations with increasingly complex invariants.
these are i an implementation of sorted singly linked lists taken from korat s benchmarks we test routines get addand remove ii an implementation of binary search trees we test routines add find andremove iii an implementation of red black trees we test routines add remove and contains and iv an implementation of binomial heaps we test routines extractmin delete and insert .
in these analyses we impose as a restriction a maximum of hour for generation time and hour for testing time and million structures for suite size.
notice that the million limit is on structures not inputs inputs are in most cases composed of the structure where the method is executed combined with the additional parameters received by the corresponding routine e.g.
find in binary search trees receives the key to be searched for .
since in tables we report inputs we have cases that exceed million although these are always built with at most million structures.
inputs corresponding to the additional method parameters are also generated using the corresponding approach i.e.
bounded exhaustively for bounded exhaustive testing experiments eld exhaustively for eld exhaustive testing experiments etc.
.
when generation or testing times are exceeded we mark so in the table with to timeout .
when the limit on the number of structures is exceeded we mark so in the table with il input limit .
the results comparing eld exhaustive fe testing with bounded exhaustive be testing are summarized in table .
the results for random testing are shown in a separate table table since random testing does not depend on a scope as the other two techniques.
in both tables size reports number of test cases test suite size .
generation and testing times are in seconds testing time is the sum of testing all routines for each case study .
mutation score and branch coveragereport the percentage of killed mutants and branches covered respectively again as a whole for all routines of each case study.
mutants were computed using mujava .
we used korat for bounded exhaustive suite generation and randoop for random test suite generation in these sets of experiments.
for the case of random testing we ran the tool setting a maximum number of test inputs column size in table three times for each limit with di erent seeds and report the maximum coverage mutation score obtained.
the second part of the evaluation measures the ability of our computed eld exhaustive suites in nding real bugs on the refactoring engine that ships with eclipse .
.
we compare with astgen a tool for testing programs manipulating abstract syntax trees that bounded exhaustively combines input parts produced by user written generators and quickcheck a tool for the generation of random suites in this case our testing subject does not admit the use of randoop since we do not have java classes capturing the generators .
we chose as case studies the astgen generators that produced fewer inputs and the astgen generators the produced more inputs among all cases in .
so we compare our approach with astgen and random testing on six di erent testing cases corresponding to three refactoring operations namely encapsulatefield pullupfield and pullupmethod .
since this comparison is black box we report only time for test generation and text execution in each of the approaches size of the corresponding suites and bugs found.
since astgen does not discriminate generation time from testing time we report these as a whole.
for running astgen we used the generators provided in .
for running quickcheck we translated astgen generators as grammars in haskell and used quickcheck on the resulting haskell programs to produce the inputs we produced randomly generated suites of various sizes covering the sizes of our eld exhaustive suites and of those produced with astgen .
for random testing for each size we generated suites and took the average testing time and maximum found bugs across runs.
in order to apply our eld exhaustive approach we manually wrote correspondingalloy speci cations that capture astgen generators and used these speci cations to produce eld exhaustive suites using incremental sat intuitively our alloy speci cations captured the elements of java programs as alloy signatures and their relationships e.g.
a eld belonging to a class as alloy elds .
table compares astgen our eld exhaustive approach and random testing.
the rst two produce xed numbers of tests basically the scopes in this case are established by the alternatives for basic program elements in astgen which are xed .
in the case of random testing we produced increasingly larger sets of tests until the maximum number of bugs were found known from the results in .
table also reports the sum of test generation and execution times test generation is negligible both in astgen and random testing so time in these cases are essentially just test execution and the number of bugs found in each case.
the latter are computed examining the refactorings outputs helped by astgen s oracles.
.
assessment our rst set of experiments evaluates various aspects at the same time.
first it measures how e ciently our algorithm can compute eld exhaustive suites on data structure case studies.
table shows that for the evaluatedtable bounded exhaustive vs eld exhaustive on data structures sorted singly linked list scope size gen. time test.
time mut.
score branch cov.
be fe be fe be fe be fe be fe .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
il il .
il .
il .
il .
.
.
.
.
.
.
.
.
to to to to to binary search tree scope size gen. time test.
time mut.
score branch cov.
be fe be fe be fe be fe be fe .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
to to .
to .
to .
to .
.
.
.
.
.
.
.
.
to to to to to treeset scope size gen. time test.
time mut.
score branch cov.
be fe be fe be fe be fe be fe .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
to to .
to .
to .
to .
.
.
.
.
.
.
.
.
.
.
.
to to to to to binomial heap scope size gen. time test.
time mut.
score branch cov.
be fe be fe be fe be fe be fe .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
il il .
il .
il .
il .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
to to to to to case studies eld exhaustive generation generally scales to more than twice the scope of bounded exhaustive generation measured as the maximum scope that can be covered within hour.
it is worth observing that the size ofour computed eld exhaustive suites grows linearly as the scope is increased as opposed to the known exponential growth of bounded exhaustive suites.
regarding the quality of the computed suites table show that for scopes thattable astgen vs random vs eld exhaustive astgen random field exhaustive refactor inputs time bugs found inputs time bugs found inputs time bugs found encapsulatefield.singleclassfieldref .
.
.
.
.
.
.
.
.
pullupmthd.tripleclassmethodchild .
.
.
.
encapsulatefld.doubleclassfieldref .
.
.
.
encapsulatefield.classarrayfield .
.
encapsulatefld.singleclasstwofields .
.
pullupfield.doubleclasschildfield .
.
table random testing on data structs.
sorted s. linked list size gen. time test.
time mut.
score branch cov.
.
.
.
.
binary search tree size gen. time test.
time mut.
score branch cov.
.
.
.
.
.
.
treeset size gen. time test.
time mut.
score branch cov.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
binomial heap size gen. time test.
time mut.
score branch cov.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
are reached both by eld exhaustive and bounded exhaustive suites the mutation score and branch coverage obtained are very similar with less that di erence from scope .
considering the largest produced suites in each case eldexhaustive suites generally outperform bounded exhaustive suites both in branch coverage and mutation score in a case in more that of its mutation score with signi cantly smaller suites and corresponding testing times.
regarding the comparison with random testing randoop produces suites very e ciently outperforming in test generation both the bounded exhaustive and eld exhaustive approaches.
however the sizes of test suites required to reach similar mutation scores and coverage as bounded exhaustive and eld exhaustive suites are in most cases signi cantly larger.
this can be observed in all cases except linked lists.
for instance it takes tests for randoop to achieve branch coverage for binomial heaps while eld exhaustive testing achieves the same coverage with tests.
the second part of the experiments concentrates on theability of eld exhaustive suites to catch real bugs.
we compared with astgen a tool particularly tailored to testing source code manipulating programs which has been used to nd real bugs in refactoring engines and quickcheck a random test input generation tool.
out of the bugs found by astgen with a total of test inputs our eld exhaustive approach was able to catch with a total of test inputs.
random testing on the other hand had to make the test set grow up to to catch the bugs.
it is however important to notice that random testing performed very well on most case studies it outperformed astgen in number of tests to catch all bugs.
still eld exhaustive testing showed in this case the best ratio in number of inputs per bugs found.
all the presented experiments can be reproduced following the instructions available in .
.
threats to validity our experimental evaluation is limited to data structures and a refactoring engine.
both are good representatives of data characterized by complex constraints which are challenging for automated testing techniques.
from the vast domain of data structures we have selected a few that we consider representative for several reasons because they are often used as case studies in the evaluation of other analysis tools and their invariants have varied complexity which is a dimension that a ects eld extensions size and thus also a ects the computation of eldexhaustive suites .
one might argue that restricting the analysis to these case studies might favor our results.
while an exhaustive evaluation of data with complex constraints is infeasible we identi ed that invariant complexity is a dimension that a ects eld extensions size and thus their computation and designed the experiments to take this problem into account.
we selected structures with a broad range of complexity going from those with simple invariants to some with rather complex constraints.
the selection of tools for comparison might have accidentally favored our techniques.
we selected korat based on the evaluation of several alternatives and the analysis in despite being older than other tools it is the most e cient choice for our data structure case studies.
also for this tool the implementation of imperative representation invariants a ects its e ciency.
we used the imperative invariants provided with the tool s examples which are tailored to korat sbounded exhaustive suites computation approach.
regarding our comparison with astgen and random testing on bug nding we manually produced representations ofastgen generators both for quickcheck and alloy to enable our eld exhaustive approach.
we did not formally verify the equivalence with the generators but we manually corroborated that the inputs produced by the three alternatives were consistent across tools to discard the possibility of improved e ciency due to errors in the translations.
also the selection of the six cases for refactoring was done taking into account the corresponding numbers of inputs generated byastgen and we included the three with fewer cases where astgen shows better ratio between tests and number of bugs catched.
more recent tools such as udita may be used instead of astgen .
however udita improves only test generation time not the tests produced which are the same as astgen s nor the test execution time thus udita would not produce noticeable improvements in our experiments.
in we provide some additional experiments using udita con rming this observation.
.
related work automated test case generation is currently a very active area of research and many tools and techniques have been developed in recent years.
among these approaches the most e ective and successful are either based on random generation evolutionary computation model checking constraint solving including smt and sat solving or some forms of exhaustive search .
test suites generated by tools based on random generation and evolutionary computation such as randoop autotest quickcheck and evosuite tend to generate large test sets which has as a consequence an increased testing time a problem we try to avoid with eld exhaustive testing.
our approach corresponds to systematic test generation in the terminology of which makes it closer to tools like pex fajita symbolic pathfinder and korat .
these tools are also speci cation based i.e.
they produce tests from input speci cations as opposed to tools like evosuite orrandoop that use routines methods of the testing subject to produce tests.
with respect to korat eld exhaustive testing is already extensively compared to bounded exhaustive testing in the paper in particular against this tool.
tools that produce small test sets generally driven by some testing criterion e.g.
pex fajita symbolic pathfinder usually concentrate on white box coverage as opposed to our automated testing approach.
in a set of experiments compare random testing and systematic testing for container classes arriving to the conclusion that random testing produces suites that are comparable in quality coverage mutation score to systematically produced suites using shape abstraction while consuming less computational resources less generation time .
we compared our approach with random testing in the rst set of examples against randoop because the testing subject admits such comparison and in the second case against quickcheck .
our results show that while we still consume more computation resources the produced suites are comparable in quality with those produced with random testing but achieve such quality with signi cantly fewer test cases.
incremental sat has been used by other tools in particular in fajita for automated test input generation and in for generating combinatorial interaction tests forproduct families.
other tools use sat smt solving as part of the test generation process.
testera uses incremental sat solving for exhaustive bounded generation of input data.
it is then very close to korat while korat shows better performance.
whispec builds on speci cation based testing and focuses on maximizing code coverage by iteratively running a conjunction of method preconditions and path conditions.
pexuses smt solving to produce minimal suites maximizing branch coverage.
in our approach computing eld exhaustive suites produces eld extensions.
these extensions are equivalent to upper tight eld bounds and thus our work is related to approaches to compute such bounds e.g.
.
however none of these related approaches focuses on test generation does not collect instances in the tight bound computation process and even if it did so it would be signi cantly more ine cient than our approach since it requires a cluster for tight bound computation follow a bounded exhaustive enumeration of instances to compute tight bounds as opposed to our eld exhaustive mechanism.
.
conclusion and future work thanks to advances in automated testing technologies new testing criteria infeasible in manual testing contexts are now emerging.
among the many tools that produce test suites automatically from code some produce large suites that make their use di cult in settings that demand repetitive use like regression testing while others produce small suites typically driven by traditional most often white box testing criteria.
we proposed a new black box testing criterion that we called eld exhaustive testing whose satisfaction is associated with the coverage of feasible values for object elds.
in e ect the criterion requires a bound or scope to be provided so the space of valid object instances is nite and limited and demands enough inputs to be produced so that every feasible value for every eld is covered.
besides formally de ning the criterion we developed an algorithm that automatically produces eld exhaustive suites and showed that suites can be generated e ciently are composed of relatively small numbers of tests and are of very good quality measured in terms of mutation score and branch coverage.
moreover the produced suites are comparable in coverage and mutation score to suites produced using bounded exhaustive testing and random testing tools with signi cantly fewer tests.
our testing criterion and test generation algorithm lead to various new research problems that we plan to study.
the test generation algorithm produces eld extensions which correspond to tight bounds and can be used to improve sat based analysis.
while in this paper we concentrated in testing this algorithm can be used to compute tight eld bounds and exploit these for other analyses.
we plan to study this further in the future.
also while in this paper we produced eld exhaustive suites for all elds in the corresponding testing subjects one may select an appropriate subset of elds and generate eld exhaustive suites just for this set.
the right set of elds to select will generally depend on characteristics of the testing subject and the kind of bugs one is searching for.
for instance choosing only reference elds in heap allocated data structures would imply concentrating on structures shapes not the data and thus would target bugs related to re linking structures objects.
.