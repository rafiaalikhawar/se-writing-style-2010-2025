nofaq synthesizing command repairs from examples loris d antoni university of wisconsin madison loris cs.wisc.edurishabh singh microsoft research risin microsoft.commichael vaughn university of wisconsin madison vaughn cs.wisc.edu abstract command line tools are confusing and hard to use for novice programmers due to their cryptic error messages and lack of documentation.
novice users often resort to online help forums for finding corrections to their buggy commands but have a hard time in searching precisely for posts that are relevant to their problem and then applying the suggested solutions to their buggy command.
we present a tool n ofaq that uses a set of rules to suggest possible fixes when users write buggy commands that trigger commonly occurring errors.
the rules are expressed in a language called f ixit and each rule pattern matches against the user s buggy command and the corresponding error message and uses these inputs to produce a possible fixed command.
our main contribution is an algorithm based on lazy vsa for synthesizing f ixit rules from examples of buggy and repaired commands.
the algorithm allows users to add new rules in n ofaq without having to manually encode them.
we present the evaluation of n ofaq on benchmark problems and show that n ofaq is able to instantly synthesize rules for benchmark problems in real time using just to input output examples for each rule.
.
introduction command line interfaces cli let users interact with a computing system by writing sequences of commands.
clis are especially popular amongst advanced computer users who use them to perform small routine tasks such as committing a file to a repository with version control installing software packages compiling source code finding and searching for files etc.
even though this mode of interaction is getting replaced by more natural graphical user interfaces clis are still routinely used for most scripting tasks in unix and mac os.
even the windows operating system now officially provides complex command line interfaces with products such as windows powershell.
since command line interactions often require complex parameters and flag settings for specifying the desired intent non expert users find clis challenging to use .
moreover after entering an incorrect input command the user has to deal with cryptic errors that are hard to decipher by just looking at the verbose text based documentation of the commands.
for these reasons users typically resort to online help forums for finding corrections to their buggy commands.
unfortunately this can also be problematic as users need to precisely search for posts that relate to the issues with their commands and then transform the suggested solutions to apply them in their context.
sometimes users also need to create a new post if no relevant post exists or can be found and then need to wait for hours or days to obtain a solution to their problem.
what about common errors?
recently a tool t hefxxx1was developed for automatically addressing common errors when work1we decided to censor the name of the tool.
the tool can be found at .ing with a cli.
if after typing a command a user receives an error message t hefxxx uses a set of hard coded rules to suggest possible fixes to the user s command.
each rule pattern matches against the input command and the error message and uses these inputs to produce a possible fixed command.
typical fixes include adding missing flags creating a missing directory or changing file extensions.
t hefxxx has become extremely popular and on github it has already been starred by more than users and has been forked more than times.
despite its success the tool also has a main limitation to add a new rule a developer first needs to understand the syntax and precise semantics of t hefxxx and then manually hard code the rule into the tool.
due to this complexity newly added rules have at times caused non terminating or unexpected behaviors2.
synthesizing repairs from examples inspired by the success and limitations of t hefxxx we built n ofaq no more frequently asked questions a tool for automatically addressing common errors in clis.
n ofaq also uses a set of rules for fixing common errors but it differs from t hefxxx in the following key aspects .
rules are encoded in a declarative domain specific language dsl called f ixit.
.
to add new rules users only provide examples of buggy and repaired commands and n ofaq automatically synthesizes the desired f ixit rules that are consistent with the given examples.
we envision n ofaq system being used by non developers and end users who can easily extend the system by providing new examples of fixes.
the long term goal of the system is to learn from examples obtained from shell histories of thousands of users in an unsupervised manner.
although a developer can write similar rules in a system like t hefxxx manually there are two main challenges with so.
first it is not feasible to easily add thousands of rules as end users generally do not have contributor access to thefxxx s source code.
second even for developers writing correct rules is difficult and error prone because of the complexity of the string manipulations needed to perform the command fixes.
in fact t hefxxx only consists of less than rules in a little over year since adding new ones is a fairly complex task.
the f ixit dsl for encoding fix rules is inspired by the types of rules appearing in t hefxxx and by common command repairs requested by users on help forums.
a f ixit rule first uses pattern matching and unification to match the command and error message and then applies a fix transformation if the match succeeds.
the transformations consist of substring and append functions on strings present in the command and error message.
we present an algorithm that efficiently synthesizes f ixit rules that are consistent with a given set of input output examples using a version space algebra vsa .
vsa based synthesis techniques are used to succinctly represent the set of all expressions that are and .
14arxiv .08219v1 aug 2016consistent with a set of examples .
even though existing vsa data structures can represent an exponential number of f ixit rules in polynomial space this space can still be quite large.
to address this problem we introduce lazy version space algebra .
given a set of examples our algorithm maintains a lazy representation of only a subset of the f ixit rules that are consistent with the examples.
the rules missing from the version space are only enumerated when necessary i.e.
when a new input output example can only be accounted by adding a f ixit rule that is not already present in the version space.
because of the careful design of f ixit our synthesis algorithm has a polynomial time complexity.
in contrast existing vsa based synthesis techniques for string transformations require exponential time .
the polynomial time complexity is crucial for our synthesis algorithm to scale to a large number of fix examples.
since different examples may refer to different target rules we propose a strategy to partition the input examples into groups of examples corresponding to individual rules.
we then use the lazy vsa algorithm to learn the f ixit rules for each partition.
we evaluate the synthesis algorithm implemented in n ofaq on benchmark problems obtained from both t hefxxx and online help forums .
n ofaq is able to learn the repair rules for of the buggy commands in these benchmark problems from only to input output examples each.
contributions summary .
f ixit a declarative domain specific language for encoding rules that map a command and an error message to possible fixed commands .
.
a sound and complete polynomial time synthesis algorithm based on lazy version space algebra for synthesizing f ixit rules from input output examples .
.
an analysis of the formal properties of the f ixit language and its synthesis algorithm .
.
a qualitative and quantitative evaluation of the synthesis algorithm on benchmarks obtained from both t hefxxx and online help forums .
.
.
motivating examples we first present the main ideas behind n ofaq using some concrete examples.
all the example rules presented in this section are actual rules appearing in t hefxxx system.
.
adding missing file extension java programmers in particular novice ones are likely to encounter this error when they accidentally pass a class name instead of a source code file to the javac compiler.
cmd1 javac employee err1 class names employee are only accepted if annotation processing is explicitly requested often this error is provided by the javac compiler when it is invoked on a file that does not have the proper .java extension.
a seasoned programmer would immediately recognize the problem and add the extension .java at the end of the input file.
fix1 javac employee.java on the other hand a novice programmer will search the web in the hope of finding a way to address the error and understand how to apply it to their setting.
the goal of n ofaq is to automatically synthesize simple fixes like this one from examples provided by experienced users and use the synthesized fixes to help novice userswho encounter similar errors.
for example let s say that a skilled developer provides another triple of the following form.
cmd2 javac pair err2 class names pair are only accepted if annotation processing is explicitly requested fix2 javac pair.java using these two examples n ofaq will synthesize the following fix rule.
match and str class str names v ar match str are str only str accepted str if str annotation str processing str is str explicitly str requested !
the first part of the rule i.e.
up to the symbol !
pattern matches against the command and the error message and binds the input strings to the corresponding variables.
the variables are then used by the second part of the rule to produce the output.
in this case the sub lr .java var expression extracts the complete string associated with v ar a start index of 0and an end index of0denotes the identity string extraction and then prepends the string at the beginning of it and appends the string .java at the end of it.
.
extracting substrings the following scenario is another common one for novice java programmers.
cmd1 java run.java err1 could not find or load main class run.java fix1 java run given this example and another similar one n ofaq synthesizes the following rule.
match and str could str not str find str or str load str main str class var match .java !
this rule extracts the substring of the input file name starting at index 0and ending at the index 5thindex from the end of the string in order to remove the .java extension.
.
extracting complex substrings a user was trying to move a picture from one location to another but got the following error message.
cmd1 mv photo.jpg mary summer12.jpg err1 can t rename photo.jpg no such file or directory fix1 mkdir mary mv photo.jpg mary summer12.jpg the error is cryptic for novice command line users and does not guide them towards the actual problem of the missing directory.
given this example and another similar one n ofaq synthesizes the following rule.
14match str mv v ar match var match and str can t str rename v ar match str no str such str file str or str directory !
fstr mkdir sub lr cpos var fstr mv sub lr var sub lr var the second expression in the output extracts the directory name i.e.
the substring that starts at index and ends at the index of first occurrence of the character .
the rule also adds a string at the end of the extracted string to pipe the two output commands.
.
the command repair language f ixit we now describe f ixit a domain specific language for expressing repair rules.
the syntax and semantics of f ixit is presented in figure and figure respectively.
the language f ixit is designed to be expressive enough to capture most of the rules we found in thefxxx and in online help forums but at the same time concise enough to enable efficient learning from examples.
general structure each f ixit program is a rule of the form matchcmd anderr!fix that takes as input a command scmd and an error serrand either produces a fixed command or the undefined value ?.
the inputs scmd and serrare lists of strings that are obtained by extracting all the space separated strings appearing in the input command and error message respectively.
the output fix produced by the rule is also a list of strings.
from now on we assume that the inputs and outputs are lists of strings that do not contain space characters.
a rule has three components.
.
a list of match expressions cmd used to pattern match against the input command scmd.
.
a list of match expressions err used to pattern match against the input error message serr.
.
a list of fix expressions fix used to produce the new fixed command.
match expressions a match expression mis either of the form str s denoting a constant string sor of the form var match i l r .
a v ar match i l r expression denotes a variable index iand requires the matched string to start with the prefixland end with the suffix r. we assume that no two variable expressions appearing in the match expression have the same index.
when a list of match expressions is applied to a list of strings s with the same length l it generates a partial function n7!
that assigns variables appearing in the match expressions to the corresponding strings in the input.
for example evaluating on the list of strings produces the function such that a.jpg and a.jpg .
on the other hand evaluating it on yields?
asa.png does not match the required suffix in v ar match .jpg .
fix expressions a fix expression fis either of the form f str s denoting the constant output string s or of the form sub lr pl pr l r var i denoting a function that is applied to the string simatched by the variable v ar i .
this function outputs the string l m r where denotes the string concatenation operator and m substr s jl jr wherejlandjrare thefix rule r matchcmd anderr!fix input cmd cmd input error err output cmd fix match expr m str s jvar match i l r fix expr f fstr s jsub lr pl pr l r var i pos expr p ipos k jcpos c k variables and constants s sl sr string i k integer c character figure syntax of the rule description language f ixit.
indices resulting from respectively evaluating the position expressionsplandpron the string s. here given a string s a0 an the expression substr s jl jr denotes the string ajl ajr ifjl jr n and the undefined value ?otherwise.
notice that unlike previous vsa based languages f ixit does not allow binary recursive concatenation this is one of the key features that enables polynomial time synthesis.
positions expressions a position expression pcan be one of the following types of expressions.
a constant position expression i pos k which denotes the indexkifkis positive and the index jsj kifkis negative.
if k this expression evaluates to 0when evaluated for pl i.e.
the starting index of the substring and to jsjwhen evaluated forpr wherejsjdenotes the length of the string s. for example in the function s ub lr ipos ipos var where file the first constant position evaluates to the index while the second constant position evaluates to the indexjfilej .
a symbolic position expression c pos c k which denotes the result of applying an offset to the index of the k th occurrence of the character cinsifkis positive and the result of applying an offset to the index of the k th to last occurrence of the character cinsifkis negative.
for example given the string the expression c pos .
denotes the index two positions before the first dot while the expression c pos .
denotes the index two positions after the last dot .
this operator is novel and can express operations that are not supported by previous vsa based work.
in particular flashfill only allows the extraction of the exact position of a character and not positions in its proximity.
despite this additional capability f ixit programs can be synthesized in polynomial time.
comparison with flashfill dsl at the top level f ixit consists of match expressions over original command and error message which perform pattern matching and unification of variables with strings.
this form of matching and unification is not expressible in flashfill so we cannot use it to learn the fix rules directly.
however we can use flashfill as a subroutine to learn string transformations corresponding to expressions similar to s ub lrexpressions in n ofaq.
however the flashfill dsl has two major limitations no support for offsets from regular expression matches in computing position expressions in contrast to f ixit s c pos c k operator and a finite hard coded token set for regular expressions e.g.
no support for constant character tokens .
moreover as described in subsection .
and section our s ub lroperator yields a synthesis algorithm that operates in polynomial time in the 14jmatchcmd anderr!fixk scmd serr jfixk unify cmd scmd unify err serr ?
?
otherwise unify s j lmatch expr mj sj match expr str s1 s2 0ifs1 s2and 0is the always undefined function ?
otherwise match expr var match i l r s if9 s.t.s l rand i sand is undefined on every j6 i ?otherwise j k jfstr s kfun s jsub lr pl pr l r var i kfun l m r if i s andm substr s jplkpos s l jprkpos s r jipos k kpos s d k k jsj k k 0k d l jsjk d rjcpos c k kpos s d i k 0andi indices s c andjij k i k 0andi indices s c andjij k l jij ?
otherwise indices s c where80 l j il il s cand8j s c!
l j il j figure the semantics of the command repair dsl f ixit.
number of examples which enables the algorithm to scale to a large number of examples.
because of the recursive binary concatenate expressions in flashfill the dag intersection based synthesis algorithm is exponential in the number of examples.
.
synthesizing rules from examples in this section we first describe our algorithm for synthesizing a single f ixit rule from a set of examples of concrete command fixes.
we then describe a multi stage partitioning algorithm for learning multiple f ixit programs from a large undifferentiated set of command repair examples.
the algorithm for learning a single f ixit rule is described in figure it takes as input a list of examples e where each example eiis a triple of the form scmd serr sfix and outputs a symbolically represented set of f ixit rulesr consistent with e i.e.
for every rule r2rand example ei scmd serr sfix the ruleroutputs sfixon the input scmd serr .
the algorithm processes one input example at a time and after processing the first iexamplesei the algorithm has computed a set of rules riconsistent with ei.
at the end the algorithm outputs one of the rules in rn.
we use?to denote the undefined result.
if at any point our algorithm returns ?it means that there is no f ixit rule that is consistent with the given set of examples.
.
symbolic representation of multiple rules since there can be exponentially many rules consistent with the input examples we adopt a symbolic representation of the set r that is guaranteed to always have polynomial size.
our synthesis algorithm takes as input a list of examples eand produces as output a symbolic rule of the form matchcmd anderr!sfixes wherecmd anderrare tuples of expressions that can consist of either constants or variables and fixes is a list of expressions that symbolically represents a set of outputs that is consistent with the examples e. formally each fiinfixes is either a constant expression f str s for somes or a set ofsubstring expressions fsu1 sukg where each suiis of the form s ub lr pl pr l r var j .
intuitively if we replace each set with one of the fix expressions it contains we obtain a f ixit rule.
if each ficontainskelements this symbolic representation modelsknprograms using an expression of size kn.
.
lazy rule representation the core element of our algorithm is a lazy representation of the rules that represents match and fix expressions as constants for as long as possible i.e.
until a new example shows that some parts of the rule cannot be constants.
this helps reduce the number of variable expressions which in turn reduces the number of substring expressions to be considered.
we first illustrate the idea with a concrete example.
let s say that we are given the two examples shown in figure 3a and 4a.
after processing the first example our algorithm synthesizes the f ixit rule in figure 5a in which every match expression and every fix expression is a constant.
however since we have only seen one example we do not yet know whether some expression appearing in the match should actually be a variable match expression or whether some element in the fix expression should actually be a function of some variable.
the main idea is that any of these possibilities can still be recovered when a new example shows that indeed a variable is needed.
using this idea we maintain each expression as a constant until a new example shows that some expression cannot actually be a constant.
this is exactly what happens when processing the input example in figure 4a.
at this point in order to find a rule that is consistent with both examples we need to introduce a variable match as the second expression of the command match and some function application as the second element of the fix.
to do so our algorithm applies the following operations to the previously computed rule.
.
all match expressions that cannot be constants are promoted to variable match expressions making sure that all variable names are unique which match on the longest shared prefix and suffix of all previously seen values at that position.
the following table illustrates the idea for the case in which we try 14cmd1 java run.java err1 could not find or load main class run.java fix1 java run a first example.cmd2 java meta.java err2 could not find or load main class meta.java fix2 java meta a second example.
match and str could str not str find str or str load str main str class str run.java !s a symbolic rule representation synthesized after first example.match and str could str not str find str or str load str main str class v ar match .java !s fstr java sub lr ipos ipos var sub lr ipos cpos .
var sub lr ipos cpos .
var a symbolic rule representation synthesized after both examples.
figure two input examples e1ande2and symbolic rules synthesized after processing e1ande2.
to unify the command cmd2 in figure 4a with the matching part of the already computed rule in figure 5a.
rule s tr java s tr run.java new ex java meta.java new rule s tr java v ar match .java .
all the fix expressions that cannot be constants are promoted to s ub lr expressions that are consistent with the current examples and are allowed to use the variables appearing in the match expressions.
the second rule in figure d reflects this update.
the figure also shows how multiple s ub lrexpressions are represented symbolically as a set.
we describe all of these components in detail in the next section.
.
synthesis algorithm given a list of input examples the function s ynth rules uses the first example and the function c onst rule to generate the symbolic rule composed only of constant operators.
it then iteratively refines the rule on the remaining examples as shown in figure .
this second operation is done by the function r efine rule which takes as input a symbolic rule r one new example scmd serr sfix and the list of examples eon which every concrete rule represented by rbehaves correctly.
r efine rule executes two main steps using the following functions.
findvariables tries to unify the inputs scmdand serrwith the corresponding match expressions cmd anderrin the symbolic rule rand generates new variable match expressions if necessary i.e.
whenrcontains a matching expression s tr s but the corresponding component in the example is a string different from s. in this case a v ar match i l r expression is generated such that iis a new variable name and landrare the longest prefix and suffix shared bys respectively.
when f indvariables is presented with a new scmd or serrafter a constant match expression has been promoted to a var match i l r expression the prefix and suffix are updated accordingly.
f indvariables determines the longest prefix r0and suffixl0oflandr respectively that is consistent with the appropriate component of the new example and generates var match i l0 r0 .
synth fix uses the variables computed in the previous step to synthesize all possible fix expressions that are consistent with the list of examplesf scmd serr sfix g e. in order to simplify variable naming and guarantee unique names each variable has the index of the corresponding element inthe input i.e.
v ar i denotes thei th string in the list scmd serr obtained by concatenating the command and error input lists.
lazy pattern matching the function f indvariables given a rulerand a new example e iterates over the input components of the new example eand outputs the set of variables necessary to match this new example with respect to the previously computed symbolic rule r. the function s ynth fix given a rule rand a list of examples e individually synthesizes all the components fi of the symbolic output fix expression that are consistent with e. synth fixis incremental in the sense that it tries to minimally change the original fix expression of r if thei th component tiof the fix expression of ris a constant string consistent with the new example then it is left unchanged in any other case the output has to be a substring operation and the function s ynth substrings is used to compute all the possible s ub lrexpressions that are consistent with the set of examples e. given a list of examples e e the function s ynth substrings first synthesizes all the s ub lrexpressions that are consistent with eusing the function a llsubstrings and then runs each synthesized expression on examples in eto remove the inconsistent ones.
allsubstrings figure omits the formal definition of the function a llsubstrings due to space limitations but we describe its main components.
given an example e scmd serr sfix a set of variable names v and the index i corresponding to the element of the output sequence we are trying to synthesize a llsubstrings computes the set of all substring expressions of the form fun sub lr pl pr l r var j that are consistent with esuch that the result of applying fun to the j th string in scmd serris thei th string in sfix.
let s assume thatj scmdj j serrj ni j sfixj no andnlis the length of the longest string appearing in any of the three lists in the input example.
to compute the set a llsubstrings e v i we iterate over all variable indices and for each variable index j2vwe do the following.
.
extract the string sjcorresponding to the variable v ar j o ni iterations.
.
for each string sthat is a substring of both sfix and sj compute all possible pairs of indices k1 k2such that substr sj k1 k2 s o n2 k possible substrings and o nk possible ways to place the substring in sfix .
rules consistent with input examples funsynth rules r const rule e0 for1 i ndo .refine on each example ei r refine rule r ei returnr constant rule consistent with one example funconst rule sc sc n se se m sf sf l cstcmd str sc str sc n csterr str se str se m cstfix fstr sf fstr sf l return matchcstcmdandcsterr!scstfix refines a rule to make it consistent with one more example funrefine rule r e scmd serr sfix r matchcmd anderr!sfixes cmd0 vc findvariables scmd cmd err0 ve findvariables serr err j scmdj v vc ve e0 scmd serr sfix e fixes0 synth fix sfix fixes e0 v return matchcmd0anderr0!sfixes0 finds variables necessary to match example funfindvariables o ifn6 mthen .input length same as match length?
return?
m v for1 i ndo caseti str s s si m v m str si v caseti str s s6 si pref longest common prefix s si suf longest common suffix s si newid i o .
create new variable m m v v fnewidg caseti var match j l r pref longest common prefix s l suf longest common suffix s r m m v v fjg return m v outputs the fixes consistent with all the examples eand such that s ub lrexpressions can depend on any variable in v. the fix component of the latest example and the fixes computed on the previous examples are also passed as input funsynth fix e e v ifn6 mthen return?
f for1 i ndo ifti fstr s s sithen f f else f f returnf outputs all s ub lrexpressions consistent with all the examples that can appear at position iin the fix expression funsynth substrings e e v i f allsubstrings e v i for all scmd serr sfix 2edo f0 for allfun2fdo letsub lr pl pr l r var j fun o j scmdj ifj o then .the variable is in scmd ifeval fun scmd sfix then f0 fun f0 else .the variable is in serr ifeval fun serr sfix then f0 fun f0 f f0 returnf outputs all s ub lrexpressions consistent with one example that can appear at position iin the fix expression funallsubstrings scmd serr sfix v i return all s ub lr pl pr l r var j that when evaluated on scmdand serroutput sfix and such that j2v.
figure algorithm for synthesizing f ixit rules from concrete examples.
.
for each k1 resp.k2 compute every position expression p1 resp.p2 such that evaluating p1 resp.p2 onsjproduces the indexk1 resp.k2 o nk possible positions.
.
for each of these possibilities yield the expression sub lr p1 p2 l r var j wherelandrare such that sfix l substr sj k1 k2 r. allsubstrings produces a set of expressions that in the worst case has size o nin5 k .
if we restrict the offset component to only range over the values f 1gfor the symbolic expressions 3note that the efficiency of this implementation is contingent on our specific choice of data structure and algorithms.
a more naive solution based on set intersection like that of the dag based algorithm in flashfill may experience exponential blow up in the number of examples due to the quadratic nature of the intersection operations.cpos c i the size reduces to o nin3 k and the synthesis algorithm is still sound and complete for this fragment of f ixit.
this last restriction of the language can capture all the rules we are interested in.
notice that this analysis still holds in the extreme case in which all input matches are variable expressions of the form var match i .
in our experiments on real world commands worst case performance is uncommon and is induced by substring operations over heterogeneous strings which yield many possible implementations.
consider the following two examples.
cmd1 aaaa aaaa cmd2 bbbb bbbb err1 aaaa aaaa err2 bbbb bbbb fix1 aa fix1 bb performing synthesis on this pair of examples yields a pattern match consisting of four v ar match i expressions.
due to the uniformity of the input strings synthesis yields 48possible 14sub lrexpressions.
in particular the desired fix can be generated from any of the four strings in the supplied scmd andserr.
each of the four strings has three substrings of length any of which yields the desired output.
for each such substring there are four pairs of i pos values that supply the appropriate indices the pair with two positive indices the pair with two negative indices and the two pairs consisting of one positive and one negative index.
key point at this point we are ready to explain why all the match expressions can be kept as constants for as long as possible.
if after processing a set of examples e some expression in cmd or err is of the form s tr si then for every input example the value of the i th component is the string si.
therefore even if we replace this expression with a variable all its instantiations will have the same values.
consequently every function of the form s ub lr p1 p2 l r var i will produce a constant output making it equivalent to the some constant function f str s0 .
.
partition based synthesis fixit can learn repair rules from a set of examples corresponding to a specific incorrect use of a command.
in practice however it may be difficult to present f ixit with a collection of neatly curated sets of examples from each of which f ixit learns a single symbolic rule.
such a process is both labor intensive and error prone.
we instead envision large scale learning of f ixit rules from undifferentiated sets of examples submitted by many users.
to facilitate this we propose a simple multi stage partitioning strategy.
as a consequence of f ixit s structure each symbolic rule matches on a pair of command and error strings each of which has a fixed number of tokens.
upon a match f ixit generates a repaired command with a fixed number of tokens.
conversely every symbolic f ixit expression must be learned from a set seof example triples of the form scmd serr sfix for which the lengths ofscmd serr andsfixdo not vary.
given an undifferentiated set of examples se we partition seintondisjoint subsets iwherese sn i i. for every ithe property8 scmd serr sfix i scmd serr sfix i jscmdj j scmdj jserrj j serrj jsfixj j sfixj.
this dividesseinto subsets from which it is possible to synthesize fixit rules.
after dividing se it may still be the case that individual sets i contain examples representing distinct command repair rules which share the same triple of scmd serr andsfixlengths.
at this point we attempt to find the smallest set of rules that can be synthesized from the examples in i. the search ranges over all partitions pof i wherepis the setf i i i mgsuch thatsm j i j iand8j6 k i j i k ?.
we enumerate the partitions in ascending order of size m starting with p f ig and ending with the partition consisting entirely of singleton sets.
given a partition p we attempt to synthesize a symbolic f ixit rule for each set in p stopping when we have generated a rule for each i j. as we will show in section .
this expensive procedure is only feasible when using our novel contribution of lazy vsa.
example partitioning consider the example set shown in figure .
the first two examples in this set correspond to the repair in section .
while the last two correspond to the repair in section .
.
the third and fourth example correspond to the rule that outputs composer followed by the token at index 8in the input i.e.
the first token suggested by the error message .
we first group the examples based on the length of their components.
for the first four examples we have jscmdj jserrj jsfixj and for the two remaining examples jscmdj jserrj jsfixj .
thus we obtain two groups s1 fe1 e2 e3 e4gands2 fe5 e6g.cmd1 java run.java e1err1 could not find or load main class run.java fix1 java run cmd2 java test.java e2err2 could not find or load main class test.java fix2 java test cmd3 composer pkg e3err3 did you mean one of these?
pkg1 pkg2 fix3 composer pkg1 cmd4 composer hptt e4err4 did you mean one of these?
http html fix4 composer http cmd5 mv photo.jpg mary summer12.jpg e5err5 can t rename photo.jpg no such file or directory fix5 mkdir mary mv photo.jpg mary summer12.jpg cmd6 mv dec31.jpg bob family.jpg e6err6 can t rename dec31.jpg no such file or directory fix6 mkdir bob mv dec31.jpg bob family.jpg figure examples requiring more than one f ixit rule.
while there exists a f ixit program that is consistent with the examples in the set s2 no f ixit program can describe a transformation that is consistent with all the examples in s1.
we therefore proceed by iteratively partitioning the set si attempting to find a partition pifor which we can synthesize a rule for every si j2pi.
fors2 we can clearly do so for the initial partition p2 fs2g yielding the rule from section .
.
for s1 the first partition for which we can generate a f ixit rule for every element is p1 fs1 fe1 e2g s1 fe3 e4gg.s1yields the rule from section .
and s2yields the simple substitution rule described previously.
.
more succinct representation the version of symbolic rule we presented is already able to store exponentially many concrete f ixit rules in polynomial space.
in this section we discuss further improvements that can make the representation more succinct.
avoid redundancy in the set of fix expressions enumerated by the function a llsubstrings the last three components of the the expression s ub lr p1 p2 l r var j are often repeated many times.
looking at figure 6a we can see how all the synthesized functions have l r and are applied to the variable v ar .
we define a data structure for representing sets of fix expressions that avoids these repetitions.
a set of fix expressions is represented symbolically using a partial function d n7!
!set p p wherepis the set of all position expressions.
formally given a variable index iand two strings landr the setd i l r symbolically represents the set of fix expressions fsub lr p1 p2 l r var i j p1 p2 2d i l r g. the functiondcan be efficiently implemented and avoids redundancy.
considering again the example rule in figure 6a all the fix expressions in the second component of the output can be succinctly represented by the function dthat is only defined on the input and such that d f ipos ipos ipos cpos .
ipos cpos .
g avoid example representation each synthesized rule is in some sense coupled to the set of examples used to synthesize it.
we present a data structure that only keeps track of the important parts of the input examples and therefore allows us to discard each example after it has been processed.
we modify the symbolic rule representation as follows.
given a set of examples s1 cmd s1 err s1 fix sn cmd sn err sn fix every variable v ar match i l r in the match component becomes a pair var match i l r where the second component is the list of strings that binds to v ar i in the input components of the examples i.e.
bj sj cmd sj err every set of fix expressions represented by a function diand corresponding to the i th component of the fix expression becomes a pair di where the second component is the list of strings that appear in position iin the output components of the examples i.e.
bj sj fix using this data structure we do not need to store examples as we can always re infer them from the symbolic rule representation.
.
concrete outputs taking into account the updated data structures the algorithm synth rules returns a symbolic rule rof the form matchcmd anderr!sfixes wherecmd anderr are lists of expressions of the form s tr s or var i b whilefixes is a list of expressions of the form f str s or d b wheredis the data structure for representing multiple fix expressions.
the set of concrete f ixit rules induced by this symbolic representation is the following.
con matchcmd anderr!sfix fmatchcmd anderr!fjf2con fix g con f f0 f0 l jf0 i2con fi g con fstr s ffstr s g con d b fsub lr p1 p2 l r var i j 9i l r p1 p2 2d i l r g .
formal properties we study the formal properties of the synthesis algorithm and of the language f ixit.
these specific properties describe the behavior of the synthesis algorithm in the absence of the partitioning strategy described in section .
.
properties of the synthesis algorithm first our synthesis algorithm is invariant with respect to the order in which the training examples are presented.
thus the properties of a symbolic rule generated by s ynth rules can be discussed solely in terms of thesetof examples provided to s ynth rules .
theorem order invariance .given a list of examples e for every permutation of examples e0ofe we have con synthrules e con synthrules e0 .
proof sketch.
consider a list of examples e. if two examples differ at theith position in their respective commands the ith expression incmd will be promoted to a v ar match regardless of the order in which they are presented to s ynth rules .
moreover if all jejstrings at the ith position in the commands share a prefix or suffix reordering edoes not change this fact.
thus the discovered var match expressions will not vary based on order.
the same holds forerrand the promotion of constants in s ynth fix.
moreover s ynth substring starts from scratch at each iteration of the loop in s ynth rules andfix depends only on the output of s ynth fixin the final iteration.
since the variable set does not vary based on the ordering of e the final invocation of synth fixdoes not depend on the ordering of e. second the synthesis algorithm produces only rules that are consistent with the input examples.
if we select an arbitrary concrete rulerfrom the set specified by a symbolic rule generated bysynth rules and run it on the command and error of any of the examples provided to s ynth rules for the synthesis of r we will obtain the fix originally provided in that example.
theorem soundness .given a list of examples e for every rule r2 con synthrules e and for every example scmd serr sfix 2e jrk scmd serr sfix.
proof sketch.
the repeated applications of f indvariables will promote any s tr s expression if a new example does not match ons.
moreover when refining a v ar match findvariables chooses the longest prefix and suffix consistent with all examples seen so far.
thus cmd anderrwill correctly match on all examples.
the soundness of the resulting fixderives from the fact that at each iteration of the loop in s ynth rules the invocation of synth substring in s ynth fixtakes into account all examples seen in previous iterations of the loop.
moreover each invocation begins with the set of all possible s ub lrexpressions and prunes those inconsistent with any example seen so far.
since parts of the match expressions are promoted to variables only when the input examples show that this is required our synthesis algorithm does not explicitly keep track of all the possible rules that can be consistent with the examples.
our completeness result reflects this idea.
theorem completeness .given a set of examples e for every fixit ruler that is consistent with e either r2con synthrules e or there exists an example esuch that r2con synthrules e e .
proof sketch.
concretely a particular rule rthat is consistent with emight not appear in r synth rules e .
however this can only happen because the match expression of rhas more variables than the match of any rule in r. this can be fixed by providing an example that forces the algorithm to promote to variables all the required match expressions.
properties of the language fixit we define the size of an input examplee scmd serr sfix and the size of each rule rconsistent with eas the sum of its lengths size e size r j scmdj j serrj j sfixj.
for each set of examples there can be exponentially many rules consistent with it.
theorem number of consistent rules .given a set of examples e each of size k the set con synthrules e contains 2o poly k rules.
proof sketch.
as we showed in section .
for each position in the output of a f ixit rule there are potentially polynomially many sub lrexpressions consistent with the provided examples.
for theith position in fix we are free to choose any of the possible sub lrs independently of our choice at other positions.
thus the number of possible rules is potentially exponential in j sfixj.
despite the exponential number of rules represented our data structure allows the s ynth rules to encode these rules using only polynomial size.
next there exists an active learning algorithm for learning fixit rules that requires only a polynomial number of examples i.e.
queries to the user.
theorem complexity of active learning .if there exists a target rulerof sizek there exists an active learning algorithm that will learnrby askingo poly k queries of the form what should the output ofrbe on the input scmd sfix .
proof sketch.
the algorithm first asks kqueries to figure out which match expressions are variables and which ones are constants.
then for each output component for which there exists two possible fix expressions s ub lrconsistent with the examples it asks 14a query that differentiates the two.
since there are only o knin5 k many expressions in the output the algorithm will ask at most polynomially many queries.
.
implementation and evaluation we now describe the implementation details of n ofaq as well as our experimental evaluation of n ofaq on a set of examples and test cases isolated from t hefxxx and web forums.
.
implementation we implemented the language f ixit and its synthesis algorithm in a system called n ofaq.
n ofaq is implemented in f 4and consists of some additional optimizations and design choices as described below.
.
.
implementation optimizations the function a llsubstrings in figure synthesizes all s ub lr functions that are consistent with the first input output pair s t of strings in the example set eand then applies each of the synthesized functions to the other elements of efor filtering only consistent functions.
in practice we first compute the longest common prefixes and suffixes of the strings appearing in the components sfixofeto avoid enumerating instances of the form sub lr l r such thatlorrare not prefixes or suffixes of some output string tappearing in e. the other optimization is based on the following property of the r efine rule function when adding a new example to r if the function f indvariables introduces a new set of variables v all the new instances of s ub lrthat did not already appear inrdepend on one of the newly introduced variables in v. based on this idea the function a llsubstrings only has to compute functions of the form s ub lr var i wherei2v and can reuse the previously computed functions for the other variables by simply filtering the ones that behave correctly on the newly introduced example.
.
.
ranking since there can be multiple possible expressions in f ixit that are consistent with the examples we employ a simple ranking technique to select an expression amongst them.
if there are multiple sub lrexpressions that can generate the desired output string we select the expression that uses the variable with the lowest index i.e.
the leftmost one.
similarly the landrincluded in var match expressions implicitly encode all rules matching on prefixes and suffixes of landr respectively.
we choose the longest landrover all others.
as the example set increases in size we envision users will likely submit diverse sets of examples particularly in use cases with thousands of users submitting examples.
as users submit examples which draw from heterogeneous collections of command parameters v ar match prefixes and suffixes should converge to the least restrictive versions.
similarly n ofaq should discover the least restrictive set of constants for both match expressions.
as these input parameters vary over the set of examples spurious ambiguities in s ub lrshould be eliminated when n ofaq is presented with specific fix examples which function as counterexamples to unnecessary substring expressions.
.
evaluation we now describe our experimental evaluation.
the experiments were run on an intel core i7 .30ghz cpu with gb of ram.
4the implementation will be made open source and publicly available after the review process.we present both qualitative and quantitative analysis of the algorithm.
we assess the expressiveness of n ofaq by attempting synthesis on a benchmark suite that includes the rules in the tool t hefxxx.
we then evaluate the performance of n ofaq and its scalability.
.
.
benchmark suite we compiled our benchmark suite from an initial set of of benchmarks which were collected from both t hefxxx and online help forums .
we considered the repair rules hardcoded in the t hefxxx tool to assess the expressiveness of n ofaq.
since rules in t hefxxx can use arbitrary python code it is hard to exactly compare them to the ones produced by n ofaq.
we use manual testing to check that a rule rgenerated by our tool isconsistent with a ruler0in t hefxxx.
to do so we manually constructed a set of examples based on the pattern matching and textual substitutions performed by the t hefxxx rules.
the other sixteen example sets were obtained from examples found during a non exhaustive survey of command line help forums on the web.
these commands consist of various types of git svn and mvn commands including committing reverting and deleting from repositories as well as installing and removing packages.
the n ofaq system is able to synthesize a rule for of the benchmarks.
the remaining failing benchmarks can be divided into three broad categories i hard coded operations searching for specific strings in some context ii complex patterns checking relationships between variable expressions and iii error messages displaying parts of the input file s content .
we did not provide examples for these rules.
we elaborate more about these categories in section .
number of examples we observed that it was natural to provide two to five examples per benchmark for n ofaq to uniquely learn the desired fix rule.
we also provided additional examples for manually testing the learned rules yielding a set of three to six examples.
given the rule appearing in figure for example we used the two examples in figure and another example with the file name employee.java.
in future we envision users to contribute different examples to the system for automatically building a large corpus of learned fix rules.
while these examples are synthetic examples reverse engineered from other sources they are also natural examples which exercise the range of e.g.
path and file names one would expect to see in a real unix system.
in the case of the repaired command in section .
the natural two example set would consist of two distinct directory names which do not share prefixes and suffixes as well as filenames with distinct prefixes and extensions.
.
.
qualitative evaluation given a single set containing examples for all the cases in which nofaq is capable of synthesizing a rule we performed synthesis as described in section .
.
for each rule we retained a single example from the training set and used it to test the accuracy of each rule.
we also report how often a given input could be repaired using more than one rule.
results for all cases n ofaq synthesized a rule consistent with the corresponding t hefxxx rule or web forum answer.
in some cases we had to synthesize more than one f ixit rule to capture the different possible behaviors of a single rule in t hefxxx.
for example one can try adding sudo in front of a command for several possible errors such as command not found you don t have the permission etc.
in such cases thanks to the partitioning algorithm n ofaq generated a separate rule for each possible error message.
for each case where we synthesized a rule correctness 81size of the expressions benchmarksdistribution of cmd err fix expr size cmdsize errsize fixsizefigure the distribution of benchmarks in terms of individual sizes of scmd serr and sfixexpressions in the examples.
was independent of our choice of examples.
if the correct rule was synthesized it was synthesized regardless of which subset of the examples provided for that rule we selected.
distribution of rule sizes we define the size of an expression such as scmd serr and sfixas the number of strings present in it.
the distribution of the size of the benchmarks in terms of the sizes of the scmd serr and sfixtuples in input output examples is shown in figure .
note that we do not show two benchmarks in the graph with disproportionately high serrexpression size of for clarity.
the average total size of the examples in the benchmarks was15 with the maximum size of .
the average sizes for the individual expressions of the examples were i scmd 01with maximum of ii serr 85with a maximum of and iii sfix 55with a maximum of .
distribution of rule matching for each set of example provided for an individual rule we isolated one example to measure the accuracy of the tool.
all the test examples were correctly described by at least one of the synthesized rules.
for the majority of the test cases there was exactly one rule which matched both the command and error message.
the remaining 12test cases which matched against multiple rules came from collections of example sets which represented different fixes of the same command and error messages.
total test cases test cases matched by one rule test cases matched by multiple rules ranking consistent with our hypothesis in section .
.
a diverse set of examples was sufficient for eliminating spurious restrictions and substring expressions.
in every test case the rule chosen by our ranking policy was capable of correcting all test cases presented.
in practice many rules still have several possible correct s ub lrexpressions.
however this remaining ambiguity occurs because the same string can appear many times in the command and error message e.g.
the string employee in the example in section .
.
.
.
quantitative evaluation we now report on the quantitative metrics of our synthesis algorithm.
in this section we only report data for the benchmarks for which n ofaq can successfully synthesize a f ixit rule.
5we use a sto denote an average awith standard deviation s. 121314151617synthesis time in secondssize of largest groupeager vs lazy vsaeager vsalazy vsaenumerating partitionsfigure synthesis times for different benchmarks for the lazy and non lazy rule representations.
evaluation of lazy vsa synthesis time in figure we show the time taken to partition and synthesize f ixit rules for the benchmarks using both the lazy and a non lazy rule representation as the number of examples per benchmark increases.
the nonlazy representation always considers match and fix expressions as variables rather than initially starting with constants.
to test the performance of the lazy and non lazy representations as the size of the input set increases we iteratively increase the size of the training set.
for each test we add a single example to one of the benchmarks and then attempt synthesis.
we plot the synthesis time with respect to the largest set of examples for which we must enumerate possible partitions until we successfully synthesize rules.
to understand the performance overhead induced by synthesis we also evaluate a version of the algorithm which enumerates partitions without performing synthesis.
for each algorithm we iteratively increased the training set size until the algorithm reached a2 000second timeout.
the non lazy vsa incurs a significant overhead and scales much worse than the lazy version reaching the timeout when the largest set has examples.
the lazy vsa in contrast is much closer to the optimum the synthesis time is negligible compared to the inherent cost of enumerating all partitions of a set.
in fact the lazy synthesis actually completes faster than exhaustive enumeration.
this is reasonable as the first partitioning which yields a successful f ixit rule for all subsets tends to be somewhere near the middle of the enumeration and thus does not incur the cost of enumerating the remainder of the search space.
in summary the lazy vsa strictly outperforms non lazy vsa and can handle much larger sets of examples.
sub lrexpression in synthesized rules the distribution of fstr and s ub lrexpressions in the synthesized f ixit rules is shown in figure .
the output components of the synthesized rule contain on average sub lrexpressions.
concretely a synthesized rule contains on average 76sub lr expressions.
synthesis time vs. number of sub lrexpressions the synthesis time for different numbers of s ub lrexpressions in the repair rule is shown in figure .
as expected the benchmarks that do not contain s ub lrexpressions take negligible time.
the benchmarks involving two s ub lrexpressions on average require more time than the benchmarks with a single s ub lrexpression.
interestingly the benchmarks with s ub lrexpressions take lesser time than the benchmarks with s ub lrexpressions.
a possible explanation for this behavior is that the complexity of substring extraction tasks for these benchmarks is relatively simpler e.g.
identity than the benchmarks with s ub lrexpressions.
81size of the fix expression benchmarks of s ublr and fs trexprs in fix exprs fstr sublrfigure the distribution of f strand s ub lrexpressions in the final synthesized repair expression.
3learning time in ms number of sublr expressions in fix exprsynth rules time vs sublr exprs figure synthesis times for varying number of s ub lrexpressions in the repair rule.
scalability of synthesis algorithm with example size since all real world examples we collected are relatively of small size with maximum size of space separated strings we evaluate the scalability of the s ynth rules algorithm by creating artificial examples of increasing sizes.
we create these artificial examples by repeating the scmd serr and sfixcommands multiple times for the example shown in section .
.
the synthesis times for increasing size of examples is shown in figure .
from the graph we observe that the synthesis times scale in a quadratic fashion with respect to the example size.
.
limitations we showed that the language f ixit is able to express many realworld command line repair rules and that these rules can be synthesized using few examples.
we now present some limitations of our approach in particular with respect to the t hefxxx rules that fixit could not describe.
complex patterns two rules were checking complex properties of the input that f ixit cannot capture.
for example f ixit cannot check whether the error message contains some special character.
f ixit s conditional matching is limited to whole string or prefix suffix matching and thus cannot check if e.g.
a file name contains a non unicode whitespace character.
all character relative logic occurs in the substring generation after 357learning time in ms number of expressions in examplessynth ruletime vs example exprsfigure synthesis times with increasing size of examples.
input matching.
f ixit also cannot check whether some string in the input command is repeated more than once.
context dependencies eight rules had hard coded operations that were searching some context the file system a configuration file etc.
for specific strings to complete the output.
f ixit only receives as inputs the command and the error message and the rules currently cannot use any context.
.
related work version space algebra for synthesis the concept of versionspace algebra vsa was first introduced by mitchell in the context of machine learning and was later used by lau et al.
to learn programs from demonstrations in a programming by examples demonstrations system called smartedit .
it has since been used for many pbe systems from various domains including syntactic string transformations in flashfill table transformations number transformations text extraction from semi structured text files in flashextract and transformation of semi structured spreadsheets to relational tables in flashrelate .
our synthesis algorithm also uses vsa to succinctly represent a large set of conforming expressions.
however in contrast to previous approaches that represent all conforming expressions concretely and then use intersection for refinement our synthesis algorithm maintains a lazy representation of rules and concretizes the choices on demand in a lazy fashion only when it is needed.
moreover our careful design of dsl operators and the corresponding vsa in n ofaq lead to a polynomial time synthesis algorithm unlike most previous approaches that have exponential time synthesis algorithms.
in particular it is illustrative to compare the flashfill dsl with fixit.
while like f ixit flashfill synthesizes string manipulations from input output examples specific performance properties make it less suitable for large scale learning from large sample sets.
prior to developing n ofaq we evaluated the possibility of simply using the flashfill algorithm as is for our purpose of learning command repair rules.
early empirical results indicated that the offthe shelf algorithm scaled poorly as the error messages increased in length which was a common occurrence for our benchmarks.
moreover other limitations of no offset operator in position expressions and support for finite hard coded regular expression tokens made flashfill unsuitable for learning s ub lrexpressions.
we isolated several theoretical properties of flashfill s key operators which yielded poor performance on large inputs.
in particular the binary concatenation operator over arbitrary substrings of 14the entire input string induces a dag structure for the symbolic representation of programs.
more explicitly given an example output strings there exists a node npfor each position pins.
an edge fromnpton0 p p p0represents the substring s .
each edge is labelled with the set fof functions over the example inputs which yield the substring.
thus a path from n0tonjsjrepresents some concatenation of the output of several string operations which yields the desired output.
given a dag dconsistent with a set of examplese flashfill incorporates a new example erepresented by dagd0by taking the cartesian product of the vertices of dand d0 to construct a new dag d00.
an edge with label set f00in the new dag represents a set of functions which were part of a correct program for the examples e and also map from the inputs of eto a substring of e s output.
the iterated cartesian products yield time complexity exponential in the number of examples.
fixit in contrast posesses unary string operations constrained to specific variable terms.
f ixit s unary s ub lroperator yields a language that is disjoint from flashfill with concatenation removed we obtain a language expressive enough for a large set of practical command repair transformations isolated from real use cases while dramatically improving worst case performance.
the constrained nature of the program representation lets the synthesis algorithm eliminate programs inconsistent with a new example without directly computing the intersection of two sets of candidate programs ensuring polynomial time performance even in the worst case.
moreover f ixit also allows for repair transformations that require arbitrary offsets from a regex match which are not expressible in the flashfill dsl.
programming by examples pbe pbe has been an active research area in the ai and hci communities from a long time .
in addition to vsa based data wrangling pbe techniques have recently been developed for various domains including interactive synthesis of parsers synthesis of recursive functional programs over algebraic data types synthesizing sequence of program refactorings imperative data structure manipulations and network policies .
our technique also learns repair rules from few input output examples of buggy and fixed commands but both our problem domain of learning command repairs and the learning techniques of using lazy vsa are quite different from these pbe systems.
program repair research in automated program repair focuses on automatically changing incorrect programs to make them meet a desired specification .
the main challenge is to efficiently search the space of all programs to find one that behaves correctly.
the most prominent search techniques are enumerative or data driven.
genprog uses genetic programming to repeatedly alter the incorrect program in the hope to make it correct .
data driven approaches use the large amount of code that is publicly available online to synthesize likely changes to the input program .
prophet is a patch generation system that learns a probabilistic application independent model of correct code from a set of successful human patches.
unlike these techniques that learn a global model of code repair across different applications our technique learns command specific repairs by observing how expert users fix their buggy commands i.e.
from both the incorrect command the user started with together with the error message and the correct command she wrote as a fix.
crowdsourced repairs helpmeout is a social recommender system that helps novice users facing programming errors by showing them examples of how other programmers have corrected similar errors .
while helpmeout can show examples of similar fixes it does not concretely show the user how the code should be corrected.
this aspect is the major difference between helpmeout and nofaq.thefxxx provides a python interface for command substitution and repair rules and it requires a degree of language and toolspecific knowledge that may not be accessible to command line novices particularly if non trivial substring operations are required to derive the desired command.
much like flashfill we aim to emulate the workflow of non technical users communicating with experts on web forums.
for a beginner learning the command line python string manipulations are likely a fairly challenging task and the cost of an incorrectly transformed shell command is potentially catastrophic.
in such a situation where a non expert desires a new thefxxx rule such a user may provide an example of several command error pairs and the desired fix for each from which an expert would write the desired python code.
nofaq shortens this loop by moving the fix synthesis into a polynomial time algorithm on the user s machine.
rule learning rules provide a simple way to represent programmers actions and in general any type of data transformation.
rule learning has been extensively investigated in classical machine learning and data mining .
the goal of rule learning is to discover and mine rules describing interesting relations appearing in data.
common concept classes for describing rules are horn clauses or association rules .
the approach presented in this paper differs from rule learning in two aspects the rules are expressed in a complex concept class and are hard to learn i.e.
f ixit programs the examples are given by a teacher that has in mind a target rule.
in the future we plan to build a system that uses rule learning techniques to mine f ixit rules from unsupervised data.
program synthesis there has been a resurgence in program synthesis research in recent years .
in addition to examples as described above there have been several techniques developed for handling other forms of specifications such as partial programs reference implementations and concrete traces .
while these specification mechanisms have been found to be useful in several domains we believe examples are the most natural mechanism for specifying command line repairs especially for beginners.
there is also a recent movement towards using data driven techniques for synthesis e.g.
the pliny project .
in future we envision our system to also make use of large number of examples of buggy commands and their corresponding repairs to learn a big database of f ixit rules.
.
conclusion and future directions we presented a tool n ofaq that suggests possible fixes to common buggy commands by learning from examples of how experts fix such issues.
our language design walks a fine line between expressivity and performance by careful choice of unary operators over pre defined variables and exclusion of arbitrary substring operations we avoid exponential time worst case performance while still maintaining a useful degree of functionality.
n ofaq was able to instantly synthesize of the rules appearing in the popular repair tool t hefxxx and other rules from online help forums.
although n ofaq tool is aimed towards repairing commands we believe our novel combination of synthesis and rule based program repair is quite general and is applicable in many other domains as well.
we plan to to apply this methodology to more complex tasks such as correcting syntax errors in source code applying code optimization and editing configuration files.
in the future we hope to create a tool which can take large command histories from expert users and quickly derive rules as well as synthesize new rules online as experts use the shell.
14references r. alur r. bod k e. dallal d. fisman p. garg g. juniwal h. kressgazit p. madhusudan m. m. k. martin m. raghothaman s. saha s. a. seshia r. singh a. solar lezama e. torlak and a. udupa.
syntax guided synthesis.
in dependable software systems engineering pages .
.
d. w. barowy s. gulwani t. hart and b. zorn.
flashrelate extracting relational data from semi structured spreadsheets using examples.
in proceedings of the 36th acm sigplan conference on programming language design and implementation pldi pages new york ny usa .
acm.
isbn .
.
.
.
url .
.
.
s. m. doane d. s. mcnamara w. kintsch p. g. polson and d. m. clawson.
prompt comprehension in unix command production.
memory cognition .
j. k. feser s. chaudhuri and i. dillig.
synthesizing data structure transformations from input output examples.
in proceedings of the 36th acm sigplan conference on programming language design and implementation portland or usa june pages .
.
.
.
url http .
j. furnkranz d. gamberger and n. lavrac.
rule learning in a nutshell.
in foundations of rule learning cognitive technologies pages .
springer berlin heidelberg .
isbn .
.
7 2 .
url http dx.
.
c. goues s. forrest and w. weimer.
current challenges in automatic software repair.
software quality journal sept. .
issn .
.
s11219 .
url http dx.
.
s. gulwani.
automating string processing in spreadsheets using inputoutput examples.
in proceedings of the 38th annual acm sigplansigact symposium on principles of programming languages popl pages new york ny usa .
acm.
isbn .
.
.
.
url http .
s. gulwani w. r. harris and r. singh.
spreadsheet data manipulation using examples.
commun.
acm aug. .
issn .
.
.
.
url http .
w. r. harris and s. gulwani.
spreadsheet table transformations from examples.
in proceedings of the 32nd acm sigplan conference on programming language design and implementation pldi san jose ca usa june pages .
.
.
.
url .
.
b. hartmann d. macdougall j. brandt and s. r. klemmer.
what would other programmers do suggesting solutions to error messages.
in proceedings of the sigchi conference on human factors in computing systems chi pages new york ny usa .
acm.
isbn .
.
.
.
url .
.
t. lau s. a. wolfman p. domingos and d. s. weld.
programming by demonstration using version space algebra.
mach.
learn.
oct. .
issn .
.
a .
url a .
v .
le and s. gulwani.
flashextract a framework for data extraction by examples.
in proceedings of the 35th acm sigplan conference on programming language design and implementation pldi pages new york ny usa .
acm.
isbn .
.
.
.
url http .
c. le goues m. dewey v ogt s. forrest and w. weimer.
a systematic study of automated program repair fixing out of bugs for each.
in proceedings of the 34th international confer ence on software engineering icse pages piscataway nj usa .
ieee press.
isbn .
url http dl.acm.org citation.cfm?id .
.
a. leung j. sarracino and s. lerner.
interactive parser synthesis by example.
in proceedings of the 36th acm sigplan conference on programming language design and implementation portland or usa june pages .
.
.
.
url .
.
h. lieberman.
your wish is my command programming by example .
morgan kaufmann .
f. long and m. rinard.
automatic patch generation by learning correct code.
in proceedings of the 43rd annual acm sigplansigact symposium on principles of programming languages popl pages .
t. m. mitchell.
generalization as search.
artif.
intell.
.
p. osera and s. zdancewic.
type and example directed program synthesis.
in proceedings of the 36th acm sigplan conference on programming language design and implementation portland or usa june pages .
.
.
.
url .
.
g. piatetsky shapiro.
discovery analysis and presentation of strong rules.
in g. piatetsky shapiro and w. j. frawley editors knowledge discovery in databases pages .
aaai press .
v .
raychev m. sch fer m. sridharan and m. t. vechev.
refactoring with synthesis.
in proceedings of the acm sigplan international conference on object oriented programming systems languages applications oopsla part of splash indianapolis in usa october pages .
.
url .
.
.
v .
raychev m. vechev and e. yahav.
code completion with statistical language models.
in proceedings of the 35th acm sigplan conference on programming language design and implementation pldi pages new york ny usa .
acm.
isbn .
.
.
.
url .
v .
raychev m. t. vechev and a. krause.
predicting program properties from big code .
in proceedings of the 42nd annual acm sigplan sigact symposium on principles of programming languages popl mumbai india january pages .
.
.
.
url http .
e. schkufza r. sharma and a. aiken.
stochastic superoptimization.
inarchitectural support for programming languages and operating systems asplos houston tx usa march pages .
.
.
.
url .
r. singh and s. gulwani.
synthesizing number transformations from input output examples.
in proceedings of the 24th international conference on computer aided verification ca v pages berlin heidelberg .
springer verlag.
isbn .
.
url org .
7 44 .
r. singh and s. gulwani.
learning semantic string transformations from examples.
proc.
vldb endow.
apr.
.
issn .
.
.
.
url .
r. singh and a. solar lezama.
synthesizing data structure manipulations from storyboards.
in sigsoft fse pages .
a. solar lezama.
program synthesis by sketching .
phd thesis eecs dept.
uc berkeley .
a. solar lezama r. rabbah r. bodik and k. ebcioglu.
programming by sketching for bit streaming programs.
in pldi .
a. udupa a. raghavan j. v .
deshmukh s. mador haim m. m. k. martin and r. alur.
transit specifying protocols with concolic 14snippets.
in acm sigplan conference on programming language design and implementation pldi seattle wa usa june pages .
.
.
.
url .
m. yakout a. k. elmagarmid j. neville m. ouzzani and i. f. ilyas.
guided data repair.
proc.
vldb endow.
feb. .
issn .
.
.
.
url .
y .
yuan r. alur and b. t. loo.
netegg programming network policies by examples.
in proceedings of the 13th acm workshop on hot topics in networks hotnets xiii los angeles ca usa october pages .
.
.
.
url .
a. proofs of theorems and we first define a notion of completeness for a symbolic rule.
intuitively a symbolic rule has to summarize all possible correct rules to be complete.
definition command string completeness .let r matchcmd anderr!sfixes be a symbolic rule such that cmd err fixes ande a sequence of examples.
we say that cmd is complete for e and produces variables v1 compc cmd e v iff for every i a ci str s for somes iff every example scmd serr sfix in eis such that scmd for somek andsj s. ci var match j l r iffi2v i j and there exists two examples s1 cmd s1 err s1 fix and s2 cmd s2 err s2 fix inesuch that s1 cmd s2 cmd s0 s0 k for somek andsj6 s0 j. ifci var match j l r then for every example scmd serr sfix inewhere scmd lis a prefix ofsj.
moreover lis the longest such prefix.
ifci var match j l r then for every example scmd serr sfix inewhere scmd ris a suffix ofsj.
moreover ris the longest such suffix.
definition error string completeness .analogously we say that err is complete for e and produces variables v2 compe err e v iff for every i b mi str s for somes iff every example scmd serr sfix ineis such that scmd for somek andsj s. mi var match j l r iffi2v i a j and there exists two examples s1 cmd s1 err s1 fix and s2 cmd s2 err s2 fix ine such that s1 err s2 err s0 s0 k for somek andsi6 s0 i. ifmi var match j l r andi a j then for every example scmd serr sfix inewhere serr l is a prefix of si.
moreover lis the longest such prefix.
ifmi var match j l r andi a jthen for every example scmd serr sfix inewhere serr ris a suffix of si.
moreover ris the longest such suffix.
definition input completeness .if bothcompc cmd e v andcompe err e v hold we say that cmd anderrare complete for e and produce variables v1 v2 comp cmd err e v v2 .
definition partialfi completeness .we say thatfiis partially complete pcompfi fi e i with respect to eif the following condition holds fi for somes iff every example scmd serr sfix ineis such that sfix for somek andsi s. if for every i c pcompfi fi e i holds then we say that that fixes is partially complete with respect to v pcompf fixes e .
definition fi completeness .if there exists a v fi1 ijg such thatcomp cmd err e v we say thatfiis complete with respect tovat positioni compfi fi e v i iff pcompfi fi e i .
fi such that for all ind tind6 fstr s for any s iff the following properties hold.
for everyind mandl k jtindkfun l sl fix where for ally j l iy sl cmd sl err .
if there exists a sub lr functiontsuch that for every ind n andl k jtkfun l sl fix where for all y j l iy sl cmd sl err then there exists x msuch thattx t. definition fix completeness .if for every i c compfi fi e v i holds then we say that that fixes is complete with respect to v compf fixes e v .
definition rule completeness .if there is a vsuch that comp cmd err e v andcompf fixes e v we say that ris complete for e compr r e .
notice that for any permutation e0ofe compr r e iff compr r e0 .
proposition compr andcon .letea sequence of examples andr matchcmd anderr!sfixes be a symbolic rule.
if compr r e then every concrete rule r02con r is consistent with any example in e. moreover for every non symbolic rule r1 matchcmd anderr!
consistent with e s1 cmd s1 err s1 fix sn cmd sn err sn fix the following is true if for every i ti6 fstr s iff for some j1 j2 n sj1 fix sj2 fix thenr12con r .
proof.
immediate from definition and the definition of con.
more specifically assume there is some r02con r not consistent with an example e2e.
the only way it can be inconsistent with scmd or serris if some match expression in cmd orerris a fixed string not equal to some string in scmd or serr.
definition precludes this possibility.
similarly it follows from definition that if one of the fix expressions is a constant string then it is consistent with every example fix.
by definition if it is a set of s ub lrexpressions then each one is consistent with every example.
we now show that s ynth substring and s ynth fixhave the intended behaviour with respect to definition .
lemma correctness of s ynth substring .let e s1 cmd s1 err s1 fix sn cmd sn err sn fix be a sequence of examples where every sv fixhas lengthm v fi1 ijg be a set of variables and i mbe an index in the output fix.
if there exist aandbsuch that sa fix sb fix then synthsubstring e v i siffcomp s e v i .
proof.
this lemma states that s ynth substring returns all the sub lrfunctions consistent with the given examples.
again the proof is by induction on the length of e. the base casejej follows from the definition of a llsubstrings .
the inductive step is also trivial s ynth substring simply runs all the functions computed so far on the added example and filters out those that are not consistent with it.
since by ih the varaible fwas correct at 14the beginning of the loop it remains correct.
notice that the order of the examples does not matter.
lemma correctness of s ynth fix .lets be a list of strings t be a sequence of symbolic fix expressions e s1 cmd s1 err s1 fix sn cmd sn err sn fix be a sequence of examples where every sv fixhas lengthm e scmd serr sfix be an example such that for each i n sfix si andvbe a set of variables.
if pcompf t e then synthfix s t e e v fixes iffcompf fixes e e v .
proof.
immediate by induction on mand by using lemma at each step.
as s ynth fixiterates over each string in the example fix and compares it to the corresponding fix expression we can see that the only interesting case of the proof is when tiis either a fixed string not equal to the correpsonding sn fix ine ortiis a set of s ub lrexpressions.
in this case correctness follows directly from lemma as s ynth fixcalls s ynth substring to refine the set of substring operation to those generating sn fix as well as all other sfix values.
next we show the correctness of r efine rule and f indvariables .
lemma correctness of f indvariables .let e s1 cmd s1 err s1 fix sn cmd sn err sn fix be a sequence of examples and cmd anderrbe two sequences of match expressions of lengthsj si cmdjandj si errjrespectively.
if there exists two sets of variablesv1andv2such thatcompc cmd e v1 andcompe err e v2 then if cmd0 v0 findvariables sn cmd cmd then compc cmd0 e v0 .
if err0 v0 findvariables sn err err j si cmdj then compe err0 e v0 .
proof.
the two statements can be proved separately but the proof is identical.
the proofs are both by induction on the length of the first argument of f indvariables and are very simple case analysis following definitions and .
w.l.o.g consider the case for cmd .
over a run of f indvariables a s tr s incmd is only changed if at thenth iteration of the loop cmd is s tr s wheresis not equal to sn cmd .
in that case f indvariables introduces a new variable match expression v ar match i l r wherelandrare respectively the longest shared prefix and suffix of sand sn cmd .
by the i.h cmd was command complete.
it follows directly from definition that command completeness continues to hold.
a v ar match i l r incmd is only changed if at iteration n the longest common prefix suffix x shared by sn cmd andl r is not equal to l r .
in this case v ar match i l r is replaced by v ar match i l0 r var match i l r0 wherer0 l0 is equal to the common prefix suffix x. by the i.h lwas the longest prefix suffix shared by the first n 1values of sk cmd .
clearly x r0 l0 is the longest prefix suffix shared by the first n values of sk cmd .
moreover by the i.h.
cmd satisfied all other criteria for command completeness.
thus it follows that command completeness continues to hold.
it is clear that determining the shorteset prefix and suffix shared by every sk cmd does not depend on the order in which the examples are presented.lemma correctness of r efine rule .letrbe a symbolic rule ebe a sequence of examples ebe an example and r0 refinerule r e e .
ifcompr r e thencompr r0 e e .
proof.
immediate from definition and lemmas and .
lemma correctness of s ynth rules .letebe a sequence of examples.
if r0 synthrules e thencompr r e .
proof.
by induction on the length of e. casejej 1ande the result of c onst rule e clearly satisfies compr r e .
the inductive step follows from lemma .
we can now conclude the proofs of theorems and .
theorem and follow from the order invariance of compr r e and from proposition and lemmas .
proof of theorem let e s1 cmd s1 err s1 fix sn cmd sn err sn fix be a sequence of examples synth rules e r matchcmd anderr!sfixes be the symbolic rule for eand r0 matchcmd0anderr0!fix0 be a concrete rule that is consistent with all the examples in e. if r0belongs to con r then we are done.
assume it doesn t. case .cmd cmd0anderr err0.
then by proposition there exists some ti1 tiksuch that each tivis of the form s ub lr pv l pv r lv rv var jv and for all j n sj fix sfor somes i.e.
the output is a function of the input but all examples can be captured using a constant output .
in this case it is enough to create a new example e0starting from any example scmd serr sfix 2ewhere for each ivwe modify sjv scmd serr so that s ub lr pv l pv r lv rv var jv now returns a value different from the previous one this can be done by simply adding a new character between pv landpv r .
sfix is replaced by the result of applying r0to the modified input.
case .cmd err6 cmd0 err0.
this means that r0uses more variables then r notice that from definition the set of variables used by r0is necessary .
this can be fixed by changing the input of any example scmd serr sfix 2e.
for each variable var i that is incmd0 err0but not incmd errreplace the string scmd serr a1 anwithba1 anwherebis a symbol not appearing in a1 an.
sfixis replaced by the result of applying r0to the modified input.
if the rule is still not in con r0 we can then modify the example using the techniques from case since nowcmd cmd0anderr err0.