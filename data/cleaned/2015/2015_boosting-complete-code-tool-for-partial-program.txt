boosting complete code tool for partial program hao zhong department of computer science and engineering shanghai jiao tong university china zhonghao sjtu.edu.cnxiaoyin wang department of computer science university of texas at san antonio usa xiaoyin.wang utsa.edu abstract to improve software quality researchers and practitioners have proposed static analysis tools for various purposes e.g.
detecting bugs anomalies and vulnerabilities .
although many such tools are powerful they typically need completeprograms where all the code names e.g.
class names method names are resolved.
in many scenarios researchers have to analyze partial programs in bug fixes the revised source filescan be viewed as a partial program tutorials and code search results.
as a partial program is a subset of a complete program many code names in partial programs are unknown.
as a result despite their syntactical correctness existing complete code tools cannot analyze partial programs and existing partial code tools are limited in both their number and analysis capability.
insteadof proposing another tool for analyzing partial programs we propose a general approach called g rapa that boosts existing tools for complete programs to analyze partial programs.
ourmajor insight is that after unknown code names are resolved tools for complete programs can analyze partial programs withminor modifications.
in particular g rapa locates java archive files to resolve unknown code names and resolves the remainingunknown code names from resolved code names.
to illustrate g rapa we implement a tool that leverages the state of theart tool w ala to analyze java partial programs.
we thusimplemented the first tool that is able to build system dependencygraphs for partial programs complementing existing tools.
we conduct an evaluation on partial code commits from four popular open source projects.
our results show that g rapa fully resolved unknown code names for .
bug fixes with an accuracy of .
in total.
furthermore our results show the significance of g rapa s internal techniques which provides insights on how to integrate with more complete code tools toanalyze partial programs.
index t erms partial program program analysis boosting complete code tool i. i ntroduction a partial program is a subset of a complete program.
partialcode analysis is necessary in many scenarios where only partial programs are available such as mining bug fixes forautomatic patching and defect prediction analyzing forum threads and software documents for code recommenda tion and ranking code search results .
in our paper we follow the definition in dagenais and hendren s as below which requires partial programs to be free of syntax errors.
definition partial program given a complete program s r c d e p in which src is the set of compilable source files and dep is the set of compiled dependency files a partial program par is a subset of src .
this definition is consistent with the majority of application scenarios such as analyzing bug fixes code search results andsamples in documents where source files are incomplete butunlikely to have syntax errors.
although the syntax of partial programs is often correct it is infeasible to compile a partial program since the code decla rations it refers to may not be available.
for various purposes researchers e.g.
have proposed approaches that analyze partial programs.
however these approaches havethree limitations.
first most partial code tools are not general.for example zhong et al.
propose mapo that mines specifications for recommending code samples.
mishne et al.
criticize that mapo cannot mine specifications for partial programs.
to handle the problem mishne et al.
propose prime that compares unknown method calls withknown method calls in other call sequences when it minesspecifications.
although prime thus is able to mine speci fications for partial programs its techniques cannot supportpartial code analysis for other purposes e.g.
.
second due to the difficulties of analyzing partial programs partial code analysis is typically imprecise.
for example mishne et al.
admit that their approach is only relatively precise.
finally existing partial code tools cannot support complicated analyses.
for example although graphs are informative tocompare code kim and notkin complain that cfg basedapproaches e.g.
cannot analyze partial programs.
our insight.
we notice that many complete code tools e.g.
w ala are built on mature compilers e.g.
eclipse jdt .
as a partial program is incomplete a compiler typically failsto resolve unknown code names.
when complete code tools encounters unknown code names they will fail to producemeaningful results.
if we fully resolve such unknown codenames it is feasible to boost some complete code tools toanalyze partial programs.
definition code name for a given partial program p we define code names of p denoted as names p as identifiers of code elements at all granularities e.g.
classes types fields methods and variables appearing in p. also we define resolving code name nas determining the variable type and the full name of nifnis a variable field determining the full name of nifnis a type and determining the signature ofnifnis a method.
the benefits and challenges.
our insight leads to a novel approach with the following benefits .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research671 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i the inference strategies of ppa.
strategy example assignment b.field hello world field unknown java.lang.string return int m return method method unknown int method f1 m1 f2 d m1 e p f1 unknown d and f2 unknown e condition if f ... f unknown boolean binary and unary operators int i f f unknown int array f1 f2 f3 unknown int and f8 unknown unknown switch switch f ... f unknown int conditional int i f1?
f2 f1 unknown boolean and f2 unknown int benefit .
this is a general approach that enables many complete code tools for partial code analysis.
unknown code names of partial programs have different impacts on thesetools.
instead of proposing a solutions for specific purposes e.g.
api specification mining our approach works on all the complete code tools that are built on mature compilers.
benefit .
this is a practical way to improve the precision of partial code analysis.
as partial programs contains unknown code elements partial code tools are typically imprecise.
ourstrategy obtains precise tools for partial code analysis sinceit preserves the preciseness of complete code tools.
despite the above benefits to fulfill this strategy we shall overcome the following challenges challenge .
it is challenging to resolve unknown code names for partial programs.
ppa is the state of the art tool that resolves code names for unknown code elements but our studyshows that ppa fully resolves all code names for only .
of partial code snippets section iv c .
challenge .
it is challenging to determine whether unknown code names are sufficiently resolved.
some complete code tools e.g.
do not implement complicated code analyses.
as they never touch some code names boosting such tools isinsufficient to determine whether unknown code names arefully resolved.
in contrast although we can feed resolvedpartial programs to a compiler it is a too strict criterion since it is feasible to conduct many complicated analyses evenwithout producing bytecode from partial programs.
our contributions.
in this paper we propose a novel approach called gra phs for pa rtial programs g rapa that boosts complete code tools to analyze partial programs.
as itcan take huge effort to analyse whole projects researchers have explored analyzing only a subset of awhole program.
their basic idea is to extract an abstractionof other parts of a program.
even if the abstraction is notfully correct it speeds up the analysis on the subset of aprogram significantly.
following their idea g rapa enables partial code analysis by constructing the context code of apartial program.
in particular to handle the first challenge weidentify a compiled release of the complete program whose version is closest to the partial program to be analyzed andextract information from the compiled release to fully resolveunknown code names.
to handle the second challenge we build system dependency graphs sdgs for partialprograms which is a general abstraction of all code elements and relations compared with lighter weight analyses in task specific tools.
it should be noted that a lot of useful analyses such as change impact analysis information flow analysis and static slicing can be simply performed onthe sdg of the program to be analyzed.
this paper makes the following major contributions a novel research idea for generally improving partial code tools.
instead of another approach for specificpartial code analysis our research idea has the potentialto boost many existing complete code tools for partial code analysis if such tools are built on compilers.
a novel approach called g rapa that boosts completecode tools for partial code analysis.
it includes atechnique to locate context versions for a partial program and extends ppa with additional inference strategies.
a tool that boosts w ala for partial code analyses.
thetool has enabled more in depth empirical studies and more advanced bug detection approaches.
an evaluation of our tool on partial code bug fixesthat are collected from four popular open source projects.
our results of the first evaluation show that g rapa fully resolved unknown code names and thus built sdgs for98.
of the total bug fixes.
our results of the secondevaluation show that in .
of bug fixes its code name resolution results are identical with those generatedby a java compiler on their corresponding manuallybuilt complete programs.
in summary different fromexisting imprecise partial code tools our tool preservesthe preciseness of w ala. ii.
m otiv a tions in this section we use an example to illustrate the application scenarios of partial code analysis and the limita tion of existing tools.
the example is from the committedfiles of aries .
specifically programmers modified the tradejdbc.java and added line as follow public tradejdbc ... .
private ... string gettsiaquotesorderbychangesql ... .
public marketsummarydatabean getmarketsummary ... .
connection conn null .
preparedstatement stmt getstatement conn gettsiaquotesorderbychangesql ... this bug fix may need to be analyzed for various reasons such as bug prediction and mining bug repair patterns and typically both the old and new version tradejdbc.java needs to be fed into a static analysis tool.
according to our definitionin section i these two versions of tradejdbc.java are two partial programs.
ppa is the state of the art tool to analyze authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
9huvlrqv 9huvlrq lowhu 9huvlrq 6hohfwru rpslohu sh 5hvroyhu9huvlrq dqglgdwhv3duwldo 3urjudp zlwk sh lqglqjv peljxlw 5hvroyhu rqwh w 9huvlrq zlwk xoo lqglqjv fig.
the overview of g rapa .
partial programs.
it is built on existing compilers such as the eclipse jdt and polyglot and uses its underlying compilerto resolve known code names and iteratively infers unknowntypes based on known types.
table i shows the eight inferencestrategies of ppa.
in this table t1 t2denotes that t1is a subtype of t2 and t1 t2denotes that t1is a super type of t2.
the method strategy infers variable types based on known method signatures and can reversely infer method signatures based known types although it is not explicitly defined as the types of the gettsiaquotesorderbychangesql andconn variables are known in lines and it shall be feasible for ppa to infer the parameter types of the getstatement method in line .
however ppa fails to resolve the parameter types as it depends on the underlying com piler eclipse jdt to acquire the initial resolved code names and eclipse jdt and most other compilers stops compilationencountering the unknown type marketsummarydatabean .
although possible revising existing compilers to bypass com pilation stops raises extra burden and limitation.
furthermore as getstatement is inherited it is impossible for ppa to fully resolve the method signature as it does not know which super type of tradejdbc defines the method.
as the above scenario is frequent in section iv c we find that ppa fully resolves only .
bug fixes.
in g rapa w e acquire initial resolved code names from compiled releases and propose additional variable and field inference strategies section iii c .
in this example aries release several versions .g rapa refers to the closest version for resolving more code names.
as the closest version is introduced it also reducesthe crashing probability of the underlying compiler for otherreasons e.g.
incompatibility .
as a result in total g rapa fully resolves .
bug fixes.
iii.
a pproach a. approach overview figure shows the overview of g rapa .
the basic idea behind g rapa is to extract context code of a given partial program and to enable complete code analysis on the partialprograms with the information from the context code.
definition context code given a partial program i.e.
a set of source files pwhich uses a set of code names names p as defined in definition the code context of pwith depth is defined as context p p v n name p v declares n where vis a binary or source file.
the full code context of pis then defined as context p applying context1function recursively on puntil the result set no longer change i.e.
the fixed point is reached .
with the definition of partial programs and code context we can see that for a partial program p our goal is to find context p and feed it to a complete code analysis tool e.g.
w ala .
the ideal source of context code would be the wholesource code set and all dependency jar files at the versionthe partial program is from.
however a recent study shows that even if checking out whole set of source files most commits are not compilable.
in g rapa for a partial program we use the released versions of the software project it belongs to as its contextcode.
as a released version is already successfully compiled we do not need to fix compilation errors.
a partial can refer to code names that do not appear in any released versions.
for example a code name may be added after a version isreleased and deleted before the next version is released.
inaddition a partial program can be from a code base after itslatest release so all the released versions are outdated.
as aresult locating context code alone is insufficient so we furtherpropose inference strategies to resolve unknown code names.
as shown in figure g rapa has the following major steps.
for a partial program g rapa first searches for a compiled software versions that encloses the given code piece or is compatible with it detailed in section iii b .
we refer to this version as the context version of the given partial program.
after that g rapa extracts asts from the partial program and resolves unknown type bindings of asts detailed insection iii c .
to integrate with complete code tools g rapa further resolves ambiguous types between the partial programsto be analyzed and context code detailed in section iii d .
b. context v ersion extraction to efficiently find the context version of a partial program g rapa uses a two stage strategy according to the code names in the partial program g rapa identifies a small set of context version candidates detailed in section iii b1 and g rapa tries the context version candidates one by one to compile the partial program detailed in section iii b2 .
v ersion filter grapa first extracts the declared types methods and fields from the binary code i.e.
all .class files of all available compiled versions and constructs three lists of declared code names ltdenotes the list of declared types lm denotes the list of declared methods and lfdenotes the list of declared fields.
in a list l l1 ... l n each item l i s in the format of angbracketleftc v angbracketright where cdenotes a code name and v v1 ... v n denotes the set of compiled versions that declare c. for example at the granularity of types it extracts the following list for the released versions of apache derby4 clientsavepoint .
.
.
qualifierutil .
.
.
.
.
.
... for a partial program we determine its context version candidates based on the code names it uses.
a context version authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
candidate should declare most if not all code names used by the partial program if the code name is not declared inthe partial program itself.
for example if a partial programdeclares a local variable whose type is it uses the codename clientsavepoint and .
.
.
will be considered a context version candidate.
given partial program p to extract the set of code names puses denoted as names p g rapa applies the following rules.
for each a.f expression where ais a variable and fis a field it adds both aandftonames p .
for each t.f expression where tis a type and fis a field it adds tandftonames p .
for each a.m p ... expression where ais a variable mis a method and pis a parameter it adds a m and p ... tonames p .
for each t.m p ... expression where tis a type m is a method and pis a parameter it adds mand p ... tonames p .
for each m p ... expression where mis a method and pis a parameter it adds mand p ... tonames p .
for each t a cast expression where tis a type and a is a variable it adds both tandatonames p .
for each ta declaration expression where tis a type andais a variable it adds ttonames p .
for each t m t1 p1 ... throws e1 ... expression where tis a return type mis a method p1is a parameter t1is the type of p1 and e1is a thrown exception it adds t t1 ... and e1 ... tonames p .
for each class interface enum t extends t1 ... implements i1 ... expression where tis a declared class interface or enum t1is a type and i1is an interface it adds t1 ... and i1 ... to names p .
to determine the set of context version candidates based onnames p and a list of declared names l lcan be one of lt lm and lf we developed algorithm .
in the algorithm line initializes vwith the versions of li where the declared code name of liappears in the list of called code names names p .
line iterates used code names if they appear at least in one version.
for each iterated code name c line compares whether v lc.vis an empty set.
if it is not an empty set line updates vwith v lc.v.
if it is line algorithm context v ersion extraction algorithm input lis a list of declared code names names p is a set of called code names output vis a set of context versions v li.vwhere li.v negationslash l i.c names p for all c names p lc.v negationslash do ifv lc.v negationslash then v v lc.v else break end if end for6 leaves the current vas the output.
this line guarantees that vhas at least one version.
given the set of used code names names p g rapa runs algorithm on each of the three lists of declared code names l t lm and lf and produces three sets of context version candidates as vt vm and vf.
as line of the algorithm guarantees that vhas at least one version vt vm and vf are all nonempty sets.
shi et al.
show that types are more unlikely to change than methods and fields.
for a partial program g rapa initiates its context versions vasvt and refines vasvt vmandvt vm vf if such intersection does not generate an empty set.
v ersion selector our version filter uses an efficient algorithm to quickly find context version candidates from potentially many released versions.
however although thealgorithm guarantees that all code names referred in a partialprogram are declared in a context version candidate it cannotrule out incompatibilities such as type conflicts in transitive type inference.
with fewer versions as context version candi dates we apply a compiler which is a more heavy weight but more precise code name resolver to the partial program and each of its context version candidate to select the final contextversion.
specifically as partial programs are syntacticallycorrect a compiler s syntax analysis can build the ast froma partial program but as partial programs has unknown code names the semantic analysis often fails to add name and type bindings to asts.
as a result a compiler will throwexceptions when it encounters unknown or incompatible codenames.
g rapa uses the eclipse jdt compiler as its underlying compiler since many complete code tools are built on thecompiler.
during parsing a compiler can search its classpath for code names.
g rapa adds context versions to the class path of a compiler since it allows a compiler to search code names and thus reduces the possibility of throwingexceptions.
as introduced in section iii b1 g rapa can locate multiple context versions for a partial program.
in this step grapa tries context version candidates one by one until no exceptions are thrown.
although this strategy is simple our evaluation results show that it is already sufficient to analyzereal world partial programs such as bug fixes.
algorithm inference algorithm input fis a list of facts tis a set of known types output tis a set of inferred types t ppa prime f t while t negationslash do t variable f t t field f t t ppa prime f t end while authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
c. context aware type resolver after the context version is determined g rapa further enhances the inference rules of ppa to take full advantage of the information from the context code.
as shown in table i ppa follows eight strategies to resolve unknown type bindings.for example its assignment strategy is as follow 1b.field hello world field unknown java.lang.string t1 t2denotes that t1is a subtype of t2 and t1 t2 denotes that t1is an ancestor of t2.
as shown in the above example ppa considers only the partial program itself its in ference strategies are localized to statements and do not fullyreuse inferred results.
in contrast with context code available g rapa can link the definition and all usage locations of a variable in the code piece and infer the variable type based on the global information from all usage locations.
in particular grapa has the following three additional inference strategies .
variable inference strategy.
for each method the strategy updates bindings of variables until it is safe.
suppose that amethod declares a variable vand uses the variable in locations v ... v n. we use dt v to denote the type of v and the safe order of inferred types follows the definition of ppa i.e.
unknown missing super missing full .w e consider the vvariable to be safe if dt v dt v1 ... dt vn .
for partial programs a variable can be unsafe since a compile can fail to resolve its type at specific locations.
forexample if v iappears in a code line with a serious compilation error a compiler can fail in resolving the bindings for vi.a s a result although the bindings of other locations are resolved the binding of v iis still unknown.
in addition a variable can become unsafe during inference.
for example if a known variable is assigned to vi the assignment strategy of ppa can infer the binding of vi.
after the inference vican be safer than its other locations.
when this happens our variable inference strategy locates the safest type dt vi and propagates dt vi to all the locations of the vvariable to make it safe.
.
field inference strategy.
the field inference strategy is similar to the variable inference strategy but with a differentvariable scope.
the strategy updates bindings of fields untilthey coincide.
for each field the strategy combines solvedtypes in all its usage locations.
.
switch inference strategy.
for a switch statement switch v ppa defines a switch inference strategy that considers dt v as a subtype of the int primitive.
the strategy is not fully correct since dt v can be byte short char int string andenum values.
g rapa revises the strategy and considers that a switch statement switch v case c1 ... case cn ... is safe if dt v dt c1 ... dt cn .i f a switch statement is unsafe g rapa locates the safest type dt ci from dt v anddt c1 ...d t cn and propagates dt ci to all the locations to make it safe.
ppa can infer the type for a variable at a location but leaves its type unresolved at other locations.
as a result although the type of the variable can be useful to infer more unknownbindings ppa fails to leverage such benefits.
algorithm 2shows the process to solve the problem.
line infers typeswith our modified ppa ppa prime .
here g rapa modifies the original switch inference strategy of ppa.
for a variable ora field lines and search for its safest type and updatesall its locations with the safest type.
after that line furtherinfers types with our modified ppa.
if more unknown bindingsare resolved line repeats the follow up lines until nonew unknown bindings are thus resolved.
here t denotes newly resolved bindings in each iteration.
in algorithm ourvariable and field inference strategies unveil the full potentialof ppa since they combine facts from different locations to infer the safest types for unknown code names.
we use the following partial program to illustrate the difference between g rapa and ppa on type binding resolution.
b a.f ...2c b xyz object obj a.f ppa resolves type facts for each variable location in the example so for line it infers variables bandcas of type java.lang.string and for line it infers obj and a.f as of type java.lang.object .
finally based on the type of a.f ppa further resolves bat line as of type java.lang.object .
here ppa leaves the variable bat line and line with different types because it does not know whether the two appearances refer to the same variable inpartial code analysis.
in contrast g rapa extracts information from the context version to confirm that the whole code piece comes from thesame method and the two appearances of brefer to the same local variable.
g rapa further uses algorithm to infer the type of bacross all appearances and finally the type of b anda.f are both updated to java.lang.string .
d. ambiguity resolver if a complete code tool does not require inter procedure analyses the integration is straightforward.
for example asmapo implements only intra procedure analyses it is feasibleto boost mapo for partial programs after unknown bindingsare resolved.
however if a complete code tool requires inter procedure analyses involving the context version into partial code analysis also results in a new challenge.
as the contextversion can contain a copy of the partial programs piece theremay be two duplicate declarations of the same code name e.g.
types variables and methods .
in the partial code analysis weneed to make sure that g rapa analyzes the partial programs piece instead of its copy in the context version.
for example suppose that a partial program implements the t1 ... t ntypes and t1uses t2.
when a inter procedure tool analyzes t1 it needs to locate the declaration of t2.
when locating a type a compiler typically searches the build pathof a project before they search the source code of the project.
g rapa builds a temporary project for the partial program and adds the context version to the build path of the project.
thecontext version can include t prime 2whose name is identical with t2.
as a result the t prime 2type in the context version is analyzed instead of the t2type in the partial program.
as the context authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
version is only an approximate of the partial program the analysis results can be inaccurate.
we envisage that there are at least three techniques to handle the problem removing t1 ... t nfrom the build path of the project pre analyzing t1 ... t n and merging their analysis results and changing the search sequence.
the first technique is simple but may not work on some complete code tools.
for example if a compiler cannot find a type inthe build path of a project it may either search the sourcefiles of the project or throw exceptions depending on itsimplementation details.
the second technique can introduceextra analysis effort.
the third technique requires modifying source files of complete code tools but it is flexible anddoes not introduce extra analysis effort.
therefore in theimplementation of g rapa we follow the third technique and we introduce how we modify the subject complete code analysis tool in section iii e. e. implementation in the current implementation of g rapa we select w ala as the subject tool to illustrate the potential of our approach.
w ala implements various analyses e.g.
type hierarchy analysis data flow analysis slicing and dependency analysis .w ala implements its advanced analyses on its unified intermediate representation called ir whose format is like java bytecode.
when w ala analyzes java source files it uses theeclipse jdt compiler to build asts from source code andthen translates asts into irs.
when the underlying compilerparses a partial program p it is able to build an ast for p since the syntax of pis correct.
however the unknown code names in pcause exceptions when w ala translates pto its ir.
as a result w ala cannot analyze partial programs.
like most compilers w ala searches the build path first when resolving types.
as mentioned in section iii d wemodify its code to reverse the search strategy.
here we modify the classloader of w ala instead of the classloader of jvm.
as a result our tool is not coupled to jvm.
it should benoted that our modifications to w ala is minimal and suchmodifications are similar for all analysis tools with a specificcompiler component.
for analysis tools that depend on acompiler already supported by g rapa e.g.
eclipse jdt grapa is able to work with the tools directly.
iv .
e v alua tions with the implementation of g rapa we conducted evaluations to explore the following research questions rq1 how effectively does g rapa resolve unknown code names of partial programs section iv a ?
rq2 what is the accuracy of g rapa to resolve unknown code names section iv b ?
rq3 what is the effectiveness of g rapa s internal techniques section iv c ?
rq1 concerns the effectiveness of g rapa .
as our primary research goal is to boost existing complete code tools in section iv a we select the state of the art tool w ala asthe subject tool for the first research question and use thetable ii overall result.
name v fix successfailure u f d aries .
cassandra .
derby .
mahout .
total .
u unsupported fragment f not fully resolved d defect.
sdg generation for bug fixes as our application scenario.
from four widely used open source projects we collected bugfixes.
our results show that w ala built sdgs successfully for98.
of the bug fixes after g rapa resolved their unknown code names.
this is a significantly improvement since as a complete code tool w ala cannot build any system dependency graphs from such bug fixes.
we understand that it ispossible that some code names are wrongly fixed.
to explorethis issue we introduce more evaluations in rq2.
rq2 concerns the accuracy of g rapa .
in section iv b we select bug fixes and manually build the correspondingbuggy and fixed versions and fed the complete built programsto w ala so that w ala can correctly resolve all the codenames and build sdgs correctly.
collecting these sdgs asgolden standard we compare with them sdgs generatedby g rapa for the same buggy and fixed programs partial programs .
our results show in .
of bug fixes g rapa based sdgs are identical to the sdgs in the golden standard.
rq3 concerns the internal techniques of g rapa .
in section iv c we turn off different internal techniques of g rapa and our results show the significance of individual techniques.
the results also reflect how much code name resolution is needed to leverage a complete code tool such as w ala. a. rq1 the effectiveness subject as we introduced in section ii bug fixes can be viewed as partial programs and we use bug fixes as the subjects of our evaluation.
we use the following two criteriato determine a bug fix .
issue number.
open source projects typically have issue trackers to track various issues e.g.
bugs improvements new features tasks and sub tasks .
when programmers commit their modified files they often write the corresponding issue number in the message of the commit.
for example incassandra a commit s message says implement multiple index expressions.
patch by jbellis reviewed by nate mccallfor cassandra .
in the issue tracker the page ofthe issue says that cassandra is a bug.
we thusdetermine that the corresponding commit is a bug fix.
.
keyword.
programmers may detour issue trackers especially when they believe that a change is trivial.
when they commit such a change programmers may write a messageto describe the fix.
for example in aries the message of acommit says fix broken service registration listener .
we thusdetermine the commit as a bug fix since its message containswords such as bug or fix .
the heuristic is simple and a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
number of previous studies e.g.
used the same technique to extract bug fixes.
in table ii column name shows project names.
all the projects are from the apache software foundation.
column v ersion lists released versions of the projects.
column bug fix lists number of analyzed bug fixes.
we select theseprojects since they are under active maintenance and theirbug fixes are already collected and confirmed by previousstudies .
here we filter bug fixes that do not modify sourcefiles or modify only test code.
typically a released version does not include test code so it becomes infeasible to locatecontext versions for test code.
as the input of this evaluation a bug fix is defined as follow definition bug fix a bug fix between a buggy version bv and a fixed version fv is a pair of two partial programs b p f p where bpbelonging to bv and includes all file removed or modified fpbelonging to fv and includes all source files added or modified during the bug fix.
tufano et al.
analyzed snapshots from apache projects.
they found that only code commits are automatically compilable and are caused by unresolvablereferences.
mockus et al.
introduce that the apache foundation has a strict management over its hosted projects.without such a management system the problem may beworse in other open source communities e.g.
github .
as a result both bvandfv are typically partial programs.
zhong and su show that such partial programs typically containfewer than three source files.
evaluation scenario we use the sdg generation for bug fixes as our evaluation scenario due to two considerations.first analysis of bug fixes is the basis of many downstreamresearch topics such as bug prediction and mining of bug repairpatterns.
automating in depth analysis of bug fixes will allowall above research to be applied on a much larger data set.second sdgs are general abstractions of all code elementsand relations in the program and many general code analysistools such as w ala and codesurfer use sdgs as theirdefault output.
a lot of useful analysis results such as change impact analysis information flow analysis static slicing can be direct extracted from the sdgs of theprogram to be analyzed.
as the output of g rapa an sdg is defined as follow the same as its definition in w ala definition a system dependency graph is defined as g angbracketleftv e e2 angbracketright where v is a set of nodes corresponding to variables expressions and e1 e2 v vare two sets of edges.
a angbracketlefts1 s2 angbracketright e 1edge denotes a data dependency from s1tos2 and a angbracketlefts1 s2 angbracketright e 2edge denotes a control dependency from s1tos2.
as an example figure shows the built system dependency graph for the buggy code of derby which swallows an exception.
private static void closestream ... try if stream!
null stream.close .gdwd ghshqghqf y elqdu rs qh y y qxoo frqglwlrq eudqfk lqyrnh forvh lqyrnh mdyd fhswlrq uhwxuq ydoxh jrwr jrwr frqwuro ghshqghqf fig.
built graphs for partial programs catch ioexception e util.javaexception e under this application scenario with g rapa bug prediction and pattern mining tools can easily acquire sdgs and other down stream analysis results e.g.
slicing from a large number of bug fixes.
while without g rapa there must be a lot of people manually build all the relevant code versions and analyzing the whole code base is also much slower thananalyzing only the partial programs involved in the bug fixes.
criterion as we collected thousands of bug fixes and each fix can contain thousands of unknown code names it isinfeasible to manually examine whether g rapa fully resolved unknown bindings of a bug fix or not.
instead of a manual ex amination we use the underlying complete code tool w ala as an automatic measure.
a simple tool is insufficient for the automated measure since it may not touch many resolvedcode bindings.
in contrast w ala is the state of the art toolfor java analysis and it implements many advanced analysistechniques that require various code bindings.
our criterionillustrates our contributions to the state of the art since itcomplements existing tools.
for each bug fix we extract its buggy files revised or deleted files of the bug fixing commit in the pre fix version and modified files revised or added files of the bug fixing commit in the post fix version .
both the set of the buggy files and modified files are partial program since we did notcheck out their corresponding whole projects.
we considerthat bindings in the buggy or modified files are fully resolved if w ala is able to build system dependency graphs fromthe code.
for a bug fix we consider that it is successfully resolved if g rapa fully resolved all its source files.
here we concede that w ala can build a system dependency graph for a partial program even if it is incorrectly resolved.
wefurther investigate this issue in section iv b. result g rapa uses only tens of released versions to approximate contexts of thousands of commits and thus avoideffort of analyzing the whole project for each commit and building each commit which often needs nontrivial manualeffort.
our results lead to the following findings .
g rapa fully resolved unknown code names for most bug fixes.
in table ii column success lists number of successes and column lists success rates.
in total we find that grapa fully resolves .
bug fixes since their dependency graphs can be built.
.
w ala failed to analyze .
fixes even after g rapa fully resolved their bindings.
column failure lists number of failures.
based on our inspection we further put them into three categories.
in particular subcolumn u lists fixes thatw ala failed to analyze.
for example the f0be890 commit authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii the results of comparing with the golden standard.
name v ersion fix file method same aries .
.
cassandra .
.
.
derby .
.
.
.
mahout .
.
.
total .
of cassandra modifies schemakeyspace.java a file with lambda expressions all.foreach table getschemacfs table .truncateblocking the underlying tool w ala cannot analyze lambda expressions.
as another example we notice that g rapa fails on the following code final standardmbean standardmbean new standardmbean bean beaninterface ... we inspect the relevant code of w ala and find an assertion assert superctor!
null couldn t find constructor for anonymous class based on the error message w ala seems to have limitationson analyzing anonymous classes.
.
g rapa failed to fully resolve bindings in .
bug fixes.
subcolumn f lists cases where bindings are not fully resolved.
we find that the failed cases fall into three major categories .
insufficient facts to infer bindings.
for example we find a code snippet as follows replicationmessage message ... switch message.gettype case replicationmessage.type log ...case replicationmessage.type failover ...case replicationmessage.type stop ...default ... in this code snippet replicationmessage is an unknown code name.
based on the switch statement g rapa infers thattype log type failover type stop and the return value of the message.
gettype method shall be the same.
the type does not appear in any released versions but between two versions.
as the code snippet does not provide adequateinformation g rapa fails to determine their types.
.
insufficient type inference strategies.
for example we find a code snippet as follows public class editauthorform extends formservlet private static final long serialversionuid ... in the above code formservlet is an unknown code name but the inference strategies of ppa and our extension cannotinfer the binding for the ancestor type.
.
conflict facts.
for example we find the following snippet public void setup string aggregatename super.setup aggregatename ... the above code calls the super.setup ... method but in the located version the signature of the method is as follow public void setup classfactory classfactory string s datatypedescriptor datatypedescriptor ... the above code and release have different definition on the signature of the super.setup ... method.
we find that when this type of conflicts happens ppa tends to reject the information from source code.
however as our locatedreleases are approximate the information from the build pathshall be rejected so the strategy of ppa leads to incorrectbinding resolution in this example.
.
the eclipse jdt compiler failed to parse .
fixes.
subcolumn d lists cases where the jvm machine crashes a fatal error has been detected by the java runtime environment ... we notice that the following method calls appear in crash logs cimethod org eclipse jdt core compiler charoperation... ... jdt internal compiler ast typereference init ...... jdt internal compiler ast expression init ... we suspect that the underlying compiler eclipse jdt is not designed for parsing partial program so it reports the aboveproblem when parsing partial program.
in summary our results show that g rapa effectively resolved bindings for more than of bug fixes.
only .
of bug fixes are not fully resolved which may be resolved inour future work.
b. rq2 the accuracy subject table iii shows our subjects.
we choose the latest version since it is easier to fix possible compilation errors.
for example an old version may require a third party librarythat is no longer available.
column bug fix lists selected bugfixes.
tufano et al.
show that recent snapshots are almost .
times more likely to compile than early snapshots.
toreduce the manual effort to prepare the golden standard weselect bug fixes whose detected version is exactly the latestversion.
we filter out bug fixes whose graphs are not built and bug fixes that do not have compilation problems.
column file and column method list total source files and totalmethods of selected bug fixes respectively.
criterion for each bug fix we checked out its buggy and fixed versions and repaired all compilation errors.
afterthat we used w ala to build sdgs g wa l a for the buggy files of the bug fix as our golden standard.
meanwhile weuse g rapa to build sdgs g grap a from the buggy files as a partial program.
we implemented a tool to compareg wa l a with ggrap a for their differences.
the tool uses the hungarian algorithm to match nodes and we definethe distance between two nodes m andn as follows dis m n i m i n i m i n o m o n o m o n d l m l n i m denotes the indegree of m o m denotes the outdegree ofm l m returns the label of m and d l1 l2 returns the levenshtein edit distance between the l1label and the l2label.
result .
g rapa correctly resolved bindings in most fixes.
table iii shows the overall results.
column same lists methods whose built graphs are identical.
column listscorresponding percents.
in total .
bindings resolved by g rapa are identical with the golden standard.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv the significance of internal techniques.
nameno version no ppa no extension suc.
suc.
suc.
aries .
.
.
cassandra .
.
.
derby .
.
.
mahout .
.
.
total .
.
.
.
g rapa failed to correctly resolve bindings in only .
fixes.
after manual inspection we identified two types of wrong resolutions .
not fully resolved bindings.
for example cassandra6181 includes the following code public void serialize dataoutput out... ... bytebufferutil.
writewithshortlength tombstones.starts out ... in this code the writewithshortlength method is unknown.
ppa infers its signature based on its parameters writewithshortlength ljava nio bytebuffer ljava io dataoutput v when we manually recover the code we find that the declaration of the method is as follow public static void writewithshortlength bytebuffer buffer dataoutputplus out ... ... the above code has no compilation errors since dataoutputplus is a subtype of dataoutput .
our tool detects the following difference zulwh lwk6kruw hqjwk mdyd qlr wh xiihu mdyd lr dwd2xwsxw zulwh lwk6kruw hqjwk mdyd qlr wh xiihu ruj dsdfkh fdvvdqgud lr xwlo dwd2xwsxw3oxv .
wrong static and instance code names.
for example cassandra modifies the following code bf filterfactory.getfilter ... here the filterfactory.getfilter ... method is unknown.
ppa wrongly resolves the static method to an instancemethod although it correctly resolves all the parameters andthe return value.
we identify the wrong resolution since ourtool detects the following difference qyrnh vwdwlf jhw lowhu qyrnh yluwxdo jhw lowhu in the above two situations w ala can still build graphs based on incorrect binding resolutions.
in table ii the resultson these methods are counted as successes according to thecriterion in section iv a. our tool detected the incorrectresolutions but as shown in table iii .
of the totalbindings are correctly resolved.
c. rq3 internal techniques setup our approach has two major techniques to resolve unknown bindings it detects the context versions for a partial program section iii b1 and it extends ppa withadditional inference strategies section iii c .
in this section we use g rapa to analyze the bug fixes in table ii without the above techniques to show their significance.
result in table iv column no v ersion shows the results when g rapa does not detect context versions.
column no ppa shows the results when g rapa does not resolve unknown bindings with ppa.
column no extension showsthe results when g rapa uses the standard ppa instead of our extended ppa as described in section iii c. subcolumn suc.
lists number of successes.
subcolumn lists success rate.
the results lead to our findings .
the technique of locating context versions is the most effective internal technique.
without locating context versions only .
of the total fixes are fully resolved.
withoutthe standard ppa and our extended ppa .
and .
of the total fixes are fully resolved respectively.
the resultshighlight the importance of locating context versions and theimprovement over ppa.
.
our extended ppa shows its significance when partial programs have critical compilation errors.
comparing column no ppa with column no extension we find thatour extension of ppa improves the success rates.
we noticethat like other compilers the eclipse jdt compiler can stop resolving bindings after it encounters a critical compilation error.
for example in aries a method is as follows private ... string gettsiaquotesorderbychangesql ... public marketsummarydatabean getmarketsummary ... preparedstatement stmt getstatement gettsiaquotesorderbychangesql ... ... in the method the code name marketsummarydatabean is unknown and causes a critical compilation error.
the underlying compiler eclipse jdt does not resolve any bindingsinside the method after encountering the error.
for example although gettsiaquotesorderbychangesql is declared in the same type its type is resolved as null .
consequently ppa fails to resolve the signature of the getstatement method.
our variable and field strategies links resolved bindings beforethe error line and those unresolved bindings after the errorline.
in this example our field strategy links the declarationof gettsiaquotesorderbychangesql to the parameter of thegetstatement method.
as a result it becomes feasible to resolve the signature of the method.
in this way our additionalinference strategies make the improvements in table iv.
d. threats to v alidity the threats to internal validity include our criterion to determine incorrect resolutions in rq2.
to reduce the bias we implement a tool to compare dependency graphs but even a tool can introduce errors.
the threat could be reduced by introducing more manual inspections.
the threats to externalvalidity include that we focus on only a type of partial pro grams from only apache and a single tool so our effectivenessmay vary on other subjects.
to reduce the threat we selectthousands of commits and the state of the art tool.
the threatcould be reduced by analyzing more subject tools.
v. a pplica tions of grapa as a support tool the benefits of g rapa are indirect and our evaluations did not show its applications.
however we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
believe that g rapa can be useful in many real applications since it enables more accurate analysis on partial programs.
.
more in depth empirical studies.
researchers have conducted various empirical studies to explore open questions that involve partial programs e.g.
bug fixes .
as their underlying partial code tools are limited and imprecise their results can be superficial or even biased.
g rapa enables more in depth analysis on partial programs.
indeed zhong andmeng have conducted an empirical study on using pastfixes to construct new patches.
as they compare sdgs of bugfixes their study is infeasible without g rapa .
more advanced bug detection repair approaches.
many researchers believe that it is feasible to propose more advancedbug detection repair approaches based on the knowledge thatis extracted from past fixes.
however as existing partial code tools are limited it is quite challenging to automate theextraction.
for example although kim et al.
implemented tools to reduce their inspection effort their analysis is largelymanual which is tedious and error prone.
g rapa enables more in depth empirical studies on bug fixes and moreadvanced bug detection repair techniques.
indeed zhong andwang have detected previously unknown bugs for all the four projects and their tool is built on g rapa .
.
analyzing partial programs in more scenarios.
the applications of g rapa are not limited to analyzing bug fixes.
besides this scenario g rapa can be applied to many other scenarios where partial programs and some compiled releases are available.
typical scenarios include code samples in apidocuments development emails and code searchengines .
it is feasible to extend g rapa for the above scenarios after minor changes.
for example although manycode samples in api documents do not have method classbodies zhong and su show that it is feasible to constructfake bodies which enables follow up analysis.
as anotherexample terragni et al.
propose an approach that extracts code samples from forums.
from such samples it is feasible to locate context versions by querying such types on existing code search engines e.g.
grepcode or github .
despite of that algorithm is suboptimal it achieves more than accuracy leaving adequate space for further improvements.
vi.
r ela ted work partial code analysis.
mishne et al.
propose prime that mines specifications from partial programs.
zhong and su detect errors in code samples of api documentations and suchsamples are partial programs.
subramanian and holmes extract api calls from code samples in stackoverflow.
our approach presents a general way to leverage tools for complete code so they can analyze partial programs complementing ex isting approaches.
dagenais and hendren propose ppa thatfixes unknown bindings for partial programs.
we are the first toprovide the insight that extending ppa can potentially leveragecomplete code tools to analyze partial programs.
ossher et al.
resolve missing dependencies for complete programs but most partial programs are not compilable even if theirdependencies are resolved.
carvalho gomes et al.
analyzeincomplete java bytecode.
during compilation complete codeinformation is encoded into bytecode so jvm can execute itcorrectly.
when analyzing partial code we do not have suchinformation so the problem we target is more challenging.
code comparison.
fluri et al.
compare asts of source files for their differences.
maletic and collard translates files into srcml and compare the translated format for differ ences.
kim and david denote code with a set of predicatesand compare these predicates for their differences.
buse and weimer generate documents to describe code changes.
apiwattanapong et al.
compare cfgs for their delta.
although graphs are more informative kim and notkin complain that cfg based approaches cannot analyze partialprograms which is complemented by our approach.
empirical study on bug fixes.
researchers have conducted various empirical studies to understand the nature of bug fixes.
yin et al.
show that bug fixes can introduce new bugs.
nguyen et al.
show that repetitiveness is common in small size bug fixes.
eyolfson et al.
show that the bugginess of a commit is correlated with the commit time.
thung et al.
show that faults are not localized.
zhong and su analyze the nature of fixing bugs.
canfora et al.
analyze the relations between fixed code elements and the time to fix bugs.with our approach researchers can integrate more advanced tools for analyzing bug fixes reducing the analysis effort.
vii.
c onclusion and future work in this paper we propose an approach that locates approximate java archive files and resolves remaining unknownbindings.
after integration we can boost existing completecode tools to analyze partial programs.
based on our approach we implement g rapa and conduct evaluations on thousands of partial code bug fixes.
our results show that our tool correctly fully resolved unknown bindings for .
of bugfixes and for .
of bug fixes our binding resolutions are identical with our golden standard.
in future work we plan to explore two directions as follows.
first applying g rapa to different application scenarios may require more advanced technical adaptations.
for example symbolic analysis often needs a driver function to initiateobjects of partial programs.
person et al.
propose differential symbolic execution that reuses analysis results betweenprogram versions and test code can provide hints on initiatingobjects.
analyses of forum threads calls for more advancedsearching techniques for context versions.
second althoughour tool works on java our approach is general and can beadapted for other programming languages.
a cknowledgments we appreciate the reviewers for constructive comments and na meng for repairing bugs in g rapa .
hao zhong is sponsored by the program in china no.
2015cb352203 thenational nature science foundation of china no.
and the grant of science and technology commission ofshanghai municipality no.
15dz1100305.
xiaoyin wang swork is supported in part by nsf grant ccf anddhs grant dhs st .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.