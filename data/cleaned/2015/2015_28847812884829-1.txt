performance issues and optimizations in javascript an empirical study marija selakovic department of computer science tu darmstadt germany m.selakovic89 gmail.commichael pradel department of computer science tu darmstadt germany michael binaervarianz.de abstract as javascript is becoming increasingly popular the performance of javascript programs is crucial to ensure the responsiveness and energy e ciency of thousands of programs.
yet little is known about performance issues that developers face in practice and they address these issues.
this paper presents an empirical study of xed performance issues from popular client side and server side javascript projects.
we identify eight root causes of issues and show that ine cient usage of apis is the most prevalent root cause.
furthermore we nd that most issues are addressed by optimizations that modify only a few lines of code without signi cantly a ecting the complexity of the source code.
by studying the performance impact of optimizations on several versions of the spidermonkey and v8 engines we nd that only .
of all optimizations improve performance consistently across all versions of both engines.
finally we observe that many optimizations are instances of patterns applicable across projects as evidenced by previously unknown optimization opportunities that we nd based on the patterns identi ed during the study.
the results of the study help application developers to avoid common mistakes researchers to develop performance related techniques that address relevant problems and engine developers to address prevalent bottleneck patterns.
.
introduction javascript has become one of the most popular programming languages.
it is widely used not only for client side web applications but also for server side applications mobile applications and even desktop applications.
the performance of javascript code is crucial to ensure that applications respond quickly to requests without consuming unnecessarily high amounts of cpu time and energy.
for example for server side code that may respond to thousands of requests every second even a relatively small performance improvement can have a signi cant impact on the overall throughput and energy consumption.
likewise client side code that permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
poorly can cause users to perceive an application as unresponsive which may encourage them to instead use a competitor s web site.
the use of the language has evolved from simple clientside scripts to complex programs such as email clients word processors and interactive games.
this development has been enabled by signi cant improvements of javascript s performance.
the main reason for this evolutionary step are the tremendous improvements of javascript engines in recent years e.g.
due to highly optimized just in time jit compilers .
despite the e ectiveness of jit compilation developers still apply optimizations to address performance issues in their code and future improvements of javascript engines are unlikely to completely erase the need for manual performance optimizations.
for example a common optimization is to replace a forinloop that iterates over the properties of an object oby code that rst computes these properties using the built in object.keys function and then iterates through them with a traditional forloop.
this optimization often improves performance on the v8 engine because the jit compiler may refuse to optimize a function that contains a for in loop if the object ois internally represented as a hash map.
in contrast the jit compiler successfully optimizes the call of object.keys and the traditional forloop.
despite the importance of javascript s performance little is currently known about performance issues and optimizations in real world javascript projects.
this paper addresses this problem and asks the following research questions rq what are the main root causes of performance issues in javascript?
rq how complex are the changes that developers apply to optimize their programs?
rq what is the performance impact of optimizations?
rq are optimizations valid across javascript engines and how does the performance impact of optimizations evolve over time?
rq are there recurring optimization patterns and can they be applied automatically?
answering these questions helps improve javascript s performance by providing at least three kinds of insights.
first application developers bene t by learning from mistakes done 1we refer to a source code change that a developer applies to improve performance as an optimizations and we refer to an automatically applied transformation e.g.
in a jit compiler as a compiler optimization .
ieee acm 38th ieee international conference on software engineering by others.
second developers of performance related program analyses and pro ling tools bene t from better understanding what kinds of problems exist in practice and how developers address them.
third developers of javascript engines bene t from learning about recurring bottlenecks that an engine may want to address and by better understanding how performance issues evolve over time.
to address these questions we present an empirical study of performance issues and optimizations in real world javascript projects.
the study involves xed issues that developers have documented in bug tracking systems.
the issues come from javascript projects including both clientside and server side code popular libraries and widely used application frameworks.
our main ndings are the following the most prevalent root cause of performance issues is that javascript provides apis that are functionally equivalent but provide di erent performance and that developers often use these apis in a suboptimal way.
this nding suggests that developers need guidance in choosing between such apis and that future language and api designs may want to reduce the amount of redundancy of apis.
many optimizations a ect a small number of source code lines and of all optimizations a ect less than and lines respectively.
many optimizations do not signi cantly a ect the complexity of the source code .
of all optimizations do not change the number of statements and .
of all optimizations do not change the cyclomatic complexity of the program.
this nding challenges the common belief that improving the performance of a program often implies reducing its understandability and maintainability .
only .
of all optimizations provide consistent performance improvements across all studied javascript engines.
a non negligible part .
of changes even degrades performance on some engines.
these ndings reveal a need for techniques to reliably measure performance and to monitor the performance e ect of changes across multiple execution environments.
many optimizations are instances of recurring patterns that can be re applied within the same project and even across projects of the studied issues are instances of patterns that reoccur within the study.
furthermore we nd previously unreported instances of optimization patterns in the studied projects.
most optimizations cannot be easily applied in a fully automatic way mostly due to the dynamism of javascript.
we identify ve kinds preconditions for safely applying recurring optimization patterns.
statically checking whether these preconditions are met is a challenge.
our results suggest a need for tools that help developers applying recurring optimizations.
in summary this paper contributes the following the rst in depth study of javascript performance issues and optimizations that developers apply to x them.
a documented set of reproduced issues that may serve as a reference point for work on nding and xing per formance bottlenecks.
all data and code gathered during the study is available for download.
evidence that developers need tools and techniques to improve performance e.g.
to choose between redundant apis to apply recurring optimization patterns and to reliably measure performance improvements.
.
methodology this section summarizes the subject projects we use in the empirical study our criteria for selecting performance issues and our methodology for evaluating the performance impact of the optimizations applied to address these issues.
.
subject projects we study performance issues from widely used javascript projects that match the following criteria project type.
we consider both node.js projects and clientside frameworks and libraries.
open source.
we consider only open source projects to enable us and others to study the source code involved in the performance issues.
popularity .
for node.js projects we select modules that are the most depended on modules in the npm repository.3for client side projects we select from the most popular javascript projects on github.
number of reported bugs .
we focus on projects with a high number of pull requests to increase the chance to nd performance related issues.
table lists the studied projects their target platforms and the number of lines of javascript code.
overall we consider projects with a total of lines of code.
.
selection of performance issues we select performance issues from bug trackers as follows .keyword based search or explicit labels .
one of the studied projects angular.js explicitly labels performance issues so we focus on them.
for all other projects we search the title description and comments of issues for performance related keywords such as performance optimization responsive fast and slow .
.random selection or inspection of all issues .
for the project with explicit performance labels we inspect all such issues.
for all other projects we randomly sample at least issues that match the keyword based search or we inspect all issues if there are less than matching issues.
.con rmed and accepted optimizations .
we consider an optimization only if it has been accepted by the developers of the project and if it has been integrated into the code repository.
.reproducibility .
we study a performance issue only if we succeed in executing a test case that exercises the code location lreported to su er from the performance problem.
we use of the following kinds of tests a test provided in the issue report that reproduces the performance problem.
javascriptissuesstudy 62table projects used for the study.
project description kind of platform total loc number of issues angular.js mvc framework client jquery client side library client ember.js mvc framework client react library for building reactive user interfaces client underscore utility library client and server underscore.string string manipulation client and server backbone mvc framework client and server ejs embedded templates client and server moment date manipulation library client and server nodelrucache caching support library client and server q library for asynchronous promises client and server cheerio jquery implementation for server side server chalk terminal string styling library server mocha testing framework server request http request client server socket.io real time application framework server total a unit test published in the project s repository that exercises l. a newly created unit test that calls an api function that triggers l. a microbenchmark that contains the code at l possibly pre xed by setup code required to exercise the location.
.split changes into individual optimizations .
some issues such as complaints about the ine ciency of a particular function are xed by applying multiple independent optimizations.
because our study is about individual performance optimizations we consider such issues as multiple issues one for each independent optimization.
.statistically signi cant improvement .
we apply the test that triggers the performance critical code location to the versions of the project before and after applying the optimization.
we measure the execution times and keep only issues where the optimization leads to a statistically signi cant performance improvement.
the rationale for focusing on unit tests and microbenchmarks in step is twofold.
first javascript developers extensively use microbenchmarks when deciding between different ways to implement some functionality.4second most projects we study are libraries or frameworks and any measurement of application level performance would be strongly in uenced by our choice of the application that uses the library or framework.
instead focusing on unit tests and microbenchmarks allows us to assess the performance impact of the changed code while minimizing other confounding factors.
in total we select and study performance issues as listed in the last column of table .
.
performance measurement reliably measuring the performance of javascript code is a challenge e.g.
due to the in uence of jit compilation garbage collection and the underlying operating system.
to evaluate to what extent an applied optimization a ects the program s performance we adopt a methodology that was previously proposed for java programs .
in essence we repeatedly execute each test in nvmnewly launched vm 4for example jsperf.com is a popular microbenchmarking web site.instances.
at rst we perform nwarmup test executions in each vm instance to warm up the jit compiler.
then we repeat the test nmeasure more times and measure its execution times.
to determine whether there is a statistically signi cant di erence in execution time between the original and the optimized program we compare the sets of measurements mbefore andmafterfrom before and after the optimization.
if and only if the con dence intervals of mbefore andmafterdo not overlap we consider the di erence to be statistically signi cant.
based on preliminary experiments we use nwarmup nmeasure and nvm because these parameters repeat measurements su ciently often to provide stable performance results.
we set the con dence level to .
because very short execution times cannot be measured accurately we wrap each test in a loop so that it executes for at least 5ms.
all experiments are performed on an intel core i7 4600u cpu .10ghz machine with 16gb of memory running ubuntu .
bit .
.
javascript engines javascript engines evolve quickly e.g.
by adding novel jit optimizations or by adapting to trends in javascript development5.
to understand how the performance impact of an optimization evolves over time we measure the performance of tests on multiple engines and versions of engines.
table lists the engines we consider.
we focus on the two most popular engines v8 which is used e.g.
in the chrome browser and the node.js platform and spidermonkey which is used e.g.
in the firefox browser and the gnome desktop environment.
for each engine we use at least three di erent versions taking into account only versions that are published after introducing jit compilation and including the most recent published version.
all considered versions are published in di erent years and we take engines for which their version number indicates that the engine potentially introduces signi cant changes compared to the previous selected version.
table lists for each engine which types of projects it supports.
we execute the tests of a project on all engines that match the kind of platform client or server as listed in column three of table .
63table javascript engines used to the test performance impact of optimizations sm spidermonkey .
engine versionplatform project type firefox client firefox clientsm39 firefox client .
node.js server .
chrome clientv83.
chrome and node.js client and server .
chrome and io.js client and server a most prevalent root causes.
inefficient api usage inefficient iteration repeated execution inefficient or unnecessary copying special cases api reimplementation repeated checks too generic api otherpercentage of issues b apis that are used ine ciently.
reflection strings dom arrays project internal other built in other third partypercentage of issues within inefficient api usage figure root causes of performance issues.
.
rq root causes of performance issues this section addresses the question which root causes realworld performance issues have.
to address this question we identify eight root causes that are common among the studied issues and we assign each issue to one or more root cause.
figure summarizes our ndings which we detail in the following.
.
api related root causes the root cause of performance issues is related to how the program uses or does not use an api.
we identify three speci c root causes related to api usage.
inefficient api usage.
the most common root cause of all issues is that an api provides multiple functionally equivalent ways to achieve the same goal but the api client does not use the most e cient way to achieve its goal.
for example thefollowing code aims at replacing all quotes in a string with escaped quotes by rst splitting the string into an array of substrings and then joining the array elements with the quote character .. str .
split .
join the optimization is to use a more e cient api.
for the example the developers modify the code as follows .. str .
replace g ine cient api usage is the most prevalent root cause with a total of issues.
figure 1b further classi es these issues by the api that is used ine ciently.
the most commonly misused apis are re ection apis such as runtime type checks invocations of function objects and checks whether an object has a particular property.
the second most common root cause is ine cient use of string operations such as the above example.
inefficient reimplementation.
the root cause of of all issues is that the program implements some functionality that is already implemented in a more e cient way e.g.
as part of the built in api.
the optimization applied to avoid such performance issues is to use the existing more e cient implementation.
for example angular.js had implemented a map function that applies a given function to each element of an array.
later the developers optimize the code by using the built in array.prototype.map function which implements the same functionality.
generic api is inefficient.
another recurring root cause of all issues is to use an existing api that provides a more generic and therefore less e cient functionality than required by the program.
for example given a negative number n the following code accesses thejnjth to last element of the array arr arr .
slice n the code is correct but ine cient because slice copies parts of the array into another array of which only the rst element is used.
the optimization applied to avoid such performance issues is to implement the required functionality without using the existing api.
for the example the developers improve performance by directly accessing the required element arr .
other root causes besides api related problems we identify six other common causes of performance issues.
inefficient iteration.
javascript provides various ways to iterate over data collections such as traditional forloops for in loops and the array.prototype.foreach method.
a common root cause of poor performance of all issues is that a program iterates over some data in an ine cient way.
the optimization applied to avoid such performance issues is to iterate in a more e cient way.
for example the following code iterates through all properties of argusing a for in loop 6issue of underscore.js.
7issue of angular.js.
8issue of jquery.
9issue of ember.js.
64for var prop in arg if arg .
hasownproperty prop use prop this iteration is ine cient because it requires to check whether the property is indeed de ned in argand not inherited from arg s prototype.
to avoid checking each property the developers optimize the code by using object.keys which excludes inherited properties var updates object .
keys arg for var i l updates .
length i l i var prop updates use prop repeated execution of the same operations.
of all issues are caused by a program that repeatedly performs the same operations e.g.
during di erent calls of the same function.
for example the following code repeatedly creates a regular expression and uses it to split a string function on events ... events events .
split s ... the code is ine cient because creating the regular expression is an expensive operation that is repeatedly executed.
the optimization applied to avoid such performance issues is to store the results of the computation for later reuse e.g.
through memoization .
for the above example the developers compute the regular expression once and store it into a variable var eventsplitter s function on events ... events events .
split eventsplitter ... unnecessary or inefficient copying of data.
another recurrent root cause of all issues is to copy data from one data structure into another in an ine cient or redundant way.
the optimization applied to avoid such performance issues is to avoid the copying or to implement it more e ciently.
for example a function in angular.js used to copy an array by explicitly iterating through it and by appending each element to a new array.11the developers optimize this code by using the built in array.prototype.slice method which is a more e cient way to obtain a shallow copy of an array.
a computation can be simplified or avoided in special cases.
of all issues are due to code that performs a computation that is unnecessarily complex in some special case.
the optimization applied to avoid such performance issues is to check for the special case and to avoid or to simplify the computation.
for example the developers of angular.js used json.stringify value to obtain a string representation of a value.
however the value often is a number and calling stringify is unnecessarily complex in this case.12the developers optimize the code by checking the runtime type of 10issue of backbone.
11issue of angular.js.
12issue of angular.js.the value and by using the much cheaper implicit conversion into a string value when the value is a number.
repeated checks of the same condition.
several issues are because the program repeatedly checks the same condition even though some of the checks could be avoided.
for example the following code repeatedly checks whether a given object is a function which is ine cient because the object cannot change between the checks.
function invoke obj method .map obj function value isfunc .
isfunction method ... the optimization applied to avoid such performance issues is to refactor the control ow in such a way that the check is performed only once.
for the above example the developers hoist the isfunction check out of the map call.
our analysis shows that various performance issues can be mapped to a relatively small number of recurring root causes.
some but not all of these root causes have been addressed by existing approaches on automatically nding performance problems .
our results suggest that there is a need for additional techniques in particular to help developers choose among multiple functionally equivalent ways to use an api.
.
rq complexity of optimizations this section addresses the question how complex the source code changes are that developers apply to optimize their programs.
to address this question we analyze the project s code before and after each optimization.
we study both the complexity of the changes themselves section .
and to what degree applying these changes a ects the complexity of the program s source code section .
.
.
complexity of changes to assess the complexity of changes applied as optimizations we measure for each change the number of a ected lines of source code i.e.
the sum of the number of removed lines and the number of added lines.
to avoid biasing these measurements towards particular code formatting styles we apply them on a normalized representation of the source code.
we obtain this representation by parsing the code and pretty printing it in a normalized format that does not include comments.
we nd that optimizations a ect between and lines of javascript source code with a median value of .
figure shows the cumulative sum of the number of a ected lines per change i.e.
how many optimizations are achieved with less than a particular number of a ected lines.
the graphs shows that of all optimizations a ect less than lines of code and that of all optimizations a ect even less than lines of code.
we conclude from these results that a signi cant portion of optimizations are possible with relatively simple changes which empirically con rms an assumption made by prior research on performance bug detection .
13issue of underscore.js.
160percentage of optimizations affected lines cumulative sum figure number of source code lines that are a ected by optimizations.
a e ect on the number of statements.
infinity.. .. .. .. .. .. ..infinitypercentage of optimizations difference in number of statements b e ect on cyclomatic complexity.
infinity.. .. .. .. .. .. ..infinitypercentage of optimizations difference in cyclomatic complexity figure e ect of applying an optimization on the cyclomatic complexity.
.
change in complexity of program to understand to what degree optimizations in uence the complexity of the source code of the optimized program we measure the number of statements in the program and the cyclomatic complexity of the program before and after each change.
these metrics approximate the understandability and maintainability of the code.
for each change we obtain the metric before and after the change nbefore andnafter and we summarize the e ect of the change as nafter nbefore .
a positive number indicates that the change increases the complexity of the program because the changed program contains additional statements or increases the cyclomatic complexity whereas a negative number indicates that the program becomes less complex due to the change.
figures 3a and 3b summarize our results.
the graphs show what percentage of optimizations a ect the number of statements and the cyclomatic complexity in a particular range.
for example figure 3a shows that of all optimizations add between one and three statements to the program.
we nd that a large portion of all optimizations do not a ect the number of statements and the cyclomatic complexity at all .
do not modify the number of statements and .
do not modify the cyclomatic complexity.
a manual inspection of these optimizations shows that they modify the code in minor ways e.g.
by moving a statement out of a loop by adding an additional subexpression or by replacing one function call with another.
it is also interesting to note that a non negligible percentage of optimizations decreases the number of statements .
and inefficient api usage inefficient reimplementation generic api inefficient iteration repeated execution inefficient copying special cases repeated checksperformance impact performance improvements per root causefigure performance improvements obtained by optimizations per root cause.
the bottom and the top of the box indicate the rst and of the data and the middle line indicates the median value.
vertical lines extend the bottom and the top of the box to indicate the minimum and the maximum values.
the cyclomatic complexity .
.
these results challenge the common belief that optimizations come at the cost of reduced code understandability and maintainability .
we conclude from these results that many optimizations are possible without increasing the complexity of the optimized program.
.
rq performance impact of optimizations the following addresses the question which performance impact developers achieve by optimizing their programs.
to address this question we execute the tests of all optimizations on all considered javascript engines where the respective code can be executed section .
in total we obtain performance improvement results.
figure shows the performance results obtained by optimizations for each root cause.
the gure illustrates that optimizations lead to a wide range of improvements with the majority of optimizations saving between and of the execution time.
perhaps surprisingly the gure shows that some optimizations cause a performance degradation.
we further analyze these cases in section .
in general the performance results depend on the tests we use and we can not generalize the results for a speci c root cause.
for example the optimizations tested with microbenchmarks usually yield large improvements because they run small snippets of code.
given these results and the results from section one may wonder whether there is any correlation between the pain and the gain of optimizations i.e.
between the number of lines a ected by a change and the performance improvement that the change yields.
to address this question figure shows the relation between these two metrics for all issues.
the gure does not show any correlation pearson s correlation coe cient .
.
we draw three conclusions from our results.
first developers apply some optimizations even though the achieved performance impact is relatively small.
this strategy seems 160max.
performance improvement affected linesfigure relation between the number of lines a ected by a change and the achieved performance improvement.
spidermonkey v8 .
.
.
.
.
.
.
.
.
.
table percentage of optimizations that result in positive positive or no positive or negative no or negative and negative speedup in v8 and spidermonkey.
reasonable e.g.
when the modi ed code is in a heavily used library function but may also be a sign for premature optimizations .
second developers apply some optimizations even though these optimizations cause a performance degradation on some javascript engines either consciously or without knowing what impact a change has.
third some optimizations lead to signi cant savings in execution time and future work on pro ling should pinpoint such optimization opportunities to developers.
.
rq consistency across engines and versions since di erent javascript engines apply di erent optimizations changing code to improve performance in one engine risk to degrade it in another engine.
furthermore since engines evolve quickly an optimization applied to speed up the program in one version of an engine may have the opposite e ect in another version of the same engine.
to assess to what degree developers struggle with these risks this section addresses the question how consistent performance improvements are across di erent javascript engines and across multiple versions of the same engine.
similar to rq we address this question by measuring the performance impact of the performance issues in all considered javascript engines.
since we want to compare performance impacts across engines we include only issues that we can execute in both v8 and spidermonkey i.e.
we exclude non browser optimizations.
in total we consider issues for this research question.
.
consistency across engines table compares the performance impact of changes in the v8 and spidermonkey engines.
for each engine the table distinguishes ve cases means that a change im .
.
.
.2performance improvement versions of v8 39performance improvement versions of spidermonkeyfigure performance improvement of changes in di erent versions of engines.
each line represents one performance optimization same line style in both gures means the same optimization .
proves performance in all versions of the engine means that the change improves performance or does not a ect performance means that the change improves performance in some version but degrades it in another version means no performance change or a performance degradation and nally means a negative performance impact in all versions.
for each combination of these ve cases the table shows the percentage of changes that fall into the respective category.
because the study includes only issues that provide an improvement in at least one engine section .
the four cases in the bottom right corner of the table cannot occur.
we nd that only .
of all changes speed up the program in all versions of both engines which is what developers hope for when applying an optimization.
even worse .
of all changes degrade the performance in at least one engine i.e.
a change supposed to speed up the program may have the opposite e ect.
interestingly a non negligible percentage of changes speed up the program in one engine but cause slowdown in another.
for example .
of all changes that increase performance in all versions of spidermonkey cause a slowdown in at least one version of v8.
some changes even degrade performance in some versions of both engines.
for example .
of all changes may have a positive e ect in v8 but will either decrease or do not a ect performance in spidermonkey.
.
consistency across versions of an engine to better understand how the performance impact of a change evolves across di erent versions of a particular engine figure shows the speedups of individual changes in the v8 top and spidermonkey bottom engines.
for readability the gure includes only those .
of all changes that cause a slowdown in at least one version of some en67gine.
the graphs show that performance can di er signi cantly across di erent versions.
for example a change that provides an almost speedup in version .
of the v8 engine causes a non negligible slowdown in version .
of the same engine.
the graphs also show that the performance impact of a change sometimes evolves in a non monotonic way.
that is a bene cial optimization may turn into a performance degradation and then again into a bene cial optimization.
in summary our results show that performance is a moving target.
this nding motivates future work that supports developers in achieving satisfactory performance despite the heterogeneity of javascript engines such as techniques to decide when to apply an optimization to reliably and automatically measure the performance e ect of a change to track the e ect of an optimization over time to undo an optimization that turns out to be counterproductive in a new engine and to specialize javascript code for particular engines.
.
rq recurring optimization patterns the following addresses the question whether there are recurring optimization patterns and whether they can be applied automatically.
to address the rst part of the question we manually identify a set of optimizations that can be re applied across several projects and semi automatically search for instances of these optimization patterns beyond the studied issues section .
.
to address the second part of the question we identify pre conditions for applying the recurring optimization patterns in a fully automated way section .
.
.
prevalence of recurring optimization patterns to identify performance optimizations that may apply in more than a single situation we inspect all issues.
first we identify optimizations that occur repeatedly within the study table patterns .
second since the studied issues may not expose multiple instances of a pattern that would occur repeatedly in a larger set of issues we also identify patterns that may occur repeatedly table patterns .
for each optimization pattern in table we provide a short description as well as an example of code before and after the optimization.
in table the numbers before the vertical lines show how often each optimization pattern occurs within the issues considered in the study.
for instance there are two instances of pattern avoid for in loops in the angular.js project.
the last column shows that the studied issues contain eight optimizations that match pattern .
in total of the studied optimizations match one of the optimization patterns.
to study whether there are occurrences of the optimization patterns beyond the studied optimizations we develop a simple ast based static analysis for each pattern in table .
each such analysis performs an ast traversal of a javascript program to nd matches of the patterns.
due to the well known di culties of statically analyzing javascript in a sound way section .
the analyses cannot guarantee that the optimization patterns can indeed be applied at the identi ed code locations without changing the program s se table instances of recurring optimization patterns a jb a number of pattern instances in the studied issues b number of previously unreported pattern instances found with static analysis .
id projectsember react less mocha angular underscore.string ejs socket.io moment cheerio underscore request chalk 11j20 j21 j12 j0 j2 j0 j0 j1 j0 j0 j0 j0 j08j56 20j0 j0 j1 j0 j1 j0 j1 j0 j0 j0 j0 j0 j06j3 30j6 j1 j3 j6 j2 j7 j7 j1 j0 j1 j0 j0 j12j35 40j0 j0 j0 j0 j0 j0 j0 j0 j0 j0 j0 j0 j06j0 50j2 j0 j0 j0 j0 j0 j0 j0 j0 j0 j0 j0 j02j2 60j0 j0 j0 j0 j0 j0 j0 j0 j0 j0 j0 j0 j01j0 70j9 j0 j1 j4 j0 j0 j0 j0 j3 j2 j2 j0 j01j21 80j2 j0 j0 j0 j1 j0 j0 j0 j0 j0 j0 j0 j01j3 90j0 j0 j1 j0 j0 j0 j0 j0 j0 j2 j0 j2 j01j5 100j1 j0 j2 j0 j3 j1 j0 j5 j2 j0 j0 j0 j01j14 1j40 j22 j20 j10 j9 j8 j8 j7 j5 j5 j2 j2 j129j139 mantics.
to enable us to manually check whether a match is a valid optimization opportunity the analyses also rewrite the program by applying the respective optimization pattern.
we then manually inspect the rewritten program and prune changes that would modify the program s semantics.
we apply the ten analyses to the current version of each of project.
in total the analyses suggest optimizations of which we manually prune changes because they break the semantics of the program.
in table the numbers after the vertical lines show how many previously unreported optimization opportunities the analyses nd for each project.
we omit four projects for which we do not nd any match.
in total we nd instances of recurring optimization patterns.
the most common patterns are pattern avoid for in loop pattern use implicit string conversion and pattern use instanceof .
for two patterns and the analyses do not nd any previously unreported instances.
the results show that patterns are recurring within a project.
for example pattern has been applied only once in the ember project by the developers but we nd additional code locations that o er the same optimization opportunity.
furthermore the results show that recurring patterns can be applied across projects.
for example the only instance of pattern within the studied issues is in the mocha project but there are additional instances in other projects.
we are reporting optimization opportunities to the developers and some of them have already been applied incorporated into the projects.
we conclude from these results that there is a need for tools and techniques that help developers apply an already performed optimization at other code locations both within the same project and across projects possibly along the lines of existing work .
.
preconditions for automatic transformation the second part of the rq is whether recurring optimization patterns can be applied automatically.
answering 14see javascriptissuesstudy for an updated list of reported issues.
68table recurring optimization patterns and pre conditions for applying them t type check nf native function is not overridden p prototype is not overridden tf function from third party library is not overridden v check on value of an expression .
id description example preconditions before after t nf p tf v prefer object.keys over computing the properties of an object with a for in loop.for var key in obj if obj .
hasownproperty key ... var keys object .
keys obj for var i l keys .
length i l i var key keys ... l l l m m to extract a substring of length one access the character directly instead of calling substr .str .
substr i str lmlm m to convert a value into a string use implicit type conversion instead of string .starts string starts starts starts mlmlm use jquery s empty instead of html .body .
html body .
empty lm m lm use two calls of charat instead of substr .key .
substr !
key .
charat !
key .
charat !
l l l m m to replace parts of a string with another string use replace instead of split and join .str .
split .
join str .
replace g l l l m m instead of checking an object s type with tostring prefer the instanceof operator.if tostring .
call err ...if err instanceof error tostring .
call err ...ml l ml for even odd checks of a number use 1instead of .index index 0lm m m m prefer forloops over functionalstyle processing of arrays.styles .
reduce function str name return ... str for var i i styles .
length i var name styles str ... return str l l l m m when joining an array of strings handle single element arrays e ciently.
.
slice .
call arguments .
join arguments .
length ?
arguments .
slice .
call arguments .
join lmlm m this question is an important rst step for developing techniques that help developers nd optimization opportunities based on recurring patterns and for developers of jit engines who may want to address some of these patterns in the engine.
to address the question we identify for each optimization pattern the preconditions that must be satis ed to safely apply the optimization in an automatic way.
we nd the following kinds of preconditions type check .
check the type of an identi er or expression.
for example the objidenti er in pattern must have type object.
native function is not overridden .
check that a built in javascript function is not overridden.
for example in pattern both hasownproperty and keys must be the built in javascript functions.
prototype is not overridden .
check that particular properties of the prototype are not overridden.
for example for pattern the hasownproperty property of object.prototype must not be overridden.
function from third party library is not overridden .
check that a function from a third party library is not overrid den.
for example the html and empty functions in pattern must be functions from the jquery library.
check the value of an expression .
check whether an expression has a particular value.
for example to apply pattern the tostring variable must refer to the object.prototype.tostring method.
the last columns of table show which preconditions need to be satis ed to automatically apply the optimization patterns.
due to the dynamic features of the javascript language it is challenging to statically analyze whether these preconditions are met.
possible solutions include a more sophisticated static analyses or dynamic checks that ensure that the conditions are met at runtime.
we conclude from the fact that each pattern is subject to several kinds of preconditions that applying optimizations in javascript in a fully automatic way is not trivial and that nding techniques that address this challenge is subject to future work.
.
threats to v alidity subject projects.
our study focuses on open source projects and the results may not be representative for closed 69source projects or other open source projects.
furthermore as we consider projects written in javascript our conclusions are valid for this language only.
performance tests.
we measure the performance impact of optimizations with unit tests and microbenchmarks the application level impact of the optimizations may di er.
we believe that our measurements are worthwhile because javascript developers heavily use unit tests and microbenchmarks to make performance related decisions.
javascript engines and platforms.
we measure performance with several versions of two javascript engines that implement jit compilation.
our results may not generalize to other jit engines such as chakra which is used in internet explorer or interpreter based engines.
since the most popular server side platform node.js and popular browsers build upon the v8 or spidermonkey engines we expect that our measurement are relevant for developers.
underapproximation of recurring optimization patterns.
our methodology for ndings instances of recurring optimization patterns may miss instances e.g.
because the static analyses rely on naming heuristics.
as a result the number of previously unreported instances of optimization pattern is an underapproximation.
since our goal is not to precisely quantify the prevalence of recurring patterns but to answer the question whether such patterns exist at all this limitation does not invalidate our conclusions.
.
related work .
studies of performance issues studies show that performance bugs occur frequently and that they account for a non negligible amount of developer time .
jin et al.
report that many problems in c and c can be xed by following e ciency rules .
liu et al.
study performance bugs in smartphone applications and propose specialized program analyses that detect two common kinds of problems.
linares vasquez et al.
study how api usages on android in uence energy consumption which is closely related to performance.
our work di ers from the existing studies by studying the root causes of issues the complexity of optimizations the performance impact of the applied optimizations and the evolution of the performance impact over time.
furthermore we are the rst to study performance issues in javascript which di ers from c c and java both on the language and the language implementation level.
we had presented an earlier version of this work in a poster paper .
.
studies of javascript ocariza et al.
study the root causes and the impact of correctness bugs in javascript as well as the characteristics of failures .
a recent study by gallaba et al.
focuses on the usage of javascript callbacks.
other studies consider the dynamic behavior of javascript applications the prevalence of the eval function javascript inclusions and the harmfulness and prevalence of type coercions .
in contrast to all these studies this paper focuses on performance issues.
.
efficiency of javascript engines the need for e ciently executing javascript code is addressed by optimizing just in time compilers that produce type specialized code that e ciently representobjects and that specialize functions based on previously observed parameters .
our work shows that engines employ di erent optimization strategies and that some optimizations provide very di erent performance across the engines.
we envision that the ndings of our study help engine developers to focus on performance bottlenecks that they may currently not be aware of.
.
javascript analysis program analyses for javascript include dynamic analyses to nd type inconsistencies and violations of code quality rules dynamic determinacy analysis dynamic information ow analysis change impact analysis combined dynamic static analysis to check if an interface description matches a library implementation static analysis of library clients ui level test generation and type analysis for javascript .
our study motivates future research on analyses that help developers improve the performance of javascript code and provides evidence to steer such work toward relevant problems.
.
detecting performance bottlenecks there are various analyses and pro ling approaches to detect performance bottlenecks such as memoization opportunities jit unfriendly code memory bloat repeated operations in loops repeated patterns of method calls ine cient use of collections and performance regressions .
our work highlights common performance issues in javascript and provides insights to steer future approaches for detecting performance issues.
.
conclusion optimizations of javascript code deserve attention because thousands of javascript applications rely on responsive and energy e cient computations.
despite the fact that javascript engines keep getting faster developers still deal with performance issues by applying optimizations to their code.
this paper presents the rst systematic study of realworld javascript performance issues.
we collect reproduce and make available issues and optimizations collected from popular javascript projects.
our results provide insights about the most prevalent root causes of performance issues the complexity of changes that developers apply to optimize programs the performance impact of optimizations and its evolution over time.
furthermore our work provides evidence that many optimizations are instances of recurring optimization patterns.
by nding previously unreported optimization opportunities based on optimization patterns applicable across projects we show a great potential for techniques to further optimize existing programs.
our results and observations motivate future work on developing techniques and tools that help developers solve performance issues and that provide directions to steer such work toward problems that are relevant in practice.