context aware integrated development environment command recommender systems marko gasparic tural gurbanov francesco ricci free university of bozen bolzano piazza domenicani bolzano italy abstract integrated development environments ides are complex applications that integrate multiple tools for creating and manipulating software project artifacts.
t o improve users knowledge and the effectiveness of usage of the available functionality the inclusion of recommender systems into ides has been proposed.
we present a novel ide command recommendation algorithm that by taking into account the contexts in which adeveloper works and in which different commands are usually executed is able to provide relevant recommendations.
we performed an empirical comparison of the proposed algorithmwith state of the art ide command recommenders on a realworld data set.
the algorithms were evaluated in terms of precision recall f1 k tail and with a new evaluation met ric that is specifically measuring the usefulness of contextual recommendations.
the experiments revealed that in terms of the contextual relevance and usefulness of recommendations theproposed algorithm outperforms existing algorithms.
i. i ntroduction software development tools can affect the efficiency and the quality of software construction .
integrated development environments ides are popular applications that serve theneeds of a large and diverse user population by bringingtogether multiple tools to create and manipulate softwareproject artifacts.
a generic ide user is not supposed to access the full provided functionality if that is not useful to accomplish the task at hand.
nevertheless it is important totry to increase the breadth of the used functionality especiallyof the less skilled users since the lack of knowledge mayprevent the exploitation of useful functions .
in fact in our previous work we conducted a user study and performed a number of interviews which confirmed that even professionalsoftware developers are willing to learn new ide functionalityand would like to use an application that could help them toachieve this goal .
to improve ide users knowledge and usage of the available functionality command recommender systems rss havebeen proposed .
commands are shortcuts or menu buttonsthat execute a certain function and they can be recommendedas opportunistic suggestions which refer to recommendations that are relevant in the specific situation when the recommen dation is presented and global suggestions which refer to recommendations that are based on the long term commandusage history and are supposed to be relevant in general for thefuture activity of the user.
in our work we focus on global ide command recommendations which should take into account the typical contexts in which a particular developer works andare useful in these contexts.
we note that the actual deliveryof the recommendations i.e.
presentation and timing are outof scope of this paper but we refer an interested reader to some of our previous publications in particular and .
we model the context with contextual factors that describe the environment in which an ide user executed a command the temporal perspective of the execution what was the user sactivity before and during the execution and what projectartifact she interacted with .
the exploitation of contextualinformation to generate global command recommendations is novel since existing algorithms which are either basedon command popularity collaborative filtering or commanddiscovery patterns do not take into account any contextualinformation.
even codis which is a recent algorithmthat combines the information about the co occurrences ofcommands in the same session with the command discoverypatterns cannot be considered as context aware when itgenerates global recommendations.
we conjecture that without taking into account contextual information the usefulness ofthe recommendations to the recipient s work is coincidental.
imagine an illustrative scenario which we also observed in the data set used in the evaluation.
by the end of the firstweek of usage of eclipse ide see anovice programmer executed distinct commands such aspaste build all and navigate back.
codis recommends to this user save save as run quick fix and open browser.
conversely recommending the most popular commands theuser would learn save run undo copy and content assist also called autocomplete .
naturally these commands arevery useful for any ide user and especially for that novice who is using eclipse for editing simple java code.
however these are the most basic functions provided by any ide andthe user will surely learn them quickly also by herself.
onthe other hand the context aware rs based on the algorithmproposed in this paper which we named cntx would suggestsimple but less obvious commands namely save all files run last reset perspective go to line start and showmarketplace wizard.
moreover after some more time whenthe novice user has already executed distinct commands our algorithm would also recommend two simple commands collapse all and go to text start and three advanced com mands execute open run configurations and incrementalfind.
but the other two algorithms would still be focused onsimple commands such as redo go to previous word selectnext word select previous word and show file properties.
hence as this example illustrates we believe that there .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research new ideas688 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is a great potential in context aware command recommender systems and this paper discusses their main advantages andalso their limitations.
in the rest of the paper we first present the basic characteristics of existing algorithms for generating global ide command recommendations sec.
ii .
then we present the proposed cntx algorithm sec.
iii and the offline evaluationmethod sec.
iv .
the results sec.
v show that by usingcontext the recommender is able to identify and suggestcommands that are less likely to be discovered without ars and are more useful for the working context than the commands recommended by existing algorithms.
at the end we draw the conclusions of our research results and outlinethe plans for the future work sec.
vi .
the main contributions of this paper are a novel contextbased algorithm for recommending ide commands a detailed discussion of the algorithm implementation and problemsresolution a novel context based metric for estimating thepotential usefulness of the recommended commands and anoffline evaluation of the existing algorithms.
ii.
r elated work murphy hill et al.
studied eight command recommendation algorithms namely most popular which recommendsmost frequently executed commands most widely used which recommends commands that are used by the largestnumber of users item based collaborative filtering cf and user based cf which recommend commands that aremost similar to those already used by the user or usedby similar users and advanced discovery most populardiscovery item based cf with discovery and user basedcf with discovery which are based on sequential patternmining that is combined with basic collaborative filteringalgorithms or popularity based algorithms.
to evaluate theseeight algorithms murphy hill et al.
performed offline andonline evaluations.
in the offline evaluation they applied the k tail evaluation method suggested by li et al.
which measures the ca pability of an algorithm to predict commands that the usereventually used.
advanced discovery algorithm achieved thehighest score which was noticeably higher than the scoresof most popular user based cf and item based cf andrelatively similar to the scores of other algorithms.
in the special k tail evaluation where a command was treated as being discovered only if it was used multiple times or in multiple sessions the highest score was achieved by userbased cf with discovery.
in the online evaluation murphy hill et al.
recruited four experts and nine novices.
the participants were asked to ratethe usefulness and novelty of recommendations.
the resultsshow that for the novices user based cf most popular anditem based cf with discovery generated the largest proportion of useful and novel recommendations.
for the experts the item based cf with discovery algorithm was the onlyalgorithm that performed relatively well.recently zolaktaf and murphy proposed codis which is an algorithm based on the analysis of command discovery patterns and co occurrence of command executions in work sessions.
in an offline study codis outperformed all otheralgorithms in terms of the k tail metric when the number of observed top n recommendations is larger than for n user based cf with discovery outperformed codis.
it is worth noting that the aforementioned algorithms were designed to accurately predict which commands an ide user will discover and start using autonomously.
nevertheless weargue in this paper that it is also important for a recommenda tion algorithm to identify commands which a recommendationrecipient can and will use during the work but are not likely tobe discovered without the help of a rs.
we think that in sucha case an ide command rs is especially valuable.
hence weconjecture that by employing information about the contextsin which a developer works and in which different commandsare usually executed it is possible to provide such a type ofrecommendations.
iii.
cntx c ontext based ide c ommand recommendation generation algorithm we apply a probabilistic model to generate personalized context aware novel and useful command recommendations.the recommendation score of a command afor a user uis defined to be p a u which is the probability of observing the usage of a assuming that uknows a. commands with the highest recommendation score should be recommended first top n .
we assume as in that the rs users are only interested to receive recommendations of commands that they are not aware of i.e.
have never been executed by the user.
the input data for the recommendation algorithm was collected by logging the ide interactions of first year bachelorstudents at the free university of bozen bolzano during thefirst ten weeks of the introduction to programming course.
the data collection was completely anonymous.
the data setcontains command execution records.
each record is a tuple u a t c where tis the timestamp and cis the context in which uexecuted a. overall we detected different user identifiers and different commands.
each context is a set of values for different contextual factors.
weused the context model proposed by gasparic et al.
whichconsists of eleven contextual factors namely type length and complexity of the artifact under development current and previous activity time of the day day of the week ide instance active perspective opened user interface elements and user interface element with focus.
an example of the interaction history log is presented in tab.
i the columnsfollowing timestamp refer to the contextual factors.
a user ucan be described by a set of contexts c uthat were detected when she executed commands.
the probabilityp a u that acan be executed by u if she knows a i s estimated as p a c u which is the probability to observe the execution of ain the population of users that know and use a given a set of contexts in which uworked.
assuming that the contexts are alternative we define p a u as the average authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i user ide interaction data log example .
command iduser idtimestamp artifact type ...uiwith focus undo a .html ... editor collapseall a .java ... editor linestart b .java ... console ... ... ... ... ... ... undo x .java ... expressions value of the probabilities p a c to observe the execution of a given the u s context c. hence the scoring function is defined as follows score u a p a u p a cu cu c cup a c to estimate p a c for each command a we train a regression model for each command a on a set of contexts extracted from the ide interaction history logs of the users who are using a. the regression model is trained to predict a boolean variable indicating whether awill be executed when a specific context cis detected.
the score calculated by the regression model for the context cis considered as the probability p a c to observe agiven c. to train a regression model categorical variables should be transformed into continuous .
since the values of ourcontextual factors are nominal i.e.
cannot be ordered wetransform each value of a contextual factor into a binaryvariable.
for example if the contextual factor type of the artifact under development can have .html and .java values see artifact type column in tab.
i two binary variables are created artifact type .html and artifact type .java and the values of artifact type .html are equal to 1for the rows where artifact type contains .html and 0otherwise see artifact type .html column in tab.
ii .
moreover since regression models trained with few observations are unreliable we limited the set of recommendablecommands to those for which we have at least mobservations.
we tested different parameter values and finally set mto since this value yields the best results in the offline evaluationreported in this paper.
furthermore in order to improve the accuracy of the regression model and to compress the transformed data set whichcontains a large number of potentially correlated columns we performed dimensionality reduction .
we appliedlatent semantic indexing lsi which uses singularvalue decomposition to identify a linear subspace of the fullfeatures space that captures the largest part of the variance in the collection.
if we consider the generated binary variablesasfeatures we could have applied lsi directly however since the number of rows i.e.
observations of the command executions is large we trained lsi with a random sampleof observations from the interaction history log.
this without losing the quality ensures that the calculations can be per formed in minutes and not in hours or days.
by setting the number of features to and the maximum size of the sample to command execution records lsi explains ofthe training data variance even though the initial data setcontains more than features.
we used this configuration also in the offline evaluation.
the class imbalance problem was the last issue to solve before we could train the regression model.
the number of executions of any command ais much lower than the number of executions of non a commands i.e.
commands other than a. consequently any trained model learned on the full data set would be biased to predict that command ais never executed regardless of the context.
to solve this problem we adopted random undersampling for each command regressionmodel we included in the training data all the observations of the command aexecution and an equal number of randomly picked observations of executions of the other commands.
finally for each command the training data represented with the selected latent features was used to train a regression model that predicts p a c .
in our experiments we considered three linear regression models ridge adaboost with alinear loss function and adaboost with an exponential lossfunction .
the ridge regressor is based on the linear leastsquares loss function and uses l norm regularization to avoid model s overfitting.
an adaboost regressor is a meta estimator that begins by fitting a regressor on the original data set andthen fits additional copies of the regressor on the same dataset with adjusted weights assigned to instances which arelarger for instances where the regressor is wrong.
in that way subsequent regressors focus more on difficult cases.
the ridgemodel has been used as a component of the adaboost models.
to identify the most suitable regression model for a command we conducted a five fold random cross validation test over a set of candidate models.
the model with the highestaverage score according to the r 2metric was selected.
the r2metric also called coefficient of determination is a regression score function that measures how well future samples are likely to be predicted by the model.
iv .
o ffline ev aluation method we conducted an offline experiment to evaluate rs algorithms.
with an offline experiment one can efficiently compare a wide range of algorithms and estimate their quality byusing some proxy metrics before the rs is deployed to realusers.
typically these types of experiments are simple and inexpensive if compared to user studies and online evaluations as they require no interaction with real users.
however offline experiments can only answer a narrow set of researchquestions since the data sets collected before the deploymentof the rs cannot be used for measuring the rs s effect onuser behavior in a real world setting .
in our empirical evaluation we have compared cntx with the algorithms listed in sec.
ii.
we used the data set describedin sec.
iii.
since the participating students were enrolled in anintroductory course they were expected to have none or verybasic programming knowledge.
consequently the assigned tasks were focused on java syntax.
to allow a fair comparisonand meaningful analysis of the evolution of the metrics overthe weeks we limited the testing set to students who used authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii binarized interaction data log example .
command iduser idtimestamp artifact type .html artifact type .java ...uiwith focus editor uiwith focus console ...uiwith focus expressions undo a ... ... collapseall a ... ... linestart b ... ... ... ... ... ... ... ... ... ... ... ... undo x ... ... the ide for at least five weeks.
for each user and with each algorithm we generated the top recommendations for eachdifferent week of usage by using the data observed in thepast.
previous analyses benchmarked the proposed algorithmson a larger number of recommendations.
however in a real world setting only the very first recommended commands areusually browsed by the users.
we must observe that ide command usage history logs show only the actions that have been performed by the users and it is unclear why certain actions in particular executionsof specific commands have not been performed.
for instance when a command is never observed is this because the user isnot aware of its existence or has she deliberately decided not to use it?
secondly ide command usage history logs containcommands that have been discovered by the users withoutthe help of a rs and traditional offline evaluation metricsshow how well the recommender prediction model identifies commands that the user eventually used but they do not fully show whether the recommender identifies new and usefulcommands.
for instance the k tail evaluation method is measuring the accuracy of the recommendation algorithmin suggesting commands autonomously discovered by the user.
that is why we also introduce here a novel evaluation metric that measures the usefulness of the recommendations byconsidering the contexts in which users will actually executethe suggested commands.
a. usage prediction in our experiments to measure the accuracy of the algorithms predictions we considered precision recall and f1metrics .
these are popular rss evaluation metrics.
moreover we also adopted the k tail evaluation method to better relate our analysis to previous studies.
to perform the k tail evaluation and to compute precision recall and f1 the data must be split into training and testing sets.
the recommendations are generated by training the predictive model on the observations from the trainingset.
standard evaluation is based on the assumption that thecommands included in the testing set which have been used by the users are good recommendations higher similaritybetween the recommendations and the commands in the testingset indicates higher quality of the algorithm.
p recision measures how many items in the list of recommendations are relevant while recall shows how many of all the relevant items are included in the list of recommendations.
since there is usually a trade off between precision andrecall it is also common to measure f1 which averages harmonically the two metrics precision tp tp fp recall tp tp fn f1 precision recall precision recall where tp represents the set of correct recommendations often called true positives fp represents the set of incorrect recommendations often called false positives and fn represents the set of correct items that were not recommended often called false negatives .
the highest possible score off1is .
it is obtained if the algorithm recommends exactly all the relevant items.
to calculate precision recall and f1and to observe their evolution over time we split the command usage logs in tenweeks.
we generated a set of recommendations every week for the first weeks.
the data collected until wednesday 6am which is between the weekly assignment submission deadlinesand laboratory exercises was used as the training set.
the datacollected in the following one week was used as the testingset where the set of relevant recommendations is composedof the commands not already present in the training set.
conversely in k tail testing procedure the training set consists of the logs of the command executions that occurredbefore the user started using the last kcommands while the testing set consists of the commands that were executed forthe first time after that moment.
the testing set is used tocalculate hit ratio hr hr u u uhitu where uis the set of all users uandhituis a binary variable equal to when the recommended commands include at leastone of the last kcommands and equal to otherwise.
in our experiment kis equal to as in and which means that the testing set contains only the last discovered command.
b. contextual relevance in this paper we propose to relate the relevance of a command recommendation to the contexts in which the command has been executed.
in fact we know that the contexts inwhich the command is executed are the contexts in which the command is useful.
in other words in ideal conditions themost relevant command for a given context is the one that hasbeen observed most often in this context.
but since contexts are presented in a high dimensional space it is very unlikely authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to observe for a target user uexactly the same contexts that are observed in the training set.
hence we use a notion of similarity between the target contexts of the user and thecontexts in which the command has been executed to identifythe most relevant recommendations.
in particular the relevanceof a command ato a user ucan be defined as the average similarity between the contexts in which the command was used by the users that know and use it and the contexts in which the recommendation recipient worked during theperiod that is included in the testing set.
the more similar thetwo contexts are the more relevant ais to u. the contextual relevance is calculated as follows rel a u c u cu c u ca c a sim cu ca c a where c a is a set of contexts in which ahas been executed c u is a set of contexts in which uwas executing commands sim cu ca is the similarity between two contexts and ca andcuare a context where the command awas executed and the target context of user u respectively.
we use cosine similarity since we are interested in the correlation betweenfeatures of the different contexts .
the context aware usefulness metric ar ncalculates the average relevance of the top n recommendations for each user u u.i frec n uis the set of top n recommended commands then ar ncan be defined as follows ar n u u u ar rec n urel ar u n higher values indicate that more useful commands are recommended by the algorithm.
moreover ar npenalizes the algorithms that generate less than nrecommendations.
to calculate the weekly contextual relevance of the top commands for each user i.e.
ar we used the interaction history logs in the same way as for the calculation of precision recall and f1.
but instead of matching recommended commands to commands in the testing set we match the observed contexts of the users which were detected duringthe week that followed the recommendation generation mile stone with the contexts in which the recommended commandscan be effectively used.
we note that the source code of ar nand cntx is available at rs.
v. r esults the algorithms evaluated in our study generate very different recommendations as can be seen in fig.
.
here as anexample the word cloud created from the recommendationsproduced by the cntx and the most widely used algorithmsare shown.
it can be seen that the commands recommendedand their frequencies are dissimilar.
the results of the k tail evaluation tab.
iii show that advanced discovery has the highest hit ratio as in .
apart from that our results are in a disagreement with the previousstudies.
for instance most popular has higher hit ratio than most widely used and user based cf with discovery and fig.
.
recommendation cloud of cntx left and most widely used right algorithms in the fifth week of the study.
table iii results of k tail ev aluation .
algorithm hit ratio algorithm hit ratio most popular .
most widely used .
item cf .
user cf .
advanced discovery .
most popular discovery item cf discovery user cf discovery .
codis .
cntx .
codis have a very low hit ratio .
interestingly the lowest hitratio was achieved by our algorithm .
means that only out of students autonomously discovered and executed a command that would have been recommended to them by thecontext aware algoirthm.
hence according to the results of thek tail evaluation we expect that the proposed algorithm will recommend commands that the users would find really novel.
the average recall precision f1 and ar o ft h e considered algorithms during nine weeks are shown in fig.
.these results show that recall grows over time.
the main reason for this is that there are less and less commands in thetesting set every week.
for the same reason precision tends to decrease over time.
the only exceptions are offered by thealgorithms based on discovery patterns which do not provideany recommendations in the first weeks thus their precision is initially and later starts increasing.
in fig.
it can beseen that the ranking of the algorithms according to f1and precision is basically identical.
similarly to what we observed and discussed in the k tail evaluation we can conclude that cntx algorithm would recommend only a small set of thecommands that the students would discover autonomouslyduring the next week.
the only algorithm that would providemore novel recommendations is user based cf.
as the number of the commands that can be recommended decreases also the number of the recommendable commandswith the contexts similar to the users contexts decreasesover time.
consequently the ar 5scores tend to decrease with time.
nevertheless considering this metric the proposed cntx algorithm outperforms other algorithms in every week.
furthermore we can see that the popularity based algorithmsperform worse than how they performed with respect to f1.
but the ranking of the other algorithms remains almost thesame as for f1.
still it seems that the popularity based algorithms perform very well at the beginning which means thatrecommending popular commands to novices is reasonable.this result is also in agreement with the results of the online authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
.
.6recallmost popular most widely used item cf user cf advanced discovery most popular discovery item cf discovery user cf discovery codis cntx .
.
.6precision .
.4f1 .
.
weekar fig.
.
recall precision f1 and ar values of the algorithms per week.
evaluation performed by murphy hill et al.
.
however after the number of known commands by the users increases personalized algorithms tend to outperform popularity basedalgorithms while context aware algorithms have an evengreater potential.
vi.
c onclusions and future work in this paper we have presented a novel ide command recommendation algorithm that provides recommendations by taking into account the contexts in which a particular softwaredeveloper works and the contexts in which different commandsare usually executed.
the algorithm aims at suggesting thecommands that a recommendation recipient can and will useduring the work but which are not likely to be discoveredwithout the help of the rs.
since traditional metrics such as precision recall f1 and hit ratio only measure the accuracy of predicting the commands autonomously discovered bythe users we also introduced a novel evaluation metric thatmeasures the relevance of the recommendations in the contextsof the users.
we have compared the proposed algorithm with aset of state of the art algorithms on a real world data set.
theexperiments revealed that in terms of contextual relevance andrecommendation usefulness the proposed algorithm outper forms existing algorithms while the traditional metrics scoreit lower.
the explanation of this is that the proposed algorithmrecommends more novel commands to the user which are notlikely to be discovered without the help of the recommender.
in the future we plan to conduct an online experiment on a smaller set of algorithms to evaluate the rs s effect on the user behavior in a real world setting.
moreover wewill consider designing and testing hybrid algorithms withthe aim to obtain the benefits of the popularity collaborativefiltering and context based algorithms while decreasing theirdrawbacks.
r eferences ieee comp.
soc.
p. bourque and r. e. fairley guide to the software engineering body of knowledge.
ieee computer society press .
t. grossman g. fitzmaurice and r. attar a survey of software learnability metrics methodologies and guidelines in conference on human factors in computing systems .
m. gasparic a. janes f. ricci and m. zanellati gui design for ide command recommendations in international conference on intelligent user interfaces .
m. gasparic a. janes f. ricci g. c. murphy and t. gurbanov a graphical user interface for presenting integrated development environment command recommendations design evaluation and implementation inf.
softw.
tech.
.
e. murphy hill r. jiresal and g. c. murphy improving software developers fluency by recommending development environment com mands in international symposium on the f oundations of software engineering .
m. gasparic and f. ricci should context aware ide command recommendations always be presented in context or not?
in workshop on awareness interfaces and interactions .
m. gasparic g. c. murphy and f. ricci a context model for idebased recommendation systems j. syst.
softw.
vol.
pp.
.
s. zolaktaf and g. c. murphy what to learn next recommending commands in a feature rich environment in international conference on machine learning and applications .
w. li j. matejka t. grossman j. a. konstan and g. fitzmaurice design and evaluation of a command recommendation system forsoftware applications acm trans.
comput.
hum.
interaction vol.
pp.
.
y .
hu y .
koren and c. v olinsky collaborative filtering for implicit feedback datasets in international conference on data mining .
g. james d. witten t. hastie and r. tibshirani an introduction to statistical learning with applications in r. springer .
s. koranne handbook of open source tools.
springer .
s. deerwester s. t. dumais g. w. furnas t. k. landauer and r. harshman indexing by latent semantic analysis j. amer .
soc.
inf.
sci.
vol.
pp.
.
h. he and e. a. garcia learning from imbalanced data ieee trans.
on knowl.
and data eng.
vol.
pp.
.
c. m. bishop pattern recognition and machine learning.
springer .
a. gunawardana and g. shani evaluating recommender systems in recommender systems handbook.
springer .
x. amatriain and j. m. pujol data mining methods for recommender systems in recommender systems handbook.
springer .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.