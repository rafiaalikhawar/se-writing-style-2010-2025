understanding gcc builtins to develop better tools manuel rigger johannes kepler university linz austria manuel.rigger jku.atstefan marr university of kent united kingdom s.marr kent.ac.uk bram adams polytechnique montr al canada bram.adams polymtl.cahanspeter m ssenb ck johannes kepler university linz austria hanspeter.moessenboeck jku.at abstract c programs can use compiler builtins to provide functionality that the c language lacks.
on linux gcc provides several thousands of builtins that are also supported by other mature compilers such as clang and icc.
maintainers of other tools lack guidance on whether and which builtins should be implemented to support popular projects.
to assist tool developers who want to support gcc builtins we analyzed builtin use in c projects from github.
we found that of these projects relied on at least one builtin.
supporting an increasing proportion of projects requires support of an exponentially increasing number of builtins however implementing only builtins already covers over of the projects.
since we found that many builtins in our corpus remained unused the effort needed to support of the projects is moderate requiring about builtins to be implemented.
for each project we analyzed the evolution of builtin use over time and found that the majority of projects mostly added builtins.
this suggests that builtins are not a legacy feature and must be supported in future tools.
systematic testing of builtin support in existing tools revealed that many lacked support for builtins either partially or completely we also discovered incorrect implementations in various tools including the formally verified compcert compiler.
ccs concepts software and its engineering language features compilers .
keywords gcc builtins compiler intrinsics c github projects acm reference format manuel rigger stefan marr bram adams and hanspeter m ssenb ck.
.
understanding gcc builtins to develop better tools.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
.
.
esec fse august tallinn estonia copyright held by the owner author s .
publication rights licensed to acm.
this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version of record was published in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia introduction most c programs consist not only of c code but also of other elements such as preprocessor directives freestanding assembly code files inline assembly compiler pragmas and compiler builtins.
while recent studies have highlighted the role of linker scripts and inline assembly compiler builtins have so far attracted little attention.
builtins resemble functions or macros however they are not provided by libc but are directly implemented in the compiler.
the following code fragment shows the usage of a gcc builtin that returns the number of leading zeros in an integer s binary representation int leading zeroes builtin clz int max returns on linux we observed that gcc builtins are widely used and are also supported by other mature compilers such as clang and icc .
for developers working on tools that process c code such as compilers as well as static and dynamic analysis tools implementation and maintenance of gcc builtins is a large effort as we identified a total number of gcc builtins all of which are potentially used by projects and thus need to be supported.
hence to assist developers of tools that process c code the goal of this study was to investigate the use of builtins and how current tools support them.
to this end we analyzed the builtin use of projects from github and implemented a builtin test suite which we used to test popular tools employed by c developers.
by combining quantitative and qualitative analyses we answer the following research questions rqs rq1 how frequently do projects use builtins?
knowing the prevalence of builtins helps tool writers to judge the importance of implementing support for them.
we hypothesized that builtins are used by many projects and that any program that processes c code will therefore encounter them yet similar to inline assembly we expected that they are used in only a few source code locations.
rq2 for what purposes are builtins used?
knowing the primary use cases for builtins helps tool developers to judge whether their tools can support them.
for example static analysis tools might lack support for multithreading and hence be unable to deal with atomic builtins used for synchronization.
rq3 how many builtins must be implemented to support most projects?
tool authors who have decided to support gcc builtins would find it helpful to know the implementation order that would maximize the number of projects supported.
rq4 how does builtin usage develop over time?
understanding the usage of builtins over time could tell us whether projects continuearxiv .00863v1 jul 2019esec fse august tallinn estonia manuel rigger stefan marr bram adams and hanspeter m ssenb ck to add builtins or remove them.
if builtins were a legacy feature of compilers that projects sought to remove the incentive of tool developers to implement them would be low.
rq5 how well do tools support builtins?
to determine the room for improvement in tools we examined how well existing tools support builtins.
our assumption was that state of the art compilers such as gcc clang and icc provide full support while other tools provide partial or no support.
we found the following gcc builtins exist but only were used in our corpus of projects of the projects used builtins.
projects primarily used architecture independent builtins for example to interact with the compiler for bit level operations and for atomic operations.
however when a project would use an architecture specific builtin it would often be used many times in the same project.
while mature compilers seem to provide full support for builtins most other tools lack some builtins or have some implemented incorrectly.
notably we found two incorrectly implemented gcc builtins in an unverified part of the formally verified compcert compiler.
the effort of supporting a specific number of projects rises exponentially for example to support half of the projects only builtins are needed.
supporting of the projects however requires about builtins.
over time most of the projects increasingly used builtins nevertheless a number of projects removed builtin uses to reduce maintenance effort.
our results are expected to help tool developers in prioritizing implementation effort maintenance and optimization of builtins.
thus this study facilitates the development of compilers such as gcc clang icc and the formally verified compcert compiler of static analysis tools such as the clang static analyzer splint frama c and uno of semantic models for c and of alternative execution environments and bug finding tools such as klee sulong the llvm sanitizers and softbound .
for reproducibility and verifiability we provide the database with gcc builtin usage test suite tools used for the analysis and a record of the manual decisions on .
methodology to answer our research questions we analyzed builtin use in a large number of c projects and populated a sqlite3 database with the extracted data.
as detailed below we downloaded and filtered projects from github on which we performed a textual search for the names of the gcc builtins.
to identify the builtin names we extracted them from the official documentation and from the gcc source code.
to exclude false positive identifications of builtin use we applied heuristics such as excluding builtin names inside string literals and comments.
selecting the projects.
we analyzed projects from the popular github code hosting service.
similar to other large empirical studies we selected projects based on popularity specifically the number of github stars .
to obtain about projects we downloaded projects down to stars.
this cutoff point was sufficiently large to prevent the inclusion of personal projects homework assignments and forks .
in total we downloaded github projects that contained in total million lines of c code.
this strategy allowed us to obtain a diverse set of projects see table .
to provide further evidence for the diversity of the projects we computed nagappan et al.
s coverage score .
for this we used the manually validated github project metadata of munaiah et al.
s reporeapers data set which contained of our studied projects.
this subset alone obtained a coverage score of .
with respect to the universe of c projects in the reporeapers data set.
this indicates that our project sample is both representative and diverse.
table overview of the projects obtained after filtering the first commit in stems from a project that was converted from another version control system.
metric minimum maximum average median c loc 37m 228k 10k commits 668k committers 17k first commit last commit filtering the projects.
from the downloaded projects we selected by filtering out those that did not meet our needs.
first we filtered out all projects that had fewer than loc as we considered them too small to constitute c projects.
gcc forks of gcc1 and other c c compilers such as rose implement the gcc builtins themselves use them internally and exercise them in their test suites.
hence to avoid a high number of false positives we excluded these projects they were easy to identify as they contained the largest numbers of unique builtins.
identifying the builtins.
next we identified the names of the available gcc builtins to then perform a textual search on the github projects.
identifying the list of names was difficult since gcc builtins are not described or specified in a coherent manner as they were added over a period of more than years.
thus we investigated both i builtins listed in the gcc documentation as well as ii builtins internal to gcc which we automatically extracted from gcc s source code including test cases for builtins .
i builtins from the documentation.
initially we considered only builtins described by the gcc documentation.
the gcc documentation stated that some builtins are internal which we initially did not want to include as we expected that other projects would not use them.
while extracting the names of architecture independent builtins worked well gcc also provides builtins that are specific to an architecture.
for example builtin ia32 paddq allows the use of x86 s paddq instruction.
in some cases architecture specific builtins were not described by the documentation but referred to vendor documentation for example the arm c language extensions.
for these builtins the documentation of gcc version .
contained a list of builtins which we used instead.
however for certain special purpose architectures obtaining such a list was impractical 1the projects filtered out included the gcc fork for the xtensa processor https github.com jcmvbkbc gcc xtensa and a fork that is based on gcc to dump an xml description of c code gcc builtins to develop better tools esec fse august tallinn estonia for example for the tile gx and tilepro processor builtins.
as we expected little influence on the results overall architecturespecific builtins were used infrequently see section .
we omitted analyzing these special purpose builtins.
in total this process yielded builtins of which were architecture independent and were architecture specific.
ii builtins from the gcc source code to verify that we did not omit any commonly used builtins we searched the projects for strings starting with builtin .
since we found that many analyzed projects relied on a small number of gcc s internal i.e.
undocumented builtins see below we assumed that tool developers would also need to support these builtins.
hence we added them to our search terms by including all additional builtin functions that we found in the gcc source code and test suite additional builtins .
in a number of cases gcc implemented public builtins using undocumented internal builtins this was a potential problem in our study as public and internal builtins would be counted as separate even if they implemented the same semantics.
however since the number of internal builtins actually used was relatively small we did not attempt to match public builtins with internal ones in our quantitative analysis.
searching within the projects.
for each analyzed project we searched all its c files for the names of the builtins described by the gcc documentation or used in the gcc source code.
note that we considered only occurrences where the builtin name was not a substring of another identifier.
for each builtin that we found we created a record in our database thus obtaining 659k builtin entries.
excluding builtin use records.
we used several strategies to eliminate false positives in the builtin use records.
while investigating the projects with the highest numbers of unique builtins mostly operating systems we found that many of them included parts of the source code of clang or gcc even though the projects themselves were not compiler projects.
such projects were missed by our prior filtering.
for these projects we excluded directories whose name started with gcc clang orllvm excluding of our records .
we also excluded builtin occurrences that were enclosed in double quotes as this indicates that they are part of a string literal instead of part of the code excluding of the records .
to exclude builtins in comments we did not consider builtins found in lines that started with or which excluded of the records .
finally we manually inspected a number of randomly selected uses for each distinct builtin which we used to create a list of one line code fragments that indicated false positives excluding of the records .
we consider this filtering step optional since it did not significantly reduce the number of builtin uses.
as part of this process we detected that builtins not starting with the builtin prefix i.e.
machine specific builtins were likely to cause false positives which is why we examined such builtin uses in detail.
for example the ti c6x architecture provided builtins like abs which often occurred in code that did not use builtins.
as another example inline assembly with an instruction mnemonic that corresponded to a builtin name often resulted in false positives.
in total these measures reduced the number of records to 319k of the original number .
results .
rq1 how frequently are builtins used?
to answer rq1 we considered both duplicate and unique builtin uses per project.
counting uses even if they were duplicated within a project allowed us to measure the overall prevalence of builtin use.
counting project unique uses better reflected the implementation effort needed to support a project because duplicates do not increase the implementation effort.
overall use.
in total of the projects of all projects used a common subset of builtins.
the frequency of compiler builtins varied strongly depending on the project and ranged from one builtin every loc to one every loc.
the median frequency of builtins was one every loc on average one builtin every loc .
figure shows boxplots to illustrate the builtin use by the projects and breaks their use up into architecture specific and architecture independent uses considering both unique and non unique builtin occurrences within a project.
non unique occurrences.
the median number of builtin calls in a project that used builtins was the average was indicating that there were outlier projects that used a large number of builtins.
in projects that used builtins architecture specific builtins were employed in greater numbers median in contrast when architecture independent builtins were used their numbers were far lower median .
however since use of architecture specific builtins is limited to fewer projects see section .
the overall result is dominated by the architecture independent builtins.
we investigated the projects with the highest numbers of builtins and found that audio video players and codecs lead the ranking followed by operating systems a game engine a software library specialized for arm processors and a libc implementation.
unique occurrences.
of the 319k builtin calls 30k were projectunique that is the others were duplicated within a project.
the median number of unique builtins used by projects with builtins was low with a median of and an average of .
as with non unique builtins projects that used architecture specific builtins had more such builtins median than projects that used architectureindependent builtins median .
the projects that used the largest number of unique builtins were again in most cases audio video players and codecs .
however operating systems game engines language implementations and compilers a messenger and an image codec also ranked among the top .
reoccurring files.
we observed that files with particular names primarily header files were more likely to contain calls to builtins.
one reason for this was that consistent with findings by lopes et al.
files were copied from other projects.
the majority of these files originated either from the gnu c library glibc or from linuxbased operating systems.
while they were used primarily in operating system implementations they were also copied to projects with application code.
as another example the frequently used sqlite3.c andsdl stdinc.h files even contained the projects names as part of the file name sqlite is a popular database and sdl a commonly used media library.
in other cases duplicate file names indicated the use case for the builtin use.
for example builtin based atomicity support was often implemented in files named atomic.h and math builtins were used in files named math.h .esec fse august tallinn estonia manuel rigger stefan marr bram adams and hanspeter m ssenb ck non unique occurrencesunique occurrences 10000machine independentmachine specifictotal machine independentmachine specifictotalcategory figure number of architecture specific and architectureindependent builtins per project that used builtins of the respective category logarithmic scale .
discussion.
we found that gcc builtins exist that tool developers potentially need to consider but that only about of these are used.
although a builtin is typically found only once every lines of c code of all popular projects rely on compiler builtins thus strongly incentivizing their implementation in analysis and other tools.
.
rq2 for what purposes are builtins used?
to identify the purpose for which builtins are used we explored their usage at different levels of granularity first we examined in detail the usage of architecture independent builtins and of architecture specific builtins as summarized in figure .
then we analyzed builtins that remained unused in our corpus.
architecture specific and independent builtins.
the gcc documentation categorizes builtins into architecture specific and architecture independent ones which we used as a basis for discussion.
while projects used at least one architecture independent builtin we found architecture specific builtins in only projects.
that architecture independent builtins are more common across project was unexpected since we found only 85k architectureindependent builtin uses but 213k architecture specific ones.
however as discussed in section .
a project using architecture specific builtins is likely to use more such builtins than projects that use architecture independent builtins.
other builtins.
the builtin category other which contained miscellaneous builtins was the most common category of gcc builtins even though it comprised only builtins of which were among the most frequently used.
since these builtins were the most common we further analyzed their use and classified them into the following subcategories i direct compiler interaction ii bit and byte operations iii special floating point values and iv dynamic stack allocation.
i direct compiler interaction.
these builtins allow direct interaction with the compiler for example to improve performance the most frequently used builtin was builtin expect which communicates expected branch probabilities to the compiler which can exploit this information for optimization.
the builtin unreachable builtin can be used to silence warnings by informing the compiler that code is unreachable whichis useful when the compiler cannot deduce this.
some of the builtins in this subcategory can also be used for metaprogramming the builtin constant p builtin is resolved at compile time and allows programmers to query whether a pointer is known by the compiler to be constant.
as another example builtin types compatible p queries whether two input types passed to the builtin are the same.
plain c does not offer similar functionality.
ii bit and byte operations.
these builtins process integers at the level of bits and bytes.
the second most frequently used builtin was builtin clz which counts the leading zeroes in an unsigned int its variants for other data types also ranked among the most commonly used builtins overall.
similarly frequent were builtins for computing the position of the least significant one bit for counting the number of one bits in an integer and for reversing the bytes of an integer.
we believe that these builtins were used for convenience and performance optimizations as the same functionality could be implemented in plain c. iii special floating point values.
these builtins generate special values for various floating point types.
for example the builtin inf builtin generates a positive infinity double value.
as another example builtin nan returns a not a number value.
recent c standards specify macros and functions for obtaining such values.
iv dynamic stack allocation.
the builtin alloca builtin allocates the specified number of bytes of stack memory.
since c99 variable length arrays have offered a similar functionality as the size of an allocated array can depend on a run time value.
synchronization and atomics.
after other the next common builtin category was synchronization sync with of the most common builtins.
in this category the most frequently used builtin was sync synchronize which issues a full memory barrier to restrict the order of execution in out of order cpus.
builtins for atomically executing operations were also common e.g.
sync fetch and add .
these builtins were designed for the intel itanium abi and were deprecated in favor of the builtins contained in the atomic category.
the builtins in the atomic category additionally allow specifying the memory order of the operation but were not that frequently used nevertheless builtins of this category ranked among the most common builtins.
note that c11 introduced synchronization primitives which are alternatives to these builtins.
libc functions.
gcc provides builtins for many functions of the standard c library such builtins were amongst the most common builtins.
an example is builtin memcpy which implements the semantics of memcpy .
the builtin version of the libc function is useful when compiling a program assuming a c dialect in which a function is not yet available for example when compiling under the c90 standard std c90 the newer c99 function log2 cannot be used however the prefixed version builtin log2 can still be used.
furthermore they enable bare metal programs which are compiled freestanding and therefore do not have access to libc functions unless they use compiler builtins.
gcc internal functions.
several builtins were used by projects although they were not documented ranked among the top frequently used builtins.
these most frequently used builtins namely builtin va start builtin va end understanding gcc builtins to develop better tools esec fse august tallinn estonia builtin va arg and builtin va copy were used exclusively to implement the vararg macros of the c standard.
function return address and offsetof.
the introspection category with of the top builtins enables programmers to query i the address to which a function returns and ii the address of the current frame i.e.
the area where local variables are stored .
to this end gcc provides builtin return address builtin frame address and other builtins.
another similar category is offsetof with a single builtin builtin offsetof which was one of the top builtins.
it determines the offset of a struct or array member from the start address of the struct or array.
object size and safe integer arithmetics.
the builtin builtin object size in the object size category enables programmers to query the size of an object which is useful when implementing bounds checks.
to implement this builtin gcc relies on static analysis to determine the size of an object where possible.
the overflow category of which no builtin ranked among the top provides wraparound semantics for overflow in signedinteger operations e.g.
builtin add overflow for addition which would otherwise induce undefined behavior in c .
usage of architecture specific builtins.
of the mostfrequent builtins were specific to an architecture.
most frequent were the builtins for the powerpc family of which were among the top builtins.
the most frequent powerpc builtins were those implementing vector operations such as vec perm which implements a vector permutation.
the second category were arm c neon extensions of which were among the top builtins that also implement vector operations.
on x86 which ranked next the most common builtin was builtin cpu supports followed by builtin cpu init which allow programmers to query the availability of cpu features such as simd support.
in x86 inline assembly the equivalent cpuid instruction ranked among the most commonly used instructions .
other x86 builtins were quite diverse and less frequent.
for brevity the less frequently used architecture specific builtin categories are omitted.
however they are included in the full list of commonly used builtins in the online appendix.
unused builtins.
to identify unused builtins we considered only those described in the gcc documentation i.e.
the public ones .
surprisingly we found that half of them namely were not used in our corpus.
the distribution differed between architecture specific and architecture independent builtins.
from the architecture independent builtins of were used which corresponds to unused builtins.
we characterize these unused builtins below.
from the architecture specific builtins only of builtins were used which means that more than half of them were not used in any project this is why we do not characterize them in detail.
we contacted the gcc developers to report our findings they responded that builtins could not be removed from the documentation due to vendor guarantees for architecture specific builtins and because they might still be used in closed source software or by projects not hosted on github.
while the possibility cannot be excluded that these builtins are used by some projects or code yet to be written the possibility that all of them are usedis rather low.
thus our study provides a first step towards deprecating unused builtins and removing those builtins from the public documentation that could be considered internal.
unused architecture independent builtins.
none of the projects used any of the bounds checking builtins for controlling the intel mpx based pointer bounds checker instrumentation which is based on a hardware extension in intel processors.
one reason for this is that they are used by a pass within gcc and have received only little further attention as intel mpxbased approaches perform only about as fast as pure software approaches .
four of the object size checking builtins were not used namely a subset of those for printing format strings e.g.
builtin vfprintf chk .
the builtins of this category were derived from library functions e.g.
memcpy but require an additional size argument e.g.
builtin memcpy chk .
the intended use of these builtins is to prevent buffer overflow attacks since object accesses that exceed the size of the object can be prevented.
we speculate that these builtins were not frequently used because neither the c language nor builtins provide the functionality to reliably query the size of an object which would require run time support .
none of the builtins of the cilk plus c c language extensions which offer a mechanism for multithreading were used.
in cilk plus was deprecated and in november gcc removed its implementation .
of the prefixed libc functions were unused.
most programs are probably compiled in hosted mode where compilers can substitute calls to the libc functions with these builtins.
another reason could be that some of them are used only internally.
nevertheless they were documented in the public api.
of the unused builtins in the other category the majority were narrowly specialized builtins such as builtin inffn which generates an infinity value for the data type floatn .
further builtin clear cache for flushing the processor s instruction cache remained unused.
the unused builtin call with static chain enables calls to languages that expect static chain pointers such as go.
discussion.
the use cases for builtins were diverse.
the use of gcc builtins was dominated by architecture independent builtins for direct interaction with the compiler for bit and byte operations atomic operations and libc equivalents.
depending on the tool different builtin categories could be supported to different degrees for example static analysis tools that do not analyze the semantics of multithreaded atomic operations might eschew implementing those.
architecture specific builtins were used by fewer projects but within these projects in greater number than architectureindependent builtins.
they were used for simd instructions to determine cpu features and to access platform specific registers.
.
rq3 how many builtins must be implemented to support most projects?
in order to provide tool developers with a recommended implementation order for builtins we considered two implementation scenarios.
the first scenario considered all builtins as implementation candidates.
the second considered only architecture independentesec fse august tallinn estonia manuel rigger stefan marr bram adams and hanspeter m ssenb ck architecture independent architecture specific othersync other libc gcc internaladdressatomicoffseto object sizoverflowvector powerpc altivecarm c extensionsx86alphablackfin fr v read writtile gx mips loongsonarc arm floating point statusaltera nios iimsp430 powerpc transactionsmips simmips dspavr mips other armv8 m security extensionspowerpc s390 systemzx86 transactions050010001500 projects figure the number of projects that rely on architecture independent and architecture specific builtins.
builtins which can be relevant when only a subset of architectures is to be supported.
additionally we assumed two pragmatic strategies for the order of implementation an order based on the frequency of builtins and one based on a greedy algorithm.
note that this paper assumes equal weights across projects since weights would have biased the results based on assumptions that might not hold for all tools.
frequency order.
using this strategy we assumed that the builtins used by the highest number of projects are to be implemented first.
thus this strategy follows the order given by table .
this order is not generally optimal because it does not take into account that in order for a project to be supported all builtins used must be implemented.
greedy order.
for rapid experimentation it can be beneficial to quickly support as many projects as possible.
to this end we implemented a greedy order where the next builtin to be implemented is selected such that it enables support of the largest number of additional projects.
if no such builtin exists the next builtin is selected using the frequency order.
results.
implementing builtins takes an exponential implementation effort in terms of number of builtins that must be implemented to support a specific number of projects see figure .
the greedy order for implementing builtins performs better than the frequency order a trend that is more clear cut when considering all builtins rather than just architecture independent ones.
to support half of the projects in both scenarios and using both strategies no more than builtins need to be implemented.
note that these builtins are all architecture independent ones this is expected because as described in section .
projects rely less frequently on architecture specific builtins but if they do they use a larger number of such unique builtins.
supporting of the projects requires builtins to be implemented for the greedy approach and builtins for the frequency strategy when considering only architecture independent builtins.
when considering all builtins more than builtins must be implemented for the frequency strategy and more than for the greedy strategy.
to support of the projects the greedy algorithm is better when considering only architecture independent builtins around instead of builtins must be implemented compared to instead of builtins when considering all builtins.
thus we suggest that tool developers use a greedy approach when implementing builtins.
implemented builtinspercentage of supported projectsfrequency frequency machine independent greedy greedy machine independent figure the numbers of builtins needed to support an increasing number of projects increases exponentially note the exponential x axis.
table the most frequent builtins.
builtin category projects builtin expect other compiler interaction .
builtin clz other bitwise operation .
builtin bswap32 other bitwise operation .
builtin constant p other compiler interaction .
builtin alloca other stack allocation .
sync synchronize sync .
builtin bswap64 other bitwise operation .
sync fetch and add sync .
builtin ctz other bitwise operation .
builtin bswap16 other bitwise operation .
.
rq4 how does builtin usage develop over time?
to understand whether builtin usage is an ongoing concern of software projects or just a form of technical debt introduced temporarily before being removed we studied the development of builtin usage over time in the projects that used builtins.
for this we analyzed all commits by iterating from the latest commit to the oldest commit including merge commits represented by the union of all commits that are merged always by following the first parent i.e.
staying on the master branch .
we considered only those projects for further inspection that had at least five commits that introduced or removed calls to builtins since projects with fewer commits made it difficult to judge a project s development trend.
this left us with projects of the projects for which we processed the builtin history.understanding gcc builtins to develop better tools esec fse august tallinn estonia table builtin trends in projects.
trend classification projects median commits increasingmostly increasing stable then increasing stagnantincreasing then stable spike then stable mostly stable decreasing inconclusive manual inspection methodology.
we manually classified the projects based on their trends of adding and removing builtins.
since manual classification of trends is partly subjective we performed manual classification based on negotiated agreement .
basically the three authors jointly open coded the qualitative data sources arriving at a classification through consensus.
given the lack of pre existing classifications such an approach seems justified.
in particular the three authors first independently classified a fixed set of randomly selected projects with respect to their builtin trends.
in of the cases all three authors agreed on the classification.
in of the cases two authors agreed.
in of the cases all authors disagreed.
subsequently the three authors discussed diverging classifications and came to a consensus for each of them.
as with other studies this initial classification served as a calibration phase for a single author to classify the remaining trends.
classification results.
the final classification consisted of four main categories of trends see table .
most prevalent was the increasing trend which we assigned to projects that mostly added builtins .
the majority of those showed a clear increasing trend while few had an initial stable period that was followed by an increasing trend .
the second most common trend was thestagnant trend for those projects that initially had builtinrelated commits but then did not show any or few further changes to the usage of builtins.
most stagnant projects initially added builtins then became stagnant .
others initially added builtin uses but then removed all or many of them shortly afterwards a development to which we refer as a spike and subsequently showed none or few further changes .
a low number of stagnant projects exhibited a mostly stable trend overall .
we assigned thedecreasing trend to projects that initially had an increasing trend followed by a decreasing trend i.e.
the removal of builtin uses .
finally we assigned the inconclusive trend to projects for which we could not clearly assign a trend e.g.
because they exhibited a combination of trends .
reasons for builtin additions or removal.
we attempted to find reasons for changes in the numbers of builtins for which we analyzed commit messages and commit changes then identified common cases.
builtin additions.
the majority of sharp increases in the number of builtins was caused by the inclusion of third party libraries that call builtins internally as indicated by commits such as update packaged sqlite to .
.
.
or added latest stb image.
in some cases only single existing header files were included as indicatedby commit messages such as add atomic.h that wraps gcc atomic operations or copy over stdatomic.h from freebsd.
builtins both architecture specific and independent ones were often used for performance optimizations.
example architectureindependent optimizations are popcount optimization for speed using builtin popcount use builtin expect in scanline drawers to help gcc predict branching and a prefetch of status last alloc tslot saved using builtin prefetch .
examples of architecture specific builtin commits were vp9 common for armv8 by using neon intrinsics and encoding speedup use neon for quantizeblock .
builtins were also used when they conveniently provided required functionality in commits such as bitmap add few helpers for manipulations .
they were often used for atomics as in gcc .
builtin atomic operations and adding atomic bitwise operations api and rwlocks support .
they enabled metaprogramming techniques for example by enabling macros to handle various data types util ensure align power2 works with things other than uint.
this uses a set of if builtin types compatible p statements to pick the correct alignment function tailored to a specific type .
finally builtins were employed to reduce the usage of assembly and inline assembly in commits such as avoid inline assembly in favor of gcc builtin functions and padlock engine make it independent of inline assembler.
or as an alternative to architecture specific system libraries such as alloca fallback for gcc which added a use of builtin alloca when the platform did not provide a header file that implements alloca .
builtin removals.
removals of third party libraries accounted for the most significant number of removals of builtins as indicated by commits such as remove thirdparties or removed outdated headers and libraries.
individual files or functions that used builtins were removed as side effects of refactoring or cleanup in commits with messages such as general cleanup of the codebase remove redundant files.
or tools remove unused code.
auto generated files were removed for instance in the commit removed getdate.c as it is regenerated from getdate.y .
a number of removals were related to technical debt .
projects removed builtins for old architectures for which they dropped support for instance in avr32 retire avr32 for good.
avr32 is gone.
or blackfin remove.
the architecture is currently unmaintained remove .
in other cases builtins for certain architectures were removed due to their maintenance effort remove support for altivec using gcc builtins since these keep changing across gcc versions.
.
uses of builtins were hidden behind a macro to concentrate their use to a single location in the source code convert remaining builtin expect to likely unlikely for builtin expect and use the new sol atomic.h api instead of directly gcc intrinsics for atomic operations .
in other cases a use of builtin expect was removed because it did not improve performance it had no reliably measurable performance improv ment at least on an i7 and within a microbenchmark.
.
case study.
finally we examined the builtin development in four projects whose trends we considered both representative and insightful for our case study see figure .
first we selected libucl esec fse august tallinn estonia manuel rigger stefan marr bram adams and hanspeter m ssenb ck libucl libav tinycbor sheepdog .
.
.
.
.
.
.
.
datenr builtins figure builtin development in tinycbor hashcat libav and libucl.
a configuration library parser which is representative of the increasing trend.
like the majority of projects that we examined it added a small number of builtin calls for various tasks.
we selected libav a collection of cross platform tools to process multimedia formats and protocols to represent the decreasing category.
as is typical of a media library it contained a number of builtin related commits that improved performance by adding calls to architecturespecific builtins but also systematically removed them to reduce maintenance effort.
we selected tinycbor a library for encoding and decoding the cbor format to represent the stagnant trend.
specifically we classified it as increasing then stable .
finally we selected sheepdog a distributed storage system for the qemu virtual machine which we classified as inconclusive due to its pit shape in the center of the plot.
libucl increasing .
the builtin additions in libucl were in most cases related to hashing.
the first two builtin related commits of libucl imported a hash algorithm from third party libraries that used builtin clz and builtin swap32 in their hashing computations.
subsequently a third party library hashing implementation was replaced with a custom implementation removing a builtin use.
subsequent commits were also related to finding better hashing algorithms resulting in additions of calls to byteswap builtins and checks for simd support using builtin cpu init and builtin cpu supports .
additionally the library added a reference counting scheme to free memory when an allocation is no longer referenced whose implementation depended on atomics.
libav decreasing .
in the first half of libav s development its use of builtins mainly increased mostly due to altivec specific builtins used to optimize computation intensive operations but also due to architecture specific builtins of other architectures such as powerpc or arm.
in a few cases calls to architecture independent builtins were added for example for atomics.
in the second half of the project refactorings reduced the number of builtin calls.
in calls to altivex specific builtins were removed to reduce technical debt and improve the maintainability of the snow codec which was removed in remove altivec optimizations for snow.
they are hindering the development of snow which is still in flux.
in calls to builtins were removed as part of a cleanup that dropped an unused function in the same year a library was removed that used builtins.
in another smaller but interesting commit removed calls to alpha specific builtins as the platform was no longer considered important remove all alpha architecture optimizations.
alpha has been end of lifed and no more test machines are available.
tinycbor stagnant the initial commit introduced macros for performance optimizations that used builtin expect to communicate branch probabilities to the compiler one of the macros was used to annotate an error handling case as unlikely.
similarly the builtin unreachable builtin was used to annotate the case that should not happen as undefined allowing the compiler to generate more efficient code.
to support byteswap operations on non linux systems where the endian.h header file is typically not present a use of builtin bswap64 was added.
a subsequent commit also introduced byteswap uses for linux systems with the commit message stating that it was more efficient and made cross building the project easier.
the builtin add overflow was added to implement an addition that does not cause undefined behavior on overflow .
three commits that did not change the number of used builtins adjusted the conditions when builtins were used due to portability reasons.
for example according to the commit messages builtin bswap16 was added with gcc .
and icc did not support builtin add overflow making it necessary to check for these cases using macros.
while the last builtin related commit was in the project continued to be active until .
sheepdog inconclusive in sheepdog the prominent increase before the pit was caused by a commit that replaced mutex locks by equivalent synchronization builtins as it was stated to make the execution faster.
the uses were then replaced with calls to an external library that offered equivalent functionality resulting in the sharp decrease.
other commits replaced an assembly fragment that obtained the address of the frame pointer with builtin frame address for logging.
the builtin in turn was replaced by invoking gdb to perform this action.
the performance of logging was improved by builtin expect which was used to annotate code to assume the standard logging level.
besides bit operations were simplified using builtin clzl and builtin ffsl .
discussion.
we analyzed the development history of builtins in projects and found that many projects mostly added calls to builtins.
they were added for performance optimizations atomic implementations to enable metaprogramming techniques and others they were removed for example due to their maintenance cost and through refactorings.
overall it seems that compiler builtins are not a legacy feature from times when compilers applied less sophisticated optimizations tool developers must expect that contemporary and future code will use them.
the four representative projects gave insights into how projects added and removed builtin uses.
like the majority of projects we examined libucl tinycbor and sheepdog had few commits related to architecture independent builtins.
these builtins were used in various use cases for instance to improve the performance of code to test for cpu features to implement hash computations and as a fallback when architecture specific builtins were missing.
libav was one of the relatively few projects that had a large number of commits related to architecture specific builtins and it reduced their number during code refactorings.
for sheepdog and libav builtins were also removed to reduce technical debt in sheepdog understanding gcc builtins to develop better tools esec fse august tallinn estonia gcc .
clang .
icc .
.
klee .
sulong c710bf2 dragonegg .
frama c chlorine cilly .
.
kcc .
compcert .
tcc .
.
executed test cases correct other error missing incorrect figure the test case results before bugs were fixed or builtins implemented.
the order of the legend items corresponds to the order of the stacked plots.
other errors refers to failed test cases unrelated to builtin support.
builtins were replaced by using an external library instead and in libav they were removed since an outdated architecture was no longer supported.
.
rq5 how well do tools support builtins?
to determine how well current tools support gcc builtins we manually implemented a builtin test suite for the most commonly used architecture independent builtins cf.
rq2 which would support the architecture independent portion of almost of the builtin using projects see section .
.
for each builtin we used its documentation to determine both typical inputs and corner cases then wrote test cases for them.
as tools to be tested we selected popular and widely used mature compilers special purpose compilers source to source translators alternative execution environments and static analysis tools.
figure shows the results.
mature compilers.
we tested the most widely used opensource compilers on linux gcc and clang as well as the commercial icc.
they all executed the test cases successfully.
special purpose compilers.
we tested the special purpose compilers compcert and tcc.
compcert is a compiler used in safety critical applications and has been formally verified to be correct which however excludes its implementation of builtins.
we found that compcert correctly executed only builtin test cases supporting out of the most frequently used builtins.
both builtin clzl and builtin ctzl computed an incorrect result for large input values .
after reporting the bugs detected by our test suite they were fixed within a day with the note that we need more testing here .
the tcc compiler is a small compiler developed to compile code quickly.
it successfully ran only six builtin test cases.
while most tests failed with a build error the builtin types compatible p builtin produced an incorrect result when comparing enumerations .
c front end.
the c intermediate language cil is a front end for the c language that facilitates program analysis and transformation.
we tested its driver called cilly which can also be used as a drop in replacement for gcc.
it successfully executed builtin test cases.
the builtin bswap16 and builtin types compatible p builtins produced incorrect results .
cilly also failed on atomic test cases on test cases due to a failure to parse a system library on test cases due to unrecognized builtins and on test cases due to warnings for the long double type.
source to source translators.
we evaluated dragonegg which compiles source languages supported by gcc to llvm ir.
although it has not been updated for several years it successfully executed more than two thirds of the test cases.
it failed to translate more recent builtins e.g.
from the atomic category that were added to gcc after the last commit in dragonegg.
static analysis.
we tested frama c a static analysis framework.
by default it assumes code to be portable and supports compiler extensions only with an option.
for test cases framac s analysis did not trigger a warning or error .
test cases failed because its standard library lacked macros for infinity and nan which were used in the test cases.
test cases for sync builtins were generally supported but incorrectly implemented for thelong type.
furthermore builtin object size referred to an undefined variable in its macro which resulted in an error.
alternative execution environments.
we tested sulong an interpreter with dynamic compiler for llvm based languages and kcc a commercial interpreter for c that was automatically derived from a formal semantics for c and detects undefined behavior.
sulong successfully executed all but two test cases namely for builtin fabsl and builtin clear cache which were not implemented .
note that we found these errors with a preliminary version of the test suite and consequently contributed implementations for the two missing builtins.
kcc successfully executed test cases for builtins but since it is based on cil it had the same error in the implementation of the builtin types compatible p builtin.
the kcc developers also mentioned that they have recently been trying to add more supports for gnuc builtins.
.
symbolic execution engine.
we tested klee a symbolic execution for llvm based languages.
klee executed all test cases successfully when executed with concrete inputs.
discussion.
our findings indicate that mature compilers support builtins which is expected since many projects rely on them.
however many other tools lack builtin implementations or have errors in their implementations.
note that working builtin implementations can typically not be reused by other tools due to their differences in use cases and implementation languages.
for example while gcc translates builtin usages to efficient machine code in its c c source code frama c abstractly reasons about them using ocaml.
tools based on existing mature compiler infrastructure such as klee and sulong which are based on llvm seem to have a better builtin support partly because some builtins are handled by the compiler s front end.
threats to validity internal validity.
the main threat to internal validity i.e.
risk of confounding variables is that we relied on a source based heuristic approach to determine the usage of gcc builtins namely by searching for identifiers of known builtins in the source files.
we could have mistakenly recorded a builtin use when the builtin wasesec fse august tallinn estonia manuel rigger stefan marr bram adams and hanspeter m ssenb ck enclosed in a comment or when an identifier with the same name as a builtin was used for another purpose.
however as described we used several mitigation strategies to address such deceiving uses.
conversely we could have missed builtin uses if their names consisted of strings that were concatenated by using preprocessor macros however we expect such uses to be uncommon.
rq4 required manual effort for classifying projects based on their use of builtins as they evolved and selecting representative projects which is both difficult to reproduce and subjective.
to address this we had a calibration phrase where three authors performed a classification of of the projects.
construct validity.
the main threat to construct validity is that the implementation order we suggest might not reflect the needs of developers.
in all implementation scenarios we assumed that each project has equal weights.
in practice tool developers might prioritize one project domain over another and might thus implement builtins in a different order.
for example developers of security analyzers would likely first want to support projects with a high attack surface while compilers for embedded systems would implement support only for embedded software.
we consider equal weights as a neutral and simple metric if not applicable developers can use our artifact to determine a better suited order.
external validity.
several threats to external validity i.e.
whether our results are generalizable are related to the scope of our analyses.
first besides c code c code also can access gcc builtins which we considered beyond our scope so our results cannot be generalized to c projects.
we analyzed open source github projects hence our findings might not apply to proprietary projects.
furthermore they do not necessarily apply to projects hosted on sites other than github this biases our results as for example gnu projects other than gcc are often hosted on savannah and could potentially rely more strongly on gcc builtins.
additionally our results cannot be generalized to the builtins of compilers other than gcc.
finally we investigated the usage of builtins at the source level which might be different from the usage in the compiled binary e.g.
because their usage could be influenced by macro metaprogramming and the usage during execution of the program.
related work studies of inline assembly and linkers.
besides compiler builtins c projects also contain other elements not specified by the c standard.
rigger et al.
found that around of popular c projects use x86 inline assembly .
the current paper demonstrates that gcc builtins are used more frequently than inline assembly which provides even stronger incentives to implement support by c tools.
other studies focused on the role of linkers and the preprocessor .
c projects are often built using makefiles whose feature usage has also been investigated .
studies of other language features.
this paper fits into a recent stream of empirical studies of programming language feature usage all of which share a methodology of mining software repositories to determine the popularity of features in large sets of open source projects and or evaluate the harmfulness of features in terms of potential for bugs.
most of this work has focused on general purpose programming languages and research has evolvedfrom more common to lesser known features.
for example for java the usage of general language features fields inheritance exception handling lambda features and async constructs on android have been studied.
for c projects the usage of templates generic constructs concurrency constructs and asserts have been studied.
the latter also considered c projects similar to nagappan et al.
s study of the usage and harmfulness of the goto construct.
however to the best of our knowledge a study of the usage of compiler builtins has not yet been conducted and as such fits into the line of research into c programming language features.
conclusions we have presented an empirical study of the usage of gcc builtins in a corpus of open source c projects retrieved from github.
to the best of our knowledge this is the first study of compiler builtins despite them having existed in gcc for years.
we believe that they warrant investigation since more than builtins exist that tools could support and because even safety critical tools such as the compcert compiler have bugs in the implementations of common builtins.
implications for tool builders.
since of all popular projects relied on compiler builtins any tool that processes c code needs to deal with them.
however since only about of builtins were used it might not be necessary to implement all builtins.
in fact we found that architecture independent builtins are most commonly used and by implementing only of such core builtins half of the projects can be supported.
since the majority of projects mostly added builtin usages tools are likely still expected to support builtins for code yet to be written.
implications for the gcc developers.
we think that our study is also informative for compiler developers especially those of gcc.
this study demonstrated the large scope of gcc builtin usage and might encourage compiler developers to add maintain and document builtins in a consistent and structured way.
in particular we think that public and internal builtins should be strictly separated.
since our study highlighted the builtins that remained unused in our data set such builtins could potentially be considered as deprecation candidates.
as part of our future work we want to engage with the gcc developers to discuss how the identified problems could be addressed.
implications for application developers.
furthermore our study informs application developers about downsides of using builtins.
although supported by mature compilers gcc builtins are a language extension that are not supported by all tools e.g.
compcert tcc kcc and frama c .
thus a reliance on builtins means that fewer code analysis and other tools can be used on such applications.
furthermore projects that rely on internal builtins such as those for variadic arguments handling add an additional level of technical debt as they should only be used within gcc and can in theory change without notice.
thus we recommend application developers to use builtins with caution.
implications for language designers.
we believe that our results are also useful to language designers as they show which functionality plain c lacks and what potential implications adding compiler builtins has on the projects developed in a given language.understanding gcc builtins to develop better tools esec fse august tallinn estonia