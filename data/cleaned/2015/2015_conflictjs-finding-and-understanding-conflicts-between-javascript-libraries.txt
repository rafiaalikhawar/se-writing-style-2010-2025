conflictjs finding and understanding conflicts between javascript libraries jibesh patra tu darmstadt jibesh.patra gmail.compooja n. dixit tu darmstadt poojandixit gmail.commichael pradel tu darmstadt michael binaervarianz.de abstract it is a common practice for client side web applications to build on variousthird partyjavascriptlibraries.duetothelackofnamespaces in javascript these libraries all share the same global namespace.
as a result one library may inadvertently modify or even deletetheapisofanotherlibrary causingunexpectedbehavioroflibraryclients.giventhequicklyincreasingnumberoflibraries manually keeping track of such conflicts is practically impossible both for library developers and users.
this paper presents conflictjs a n automatedandscalableapproachtoanalyzelibrariesforconflicts.
the key idea is to tackle the huge search space of possible conflicts in two phases.
at first a dynamic analysis of individual libraries identifiespairsofpotentiallyconflictinglibraries.then targeted testsynthesisvalidatespotentialconflictsbycreatingaclientapplicationthatsuffersfromaconflict.theoverallapproachisfree of false positives in the sense that it reports a problem only when suchaclientexists.weuse conflictjs toanalyzeandstudyconflicts among real world libraries.
the results show that one out offour libraries is potentially conflicting and that libraries are involvedinatleastonecertainconflict.thedetectedconflictscause crashesandotherkindsofunexpectedbehavior.ourworkhelps library developers to prevent conflicts library users to avoidcombining conflicting libraries and provides evidence that designing a language without explicit namespaces has undesirable effects.
acm reference format jibeshpatra poojan.dixit andmichaelpradel.
.
conflictjs finding and understanding conflicts between javascript libraries.
in icse icse 40th international conference on software engineering may 27june gothenburg sweden.
acm new york ny usa pages.
introduction thepopularityofjavascripthasleadtothedevelopmentofnumerous javascript libraries.
for example a popular content delivery networkthathostsjavascriptlibrariesprovidesover3 000different libraries.
.
libraries are ubiquitous and many applications use multiple libraries.
one estimate is that of the top million permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
strophe.js window.base64 encode function b code decode function b code jsencrypt.js window.base64 unarmor function t code decode function i code library client jsencrypt new jsencrypt jsencrypt.setkey ... returns false instead of decrypted data when strophe.js is loaded after jsencrypt.js.
jsencrypt.encrypt ... figure example of two conflicting libraries and a client that will experience unexpected behavior when loadingboth libraries.
websites use at least one of the top libraries.2a recent study onthetop75 000alexawebsites reportsthatthenumberof externally hosted scripts that a website includes has a median of and a maximum of .
unfortunately using multiple independently developed libraries togethermaycause unexpectedbehavior.thereasonis thatjavascript does not have namespaces but instead all libraries sharea single global namespace.
as a result a value or a function exported byonelibrarymaybeeasilyoverwritten modified deleted or accidentally used by another library.
moreover libraries may overwrite built in apis sometimes called monkey patching and multiple libraries may try to overwrite the same api in different ways.inpractice theproblemiscompoundedbytheloosetypingin javascript which allows one library to overwrite another library s api even with a type incompatible value.
as a real world example of a library conflict found by our approach consider figure .
the left side of the figure shows an excerptof strophe.js alibrarythatimplementsthexmppmiddlewareprotocol.thecenterpartofthefigureshows jsencrypt.js a librarythatprovidesopensslrsaencryption.bothlibrarieswrite to the global variable base64.3when included together the library thatisincludedlastwilloverwritethe base64objectofthelibrary that was included first.
such overwriting may cause unexpectedbehavior in a client of either of these libraries.
for example theright side of the figure shows a client that tries to encrypt somedata using jsencrypt.js.
when executing this client after loading onlyjsencrypt.js the last call returns the encrypted data.
however when executing the client after loading jsencrypt.js and then strophe.js the last call simply returns false.
the fact that including an apparently unrelated library breaks the core feature of the encryptionlibrarywillsurpriseusersandisunintendedbythedevelopers of both libraries.
problems caused by conflicting libraries may occur whenever a developer loads two libraries which is common practice.
even if a 3thewindowvariable is the global object in client side javascript.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jibesh patra pooja n. dixit and michael pradel developerexplicitlyloadsonlyonelibrary otherlibrariesmaybe implicitly loaded.
due to the highly dynamic nature of javascript where some code may dynamically load other code an application developer may implicitly load libraries without even noticing it.
forexample websitesbuiltontopofcontentmanagementsystems oftenuseplugins eachofwhichimplicitlyloadssomelibraries.
other common ways of implicitly loading libraries are third party ads socialmediaservices andnewsfeeds.whenaconflictbetween librariesexists javascriptoftenfollowsa nocrash philosophy i.e.
misbehaviormaynotleadtoanexception.asaresult conflictseasily remain unnoticed at library load time or even later until a user triggerstheunexpectedbehavior asillustratedinthemotivating example.
in principle there is a sane way for libraries to share the global namespace.ideally librarydevelopersallfollowa singleapiobject pattern wheretheentireapiofthelibraryisencapsulatedintoa singleobject.thelibrarythenwritesthisobjecttoasingleglobal variable e.g.
namedlikethelibraryitself tominimizethepotential for conflicts.
in practice not all libraries follow this pattern andsome global variables such as and are particularly popular.
ourempiricalresultsshowthat71 ofalllibrariesdonotfollow the single api object pattern.
libraryconflictsarechallengingtodetectforaprogramanalysis and difficult to avoid for library developers.
one reason is that unintendedeffectsofconflictstypicallymanifestonlyatruntime.apurelystaticanalysiscaneithersoundlyoverapproximatepotentialconflictsandtheireffects whichislikelytoproducealargenumber offalse positives in particular forjavascript or unsoundly underapproximatethem whichmaymissconflicts.anotherchallengefor detecting conflicts is the large number of javascript libraries.
with thousands of libraries available and new libraries being added and updated every day analyzing all possible combinations of libraries leads to a combinatorial explosion that is prohibitive in practice.
currently thereexistsnotechniqueforlibrarydeveloperstocheck whether their library conflicts with another and for library clients tocheckwhichcombinationsoflibrariestoavoid.furthermore itis currently unknown to what extent the problem of library conflicts matters in practice.
this paper presents conflictjs the first automated and scalable techniquethatanalyzesjavascriptlibrariesforconflicts.weaddress the huge search space of possible conflicts and the difficulties of statically analyzing javascript through a two phase approach that combines dynamic analysis and test synthesis.
in the first phase conflictjs dynamicallyanalyzesindividuallibrariestodetectwrites to the global namespace while loading a library.
an offline com parison of these global writes yields a set of potential conflicts betweenlibraries.inthesecondphase conflictjs synthesizesand dynamicallyanalyzes libraryclients tocheck ifpotential conflicts indeedleadto unexpected behavior.thesecond phase andtherefore also the overall approach is precise in the sense that every validated conflict certainly occurs in the synthesized client and leads to different behavior depending on the loaded libraries.
we useconflictjs to analyze and study libraries.
the resultsshowthat268 librariesarepotentiallyconflictingand 4for a real world example see troubleshooting what is this jquery conflict .that libraries are certainly conflicting with at least oneother library.
the conflicts may lead to crashes unexpected be havior and globally reachable state with unexpected values andtypes.
a manual analysis of conflicting libraries reveals several recurringpatternsofrootcausesforconflicts whichareinstructive forlibrarydevelopers api designers andlanguagedesigners.
we reported seven of the detected conflicts to the respective librarydevelopers of which four already have been acknowledged and confirmedasproblematic.ofthefourconflicts twohavebeenfixed by the developers of the respective libraries.
comparedtoexistingworkonanalyzingjavascript ourwork is the first to address conflicts among libraries.
existing static analyses focus on type checks of single libraries or assume the presence of library clients .
existing dynamic analyses that target type inconsistencies and other coding problems assume to have inputs to exercise the program whereas our work synthesizes library clients automatically.
jsnose identifies excessive uses of global variables but focuses on single libraries.
finally ourempiricalresultsrelatetoexistinglarge scalestudies ofjavascriptlibrariesandtheirusage .ourworkisthefirst to study library conflicts.
weenvision conflictjs tobeusefulfordevelopersoflibrariesand libraryclientsalike.librarydevelopersmayuse conflictjs tocheck whether their library conflicts with others allowing them to avoid theconflictsbyadaptingthelibrary.developersoflibraryclients mayuseconflictjs tocheckwhichlibrariesconflict allowingthem to avoid including them together.
in summary this paper contributes the following wearethefirsttoaddresstheproblemofconflictsamonglibraries in a language without explicit namespaces.
wepresent conflictjs anautomatedandscalabletechniqueto precisely detect conflicts in javascript libraries through a combination of dynamic analysis and test synthesis.
weprovide empirical evidence thatthe approachscales to951 libraries where it effectively detects and validates conflicts among them.
we provide our implementation as open source.
motivation and problem statement this section provides some background motivates the problem of conflictsamong libraries withexamples fromreal world libraries and formulates the problem addressed in this paper.
.
background the javascript version that is fully supported by most modern browsers is ecmascript .
it does not provide any kind of namespacesormodulesatthelanguagelevel.instead librarydevelopers rely on several ad hoc mechanisms to encapsulate code and to export apis.
first some libraries follow a single api object pattern where the library initializes itself in a local scope and provides its api as properties of a single global object.
the most obviouschoicefornamingthisglobalapiobjectisthenameofthe library which typically is unique.
for example react.jsfollows this patternbyexportingitsapisintotheglobal reactobject.thepopularjquerylibraryfurthermoreenablesdeveloperstoavoidconflicts authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflictjs finding and understanding conflicts between javascript libraries icse may june gothenburg sweden by specifying the global variable where to provide the library or to evenexportthelibraryintoanexisting non globalobject.6second somelibrariesbuild upontheasynchronous modulespecification amd a module system targeted at client side javascript and implementedasalibrary e.g.
requirejs7.third somelibrariesuse commonjs a module system targeted at non client side javascript and implemented as the default module system on the node.js plat form.unfortunately theseoptionsareneithercompatiblewitheach othernoravailableonalljavascriptplatforms.ecmascript6 unifiesideasfromcommonjsandamdintolanguage levelmodule support and popular javascript platforms have started to adopt it.
however sincewidely usedlibrariescannotrelyonrecently added language features they typically ensure backward compatibilityby relying on other ways to export their apis.
in summary the lackofnamespaceandmodulesincurrentlydeployedversionsof javascript creates a non trivial problem for library developers.
.
motivating examples and classification of conflicts thefollowingsectionmotivatestheproblemofconflictsbetween libraries with real world examples found using our approach.
furthermore we use these examples to define four classesof conflicts based on how the conflicts manifest to a library client.
for each example we show code from two conflicting libraries and a client application that observes different behavior depending on which of the libraries are included and on the order of inclusion.
inclusionconflicts.
thiskindofconflictraisesanexceptionwhen including multiple libraries without any further interaction between the client and the libraries.
the example in the first column illustrates the problem with the curlanddojolibraries.
loading the second library after loading the first library causes an exception.
foralibraryuser finding suchconflictsisnon trivialbecause the exceptiondependsontheorderofincludingthelibraries onlyif a client loads dojobefore loading curlthe exception occurs.
the documentation of neither of the libraries provides any reference to the other library presumably because the respective developers are not aware of each other.
typeconflicts.
typeconflictsoccurwhenmultiplelibrarieswrite type incompatiblevaluestothesamegloballyreachablelocation.
table1presentsanexampleoftwolibraries ocanvas.js andaframe.js thatwriteto window.logs anarrayandafunction respectively.a client using one of these libraries may rely onthe type of the conflictingvalueandwillbesurprisedifincludinganotherlibraryor changingtheorderoflibraryinclusionbreaksthetypeassumption.
this and the following kinds of conflict are more subtle than inclusionconflictsbecause theydonotleadtoanobviouserror when simply including the libraries.
valueconflicts.
similar totypeconflicts thiskindofconflict is caused by multiple libraries writing different values to the same globally reachable location.
we classify a conflict as value conflict if the values are type compatible but different.
table providesan example where two libraries pakoand3dmol write different pako.therootcauseofthisconflictis that3dmolcontains an outdated version of pako.
behavior conflicts.
a behavior conflict occurs when multiple librariesstorefunctionsatthesamegloballyreachablelocation but these functions do not provide the same behavior.
table presents an example where two libraries jsfaceandmatreshka overwrite thesamevariable class.asillustratedbytheclientcode thetwo functions provide different behaviors which may surprise a client thatisnotawareofthefactthatbothlibrariesprovidedissimilar implementations of the same global function.
.
problem statement based on these four types of conflicts we now formulate the problemaddressedinthispaper.theinputtoourapproachisaset lof libraries.
we assume that each l lis supposed to be usable without including any other library in l. in particular this assumption excludes libraries that extend another library e.g.
libraries that extend the popular jquerylibrary with additional features.
libraries are used by clients that interact with the apis of a library.
client here means any sequence of statements that is ex ecuted after loading one or more libraries.
we denote a client c that executes after loading libraries l1 .. lkascl1 .. lk.
we call the sequence l1 .. lkoflibrariesloadedbeforeexecutingaclientthe libraryconfiguration.the client rowoftable1showsexamples of clients.
wetargetconflictsduetolibrariesthatwritetothesameglobally accessible memory location.
in javascript such memory locations are properties of an object.
properties are accessed using either dot notation e.g.
x.p orbracketnotation e.g.
x .ineithercase thenameofapropertyisrepresentedbyanidentifierofstringtype.
for properties of nested objects the property accessors consistof multiple identifiers e.g.
window.foo.bar .
we call all property accessors using either single or multiple identifiers access paths.i f thefirstsegmentofanaccesspathisgloballyreachable wecallita globalaccesspath.forexample window.foo.bar and window.baz are globalaccesspaths.sincethe window prefixisoptionalinjavascript we omit it in the remainder of the paper unless needed.
based on these definitions we can now define conflicts between pairs of libraries definition conflict .letl1 l2 lbe two libraries that both write to the same global access path p. these libraries are conflicting with eachother if thereexists a clientso thatany of thefollowing is true cl1behaves differently than cl2 cl1behaves differently than cl1 l2 cl1behaves differently than cl2 l1 cl2behaves differently than cl1 l2 cl2behaves differently than cl2 l1 cl1 l2behaves differently than cl2 l1 the first case means that the same client behaves differently dependingonwhichlibraryisloaded.suchaconflictisrelevantfor thedevelopersofthelibrariesbecausetheselibrarieswritedifferent data or functions to the same globally accessible memory location.
cases to mean that a client that includes a single library will changeitsbehaviorsimplybecauseanotherlibraryisalsoincluded.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jibesh patra pooja n. dixit and michael pradel table examples of conflicts between real world libraries.
problem inclusion conflict type conflict value conflict behavior conflict code example curl.js window.define function k ... dojo.js var def function ... var req function ... if window.define ... else window.define def window.require req window.require exception ocanvas.js function a b c a.logs window document aframe.js c function e ... window.logs c pako var pako deflate function ... inflate function ... ... 3dmol var pako inflate function ... inflateraw function ... ... jsface function o t o ... window.class o matreshka window.class function a b ... client client that includes first curl.js and then dojo.js exception because require is undefined try to add to the logs array logs.push log exception because logs is a functionobject.keys pako returns with pako but with 3dmolvar v1 null var v2 v0 window.class v1 v2 typeerror with matreshka but no errors with jsface description bothlibrarieswritetotheglobalvariable define.
toavoidoverwritinganalreadydefinedvariable e.g whenthesamelibraryisincludedmultiple times dojochecks whether defineis already defined.
unfortunately the code incorrectly assumesthat requireisalwaysdefinedtogether with define causinganexceptionwhentrying tocallthisfunction.theproblemistriggeredby any client that includes first curland then dojo.both libraries write to a global variable logs.
the type of logsis arrayinocanvasbutfunction inaframe.bothlibrariesoverwritetheglobal variable pako.thesizeoftheglobal variable is different in both cases.
thisoverwritinghappensbecause 3dmol ships a variant of the pako library that misses some features.both libraries write to the same global variable class.
the implementation of both differ as illustrated by the client.
such a conflict is relevant for developers of clients who may be surprisedthatsimplyincludinganotherlibrarycausesnewbehavior.
thelastcasemeansthataclient sbehaviorchangeswhenswapping the order in which two libraries are included.
again this case is relevant for client developers because such a change in behavior is surprising.
basedondefinition1 wesaythatalibraryis conflicting ifthere existsanotherlibrarysothatbothareconflictingwitheachother.
the problem addressed in this paper is how to find conflicting libraries in a precise way i.e.
without false positives.
.
challenges duetotheincreasingpopularityofjavascript thereexistthousands oflibraries.onlyfewofthemcomewithrepresentativeclientsthat could serve as test cases.
our work aims at detecting conflicts inan automated and scalable way.
automated here means that theapproach requires no input except for a set of libraries.
scalable here means that this set may contains thousands of libraries.
to find conflicts in an automated and scalable way we must address several challenges.
first the sheer number of javascript libraries makes it practically impossible for an analysis to compare allcombinationsorevenallpairsoflibraries.forexample given 000libraries thereareabout500 000pairsoflibraries.weaddress this challenge by identifying potential conflicts during an analysis of individual libraries section .
which significantly reduces the numberofcombinationstoanalyzefurther.second theapproach cannotrelyonanya prioriavailablelibraryclients.weaddressthis challengebysynthesizinglibraryclients guidedbythepotential conflicts section3.
.third tovalidatewhetherapotentialconflict is indeed a conflict we need to check whether the behavior ofclients differsdepending onthe libraryconfiguration.
we address thischallengebycomparingtheruntimebehaviorofsynthesized clients executed with different library configurations section .
.
.
scope and limitations some challenges are out of the scope of this work.
one of themisdetectingalllibraryconflicts.whileourapproachisprecise it isnotsound i.e.
itmaymisssomeconflicts.formostinteresting program analysis tasks providing a sound and precise answer isimpossible and we opt for precision in this work.
another out of scope question is how many real world clients suffer from a detected conflict.
instead of addressing this question our approach showstheexistenceofaclientbysynthesizingtheclient sothat librarydeveloperscouldanticipateconflictsthatanypossibleclient mayrunintoandpreventconflictsbeforetheyoccur.finally we focus on pairwise library conflicts and ignore conflicts that arise only if three or more libraries interact with each other.
approach thissectionpresents conflictjs ascalableandautomatedapproach tofindconflictsbetweenlibraries.givenasetoflibraries theapproach consists of two main steps detectionofpotentialconflicts.atfirst conflictjs dynamically analyzesindividuallibrariestoidentifywhichgloballyreachablememorylocationstheywriteto.basedontheglobalwrites of each library the first step then reports a potential conflict for each pair of libraries that write to the same location.
validation of conflicts.
this step validates whether two libraries thatwritetothesamegloballyreachablelocationcanindeed authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflictjs finding and understanding conflicts between javascript libraries icse may june gothenburg sweden cause a client to behave differently depending on the library configuration.
to this end conflictjs synthesizes clients and compares their behavior across different library configurations.
ifandonlyiftheapproachfindsaclientwithdivergingbehavior it reports a conflict.
the remainder of this section explains these two steps in more detail.
.
detection of potential conflicts to find potential conflicts between libraries conflictjs analyzes the global access paths written to by a library.
to this end wedynamically analyze the loading of each library to keep track of the writes made to the global namespace definition global writesof a library .theglobalwritesof alibrarylisasetgl p1 .. pk ofglobalaccesspathstowhich l writes while loading l. for example if the global object is called windowand a library writestoitusing window.obj prop1 prop2 thenthesetof global writes is obj obj.prop1 obj.prop2 .
to compute the global writes of a library conflictjs generates a trivialclientthatsimplyloadsthelibraryanddynamicallyanalyzes theexecution.thedynamicanalysisupdatestheset gwhenspecific runtime events occur as summarized in table .
the analysis isguaranteed to observe all global writes that occur while loadingthelibrary.inparticular theanalysishandleswritestoaliasesof globally reachable objects as illustrated by the example involving window.array in table .
the access paths of all reachable values i.e.
paths v mentioned in table are computed by recursively traversing the properties of the object v. the information whether avariableis globalis providedbyjalangi ontop ofwhichwe implement the analysis.
afterextractingtheglobalwritesofeachlibrary conflictjs compares the global writes of all libraries with each other to check for writestothesameglobalaccesspath.iftwolibrariesshareaglobal write we classify them as potentially conflicting definition potentially conflicting libraries .two libraries l1 l2 larepotentiallyconflictingif gl1 gl2 i.e.
ifthetwo libraries share at least one access path in their global writes.
thefirstphaseof conflictjs reducesthesearchspaceofpotential conflictstobeconsideredbythesecondphaseoftheapproach.the firstphasescaleswelltoalargenumberoflibrariesbecauseeach library is analyzed in isolation.
comparing the global writes across librariesrequirescomputingpairwiseintersectionsofsets which easily scales to a large number of sets.
as mentioned in section .
theanalysismightmisspotentialconflicts e.g.
becausealibrary mightperformaglobalwriteafterthelibraryhasbeenloaded.a manualinspectionofasubsetoflibrariessuggeststhislimitation to be negligible in practice because libraries tend to initialize their apis at load time.
.
precise validation of conflicts the second step of conflictjs is to validate potential conflicts identifiedinthefirststep.atfirst wemotivatetheneedforthissecondstepwithanexample.then weexplainthedetailsofthevalidation.table actions performed by the global writes analysis.
runtime eventaction example variable write w vifwis a global variable addwtog.letpaths v be the access paths of all values reachable from v. for each pv paths v addpvtog.
function var x a window.foo x g g foo foo.a property write x.p vletpaths window be the access paths of all globally reachable values.
for each pw paths window ifpwpoints to x addconcat pw p to g. letpaths v be the access paths of all valuesreachable from v. for eachpv paths v add concat pw pv tog.
function var x window.array x.p b var y y .
q g g array.p array.p.b declara tion of function fiftheglobalvariable fpointsto the declared function i.e.
thefunction is globally declared addftog.
function function foo function bar g g bar jslite.js array.prototype.remove function t var n this.indexof t return n this.splice n this ext core.js array.prototype.remove function e var t this.indexof e return !
t this.splice t this figure2 exampletoshowtheneedforvalidatingpotentialconflicts.
.
.
motivation for validation.
potentially conflicting libraries write to the same globally accessible memory location.
this situation may or may not cause a client to suffer from a conflict as definedindefinition1.forexample considerfigure2 whichshows code snippets from two potentially conflicting libraries jslite.js andext core.js.
the global access path to which both libraries write isarray.prototype.remove .
both libraries extend the built in arrayobject by adding a new method remove which can be called with one argument.
even though the two methods are syntactically different close inspection shows that both pieces of code are functionally equivalent.
this example illustrates that reporting all potential conflicts would cause false positives because for some potentialconflicts allclientsareguaranteedtoobservethesame behavior irrespective of the library configuration.
.
.
synthesizing clients and comparing their behavior.
to checkwhetherapotentialconflictbetweentwolibrariesisindeeda conflict conflictjs synthesizeslibraryclientsandcheckswhether theirruntime behavior differs dependingonthe libraryconfiguration.
the basic idea is to consider each of the six scenarios listed in definition by comparing the behavior of two clients with each other.thetwoclientscontainexactlythesamecode exceptthat authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jibesh patra pooja n. dixit and michael pradel algorithm validate potential conflicts input libraries l1 l2 that both write to global access path p output validated conflict between l1 andl2 cempty empty client ifconflictin confi s cempty then return inclusion conflict ctypes synthesize client that checks type of p ifconflictingconfigs ctypes then return type conflict iftype ofpis non function then cvalues synthesize client that checks value of p ifconflictingconfigs cvalues thenreturn valueconflict else cbehavior synthesize clients that call function p for each cbehavior cbehaviordo ifconflictingconfigs cbehavior then return behavior conflict function conflictingconfigs c b set of observed runtime behaviors for each config l1 l2 l1l2 l2l1 do bconfig executecconfig b b bconfig if b 1then return true else return false theyrunwithdifferentlibraryconfigurations.if conflictjs observes a behavioraldifference between thetwo clients thepotential conflict between the two libraries is indeed a conflict.
forillustration consider thebehaviorconflictillustrated intable1.ourapproachtriestovalidatethisconflictbysynthesizing clients such as the client shown in the table.
the approach comparesthebehaviorofthisclientwithdifferentlibraryconfigurations.for the example conflictjs finds that on calling class there is one librarythatthrowsan exception whiletheotherdoesnot.
thatis theapproachhasvalidatedtheconflictandreportsit alongwith the synthesized client that illustrates the conflict.
algorithm1summarizesourapproachforvalidatingpotential conflicts by synthesizing and dynamically executing library clients.
themainideaistocomparetheexecutionofaclient cwithdifferent library configurations i.e.
cl1 cl2 cl1 l2 andcl2 l1 as summarized in function conflictingconfigs .
if there are multiple different behaviors then the algorithm has validated a conflict.
the following describes how conflictjs creates clients to detect the four kinds of conflicts presented in section .
.
.
.
checkingforinclusionconflicts.
atfirst conflictjs checks forinclusionconflicts lines1to2 .aninclusionconflictistriggered by simply including libraries i.e.
the client is an empty client that doesnotcontainanystatements.tocomparelibraryconfigurations thebehavior bconfigindicateswhetherincludinglibrariescausesthe client to throw an exception.
if one library configuration causes an exception whereasanotherconfigurationdoesnot then conflictjs reports an inclusion conflict.
for the inclusion conflict example of table conflictjs reports aconflictbecause tryingtoexecutetheemptyclientafter loading curl.jsanddojo.jscausesanexception whereasexecutingtheemptyclient after loading only one of these libraries does not throw any exception.
.
.
checkingfortypeconflicts.
foranypairoflibraries l1 l2 and shared global access path pfor which the approach has not validated an inclusion conflict the next step is to check for type conflicts.
to this end conflictjs synthesizes a client that reads the value at the access path pand then checks its type lines to .
the approach again executes this client with all possible library configurations and summarizes the behavior of each configuration as the type of the access path p. if one library configuration causes the client to see type t1 whereas another library configuration causes the client to see type t2 t1 thenconflictjs reports a type conflict.
an example of a library pair with a type conflict is given in the second column of table .
the approach reports this conflict because pushisanarraywhenloadingonelibrarybutafunction whenloadingtheotherlibrary.the client cellofthetableshowsa clientthatsuffersfromthistypeconflictbecausetheconflictcauses the client to crash when it tries to call a function that turns out to be an array.
.
.
checking for value conflicts.
while checking for type conflicts theanalysisgathersinformationaboutthetypesofvaluesstoredataglobalaccesspath.forpotentialconflictsthatareneither validatedto beaninclusion conflict nortobea typeconflict both libraries write values of the same type to the access path.
based on thistype conflictjs checksfortheremainingtwokindsofconflicts.
if the type is function the approach compares the behavior ofclients that call this function as described below.
if the type is a non function then the approach synthesizes a client that reads the value at the access path p lines to .
to compare the behavior ofthisclientacrosslibraryconfigurations conflictjs comparesthe valuereadat p.theanalysisdirectlycomparesprimitivevaluesand deeplycomparesobjects.ifdifferentlibraryconfigurationscause theclienttoreaddifferentvalues then conflictjs reportsavalue conflict.
the valueconflict columnoftable1givesanexampleofatype conflictonthe pakoaccesspath.
conflictjs synthesizesaclientthat extractsthe numberofpropertiesof thevaluestored at pakoand the then recursively extracts the values of these properties.
the approachreportsaconflictbecausethenumberof pako sproperties dependsonwhetherthe pakolibraryorthe 3dmollibraryisloaded.
.
.
checking for behavior conflicts.
the most challenging kindofconflictare behaviorconflicts.theseconflictsoccur when differentlibrarieswritefunctionstothesameglobalaccesspathbutthebehaviorsofthesefunctionsdiffer.ingeneral decidingwhether the behavior of two functions differs is undecidable.
conflictjs approachesthisproblembytryingtosynthesizeclientsthatexposeadifferenceinbehavior.iftheanalysissucceedsingeneratingsuch a client within a fixed time budget it reports a behavior conflict.
to synthesize clients we use a simple test generator inspired by randoop sfeedback directed randomtestgeneration .other test generation techniques such as symbolic or concolic execution orsearch basedtestgeneration couldalsobe used for this step.
given a function typed access path pdefined by two libraries the test generator starts by estimating the number authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflictjs finding and understanding conflicts between javascript libraries icse may june gothenburg sweden nofargumentsthatthefunctionexpects.tothisend weusethe lengthproperty of the function object at p which in javascript yields the number of declared function parameters.
this number is an estimate because a function body may also access additional argumentsusingthebuilt in arguments value.next togenerateacall to thefunction the testgenerator randomlydecides on arandom number ranging between and nof arguments to pass.
for each argument the test generator decides on the type of argument to createbyrandomly choosingbetweenthefollowing types boolean string number array object undefined andnull.tocreateaboolean string ornumber thegeneratorpicksfromapre definedpoolof values.forarrays thegeneratorrandomlypicksalengthranging between and and fills it with random strings and numbers.
finally tocreateanobject thegeneratorcreatesupto10properties and assigns randomly generated values to them.
once the arguments are generated the function iscalled using the generated arguments.
if and only if thecall succeeds without raising an exception for at least one library configuration the generator synthesizes a client that contains this call.
to compare the behavior of synthesized clients across library configurations conflictjs summarizes the behavior of the client executionbasedonthereturnvalueofthefunctionandbasedon whetherthefunctionraisesanexception.theapproachreportsa behaviorconflictintwocases i ifonelibraryconfigurationcauses the client to crash whereas another library configuration does not cause a crash or ii if both configurations do not crash but the return value of the function at pdiffers.
for example consider the last column of table .
conflictjs synthesizesclientsthatcallthefunctionstoredattheconflicting accesspath class.theclientshowninthetablethrowsanexception for one of the two libraries but not for the other which is why conflictjs reports a behavior conflict.
implementation weimplement conflictjs asaclient server basedtoolthatanalyzes javascript libraries.
the client component synthesizes executes and analyzes clients in a browser and sends a summary of the runtimebehaviortotheserver.theserverdetectspotentialconflicts and validates them based on execution behavior gathered in the firstand secondphase respectively.
ourdynamicanalyses tofind global writes is build on top of jalangi .
when synthesizing clients to detect behavior conflicts we set the testing budget to testsperaccesspath.inthispaper weimplementtheapproachonly forclient sidejavascript libraries anditwould bestraightforward toadaptforserver sidenpmlibrariesbuttheproblemislesssevere for node.js because there is a commonly accepted module system.
results and discussion we apply conflictjs to popular javascript libraries to evaluate the effectiveness of the approach in detecting library conflicts.
we focus on the following research questions how effective is conflictjs in finding library conflicts and what kinds of conflicts occur in practice?
section .
what are the root causes of conflicts between libraries?
section .
.
table javascript libraries used for the evaluation.
min median max total libraries lines of code size bytes do library developers make an effort to avoid conflicting scenarios by following the single api object pattern?
section .
.
whatarethepopularaccesspathsthatdeveloperstendtochoose?
section .
.
isthereacorrelationbetweenconflictsandthepopularityofa library?
section .
.
howaretheglobalwritesandconflictsdistributedacrosslibraries and access paths respectively?
sections .
.
and .
.
.
experimental setup our evaluation uses real world javascript libraries with a total of lines of javascript code .
the libraries include the popular jquery underscore and dojoprojects as well as various other highly popular libraries.
we obtain these libraries by downloading them from the cdnjs content delivery network.8at the time of starting our experiments the content delivery network offered a total of libraries.
we remove libraries that cannot be used in isolation in a standard desktop browser e.g.
because they rely on another library or because they target mobile devices.
we heuristically check for such libraries by loading each library in isolation and filtering away all libraries that throw an exception.
after filtering libraries remain which is our benchmark set for the evaluation.
to run our experiments we use an intel core i7 cpumachine clocked at3.60ghz with 32gb of memory running chrome node.js .
.
on ubuntu .
.
.
effectiveness in finding library conflicts .
.
potentialconflicts.
when analyzing theglobalwritesof individuallibraries conflictjs recordswritestoatotalof130 differentaccesspathsacrossthe951libraries.intersectingtheglobal writes of libraries reveals that of the access paths cause a potentialconflict i.e.
atleasttwolibrarieswritetoeachofthese access paths.these conflicting writesare performed by of the 951libraries i.e.
roughly one outoffourlibrariesisinvolvedina potential conflict.
.
.
validated conflicts.
out of the potentially conflicting libraries conflictjs validates166ascertainlyconflictingbysynthesizingaclientwhosebehaviordependsonthelibraryconfiguration.
the validated conflicts are due to distinct access paths.
in otherwords conflictjs successfullyvalidates62 ofthepotentially conflictinglibraries i.e.
of268libraries ascertainlyconflictingandfinds a validated conflict in of all libraries i.e.
of libraries .
.
.
kinds of validated conflicts.
figure summarizes how prevalentthefourkindsofconflictsareamongallvalidatedconflicts.
thetwosidesofthefigureprovidedifferentviewsonthesamedata.
figure3afocusesonpairsofconflictinglibrariesandshowshow manyofthesepairsarecausedbythefourkindsofconflicts.ifapair of libraries is involved in multiple kinds of conflicts then this pair authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jibesh patra pooja n. dixit and michael pradel 0inclusion typevalue behavior a library pairs classified by the type of conflict.
2inclusion typevalue behavior b libraries classified by the type of conflict.
figure3 prevalence ofthefourkinds ofvalidatedconflicts.
note that the surface is not proportional to the numbers.
isshownatthesetintersection.forexample therearefourpairs of libraries that have a value conflict for a global access path and a behaviorconflictforanotherglobalaccesspath.figure3bshows the distribution among the four kinds of conflicts for individual libraries.
since a single library may be involved in conflicts with different libraries these sets overlap.
for example there are seven librariesthatareinvolvedinatleastoneinclusionconflict value conflict and behavior conflict.
there are two main take aways of these results.
first all four kinds of conflicts are prevalent in practice which confirms our decisionstoconsiderallfourkindsin conflictjs .second themajority of conflicts are non inclusion conflicts i.e.
they do not cause an exceptionjustafter loadingtheconflictinglibraries.finding such conflicts and reasoning about them is challenging for both library developers and users alike.
.
empirical study of library conflicts the large number of libraries considered and conflicts detected in our evaluation enables us to learn more about how and why conflicts occur in javascript libraries.
we discuss these findingsin the following and discuss what impact they have on library developers library users and language designers.
.
.
rootcausesofconflicts.
tounderstandtherootcauses of conflicts between libraries we manually inspect a random sample of conflicting libraries.
during the manual inspection we identified seven recurring patterns.
table describes each pattern and and illustrates it with an example.
five of the seven patterns which account for out of the inspected conflicts are unintended by the developers and likely tocausesurprisingbehaviorforlibraryusers.thesepatternsare shown in the upper part of table .
the patterns cover conflictscausedbyindependentlydevelopedvariantsofthesamefunctional ity copied third party code poor api usage repeated use of conve nientglobalidentifiername andincorrectattemptstopatchbuilt in javascript apis.
to double check our intuition about whether conflicts are intended by the library developers we reported sevenconflicts to the developers of conflicting libraries.
at the time of writing fourofourreportshavebeenacknowledgedandconfirmed as worth fixing by the respective developers.
of the four acknowledged libraries two have been fixed by the developers.
apart from this basedonourbugreport thedeveloperofalibraryhasreportedabugtoanotherlibrarywithwhichitwasconflicting.subsequently this bug report also got fixed.
forallofthesefivepatterns therootcauseboilsdowntosuboptimal decisions by library developers such as programming errors orcopy and pasteofexistingcode.however atleastforsomeof them thedesignofthejavascriptlanguageandapismayalsobepartially toblame.
for example instances ofthe poorapi usage pattern are caused by the fact that the javascript web apis provide two orthogonal ways to attach event handlers setting the handler e.g.
onmessage .. which overwrites any already attached handler and adding a handler via addeventlistener message .. which preserves already attached handlers.
the conflicts detected byconflictjs are the result of libraries overwriting each other s event handlers by directly setting the handler.
another example is the incorrectmonkeypatching pattern.theterm monkeypatching refers to extending built in apis of the javascript language whichispossiblebutnon trivialtoimplementwithoutremoving existing functionality.
the remaining two patterns shown in the lower part of table both occur in a situation where library users are unlikely to be surprisedbytheconflict.onereasonisthatlibrariesdependoneachotheranddocumentthesedependenciesclearly sothatlibraryusers know in which order to load them.
ideally our experimental setup wouldfiltersuchlibraries asweassumeeachlibraryissupposed tobeusedindependently.anotherreasonisthatlibraries provide the same or very similar overall functionality so that library users would never include both together.
overall we drawtwoconclusion fromourmanual inspection.
first mostconflictsreportedby conflictjs areprogrammingerrors thatshouldbefixedbylibrarydeveloperstopreventclientsfrom surprisingbehavior.second therootcausesofconflictsarediversebutcanbeclassifiedintoasetofrecurringpatterns.knowingthese patterns may become the basis of guidelines for library developers what mistakes to avoid.
furthermore the patterns can guide the designoffutureprogramrepairtechniquesthatfixconflictingcode.
.
.
the singleapiobject pattern.
the singleapiobject pattern section .
allows developers to avoid conflicts by storingallgloballyaccessibledataintoasingleobjectnamedlikethelibrary.
if all libraries follow this pattern no conflicts occur.
to understand whether libraries follow this pattern we check for each library whether for all writes to a global access path the path begins with a segment that matches the name of the library as listed in the cdnjscontentdeliverynetwork.when matchinganaccess path and a library name we omit the .jssuffix that some libraries use.
wefindthat273outofthe951librariesfollowthe singleapiobject pattern.whilepromising thismeansthat71 ofalllibrariesdo authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflictjs finding and understanding conflicts between javascript libraries icse may june gothenburg sweden table recurring patterns among the root causes of conflicts.
pattern description nb.
example s independent implementationstwo libraries implement similar functionality and use the same global access path to store the function but the behavior slightly differs.
25polymerandtrixboth define wrapandunwrapfunctions.
other examples figure and issue of es6 shim.
copied third party codetwolibrariesbothcopycodefromathirdparty e.g.
another library.
at least one version of the code is outdated.
25qooxdooincludes an outdated copy of sinon.
see issue of qooxdoo.
another example issue of d3fc.
poor api usage a library adds an event handler in a way that removes all other handlers for this kind of event instead of adding to the existing event handlers.
25rxjsandgifshotbothwriteto onmessage tohandlepostmessage communication.
instead they should use addeventlistener which allows multiple event handlers.
convenient identifiertwo libraries use a convenient global identifier for different purposes.
25mermaid a library for generating diagrams writes to which is also used by score jsand others.
see issue of mermaid.
incorrect monkey patchinga library tries to extend a built in api but accidentally removes existing functionality.
25preloadjs andzingchart both overwrite the built in jsonin a way that destroys existing functionality.
see issue of preloadjs.
documented dependencyonelibrarydependsonanotheranddocumentsthisdependency.
25alloy uiis a framework built on top of yui.
clients should not be surprised by conflicts between them.
fork one library is derived from another library and modifies or extends the functionality of the original library.
25wysihtml is an extended version of wysihtml5.
clients should never use both together.
table popularity of global access paths measured in the number of libraries that write to an access path .
libs.
global access paths localstorage.debug10 requestanimationframe jquery onload require8 clearimmediate promise core js shared corejs shared .wks setimmediate core js shared .wks.iterator core js shared .wks.tostringtag notfollowthepattern butinsteadusethesharedglobalnamespace inapossiblyconflictingway.weconcludethatrelyingondeveloper disciplineinanopenenvironment suchasthejavascriptlibrary ecosystem is insufficient to enforce a conflict avoiding policy.
.
.
popular global access paths.
the large number of potential conflicts detected by conflictjs raises the question what global access paths are particularly popular among library developers.
table lists the most popular global access paths along with the number of libraries that write to it.
perhaps unsurprisingly the mostpopular access pathis thedollarsign which isalegalidentifier name in javascript and used by several libraries includingjqueryto export their api.
another popular choice is the underscoresign whichisshared e.g.
bythe underscore andlodash libraries.choosingashortidentifiernametoexportanapiistempting for library developers and potentially convenient for library users.
howeve r the downside is that multiple libraries may either knowinglyornot pickthesameshortidentifiername whichlikely causes surprises if these libraries are used together.
.
.
conflicts versus library popularity.
to better understand to what extent library conflicts depend on a library s popularity figure 4a shows for each library how many stars it has and in how manyconflictsitisinvolved.eachdatapointcorrespondstoone library.forexample onelibrarythathas45 901startsisinvolvedin two conflicts.
overall the figure shows that most conflicts are due tolibrarieswithlessthan10 000stars.themainreasonisthatonlyfewlibrarieshavemorethan10 000stars asillustratedinfigure4b.
thisfigureshowshowthelibrariesvalidatedtobeconflictingfrom a number of conflicts each library is involved in.
b popularity measure of libraries validated to be conflicting figure4 influenceofpopularityonnumberofconflictsandnumber of libraries.
each data point represents one library.
twelve out of libraries do not have a github repository and hence are not included here ourbenchmarkaredistributedacrossthepopularitymeasure.both figures look similar which explains the distribution of conflictsacross popularity.
at the same time it is interesting to note thateven some highly popular libraries are involved in conflicts as indicated by the data points on the right end of figure 4a.
.
.
distribution ofglobalwritesacrosslibraries.
tobetter understandthelargenumberof130 714globalwritesperformedbythe951libraries weanalyzehowthesewritesaredistributedacross the libraries.
the results show a highly skewed distribution with a fewlibrarieswritingtomanyglobalaccesspathsbutwithamedian authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jibesh patra pooja n. dixit and michael pradel of only one global write.
the libraries that write to most global access paths are large and popular libraries such as amazon s aws jdk access paths and microsoft s implementation of typescript global writes .
their high number of global writesdoes notimply badcodingpractice.
forexample the many access paths written by the aws sdk library almost all start with aws.
i.e.
they follow the single api object pattern.
we conclude that judging libraries based on their total number of global writes which might have been a simple alternative to conflictjs is not an effective way to find conflict triggering libraries.
.
.
distribution of conflicts across access paths.
a reader may wonder how many libraries write to the same global access path.investigatingthisquestionyieldsalong taildistribution most global access paths are contended for by only two libraries but a large number of highly popular global access paths is writ ten to by up to libraries.
we conclude that preventing library developersfromusingafewhighlycontendedaccesspaths such as and isinsufficienttosolvetheproblemoflibraryconflicts because there are many other access paths that cause conflicts.
related work lint likecheckers.
lint likecheckerssearchforbadcodingpractices through lightweight static analysis9 dynamic analysis andcombinationsofboth .someofthem e.g.
eslintandjsnose warn about excessive use of global variables within a single file but they do not analyze conflicts across files or libraries.
analysis of libraries.
existing analyses of javascript libraries checkthatalibraryimplementationmatchesitsinterfacespecification statically analyze library clients to understand types and other properties of a library and search for code injection vulnerabilities .
our work synthesizes library clients instead of analyzing existing clients.
beyond javascript pollux determines the effects of upgrading a library.
our work differs fromall the above by analyzing multiple libraries and their potential interactions instead of a single library.
dynamicanalysisforjavascript.
asurvey summarizesdynamicanalysesforjavascript.existinganalysesincludedeterminacy analysis dynamic data race detectors dynamicmodelcheckers profilerstodetectperformanceproblems taint and information flow analyses and analyses to understand code changes and the root cause of a crash .
all these techniques are orthogonal to conflictjs which is the first to focuses on library conflicts.
testgeneration.
thetestsynthesispartof conflictjs relatesto generatingtestcases suchasfeedback directed randomtestgeneration symbolic and concolic execution and searchbased testing .
jseft exploits fixtures extracted from executions to create tests.
these techniques could help the second phase ofconflictjs to further increase the percentage of validated behavior conflicts.
typecheckingand typeinference.
typeconflictsrelatetotype errors andtype inconsistencies .
severalapproaches inferand 9populartoolsinclude types through static dynamic or hybrid analysis.
none of these has been applied to multiple libraries.
another difference is that most type checkers focus on soundnessandthereforesufferfromfalsepositives whereas conflictjs validates potential conflicts.
studiesofjavascript code.
studiesshowthatjavascriptlibraries arewidelyusedandoftencombinedwitheachother.nikiforakis etal.
reportthat88 ofthewebsitesincludeatleastoneremote library andthatlibrariesareloadedfromover300.000uniqueurls.
another study shows that a web site includes a median of and a maximum of externally hosted scripts.
these numbers illustrate the risk of accidental conflicts between libraries.
beyond javascript eshkevari et al.
report conflict like problems in php applications .otherstudiesinvestigaterecurringperformance bottlenecks dynamic code loading insecure coding practices typecoercions type relatederrors recurringbug patterns the useof trivialsoftwarepackages the root causes of failures and the use of callbacks .
conclusion javascriptcode includingindependentlydevelopedlibraries shares thesameglobalnamespace.becausethemostwidelyusedversions of the language lack features designed for encapsulating exported apis librarydevelopersrisktoaccidentallysharethesameglobally accessible memory locations and write different data and functions to them.
this paper defines and classifies such library conflicts presentsanautomaticandscalableapproachtodetectthem and studiesconflictsin alargesetoflibraries.wedealwiththe hugesearch space of possible conflicts through a two phase approach thatdynamicallyanalyzeslibrariesinisolationtodetectpotential conflictsandthensynthesizeslibraryclientstovalidateconflicts.
among951real worldlibraries theapproachfinds166 certainly conflicting libraries.
furthermore we empirically study how andwhyconflictsoccur showingthatadiversesetofprogramming errors in libraries are the primary root cause.
our work not only provides a practical tool for library developerstodetectconflictsandforlibraryuserstoavoidconflicting libraries butalsohighlightstheimportanceoflanguagefeatures forencapsulatingindependentlydevelopedcode.webelievethat our work provides ample opportunities for future work.
one direction is to complement our precise but unsound analysis with a sound and likelyimprecise checkerforlibrary conflicts.
tohelp developersavoidconflicts anotherlineoffutureworkarerepair toolsthateitheraddressthecodingerrorsthatcauseconflicts.finally futureworkcoulddevelopautomaticcodetransformations to help libraries use encapsulation mechanisms provided in recent and future versions of javascript.