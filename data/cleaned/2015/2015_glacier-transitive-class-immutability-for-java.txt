glacier transitive class immutability for java michael coblenz whitney nelson jonathan aldrich brad myers joshua sunshine school of computer science carnegie mellon university pittsburgh pa usa email mcoblenz aldrich bam sunshine cs.cmu.edu hampton university hampton v a usa email whitney.nelson my.hamptonu.edu abstract though immutability has been long proposed as a way to prevent bugs in software little is known about how to make immutability support in programming languages effective for software engineers.
we designed a new formalism that extends java to support transitive class immutability the form of immutability for which there is the strongest empirical support and implemented that formalism in a tool called glacier .
we applied glacier successfully to two real world systems.
we also compared glacier to java s final in a user study of twenty participants.
we found that even after being given instructions on how to express immutability with final participants who used final were unable to express immutability correctly whereas almost all participants who used glacier succeeded.
we also asked participants to make specific changes to immutable classes and found that participants who used final all incorrectly mutated immutable state whereas almost all of the participants who used glacier succeeded.
glacier represents a promising approach to enforcing immutability in java and provides a model for enforcement in other languages.
keywords immutability programming language usability empirical studies of programmers i. i ntroduction mutability in software has been frequently cited as a source of bugs and security vulnerabilities .
if a component depends on mutable data the architecture typically must provide a facility for notifying the component when the data has been modified in order to maintain consistency.
if mutable data is read and modified concurrently there is a risk of a race condition unless synchronization is used correctly.
these opportunities for bugs have led some experts such as bloch to advise designing software so that as many structures as feasible are immutable not modifiable through any reference.
other experts such as helland have touted the benefits of immutability for distributed and database systems .
likewise programming languages have included features that facilitate formal specification of immutability.
this offers two advantages over informal specification enforcement so that the compiler or runtime can inform the programmer when immutability is violated and accurate documentation so that a client of a component can know what immutability guarantees the component provides.
unfortunately existing systems are either too hard to use or ineffective at preventing bugs .
the space of immutability is complex.
our prior work identified eight dimensions along which a language can support immutability .
if a programming language is to support the specification and enforcement of immutability what kinds of immutability should the language support?
supporting as many different kinds of immutability as possible results in a complexsystem to date there are no usability studies published of immutability specification systems.
we previously found that attempting to support many different kinds of immutability at once can result in a system that is very difficult to use effectively and correctly.
alternatively a design that supports a small set of immutability related features might be easy to understand and apply but fail to capture useful constraints.
such a system might fail to achieve the goals of immutability systems preventing bugs and documenting and enforcing specifications.
this motivates our research question can we select a subset of immutability features and design a corresponding programming language such that real users can use the immutability restrictions effectively with minimal training and expressing immutability with the language actually prevents bugs in situations where software engineers have already decided on an immutable design?
to address these questions we designed implemented and evaluated glacier a type annotation system for java.
type annotations are an existing mechanism in java that supports extending the type system.
based on prior work that found that programmers would benefit from strong guarantees we focused on transitive class immutability .transitivity ensures that immutable objects can never refer to mutable objects class immutability means that immutability of an object is specified in its class s declaration.
glacier which stands for great languages allow class immutability enforced readily enforces immutability statically with no effect on the runtime and therefore no performance cost on the compiled software so that users can get strong guarantees at compile time.
we evaluated the practicality applicability usability and usefulness of glacier in two case studies on existing code and in a user study with participants.
in the case studies we successfully applied glacier to a spreadsheet model component and to a reusable immutable container class observing that glacier is applicable to these real world existing software systems.
in applying glacier we also found two previouslyunknown bugs in the spreadsheet implementation.
in the user study we compared glacier with final since final is the current state of the practice mechanism for specifying immutability in java.
when given programming tasks users in the condition where they only had final all made various errors that resulted in breaches of immutability even after receiving explicit training in how to use final correctly in contrast although the participants who used glacier had never ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
seen it before almost all of them succeeded in using it to specify immutability correctly.
we also asked participants to complete programming tasks with immutable classes and found that although most users were able to complete the tasks all users offinal wrote code that had bugs or security vulnerabilities due to improper mutation glacier prevented these problems at compile time.
this paper makes the following contributions a definition and formal model of transitive class immutability as an extension to featherweight java an implementation of that model in a tool called glacier which enforces transitive class immutability in java.
by enforcing only the kind of immutability for which there is the strongest empirical support we have achieved significant simplifications relative to existing systems evaluations of glacier in two case studies on real software projects that showed that glacier captures a kind of immutability appropriate for those projects the first formal user study of any immutability system.
we compared glacier to final and found that all ten participants who used final wrote code that had bugs or security vulnerabilities even after having been trained on correct final usage in a situation in which glacier statically detects those problems.
almost all the glacier users were able to complete the tasks successfully.
ii.
b ackground although it might seem that immutability is a simple concept designing an enforcement system requires making a collection of design choices regarding what immutability means and how it will be enforced.
prior work identified eight distinct dimensions of immutability resulting in at least different combinations of features.
as such any proposal should include a justification for its position in the design space.
some key dimensions of immutability include restriction type assignability restricts assignment to variables read only restrictions prevent writes through particular