multi granular conflict and dependency analysis in software engineering based on graph transformation leen lambers hasso plattner institut potsdam germany leen.lambers hpi.dedaniel str ber universit t koblenz landau germany strueber uni koblenz.degabriele taentzer kristopher born jevgenij huebert universit t marburg germany taentzer born huebert mathematik.
uni marburg.deabstract conflictanddependencyanalysis cda ofgraphtransformation has been shown to be a versatile foundation for understanding interactionsinmanysoftwareengineeringdomains includingsoftwareanalysisanddesign model drivenengineering andtesting.
in this paper we propose a novel static cda technique that is multi granularinthesensethatitcandetectallconflictsanddependenciesonmultiplegranularitylevels.
specifically weprovidean efficient algorithm suite for computing binary coarse grained and fine grained conflicts and dependencies binary granularity indicates the presence or absence of conflicts and dependencies coarse granularityfocusesonrootcausesforconflictsanddependencies and fine granularity shows each conflict and dependency in full detail.
so we can address specific performance and usability requirementsthatweidentifiedinaliteraturesurveyofcdausagescenarios.
inanexperimentalevaluation ouralgorithmsuite computesconflictsanddependenciesrapidly.
finally wepresent a user study in which the participants found our coarse grained resultsmoreunderstandablethanthefine grainedonesreportedin astate of the arttool.
ouroverallcontributionistwofold i we significantly speedupthe computation of fine grained and binary cdaresultsand ii complementthemwithcoarse grainedones which offer usability benefits for numerous use cases.
ccs concepts software and its engineering automated static analysis introduction conflictsanddependencies arefundamentalphenomenainsoftware engineering.
forexample whenasoftwaresystemisdevelopedcollaboratively achangeoperationcanfacilitateorprohibitother changeoperations.
inconcurrentprogramming conflictsmayarise from data races when a thread writes to a memory location accessed by another thread.
from unrecognized conflicts and dependencies severe consequences mayarise rangingfromproductivityobstaclestofatalsafetyhazards.
therefore thereisaneed for techniques to detect conflicts and dependencies automatically.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.
copyrightsforcomponentsofthisworkownedbyothersthanacmmustbehonored.
abstractingwithcreditispermitted.
tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse gothenburg sweden acm.
... .
.
.3180258graph transformation has been shown to be a versatilefoundationforsupportingconflictanddependencydetection in software engineering based on the following three principles first graphsareusedforrepresentingstructuresofinterest suchas states of computation or versions of the system structure .
second certainchanges suchasstateorstructuremodifications aredescribedusinggraphtransformationrules.
third theprovided transformationspecificationisfedtothestatic conflictanddependencyanalysis cda ofgraphtransformations givenaset oftransformationrules allconflictsanddependenciesarisingfrom a given pair of rules are identified.
a conflict arises for example if the first rule application deletes an element required by the second ruleapplication.
akeybenefitofgraphtransformationisitsmature formalfoundation whichsupportscdatechniquesthatarecorrect by design all conflicts and dependencies can be detected.
basedontheseprinciples thecdaofgraphtransformationshas enabled a large number of use cases in software engineering includinganalysisanddesign model drivenengineering andtesting.
forexample graphtransformationscanbeusedtomodeltheexecution behavior of java programs in terms of preconditions and effectsontheobjectstructure identifiedconflictsanddependenciesare thenusedasoraclesfortestgeneration .
insoftwareproduct lineengineering featureinteractionscanbedetectedbyspecifying features as graph transformations and identifying conflicts and dependencies with cda .
in model based refactoring graph transformations and cda are used to find a suitable order of refactoringsteps.
onecontributionofthispaperisaliteraturesurvey that overviews papers describing such use cases.
althoughgenerallyhelpfulforthetaskathand however several authors report that the used cda technique showed severe limitations.
inoursurvey weidentifythreekeyrequirementsfor animprovedcdatechniqueforsoftwareengineering itshallbe i domain independent tobe applicableto alarge varietyofsoftware engineering domains ii usablein the sense that it should display areasonableamountofinformationtosupportunderstandability and iii efficientwhen applied to software projects of realistic size.
toaddresstheserequirements wepresentanovelstaticcda technique for software engineering based on graph transformation.
thetechniqueisbasedonthenotionof granularity ofconflictsand dependenciesintroducedin often theusermerelyrequires toknowifagivenrulepaircaninduceconflictsordependencies at all while detailsare irrelevant binary granularity .
atthe next level the user wants to pinpoint certain elements that present the rootcausesofconflictsordependencies coarsegranularity .
atthe acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
final level a complete description of each potential conflict and dependency is required fine granularity .
to enable an efficient computation we present an algorithm suite which can compute binary coarse grained and fine grained results rapidly.
the computation offine grained onesharnesses coarse grainedones.
moreover we conducted a user study in which the participants found coarsegrainedanalysisresultsmoreunderstandableandeasiertowork with than fine grained ones reported by a state of the art tool.
insummary thispaperpresentsa multi granular cda techniquebasedongraphtransformation achievingthesamelevel of i domain independence as the state of the art while providing major ii understandability and iii performance improvements.
specifically we make the following contributions aliterature survey of existing cda use cases sec.
focusing on granularity requirements.
aformalization of different granularity levels of conflict and dependencies sec.
for ensuring the wellfoundedness of our technique.
analgorithm suite supporting the computation of cda results at multiple granularity levels sec.
.
animplementation evaluation in which we study the performance of our algorithm suite sec.
.
auserstudy todeterminetheusefulnessofcoarse grained conflict results in comparison to fine grained ones sec.
.
with these contributions we aim to improve on the state ofthe art cda technique critical pair analysis c p a .c p a does not distinguish between granularity levels since its goal is to provideallconflictsanddependencies itsoutput alistof critical pairsdepictingeachconflictsituationinaminimalcontext always exhibits fine granularity.
from the lack of support for differentgranularity levels two main drawbacks arise.
first computing allcriticalpairscanbecomputationallyvastlyexpensive.
second comprehending the critical pairs of a set of rules can be a daunting task since the list of critical pairs generally reflects numerous options to combine the involved root causes.
our work is the first to provide a general cda technique for graph transformations supporting multiple granularity levels.
earlier usage scenarios either used cpa or task specific cda techniquesrelyingonthestructureoftheinvolvedrules .
our earlier work serves as a formal foundation forthe current one.
we now amend the existingdeclarative definitions with constructive characterizations that supportefficient computations.
to the best of our knowledge we provide the first albeit preliminary empirical evidence regarding the usefulness of cda techniques.
running example our running example deals with requirement elicitation for a web shop aservice orientedsoftwaresystemthatenablesaretailerto sell goods on a website.
customers can perform orders and inspecttheinformationongoodsandorders.
theretailerusestheavailable information to manage its business processes.
we focus on twobusiness processes one for order management and one for data mining which we do not want to interfere with each other.
this means that activities of one process should not render activities of the other process impossible hence conflicts between activities of differentprocessesshouldnotoccur.
tobeabletoanalyzeconflicts we specify activity requirements with graph transformation.
a transformation rule specifies pre and post conditions of activities.
inourexample weconsidertwoactivitiesoftheselectedbusiness processes to be specified by rules rule returnunpaidgood on theleftoffig.1returnsa goodintothestockbydeletingthecorresponding orderitem andbillitem.
in addition the returned good is removedfromthecustomer.
rule offergiftspecifiesapatternfor data mining which looks for an orderwith at least two orderitems.
thecustomer ordering and owning these items is marked for a giftoffer.
note that a customer may own a good without having itorderedandpaidsinceitmaybeagift.
bothrulesaredepicted inanintegratedformwhereannotationsspecifywhichgraphelements are deleted preserved and created.
while the preserved and deleted elements form the left hand side lhs of a rule the preserved and created elements form its right hand side rhs .
conflictandgranularityconsiderations.
toruntheselected business processes for order management and fordata mining concurrently they shall not interfere with each other.
this is the case iftheiractivitiesdonotinterferepairwise neglectinganypotential control flow on activities .
we focus our investigations on activity returnunpaidgood beingpartoftheordermanagementprocessand offergiftbeingsomedataminingactivity.
toinvestigateinterferencesbetweenthesetwoactivities weanalyzetworulesspecifyingthem.
ifanapplicationofthefirstrulerendersanapplicationofthe secondruleimpossibleor ifthesecondruleisstillapplicable but not at the original match anymore a conflict occurs.
to reduce the amount of conflicts we need to identify all their potential sources.
if the developer is just interested in knowing whether a given pair of rules can induce a conflict this information can be easily giveninatablesuchastable1wherea marksthataconflictfor the given rule pair arises while marks that there is no conflict.
rule rule returnunpaidgood offergift returnunpaidgood offergift table binary information about conflicts to get acoarse understanding of conflicts the developer may beinterestedinknowingwhichruleelementscancauseconflicts.
sincerules returnunpaidgood andoffergiftspecifyactivitiesoftwo processes that shall not interfere we are especially interested inunderstanding all conflicts related to this rule pair.
two reasons forconflicts areshowninthe middleoffigure1.
conflict causing elements are included in minimal graphs that describe the needed overlapofparticipatingrules depicted ontheleftand ontheright tocauseanactualconflictontheirapplications.
theuppergraph specifies the deletion of an order item needed to offer a gift.
the loweroneshowsthedeletionofan owns edgeneededtoofferagift.
each of these graphs with their embeddings into rules are called minimalconflictreasons.
overlappingtherulesalongsuchaconflict reason yields two conflicting rule applications called critical pair.
for afine grained representation of all conflicts we also have to consider all possible combinations of root causes.
this means that all possible compositions of minimal conflict reasons describe furtherconflictsituationswhichwejustcall conflictreasons.
one exampleofsuchaconflictreasonisshowninfigure2 wherethe order item as well as the targeting owns edge for one and the same authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure rules returnunpaidgood andoffergift and two minimal conflict reasons coarse grained information goodaredeleted bothneededtoofferagift.
thisgraphinducesone ofaltogether6conflictreasonscausedbyrule returnunpaidgood on ruleoffergift.
the conflict reasons not shown are analogous to the three ones depicted in figures and .
the remaining three onesoverlap orderitem and6 goodofrulereturnunpaidgood with orderitem and4 goodof ruleoffergift.
figure2 oneof6conflictreasonsofrule returnunpaidgood on ruleoffergift excerpt of fine grained information the state of the art cda which computes essential critical pairs however yieldsmoreresultsforthisrulepair namely10pairs ofconflictingtransformations.
while6ofthemdirectlycorrespond to the ones discussed above there are further results which do not show basically new conflict reasons but just nuances of the consideredones.
hence theexistingcdaprovidesanevenmore fine grained information about conflicts.
table compares thenumbers of coarse and fine grained results for our example distinguishing our intended fine grained analysis indicated by new fine from the existing cda indicated by ex.
fine .
while the entry for rule pair returnunpaidgood offergift shows a moderate increase of numbers this is already more striking for rule pair returnunpaidgood returnunpaidgood demonstratingabigger difference between numbers of coarse and existing fine grained conflict information versus .
in general a lot of different critical pairs can exist and it may be tedious to go through all of them.
in section we found an example rulepair with ess.
critical pairs vs. min.
conflict reasons.
rule rule returnunpaidgood offergift returnunpaidgood coarse coarse new fine new fine ex.
fine ex.
fine table number of conflict reasons and ess.
critical pairs resp.
in coarse and fine grained representations conclusion.
instead of overwhelming the user with a large numberofconflictsasthestate of the artfine grainedcdadoes a multi granular analysis supports a continuously deeper understandingofconflictswhereneeded.
inthisexample rulepair returnunpaidgood offergift is of special interest since it may be conflicting and specifies activities of two processes that should runindependentlyofeachother.
fromtheanalysis wecandeducethatdataminingonunpaidgoodsmayleadtoinconsistencies.
toavoid such conflicts the activities may be adapted by e.g.
offering a gift only for goods that have been already paid.
literature survey we conductedaliteraturesurveyto explorethe varietyofsoftware engineeringdomainsinwhichcriticalpairanalysis cpa hasbeen applied thedesignatedstate of the arttechniqueforconflictand dependencyanalysis cda based ongraphtransformation.
first wepresentcollectedstatementstoperformanceandusabilityofthe cpa.
then we elicit requirements regarding the actual granularity level needed when performing cda in specific use cases.
to identify use cases in the literature we applied the search clause critical pair and graph transformation or model transformation to the five major cs online libraries ofacm iee elsevier wiley andspringer restrictingthesearchto mentionsintitleandabstract.
thissearchyieldedaninitialbody of papers to which we added based on our knowledge about cpauses.
wediscardedthosethatfocusedontheoreticalresults and those represented by other papers in the same line of work on the same overall use case.
we grouped the remaining papers in four main softwareengineering application domains seetable .
performance and usability statements.
in several papers such as the authors recognized severe performance problemswhenusingthestate of the artimplementationofthecpa in agg .
they conclude that cpa does not scale for industrial use.
oftenatoolargenumberofcriticalpairsiscomputedwhich makesthe manualinspection ofthecparesults nearlyimpossible.
asonesolutiontoincreasetheperformanceandtodropthenumber ofresults authorstriedtoconstraintheallowedgraphs.
another wayoutofthisdilemmawastoreplacethestaticcdabyaruntime check.
however these actions either change the kind of graphsconsidered or switch from static to dynamic analysis.
from this reviewof performanceandusability statements weconcludethat authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
granularity se domainanalysis and design of software systemsmde techniques testing optimization of rule based computations binary graphparsing activity diagramvalidation editoperationrecognition nondeterminism detection coarse grained consistencyvalidationofuse cases service based systems contextaware and adaptive systems activitydiagrams featureinteraction detection model versioning refactoring recommendation detecting resolving model inconsistencies test case generation validation fine grained verification of model transformations table granularity requirements and software engineering domains of the cpa in literature survey a highly performant static analysis is needed which produces a concisesetofresultsthatiseasytoinspectmanually.
theessential cpa also available in agg was introduced as a first solution to these requirements yielding a considerably smaller set of results in asmaller amount oftime.
we observed however that eventhe essential cpa often returns too fine grained results representing an obstacle for performance as well as for usability when cda.
therefore we analyze now the requirements w.r.t.
the actual level of granularity needed when performing cda.
sedomainsandgranularityrequirements.
wedescribeour findings w.r.t.
granularity requirements of the cpa use cases along their application domains in se as illustrated in table .
insoftware system design and analysis the conformance of behavior models such as activity models and live sequence charts with the rule based specification of activities methods operations or services is investigated.
the cpa is mostly used to find and understand conflicts and dependencies in the data flow and to reason abouttheirplausibilityw.r.t.
theconsideredsystem.
inthiscontext acoarse grained cda seems to be sufficient to start with.
model driven engineering mde techniques are often specified on the basis of model transformations.
the cpa can be used to detectandtoreasonabouttheplausibilityofconflictsanddependenciesbetween specifiedtransformations.
inmodel versionmanagement thecpaismoreoverusedtoresolveconflictsbetweenmodel changes.
the coarse grained analysis seems to be sufficient to find conflictsanddependenciesbetweentransformationspecifications here.
confluenceproofs however havetob eperformedbasedona fine grained analysis since these proofs are based on completeness of the cpa results which is only given in the fine grained case.
intesting the cpa is used for reasoning about and generating interesting test cases.
a coarse grained analysis of rule interdependenciesseemsadequatetounderstandthespecifiedactivities.
inoptimization of rule based computations the cpa has been used to find out which rule pairs are conflicting or dependent at all and to exploit this information for improving the computation.
the non existence of conflicts or dependencies may allow computations without backtracking.
hence binary information about the existence of conflicts or dependencies is usually sufficient to either avoid or deliberately postpone backtracking.
for further optimization the elimination of existing conflicts or dependencies may be a choice.
furtherinformation i.e.
a coarse grainedanalysis isthen needed to understand their causes and to modify rules accordingly.
threats to validity regarding construct validity we omit investigatingexpressivenessoftheanalyzedgraphtransformationsw.r.t.
advancedtransformationfeaturessuchasnegativeapplication conditions whichisorthogonaltotherequiredgranularitylevel.
theextensionofourtechniquetothesefeaturesisongoingwork.
while not being trivial we are confident that this is possible since the underlying theory is given in a category theoretical setting.
conclusion.
wededucethefollowinggranularityrequirements for cda binary granularity refers to the situation where the relevant information is whether a conflict dependency between two graph transformations rules exists or not.
such informationis sufficient e.g.
to trim a solution space of possible alternatives.
coarse granularity refers to the situation where users need to inspectindividualconflictsanddependencies butdonotneedto know the precise details of each possible conflict or dependency situation.
finegranularity isneededtoinspecteachconflictand dependencysituationin depth.
thisisnecessary forexample to reason about confluence of a state transition relation.
our observations intable3 demonstratethatformostconsideredapplications of conflict and dependency analyses a binary or coarse grainedanalysiswouldhavebeensufficientorwouldhaverepresenteda goodstartingpointforanalysisthatcan onlyifnecessary stillbe refinedtoamorefine grainedone.
thesegranularityrequirements support the need for a multi granular approach to cda.
conflict and dependency concepts we revisit conflict and dependency concepts for graph transformationwithvaryinggranularitylevelinsec.
.
.
asanewcontribution we instantiate the binary coarse and fine granularity level asidentifiedinsec.
ofourmulti granularcdatechniquewith adequate formal conflict and dependency concepts in sec.
.
.
.
background werecallmainconceptsfromgraphtransformationwiththeconflictnotionunderlyingourwork .
then conflictanddependency concepts with varying granularity level are recalled .
graph transformation.
representing complex structures as graphs graphtransformation isoneofthemainparadigmstodescribe their rule based modification.
a rulemainly consists of two graphs lis the left hand side lhs of the rule representing a patternthathastobefoundtoapplytherule.
aftertheruleapplication apatternequal to r theright hand side rhs hasbeencreated.
the intersection k l ris the part that is not changed the part thatistobedeletedisdefinedby l k while r kdefinesthepart tobecreated.
tomakethedeletionpartofaruleagraph weaddall authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
boundary nodes b k hence obtain deletion graph c l k b .
ifcis empty the rule is called non deleting.
agraphtransformation gr m hbetweentwographs gandh is defined by first finding a match m that is a mapping of the lhs lofrule rintogsuchthat misinjectiveandfulfillsthe dangling condition alladjacentgraphedgesofagraphnodetobedeleted must be deleted as well.
second we construct hin two passes build d g m l k i.e.
erase all graph elements that are to be deleted construct h d m prime r k such that a new copy of all graph elements that are to be created is added.
example figure3showsagraph towhichrules returnunpaidgood andoffergiftinfigure1areapplicable.
considering e.g.
rule returnunpaidgood theredandthe grey parts form the lhs and the rhs consists of the green and the grey parts.
hence kis represented by the grey part.
boundary nodes are customer order bill and good.
deletion graph c consists of the red rule part together with all boundary nodes.
figure example graph to which rules returnunpaidgood andoffergift are applicable with indicated matches therule smatchesareindicatedbynumbers.
forexample customerof rulereturnunpaidgood and2 customer of ruleoffergift are both mapped to customer.
an indicates that this node is notinthecorrespondingmatch.
notethatrule returnunpaidgood can be applied in two different ways to this graph.
since rule offergiftis non deleting the dangling condition is always fulfilled.
rulereturnunpaidgood however deletestwonodes orderitem and7 billitem.
theirimagesinthegrapharenotallowedtohave danglingedges i.e.
edgeswithoutoriginsinthelhs.thisisthe case here hence both mappings fulfill the dangling condition.
theeffectofapplyingrule returnunpaidgood atthegivenmatch isthedeletionofedge ownsfrom1 customer to6 goodaswell asofnodes orderitem and7 billitem withadjacentedges.
in addition a new edge from stockto6 goodis added.
conflict.
givenagraph gthereare ingeneral severalrulesapplicableatdifferentmatches.
apairoftransformations gr1 m1 h1 gr2 m2 h2 isinconflict ifthefirstruleapplicationdeletesgraph elements used by the second one i.e.
if m1 c1 b1 m2 l2 is not empty.
since matches are injective we can build a conflict part m m1 c1 b1 m2 l2 c1that can be completed by adding incident boundary nodes to a conflict graph s1 being a subgraph of the deletion graph c1of rule r1.
moreover we have a mapping e2 m m1ofs1into l2.
together with its embedding into c1 aspan s1 c1 s1e2 l2 for rule pair r1 r2 canbedefinedwhichdistillsthecauseofaconflictandtherefore is calledconflict reason forgr1 m1 h1andgr2 m2 h2.
given a span s1 c1 s1e2 l2 for rule pair r1 r2 and mappings m1 l1 gandm2 l2 gwe say that these mappings overlap ins1ifm1 s1 m2 e2 s1 m1 l1 m2 l2 .
example in the graph in figure with the given matches of rulesreturnunpaidgood andoffergift the resulting pair of transformations is in conflict since m1 c1 b1 m2 l2 contains node orderitem withadjacentedgesandedge ownsfrom1 customer to6 good i.e.
these elements are deleted by the first transformation and used by the second one.
the corresponding conflict reasonisgivenbytheconflictgraphinfigure2 itsembeddinginto the deletion graph of rule returnunpaidgood and its mapping into thelhsofrule offergift.
bothembeddingsaregivenbynumbers compare figures and .
we focus on the conflict graph of a conflict reason while embeddings are just given by corresponding numbers as explained above.
conflictconcepts.
headingtowardsastaticconflictanalysis wedonotinvestigateeachpairofgraphtransformationsbutanalyze rule pairs instead.
rule pair r1 r2 is inconflictif there is any pair of conflicting transformations applying rule r1and then r2.
we further concentrate on rule parts that may cause conflicts.
the minimal building bricks of conflict causes are called conflict atoms.
an atom is derived from an atom candidate being a span a1 c1 a1e2 l2 for rule pair r1 r2 where a1is a single deletednodeoredgeincidentwithpreservednodes.
itisdeleted bythefirstruleandusedbythesecondone.
adeletededgewithat leastoneincidentdeletednodeisnotconsideredasatomcandidate since the edge is deleted together with the deleted node anyway.if a pair of transformations exists so that their match mappings overlapontheatomcandidate itiscalled conflictatom.
notethat in general the matchesofsuch apairof transformationsmayoverlap also in graph elements other than the conflict atom.
aconflict reason s1 c1 s1e2 l2 for rule pair r1 r2 subsumesallatomsbeinginvolvedinaconflict.
amongtheconflict reasonsfortworules thereare minimalreasons describingminimal compositions of atoms leading to conflict reasons.
in contrast to conflict reasons showing conflict causing rule overlaps a criticalpair consistsoftwoconflicting transformations applyingtworulesinaminimalcontext whereallelementsstem from l1orl2orboth.
criticalpairanalysis cpa isthe state of the art static cda for graph transformation.
the set of critical pairs has the important property that it is complete each possible conflicting pair of transformations is represented by some critical pair.
two important subsets of critical pairs being still complete have been identified in the literature an essential critical pair is one where the rules lhss overlap merely deletion graph elements of one rule with lhs elements of the other rule i.e.
only the conflict reason is overlapped.
the rationale is that overlappingadditionalpreservedelements asdoneinregularcpa doesnotcontributetonewconflicts.
essential criticalpairscanbe computedwiththestate of the artimplementationofthecpain agg and verigraph .
aninitial conflict is an essential criticalpairwithoutisolatedboundarynodes.
thelatterarisewhen a preserved node with incident deletion edges of the first rule isoverlapped with a node of the second rule without overlapping authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
any incident deletion edge of the first rule.
such overlaps do not contribute to new conflicts.
initial conflicts represent currently the most optimal subset of critical pairs fulfilling the completeness property but their detection has not been implemented yet.
example .
considering the conflict reason in figure it is covered by two conflict atom graphs consisting of node5 orderitem and edge ownsfrom1 customer to6 good.
we can complete conflict atom orderitem to a minimal conflict reason by adding both adjacent edges and their incident source or target nodes.
it is shown as top graph in figure .
the conflict atomincludingthe ownsedgealreadyconstitutesaminimalconflict reason shown underneath the top graph in figure .
both together form the conflict reason shown in figure .
overlapping the lhss of both example rules at this conflict reason yields the graph in figure3.
theresultinglhsembeddingsintothisgraphareactually rule matches since they fulfill the dangling condition as shownabove .
the corresponding transformations form a critical pair which is actually an initial conflict here.
dependencyanddependencyconcepts.
forreasoningabout dependencies wheregraphelementsbeingproducedbythefirst transformation are used by the second one we simply consider the dual concepts by inverting the first transformation of a conflicting pair.
based on this analogy the concepts dependency between rules and minimal dependency reason are defined accordingly.
.
formalizing granularity levels as suggested by the granularity requirements derived from our literaturesurveyinsec.
varioususe casesmayrequireeitherfinegrained coarse grained and binary analysis results.
to support all of these granularity levels in our technique we formalized each granularitylevelwithappropriateconflictanddependencyconcepts as outlined in this section.
a full account of formal definitions characterizations and proofs is given in .
overapproximation.
our survey in sec.
indicates serious performanceproblemsin practicewhencomputingconflictinformation on a fine grained level in the form of essential critical pairs as donein the state of the artimplementation in agg .
thereforewe proposeasfirstimprovementa well chosen overapproximation ofresultsthatiseasiertocompute.
itisbasedonthe idea that if there is a conflict for a pair of rules r1 r prime then an equivalent conflict exists for the rule pair r1 r2 with r2being the non deletingvariant ofrule r prime .
theotherdirectiondoesnothold since the dangling condition of rule r prime 2could be violated then.
mapping conflict concepts.
fig.
gives an overview of how we further map conflict concepts to granularity levels.
sinceinitialconflictsrepresentcurrentlythemostoptimalsubset of critical pairs being still complete we have chosen to return allconflict reasons for r1 r2 corresponding to initial conflicts as newfine grainedresults.
aninitialconflictfor r1 r2 with r2being non deletingsimplycorrespondstotheoverlapofsuchaconflict reason.
as reported in sec.
this choice represents a very good trade off between precision and performance.
moving to the coarse grained level we selected minimal conflict reasons since our considered conflict reasons at the fine grained level are composed of minimal ones.
the conflict graph of minimal conflictreasonsforarulepair r1 r2 with r2non deletingcanbe figure conflict concepts mapping to granularity characterizedassubgraphofaso calleddeletioncomponent.
the deletionpart l1 k1ofagivenrule r1mayconsistofseveraldisjointfragments called deletionfragments.
completingadeletion fragmenttoagraphbyaddingallincidentboundarynodesfrom b1 yieldsadeletioncomponent .
eachtwodeletioncomponentsoverlap inboundarynodesonly theunionofalldeletioncomponentscoincides with the deletion graph c1of the rule.
deletion components thus specify maximal partsof c1that need to be overlapped in ordertofindcorrespondingconflictingtransformations.
overlapping more elements than present in a deletion component can neverlead to additional minimal conflict reasons since if the dangling condition of r1was not fulfilled before it will never be fulfilled.
example rulereturnunpaidgood in figure hasthreedeletionfragments node orderitem withadjacentedges node7 billitem with adjacent edges and edge ownsfrom node to node .
for completing them to deletion components boundary nodes1 customer order bill and goodareneeded.
onthebinarylevel wereportifa rulepairisconflicting since thismeansbydefinitionthatthereisatleastonepairofconflictingtransformations via these rules.
in particular we can check if there isaminimalconflictreasonforthegivenrulepair r1 r2 with r2 non deleting equivalent with the rule pair being conflicting.
example twominimalconflictreasonsofrule pair returnunpaidgood offergift were discussed above.
hence thesetworulesareinconflict.
twofurtherminimalconflictreasons ariseifnode5ofthefirstruleoverlapswithnode3ofthesecond rule and if node of the first rule is overlapped with node of the secondone.
thesefourminimalreasonsformthecoarseanalysis resultoftheconsideredrulepair.
togetherwithalltheirpossible combinations we get conflict reasons being reported as new fine analysis result in table .
mapping dependency concepts.
as mentioned before a dependency canbeunderstoodasdualconcepttoconflicts.
analogous totheconflictcase weoverapproximateproduce usedependencies by produce read dependencies.
then dependencies between rules minimal dependency anddependency reasons are mapped to the binary coarse and fine granularity level accordingly.
algorithm suite we present an algorithm suite for computing binary coarse and fine grainedconflicts.
itisimplementedinhenshin amodel transformationframeworkbasedongraphtransformationconcepts.
given a pair of rules we consider a non deleting variant of the second rule supporting the overapproximation presented in section4.
.
thealgorithminfigure5computesminimalconflict reasons coarsegranularity .
thealgorithminfigure6usesthese resultstocomputeallconflictreasons finegranularity .
tosupport use cases where binary granularity is sufficient we can stop the computation as soon as one minimal conflict reason is discovered.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
functcomputeminreasons r1 rule r2 rule varreasons for eachc computeatomcandidates r1 r2 do computeminreasonsrecursively r1 r2 c reasons returnreasons functcomputeatomcandidates r1 rule r2 rule varcandidates for eachel1 r1.conflictinducin elements do for eachel2 r2.lhs .occurenceof el1 do vars1 newgraph el1 varembed r1 newmappin el1 mapsto el1 varembed r2 newmappin el1 mapsto el2 candidates newspan s1 embed r1 embed r2 returncandidates functcomputeminreasonsrecursively r1 rule r2 rule s1 span reasons set span var g m1 m2 constructoverlap r1 r2 s1 variscr s1 finddan lin ed es r1 m1 .isempty ifiscr s1thenreasons s1 return else for eachs2 extendspan r1 r2 s1 reasons do computeminreasonsrecursively r1 r2 s2 reasons functextendspan r1 rule r2 rule s1 span reasons set span var g m1 m2 constructoverlap r1 r2 s1 vardan lin finddan lin ed es r1 m1 varfixin dan lin .foreach findfixin ed es r1 r2 s1 returna e rate fixin .foreach enumerateextensions s1 figure computing minimal conflict reasons.
computing minimal conflict reasons.
for efficiency we use the characterization of minimal conflict reasons as introduced in sect.
.
.
the key idea is to compute first the set of all conflict atom candidates line .
to this end all conflict inducing elements ofr1are identified in line .
each match of such an element to r2 line is extended to a span lines yielding an atom candidate.
next we try to extend each atom candidate to minimal conflict reasons line recursively and return the results line .
todetermineefficientlyifaparticularcandidatecanbeextended to a minimal conflict reason recursively we check if it gives rise to a critical pair by computing the overlap graph gof the rules lhss alongthecandidate line18 andcheckingifthecorrespondingembeddings m1 l1 gandm2 l2 gare rule matches line .
sinceweassume r2tobenon deleting m2isautomaticallyamatch.
weare finishedif m1isa matchas well i.e.
if r1canbe appliedat embedding m1without producing dangling edges meaning that we found a reason line .
otherwise we extend candidate spans inpotentiallyseveralways line21 discardingfurtherextension opportunities in case we identified a conflict reason.
we computed all extensions by function extendspan line .
a span s1has to be extended if the rule lhs embeddings into a given overlap graphdo notfulfillthe danglingcondition line .
anextension isperformedstepwisebyfirstidentifyingalldanglingedges line .
for each of them a set of fixing edges in r2is searched line .
suitable candidates for this purpose are all adjacent edges ein c1 s1ofe s adjacent node in s1being identified by calling findfixingedges .
for each fixing edge function enumerateextensions line yields a set of spans each extending s1by an edge and its adjacentnodeifnotpreviouslyincludedin s1.
allthesesetshave to be aggregated to obtain the result line .
since we know that aminimalconflictreasonisalwayspartofadeletioncomponent wehaveastoppingcriterionfortheextensionprocess aswecan focus on adjacent edges when computing extensions.computing conflict reasons.
starting from a set of minimal conflictreasons allconflictreasonscanbecomposedofthem.
functioncomputeconflictreason infigure6picksanyminimalreason mroutofagivenset line4 addsitasreason line5 andcomposes itwiththeset subreasons ofallconflictreasonscomputedfromthe remaining set of minimal reasons lines .
all conflict reasons insubreasons arefirstofallconflictreasonsthemselves line9 and second to be composed with mrif composable lines .
functcomputeconflictreasons minreasons set span varreasons ifminreasons .nonempty then varmr minreasons .pickany reasons .add mr ifminreasons .size then varsubreasons computeconflictreasons minreasons .remove mr reasons .add subreasons for eachs subreasons do ifiscomposable mr s thenreasons .add compose mr s returnreasons figure computing conflict reasons.
computingdependencyreasons.
weinvertrule r1 compute all conflict reasons and interpret them as dependency reasons.
implementation.
we implemented the algorithm suite for the henshin model transformation language which is based ongraph transformation concepts and the eclipse modeling framework emf .
our implementation includes a comprehensive test suite inwhichthetestoracleisprovidedbycomputingfine grained conflicts in the state of the art cda framework agg.
section studies the performance of our implementation.
implementation evaluation we evaluated our analysis via comparison to the existing analysis inagg focusingontworesearchquestions rq1 howfastareour coarseandfine grainedanalysesinrelationtotheexistinganalysis in agg?
rq2 what is the degree of the overapproximation of the multi granular cda technique?
we performed our evaluation on three subject rule sets all of them representing use cases identified in sect.
refac is a setofrefactoringrulesasusedinrefactoringrecommenders .
fmedit is a set of editing rules that was proposed in a sa benchmark for edit operation detection .
nanoxml is a set of rules that was reverse engineered from the java code for asmall xml parser to provide an oracle for test case generation .
theimplementationandevaluationartifactsareavailable at rq1.we considered the essentialcpa in agg and compared it with our computations of minimal conflict dependency reasons mcr mdr as coarse grained analysis and conflict dependency reasons cr dr as fine grained one.
we analyzed delete useconflictsbetweeneachrulepairconsideringanon deletingversion of the use rule in each case.
moreover we preprocessedthe rule set and meta model such that they fit to the features supported by agg and by our implementation.
in the results we observed that our approach achieved a major speed up from e.g.
over minutes to seconds for rule pairs.
in terms of quantity we see that the mean number of results dropped considerably for the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
runtime m ss.x results mean rule mcr cr ess.mcr cr ess.
rule set pairsmdr dr cpamdr dr cpa refac .
.
.
.
.
.
fmedit .
.
.
.
.
.
nanoxml .
.
.
.
.
.
table rq1 results from our coarse mcr mdr and finegrained cr dr vs. theexistinganalysisinagg ess.
cpa .
rule set prec.recall refac .
.
fmedit .
.
nanoxml .
.
table overapproximation results larger cases e.g.
from .
to .
for fmedit rule pairs.
there were even more striking results for individual rule pairs.
in the most extremecase wehad1588ess.
criticalpairs 644conflictreasons and min.
conflict reasons.
a trend towards excessive individual casesisreflectedinahigherstandarddeviationofresults which in the fmedit case amounted to .
for coarse grained .
for fine grained and .
for the essential cpa results.
rq2.we computed the sets of essential critical pairs ess.
cps for an original rule pair and the one for a pair where the second rule is the non deleting variant of the original one.
both sets of ess.
cps have been filtered w.r.t.
initial conflicts dependencies .
theprecisionisthepercentageofrulepairswithequalnumbersof initial conflicts dependencies .
since we do an overapproximation the recall is always .
i.e.
we do not miss a critical pair when switching to the non deleting rule variant.
the precision however happenstobesmallerthan1.
i.e.
falsepositivescanoccur.
asthe results in table show the resulting precision is still acceptable.
threadstovalidity.
external validity can be questioned since we focus on a limited number of rule sets being preprocessed accordingtounsupportedfeaturessuchasapplicationconditions andamalgamation .
weintendtosupportmoretransformation featuresinthefuture thusenablingamorecomprehensivestudy with more expressive subject rule sets.
user study thegoalofouruserstudyistotesttheusefulnessofourtechnique s output compared to that of its predecessor critical pair analysis cpa .asdiscussedinsection3 inmanyuse cases coarse grained results may provide a more suitable level of detail than the fine grained ones produced by cpa.
focusing on such use cases weinvestigated the following research question how useful are our coarse grained results compared to fine grained ones?
weconductedauserstudyinwhichcomprehensiontaskshad to be solved based on conflict analysis results.
the analysis results wereembeddedas screenshotsinto anonline questionnaire.
with this web based setup we aimed to recruit a sufficient number of participantswithappropriateexpertiseingraphtransformations.
areplicationpackagewithalltasksanddatafromouruserstudy is available at focusing on the usefulness concerns of user performance and perception our null hypotheses were as follows h0perf users can solve comprehension tasks equally well using the given coarseand fine grained results h0perc users perceive the usefulness of thegiven coarse and fine grained results as equal.
we used a standard experimental setup involving independent dependent and controlledvariables.
granularitywastheindependentvariable.
user performance and perception were the dependent variables.
we controlled the used examples and the chosen visualization by keeping them constant.
all analysis results were shown in the result visualization of agg .
methods participants materials.
ourstudydesignisa crossoverstudy avariantof within subjectdesign inwhichallparticipants are sequentially exposed to both treatments here coarseand fine grained analysis results .
we selected this design because itminimizesthenumberofparticipantsnecessarytoidentifystatisticallysignificantdifferencesbetweentheresulttypes.
themain threattothevalidityforthisdesignarelearningeffects.
welater discuss threats and adopted mitigation measures.
the experiment took place in summer .
to recruit subjectswithappropriateexpertise weinvitedparticipantsofrecent software engineering conferences focusing on model and graph transformations and authors of the papers surveyed in sect.
.
wesent invitations to persons of which participated in the survey.
our overall sample consisted of academic scientists phd students practitioners and msc student.
to survey the shared software engineeringandgraph transformationbackgroundofour participants we collected demographic data based on five pointlikert scales.
respondents rated their experience with uml based modeling or higher of them like did for their graph transformationexperience in27cases 25participants rated their experience as cda users as or higher cases .
the questionnaire was made up of three parts an instruction part an experimental part and a survey part.
the instruction part used an example to revisit basics about conflicts of graph transformationsandfamiliarizetheparticipantswiththeusedvisualization.
thecomprehension partincludedquestion basedcomprehension tasks.
in the surveypart we aggregated the demographic information and asked the participants for their subjective experiences.
the instruction and comprehension parts used a common example domain namely the detection of conflicting requirements during the development of an online shop.
the rationale for choosing this domain was twofold first it did not require expertise in a specializedtechnicalenvironment.
second itisbasedonause case in which we hypothesize that coarse grained results are beneficial namely consistency validation of use cases .
the example in sect.
is representative for this example domain and use case.
in the comprehension part each participant solved two tasks one for each granularity level.
each task included an example rule pair anumber of conflictanalysis results and twoquestions first whether any conflicts existed for the rule pair.
second if the firstquestionwasanswered yes weaskedtonamethespecific elements causing the conflicts.
the rule pairs and their order were thesameforeachparticipant.
theorderofthegranularitylevels used to present the conflicts was assigned randomly.
based on the questions the task metrics were measured as follows a correct answerforthefirstquestionwasrewardedwith1point.
thesecond questionwasmorecomplicated whichwasreflectedin2pointsfor a fully and point for a partially correct answer.
the time needed to complete both tasks was measured using the questionnaire.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table user study results.
conflict type correctness completion time understandability simplicity effort hard to understand hard to solve tasks much effort fine grained .
.
.
min .
min .
.
.
.
.
.
coarse grained .
.
.
min .
min .
.
.
.
.
.
p .
p .
p .
p .
p .
we tested the tasks in a prestudy with participants in which we experimented with various difficulty levels.
we aimed to balancecomplexity thedrawbacksoffine grainedresultsaremore obviousforcomplexexamplesandtasks andsimplicity toavoid participant exhaustion and to benefit completion rate.
to this end we decided to drop additional tasks concerning dependency analysisandconflictrepair.
theactualtasksusedinourexperiment were based on the conflict example shown in sect.
task and a comparableone task2 .
fine grainedresultsrepresentessential critical pairs as provided by the state of the art cda tool agg.
coarse grained results are those of our multi granular cda.
in the survey part to measure user perception the participants wereaskedfortheirsubjectiveassessmentofbothgranularitylevels.
three metrics were collected using five point likert scales ratings of understandability how easy was it to understand the results of type x?
difficulty of solving tasks how difficult was it to answer the questions using the results of type x?
and perceived effort how much effort was required to answer the questions using the results of type x?
.
finally we asked them for their overall preferencebetweenbothgranularitylevelsonafive pointlikert scale.
additionalqualitativeinformationregardingthesubjective assessment was collected using free form text fields.
for statistical hypothesis testing we used the wilcoxon signedranked test and where applicable the paired samples t test .
wilcoxon is a standard nonparametrized test that supports high confidence inferences for paired data.
the t test providesgreater statistical power than wilcoxon for normally distributed data.
we checked for normality using the shapiro wilk test .
figure correctness and completion time.
results.
table summarizes the results in terms of descriptive and inferential statistics.
the task metrics are visualized with boxplotsinfig.
.
irrespectiveofwhethercoarse orfine grained detection results were used the vast majority of all participants answered the tasks with full correctness scores.
the mean time required to complete the tasks was shorter by minutes when coarse grained results were used.
yet the completion times for the fine grainedcaseincludedtwoexcessivedatapointsof28and31 minutes whichcanbeconsideredasoutliers.
afterremovingthem themeancompletiontimeforcoarse grainedisstilllowerby0.
minutes.
thecompletiontimesdidnotnotdiffertoastatistically significant extent p .
.
in summary since we cannot find a significant effect on correctness and completion time our first null hypothesis h0perfcannot be rejected.theperceptionmetricsofunderstandability difficulty andeffort are visualized in fig.
.
in all cases the participants reported more positive vs. fewer negative vs. andfewerneutralscores vs. whenworking withthecoarse graineddetectionresults theyexperiencedbetter understandability ease ofsolving tasks and less effort.
the differences were strongly statistically significant p .
.
in summary our second null hypothesis h0percis rejected.
figure user perception and preference.
finally we asked for an overall subjective preference.
fig.
givesadistributionoverview coarse grainedresultsattractedmore subjectivepreferencesthanfine grainedones.
infact theoverall sample ismostly divided intotwo groups those participantswith a preference for the coarse grained results of them with a strong preference and those without a preference .
in qualitative information collected using the questionnaire we found that the reasons for preferring were largely in line with our motivation participants found that less results provided a quicker overview andthatcoarse grainedresults boildowntheproblemto actual distinguish conflicts .
some subjects extrapolated from our taskstomorecomplexcases assumingthatwehavealargersetof rulesthatconflictwitheachother i dassumethatthe results will become very complex and hard to understand .
wealsofoundreasonswhythispreferencewasnotsharedunanimously.
someparticipantsfoundtheredundancyoffine grained beneficial as it presented conflicts more consistently and felt that coarse grainedresultsdidnotmirrortheirunderstandingofconflicts i believe that displays all conflicts whereas onlydisplaysselectedconflicts.
thisgroupofusers maystillbenefitfromourfastercomputationoffine grainedresults.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
threats to validity.
construct validity.
for our effort and understandability measurements we rely on subjective ratings by the participants.
however such subjectivemeasures arehighlycorrelated with objective measures of cognitive load .
moreover we aimed to avoid participant bias in favor of the experimenters by replacingthenamesoftheusedtoolsandconceptswithpseudonyms.
internal validity.
the main threat in our within subject design are learning effects in particular since the same questions were askedforeachanalysisresulttype albeitfordifferenttasks .
we mitigated this threat by using counterbalancing i.e.
randomizing the order in which the results were shown to the participants.
external validity.
we addressed external validity by recruiting asufficientlylargenumberofparticipantswithrelevantsoftware engineering and cda expertise.
however our web based setup requiredsometrade offs thesampleanalysisresultswererelatively small 10entries and wereshownusingscreenshotsinsteadof in the actual tool.
generalizations to a greater variety of use cases arethreatenedsinceweconsideredasingledomainanduse case.
while our discussion in sect.
highlights key similarities to other domains a definitive verdict on the practical usefulness of coarsegrained results is outside the scope of this paper.
summary.
having identified use cases in which the level of detail offered by our coarse grained results seems sufficient sect.
we set out to empirically study their usefulness in one such usecase.
while we did not detect an effect on participants performance theparticipantsperceived coarse grained resultsaseasier to understand and work with than fine grained ones.
the relative majority of participants preferred coarse grained over fine grained results.
our user study complements significant performance benefit achieved by our multi granular computations and to the best of our knowledge provides the first empirical evidence on the usefulness of cda for graph transformation.
related work inthispaper wehavepresentedageneric multi granularcdatechniquebasedongraphtransformation gt whichisstaticallyanalyzingtransformationrules itisfullyautomaticandstate independent.
we compare with other analysis techniques along these aspects.
furthergtanalysistechniques.
anotherstaticanalysis techniqueforgtchecksforinvariants .
incontrast modelchecking techniques forgt needaninitialstartgraphandthengenerateforthisgraphandagivenrulesetacorrespondingstatespaceinorder to analyze more complex temporal logic properties.
whereas bothkindsofanalysistechniquesarefullyautomatic thereexist alsointeractivetheoremprovingtechniques dedicatedtogtthatare able to prove partial correctness of graph programs .
with respect to designing and performing analysis techniques withdifferentgranularitylevels wecanrelateourworkinabroader sensetotheworkon counterexampleguidedabstractionrefinement cegar initiallydescribedin andappliedtotheanalysisof gtin .
ourapproach containsa similarideain thesense that weperformastepwiseanalysistechniquewithdifferentlevelsof accuracyandterminatewiththelevelofaccuracythatisneeded.inthecegarapproachthedesiredlevelofaccuracyisobtained if either the desired property for the analyzed system is success fully verified or a real counterexample has been detected.
in ourapproachtherecanbemanydifferentuse casestobesatisfiedwith acertainlevelofaccuracyoftheanalysisasdescribedindetailin the literature review in section .
other genericcda techniques.
besides gt there exist other formal approaches which allow for static and dynamic cda of specifiedsystems.
achurch rosser checkerforequationalspecificationsinmaude looksforcriticalpairsbetweenconditional term rewriting rules and tries to join them.
there are also logicbasedapproachessuchas conditionaltransformations providing static cda techniques.
these techniques are generic and therefore language independent but the analysis techniques provided arenotmulti granular.
furtherlogic basedapproachessuchas constraint networks andmodel checking approaches such as alloy are not state independent.
language specific cda techniques.
there are many sophisticatedcdatechniquesinthecontextofsequentialandconcurrent programming.
in the context of concurrent threads conflicts arecalled data races they occur if two different threads access the same memory location and at least one of them is a write see e.g.
.
common challenges of these techniques are dynamic object creation dynamic thread creation and