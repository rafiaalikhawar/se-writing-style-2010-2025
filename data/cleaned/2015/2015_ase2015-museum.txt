mutation based fault localization for real world multilingual programs shin hong byeongcheol lee taehoon kwak yiru jeon bongsuk ko yunho kim moonzoo kim kaist south korea hongshin thkwak podray kimyunho kaist.ac.kr moonzoo cs.kaist.ac.kr gist south korea byeong bsk gist.ac.kr abstract programmers maintain and evolve their software in a variety of programming languages to take advantage of various control data abstractions and legacy libraries.
the programming language ecosystem has diversified over the last few decades and non trivial programs are likely to be written in more than a single language.
unfortunately language interfaces such as java native interface and python c are difficult to use correctly and the scope of fault localization goes beyond language boundaries which makes debugging multilingual bugs challenging.
t o overcome the aforementioned limitations we propose a mutation based fault localization technique for real world multilingual programs.
t o improve the accuracy of locating multilingual bugs we have developed and applied new mutation operators as well as conventional mutation operators.
the results of the empirical evaluation for six non trivial real world multilingual bugs are promising in that the proposed technique identifies the buggy statements as the most suspicious statements for all six bugs.
i. i ntroduction many software systems today are written in multiple programming languages to reuse legacy code and leverage the languages best suited to the developers needs.
over the last few decades language designers have made a variety of choices in designing the syntax and semantics of their languages.
the result is a robust ecosystem where a few languages cover the most use in part due to open source libraries and legacy code while many languages exist for niche uses .
this ecosystem is likely to make developers write a multilingual program which is a non trivial program written in more than a single language.
high level languages such as java python and ocaml provide standard libraries which typically call legacy code written in low level languages e.g.
c to interface with the operating system.
a number of projects for the legacy libraries that have evolved for decades provide language bindings for each language.
a large scale software project employs a number of libraries written in multiple languages.
correct multilingual programs are difficult to write in general in part due to the complex language interfaces such as java native interface jni and python c which require the programs to respect a set of thousands of interface safety rules over hundreds of application interface functions .
moreover once a bug occurs at interactions of code written in different languages programmers are required to understand the cause effect chains across language boundaries.
despite the advances of automated testing techniques for complex real world programs debugging multilingual bugs in real world programs is stillchallenging and requires significant human effort.
for instance bug in the eclipse bug repository crashes jvms with a segmentation fault in c as an effect when the program throws an exception in java as the cause section vi .
locating and fixing this bug took a heroic debugging effort of more than a year from to with hundreds of comments from dozens of programmers before the patch went into eclipse .
.
in september .
the existing error detectors targeting multilingual program errors are not effective in debugging this case because they can only report certain kinds of safety rule violations they cannot indicate the root cause of the bug especially when the bug does not explicitly involve any known safety rule violations.
moreover these bug detectors do not scale well to a large number of languages and various kinds of program errors since they have to deeply analyze the semantics of each language for each kind of bug.
this paper presents a mutation based fault localization mbfl technique for multilingual programs.
the technique takes multilingual source code of a target program and a set of test cases including at least one failing test case as input it then and generates a list of statements ordered by their relevance to the error i.e.
suspiciousness score .
to calculate the suspiciousness score of a statement a mbfl technique first generates diverse variants of target programs by systematically changing each statement i.e.
mutants and then observes how testing results change if a certain statement is mutated.
in addition to improve the accuracy of localizing multilingual bugs e.g.
bugs whose causes and effects are located in code segments written in different languages we have developed new mutation operators focusing on localizing multilingual bugs1.
the proposed mbfl technique for real world multilingual programs is effective i.e.
it identifies the locations of bugs precisely and language agnostic i.e.
extensible for combination of various programming languages .
our empirical evaluation of six real world java c bugs demonstrates that the proposed technique locates the bugs in non trivial real world multilingual programs far more precisely i.e.
the technique identifies the buggy statements as the most suspicious statements for all six bugs than do the state of the art spectrum based fault localization sbfl techniques section iv .
for 1the proposed technique is an extension for multilingual bugs based on muse which targets to localize c bugs .
30th ieee acm international conference on automated software engineering .
ieee example for bug in the eclipse bug repository the technique indicates the statement at which the developer made a fix as the most suspicious statement among a total of candidates section vi .
in summary this paper s major contributions are new mutation operators targeting multilingual program errors which are highly effective at locating multilingual bugs section iii c empirical demonstration of the high accuracy of the mutation based fault localization technique for the six real world multilingual bugs section iv detailed report on two case studies to determine why and how the proposed technique can precisely localize real world multilingual bugs sections v and vi .
the rest of the paper is organized as follows.
section ii describes the background on multilingual debugging and fault localization techniques.
section iii explains our mbfl technique.
section iv provides an overview of the empirical study on the six real world multilingual bugs.
sections v and vi describe two case studies on real world multilingual bugs in detail.
section vii discusses observations made through the experiment.
section viii concludes this paper with future work.
ii.
b ackground and related work a. multilingual bugs a multilingual program is composed of several pieces of code in different languages that execute each others through language interfaces e.g.
jni and python c .
these language interfaces require the multilingual programs to follow safety rules across language boundaries.
lee et al.
classifies safety rules in java c programs into three classes state constraints type constraints and resource constraints state constraints ensure that the runtime system of one language is in a consistent state before transiting to from a system of another language.
for instance jni requires the program to not propagate a java exception before executing a jni function from a native method in c. type constraints ensure that the programs in different languages exchange valid arguments and return values of expected types at a language boundary.
for instance the newstringutf function in jni expects its arguments not to be null in c. resource constraints ensure that the program manages resources correctly.
these resource constraints are comparable to the contracts of calling the free function for dynamically allocated memory in c. for example a local reference lto an java object obtained in a native method m1should not be reused in another native method m2since lbecomes invalid when m1terminates see section v as an example of a multilingual bug that violates this resource constraint .
a multilingual bug is caused by violating safety rules at language interface i.e.
foreign function interface ffi bugs and or by unintended interactions of code across language boundaries.
when a program breaks an interface safety rule the program crashes or generates undefined behaviors.
multilingual programs respecting all interface safety rules stillcan have multilingual errors when the cause effect chain goes through languages interfaces.
for instance a program would leak a c object referenced by a java object that is garbage collected at some point.
the cause of the memory leak is in java at the last reference to this java object while the effect is in c because java code is expected to free the c object section iii a .
b. debugging multilingual bugs debugging a program bug consists of the following three steps detecting an error locating the root cause of the error i.e.
buggy statements and creating a fix on the buggy statements.
these three steps are more challenging for multilingual programs than for monolingual programs because interactions among different languages should be considered which increases the complexity of debugging.
for the first step i.e.
detecting a multilingual error there exist dozens of static and dynamic analysis techniques .
some of these techniques provide bug checkers that detect predict interface safety rule violations for example checkjni which is a built in dynamic jni checkers in jvms such as hotspot and j9 .
the other techniques detect an error in one programming language while the root cause would be in other languages.
unfortunately few techniques support the second step i.e.
fault localization of multilingual bugs .
although the aforementioned static and dynamic analysis techniques can detect predict multilingual errors locating the buggy statements that cause the multilingual errors is still challenging because the root cause of multilingual errors is often nontrivial and located far from the error sites for examples see sections v vi .
although multilingual debuggers may support programmers in locating the causes of the bugs manually it still takes a considerable amount of time to localize a complex multilingual bug e.g.
bug of the eclipse bug repository .
c. mutation based fault localization fault localization techniques aim to locate the root cause of an error in the target program i.e.
the second step of debugging by observing test runs.
fault localization has been extensively studied for monolingual programs both empirically and theoretically .
spectrum based fault localization sbfl techniques infer that a code entity is suspicious for an error if the code entity is likely executed when the error occurs.
note that sbfl techniques are language agnostic because they calculate the suspiciousness scores of target code entities by using information on the testing results i.e.
fail pass of test cases and the code coverage of these test cases without complex semantic analyses.
however the accuracy of sbfl techniques is often too low to localize faults in large real world programs.
to improve the accuracy of fault localization mutationbased fault localization techniques mbfl have been proposed recently these techniques can analyze diverse program behaviors using mutants i.e.
target program versions that are generated by applying simple syntactic code changes such as replacing if x withif x .
mbfl techniques are 465also language agnostic since they utilize only information on the testing results i.e.
fail pass of test cases on the original target program and its mutants.
moon et al.
demonstrate that their mbfl technique calling it muse is .
times more precise than state of the art sbfl techniques such as ochiai and op2 on the versions of the sir subjects.
the key idea of muse is as follows.
consider a faulty program pwhose execution with some test cases results in error.
let mfbe a mutant of pthat mutates the faulty statement and mcbe one that mutates a correct statement.
muse assesses the suspiciousness of a statement based on the following two observations observation a failing test case for pis more likely to pass onmfthan on mc.mutating a faulty statement is more likely to cause the tests that failed on pto pass on mfthan onmcbecause a faulty program might be partially fixed by modifying i.e.
mutating a faulty statement but not by mutating a correct one.
therefore the number of test cases whose results change from fail to pass will be larger for mf than for mc.
observation a passing test case for pis more likely to fail on mcthan on mf.a program is more easily broken by mutating a correct statement than by mutating a faulty statement.
thus the number of the test cases whose results change from pass to fail will be greater for mcthan for mf.
there exist a few other mbfl approaches.
to localize faults precisely zhang et al.
measure fault inducing changes in regression testing and papadakis et al.
measure mutant similarities.
in contrast muse utilizes the differences introduced by mutants for fault localization.
iii.
m utation based fault localization for real world multilingual programs to alleviate the difficulty of debugging multilingual programs we have developed a mutation based fault localization technique for real world multilingual programs museum .
museum is language independent because it generates syntactic mutants and statistical reasoning with testing results on a target program and its mutants.
museum does not require special build runtime environments but only a mutation tool and a coverage measurement tool for target programming languages.
this is a great advantage over other debugging techniques which require specific infrastructure such as virtual machines or compilers.
museum targets both monolingual and multilingual bugs.
to localize multilingual bugs precisely museum utilizes conventional mutation operators and new mutation operators designed for directly mutating interactions between language interfaces.
these new mutation operators section iii c improve the accuracy of mbfl by generating mutants whose testing results are informative to locate multilingual bugs section v .
a. motivating example target program figure presents a target java c program with a memory leak bug failing the assertion at line .
2this example is a simplified version of a real world bug found in azureus .
.
.
bug1 in table ii .
cptr.java public class cptr static system.loadlibrary cptr private final long peer private native long nalloc private native void nfree long pointer private native int nget long pointer private native void nput long pointer int x public cptr peer nalloc public int get return nget peer public void put int x nput peer x public void dispose nfree peer cptr.c include jni.h include stdlib.h jlong java cptr nalloc jnienv env jobject o jint p p jint malloc sizeof jint mutant m1 return jlong p void java cptr nfree jnienv env jobject o jlong p free void p jint java cptr nget jnienv env jobject o jlong p return jint p void java cptr nput jnienv env jobject o jlong p jint x jint p x client.java public class client cptr m null void add int x m new cptr mutant m2 m.put x int remove int x m.get m.dispose m null return x mutant m3 clienttest.java import java.util.
public class clienttest static final list pinnedobj new linkedlist public static object pinobject object o pinnedobj.add o return o void passingtest passing test case try client d new client d.add assert d.remove catch virtualmachineerror e assert false potential memory leak in c void failingtest failing test case try client d new client d.add d.add assert d.remove catch virtualmachineerror e assert false potential memory leak in c fig.
a java c program leaking memory in c after garbage collection in java 466the program is composed of source files in c and java defining three java classes cptr client and clienttest .
cptr lines characterizes the peer class idiom p. of wrapping native data structures which is widely used in language bindings for legacy c libraries.
the peer field line is an opaque pointer from java to c to point to a dynamically allocated integer object in c. the cptr constructor line executes the nalloc native method lines to allocate an integer object in c and stores the address of the integer object in peer .
while jvms automatically reclaim a cptr object once the object becomes unreachable in the java heap the clients of cptr are required to dispose manually the integer object by executing dispose line on the cptr object.
if the client does not dispose an cptr object before it becomes unreachable the peer integer object becomes a unreachable memory leak in c. client lines is a client java class of using cptr .
the mfield line holds a reference to a cptr object.add lines and remove lines write read a value to from the cptr object respectively.
add instantiates acptr object assigns the reference of the new object to m and then writes a value to the object.
remove reads the value of the cptr object pointed by m disposes the cptr object deletes the reference to the object and returns the value of the cptr object.
clienttest lines is a java class of driving test cases directly for client and indirectly for cptr .i t contains one passing test passingtest lines and one failing test failingtest lines .
the testing oracle validates a program execution by using the assertion statements lines and and the exception handler statements lines and .
the assertion statements at line and line validate the program state after executing a sequence of add andremove by checking if remove correctly returns the last value given by add.
on the other hand the exception handler statements at line and line detect failures at arbitrary locations.
for instance runtime monitors such as qvm and jinn would throw an asynchronous java exception either at gc safe points or at language transitions.
passing test passingtest executes successfully.
it satisfies the assertion statement at line because both the cptr object and the peer integer object in java and c are reachable and remove at line returns 1stored at line .
the runtime monitor does not throw any java exception indicating a memory leak in c because the native integer object is released in the call to remove .
failing test failingtest fails at line because the runtime monitor throws an exception due to a memory leak in c. the test case creates one client object line and two cptr objects lines and two native integer objects.
the first native peer integer object is a leak in c heap while all the other objects are reclaimed automatically by garbage collectors and manually by c memory deallocator i.e.
dispose .
the first cptr object and its peer integer object are created in a call to add at line .
both become unreachable after the second call to add at line .
the cptr object would be garbage collected while the program does not manually execute dispose on the unreachable nativeinteger peer object.
the runtime monitor would perform a garbage collection and find out the native integer peer object is a unreachable memory leak.
this memory leak bug appears because add does notcalldispose ifmalready points to acptr object.
thus we indicate line as the buggy statement.
our approach museum generates mutants each of which is obtained by mutating one statement of the target code.
then museum checks the testing results of the mutants to localize buggy statements.
for example suppose that museum generates the following three mutants m1 m2 and m3by mutating each of lines and .
m1 a mutant obtained by removing line this mutation resolves the memory leak as the mutant will not allocate any native memory.
however both test cases fail with the mutant because an access to praises an invalid memory access at nget nput ofcptr .
m2 a mutant obtained by inserting a statement of pinning the java reference before line this mutation inserts a statement of pinning the object clienttest.pinobject m before line where pinobject stores the java reference minto a global data structure pinnedobj .
this mutation intends to prolong the lifetime of the java object referenced by m to the end of the program run.
this mutation resolves the memory leak in failingtest because the first cptr object will not be reclaimed and thus will not leak its peer native integer object.
the two test cases pass with the mutant because the mutation does not introduce any new bug.
m3 a mutant obtained by replacing the return value with in line this mutation replaces the variable xwith an integer constant at line .
this mutation fails the assertion at lines and since the return value of remove is always .
from these testing results museum concludes that line is more suspicious than line and line because the failing test case passes only with m2and the passing test case fails with m1andm3 see step of section iii b .
locating the root cause of this memory leak poses challenges in runtime monitoring and fault localization techniques.
memory leak detectors locate memory leaks and their allocation sites not the cause of the leaks in general.
while some leak chasers locate the cause of memory leak they do not scale well across language boundaries since they do not track opaque pointers and their staleness values across languages.
sbfl techniques cannot localize the bug because both passingtest andfailingtest cover the same branches statements in their executions.
consequently sbfl techniques cannot indicate any code element that is more correlated with the failure than the others.
b. fault localization process of museum figure describes how museum localizes faults.
museum takes the target source code and the test cases of the target program as input and returns the suspiciousness scores 3seepin java object mutation operator in table i 467mutant generatorcov.
g3measure target program g3 ptesting language g3interface g3 rule g3checker e.g.
g3checkjni g3jinn test g3 suite g3 tselected test g3cases tstarget g3 stmts.
stmutant g3 generation c g3module java g3moduleprogram mutants m g20 g15 g3m g21 g15 g171 g17mk selected g3 test g3cases tsmutant g3 testing g3susp.
g3score g3 ranking g3 computationtest g3 results g3of g3 ts on g3the g3 mutantssusp.
score ranking6whs 6whs 6whs 6whs c g3module java g3module other g3languages other g3language test g3results g3 of g3ts on g3p fig.
fault localization process of museum of the target code lines as output.
museum has the following basic assumptions on a target program pand test suite t .
existence of test oracles a target program has explicit or implicit test oracle mechanism i.e.
user specified assert runtime failure such as null pointer dereference and or runtime monitor such as jinn which can detect errors clearly.
.
existence of a failing test case a target program has test cases at least one of which violates a test oracle.
museum operates in the following four steps step museum receives pand tand selects target statements stand test cases ts.stis the set of the statements ofpthat are executed by at least one failing test case in t. museum selects stas target statements for bug candidates.
also museum selects and utilizes a set of test cases ts each of which covers at least one target statement because the other test cases may not be as informative as test cases in tsfor fault localization.
to select standts museum first runs pwith twhile storing the test results and the test coverage for each test case.
testing results are obtained from the user given assert statements runtime failures and multilingual bug checkers such as checkjni jinn and qvm section ii a .
step museum generates mutant versions of p i.e.
m1 m2 ...m k each of which is generated by mutating each of the target statements.
museum may generate multiple mutants from a single statement since one statement may contain multiple mutation points .
step museum tests all generated mutants with tsand records the testing results.
since a mutation may induce an infinite loop we consider a test fails if the testing time exceeds a given time limit.
step museum compares the test results of tsonpwith the test results of tson all mutants.
based on these results museum calculates the suspiciousness scores of the target statements of pas follows.
for a statement sofp let f s be the set of tests that covers sand fails on p and p s the set of tests that covers 4museum can localize a bug spanning on multiple statements not limited for locating a single line bug .
this is because mutating a part of a bug i.e.
one statement among multiple statements that constitute a bug can still change a failing test case into passing one which will increase the suspiciousness of the statement constituting the bug .sand passes on p. let mut s m1 ...m k be the set of all mutants of pthat mutates s. for each mutant mi mut s let fmiandpmibe the set of failing and passing tests on mirespectively.
and let f2pandp2fbe the numbers of changed test result from fail to pass and vice versa between pand all mutants of p. the suspiciousness metric of museum is defined as follows susp s mut s summationtext mi mut s f s pmi f2p p s fmi p2f the first term f s pmi f2p reflects the first observation it is the proportion of the number of tests that failed on pbut now pass on a mutant mithat mutates sover the total number of all failing tests that pass on a some mutant the suspiciousness of s increases if mutating scauses failing tests to pass .
similarly the second term p s fmi p2f reflects the second observation being the proportion of the number of tests that passed on pbut now fail on a mutant mithat mutates sover the total number of all passing tests that fail on a some mutant the suspiciousness of sdecreases if mutating scauses passing tests to fail .
after dividing the sum of the first term and the second term by mut s susp s indicates the probability of sto be a faulty statement based on the changes of test results on p andmut s .
c. new mutation operators for multilingual bugs in addition to the conventional mutation operators museum utilizes new mutation operators to effectively localize multilingual bugs because these mutation operators can directly mutate interactions between language interfaces.
we have made new mutation operators which change semantics of a target program regarding the jni constraints based on the previous jni bug studies .
table i shows the list of the new mutation operators.
the description of the new mutation operators are as follows .clear pending exceptions clears a pending exception by inserting env exceptionclear env immediately after every jni function invocation in c i.e.
env jnifunction ... .
this mutation operator is created based on a best practice in jni programming .
5if a target statement has no mutant i.e.
mut s susp s is defined as .
museum defines the first term as if f2pis .
similarly the second term is defined as if p2fis .
for a concrete example of how to calculate the suspiciousness score of mbfl see section ii.c of moon et al.
.
.propagate pending exceptions propagates an exception immediately by inserting if env exceptionoccurred env return after every jni function invocation in c. .type cast to jboolean explicitly converts an integer expression to jni true orjni false when the expression is assigned to a jboolean variable.6in other words type cast to jboolean changes an assignment jbool var int expr with jbool var int expr?jni true jni false this mutation operation is motivated by the common pitfall of jni programming .
.type cast to superclass changes a jni call to get the reference of a class with the jni call to get the reference of its superclass by mutating jclass cls env getobjectclass env obj with jclass cls env getsuperclass env env getobjectclass env obj this mutation operator is motivated by a report of a realworld bug found in eclipse .
.
.
these mutation operators increase or decrease the life time of a reference to a java object and probably the life time of the referenced java objects too .
for example make global reference increases the life time of a local reference lby making the reference as a global one.
in other words make global reference inserts the following statement after an assignment statement to a local reference l i.e.
l expr l env newglobalref env l in contrast remove global reference decreases the life time of a global reference g and probably the referenced java object too by inserting the following statement for a global reference g env deleteglobalref env g we have developed four other mutation operators for local