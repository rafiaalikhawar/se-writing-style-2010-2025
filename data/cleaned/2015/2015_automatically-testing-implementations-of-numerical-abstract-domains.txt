automatically testing implementations of numerical abstract domains alexandra bugariu department of computer science eth zurich switzerland alexandra.bugariu inf.ethz.chvalentin w stholz department of computer science eth zurich switzerland wuestholz gmail.com maria christakis mpi sws germany maria mpi sws.orgpeter m ller department of computer science eth zurich switzerland peter.mueller inf.ethz.ch abstract staticprogramanalysesareroutinelyappliedasthebasisofcode optimizationsandtodetectsafetyandsecurityissuesinsoftware systems.for theirresults tobereliable staticanalyses shouldbesound i.e.
should not produce false negatives and precise i.e.
should report a low number of false positives .
even though it is possibletoprovepropertiesofthe designofastaticanalysis ensuringsoundnessandprecisionforits implementation ischallenging.
complexalgorithmsandsophisticatedoptimizationsmakestatic analyzers difficult to implement and test.
in this paper we present an automatic technique to test among other properties the soundness and precision of abstract domains thecoreofallstaticanalyzersbasedonabstractinterpretation.in ordertocoverawiderangeoftestdataandinputstates weconstruct inputs by applying sequences of abstract domain operations torepresentativedomainelements andvarytheoperationsthrough gray boxfuzzing.weusemathematicalpropertiesofabstractdomainsastestoracles.ourexperimentalevaluationdemonstrates theeffectivenessofourapproach.wedetectedseveralpreviously unknownsoundness andprecisionerrorsin widely usedabstract domains.
our experiments also show that our approach is moreeffective than dynamic symbolic execution and than fuzzing the test inputs directly.
ccs concepts software and its engineering software testing and debugging keywords soundness testing precision testing abstract interpretation permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
reference format alexandra bugariu valentin w stholz maria christakis and peter m ller.
.
automatically testing implementations of numerical abstract domains.in proceedingsofthe201833rdacm ieeeinternationalconferenceon automated software engineering ase september montpellier france.acm newyork ny usa 11pages.
introduction static program analyses compute semantic properties of programs which are the basis for program optimizations and for detecting program errors and security vulnerabilities.
since most propertiesofprogramsareundecidable staticanalysesapproximatethe set of possible program behaviors.
for its results to be reliable a static analysis should be sound and precise.
a soundanalysis considers each possible program behavior that is computes an over approximation of all possible behaviors.
consequently sound analysesdonotproducefalsenegatives.a preciseanalysiscomputes a tight approximation to minimize the number of false positives.
many static analyses are based on the abstract interpretation framework .
in this framework abstractions of the program state are represented by elements of abstract domains for instance numerical abstract domains may track intervals of possible values fornumericalvariablesorconstraintsbetweenthem.thesemantics ofprogram operationsis representedby abstracttransformers which specify the effect of an operation on the abstract state.
eventhough itis possibleto proveproperties ofthe designofa static analysis ensuring soundness and precision for its implementationis challenging.
in fact implementations of abstract domains areoftencomplexandhighlyoptimizedinordertomaximizeperformanceandscalability .errorsintheseimplementationslikely affect the usefulness of all static analyzers that build on them.
imagine a static analysis that abstracts numerical variables to intervalsofpossiblevalues.forinstance theabstractvalue for anintegervariable xexpressesthat ineachprogramexecution the concrete actual valueof xsatisfies0 x .theexampleinfig.
illustratesapotentialsoundnesserrorduetoarithmeticoverflow.
without prior knowledge about parameter p its abstract value is andconsequently theabstractvalueof aafter the assignment is .
if this abstract domain is implemented using bounded integers a naive implementationoftheadditionoperatorwillleadtoanoverflowand authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france a. bugariu v. w stholz m. christakis and p. m ller int foo int p int a p ... figure potential soundness error due to overflow.
produce .thisemptyintervalindicates thatthecodeaftertheassignmentisunreachable whichisunsound.
inparticular thisunsoundresultmightmaskprogramerrorsand security vulnerabilities in subsequent code.
inthispaper weassesstheeffectivenessofexistingautomatic testingtechniquesinfinding amongothererrors soundnessand precision issues in widely used implementations of abstract domains.wegeneratetestinputsusinganovelcombinationofexisting ideas startingfromapoolofpre selectedvalues weapplyabstractdomainoperationstocreaterepresentativedomainelements and vary the operations by employing an off the shelf gray box fuzzer suchasafl orlibfuzzer tomaximizecoverage.asinearlier workbymidtgaardandm ller weusemathematicalproperties of abstract domains as test oracles.
however we target real world implementationsofcomplexabstractdomains e.g.
apron soctagonsdomain andelina spolyhedradomain andwe extend the set of tested properties by including more precision properties and by approximating termination properties.
our evaluation on severalabstract domains of the apron and elina libraries shows that our combination effectively detectssoundnessandprecisionproblemsincomplex mature implementations.
in particular we show that it is more effective than purely relying on existing test case generation techniques suchas gray box fuzzing and dynamic symbolic execution dse also known as concolic testing .
our main contributions are the following we present a novel combination of automatic test case generation techniques to detect among other errors soundness andprecisionissuesinimplementationsofabstractdomains.
we demonstrate that our technique effectively finds bothseeded and real errors in widely used implementations of numerical abstract domains.
we show that our technique tests abstract domains more effectively than standard dse or gray box fuzzing.
ourexperienceisusefulfordevelopersofabstractdomainsto ensure soundness and precision of their implementations.
it is alsousefulfordevelopersofstaticanalyzerstoassessthequality of available abstract domain libraries.
even if the design of an abstractdomainintentionallysacrificessoundnessinfavorofother qualities it is still important to check the implementation forunintentional unsoundness caused by implementation errors.
outline.
the next section summarizes some background on abstractinterpreters.
sect.
3givesan overviewof ourapproach and sect.4explains the technical details.
in sect.
we present our experimentalevaluationonreal worldimplementationsofabstractdomains.wediscussrelatedworkinsect.
6andconcludeinsect.
.
background abstract interpretation is a theoretical framework for expressing static analyses used by many industrial analyzers such asastr e and clousot .
it relies on abstract domains to represent abstractions of concrete program states and on abstract transformers tomodelthebehaviorofprograminstructions such as assignments and conditionals.
abstractdomainsareoftenreusedacrossmanydifferentprogram analyses.
for example most static analyzers employ numerical domains which are therefore the focus of this paper.
widely used numerical domains include intervals which capture the range ofvaluesforeachvariable octagons whichcanalsoexpress simple relations between two variables polyhedra which can capture linear inequalities between arbitrarily many variables and zonotopes which express affine relations.
mostabstractdomainsarerepresentedbycompletelatticesofthe form parenleftbig a subsetsqequal latticetop unionsq intersectionsq parenrightbig.
adenotes the set of abstract elements x whicharepartiallyorderedby inclusion subsetsqequal.eachabstractelement represents a set of constraints i.e.
mathematical relations between variables and constants.
the bottomelement is the least element of the lattice it represents the empty set of concrete states and corresponds to an unsatisfiable set of constraints.
the topelement latticetopisthegreatestelementandrepresentstheuniversalsetofconcrete states that is all variables are unconstrained.
unionsqand intersectionsqare thejoinandmeetoperators which are used to obtain the union respectively the intersection of two abstractelements.
additionally an abstract domain whose lattice has an infiniteheight requiresa widening operator triangleinv to ensurethatthe analysiseventuallyreachesafixedpoint.somedomains suchas intervals and octagons also support a narrowing operator triangle which can improve the precision of the analysis .
abstracttransformersaretypicallyspecifictoagivenanalysis andprogramminglanguage butsometransformersareuniversal buildingblocksformanyanalyses.theseinclude assigntorepresent an assignment condto assume a condition to hold and project toeliminateanypreviousinformationaboutoneofthevariables e.g.
whenanewvalueofavariableisreadfromafile .here we focus on these transformers because they are the most complex to implement andthusthemosterrorprone .ageneralization of our approach to other transformers is mostly straightforward.
overview since implementations of abstract domains are often used as librariesbymanydifferentprogramanalyses weapplyaunittesting approach.
compared to system testing unit testing allows us tospecify generic test oracles which are independent of a specific abstractdomainorstaticanalysis.moreover itfacilitatesthegenera tionoftestdatabecauseabstract domainelementscanbegeneratedmuchmoreeasilythaninputprogramsforawholeanalyzer .in this section we give an overview of the three mainingredients of ourautomaticunittestapproach testoracles testinputgeneration and test drivers.
details will be presented in sect.
.
.
test oracles theabstractinterpretationframeworkprescribesanumberofproperties of the domain operators and abstract transformers collec tively referred to as domain operations in the rest of the paper whicharerequiredforsoundness.forinstance iftheabstractelement x capturing the pre state of an assignment is reachable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automatically testing implementations of numerical abstract domains ase september montpellier france that is different from bottom the post state of the assignment v eshouldalsobenon bottomforallvariables vandwell formed expressions e x nequal assign x v e nequal a we use these general soundness conditions as test oracles.
we also identify a number of general precision conditions whose violation indicatesthattheresultofadomainoperationisover approximated more than necessary.
for this purpose we compare the result of a domain operation to the best transformer that is the most precise resultrepresentable in a given abstract domain.
for instance the result of intersecting top with an element should be equal to the element itself latticetop intersectionsq x x b moreover we check that widening and narrowing converge within agivennumberofiterations whichensurestheterminationofany fixed point computation in which they are used.
note that all the properties considered in this paper are defined under the assumption that the analyzed programs do not raise exceptions otherwise thebehavior ofthe staticanalyzerdepends on the semantics of the programming language.
for example in c divisionbyzerocausesundefinedbehavior.whenclassifyingthe properties into soundness and precision as described in sect.
we assume that the abstract domain does not model error states.
.
input data abstract domains often use sophisticated data structures to optimize performance.
for instance elements of the polyhedra domain are typically represented using both matrices and vectorsof floating point numbers.
in our experiments we observed that thestandardtestcasegenerationtechniquesdonotworkwellfor complex abstract domains.
in particular fuzzing failed to detectsubtle interactions between domain operations and dse did noteffectively explore real world implementations that make heavy useoffloating pointarithmeticandlibraries.we therefore usea combination of testcase generation techniques to create apool of domain elements which serve as test inputs to domain operations.
the pool is populated in two steps.
step1createsaninitialpoolbycombiningboundaryandrandom testing.
each element of a numerical domain can be constructed fromnumericalconstraints.forinstance anelementoftheintervals domain which maps program variables vito their possible ranges is created from the constraint kl vi ku the constants klandkuare the lower and upper bounds .
we generate the numerical constants randomly or choose them from a pre defined set of boundary values that are more likely to expose bugs such as off by one errors and arithmetic overflows.
if the intervals domain is implemented using machine integers these boundary valuesare int min int max .
the initial pool also contains the extreme elements latticetopand .
selecting inputs from this pool together with a suitable expressione asargumentstothe assigntransformerwilllikelydetectthe possible unsoundness illustrated in fig.
.
the initial pool is likely to contain an element mapping the variable pto since and int maxare pre defined boundary values moreover wearelikelytoobtainanexpression eofthefrom p kforapositiveconstantk seesect.
4fordetails .evaluatingthe assigntransformer on these inputs violates soundness property a defined above.
theinitialpoolallowsustotest individual domainoperations.
however thisapproachisinsufficientintwosituations.first some implementationsrelyoncomplexconsistencyconditionsontheir datastructures.forpolyhedra forinstance thetwointernalrepresentations must be kept consistent.
if a faulty operation violates this invariant the effect can be often observed only when applyingasubsequentoperation itisthusnecessarytoperformatleasttwo consecutive operations to detect the bug.
second thereare certainsoundness orprecision propertiesof individual operationsthatcannotbecheckedbygeneric domainindependent oracles.
for instance the assigntransformer for octagonsshould insomecases applyaso calledclosureoperation failing to do so or using an imprecise closure may lead to loss of precisioninsubsequentoperations suchasinclusionorequality tests .atestoraclethatdirectlydetectsamissingclosurewould bespecifictooctagonsand thus notreusable.amoregenericway to detect this problem is by intersecting the result of the assign transformer with top.
the expected output of the intersection isthe same as the result of the assigntransformer itself.
however ifthetransformerdoesnotapplytheclosurewhenexpected the domain independent property b may fail due to imprecision.
theabovesituationscanbothbetestedbyexecutingatleasttwo consecutive domain operations before checking the oracle.therefore step of our input generation expands the pool of domainelements by iteratively applying a domain operation to existing poolelements andpossiblyotherarguments andaddingtheresulttothepool.byrepeatingthisprocess weincreasethelikelihoodof constructing elements that need to be built incrementally with severaldomainoperations.asaresult wearealsomorelikelytodetect bugs that manifest themselves only in consecutive operations.
.
test drivers and exploration foreachpropertyundertest wemanuallywriteatestdriverthatisparametricin theoperationsandtheirargumentsusedinstep2 to populate the pool of domain elements and the arguments of the property under test.
fig.2shows in pseudo code our test driver for checking soundness property a for the assigntransformer.
the driver takes as argumentsasequenceofoperations ops whichareusedinstep2 ofthepoolcreation asequenceofindicesintothepool elems a sequence of expressions exprs and a sequence of program variables vars .
the latter three provide arguments to the domain operations.
the driver also takes as arguments an index into thepool oelem anexpression oexpr andavariable ovar whichareinputstothepropertyundertest ororacle lines17 .
the test driver initializes the pool of abstract elements by creatingvalid inputsfor thecurrently testeddomain suchasintervals oroctagons step1 line4 .then itextendsthepoolbyapplying domainoperations step2 lines7 .eachiterationobtainsthe nextoperationanditsargumentsfromtheparametersofthetest driver applies it and adds the result to the pool.
finally the test driverassertsproperty a aftercomputingtheresult ofthe assign operation.
for simplicity we omit optimizations for instance our implementationinitializesthepoolonlyonce beforeallthedrivers authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france a. bugariu v. w stholz m. christakis and p. m ller 1test assign ops elems exprs vars oelem oexpr ovar populate poo l step pool init populate poo l step for i i nbops i op ops x pool y pool e exprs v vars add to pool pool apply op x y e v execute assign transformer x pool res apply assign op x ovar oexpr check property a assert x nequal res nequal figure2 pseudocodeofatestdriverforcheckingsoundness property a of the assignment transformer.
are run and several technicalities such as ensuring that indices are within bounds.
we use the state of the art gray box fuzzer libfuzzer t op r o vide the arguments to the test driver i.e.
to choose the operations usedinstep2togetherwiththeirarguments andtheparameters for the property under test.
gray box fuzzers use a lightweight code instrumentation to generate inputs that are likely to execute previously uncovered code.
in our implementation all parameters ofthetestdriverareencodedintoonearray whichiscreatedby the fuzzer.
technical solution in this section we provide the technical details of our approach.
.
test oracles ourtestoraclesarebasedondomain independentmathematical properties of abstract operations.
in the following we give an overview of these properties and explain how they are checked by the test drivers.
properties.
basedontheabstract interpretationliterature andearlierworkontestingstaticanalyzers weidentified46 properties that need to be satisfied by domain operations to ensure soundness precision and termination.
fig.
3provides an overview.
thesoundnesspropertiesarerequiredtoensurethatanabstractdomainelementover approximatestheconcretestatesitrepresents.
wehavediscussedanexampleintheprevioussection property35 .
to deal with the undecidability of most semantic program properties staticanalysesover approximatethesetofconcreteprogram behaviors and then infer or check properties on this abstraction.
since they are intended to compute an approximation one cannot expect the operations of an abstract domain to be precise w.r.t.
the concrete program execution.
therefore our precision properties check that the domain operations do not lead to unnecessary information loss that is they compare the result of an operation to thepartial order join meet bounds subsetsqequal x b x subsetsqequal b y subsetsqequal b x subsetsqequal latticetop x unionsq y subsetsqequal b x subsetsqequal x b b subsetsqequal x b subsetsqequal y x subsetsqequal y y subsetsqequal z x subsetsqequal z b subsetsqequal x intersectionsq y x subsetsqequal y y subsetsqequal x x y widening join x subsetsqequal x triangleinv y unionsq x x y subsetsqequal x triangleinv y latticetop unionsq x latticetop x triangleinv x x subsetsqequal x unionsq y triangleinv x x y subsetsqequal x unionsq y 33widening converges x unionsq y y unionsq x assignment x unionsq y unionsq z x unionsq y unionsq z x subsetsqequal y x unionsq x x a x v e subsetsqequala y v e x subsetsqequal y x unionsq y y x nequal a x v e nequal x unionsq y y x subsetsqequal y x a x v e x unionsq x intersectionsq y x 37rep e x a x v e nequal latticetop meet projection intersectionsq x 38a x v e subsetsqequalp x v latticetop intersectionsq x x conditional x intersectionsq y subsetsqequal x x subsetsqequal y c x e subsetsqequalc y e x intersectionsq y subsetsqequal y x c x e x intersectionsq y y intersectionsq x 41c x e subsetsqequal x x intersectionsq y intersectionsq z x intersectionsq y intersectionsq z narrowing x intersectionsq x x x intersectionsq y subsetsqequal x triangle y x subsetsqequal y x intersectionsq y x x triangle y subsetsqequal x x intersectionsq y x x subsetsqequal y x triangle x intersectionsq x unionsq y x triangle x 26disj x y x intersectionsq y 46narrowing converges figure algebraic properties of abstract domains.
we classify them into soundness precision or convergence .
note that all free variables are implicitly universallyquantified and all variables refer to abstract domain ele mentsexceptforvariables vande whichrefertoaprogram variable and an expression respectively.
predicate disj x y denotes that the intersection of the set of constraints from xand yistriviallyempty andpredicate rep e x thatecanbe precisely represented in the abstract domain of x. most precise representable result as obtained by applying the best transformer see sect.
.
forinstance computingthejoinoftwointervals and yields which loses the information that the variable is different from .
despite this inevitable information loss a join operator shouldsatisfyanumberofprecisionproperties for instance property prevents the join of and from returning or latticetop which is sound but unnecessarily imprecise.
thesoundnessandconvergencepropertiesneedto holdforall abstractdomains someprecision properties maynotalwayshold whenthebesttransformersdonotexistorcannotbecomputed .
forinstance domainsbasedonincompletelattices suchaszonotopes do not have a least upper bound for every pair of abstract elements.thiscanforce unionsqtoreturnalargerupperboundand thus violate property .
for such domains we require developers to select the subset of precision properties that should be checked.
the convergence properties and require widening and narrowing to eventually reach a fixed point which is necessary to ensure that the static analysis of loops and recursion terminates.
sinceconvergenceisaterminationproperty whichcannotbetested weinsteadcheckthestrongerpropertythatafixedpointisreached within a given number of iterations as we explain below.
executable oracles.
we manually construct a test driver for each of the properties in fig.
.
this driver selects suitable inputs for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automatically testing implementations of numerical abstract domains ase september montpellier france 1i 2x pool 3while true i i y pool res apply widening op x y if res x break a fixed point is reached x res assert i k figure4 fragmentofatestdriverforcheckingwhetherthe octagons widening reaches a fixed point within ksteps.
each of the free variables of the property to be tested evaluates the property and checks that it holds.
for instance for property itselectsadomainelement dforvariable xandchecksthatthe subsetsqequal operator yields true when applied to dandd.
translatingpropertiesintoexecutableoraclesisstraightforward for most soundness and precision properties but slightly more involved for convergence properties.
fig.
4shows a fragment of our test driver for checking whether the octagons widening converges afterkiterations .
the driver computes an increasing chain of xelements as checked by property each obtained by widening the previous element with an arbitrary element y. widening convergesifthe x chainbecomesstable here within ksteps.we observed that k is a sufficient upper bound for all our tested analyzers because widening converges much faster in practice.
notethat formostabstractdomains suchasintervals octagons etc.
widening can be applied to arbitrary elements.
there are however some exceptions for instance the polyhedra widening requiresmonotonicityofitsoperands thatis x subsetsqequaly .insuchcases we use a slightly different test driver that applies widening on x andthejoinof xandy thatis bychangingthelastparameterof applyonline6offig.
4tox unionsqy becausex subsetsqequalx unionsqy seeproperty8 .
asaconsequenceofthismonotonicityprecondition property31 needs to hold for the polyhedra domain only for x .
.
input data testingthepropertiesfromfig.
3requiresthreekindsofinputdata programvariables expressionsoverthem forthe assignand condtransformers and abstract domain elements that contain constraints over these variables.
we construct this data as follows.
program variables.
all our test cases operate on a set of predefined integer variables.
the number of variables must be sufficiently small to keep the memory consumption and execution time of the test cases low.
on the other hand abstract domain optimizations such as decomposition require enough variables to obtain non trivialpartitions .inourimplementation thenumberof variablesisconfigurable weuseeightvariablesinourexperiments.
expressions.
testing assignments requires numerical expressions.
forthenumericaldomainsconsideredinthispaper theseexpressions are linear sums over the program variables with integer coefficients whichare chosenby thefuzzer toincrease thelikelihood of constructing suitable expressions.
note that to test precision properties wealsoneedtogenerateexpressionsthatarenotrepresentableinthedomainundertest.forinstance foranoctagontable structure of abstract elements with one constraint for commonly used numerical domains.
domain element with one constraint intervals kl vi ku zonotopes vi kl ku ku kl i octagons civi cjvj k polyhedra c0v0 c1v1 ...cdim 1vdim k v variables c coefficients k constants v0 v1 the assignment v2 v0 2v1is expected to produce v0 v1 v2 andnot latticetop eventhoughthe assigned expression is not octagonal.
for the condtransformer we obtain boolean expressions by comparing the linear sums to zero.
domain elements.
as explained in sect.
w ec r e a t eap o o lo f abstract domain elements such as intervals or octagons in two steps step populates the pool by constructing elements usinga combination of boundary and random testing whereas step expandsitbyapplyingdomainoperationstoexistingpoolelements.
besides latticetopand step1alsocreatessimpledomainelementsthat contain only one constraint on the pre defined program variables.
more complex domain elements are constructed in step .
tab.
shows the structure of simple domain elements for common numericaldomains.theseelementscanbeconstructedbychoosing valuesfortheconstants k e.g.
theboundsofaninterval andthe coefficients c. by default we pick them from a small set of predefinedvalues e.g.
boundaryvaluessuchas0or andasmallset ofarbitrary values.
the use of pre defined values is optional and can be configured in the test drivers see sect.
.
these sets of valuesdepend on both the domain under testand its implementation.
for instance octagonal coefficients must be in whereaspolyhedralonesarearbitraryintegers.moreover differentimplementationsrepresentnumbersdifferently e.g.
we use the pre defined values int min int max for integer intervals if the implementation uses machine integers for arbitrary precision integers and additionally nanfor floatingpointrepresentations.eventhoughwefocusonintegerprogram variables here internal floating point computations may lead to rounding errors as we observed in our experiments see sect.
.
thevaluesinbothsetsare notchosenbythefuzzer.however thefuzzercanstillcontrolthepoolofdomainelementsbyselecting suitable operations in step .
this step constructs more diversedomain elements usually with more complex constraints by ap plyingdomainoperationstotheexistingelements.step2makes useofalldomainoperatorsthatyielddomainelements unionsq intersectionsq triangleinv as well as the abstract transformers assignandproject.
for simplicity we omit narrowing which is not supported by all domains and conditionals.
using all these domain operations not only allowsus to detect errors in their implementation such as the missing closure in assignments that we discussed in sect.
but it also efficiently generates a diverse set of validdomain elements.
while itistheoreticallypossibletocreateanewelementbygenerating an arbitraryset ofconstraints suchan approachwould oftenproduce unsatisfiableconjunctions ofconstraints representedby the already considered element.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france a. bugariu v. w stholz m. christakis and p. m ller experimental evaluation toevaluatetheeffectivenessofourapproach weapplyittotwo complex libraries for numerical analysis namely apron and elina .
we were able to find errors in several of the implemented domains.
most of them are already confirmed and fixed.
apron is a mature library extensively used in many academic and industrial static analyzers such as astr e and pagai as well as in the cpachecker verification platform .
elina is a recent library that uses highly optimized algorithms based ononlinedecompositiontoachievesignificantspeedups .
these algorithms are difficult to implement correctly.
in our experiments we consider three variants of apron with differentinternalrepresentationsfornumericalvalues sects.
.
and5.
and two versions of elina sect.
.
.
we also evaluate differentconfigurationsofourtechnique sect.
.
andcompareit to pure fuzzing and dse sect.
.
.
experimental setup.
since the tested domains have different complexity i.e.
theimplementationofpolyhedraissignificantly slower we estimated the maximum execution time required to testeachpropertyapproximatelyonemilliontimesforintervals zonotopes andoctagons andhalfamilliontimesforpolyhedra see tab.
.
the values are smaller for elina than for apron becauseelina scodeishighlyoptimized.intervalsandzonotopes were not considered for elina as they were not part of the tested artifacts .alltheexperimentswereperformedona3.3ghz intelxeone5 4627v2cpuwith236gbmemoryandraid6hdd.
.
apron double and rll apronsupportsdifferentinternalrepresentationsfornumerical values.
for instance the doublerepresentation uses floating point numbers while rlluses an approximation of rational numbers basedontwo64 bitintegersforthenumeratoranddenominator.
comparedtoapronmpq whichusesarbitrary precisionrationals seesect.
.
theserepresentationsofferbetterperformance but may lose precision and cause non termination .
intervals and octagons support double while rll is available for polyhedra.
our experiments indeed uncovered soundness precision and termination problems in several domains of the latest version of apron .
.
as shown in tab.
.
here the three versions of rll refertodifferenttestconfigurationsthatwediscusslater thedomainimplementationisalwaysthesame.thethirdcolumnpresents the total number of properties from fig.
3that we attempted to test for each domain.
we tested only the first properties forintervals and polyhedra since narrowing is not implemented for intervals in apron and not mathematically defined for polyhedra.
the reported violations in the fourth column are not necessarily allcausedbydifferentbugs.nevertheless observingmultipleviolations caused by the same bug can provide additional information table maximum execution time per test driver.
domainmaximum execution time s apron elina intervals not consideredzonotopes not consideredoctagons 700polyhedra 800table results for apron double and rll.
the third columnreportshowmanyofthepropertiesfromfig.
3wereapplicableforeachtesteddomain.thefirstvalueinthefourth columnshowsthenumberofviolatedsoundnessproperties the second represents precision properties and the thirdindicates how often errors in the domain implementationcaused the test driver to crash or time out.
variant domain propertiescausestested violated double intervals double octagons roundingrll v1 polyhedra overflowrll v2 polyhedra overflowrll v3 polyhedra overflow forerrorlocalization.weusedaconfigurationthatinitializesthe pool with elements step of the pool population includes long minandlong maxasboundaryvalues andapplies16 operations to generate more complex domain elements step .
thiscorrespondstoconfigurationc2fromtab.
whichwediscuss in sect.
.
together with measurements on the testing time.
intervals and octagons.
all our generic properties hold for intervals the simplest domain we tested.
nonetheless we indirectly foundimprecisionsfor subsetsqequaland unionsq bytestingapron sefficientimplementation of zonotopes discussed in sect.
.
which uses the interval operations.
these issues were confirmed and fixed.
for octagons three precision properties and are violated because the equality test gives imprecise results due to rounding errors.
in fig.
we show an example input generated by our approach that violates property .
octrepresents a call to the octagons constructor.
the root cause of the imprecision is the underlyingdoublerepresentation.for oct3 long maxcannotbe precisely represented as a double value.
the resulting rounding error gives approximate results in the subsequent computations and makes the assertion on line 5fail.
polyhedra.
with the same test configuration c2 all the tests fail toterminateforpolyhedrarll rllv1intab.
.theproblemisthat apron enters infinite loops during step of the pool construction becauseofunhandledarithmeticoverflows.thebugcanbeseen when constructing at least two consecutive domain elements as in fig.
.
the second constructor call enters an infinite loop.
this bug causes all test drivers to time out before they even reach the test oracle.
to work around it and look for additional bugs we replaced long minandlong maxbyint minand int maxas pre defined values in the pool construction.
in this case rll v2 in tab.
step of the pool construction succeeds but for21testdrivers step2timesout.theremaining20testdrivers lead toviolations of soundnessand precision properties.the root cause of all these failures is unhandled arithmetic overflows in variousoperators.droppingpre definedvaluesentirely rllv3in 1oct1 oct x0 x5 2oct2 assign oct1 x2 long min 3oct3 oct x0 long max 4oct4 meet oct3 oct2 5assert meet latticetop oct4 oct4 figure input violating property for octagons.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automatically testing implementations of numerical abstract domains ase september montpellier france 1poly1 poly x5 x6 x7 long max 2poly2 poly x4 x5 x6 x7 long min figure input entering an infinite loop for polyhedra.
tab.
allows us to construct the pool in all but four cases.
in total soundness and precision properties fail due to overflow.
.
apron mpq mpqisanapronvariantthatusesarbitrary precisionrationals for its internal representation.
for sub polyhedral domains i.e.
intervals octagons and polyhedra this variant is supposed to besound andprecise .our experimentspartiallyconfirm these theoretical guarantees with the same setup as for apron double andrll wedidnotfindany generic propertyviolationsinapron mpq for the three sub polyhedral domains.
however we uncov ered imprecisions for intervals indirectly by testing zonotopes.
moreover tofurthervalidateourtechnique weaskedthreeexpertsinabstractinterpretationtoinsertbugsinanyofthesub polyhedral domains.
our results are presented in the following paragraphs.
zonotopes.
as opposed to sub polyhedral domains the structure ofzonotopesisanincompletelattice.forthisreason notalltheprecisionpropertiesfromfig.
3areexpectedtohold e.g.
asexplained insect.
.
theleastupperboundmaynotexistforeverypairof elements .
moreover join creates new input related constants and thus the operator is by design non commutative.
initially the pool construction step did not succeed for any of thetestsduetoamemorybuginthemeetoperator.afterapplying the fix we detected additional memory exceptions raised when creatingahighnumberofinput relatedconstants.ourtestsalso revealed imprecisions in the implementation of the equality check meet and project operations.
moreover we discovered a precision bug in the partial order.
soundness property uses subsetsqequalto check if theresultofajoinover approximatesitsoperands andthebugled toaviolationofthisproperty.thedevelopersconcludedthatthe root cause is an imprecision in the implementation of the intervals domain whenoneoftheoperandsof subsetsqequal unionsq or triangleinvis represented in its canonical form through the empty interval .i f is not handled as a special case unionsq for example insteadof .thisimprecisionisindependentof theinternalrepresentationusedfornumbers.ourtestsforintervals couldnotdetectitdirectlybecauseourpropertiesaregenericanddo not check the precision based on the intervals specific definitions.
all these issues were fixed by the apron developers.
seeded bugs in sub polyhedral domains.
we asked three abstract interpretation researchers a post doc and two senior phd students with a broad experience inimplementing and using various types of abstract domains and static analyses to seed semantic bugs for our evaluation.
each expert had the task of inserting at least five soundness or precision bugs at least one of each type inanyofthesub polyhedraldomains.webelievethattheseeded bugs are representative of the kind of semantic errors that occur during the development of abstract domains.
the cumulative results are summarized in tab.
.
for each domain we show how many bugs were seeded how many our techniquefound andwhetherweobservedthebugsthroughviolationstable4 resultsforapronmpqwithseededbugs.thelast columnshowsthenumberofviolatedsoundnessproperties precision properties and of crashes and assertion failures.
domain bugs properties seeded found violated intervals octagons polyhedra of soundness or precision properties or through crashes and assertionfailuresinapron sinternalconsistencychecks.intotal we were able to find out of the seeded bugs.
in the following paragraphs wepresenttwobugsthatwedetectedandexplainwhy three of the seeded errors could not be found.
a seeded bug in intervals uses a slightly modified version of an unsound definitionfor the widening operator .
this definitionuses insteadof tocomparetwobounds whichleadstoa violation of soundness property .
our tests reveal this problem.
a seeded bug in octagons removes the call of closure in one special case of the assignment transformer.
as explained in sect.
wedetectthisbugbygeneratinganassignmentduringstep2ofthe poolconstruction followedbyameet whichviolatesfourofour precision properties because the equality check becomes imprecise.
while our approach found the vast majority of the seeded bugs therewerethreeitdidnotdetect.
oneseededbugmakestheoc tagonsclosurelessprecise.detectingthisproblemwouldrequiread ditional octagon specificprecisionpropertiesforclosure .this canbeeasilydone butourfocushereisondomain independent properties.
anotherseededbugaffectstheprecisionofwidening for intervals in a way that does not violate the properties from fig.
.
detecting it would again require additional domain specific properties.
the last undetected bug changes the assignment operator for polyhedra to act like project making it trivially sound butimprecise.thisbugcanbeeasilyfoundiftheinputelements are polyhedra of dimension practically intervals .
our defaultconfiguration excludes such elements adjusting the range of dimensions to include the value leads to a violation of property revealing the imprecision.
.
elina to evaluate how effective our technique is on highly optimized implementations we applied it to test elina.
we used the same configurationasforapron c2 onthefollowingabstractdomains ep1 polyhedra with decomposition eod octagons with decomposition eo octagons without decomposition ep2 more recent version including bug fixes of ep1 ep3 decomposed polyhedra with further optimizations ep1is the implementation in the artifact from popl andtheothervariantsarepartoftheartifact frompopl .
notethat allelina domainsarebased onfloating point numbers notontheslowerarbitrary precisionrationals .thisdesigndecision may compromise precision to achieve high performance.
initially the pool construction for ep1failed for all the tests due to corner cases likelong min .
this step was also not successful for ep2andep3if the polyhedra had long maxcoefficients a similar issue as for apron double see sect.
.
.
to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france a. bugariu v. w stholz m. christakis and p. m ller table results for different variants of elina.
the first value in the third column shows the number of violated soundness properties the second of precision properties and the last crashes or violated assertions in elina s code.
variant propertiescausestested violated ep1 overflow triangleinv eod rounding eo roundingep2 overflow assertionsep3 overflow triangleinv find additional errors we limited the set of pre defined values to int min int max .
our results are summarized in tab.
.manualinspectionofthefailedtestsrevealedthatmostof them werecaused byarithmetic overflows indifferent operations e.g.
assignand intersectionsq .wealsofoundissuesduetooverlyrestrictive assertions in the code as well as an incorrect implementation of widening for certain cases e.g.
widening with .
we reported these issues and others and they were fixed by the developer.
oneofthemostinterestingbugswefoundin ep1isrelatedto aninconsistencybetweenthetwopolyhedralrepresentations.to improveperformance elinausesanoptimizedimplementation ofthechernikovaalgorithm forincrementalconversionand applies all the operators on decomposed polyhedra.
such optimizationsmakeitmuchmoredifficulttokeepthetworepresentationsin sync.ourpool constructionapproachwasabletocreatepolyhedra with inconsistent internal states by applying sequences of meet andjoinoperationsthatusedifferentinternalrepresentations.asa result the subsequent test for the soundness of assignfailed property because the transformer returned .
the same bug was reportedbyanotherelinauser afewdaysbeforewereported it which shows that our approach detects bugs that are relevant for users of numerical libraries.
it was fixed in the meantime.
sincenarrowingwasnotavailableforoctagonsthroughelina s apron interface which we use for testing we did not include the corresponding test drivers in this experiment only the first properties were tested as shown in tab.
.
for both variants of octagons like for apron double see sect.
.
properties and23wereviolated.theseimprecisionsarecausedbyrounding errors when performing closure and implicitly in the equalitytests.wereportedtheissuesandtheywereconfirmed.however obtaining very precise results with finite precision representations is challenging and the developer is still working on a fix.
.
different configurations ourtechniquereliesonthreemainconfigurableparameters thesize of the initial pool in step of the input generation see sect.
the number of operations applied in step and whether pre defined values are used to construct elements and expressions.
we now assess the impact of these parameters on its effectiveness.
forthisexperiment weusedthethreeversionsofapronmpq with the bugs seeded by the experts and the configurations shown in tab.
.
the results are presented in tab.
.
for each seeded bug wereporttheabstractdomaininwhichitwasinserted theviolated properties and the execution time until each configuration detects the violation.
as shown in the table configurations c2 c5 and c6 allfindthemaximumnumberofviolations andimplicitlyallthetable different configurations of our technique.
configuration initial pool size operations pre defined values?
c1 yes c2 yes c3 yesc4 yes c5 yes c6 no bugs within the time limits defined in tab.
.
however c2 does so significantly faster than c5 and slightly faster than c6.
initial pool size.
whentheinitialpoolincludesjust latticetopand as in c1 no violations are detected for intervals in comparison to c2 that is bugs are missed.
on the other hand a very large initial pool c3 increases the execution time without detecting all violations.
we attribute this to the fact that the size of the initial pooldirectlyinfluencesthenumberofpossibleargumentstothe subsequent operations in step and to the test oracle exploring all of them takes more time without necessarily being more effective.
numberofoperations.
withoutusingstep2ofthepoolconstruction c4 somebugsandpropertyviolationsaremissed seesect.
for an example .
however for our technique to be effective the number of operations should not be too large since it increases the executiontime.intab.
c5isusuallyslowerthanc2eventhough both configurations find the same number of violations.
pre defined values.
forapronmpq whichusesarbitraryprecision rationals both c2 and c6 find all the violations c2 being slightly faster.
pre defined values are particularly important for testing abstract domain implementations based on fixed precision numbers such as apron double as our experiments show seesect.
.1and sect.
.
these implementations may suffer from arithmetic overflows and rounding errors.
.
fuzzing and dynamic symbolic execution inthissection wecompareourtechniquetopuregray boxfuzzing and dse.
in particular we use libfuzzer and klee a state of the art dse engine to generate inputs for the test oracles corresponding to the properties from fig.
.
for a fair comparison wewrite alternativetestdrivers thatdonotcreateandpopulatea pool of abstract elements.
instead we allow the tools to directly generate the coefficientsand constants of up to 50constraints perelement.
the test oracles are the same as in our test drivers.
gray boxfuzzing.
weranlibfuzzer withdefaultoptions onthe threeapronmpqversionswithseededbugs usingthesametime limitsasintab.
andcomparedtheresultstoourc2configuration.
libfuzzer detected out of the property violations that our approachfound.itrevealedtheseviolationsgenerallyfasterthan our approach for intervals and polyhedra but slower for octagons.
a manual inspection of the generated counterexamples shows that our technique produces significantly simpler and more readable testinputs whichwasveryusefulindebuggingthedetectedissues.
tab.8providesadditionaldetailsforthebugsseededbyexpert3.
thelast two columnsshow thetime ittakesto detecta property violationforourtechnique withc2 andforlibfuzzer respectively.
libfuzzermissedoneoftheoctagonbugs.moreover libfuzzer s results for polyhedra suggest that the implementation of join is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automatically testing implementations of numerical abstract domains ase september montpellier france table impact of different configurations on the effectiveness of our technique.
the last six columns show the time needed to find a violation for each configuration from tab.
.
we grouped the violations by the seeded bugs they reveal dashedlines andbytheexpertwhoseededthebugs solidlines .weexcludedtwoseededbugsinpolyhedrathat caused assertions failures in apron for all configurations and thereby masked the other bugs seeded by expert .
domain violated execution time s property c1 c2 c3 c4 c5 c6 intervals nd .
.
.
.
.
intervals nd .
.
.
.
.
intervals nd .
.
.
.
.
intervals nd .
.
.
.
.52intervals nd .
.
.
.
.99intervals nd .
nd nd .
.49intervals nd .
.
.
.
.
intervals nd .
.
.
.
.
octagons .
.
.
.
.
.06octagons .
.
nd .
.
.97octagons .
.
nd .
.
.
octagons .
.
nd .
.
.
octagons .
.
nd .
.
.
intervals nd .
.
.
.
.
octagons .
crash .
crash crash .5octagons .
.
.
.
.
.05octagons .
.
nd nd crash crashoctagons crash crash .
crash crash crashoctagons crash crash nd crash crash crashoctagons .
crash .
crash crash crash octagons crash .
.
crash .
.
octagons .
crash nd crash crash crashoctagons .
crash .
crash crash .65octagons crash crash nd crash crash crashoctagons .
.
.
crash crash .03octagons crash crash nd crash crash crashoctagons .
.
.
crash crash .
octagons .
.
.
.
.
.
polyhedra .
.
.
.
.
.18polyhedra .
.
nd .
.
.41polyhedra .
.
nd .
.
.94polyhedra .
.
nd .
4h .56polyhedra .
.
nd .
.
.
polyhedra .
.
nd .
.
.97polyhedra .
.
.
.
.
.17polyhedra .
.
nd .
.
.27polyhedra .
.
nd .
.
.
intervals nd .
.
.
.
787intervals nd .
.
.
.
.0intervals nd .
.
.
.
.17intervals nd .
.
.
.02intervals nd .
.
.
.
.21intervals nd .
.
.
.
.
octagons .
.
.
.
.
.4octagons .
.
.
.
.
.87octagons .
.
.
.
.
.
octagons .
.
nd nd .
.37octagons .
.
nd nd .
.25octagons .
.
nd nd .
.05octagons .
.
nd nd .
.
polyhedra .
inc inc .
inc inc polyhedra .
.
.
.
.
inc polyhedra .
.
.
.
.
incpolyhedra inc inc inc .
inc incpolyhedra .
.
.
.
.
.2polyhedra .
.
.
.
.
.2polyhedra .
.
.
.
.
.19polyhedra .
.
.
.
.
inc violations found bugs found crash crash due to the seeded bugs nd the violation was not detected inc inconsistent representations assertion failure in apron s code table comparison of our technique with fuzzing for the bugs seeded by expert .
we grouped the violations by the seeded bugs they reveal dashed lines .
domain violated execution time s property our work fuzzing intervals .
.
intervals .
.
intervals .
.
intervals .
.
intervals .
.
intervals .
.
octagons .
.
octagons .
.
octagons .
.
octagons .
nd octagons .
nd octagons .
ndoctagons .
nd polyhedra inc nd polyhedra .
ndpolyhedra .
ndpolyhedra inc ndpolyhedra .
.07polyhedra .
ndpolyhedra .
nd polyhedra .
nd nd the violation was not detected inc inconsistent representations assertion failure in apron s code imprecisesinceonlyproperty12isviolated.incontrast ourtechnique revealed that the expert seeded a more serious soundness bug properties and are also violated .
dynamic symbolic execution.
since klee does not try to exploreallexecutionpathsinexternallibrariesandapronmakes heavyuseoflibraries weperformedthecomparisononthe eod andeoelinadomains usingklee sdefaultoptions.ouralternativetestdriversuseelina sfunctionsdirectly notitsapron interface to avoid external library calls.
with the latest version of klee .
.
all but test throw an error for both tested domains because klee is not able to model malloc instructions with symbolic sizes .
to overcome this limitation weextended klee with an option for specifying the upper bound for the symbolic size we used inourexperiments.foreachtesteddomain ourtechniquedetected 3violatedproperties see tab.
butkleewasnot abletodetect any even with a time limit of 700s the fold of the time limit usedforourtechnique .webelievethisisduetothefactthatelina heavilyreliesonfloating pointarithmetic whichkleedoesnot handle very well.
.
threats to validity we identified two threats to the validity of our experiments.
test generation tool.
our comparisons to alternative approaches focus on one fuzzer and one dse tool.
since we chose mature state of the art tools we believe that our results are representative.
similarly we did notuse alternativegray box fuzzers whenevaluating our own approach.
since most fuzzers make no assumptions about the code under test we do not expect to see significantly different results for other fuzzers.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france a. bugariu v. w stholz m. christakis and p. m ller randominitialization.
ourpoolinitializationstepchoosessome of the coefficients and constants randomly.
to ensure that our resultsaredeterministic alltestdriversusethesame pre defined random seed.
related work our approach is the first to systematically test a wide range of soundness precision and convergence properties oncomplex abstract domains.
it combines several existing test case generation techniques in a novel way.
on the one hand we derive executable test oracles to check high level mathematical properties of abstract domain implementations.
on the other hand we incorporate ideas from boundary and random testing step of the pool population andfromfeedback directedrandomtesting step2 toobtaininputsforthetestoracles.akeydifferencewiththelatter isthat inourcase thefuzzercontrolswhichelementsareadded to the pool by providing the operations and their arguments.
testing static analyzers with random programs.
one way to teststaticanalyzersisbyrandomlygeneratinginputprograms .
this approach is particularly effective in testing the robustness of analyzers that is for detecting which input programs make the analyzerscrash.toalsotestsoundnessproperties cuoqetal.instrument the code of the analyzer under test with assertions about inferredvaluesorrelationsbetweenprogramvariables.theseassertionsarethencheckedagainstconcreteexecutions.incontrast ourtechniquegeneratesinputdatasystematically anddoesnotrequire any modifications to the implementation of the tested analyzers.
analysistestinganddeltadebugging.
similarly to cuoq etal.
s work andreasen et al.
compare concrete executions to abstract domainelementstodetectsoundnessandprecisionproblems.they use delta debugging to reduce the size of the input programs in order to report the errors concisely.
in contrast we propose a technique for automatically generating the input domain elements our approachstartswithsimpleelementsandappliesasmallnumber of operations generating small counterexamples by construction.
systematicallytestinglatticeproperties.
midtgaardandm ller focusonquickchecking basiclatticepropertiesofabstract interpreters.
ourtechnique wasinspired bytheir work it extends thesetoftestedpropertiesand asourevaluationshows iseffective onwidely usedandhighly optimizedabstractdomainimplementations.acomprehensiveexperimentalcomparisonwiththeirtool was not possible as the authors provide constructors and helper functionsforgeneratingorderedpairsofelementsonlyforintervals but notfor the complex numerical domains thatwe consider.
without them many of the properties cannot be tested as the randomlygeneratedinputsverylikelydonotsatisfythepreconditions.for this reason we expect that their technique cannot significantlyoutperform gray box fuzzing whichwe showedto be less effective thanourapproach seetab.
.wesolvetheproblemofgenerating ordered inputs by applying domain operations to the existing pool elements e.g.
the result of a join over approximates its operands .
formally verified static analyzers.
interactive theorem provers suchascoq havebeenusedtoverifythesoundnessofthe designof static analyses e.g.
in the context of type systems .
however the proofs do not typically provide any guarantees abouttheactual implementation oftheanalyses and thus couldstillbenefit from automated testing techniques like ours.
the verasco projectextractsexecutablecodefromverifiedcoqformalizationsof severalabstractdomains.thisapproachproducesimplementations thatarecorrectbyconstruction butisnotyetpracticalforcomplex highly optimized implementations.
recent work by madsen and lhot k uses symbolic evaluation based on symbolic executions and smt solvers to verify the correctness i.e.
safety and soundness ofabstract domainimplementations.iftheproblemis undecidable itreliesonaquickcheckingapproachinspiredby .
their evaluation does not consider complex numerical domains.
unsoundness in static analyzers.
even for analyzers that are unsoundbydesign ourtechniqueisusefultodetect unintentional sources of unsoundness and imprecision e.g.
caused by implementation errors .
testing compilers and program analyzers.
abstract domains are one of many components that are used in modern compilers and program analyzers.
besides efforts in proving properties about such components e.g.
compcert and verasco there is a significantbodyofworkonusingtestingtechniquestodetectissues in compilers and recently in dse engines .
conclusion wehavepresentedanautomatedtestingtechniquefordetecting soundness precision andconvergenceerrorsinabstract domain implementations which are crucial components of many staticanalyzers.
we have evaluated our approach on several complex real world abstract domains from two widely used libraries fornumerical analysis and demonstrated its effectiveness in finding both seeded and previously unknown errors.
eventhoughourevaluationfocusesonnumericalabstractdomains we believe that the high level ideas of our technique also applytootherdomainssuchasstringorheapdomains.suchdomainsrequiredifferenttechniquestoconstructdomainelementsas wellassuitableparametersforassignmentsandconditionals.moreover oneneedstoassesswhetherfuzzerscaneffectivelyexplore the search space of non numerical domain implementations.
we leave these generalizations as future work.
there are several lessons to be learned from this work.
first an automatedtestingtechniqueoffersapragmaticandeffectivesolutionforuncoveringissuesinstaticanalyzersthatwouldbedifficult to find using manual testing.
second off the shelf testing tools are lesseffectiveforcomplex highly optimizeddomainimplementationsthanawell designedcombinationoftechniques.webelieve that these observations carry over to other application areas such as machine learning frameworks exploring those is future work.