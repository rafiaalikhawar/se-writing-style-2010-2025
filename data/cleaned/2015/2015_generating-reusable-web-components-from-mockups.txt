generating reusable web components from mockups mohammad bajammal university of british columbia vancouver bc canada bajammal ece.ubc.cadavood mazinanian university of british columbia vancouver bc canada dmazinanian ece.ubc.caali mesbah university of british columbia vancouver bc canada amesbah ece.ubc.ca abstract thetransformationofauserinterfacemockupdesignedbyagraphic designertowebcomponentsinthefinalappbuiltbyawebdeveloperisoftenlaborious involvingmanualandtimeconsumingsteps.
weproposeanapproachtoautomatethisaspectofwebdevelopment by generating reusable web components from a mockup.
our approachemploysvisualanalysisofthemockup andunsupervised learning of visual cues to create reusable web components e.g.
reactcomponents .weevaluatedourapproach implementedin a tool called vizmod on five real world web mockups and assessed the transformations and generated components through comparison with web developmentexperts.
the results show that vizmod achieves on average precision and recall in terms of agreement with the developers assessment.
furthermore the refactorings yielded code reusability on average.
ccs concepts software and its engineering software development techniques software prototyping keywords web ui web components web refactoring machine learning computer vision acm reference format mohammad bajammal davood mazinanian and ali mesbah.
.
generating reusable web components from mockups.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 11pages.
introduction the development of user interfaces uis for web apps is often a manualandtimeconsumingtask.inasurveyofmorethan5 developers reported working on app ui design tasks on a daily basis more so than other development tasks which they tended to perform every few days.
another study also showed that an average of of the code size of software is related to the user interface .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
common workflow for creating web user interfaces is mockup based design .
in this approach a graphic designer creates a roughillustrationoftheanticipateduidesign calledthe mockup orwireframe usuallythroughagraphicdesignsoftwareorawysiwygeditor.thismockupisthenexportedtohtmltoberendered ina browser.
aweb developerthenexamines themockup andbeginsconstructingwebcomponentsfortheapp whicharenowadays implementedinoneofthepopularfront endframeworkssuchas angular or react .
the main building block of ui design and a cornerstone of these front end frameworks is the concept of reusable components whichareasetofapisandcodingpracticesallowing reuse and encapsulation of repeated patterns on the front end.
reusablecomponentshelpimprovemodularityandmaintainability makethecodemoretestable andeffectivelyremoveduplication by offloading the task of creating repetitive patterns to the webbrowser at runtime.
recent surveys show that using front end frameworks is extensively popular among web developers.
in one surveymorethan92 ofaround28 000surveyedwebdevelopers statedthattheyuseaframeworkratherthanconstructinguisusingpurehtml .asaresult creatingreusablecomponentsisoften an essential element of building an app s front end.
thiscomponentcreationprocesscanoftenbetimeconsuming andtedious inpractice itrequiresseveralmanualsteps including the examination of the mockup checking potential elements thatmayormaynotbesuitableforconversiontocomponents con structingatemplateforcomponentsthatunifiesrepeatedsegments adding placeholders for variable content and refactoring the code to replace instances with instantiated components .
to the best of our knowledge there has been little to no automated support in creating these reusable web components from mockups.existingtechniqueshelptomanagemockupsthemselves butdonotgenerateanycomponents.forinstance onesetofapproaches takesamockupasinputandconvertsitslayout into a responsive code e.g.
through css such that it is flexible to maintain the layout on different display sizes.
others propose atoolthatoverlaysthemockupasatransparencylayerwhileimplementing the ui and performs a snapping like functionality that aligns against various parts of the mockup.
in this paper we propose a technique implemented in a tool vizmod tofill this gap byautomatically generating reusable web componentsfrommockups.givenawebmockup ourtechniqueautomatically identifies patterns on the ui refactors the html code andcreatesreusablecomponentsforpopularfront endframeworks that are already familiar to developers such as react or angular.
atthecoreofourapproachisanunsupervisedmachinelearning processforthedetectionofreusableuipatterns weusefeatures composed of a hybrid of information obtained from the document object model dom as well as the visual analysis of the ui.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mohammad bajammal davood mazinanian and ali mesbah weevaluatevizmodonfivereal worldwebmockupsbyautomaticallyidentifyingandtransforming120componentinstances into components.
we also ask five experts to manually find patterns on the mockups and compare the output from our approach with the manually identified patterns.
our approach is able to achieve precision and recall on average in correctly detecting reusable patterns in the uis.
this paper makes the following main contributions a novel approach for automatically generating web components e.g.
react angular from mockups which is the first to address this issue to the best of our knowledge.
atechniqueforvisuallyanalyzingthestructureofamockup andtransformingitintocomponentsviaunsupervisedmachine learning.
animplementationofourapproach availableinatoolcalled vizmod.
aqualitativeandquantitativeevaluationof vizmodinterms of its accuracy and reusability of the generated components.
motivating example figure1illustrates a part of a sample ui mockup for a job hunting website.themockup oftendesignedbyagraphicsdesignerina team providesavisualrepresentationofwhattheuiofthewebapp issupposedtolooklike.thecodecorrespondingtothismockupincludes the html code which defines the mockup s structure andcontent andcsscode whichdefinesitsstyleandpresentation.
thiscodeistypicallygeneratedautomaticallyusingpopularweb ui editors e.g.
muse dreamweaver visual studio .
the html and css code is interpreted by web browsers to render the ui.
subsequently a web developer oversees the creation of the final front endcodefortheapp.forthevastmajorityofdevelopers amajor part of this process is the creation of reusable components .
usingcomponentsiskeyinimprovingmodularityandmaintainabilityandachievingthesoftwareengineeringbestpracticeofdry don t repeat yourself .
it is also an effective way to remove duplicationsintheapp scode whichhasbeenshowntobeassociated withincreasederror proneness maintenanceeffort code instability as well as higher hosting costs and rendering delaysduetothetransmissionofredundantdata.theutilizationof reusable web components can help to address these issues.
for example observe in figure 1that there are four groups of elements repeated in the mockup denoted by a b candd.
notice that the repeated elements are not exactly similar there aredifferences in terms of for example the text and images appearing within the elements.
nevertheless the structure of the repeated elements in each group and their overall visual appearances areunquestionably repeating.
reptitions in ui are unavoidable andneccessary.
in fact repetition is an important aspect of effective visualdesign andisknownasa functionaltechnique toachieve appealing designs .
research has shown that when a visual stimuliis repeated it is more likely to be accepted by people a phenomenon called repeated exposure .
however theprocessofcreatingcomponentsisrathertimeconsuming requiring manualeffort .
when analyzingrepetitions in a mockup to construct components in one of the modern ui frameworks developers often face the following challenges a b dc figure an example of a web ui mockup.
they need to visually glance at the mockup and manually identify the patterns in the ui that can be potentially refactored to create a reusable component.
for instance for group a they need to find all patterns in the page that represents components similar to the elements inside group a. the repetition might bespreadacrossthewebpage makingtheidentificationmore challenging.thedeveloperhastorepeatthissameprocessfor othergroupsofcomponentsonthepage whichquicklybecomes a time consuming manual effort.
note that this identification is notpossiblebyonlyusingexistingcodeclonedetectiontoolsthat support html code as input e.g.
nicad due to several reasons these toolsleave outthe visualappearance of theelements and only work at the source code level which is sub optimal since there are several inherent patterns in html which do not necessarily represent a ui component.
for example htmltablesaredeclaredusinga table tagfollowedby a series of other tags e.g.
thead tbody colgroup tr and td nested in a predefined hierarchy.
the clone detector might mark all tables on the page for extraction even if they do not visually constitute a reusable component in theui.
thesame happensfor severalother elements such as un ordered description and drop down lists.
clone detectors need to be configured properly in order to yield desirable clones.
there is usually a large list of parametersand thresholdstotune andfindingan optimalconfiguration is a laborious task .
clone detectors are not aware of the ultimate reason for detectingclones e.g.
thereisnoconfigurationthatcanforce them to only identify refactorable clones.
the developer also needs to unifythe patterns to construct a reusable component in a ui framework.
this process needs careful investigation of repeated html to identify how elementscan be unified into one representative component and whichelementscanbe parameterized whentherearedifferences.for example ingroup a adeveloperwouldexamineeachbutton authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generating reusable web components from mockups ase september montpellier france dom in web browservisual elements refactored htmlpotential component instance identification identified componentsvisual ui normalization ui component generationclass c1 extends react.component render return div ... class c1 extends react.component render return div ... class c1 extends react.component render return div ... ui components react angular ... potential component instances unsupervised visual matching figure overview of the proposed approach.
inthegroup anddeterminewhichpartsarerepeatedbetween the buttons and which part is variable e.g.
the button icon and its label .
the constructed component should resemble the exact hierarchy of the original repeated elements or else the output of the resulting ui might differ from the original one.
moreover tousetheconstructedcomponent thedeveloperhasto instantiate itintheplaceswheretherepeatedelementsoriginally appeared with the appropriate parameters e.g.
original texts or images topreservetheoutputofthemockup.forexample in groupa thedeveloperneedstorefactortheoriginalcodeand replace every occurrence of a button with a call to the button component passing along arguments for the button label and its image.
tothebestofourknowledge therehasbeennotechniquesavailable to address the aforementioned issues and support developers in the generation of components.
proposed approach figure2shows an overview of our proposed approach to automaticallygeneratemodularizedreusableuicomponentsfrommockups.
the approach begins by retrieving the dom of the web app s mockup.
next a visual abstraction is performed to generate a normalized and abstract representation of the web app s ui layout.
this transforms the mockup into a set of visual elements ves on whichfurtheranalysisisconducted.theapproachthenperformsa dynamic grouping of visual elements to identify subtrees which correspondtopotentialinstancesofauicomponent.thisgrouping isusedinthenextstep whereanunsupervisedmachinelearning technique applied on the potential ui component instances identifies ui components.
finally the actual code for the ui components is generated by refactoring the original html code.
inthefollowingsubsections wedescribeeachstepoftheproposed approach and illustrate some of their major components and analysis procedures.
.
definitions beforeweproceedtodescribethedetailsoftheproposedapproach we begin by declaring a few important definitions that are used throughout the paper.
definition ui component .a ui component ce angbracketleftn n angbracketright for a repeated group of ui element trees ein a web application is atreestructurerootedat n n wheren t pisasetofabstract user interface elements.
the component includes the templatetand theplaceholders p. the template of the ui component denotes the nodes which do not change wherever the component is used i.e.
instantiated while the placeholders allow parameterized nodes.
in this paper we use the terms ui component andcomponent interchangeably.
definition2 componentinstance .acomponentinstance i angbracketleftce f angbracketrightis a concrete and specific instantiation of a ui component ce.componentinstancessharethetemplatepartwithotherinstances ofthesamecomponent butdifferintheplaceholderparts.thefunction f p vassigns values v vto the placeholders p pofce.
definition potential instance .a potentialinstance is asubtreeofthedomconstructedforawebapplication suserinterface representingaconcreteuielementtreethatis likelytoforma component instance but may not be so.
potentialinstancesareprocessedatmultiplestagesoftheproposed approach until they are either discarded or associated with a component.
.
visual ui normalization inthefirststep oftheapproach wetakeasinputthe domofthe mockup after it is loaded and rendered in a browser and perform a visualnormalization thattransformsthedomintoasetof visual elements.thegoalofthisstepistonormalizethevisualpresentation ofawebuserinterfaceintoasetofabstractelementsthatsignify the salient features of the page from a visual perspective which mayrepresentpotentialcomponentinstances.theintuitionbehind this is that normalization and abstraction can be helpful to achieve our goal of detecting reusable patterns since the exact and minute detailsarelessrelevantwhenidentifyingrepeatedregionsofaweb page.
furthermore component instances are generally different fromeachotherinsomeaspects whiletheystillhavesimilaroverall visual appearance.
this normalization step enables obtaining a big picture to identify these potential similarities.
thevisualnormalizationisachievedasfollows.first weextract fromthedomasetofnodesthatrepresentvisualcontentofthe ui and we refer to each of these as visual elements .
we define two maintypesofvisualelements textualandgraphical image .the extractionoftextcontentisachievedbytraversingtextnodesof the dom.
more specifically t colonequal e node node domr node .hastextcontent where tis the set of all visual elements that represent text in the ui domris the rendered dom in the web browser and e node mapsthenodetothecorrespondingelement.thepredicate hastextcontent examineswhetherthereisatextassociatedwith the node and covers two possibilities non empty nodes of type text representingstringliteralsin domr andnodesof input elementsthathaveanassociatedtextvalue e.g.
buttonsorlists .
subsequently we perform another extraction for image content.
we define this as follows authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mohammad bajammal davood mazinanian and ali mesbah figure the result of the visual ui normalization stage as appliedtothemotivatingexampleoffigure .bestviewed on a color display.
i colonequal e node node domr node .hasima econtent where iis the set of all visual elements that represent images.
as in the previous case the predicate hasima econtent examines if there is an image associated with the node.
this again has two possibilities nodesof img elementsandnon imgnodeswitha non null background image attribute.
subsequently we usethesetof allvisualelementsto construct the normalized ui uin v i t whereuinis the resultant normalized ui and vis a visual projection operation that generates an image from the union of visual elements.
this is achieved as follows.
first we begin by collecting thefinalcomputed propertiesofeachelement whenrenderedinthe web browser.
these properties represent the final state of elements after the propagation of all changes and events.
the properties we collect are the size location and z orders of these elements.
next we assign different colors to each class of visual elements.
we assign green for elements in t and blue for elements in i. whileany arbitrarycolorscould have beenchosen we chosethese two colors in order to facilitate faster visual analysis in subsequent steps since these two are typically represented in separate color channels.figure 3illustratesanexampleoftheoutputgenerated fromthisvisualnormalizationstep.ascanbeobserved theminutedetailsofthepageareabstractedawaywhilethemainandessential structure of the ui is accentuated.
.
potential instance identification the result of the previous step consists of only a set of visual elements.
these visual elements on their own do not necessarily represent reusable repetitive ui patterns.
the goal of this step is to transformthesetofindividualvisualelementsintoasetof potentialreusableui componentinstances.
thesepotential component instanceswillbefurthercheckedandanalyzedinthesubsequent steps in order to generate a final set of components.
identifying potential component instances can be an intricate decision since there are multiple levels of hierarchy that can be considered.
for example consider group ain figure .
notice how the icons in that group would constitute repeated elements.the same is true for the text labels under the icons.
yet another repetition pattern is taking the icon and text as one component that is repeated multiple times.
accordingly in order to identify potential component instances we propose an approach that aims tomaximizetwocomplementaryaspects namely thenumberof repetitionsofacomponent andtheamountofrepetitionsencapsu latedwithineachcomponentinstance.werefertothiscombination of aspects as the modularization potential where a high value of modularization potential indicates a highly reusable ui component.
our goal is therefore to utilize this modularization potential to optimize a set of potential instances colonequalargmax c productdisplay ci c barex barex barex ci t i t i uin barex barex barex wherecisthesetofallcomponentinstances ciisapotentialinstance and the optimized function is the modularization potential.
thisoptimizationyieldsaglobaloptimumsetofpotentialinstances betweentwoextremes.atoneendofthespectrum eachvisualelement represents a component of its own.
this yields a sub optimal component set that has low modularization potential because of alack ofrepetitions.
forthiscase themodularization potentialin eq.
yieldsascoreof1sinceeachcomponentencapsulatesonlya singleelement.attheotherendofthespectrum onemighttheoretically consider the entirecollection of visual elements to represent a single component that is repeated only once.
this results in a score equal to n the number of total visual elements in eq.
.
on the other hand represents a global optimum between the aforementioned two extremes.
captures a set of potential component instances that aims for botha large number of components and foraninstancethatinitselfhasalargenumberofuirepetitions.
the subsequent steps of the approach will therefore only use for further analyses and final generation of components.
we now describe the implementation for generating .
figure4 showsanillustrationofthisprocess.first weobtaindomlocators e.g.
xpath expressions for each of the visual elements.
next starting from these locators as leaf nodes we iteratively build a treefromthebottomup asshowninfigure addingthedom parent of every tree node with each iteration.
at each iteration we calculate the modularizaton potential of eq.
with every node s subtreerepresentingapotentialinstance ci.thepotentialinstances areillustratedusingtheredoutlinesinfigure .notehowatthe very first iteration each potential instance is simply the visual element itself.
in the next iteration the potential instances grow larger to include more visual elements as shown by the larger red outlines at iteration .
finally the iteration that yields the maximal modularizationisreportedasthe setandpassedtothesubsequent stage.
.
unsupervised visual matching the output of the previous step is a set of potential component instances that maximizesthe modularization potential out ofmany alternative sets of instances.
however these are only potential instances that may or maynot actually belong to a component.
in other words there is still no information as to which subgroupof potential instances do indeed belong together and constitute a reusable component versus other potential instances that are simply visual elements that do not represent repetitive reusable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generating reusable web components from mockups ase september montpellier france html div div a a img img iteration 01n div a img figure4 illustrationofthepotentialinstanceidentification stage.eachiterationconsidersadifferentgroupofpotentialinstances before selecting an optimum set.
components.inthisstage weprocessthesetof potentialcomponent instances and reduce it into a final set of components.
inordertocreatethefinalcomponents weproposeanapproach that visually examines potential instances and combines them into components via unsupervised machine learning.
the intuition behindadoptingthisapproachisthatifpotentialinstancesmatchwith otherpotentialinstances the potential qualifiercanbedropped from these instances and they would be recognized as constituting acomponenttogether.inthisapproach weuseaclusteringmechanismtocreatecomponentsinordertofacilitaterobustmatchingof potential instances.
we now describe the details of the process.
first we obtain the screenshotimageofthevisualelementsperpotentialinstance.this results in one image containing all visual elements for each potentialinstance.next foreachpotentialinstanceimage weextract a feature vector.
we compute the feature vector using a vectorized pixel histogram which is a process that captures a summary of theoverallcontentintheinstanceimage.however unliketypical approaches from the machine vision literature where a binningparameter aparameterforcategorizingpixels isrequired wegeneratethevectorizedhistogramwithoutrequiringthisparameter.instead duetothenatureofvisualnormalizationthatwehave proposed onlytwocategoriesneedtobeconsidered onefortext visual elements and another for image visual elements.
therefore we finally end up with a feature vector for each potential instance.
subsequently wecomputethecosinedistancebetweeneachpair ii ijof potential instances di j ii ij bardblii bardbl bardblij bardbl next we perform an unsupervised clustering process.
the selectionofanappropriateclusteringisofparamountimportancedue toacoupleofchallenges.first theclusteringcanbechallenging due to the wide range of possibilities of arrangements and structuresofcomponentinstances.inotherwords thereispotentiallya large range of inter andintra component variations.
this makes it difficult to use hierarchical clustering for instance due to its very high sensitivity to outliers and therefore would be a poor choice forhandlinglargecomponentvariations andalsoduetoitshigh dependenceonorderofdata whichcanmakeitlesseffectiveforde tectinginstancesfarwayfromeachother.furthermore performingacutontheclusteredhierarchiesoftenrequiresspecifyingthenumber of clusters or some other parameter which can be difficult and brittle to specify.
density based algorithms e.g.
dbscan would notbeeffectiveeither astheywouldhavedifficultyhandlingthe variabledensitiespresentbetweenpotentialclustersofinstances.
accordingly we optedfor atechnique thatcanbe flexibleenough tocorrectlyidentifysuchvariationsandbeabletobetterrecognize the final components.
to do this we select a method that performs variable density clustering with a hierarchy of densities .
the hierarchy of variable densities allows the method to automatically detectstableclustersinaparameter freefashion.moreimportantly the method is built to handle varying densities which becomes very important when handling the potentially large range of interand intra component variations.
once the components have been identified through unsupervised visual matching we extract the corresponding locator in the dom e.g.
xpaths perinstance.thefinalresultisasupersetof component instance locator sets.
this superset is passed on to the nextstepinordertocombinethecomponentinstancesintofinal components.
.
ui component generation we propose an algorithm that unifies the ui component instances identified in the previous steps into a component implemented usingawebframework e.g.
react angular htmlwebcomponents .however insteadofdirectlygeneratingtheframeworkspecificcodeforcomponents weoptforconstructingan intermediatemodel thateffectivelyrepresentscomponentsatahigherlevelof abstraction.
this allows building different translation strategies for generating the actual code for different frameworks from the same model with the added benefit of remaining agnostic to the specific detailsofaparticularframework.ourimplementationsupportsthe react translation strategy which is the preferred framework for a significant number of developers in practice .
we first define the terms used in this step.
definition4 mappingnodesset .lett t1...tn bethe listofdomsubtreesfor ninstancesofauicomponentidentifiedbythe previous phases of the approach.
a set d d1 t1 d2 t2...dn tn ofdomnodescorresponding to tisa mappingnodesset when every pair di dj of dom nodes belonging to daremapping.
definition5 mapping .twodomnodes dianddjaremapping denoted as di squiggleleftrightdj when bothdianddjare root nodes of their trees or dianddjare not root nodes and di.parent .ta dj.parent .ta and di.parent squiggleleftrightdj.parent and dianddjhave the same child index e.g.
they are both the first child of their parents .
definition6 componentintermediatemodel .thecomponent intermediate model is a rooted ordered tree in which each nodecorrespondstoamappingnodesset.thehierarchyofthistree follows the mapping dom nodes hierarchy.
example.
figure5 a depictsthehtmlcodesnippetscorrespondingtotwoidentifieduicomponentinstances.thecorresponding authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mohammad bajammal davood mazinanian and ali mesbah c non parameterized node soft parameterized node hard parameterized node t2t1 div div text img span text div div div text img text span text b foosrc .png barsrc .png baz text1 text2 a d component div div arg0 img src arg1 div arg2 div component div div foo img src .png div span baz span div div div bar img src .png div div span text1 span text2 span div component args component args bar .png di v span text1 span text2 div e figure a initial html code fragments.
b correspondingdomsubtrees.
c theconstructedcomponentinterme diate model.
d the final generated ui component.
e thecallsto the generated ui component.
domsubtrees andtheconstructedcomponentintermediatemodelforthesesubtreesarerespectivelyshowninfigure b and c .the connecteddomnodeswithdottedarrowsformmappingnodes sets.noticethatnon mappingdomnodesdonotformanodein theintermediatemodel.thismodelcanbetranslatedtoareactlikecomponentsimilar towhatisshowninfigure d .finally the generated component is instantiated two times in the refactoredhtml code to replace the originally repeated dom nodes.
the calls to the component can look like what is shown in figure e .
whengeneratingtheactualframeworkcode eachmodelnode results into a dom node in the framework component as depicted infigure d whichessentially unifythenodesinthemapping nodessettoremoveduplication.therearethreepossibilitiesfor framework component dom nodes when all pairs of dom nodes in a mapping nodes set have the sametagandidenticalattributevalues theycanbeunifiedinone domnodeofthesametag.forexample thetwo div nodes in figure 5corresponding to model node 1form a div node in the component.
a pair of dom nodes in a mapping nodes set which have different tag names cannot be unified into one dom node in the component e.g.
span and div corresponding to model node5in figure .
similar is two text nodes with different content e.g.
the fooandbarcorresponding to the model node 3in figure .
in such cases the dom nodes and the whole subtree rooted at them should be hard parameterized in the resulting component i.e.
a placeholder should be created.
the originalparameterizeddomnodesarelaterpassedas arguments when instantiating the component to recreate the original dom hierarchy.
a pair of dom nodes in a mapping nodes set that have thesame tag name but different values for one of their attributes might be unifiable into a dom node via soft parameterization wherethedifferingattributevaluesareparameterized e.g.
the img tags corresponding to model node 4in figure with parameterized srcattribute values .
this can be done only if the used framework supports parameterizing attribute values.
otherwise the parameterization should be done as if it was a hard parameterization.
the intermediate model construction and refactoring algorithm.the inputs of algorithm 1are the original mockup html thelistofcomponentinstancedomsubtrees andthetranslation strategy.theoutputistherefactoredhtmlwhereinduplication is removed using the ui components.
algorithm component intermediate model generation input the original dom of the mockup domori inal ui component instances dom subtrees subtrees ui component translation strategy strate y output the new dom after refactoring domrefactored model constructemptyintermediatemodel coverednodes templatetree getsmallesttree subtrees templatenodes bfs templatetree fortemplatenode templatenodes coverednodes do coverednodes coverednodes templatenode mappednodes getmappednodesset templatenode subtrees parameterization null forcurrentnode mappednodes coverednodes do parameterization compare templatenode currentnode ifparameterization nequalnullthen break end if end for parent model .getmodelnodefor templatenode .parent ifparameterization nequalnullthen ifparameterization soft parameterization strate y .supportsattributeparameters then model .addsoftparamnode parent mappednedesset coverednodes coverednodes mappednodes else model .addhardparamnode parent mappednedesset coverednodes coverednodes getallsubtreenodes mappednodes end if else model .addnonparamnode parent mappednedesset coverednodes coverednodes mappednodes end if end for domrefactored strate y .refactor domori inal model algorithm 1starts by constructing an empty model line and anexclusionlist coverednodes inline2 thatcontainstheoriginal dom nodes of the component instances which are already coveredbythealgorithm e.g.
amodelnodehasbeencreatedfor them sothattheyareskippedinfutureiterations.toconstructthe intermediatemodel thealgorithmchoosesthedomsubtreeofone of the component instances i.e.
the template subtree to follow its hierarchy.thetemplatesubtreeistheonewiththesmallestnumber of domnodes choseninline .thisisbecausetheintermediate model cannot have more dom nodes than the smallest subtree asitresemblesthe intersection ofthecomponentinstances dom subtrees.
the algorithm loops over all the uncovered template subtree sdomnodes followingthesubtree sbreadth firsttraversal authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generating reusable web components from mockups ase september montpellier france order lines 5to28 .eachtemplatedomnodeiscomparedtoother dom nodes of its mapping nodes set identified according to definition4in line7 using the compare function line which returns the type of parameterization needed to unify two given dom nodes and nullif no parameterization is needed.
note that even if one node in a mapping nodes set should be parameterized when compared to the template dom node the resulting model node will be either hard or soft parameterized thus comparing other nodes of mapping nodes set is not required line .
the intuition behind comparing nodes in the breadth first order is that across thecomponent instances dom subtrees it is more likely that the the inner nodes which define the structure of the finaluicomponent aresimilar whiletheleafnodes texts images are more probable to differ.
the inner nodes are thus compared before leaves also facilitating the identification of mapping nodes setbasedondefinition asthenodes childindicesfollowthebfs traversal order.
the algorithm then continues to add a model node for each mapping nodes set lines 15to27 .
first the model node that has been created for the template dom node s parent in the previous runs of the loop is retrieved from the model line to which the new model nodes will be added as children.
this effectively allows themodeltopreservetheoriginalhierarchyoftheinstances dom subtrees.
if the model is empty the new model node will form the model sroot.
thesubsequent linesof thealgorithm addthe new modelnodebasedontheparameterizationtype.ineachstep the domnodesinthemappingnodessetforwhichamodelnodeis createdareaddedtothe coverednodes tobeskippedinthenext iterations.
as mentioned in case of a hard parameterized model node all the dom nodes belonging to the subtrees rooted underthe corresponding mapping dom nodes should be marked to be skipped e.g.
node 5in figure .
finally theactualrefactoringisconductedusingtheconstructed componentintermediatemodel line .thedetailsoftherefactoring are built in the translation strategy which can be implemented virtually for any ui framework of interest.
.
implementation weimplementedtheproposedapproachinatoolcalledvizmod shortfor visualmodularizer .vizmodisimplementedinjavaand python .
we use the selenium web driver to view the mockup and extract dom trees and their relevant computed properties.
for clustering we use the implementation provided by campello et.
al.
and the numpy library for mathematical and numerical functions.
evaluation to evaluate vizmod we conducted qualitative and quantitative studies aiming at answering the following research questions rq1are the refactorings by vizmod s component generation correct?
rq2how effective is vizmod in identifying ui components compared to manual examination by web developers?
rq3how much code reusability can be achieved through the proposed refactorings?inthefollowingsubsections wediscussthedetailsoftheexperimentsthatwedesignedtoanswereachresearchquestion together with the results.
.
rq1 correctness of component generation refactorings .
.
study design.
fortheproposedcomponentizationapplied on html to be safe the main criterion is that the original and the refactored htmls must result into the same dom tree landed into the users web browsers.
consequently to devise a technique that can automatically assess the safety of the applied transformations we relied on the equivalence of the dom subtrees rendered in the web browser before and after refactoring.
if the dom trees are the same given that our refactorings do not change any css style rules the resulting presentation semantics of the html files remain intact.
to automate this process we serialized the final dom trees rendered in the browser to the pretty printed html code and comparedthempre andpost refactoring.thisallowsafastcomparisonofthestructureofthedomtrees.wenormalizedthedom trees by removing text nodes which are empty or contain only white spaces.
this is done because react interprets these nodes differently compared to the standard html specifications.
.
.
results and discussion.
usingtheaforementionedtechnique we compared the dom subtrees of the ui component instances before and after refactoring for the ui component instances i.e.
ui components identified by vizmod.
the tests has passed for all subjects indicating that the refactorings introduced by component generation do preserve the dom trees and as a result the transformations are safe to apply.
.
rq2 ui component identification .
.
study design.
we asked independent expert web developers to participate in a qualitative study with the goal of understanding whattheywouldidentifyasbeingacomponentpatterninawebui.
withthisstudy weaimatevaluatingthe dis agreementbetween theproposedapproachandexpertdevelopersintermsofidentifying the ui components.
subjectsystems.
theauthor s searchedtheinternettofindmockups suitable for this study using keywords like web mockups webtemplates front endtemplates .ourselectioncriteriafor choosing mockups were they should be non trivial both visually and code wise i.e.
html and css .
note in table 1that the mockups are indeed complex intermsofthenumberof domnodesandcsscode size.
the number of subjects should be small and manageable enoughsothatwecanaskparticipantstohighlightpotentialcomponents inallof them without causing too much burden mental fatigue or boredom on them which can negatively distort the study.
theyshouldonlyrepresenttheuifront end i.e.
withoutbackend or front end business logic or functionalities.
basedonthesecriteriawechosefivemockupsforourevaluation.
weusethesamemockupsinalltheevaluationexperiments.table shows descriptive statistics for them.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mohammad bajammal davood mazinanian and ali mesbah table subjects descriptive statics subject body size kb dom nodes css size kb some mockups use css frameworks e.g.
bootstrap .
this corresponds to the total css size including the frameworks.
participants.
we emailed developers who have worked in local businessesorresearchlabsandaskedthemtovoluntarilyparticipateinourstudy.weattachedazippackagecontainingoursubject systemstogetherwithalinktoapost studyquestionnaireaimedat collectinginformationabouttheparticipants demographics e.g.
numberofyearsofexperienceinsoftwareengineeringingeneral and in web development in particular and their self assessment onwebapplicationdevelopmentskills .weaskedthemtomanuallyhighlightrepetitionsontheuiofeachsubject bydrawinga rectangle on each repetition and send the results back to us.
accordingly we emailed developers and informed them of thestudy andaskedthemtoalsopassitontotheircontacts.we receivedresponsesfromatotaloffivedevelopers.table 2shows participants demographic information.
as it is shown all the participants were quite experienced in web development as measured bytheyearsofsoftwareandwebdevelopmentexperienceandtheir own self assessment.
comparison with developers.
for each subject we compared the components highlighted by the experts with those components that vizmod automatically identified as ui components.
in particular whenmorethanhalfoftheexpertshighlightedapattern on the mockup as repeated we assume the majority is correct and consider it as a ui component that our technique should be able to identify.
the performance of vizmod is then determined using the well known precision andrecallmeasures.
a true positive for the approach is defined as a ui component that has been manually identified by more than half of the experts in our case three or more participants .
a false positive on the other hand is a ui component that is reported by the approach yet less than half of the expertshaveidentifiedit.finally a falsenegative oftheapproach isauicomponentthatisreportedbymorethanhalfoftheexperts but the approach could not identify.
table demographics of the participants participant sw dev.
web dev.
web dev.
self assessment years years highly expert .
.
results and discussion.
table3shows the results of comparing the ui patterns identified by our approach to the ui patterns identified by participating developers in our experiment.
the table shows the valuesfor true positives false positives false negatives andfinallyprecisionandrecall.thevaluesforrecallrangebetween and .
we examined the subjects at the lower end of the range to investigate further.
almost all the components that were missedbyourapproachhadmanyelementsthathadanimations or moving sub elements e.g.
a carousel that changes every few seconds .ourtechniquewasnotdesignedwithanimationsinmind.capturing and analyzing animations can be challenging due to difficulties in keeping track of changes over time and deciding which time instant to take as representative.
this might be a possible venue for future work.
as for the precision we further examined the nature of false positives in order to better understand the performance.
following this examination we identified another variable while performing thecomparisonwithparticipants the potentiallymissedopportunities.wedefinemissedopportunitiesasthosepatternsthatwere reported by as few as one developer but not the majority as well asour tool.
the reason for introducing this variable is that by manually examining the false positives we noticed that there were afewpotentialopportunitiesthatweremissedbythemajorityof developers.
we postulate a number of possible causes as to why such patterns were not reported by the majority of participants some repeating components were laid out far away from each other e.g.
attheverytopandverybottomofthepage .thisoften makes it difficult for human developers to remember patterns thatarenotimmediatelyvisiblewithinthesameview especially iftherearelotsofpatternsthattheyhavetokeeptrackof.the human brain has been shown to have a short term memory capacity of only around to objects at a time .
this fact coupled with patterns that are far away from each other andinterlaced with multiple other patterns can cause humans to misssomepatterns.ourapproach however isagnostictowherethe pattern is located and is able to recognize matching patterns fromfar endsofa webuijustas easilyaspatterns immediatelynext to each other.
some components included images or icons that were designed to be faint or barely visible due to artistic reasons.
such icons especiallywhenpresentclosetoveryvibrantandlargerepeating components are often skipped potentially due to the visual attention in the brain being directed at the larger clearer patterns.however duetothevisualnormalizationadoptedinour approach suchartisticchoicedonotmakeanydifferenceandthe pattern is recognizable regardless of how visually pronounced it is.
for these reasons we believe that the potentially missed opportunities are a better indicator of performance and we include theirnumbersinthetable.therefore wefinallyindicatethatthe precision andrecall performanceof thetool are93.
and .
respectively as shown in table .
.
rq3 code reusability .
.
study design.
wenowproceedtodeterminehowmuchcode reusabilitycanbeattainedwiththecomponentsgeneratedbythe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generating reusable web components from mockups ase september montpellier france table comparison of automatically identified components to manually identified ones by developers subject identified refactoring opportunitiesfn tp fp precision recallconsidering pmo components component instances pmo precision recall .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
pmo potentially missed opportunities.
approach.
for each test subject we compare the size of the html codeofthemockupsbeforeandafterrefactoringasameasureof how much reusability has been achieved.
lettrbe the set of dom subtrees corresponding to the ui componentinstanceswhicharegoingtoberemovedbyarefactoring operation r fromtheoriginalhtml.therefactoring raddsthe necessarycodewhichunifies trsubtreesintoauicomponent ur totheoriginalhtmlcode.moreover rreplacestrsubtreeswitha setcrofcallstoinstantiate ur.accordingly thesizereduction srr for the refactoring ris computed as srr summationdisplay t trsizeof t sizeof ur summationdisplay c crsizeof c wheretis a component instance cis a component instantiation call and sizeof x is the number of bytes corresponding to x when serialized to html.
in an html mockup there might be several sets of component instances i.e.
several ui components might be created .
the overall size reduction sr which is achieved by applying the set rof all refactoring opportunities found in a mockup is calculated as sr summationtext r rsrr.
wecalculatethesizereductionintwodifferentways basedon animplementationusingauiframework whichwehavechosento bereact and2 basedontherepresentationcontainedinthecom ponentintermediatemodel.thisisbecauseeachuiframework e.g.
react angular hasitsownsyntaxandidiomaticmechanisms for creating ui components and instantiating them.
as a result the actualsizereductionwouldbedifferentdependingonwhich and how auiframeworkisused.alluiframeworks however follow the same basic principle the set of dom nodes that can be unified into single dom nodes form a templatefor the ui component while other nodes form the parameters i.e.
placeholders i nt h e ui component.
these placeholders are filled with the arguments passed when calling the ui framework.
as a result calculating the size reduction based on the nodes and arguments identified when constructing the component intermediate model allows a more accuratedeterminationofhowthealgorithm intrinsically performs intermsofcodereusability regardlessofthedifferencesbetween the many possible ui frameworks that can be used.
moreover when using a third party ui framework it is usually required that the framework s javascript library code is imported at the client side so that the web browser is able to render the ui potentially increasing the overall size of the client side code.subjectssize reduction intrinsic performance performance with react .
.
.
.
.
.
.
.
.
.
figure6 codereusabilityperformanceachievedbytheproposed component generation as measured by final size reduction.
however ifthewebapplicationwantstoenjoythemaintainability benefits of the ui framework the javascript files should be imported anyway.
as mentioned this is an extensively popular trend among the developers .
notwithstanding if developersoptforusingstandardhtmlwebcomponents instead ofthird partyuiframeworks therewillbenoburdenintermsof the additional imported javascript files.
as a result when reporting the size measurements for react we only consider the code generatedbyourapproachforimplementinguicomponents not react s own core javascript code.
.
.
results and discussion.
figure6illustrates the results of applying the proposed refactorings on the test subjects.
observe that using react implementation refactoring ui components results inreducingthesizeofthehtmlcodeby6 .
withanaverageof11.
.the intrinsicperformanceofthealgorithmitself however is higher .
.
with an average of .
.
this difference highlights that react components require quite considerableamountofaddedcodetotheoriginaldominformationof the ui component instances.
for example a ui component shown in figure d needs to be wrapped into a function named render implemented in a javascript class that extends the internal reactclass react.component .wealsoneedtoaddadditionalcode to pass arguments to the ui components for each ui component instance.
as mentioned using another ui framework can yielddifferent saving ratios.
it is for these reasons that reporting the intrinsic performance is important.
itisworthmentioningthatthissavingisnotmeanttoreplace existingtechniquesthat forinstance minifyhtmlbyremoving authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mohammad bajammal davood mazinanian and ali mesbah whitespace orviaanyotherreductionapproach.rather whatever savingsobtainedfromthecomponentscancomplementthemby adding even more saved bytes on top of what they would normally save.
discussion context within web development.
the approach we present in this paperrefactors repetitions in theui and mergesthem into a template which is finally converted into a component in one ofthecommonfront endframeworks e.g.
react angular .this automates one of the initial steps in making a full fledged web app ui whichisoftentimeconsumingandisdonemanually.theuseof thisapproach ofcourse wouldnotmeanthatthewebappisready tolaunchtoclientsandthedevelopmentprocessisfinished.the developer would use these components and continue the development by e.g.
addingbusinesslogic handlingevents connectingto databases or other sources.
furthermore the approach we present in this paper is for modularizing the ui view itself and is thereforeorthogonaltotheremainingcomponentsofthearchitecture patternoftheapp e.g.
model view controller mvc model viewpresenter mvp and to any backend server functionality.
threats to validity.
we chose test subjects i.e.
mockups randomlyfromtheinternetwiththementionedcriteriainsection .
.
to avoid any selection bias.
plus the evaluation participants are expert web developers with different years of web development experience mitigatingthethreatstotheinternalvalidityofthestudy.
the mockups are diverse and complex enough to be representative ofreal worldappfront ends mitigatingtheexternalvalidityofthe study by making the results generalizable.
to make the study replicable we have made vizmod s source code evaluation subjects and the anonymized participants responses available online .
related work visual analysis.
there exist a few techniques that analyze web applicationsfromavisualperspective.choudharyetal.
propose anapproachthatdetectscross browsercompatibilitybyexamining visual differences between the same app running in multiple browsers.
burg et al.
present a tool that helps developers understand the behavior of front end apps.
it allows developers to specifywhichelementtheyareinterestedin thentracksthatelementfor anyvisual changesandthe correspondingcode changes.
bajammaletal.
proposeanapproachtoanalyzeandtestweb canvas element through visual inference of the state of the canvas and its objects and allowing canvas elements to be testable usingcommondomtestingapproaches.incontrasttoourwork none of these studies aims to automatically identify and extract web components.
stocco et al.
explore visual techniques for web testing applications including visual based test repair and techniques for migrating dom based tests to visual tests.
clone detection.
there is a large body of work on clone detection in conventional source code .
some techniques also exist targeting web artifacts such as for identifying duplicated content or script function clones and quantifying the structural similarity across pages .
a number of existing publications proposetemplateidentificationforjavacodeby defininga number of heuristicsto compute codesimilarity.
rajapakseandjarzabek useccfinder toidentifyduplication inwebapplications.synytskyyetal.
useanislandgrammer to identify cloned html forms and tables.
cordy et al.
propose a language independenttechniquetoidentifyexact near missclones initially in html using island grammars pretty printing and textualdifferencing.inspiredbythatwork nicadclonedetector is proposed .
transformation and refactoring.
various techniques are proposed to convert static pages to dynamic ones to generalizedynamicwebpages ortofindsimilarfunctionalities acrosswebpages .othertechniques useclusteringtogroup similarstaticwebpagestogethertoextractsingle pagetemplates.
pattern mining techniques are used for identifying and refactoring duplicated css code in web apps.
in contrast to our work noneofthesestudiesaimsatautomaticallyidentifyingand extracting web components from mockups.
conclusions thedevelopmentofawebappfront endinvolvesmultiplestakeholders chief among them the graphics designer and web devel oper.
a ui mockup designed by the graphics designer has to beanalyzed and processed by a web developer in order create the app sfront endcode ataskthatislaboriousandinvolvesmanual timeconsumingsteps.inthispaper weproposedanapproachto automatethisaspectofwebdevelopmentbygeneratingreusable webcomponentsfromamockup.weimplementedourapproach in a tool called vizmod and evaluated on real world web mock ups and assessed its generated components through comparison withexpertdevelopers.itachievesanaverageof94 precisionand recallintermsofagreementwiththedevelopers assessment performstherefactoringsinacorrectmanner andthecomponents achieve a reusability on average.