an efficient robust and scalable approach for analyzing interacting android apps y utaka tsutano shakthi bachala witawas srisa an gregg rothermel jackson dinh department of computer science and engineering university of nebraska lincoln lincoln ne usa email ytsutano sbachala witty grother jdinh cse.unl.edu abstract when multiple apps on an android platform interact faults and security vulnerabilities can occur .
software engineers need to be able to analyze interacting apps to detect such problems.
current approaches for performing such analyses however do not scale to the numbers of apps that may need to be considered and thus are impractical for application to realworld scenarios.
in this paper we introduce j itana a program analysis framework designed to analyze multiple android apps simultaneously.
by using a classloader based approach instead of a compiler based approach such as s oot j itana is able to simultaneously analyze large numbers of interacting apps perform on demand analysis of large libraries and effectively analyze dynamically generated code.
empirical studies of j itana show that it is substantially more efficient than a state of theart approach and that it can effectively and efficiently analyze complex apps including facebook pok emon go and pandora that the state of the art approach cannot handle.
i. i ntroduction smart mobile application platforms such as android provide software engineers with ides that help them develop guis and generate skeleton code and a powerful application framework that they can use to quickly create java applications apps that run on android devices.
in this way google as the android provider can collaborate with external developers to build apps with different functionalities which in turn increases the value of android.
for such reasons android is currently the most widely adopted smart mobile platform in the world.
to ensure the dependability and security of android apps engineers and security analysts need to be able to isolate faults and security vulnerabilities in these apps.
while such faults and vulnerabilities can arise from various sources many occur due to interactions between apps and these can come to exist in various ways.
for example in collusion attacks multiple apps are deliberately altered to work together to perform malicious acts .
a recent study by mcafee labs reports that over versions of android apps contained colluding code capable of data exfiltration file inspection fake sms messages and other malicious activity .
a recent study by memon and anwar lists collusion as the next major mobile malware threat .
our proposed framework j itana is designed to effectively and efficiently address this problem.
as another example android apps can interact by exchanging messages and when any of the apps involved in interactions is updated failures can occur.
arecent study notes that of android apps behave differently after a platform update .
these types of faults and security vulnerabilities create the need for program analysis frameworks that are capable of analyzing multiple apps so that distributed interactions can be discovered.
unfortunately most widely used program analysis tools for android operate primarily on individual apps so they are not directly capable of detecting faults and vulnerabilities that involve interactions among multiple apps.
nonetheless researchers engineers and analysts attempting to address such issues have created functional techniques based on these existing tools .
in one technique used to analyze multiple interacting apps li et al.
employ e picc apkc ombiner and flowdroid in a four step process.
first two candidate apps are selected.
second apkc ombiner is used to merge the two selected apps into a single app.
the goal of this step is to reduce the iac problem to an inter component communication icc problem that existing icc analysis tools can solve.
third the merged app is analyzed using e picc a n icc analysis tool that was state of the art at that time.
e picc can be used in this context because all iac connections have been converted to icc connections in the merged app.
finally flowdroid is used to perform taint analysis on the merged app to identify possible malicious icc connections.
while approaches such as the foregoing can operate on small scale scenarios they are often impractical for real world use .
section ii provides an example that demonstrates that the foregoing state of the art technique is unable to analyze a collection of apps with iacs when their interactions become just modestly complex.
this is because the merging process step is inefficient fragile and non scalable.
as such the technique has no chance of scaling up to analyze even a handful of real world apps for faults and vulnerabilities.
the goal of this work is to overcome the sources of inefficiencies in prior approaches by rethinking the design of program analysis frameworks in general.
specifically instead of designing a framework that analyzes one app at a time we design a framework that can efficiently and simultaneously analyze multiple apps while maintaining all of the information needed to support rich analysis techniques.
in this paper we introduce j itana derived from jit analysis a program analysis framework for android that ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is capable of analyzing multiple apps simultaneously with native support for the dex instruction set.
unlike s oot a commonly used program analysis framework for java and android j itana is not designed like a compiler framework.
instead it operates in a fashion similar to that of a classloader used in any java or android virtual machine.
engineers can load parts of an app an entire app or multiple apps for static analysis without decomposing or merging apps.
j itana also supports analysis of shared system classes and third party library classes.
since j itana can analyze all loaded apps simultaneously it can generate important program analysis graphs such as data flow graphs dfgs and interprocedural control flow graphs icfgs that span multiple apps.
the static class loading process j itana uses has further advantages.
first it naturally resolves potential naming conflicts e.g.
two classes having the same name in the same way in which a real classloader would.
second it continues to maintain clear separations between apps so it preserves runtime properties that might otherwise be lost in the merge process e.g.
two apps in android can be two separate processes so their address spaces are not implicitly shared .
because j itana does not modify apps through instrumentation or merging all apps continue to run in their usual fashion.
in contrast an app generated by merging multiple apps using apkc ombiner is not guaranteed to run so testing it for correctness may not be possible.
further when many apps are merged into one the resulting app can be large rendering the use of precise analysis techniques more difficult.
to evaluate j itana we use three experimental scenarios to address three research questions rqs .
rq1 how efficient is j itana ?
rq2 how robust is j itana ?
rq3 how scalable is j itana ?
in our evaluations we compare j itana with the approach described above that merges multiple apps.
our evaluations show that j itana is substantially more efficient than the merging based approach even in relatively simple analysis scenarios and far more robust in analyzing non trivial groups of real world applications.
j itana also scales to effectively analyze non trivial real devices using different numbers of installed apps cases that the merging based approach cannot handle.
in the next section we provide a motivating example.
we then introduce j itana in section iii and evaluate it in section iv .
section v provides additional insights into our empirical results.
section vi highlights prior research efforts related to our work and section vii concludes.
ii.
m otiv a tion as noted in section i current approaches for analyzing groups of android apps for problems related to interactions require the apps or their representations to be aggregated they then can be analyzed by existing tools such as e picc ic3 or s oot .
li et al.
describe three approaches for creating aggregated results.
the first approach analyzes each app for possible flows and then combines the results toyield potential inter app flows.
approaches such as e picc ic3 and sifta fall into this category.
this approach is scalable because most of the analysis effort is intra app.
however by considering only the analysis results e.g.
possible flows variability aware data structures the approach does not preserve various graphs such as cfgs dfgs icfgs and points to graphs we refer to these henceforth as analysis graphs constructed as part of intra app analyses.
such graphs are crucial however for conducting richer and more precise analyses such as static taint or precise dataflow analysis.
the second approach for creating aggregated results combines cfgs instead of possible flows.
however combining cfgs from multiple apps can be memory intensive.
one option for addressing this problem is to create cfgs in forms that can be persisted to external storage e.g.
serializable objects before they are combined.
cfgs of apps should also be generated using the same format e.g.
using the same tool so that they can be merged.
to date we are not aware of any system that addresses the problem of iac analysis using this approach.
bagheri et al.
first generate models of components and then combine them to perform analysis this approach has been used to detect permission leakage .
however their models include only portions of the analysis information relevant to the tasks we are concerned with.
the third approach for creating aggregated results is the hybrid approach we described in section i. again the approach uses apkc ombiner to merge a pair of apps at the bytecode level to create a single app that can be analyzed using existing icc analysis tools such as e picc or general program analysis frameworks such as s oot .
apkc ombiner resolves two types of naming conflicts.
when two apps use a common method same name same code only one is maintained.
when two apps use two methods with the same name same name different code one is renamed.
while this approach can cause the code in the resulting app to bloat the authors argue that in the context of security it is not likely that colluding malware would employ more than a few apps since it is less likely for a user to have all apps installed on a device.
however there are other dependability and security contexts that may require engineers and analysts to consider more than a pair of apps at a time .
for example an analyst may need to identify software components and apps installed on a device that may be connected to a shared vulnerable component.
if this vulnerable component is heavily used the number of apps connected to it could be quite large.
as such apkc ombiner may face problems scaling up to sets of apps because it can merge only a pair of apps at a time.
the resulting app is also not guaranteed to run so testing it may not be possible.
we experimented with using apkc ombiner to iteratively combine multiple apps in a pairwise fashion.
for example to combine four apps a0 a1 a2 and a3 a0anda1are first combined.
the resulting app a01is then combined with a2 and the result a012 is combined with a3.
we found that it cannot merge a resulting app e.g.
a01with another app a2 in such cases it ignores a2without reporting any error.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dex file parser class loader vm analysis enginesvm graphs analysis graphs data structure graphs jitana library workstation class loader graph class graph method graph instruction graphs field graphanalysis controller visualizersdevice pointer assignment graphs context sensitive call graphs iac graph control flow analysis data flow analysis points to analysis symbolic execution graphviz travisread writeread write readjdwp over adb signal read writesignal signalandroid vm fig.
architecture of j itana in summary creating aggregated analysis results is a necessary step for approaches that analyze multiple connected apps using existing program analysis tools that have been designed to analyze one app at a time.
we have discussed existing approaches for creating these aggregated results they suffer from high complexity or failure to preserve generated program analysis information.
to preserve contexts while controlling the number of apps that needs to be merged li et al.
introduced their hybrid approach.
while this approach can analyze a small number of connected apps we show in section iv that it faces scalability and robustness issues when it is used to merge a large number of apps or complex apps.
iii.
j itana af ramework for analyzing interacting android apps to address the problems just noted and to provide a new program analysis framework for android that can efficiently and scalably analyze multiple apps at the same time while preserving analysis graphs we now introduce j itana 1a framework for supporting both static and dynamic program analysis techniques.
in this work our main focus is static program analysis but during our subsequent discussion of analysis results we also show how j itana can perform a dynamic analysis to deal with dynamically generated code.
this renders static analysis more effective because code generated at runtime can also be included in the analysis.
to render our static program analysis more efficient we employ a classloader based analysis approach instead of the traditional compiler based analysis approach used by tools such as s oot which focus their analysis effort within the boundary of an application .
s oot first loads the entire code of an app and performs analyses that include construction of various program analysis graphs.
by focusing only on the code within an app it cannot analyze multiple apps simultaneously.
this motivated li et al.
to develop a workflow that uses s oot twice once to analyze each app for potential iac sources and destinations and another to analyze the merged app.
moreover compiler based approaches often face difficulties handling large libraries because entire codebases must be analyzed.
for example a mandroid a 1jitana is available for download at ytsutano jitana .framework introduced by wei et al.
builds models of the underlying framework and libraries to facilitate program analyses.
our classloader based static analysis approach on the other hand loads code in a fashion similar to that of an actual classloader inside any java or android vm.
figure provides an architectural view of the j itana framework.
we designed j itana to be a highly efficient hybrid program analysis framework so it needs to be able to interface with language virtual machines such as dalvik or the android runtime system art .
the vm interface is provided through the analysis controller which is connected to the android vm via java debug wire protocol jdwp over android debug bridge adb .
this connection is established primarily for use in dynamic analyses though it also assists with static analyses in cases in which code is dynamically generated during program initialization see section v for a use case of this feature that we encountered in this study .
the next major component in the framework is the classloader vm clvm .
we implemented clvm based on the java virtual machine specification .
a class which is stored in a dex file on a file system must be loaded by a classloader.
each instance of classloader which is a java class inherited from an abstract class ljava lang classloader has a reference to a parent classloader.
when a classloader cannot find a class it delegates the task to its parent classloader.
in the android virtual machine this process occurs as shown in algorithm .
our approach employs a stand alone clvm to statically load code based on the same algorithm.
by using the clvm to load classes as part of our static analysis framework the following benefits ensue the explicit relationship between a classloader and classes that it loads creates a clear encapsulation of all classes in an application.
this property enables us to load multiple apps at the same time while maintaining clear separation among apps.
this property also allows our approach to naturally resolve class naming conflicts i.e.
two different classes with the same name as these classes would belong to different classloaders.
because our clvm operates in the same way as an actual classloader the dynamic analysis component of jitana can handle dynamically generated code.
for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm class loading algorithm data n name of the class to be loaded linit initiating class loader and dl an ordered set of dex files for a class loader l. result angbracketleftldef c angbracketright a pair of defining class loader and pointer to a class or interface loaded.
1begin l linit c null do foreach d dldo ifn class definitions list of dthen c address of loaded class return angbracketleftl c angbracketright l parent loader of l while l negationslash null return angbracketleftl c angbracketright example after installation on a device we discovered that facebook loads multiple additional dex files dynamically.
our framework simply pulls these dex files from the device directly for analysis.
the use of a clvm also provides an efficient way to analyze large libraries.
traditional compiler based analysis tools need to analyze entire libraries to build graphs that can be used to supplement application analysis.
our approach analyzes only the classes within a library that have been referred to by the application thus reducing the amount of analysis needed.
as such our framework by default analyzes classes from third party libraries as well as system classes.
once classes are loaded the system generates a set of vm graphs that include classloader graphs class graphs method graphs instruction graphs and field graphs .
v arious analysis engines then process these to produce control flow data flow and points to information which is then fed back in to the vm graphs.
other information is used to construct analysis graphs such as pointer assignment graphs context sensitive call graphs and an e picc based iac graph.
the framework can run side by side with existing visualization tools such as graphviz an open source graph visualization tool.
next we describe these graphs in details.
a. supported graphs most of the data structures used in j itana are represented as hierarchical graphs.
typically a node in such graphs represents a virtual machine object e.g.
a class a method an instruction together with analysis information e.g.
execution counts while an edge represents a relationship between two nodes e.g.
inheritance control flow data flow .
to achieve efficiency every graph used in j itana models appropriate graph concepts defined in the boost graph library bgl 2a de facto generic c graph library.
this means that implementations of highly optimized generic graph algorithms i j itana graphs name type node edge class loader vm graph class loader parent loader graph class graph vm graph class inheritance method graph vm graph method inheritance invocation field graph vm graph field instruction graph vm graph instruction control flow data flow pointer assignment analysis graph register alloc site assignment graph field array rd wr context sensitive analysis graph method with invocation call graph callsite inter application analysis graph class loader information communication resource flow graph are already available for use by applications on the graphs defined in j itana without modifications.
we also implement jitana in c which supports the use of the generic programming paradigm with templates.
this paradigm separates algorithms and data structures by defining what is called a concept a description of both syntactic and semantic requirements for one or more types .
an algorithm operating on a concept needs to be implemented only once the same implementation can then be reused for any concrete type that is a model of the concept.
generated graphs can be persisted for future reuse.
analyses can also be performed on any machines on which the bgl library is installed.
the c template instantiation mechanism coupled with compiler optimizations has been shown to generate code that is as efficient as handtuned fortran .
unlike j itana most existing tools do not use explicit graph types for data structures.
for example s oot and llvm follow the traditional object oriented approach an object holds pointers to other objects to imply relationships that implicitly form a graph data structure.
this means that algorithms implemented in these platforms are strongly tied to a tool s design details not to a graph concept.
as a consequence even a simple depth first search algorithm for example must be implemented each time it is needed and when a new tool arrives a library of algorithms must be rewritten.
table i lists the graph types currently generated by j itana .
there are two categories of graphs virtual machine vm graphs and analysis graphs .
virtual machine graphs closely reflect the structure of java virtual machines.
a node in a virtual machine graph represents a virtual machine object e.g.
class method that can be created or removed only by the clvm module in j itana .
modification of a node property by an analysis engine is allowed and is one of the primary ways by which to track dynamic information such as code coverage.
the edge type is erased with the boost.typeerasure library3so that analysis engines can add edges of any type.
examples of some of these graphs rendered with g raphviz are shown in figure .
figure a displays a classloader graph for a case in which jitana analyzes four apps simultaneously.
each class loader is assigned a unique id integers in the upper left corners so typeerasure.html authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that classes with the same name from different apps can be distinguished.
for example both facebook and instagram ship a class named landroid support v4 app fragment with different method signatures because the facebook app is obfuscated with p roguard 4therefore the names of dex files have no meaning.
classloader is the system class loader and is used to load necessary system classes.
each directed edge shows the parent child relationship between two class loaders e.g.
the system class loader spawns off application class loaders .
figure b displays a class graph that shows relationships between four classes the directed edges display subclass relationships e.g.
lcom instagram .. .
loadimagetask is a subclass of the abstract class landroid os asynctask .
figure c displays a method graph that shows relationships among several methods within a set of analyzed apps.
nodes represent methods and edges indicate whether method calls are direct orvirtual .
the numbers in the upper left corners of the nodes indicate the apps to which the methods belong.
not depicted in the figure are instruction graphs and field graphs.
j itana produces an instruction graph for each method that includes both control flow and data flow information.
the data flow information is derived via reachability analysis performed on virtual registers.
field graphs store a list of fields as nodes but by default j itana does not add edges to this graph.
this data can still be used for analysis purposes.
b. supported analysis engines currently j itana supports traditional interprocedural control flow data flow and points to analysis graphs .
in java most function calls are made using a dynamic dispatch mechanism.
therefore knowing the actual type of an object in a pointer variable is essential for any interprocedural analysis.
jitana also supports a points to analysis algorithm inspired by s park a points to analysis framework in s oot .
jitana sinterprocedural control flow analysis includes both direct call edges and virtual call edges in a method graph as shown in figure c .
however the actual target of a virtual call edge cannot be accurately computed without consulting the virtual dispatch tables vtables that are used to support late binding features such as inheritance.
as such our analysis is not sound because it ignores the vtables.
further our analysis is incomplete because it ignores reflection.
these two issues are common among static analysis tools for java.
in terms of data flow analysis jitana supports reaching definitions analysis which is used to generate def use pairs.
the monotone data flow algorithm used in j itana s reaching definitions algorithm is implemented as a generic function thus it can be used to perform other types of data flow analyses such as available expressions or live variable analysis by defining appropriate functors.
it also works on any graph types that model the concepts required for control flow graphs.
system core.dex framework.dex framework2.dex ext.dex conscrypt.dex okhttp.dex core junit.dex android.test.runner.dex android.policy.dex1 superdepth super depth classes.dex parent loader facebook data app com.facebook.katana .apk classes.dex program eb5202dbb54c0efff1c01c5f...baa6.dex.dex program e2ca9fdbaa4e32f97b90b376...baa6.dex.dex program 7feaf7c75a5305b1083a160f...baa6.dex.dexparent loader instagram instagram classes.dexparent loader johnneslite johnneslite classes.dexparent loader a classloader graph.
0 0 t294 public ljava lang object 0 1 t2782 public abstract landroid os asynctask 3 0 t4001 lcom instagram android support camera loadimagetask 1 0 t87 public ljp bio100 android superdepth gamebase httptask b class graph subgraph .
static synthetic landroid os asynctask access landroid os asynctask ljava lang object v private landroid os asynctask finish ljava lang object vdirect1 public final landroid os asynctask iscancelled zvirtual1 protected landroid os asynctask oncancelled ljava lang object vvirtual4 protected landroid os asynctask onpostexecute ljava lang object vvirtual8 protected landroid os asynctask oncancelled vvirtual1 protected volatile bridge synthetic lcom instagram android support camera loadimagetask onpostexecute ljava lang object vsuper protected volatile bridge synthetic ljp bio100 android superdepth gamebase httptask onpostexecute ljava lang object vsuper protected lcom instagram android support camera loadimagetask onpostexecute ljava lang v oid vvirtual2 protected ljp bio100 android superdepth gamebase httptask onpostexecute ljp bio100 android superdepth gamebase taskres vvirtual20 protected final transient varargs landroid os asynctask publishprogress ljava lang object v virtual1 direct c method graph subgraph .
fig.
illustrations of v arious vm graphs the iac analysis used by j itana is similar to the approach used by e picc to initially uncover possible icc connections.
in the first step it searches for potential connections exit and entry points between components and apps this is done by analyzing the code and manifest files.
because j itana analyzes a collection of apps at once all iac connections within that set of apps appear in a single analysis effort.
this is the main goal that apkc ombiner tries to achieve by combining apps.
in the second step when an exit point that can connect to an entry point in another app is uncovered a connecting edge in an iac graph is created.
note that each app in a collection being analyzed represents a node in the graph.
as such two connected apps can have multiple edges between them.
currently j itana does not support interprocedural dataflow analysis.
however once we implement it in j itana dataflow analysis can be performed across these iac edges to increase analysis precision.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iv .
e mpirical ev alua tion as noted in section i to evaluate j itana we empirically studied its efficiency its robustness and its scalability.
we now present each of these studies in turn.
we conducted all three of our studies on a computer with .4g h z core duo and gb ddr3 ram running apple os x el capitan .
a. rq1 how efficient is jitana ?
study setup to address this research question we compare the performance of j itana with the approach of li et al.
described in section ii.
as a reminder their approach randomly selects two apps and uses apkc ombiner to merge them.
the approach then utilizes s oot to produce analysis graphs e.g.
icfg dfg so that more powerful analysis approaches such as icc analysis using e picc o r taint analysis using f low droid can be applied.
work by li et al.
reported that apkc ombiner was able to successfully combine over pairs of real android apps .
we initially considered using these apps for rq1.
however the authors provided no information about these apps except for edabah evaluation and clipstore so it was not possible to find them.
we did investigate edabah evaluation and clipstore and found that they were both released prior to and have not been updated for at least four years.
as such we were unable to use them in our study.
next we collected the most recent top apps august from three different categories in google play as possible experiment objects table iv provides a complete list .
we then attempted to use apkc ombiner to merge these apps.
because apkc ombiner merges two apps at a time we simply tried to find pairs of apps in each category that it could merge.
unfortunately apkc ombiner was not able to merge any pair of apps in any of our three categories.
in some cases it initially appeared to be successful but when we inspected the merged apps they contained errors and their output sizes were too small to be valid.
as such we could not gather any data with which to evaluate the ability of apkc ombiner to handle large apps.
ultimately we resorted to using apps that we discovered that apkc ombiner can operate on.
three of these are part of the droidbench benchmark suite and had previously been used to evaluate apkc ombiner we created the other apps ourselves with the goal of explicitly representing different types of iacs .
the apps we used are small so we can manually identify iac connections that exist among them.
we also know each connection type e.g.
explicit intent implicit intent broadcast receiver and content provider .
in all there are pairs of connections among the apps.
we then verified the iac information by using e picc and ic3.
we refer to this hybrid approach as oracle apkcombiner soot or oas.
in addition to representing various connection types these small apps have the further advantage of being able to be processed by both oas and j itana allowing us to compare the two for efficiency.
5these benchmark apps and additional information about them can be downloaded from ytsutano jitana .we conducted this study using three scenarios.
in study scenario we used apkc ombiner to merge each of the pairs of connected apps and then used s oot to analyze each pair of merged apps to construct the basic program analysis graphs that include cfgs dfgs and icfgs.
we also used jitana to analyze each pair of apps simultaneously.
in study scenario we increased the number of connected apps to three.
in this case we used only the droidbench apps which are already connected in two ways.
we applied apkc ombiner in turn to create two pairs of interconnected apps i.e.
a01and then a12 note that a0and a2are not connected while we applied j itana to the set of three apps simultaneously.
in practice a system under analysis for vulnerabilities might host various combinations of apps and analysts might need to consider all of these combinations.
study scenario reproduces this situation.
we drew seven independent random samples of apps from our benchmark set ensuring that each sample had a randomly chosen number of apps ranging from four to .
we also ensured that each resulting group of apps contained at least four apps that had iac connections.
we also attempted to combine and analyze all apps.
because oas cannot directly analyze an entire group of apps and instead analyzes pairs of apps we again used the information we possessed to determine the iac connections among apps in that group.
we then selected pairs of connected apps for merging by apkc ombiner .
for example one group of six apps included four that are connected as two pairs we used the apkc ombiner to merge these two pairs.
then we used s oot to analyze the two merged apps generating cfgs dfgs and icfgs.
to assess the efficiency of the approach we measured the time required to merge the pairs of apps and then generate analysis graphs for the merged pairs.
currently iac analysis in j itana identifies connections through explicit intents implicit intents and broadcast receivers.
basically j itana identifies the potential iac requests for each app and analyzes intent filters to identify iac entry points for each app.
we also implemented an analysis to identify iac connections through a content provider.
given the foregoing we also evaluated two performance aspects of jitana in scenario .
first we wished to observe the costs of the two approaches subsequent to the generation of iac connections.
this requires the two approaches to operate on the same sets of connections.
thus for j itana we begin with the same groupings and iac information that had been determined for use with oas.
in this case however j itana then simultaneously analyzes all the apps in a group instead of just the apps identified by the oracle as connected.
this results in the generation of the same iac graph as provided and the same analysis information as oas.
second we also let j itana compute and construct iac graphs on its own.
in this case each reported time includes the additional time required to compute iac connections and construct the iac graph based on implicit and explicit intents and the time required to simultaneously analyze all the apps.
to assess the efficiency of j itana in this case we measured authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii rq1 analysis data for oas and j itana for pairs of apps p0 p13 scenario and droidbench scenario reported time sec p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 droidbench oas .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jitana .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
the time required to analyze all of the apps in each group produce the iac graph for each group and simultaneously analyze apps.
for scenario time does not include iac analysis since the apps are known to be connected.
for scenarios and times are reported both with and without iac analysis.
results table ii reports our results relative to the first two scenarios in which we investigated rq1.
the table lists the times in seconds required by oas and j itana to analyze pairs of apps in scenario columns p0 p13 and the three connected apps from droidbench in scenario column droidbench .
in the case of scenario in all cases the times required by j itana were substantially less than the times required by oas.
the performance speed ups ranged from times to times with an average of .
in the case of scenario we used apkc ombiner to merge pairs of apps.
each merged app is then analyzed by soot .
the reported time is the sum of the analyses required over the pairs of apps analyzed.
in this scenario j itana achieved a performance speed up of times.
where scenario is concerned table iii reports the times taken by both systems to analyze larger groups of apps.
each row presents data on a particular configuration of apps used to evaluate oas and j itana .
the first column in the table reports the number of apps in a configuration.
the second column reports the number of pairs of connected apps in the configuration this indicates the number of pairs of apps that oas needs to combine.
the third column reports the time required by oas to combine the pairs of apps and for s oot to analyze each resulting merged apps.
the fourth column reports the time required by j itana to analyze all the apps in each configuration.
the fifth column includes the time required by j itana to analyze all the apps in each configuration and compute the iacs among them.
table iii rq1 analysis data for oas and j itana scenario of apps of connected apps oas jitana jitana iac mb mb sec sec sec .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
as the data shows with or without iac j itana achieved performance speed ups ranging from times to times.
when we used j itana to perform iac analysis it incurred negligible overhead.b.
rq2 how robust is jitana ?
study setup to answer this research question we used real world applications available for free download from the google play store the same set we had initially attempted to use to answer our first research question as noted in section iv a .
our selected apps were all on the top chart during august .
we focused on three categories of apps due to their popularity and as groupings of apps we chose apps from the same category because they are more likely to share components rendering iac connections more complex.
first we chose apps from the social network category including facebook snapchat and instagram apps from the games category including pok emon go suicide squad and nba live .
the last category is miscellaneous .
notable apps in this category include spotify google photos pandora and the top seven additional apps in the top chart that do not belong to the first two categories.
table iv lists all of the apps in each category.
table iv apps downloaded from google play for rq2 category listing of apps social network facebook snapchat instagram pinterest twitter oov oo textnow pof free dating tumblr tango games pok emon go slither.io rolling sky subway surfers color switch roblox suicide squad nba live farm heros super saga geometry dash miscellaneous messenger y outube music pandora spotify wish google photos news master topbuzz mercari marco polo walkie talkie remind as previously mentioned section iv a apkc ombiner was unable to combine any of these real world apps in a pairwise fashion.
as such we could not use it to produce any merged apps for icc analysis.
next we turned our focus to e picc and ic3 and attempted to use them to search for entry exit points in each of these large apps so that we can compare the results produced by these systems with those produced by j itana .
unfortunately both e picc and ic3 were unable to return results for these large apps in the three categories.
we also encountered a few instances in which both systems simply crashed.
one possible reason for their failures involves failures during code retargeting which is a problem that has been previously reported .
as a second possible reason our experiment objects are from a different generation of apps than those previously used to evaluate these systems prior apps used were from and the systems might simply not be able to handle the characteristics of this newer generation of apps.
finally because both systems achieve their precision through the use of the ide framework and a precise points to analysis in s oot it is also possible that analysis graphs in these apps may be too complex to be feasibly processed.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we next used j itana to simultaneously analyze all ten apps in each category to produce analysis graphs the same contexts as those used in rq1 compute iac connections and generate the iac graph for each category.
we measured the time required to complete this process.
unlike in rq1 we did not provide iac information prior to analysis.
results table v reports results relative to rq2.
the first column indicates the configuration used to evaluate j itana that is it reports the number of apps being simultaneously analyzed.
the second column reports the combined size of the apks.
for example the first row of the social network category includes two apps facebook and textnow .
the combined size of the two apks is mb.
the third column reports the number of classes that have been loaded by clvm and analyzed by j itana .
the last column reports the time by needed by j itana to analyze all the apps in each collection.
table v rq2 analysis data for j itana of apps size of apks of loaded time mb classes sec social network .
.
.
.
.
game .
.
.
.
.
miscellaneous .
.
.
.
.
as the data show j itana successfully analyzed between two and ten apps in each of the three categories.
it also processed large amounts of code ranging from mb to over mb.
the number of classes loaded and analyzed by jitana exceeded classes in several cases.
the analysis times range from seconds to seconds.
note that these times also include the time required to compute iacs.
c. rq3 how scalable is jitana ?
study setup to answer this research question we applied j itana to three non trivial real devices asus nexus 7s using different numbers of installed apps.
these devices communicate with j itana through usb ports allowing it to query and download the apks installed on each device directly.
j itana then simultaneously analyzes all of the apps on each device to build analysis contexts compute the iac connections among the apps and generate the iac graph.
in conducting this study we are considering an increasingly common scenario in which organizations allow their employees to bring their own devices to work.
in this scenario security analysts working for the organization may need to vet employee s devices to detect whether there are any connections that may allow existing apps to communicatewith the company s own apps directly or indirectly through a shared component .
since these devices would most likely have different apps installed on them the analysis must be done at speed as employees check in their devices.
we configured our three devices to have apps only the default apps and system services that come with a new installation of android .
.
apps and apps respectively with the second and third devices including those on the first and second devices respectively.
these additional apps include the apps used to investigate rq2 apps installed on the second device and additional apps installed on the third device .
we then measured for each device the times required to pull the apps from the device to the workstation running jitana to perform simultaneous analysis to build analysis contexts to compute iac connections and to produce the iac graph for the device.
note that no existing approaches are capable of performing this task at this scale thus in this study we cannot compare j itana to any baseline approach.
results table vi reports our results relative to rq3.
columns provide data on the device configuration used to evaluate the scalability of j itana including the number of apps the amount of disk space needed to store these apps on the device the number of classes and the number of methods.
other columns report the number of apps that we found to be connected using intents and content providers and the amount of time needed to analyze the entire device for iacs and construct analysis graphs.
table vi rq3 analysis data for j itana using three devices with different numbers of apps id o f total o f o f apps apps with time apps size classes methods with content sec mb 1k 1k intents providers .
.
.
.
.
.
.
.
.
as the data shows j itana was able to analyze a device with apps in about minutes device .
for the two devices with smaller numbers of apps devices and it was able to analyze all apps on each device in about minutes and minutes respectively.
for device j itana loads and analyzes over classes which amounts to about .
gb of code.
it is also worth noting that each app on a device has a tendency to connect with another apps.
the default apps use only intents for iacs but other downloaded apps use content providers in addition to intents for iacs.
we also observe that apps use intents more often than content providers.
in cases in which an app uses both intents and content providers the app is reported in both columns and .
this behavior clearly emphasizes the need to analyze interacting apps efficiently.
d. threats to v alidity the primary threat to external validity in this study involves the object programs utilized.
in our first study we have studied small benchmark programs to provide an equal chance for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
both oas and j itana to run successfully so that we can compare the efficiencies of the two systems however the inability of oas to handle larger cases mandated this.
we also employ complex real world apps including facebook instagram twitter pandora and pok emon go .
this is to apply our system to real world scenarios representative of those that engineers and analysts are facing.
a second threat involves the representativeness of our techniques for identifying iac connections.
in the case of our small benchmark apps we were able to identify all the iac connections that exist among the apps.
for larger apps we attempted to use the state of the art approach ic3 to first produce iac analysis results to use in our study.
however ic3 was unable to analyze several real world apps.
as such we used our iac analysis implementation to provide the apps that oas needs to combine.
for the apps that ic3 and j itana can analyze for iacs we also compare the results to ensure that for the types of iac connection that we can support our results do not contain any false negatives.
false positives are expected as our analysis is not as precise as that of ic3.
the primary threat to internal validity involves potential errors in the implementations of j itana and the infrastructure used to run oas and j itana .
to limit these we extensively validated all of our tool components and scripts.
the primary threat to construct validity relates to the fact that we study efficiency measures relative to applications of jitana but do not yet assess whether the approach helps engineers address dependability and security concerns more quickly than current approaches.
v. d iscussion one interesting observation from table iii is that the amount of time needed by j itana to perform text processing for iac analysis is negligible.
parsing an app for intents intent filters and content providers represents the first step in the iac analysis process.
existing approaches such as e picc ic3 and amandroid use the commonly available android a pktool to parse these xml files for analysis.
our experience has shown that a pktool is inefficient because its goal is to provide human comprehensible results.
instead we developed our own tool to directly parse the desired information which is typically stored in binary format.
this allows j itana to perform string processing with low overhead.
comparing the string processing times between a pktool and j itana w e find that j itana was more than times faster.
with respect to precision j itana currently yields iac analysis results that often contain more false positives than results produced by e picc and by ic3 which is an improvement over e picc .
this is because a specific request can be mapped to multiple intent filters.
e picc overcomes this problem by employing a sophisticated interprocedural dataflow analysis technique to reduce false positives.
ic3 further improves the precision of e picc by employing composite constant propagation to reduce the number of identified intent filters by including uri information see section vi for more information .on the other hand both e picc and ic3 are icc analysis tools so in order for them to be applicable in the iac context the use of apkc ombiner is necessary.
as we have shown apkc ombiner is not scalable or robust so techniques based on it would have limited applicability.
j itana does not suffer from this scalability issue.
we are now working to extend jitana to also support interprocedural dataflow analysis and more complex constant propagation so that we can increase the precision of our iac analysis.
we further investigated the impact of false positives in our results and found that in most cases j itana uncovered real connecting edges as well as false positive edges between pairs of apps.
therefore the final results with respect to app connectivity are still accurate.
however we also found some instances in which false positives led j itana to mistakenly identify connections between some pairs of apps.
when we analyzed five apps and apps simultaneously j itana mistakenly identified a pair of apps in each case as having an iac connection.
for the time being if higher precision can be sacrificed for higher efficiency and scalability j itana can already be used to determine iac connections.
in rq2 and rq3 we also observed an interesting strategy that apps such as facebook employ.
to reduce the size of the downloaded apk facebook generates additional classes at runtime.
these classes appear in multiple additional dex files.
to capture them we utilized the dynamic analysis capability of j itana to monitor classes being loaded.
in all j itana ended up analyzing classes while s oot analyzed only classes in facebook .
the times required to analyze facebook for s oot and j itana were .
and .
seconds respectively.
this motivates the need for an efficient hybrid program analysis system to capture these additional classes because static analysis alone including j itana in static analysis mode only would have missed them.
finally as first noted in section iv c2 imagine a company that allows its employees to bring their own devices to work.
it is conceivable that there is a team of analysts that need to vet devices before admitting them to the company s network or installing the company s apps.
when a device is submitted for vetting an analyst may need to observe how some of the key apps or services are used by other existing apps on the device.
perhaps there is a malicious app that can compromise data sent through a common service.
a recent study indicates that a smart mobile device on average contains about apps.
based on the performance reported in table vi an analyst can use j itana to perform analysis very quickly as part of an employee check in.
efficient analysis such as this would also allow security checks to be performed more frequently.
vi.
r ela ted work in this section we discuss other research efforts that are related to this work.
these efforts include program analysis frameworks for android and detection of iac connections.
over the past few years there have been several approaches introduced to analyze systems for iccs .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
epicc is a program analysis framework that uses interprocedural data flow and points to analysis to uncover icc connection points.
on average icc analysis times for a real world apps range from seconds for apps with less than to seconds for apps with classes or more.
our approach however can analyze an app with approximately classes in less than two seconds and an app with approximately classes in about seconds.
ic3 is an improvement over e picc .
it conducts uri analysis for content providers and multi v alued composite mvc constant propagation.
in mvc constant propagation analyzers try to target complex objects that may have multiple fields.
a mandroid performs flow and context sensitive points to analysis.
this can help with the construction of precise interprocedural control flow graphs icfgs and interprocedural data flow graphs idfgs .
the approach builds a data dependence graph ddg of the app from an idfg.
iccta goes a step further by taking the icc information and then performing taint analysis to detect possible malicious flows across components .
in terms of performance ic3 can analyze a corpus of real world android apps downloaded in for icc connections in about hours an average of seconds per app.
because our framework does not yet support mvc we cannot compare our performance with ic3 however we leave this evaluation as future work.
ic3 has also been used as the base system for further optimization through probabilistic models.
octeau et al.
apply probabilistic models to further resolve intent and intent filter matching to reduce false positives.
first ic3 is used to perform icc analysis.
intent resolution is then used to further reduce icc connections.
octeau et al.
conducted an evaluation using a collection of apps and malware samples .
they did not report the time required by ic3 to initially analyze these apps but the intent resolution time was minutes.
note that the intent resolution process is orthogonal to ic3 and can also be used to increase the precision of icc results produced by j itana .
taint analysis has been used to verify iac connections and detect potentially suspicious connections.
one such example is provided by i ccta .
i ccta is used to support iac analysis.
e picc or ic3 is first used to perform icc analysis on each app step and analyze for the connections that can occur across apps step .
apkc ombiner is then used to combine the connected apps so that s oot can reconstruct the analysis graphs and f low droid can perform taint analysis on the resulting app step .
d idfail was introduced at about the same time as i ccta.
it also uses flow droid for taint analysis and e picc for icc and iac detection.
however d idfail has been created specifically to detect connections among a set of apps so instead of combining apps in a pairwise fashion intra app analysis produces a set of outputs for each application that include a manifest file e picc output and f low droid output.
it then analyzes these output files to uncover iacs.
again these approaches perform their initial analysis within the boundary of an app.our work differs from the current iac analysis approaches in the following ways.
first while our approach also performs analysis of each app in a collection we perform these simultaneously .
a typically approach needs to perform intraapp analysis ntimes for a collection consisting of napps.
our approach performs its analysis just once on all napps.
second by this we preserve analysis graphs generated during the process so that richer analysis techniques such as points to analysis can be conducted on our analysis graphs.
as such our approach is more efficient in the context of analyzing interacting apps than current approaches such as iccta that require the previously mentioned three steps.
this is because our intra app analysis is done in parallel instead of sequentially data propagation can be done across apps naturally instead of having to create some forms of outputs that must be composed for iac analysis our approach eliminates the analysis graph reconstruction process altogether.
as shown in this paper this last step in the current state of theart approach to combine apps is inefficient and non scalable.
vii.
c onclusion we have presented j itana a program analysis framework for android that is capable of analyzing multiple apps simultaneously.
we show that j itana facilitates the analysis of android apps for inter app communications an analysis that can help engineers and security analysis diagnose and address faults and vulnerabilities related to inter app interactions.
we also show that j itana is more efficient than a state of the art approach for analyzing inter app connections and far more robust and scalable than that approach.
there are many activities that we plan to conduct to improve jitana s performance and capabilities.
first we are creating an interprocedural data flow analysis framework so that we can improve the precision of our iac analysis as well as provide a foundation by which other researchers can develop analysis approaches.
because j itana generates all analysis graphs in bgl compliance forms we plan to develop approaches to persist prior analysis results and off load analysis tasks to high performance clusters.
currently j itana does not analyze native code.
one possible extension is to create an approach to convert arm binary code to bgl compliance graphs.
such graphs can then be appended to j itana graphs so that analysis can flow from managed domain to native domain and vice versa.
these are just a few ideas that we have for j itana .jitana is publicly available for download at ytsutano jitana .
acknowledgment this material is based on research sponsored by darpa and maryland procurement office under agreement numbers fa8750 and h98230 c respectively.
any opinions findings conclusions or recommendations expressed here are those of the authors and do not necessarily reflect the views of the funding agencies or the u.s. government.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.