semantic relation based expansion of abbreviations yanjie jiang school of computer science and technology beijing institute of technology beijing china jiangyanjie bit.edu.cnhui liu school of computer science and technology beijing institute of technology beijing china liuhui08 bit.edu.cnlu zhang key laboratory of high confidence software technologies peking university ministry of education beijing china zhanglu sei.pku.edu.cn abstract identifiers account for of source code in terms of characters and thus the quality of such identifiers is critical for program comprehension and software maintenance.
for various reasons however many identifiers contain abbreviations which reduces the readability and maintainability of source code.
to this end a number of approaches have been proposed to expand abbreviations in identifiers.
however such approaches are either inaccurate or confined to specific identifiers.
to this end in this paper we propose a generic and accurate approach to expand identifier abbreviations.
the key insight of the approach is that abbreviations in the name of software entity ehave great chance to find their full terms in names of software entities that are semantically related to e. consequently the proposed approach builds a knowledge graph to represent such entities and their relationships with e and searches the graph for full terms.
the optimal searching strategy for the graph could be learned automatically from a corpus of manually expanded abbreviations.
we evaluate the proposed approach on nine well known open source projects.
results of our k fold evaluation suggest that the proposed approach improves the state of the art.
it improves precision significantly from to and recall from to .
evaluation results also suggest that the proposed generic approach is even better than the state of the art parameter specific approach in expanding parameter abbreviations improving f1score significantly from to .
ccs concepts software and its engineering maintaining software .
keywords abbreviation expansion knowledge graph software quality acm reference format yanjie jiang hui liu and lu zhang.
.
semantic relation based expansion of abbreviations.
in proceedings of the 27th acm joint european corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
introduction identifiers are symbols used to identify uniquely a program entity in the source code .
according to the empirical study conducted by deissenboeck et al.
identifiers account for the majority of source code in terms of characters.
consequently the quality of such identifiers is crucial for the readability and maintainability of software applications .
identifier abbreviations are popular .
developers often use a short abbreviation to replace a long term or a sequence of terms.
for example they often use e to represent exception .
however such abbreviations have severe negative impact on program comprehension and ir based software maintenance activities e.g.
concept location software clustering and recovery of traceability links .
to minimize the negative impact of abbreviations a number of approaches have been proposed to expand abbreviations in source code.
an intuitive and straightforward approach is to look up dictionaries e.g.
generic english dictionaries.
for example such approach may expand ctx into context because context is a dictionary word and dropping some characters from context results in ctx .
such dictionary based approaches are simple and straightforward and thus are widely employed.
however there often exist multiple matching dictionary words for a single abbreviation especially short abbreviation and it is challenging to select the correct one from them.
to improve the accuracy researchers exploit the contexts of abbreviations e.g.
words within the same document or the same project.
exploiting such contexts has greatly improved the accuracy.
however the exploited contexts are often coarse grained and ignore semantic relations which has severe negative impact on the performance of abbreviation expansion .
to further improve the performance in this paper we propose an automatic and generic approach to expanding abbreviations in identifiers.
the key insight of the approach is that for an abbreviation in the name of software entity e it is likely to find its full expansion in names of software entities that are semantically related to e. the rationale is that semantically related entities are likely to share some common concepts and thus their names may contain some common terms.
another characteristic of the proposed approach is that it is learning based.
from a corpus of abbreviations and their full terms the proposed approach learns automatically to prioritize matching heuristics and semantic relations.
to the best of our knowledge it is the first learning based approach to expanding identifier abbreviations.
esec fse august tallinn estonia yanjie jiang hui liu and lu zhang we evaluate the proposed approach on nine well known opensource projects.
results of our k fold evaluation suggest that the proposed approach significantly outperforms the state of the art generic approaches.
it improves precision from to and recall from to .
evaluation on parameter abbreviations also suggests that the proposed generic approach outperforms the stateof the art parameter specific approach in expanding parameter abbreviations improving f1score significantly from to .
the paper makes the following contributions a generic and accurate approach to expanding abbreviations in identifiers.
the proposed approach differs from existing ones in that it exploits the semantic relations between software entities to expand identifier abbreviations.
to the best of our knowledge it also the first learning based approach to expanding identifier abbreviations.
a prototype implementation and initial evaluation of the proposed approach.
evaluation results suggest that the proposed approach significantly improves the state of the art.
the rest of the paper is structured as follows.
section introduces related research.
section proposes the approach to expand abbreviation in identifiers.
section presents an evaluation of the proposed approach on well known open source projects.
section provides conclusions and future work.
related work .
expansion of identifier abbreviations expansion of identifier abbreviations is to turn abbreviations in identifiers into dictionary words.
various approaches have been proposed to expanding identifier abbreviations.
abbreviation dictionaries are frequently employed in abbreviation expansion .
an abbreviation dictionary contains a list of well known abbreviations and their corresponding full terms.
abbreviation expansion based on abbreviation dictionaries often high ly accurate.
however such abbreviation dictionaries are often constructed manually which significantly limits the size of such dictionaries .
as a result approaches that are completely based on such dictionaries can expand only a small number of abbreviations resulting in low recall.
generic english dictionaries are also employed for abbreviation expansion .
for a given abbreviation generic dictionary based approaches gd based approaches for short compare it against each term in the dictionaries and return those that match the abbreviation according to predefined rules.
the advantage of looking up expansion from generic english dictionaries is twofold.
first such dictionaries are ready for reuse and developers do not have to construct such dictionaries again.
second such dictionaries contain almost all possible english terms and thus in most case we can find matching terms for given abbreviations.
because generic dictionaries are much larger than abbreviation dictionaries gd based approaches can expand more abbreviations.
however it is quite often that for a given abbreviation there are a large number of matching terms from generic english dictionary resulting in great challenge in selecting the correct one.
to this end more advanced approaches look for full terms from the context of abbreviations .
such contexts include comments and enclosing methods documents projects .
corazza et al.
lawrie et al.
and madani et al.
suggest looking for full terms from comments of source code.
however developers rarely write comments.
lawrie et al.
suggests searching the enclosing methods whereas hill et al.
propose a more complex approach to search enclosing methods enclosing classes and enclosing projects in order.
abdulrahman alatawi et al.
leverage bayesian unigrambased inference model to find full terms from source code.
to the best of our knowledge abdulrahman alatawi et al.
are the first to leverage natural language models in abbreviation expansion.
evaluation results suggest that the natural language models are highly accurate.
these approaches have significantly improved the performance of abbreviation expansion.
however the exploited contexts are often coarse grained and ignore semantic relations which has severe negative impact on the performance of abbreviation expansion.
besides the generic approaches introduced in the preceding paragraphs jiang et al.
propose a parameter specific approach to expand parameter abbreviations only.
by focusing on such a special subset of identifier abbreviations the approach improves the performance both precision and recall significantly.
however it could not be applied to identifiers other than parameters.
different matching algorithms are employed to search for potential expansions from given strings sequences of words .
apostolio et al.
propose a matching algorithm where word term is regarded as a potential expansion of abbreviation abbr ifabbr is a subsequence of term .
if there are multiple potential expansions from given source strings further strategies should be used to select one from potential expansions.
lawrie et al.
make suggestions only if the given abbreviation has a single potential expansion and simply ignores the cases where multiple potential expansions are retrieved.
in contrast hill et al.
and carvalho et al.
sort such potential expansion according to their frequency and recommend the top one.
lawrie et al.
choose the one who has the highest lexical similarity with the given abbreviation.
guerrouj et al.
and corazza et al.
employ graph based matching algorithms.
nodes of the graph represent letters and edges represent transformation costs.
based on the graph they search for the shortest path from the initial letter of the abbreviation to anyone of its potential expansions with dijkstra algorithm.
the one with the shortest path is recommend as the most likely expansion.
jiang et al.
propose a series of heuristics to search for potential expansions.
in case where multiple potential expansions exist they select the shortest one.
the proposed approach differs from existing approaches in that it exploits the semantical relationship among software entities.
it also differs from existing approaches in that it is the first learning based approach to abbreviation expansion.
.
segmentation of identifier names the segmentation of identifiers is to decompose identifiers into sequences of soft words .
it is closely related to the expansion of abbreviations because the result of segmentation may significantly influence the process of expansion.
if identifiers follow some common conventions such as camel case convention the segmentation of such identifiers would be quite straightforward.
for examples we can segment identifiers 132semantic relation based expansion of abbreviations esec fse august tallinn estonia source code information extraction manual expansion rule learning graph construction information extraction graph construction abbr automatic expansion abbr expansions knowledge graph abbr knowledge graph source code rules abbr expansions figure overview of the proposed approach according the positions of some characters such as underscores and capital characters .
however there still exist some identifiers that do not follow such naming conventions.
to this end researchers have proposed some complex and effective approaches to segment such identifiers.
feild et al.
segment identifiers into constituent parts based on three word lists a list of dictionary words a list of well known abbreviations and a list of stop words.
first they segment a given identifier into a sequence of hard words according to the positions of some characters second for each of the resulting hard words if it appears in one of the word lists it is regarded as a single soft word.
otherwise they search for the longest prefix or suffix of the hard word that appears in one of the three lists.
enslen et al.
segment identifiers into sequences of terms based on two frequency tables program specific frequency table and global frequency table.
based on the two tables this approach ranks possible splits of an identifier based on a scoring function.
lawrie et al.
proposed an approach named gentest and carvalho et al.
proposed an approach named idsplitter .
compared with the approach proposed by enslen et al.
they employ different scoring functions gentest computes scores with a series of metrics e.g.
number of words and co occurrence and idsplitter simply counts the length of each term.
guerrouj et al.
proposed an approach named tidier and an enhanced version named tris .tidier finds the best splitting based on a greedy search algorithm and the string edit distance.
tris handles the segmentation of identifiers as an optimization problem and compares different segmentations and selects the one with the smallest cost as the result of segmentation.
graph based algorithms are also employed for the segmentation of identifiers.
corazza et al.
employ an approximate string matching techniques called baeaz yates and perleberg to segment identifiers.
ashish sureka employs a recursive algorithm to segment camel case identifiers.
it splits an identifier into two substrings noted as slef t andsri ht.
the optimal segmentation position is found based on a complex scoring function.
.
knowledge graph to facilitate information revival google proposed knowledge graph in may .
knowledge graph is a graph presenting entities and their semantical relations.
vertexes of knowledge graphs represent entities whereas edges present relations between the entities .
we may fuse information from a variety of data sources to construct comprehensive semantic network .
by constructing knowledge graphs we can analyze complex relations between entities and thus improve the quality of services in different fields e.g.
recommender systems and search engines .
in the field of software engineering knowledge graphs have been successfully employed to facilitate bug resolution to refine traceability links and to improve api caveats accessibility .
wang et al.
construct a bug knowledge graph based on their self constructed bug knowledge.
in the bug knowledge graph entities are descriptions of bugs commits the class names and names of relevant developers there are different edges between these entities which represent different relations.
developers can search the bug knowledge graph to find accurate and comprehensive information of a software bug issue.
du et al.
construct a vulnerability knowledge graph.
they firstly build cve ontology maven ontology and github ontology and then match these ontologies to form this vulnerability knowledge graph.
it facilitates the vulnerability spreading analysis.
li et al.
construct an api caveats knowledge graph.
they extract api caveat sentences from api documentations and link these sentences to api entities to form this api caveats knowledge graph.
it improves the api caveats accessibility and developers can avoid many unexpected programming errors.
all such successful applications of knowledge graphs suggest that knowledge graph has great potential in resolving software engineering tasks.
this is one of the reasons why the proposed approach employs knowledge graphs.
approach in this section we present an automatic approach to expanding abbreviations in identifiers.
an overview of the proposed approach is presented in section .
and the details are presented in the following sections.
133esec fse august tallinn estonia yanjie jiang hui liu and lu zhang .
overview fig.
presents the overview of the proposed approach.
the proposed approach is divided into two phases training phase the upper part of fig.
and testing phase the lower part of fig.
.
in the training phase the proposed approach learns from a corpus of training data abbreviations and their manually labeled full terms which results in a sequence of rules for abbreviation expansion.
the training phase works as follows from a corpus of source code it extracts identifiers and developers manually expand abbreviations within the extracted identifiers.
for each of the identifiers containing abbreviations it builds automatically a knowledge graph to represent identifiers that are semantically related to it.
based on the knowledge graphs and the manual expansion it employs an algorithm to learn a set of rules for abbreviation expansion.
with the resulting rules learned in the training phase the proposed approach expands abbreviations automatically in the testing predicting phase as follows first it retrieves identifiers that contain abbreviations from the given application source code .
second it constructs a knowledge graph for each of the resulting identifiers.
finally it leverages the expansion rules learned in the training phase to expand the abbreviations automatically.
details of the proposed approach are presented in the following sections.
.
software entities and semantic relations identifiers are symbols used to identify uniquely a program entity in the source code.
such entities include classes methods variables parameters and fields.
we represent all entities within a software application as a set e. the proposed approach is based on the assumption that abbreviations within the name of an entity eihave great chance to find their full terms from names of entities that are semantically related toei.
consequently to expand abbreviations in the name of ei we should retrieve software entities notated as se ei that semantically related to ei.
software entity ejis added to se ei if it is connected to eiin one or more of the following ways inclusion.
software entity eiis directly included by ej or the reverse.
for example if eiis a class all methods and fields within this class should be added to se ei .
ifeiis a method its enclosing class should be added to se ei .
assignment.
eiis assigned to ej or the reverse.
the assignment includes not only the assignment operator but also assignments in broad sense e.g.
assignment of arguments to parameter.
inheritance.
software entity eiis the superclass or subclass of ej.
typing.
software entity ejdefines the type of ei.
commenting.
although comments in source code dose not influence the semantics of programs they are rich source of full terms.consequently we add comments explicitly associated with eitose ei as well.
for example if eiis a method we include thecomment that precedes the signature of ei but exclude comments within the method body.
.
knowledge graph of software entities for software entity e we automatically create a knowledge graph to represent its semantically related entities i.e.
se e as well as their semantic relationship with e. a knowledge graph for software entity ecould be presented as a typed directed graph e v e e e t e where v e is a set of nodes e e presents directed edges between nodes and t e defines the types of the edges in e e .
we also have v e se e e e e e v v se e because the knowledge graph presents the relationship between e and its semantically related entities i.e.
se e .
types of the edges are defined at finer granularity than those in section .
.
for example the inclusion defined in section .
is further classified into class method method class class field fieldclass method variable variable method method parameter parameter method and variable class .
.
segmentation of identifiers to extract abbreviations from identifiers we split identifiers into sequences of soft words.
based on the assumption that identifiers follow the widely used camel case convention we split such names as follows first we split an identifier into a sequence of hard terms according to underscores and numbers.
for example identifier v trans2 is split into v trans .
second we split an identifier or a hard term resulted from the preceding segmentation into a sequence of terms according to capital letters.
every capital letter is taken as a segmentation flag.
an exception is the consecutive capital letters followed by lowercase ones e.g.
urivalue .
in this case only the last capital letter is employed as a segmentation flag.
consequently urivalue is split into uri and value .
each of the resulting soft words is taken as an abbreviation if it does not appear in a generic english dictionary that is composed of full terms only.
.
heuristics for directed expansion for an given abbreviation notated as abbr within the name of an entity ei the proposed approach should try to find their full terms from names of entities that are semantically related to ei noted as se ei .
while section .
discusses how the proposed approach decides the order in which entities in se ei should be tried this section presents a sequence of heuristics noted as sh h1 h2 h3 to find full terms of abbr from the name of a given entity ej se ei .
such heuristics were proposed by jiang et al.
and full explanations are available on their paper.
however for the sake of integrity of this paper we give a brief introduction to such heuristics here.
134semantic relation based expansion of abbreviations esec fse august tallinn estonia h1 acronym to replace a sequence of full terms in identifiers and thus to shorten the identifiers developers often coin abbreviations by concatenating the initial characters of such terms .
for example they may coin tf to represent transformerfactory .
based on this observation the first heuristic h1searches full terms from identifier idjfor abbreviation abbr as follows first idjis segmented into a sequence of terms notated as t. second the initial characters of terms in tare concatenated and the resulting string is represented as acr.
ifabbr is identical to acr case insensitive terms in tare returned as the full terms for abbr .
h2 prefix to shorten an identifier developers often replace a lengthy term with a prefix of it.
a well known and widely used example is str that is frequently employed to represent string .
based on this observation the second heuristic h2searches full terms from identifier idjfor a given abbreviation abbr as follows first it divides idjinto a sequence of terms.
second for each term noted as t in the sequence this heuristic compares tagainst abbr to test whether abbr is a prefix of it.
if yes term tis returned as a potential expansion of abbr .
in case where the heuristic retrieves multiple potential expansions for the same abbreviation it selects the shortest one.
h3 dropped letters dropping letters from lengthy terms is another way to coin abbreviations.
for example we may represent index with idx by dropping letters n and e .
such abbreviations are often called dropped letters .
based on this observation the third heuristic h3searches full terms from identifier idjfor a given abbreviation abbr as follows first the heuristic divides idj into a sequence of terms noted as t. second it tests whether abbr is a dropped letters of any terms from t. if yes such terms are marked as potential full terms.
in case where the heuristic retrieves multiple potential expansions for the same abbreviation it selects the shortest one.
.
creation of training data the proposed approach is learning based and thus high quality training data are indispensable.
we create training data as follows.
first we download a corpus of source code from github.
second from the downloaded source code we randomly extract a number of abbreviations and represent such abbreviations as a list abbrlist abbr e1 abbr e2 ... abbr n en where abbr iis an abbreviation contained in the identifier of software entity ei.
third we manually expand each of the abbreviations inabbrlist .
notably to reduce bias and inaccuracy we need a group of developers to expand such abbreviations.
they should discuss and vote if necessary to reach an agreement on each of the expansion.
if they fail to reach an agreement on an abbreviation abbr i we should exclude this abbreviation from further analysis.
the results of the manual expansion are represented as abbrexpans abbr i expan i abbr i abbrlist where expan iis the full expansion of abbr i. finally we construct a knowledge graph i as specified in section .
for each software entity eithat is involved in abbrlist .
we also associate the knowledge iwith the software entity eiby a mapping f ets kg where ets is the involved software entities and kgare createdknowledge graphs.
as a result we present the training data as trdata abbrexpans f .
rules for expansion as specified in section .
and section .
for abbreviations from the name of software entity e the proposed approach should search for their full terms on the knowledge graph of e. we employ an expansion rule r e to guide the abbreviation expansion.
the rule searching strategy is essentially a sequence of search actions r e a1 a2 .
.
.
an where aiis a search action.
according the expansion rule r e we should search for full terms according to the first search action a1.
if fail we turn to the next action and the followings if needed until we succeed or no more actions are available.
a search action is composed of a source and a matching heuristic ai sj hk sj sr e sr e t e dict hk h1 h2 h3 where t e as specified in formula defines the types of the edges in the knowledge graph of e dict represents common abbreviation dictionaries and sr e represents all potential source for the search actions.
sjspecifies what kind of edges or abbreviation dictionary should be exploited whereas hkspecifies which of the matching heuristics defined in section .
should be adopted.
for example a search action parameter method h1 suggests that we should employ heuristic h1 acronym to find full terms from the name of the enclosing method.
the maximal number of search actions for element eequals sr e where sr e is the size of search space.
.
learning rules as specified in section .
there is a large number sr e of search actions for element e. to specify the expansion rule r e for this element the key is to determine the order in which different search actions should be tried.
to this end in this section we propose an algorithm to sort different search actions so that the most fruitful actions are tried first.
based on training data trdata as defined in formula we learn to sort search actions for eas follows.
as defined in equation abbrlist contains all abbreviations as well as their associated software entities.
from the list we retrieve software elements as well as associated abbreviations that are of the same type as e. for example if eis a method we retrieve methods only from the list.
the resulting list is noted as abbrlist e abbr x1 ex1 .
.
.
abbr xm exm we apply each of the possible search actions to expand the abbreviations in abbrlist e .
135esec fse august tallinn estonia yanjie jiang hui liu and lu zhang we sort all of the possible search actions according to their priority in descending order that is defined as follows priorit y ai e abbrlist p ai e abbrlist e e t p ai e abbr list e where aiis a search action tp ai e abbrlist e is the number of abbreviations in training data abbrlist e that are successfully expanded by action ai.p ai e abbrlist e is the precision of the expansion guided by aion training data abbrlist e .
the resulting sequence of the possible search actions is taken as the expansion rule r e .
.
automatic expansion algorithm abbreviation expansion input abbr abbreviation to be expanded e associated software entity e knowledge graph of e r e expansion rule for e output expan full expansion of abbr for each ainr e do names retrieveidentifiers e e a.s expans for each name innames do potentialexpan getexpansions abbr name a.h expans expans potentialexpan end for ifexpans null then continue else expans sortandselect expans return expan end if end for return null as suggested by fig.
the last step of the proposed approach is automatic expansion that expands abbreviations automatically based on learned expansion rules.
the algorithm of automatic expansion is presented in algorithm .
the input of the algorithm is an abbreviation abbr its associated software entity e the knowledge graph e and the learned expansion rule r e .
the output is the resulting full expansion of the abbreviation abbr .
the algorithm works as follows first it retrieves the first search action afrom r e line second according to the edges specified by the a.s it retrieve identifiers names of entities that are semantically related to e line third for each identifier in names it retrieves full expansions forabbr according to matching heuristic a.h and appends the resulting expansions to dataset expans lines fourth if the expansion guided by action afails i.e.
expans nu ll it tries the next action in r e lines and begins the next iteration.
otherwise it goes to the next step from all of the potential expansions in expans it selects the one with the highest frequency line .
that is if exp 1appears 3times in expans whereas exp 2appears twice exp 1is preferred.
ifexp 1andexp 2have the same frequency the shorter one is selected.
if exp 1andexp 2share the same frequency and the the same length it randomly selects one of them.
finally if all of the actions in r e fail it returns nu ll line suggesting that it fails to expand the abbreviation abbr .
evaluation in this section we evaluate the proposed approach noted as kgexpander on nine well known open source applications.
.
research questions rq1 how often can abbreviations in the name of software entity efind their full terms in names of software entities that are semantically related to e?
rq2 is the proposed approach accurate in expanding abbreviation?
does it outperform the state of the art approaches?
rq3 does the proposed approach outperform parameterspecific approaches in expanding parameter abbreviation?
if yes to what extent and why?
rq4 how does the abbreviations length influence the performance of abbreviation expansion?
rq5 dose the prioritization of potential actions influence the performance of the proposed approach?
if yes to what extent?
rq6 is the proposed approach scalable?
the proposed approach is based on the assumption that abbreviations in the name of software entity ehave great chance to find their full terms in names of software entities that are semantically related to e. answering research question rq1 would validate the assumption.
research question rq2 investigates the performance e.g.
precision and recall of the proposed approach in expanding abbreviations in comparison with the state of the art approaches.
to answer this question we compare the proposed approach against linsen because linsen is accurate well known and represents the state of the art.
besides that the implementation of linsen is publicly available which facilitates the comparison.
answering this research question would reveal to what extent the proposed approach improves the state of the art.
besides generic approaches like linsen that is designed to expand abbreviations from different kinds of identifiers a parameterspecific approach is proposed by jiang et al.
we call it parexpander for convenience .
although parexpander is confined to abbreviations in parameters actual or formal parameters it is highly accurate .
research question rq3 investigate whether the proposed generic approach can outperform parexpander even if only parameter abbreviations are concerned.
rq4 concerns the impact of abbreviations length.
as suggested by jiang et al.
the length of abbreviations does influence the performance of existing approaches.
answering this question helps to reveal whether our approach is also influenced by abbreviations length.
rq5 concerns the impact of the prioritization of potential actions.
as specified in section .
the prioritization is learned from a corpus of abbreviations accompanied with their corresponding expansions that are manually expanded.
answering this question 136semantic relation based expansion of abbreviations esec fse august tallinn estonia table comparison among different searching scopes applicationknowledge graph enclosing method enclosing file enclosing project ppr esence size ppr esence size ppr esence size ppr esence size db manager batik portecle pdfsam retrofit bootique checkstyle maven filebot average would reveal the value of the learning phase.
rq6 concerns the scalability of the proposed approach i.e.
whether the proposed approach can work on large projects.
.
subject applications we reuse the subject applications employed by jiang et al.
.
we reuse such subject applications because of the following reasons.
first all of the subject applications are open source applications whose source code is publicly available which facilitates other researchers to repeat the evaluation.
second such applications have great diversity.
they are from different domains and developed by different programmers.
the size of such projects varies dramatically from loc to loc and such projects cover singledeveloper small projects as well as large projects where a large number of contributors cooperate extensively.
besides that the dataset includes both libraries and applications.
.
process the process of the evaluation is composed of three phases sampling manual expansion and k fold cross validation on the resulting dataset.
these phases are explained in detail in the following paragraphs.
to create a dataset for evaluation we download nine applications from github based on the popularity.
then we randomly pick up identifier abbreviations from each of the involved subject applications as introduced in the preceding section .
.
we follow the sampling strategy proposed by jiang et al.
to reduce potential bias.
the strategy excludes identical identifiers i.e.
identifiers in the resulting dataset are lexically different from each other.
notably for the smallest project db manag er the number of abbreviations from unique identifiers is fewer than and thus we include all such abbreviations.
manual expansion of sampled abbreviations is conducted by three software developers.
they are master level students and are familiar with java.
however they are not aware of the proposed approach.
according to the information from source code they recommend an expansion for each of the abbreviations.
if they come up with different expansions for the same abbreviation they are requested to discuss together and reach an agreement before the final expansion is confirmed.
the resulting dataset is publicly available at k fold k cross validation on the resulting dataset is conducted as follows.
on each fold a single application out of the nine subject applications is used as the testing subject noted as testin app whereas the others are used as training subjects noted astrainin apps .
each of the subject applications is used as the testing subject for once.
each fold of the evaluation follows the following process step1 manually expanded abbreviations from trainin apps are collected as training data noted as trainin data .
other sampled abbreviations are collected as testin data step2 the proposed approach learns rules with trainin data step3 we apply the proposed approach and linsen totestin d ata respectively.
step4 we compute the performance i.e.
precision and recall of the evaluated approaches.
an expansion of a given abbreviation is correct if and only if the expansion is identical to the manual expansion stored in the testing dataset.
as specified in section .
abbreviation dictionaries are useful in abbreviation expansion and thus they are exploited by the proposed approach and existing approaches like linsen and parexpander .
in the evaluation we employ two publicly available dictionaries a generic abbreviation dictionaries and a computer specific abbreviation dictionary .
for fair comparison all evaluated approaches use the same dictionaries.
.
rq1 semantic relations are crucial for abbreviation expansion to answer research question rq1 we manually expand abbreviations in identifiers and investigate where their full expansions could be found the process of manual expansion is identical to section .
.
the key of the proposed approach is to construct a searching scope for a given abbreviations according to semantic relation.
in contrast existing approaches often construct the searching scope according to distance i.e.
words within the enclosing methods the enclosing documents or the enclosing projects.
we employ the following two metrics to measure how good such search scopes are.
the first is the size of the scopes i e. the average number of unique terms within the scopes.
the larger the scope is the more challenging to pick up the right ones.
consequently the smaller the scope is the better it is.
the second is the possibility that the search scope contains the correct expansion 137esec fse august tallinn estonia yanjie jiang hui liu and lu zhang noted as ppresence ppresence no.of scopes containin expansions no.of scopes greater ppresence suggests greater chance to find full terms from the given scope.
evaluation results of different search strategies are presented in table .
the first column presents subject applications.
columns present the metrics of the proposed searching scopes i.e.
knowledge graphs.
columns presents the metrics of distance based searching scopes.
notably abbreviation dictionaries employed by the proposed approach and existing approaches as well is not counted in by the searching scopes.
these dictionaries often serve as supplements to different searching scopes and thus they can collaborate with different searching strategies and different searching scopes .
from the table we made the following observations first all of the searching scopes have great chance varying from to to contain the correct expansions of abbreviations.
it may suggest that it is potentially fruitful to search full terms within such scopes.
that is one of the reasons for the success of existing approaches e.g.
linsen .
second the average size nine unique words of knowledge graphs is significantly smaller than that of other searching scopes.
it is only .
.
and .
of the sizes of enclosing methods enclosing files and enclosing projects respectively.
considering that ppresence of knowledge graphs is comparable to other searching scopes even greater than that of enclosing methods the significantly smaller size of knowledge graphs may suggest that searching full terms in knowledge graphs could be significantly more accurate and thus more fruitful .
from the preceding analysis we conclude that abbreviations in identifiers have great chance to find their full terms in semantic based searching scopes i.e.
knowledge graphes as well as distance based searching scopes.
however knowledge graphes are significantly smaller than distance based searching scopes and thus it will be much more accurate to search for full terms in knowledge graphs than in distance based searching scopes.
.
rq2 improving the state of the art to answer research question rq2 we compare the proposed approach kgexpander against the state of the art approach linsen andbin ramexpander .
evaluation results are presented in table .
the first column of table presents the subject applications.
the second to the fifth columns present the results of the proposed approach the sixth to the ninth columns present the results of linsen and the tenth to the thirteenth columns present the results ofbin ramexpander .
the second the sixth and the tenth columns present the number of abbreviations that are successfully expanded by the proposed approach linsen and bin ramexpander respectively.
the third the seventh and the eleventh columns pres ent the incorrect expansions made by the proposed approach linsen and bin ramexpander respectively.
notably the precision and recall oflinsen are always the same because it expands all abbreviations it encounters.
from the table we made the following observations first the proposed approach is accurate.
its precision varies from to with an average of .
high precision suggests that it makes few mistakes in abbreviation expansion and thus it is reliable.
second the proposed approach successfully expands most of abbreviations in identifiers.
such high recall indicates high serviceability of the proposed approach.
third the proposed approach significantly outperforms the stateof the art approaches.
compared against linsen it improves the precision and recall by and respectively.
compared against bi ramexpander it improves the precision and recall by and respectively.
finally the proposed approach outperforms linsen andbi ram expander on every subject application.
for the linsen the smallest improvement in precision and recall is and respectively.
for the bi ramexpander the smallest improvement in precision and recall is and respectively.
we conclude from the preceding analysis that the proposed approach is accurate and it can expand most of the abbreviations in source code.
we also conclude that it significantly outperforms the state of the art approach linsen .
.
rq3 expansion of parameter abbreviations although parexpander proposed by jiang et al.
is confined to parameter it is highly accurate.
in this section we investigate whether the proposed approach is comparable to or even better than parexpander in expanding parameter abbreviations.
notably only of the abbreviations in our study are from parameters including actual parameters and formal parameters .
it suggests that the majority of the abbreviations are from non parameters and they could not be expanded by parameter specific approaches like parexpander .
we compare the proposed approach against parexpander on the parameter abbreviations that parexpander was intentionally designed to expand.
results are presented in table .
the first column of table presents the subject applications.
the second to the fourth columns present the results of the proposed approach whereas the other columns present the results of parexpander .
from this table we make the following observations first parexpander is highly accurate in expanding parameter abbreviations which is in consistent with previous study .
its average precision is up to whereas its average recall is up to .
we also observe that it performs well on each of the subject applications.
second the proposed approach outperforms parexpander concerning f1score.
it improves the average f1score from to and the improvement is up to .
third the proposed approach improves recall significantly.
the average recall of the proposed approach is significantly greater than that of parexpander .
the improvement is up to .
finally the precision of the proposed is comparable to that of parexpander even if only parameter abbreviations are concerned.
138semantic relation based expansion of abbreviations esec fse august tallinn estonia table comparison against state of the art approach applicationskgexpander linsen bigramexpander correct expansionincorrect expansionprecision recallcorrect expansionincorrect expansionprecision recallcorrect expansionincorrect expansionprecision recall db manager batik portecle pdfsam retrofit bootique checkstyle maven filebot total table expansion of parameter abbreviations applicationkgexpander parexpander precision recall f1 precision recall f1 db manager batik portecle pdfsam retrofit bootique checkstyle maven filebot average we also investigate the reasons for the reduction in precision.
we find that the proposed approach frequently expands parameter abbreviations that parexpander refuses to expand noted as refused abbreviations .parexpander refuses to expand parameter abbreviations frequently with a probability of because its searching scope is rather small and such scope often fails to contain the full expansions.
in contrast the proposed approach exploits more semantic relations and thus has greater chance to find the full expansions.
we also notice that the proposed approach is less accurate on such refused abbreviations than on other parameter abbreviations the precision is reduced from to .
as a result the less accurate expansion of such prevalent refused abbreviations leads to moderate reduction in the average precision of the proposed approach.
on the other side however the proposed approach successfully expands out of the refused abbreviations and thus improves recall significantly from to .
we conclude from the preceding analysis that the proposed approach outperforms parexpander in expanding parameter abbreviations leading to significantly improved recall.
.
rq4 impact of abbreviations length as suggested by existing studies length of abbreviations has significant impact on the performance of linsen and the shorter abbreviations are usually more challenging to expand.
to this end we investigate whether the performance of the proposed approach length of abbreviations precision of kgexpander recall of kgexpander precision recall of linsen figure impact of abbreviations length is significantly influenced by abbreviations length.
evaluation results are present in fig .
notable linsen tries to expand every abbreviation and thus its recall is always equal to its precision.
from fig we make the following observations first it is challenging for state of the art approaches like linsen to expand short abbreviations.
its precision and recall as well reduces dramatically from to when the length of abbreviations reduces from three characters to two characters.
it even further reduces to when the length reduces to one character.
second the proposed approach works well for short abbreviations especially single character abbreviations.
to reveal the reason for such high performance we manually analyze such single character abbreviations.
analysis results suggest that most .
of such abbreviations are acronyms initial characters e.g.
s standing for string .
such short acronyms are difficult to expand correctly because they may match a large number of potential full terms.
for example s could be abbreviation of any term beginning with s .
the proposed approach succeeds because it limits the size of searching scopes i.e.
it compares the short abbreviations against a small number of terms from semantically related entities.
as a result the number of matching terms is significantly reduced and the accuracy is guaranteed.
third the proposed approach fails to expand a significant part of the two character abbreviation.
we manually analyze the failed cases to figure out the major reason for the failure.
we find that .
of the involved abbreviations should be expanded into two words but are expanded improperly by our approach into a single word.
a typical example is sw .
the approach expands it into software whereas it stands for string writer .
139esec fse august tallinn estonia yanjie jiang hui liu and lu zhang table influence of prioritization applicationwith prioritization without prioritization precision recall precision recall db manager batik portecle pdfsam retrofit bootique checkstyle maven filebot total we conclude from the preceding analysis that the length of abbreviations has less impact on our approach than linsen and our approach works well on short abbreviations especially one character abbreviations.
.
rq5 influence of prioritization in section .
the proposed approach learns to prioritize potential search actions based on a manually created training dataset.
to investigate the impact of the prioritization we repeat the evaluation but ignoring the learned prioritization i.e.
the approach looks for all potential expansions with all of the available search actions and selects the most likely one as specified on line of algorithm .
evaluation results are presented in table .
from this table we make the following observations the prioritization improves the performance of the proposed approach in both precision and recall.
it increases the precision from to and recall from to .
the prioritization takes effect on each of the subject applications.
on each of the nine applications the default setting with prioritization outperforms its counterpart without prioritization .
during the evaluation we also observe some fruitful actions for different software entities.
for example the most fruitful action for local variables is type h2 and the most fruitful action for class names is superclass h2.
we conclude from the preceding analysis that the prioritization helps to improve the performance.
.
rq6 scalability we investigate the scalability of the proposed approach by analyzing the relationship between execution time of the proposed approach and the size of testing projects.
the evaluation is conducted on a personal computer with intel core i7 16gb ram and windows .
notably the execution time includes training time as specific in section .
.
based on the results we make the following observations first the execution time increases when the size of projects increases second the proposed approach is efficient takeing around minutes only to parse and expand abbreviations in the largest project checkstyle that contains more than thousands of lines of source code.
third disabling learning increases testing time significantly by and decreases training time slightly by .
.
we conclude from the preceding analysis that the proposed approach is scalable and could be applied to large projects.
.
threats to validity a threat to construct validity is that the dataset used in the evaluation is constructed manually by three students instead of the original developers of the projects.
they may make mistakes in the manual expansion because they lack system knowledge.
such mistakes may make the evaluation inaccurate.
to reduce the threat we ask the three participants to work together and exclude expansions where they cannot reach an agreement.
another threat to validity concerning the manual golden set creation is the bias to or against evaluated approaches.
if the participants know in advance how the proposed approach works they may expand the abbreviations as the proposed approach does which may seriously bias the evaluation results.
to reduce the threat we exclude the authors of the paper from the manual creation and recruit students who are not aware of the proposed approach.
a threat to the external validity is that only projects and abbreviations are involved in the evaluation.
the limited number of involved projects and abbreviations may threaten the generality of the conclusions i.e.
the extent to which such conclusions can be generalized to other situations other projects and abbreviations .
special characters of such projects may bias the conclusions e.g.
the native language of the developers the style guide applied by the project whether the project does code review whether it is a single developer project or one with many developers collaborating and whether it is a library or an application.
to reduce the threat we select such projects that cover diverse characters as shown in table .
evaluation results suggest that the proposed approach is accurate on each of the subject applications.
to further improve the generality of the conclusions in future however evaluation on more projects and more abbreviations should be conducted.
conclusions and future work in this paper we propose an automatic approach to expanding abbreviations in identifiers by exploiting the semantic relations among software entities.
the key insight of the approach is that the full terms of an abbreviation abbr in the identifier of software entity eare likely to appear in the names of software entities that are semantically related to e. consequently we build a knowledge graph for e presenting its semantically related entities and their names as well their relationship with e. based on this knowledge graph we search for full terms for abbr with a sequence of heuristics.
to investigate what kind of semantical relations and heuristics are more reliable and potentially more fruitful we prioritize potential search actions with a manually created training dataset.
we evaluate the proposed approach on open source projects.
results of the kfold cross validation suggest that the proposed approach is accurate and it improves the state of the art significantly.