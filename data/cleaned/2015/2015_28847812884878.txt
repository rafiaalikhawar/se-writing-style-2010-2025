an empirical comparison of compiler testing techniques junjie chen1 wenxiang hu1 dan hao1 2yz yingfei xiong1 2z hongyu zhang3z lu zhang1 bing xie1 1key laboratory of high confidence software technologies peking university moe 2institute of software eecs peking university beijing china chenjunjie huwx haodan xiongyf zhanglucs xiebing pku.edu.cn 3microsoft research beijing china honzhang microsoft.com abstract compilers as one of the most important infrastructure of today s digital world are expected to be trustworthy.
different testing techniques are developed for testing compilers automatically.
however it is unknown so far how these testing techniques compared to each other in terms of testing e ectiveness how many bugs a testing technique can nd within a time limit.
in this paper we conduct a systematic and comprehensive empirical comparison of three compiler testing techniques namely randomized di erential testing rdt a variant of rdt di erent optimization levels dol and equivalence modulo inputs emi .
our results show that dol is more e ective at detecting bugs related to optimization whereas rdt is more e ective at detecting other types of bugs and the three techniques can complement each other to a certain degree.
furthermore in order to understand why their e ectiveness di ers we investigate three factors that in uence the e ectiveness of compiler testing namely e ciency strength of test oracles and e ectiveness of generated test programs.
the results indicate that all the three factors are statistically signi cant and e ciency has the most signi cant impact.
.
introduction compilers are important because they are widely used in software development.
buggy compilers may lead to the unintended behaviors of developed programs which may cause software failures or even disasters in safety critical domains.
we would like to acknowledge zhendong su and chengnian sun at uc davis for their valuable and insightful comments on an early version of this paper.
this work is supported by the national basic research program of china under grant no.
2015cb352201 and the national natural science foundation of china under grant no.
.
ycorresponding author.
zsorted in the alphabet order of the last names.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
compiler bugs make debugging more di cult because developers can hardly determine whether software failure is caused by the software they are developing or the compilers they are using.
therefore guaranteeing the quality of compilers is critical.
however it is very challenging to guarantee the quality of compilers.
although compilation theory and compiler design have been thoroughly studied in reality compilers still contain bugs .
like many other software systems compiler testing su ers from the test oracle problem .
that is it is hard to determine the expected outputs of a compiler under test given some programs as the test inputs.
to automate compiler testing without oracles several techniques have been proposed in the literature.
most of the current work on compiler testing is based on randomized di erential testing rdt which assumes that several comparable compilers are implemented based on the same speci cation and detects bugs by comparing the outputs of these compilers for the same test program.
when these compilers produce di erent results some of the implementations must contain bugs.
furthermore as many compiler bugs reported in previous work are triggered by compiler optimizations a simple testing technique is to compare the outputs of one compiler at di erent optimization levels for the same test program.
we call such a technique di erent optimization levels dol which is technically a variant of rdt.
recently le et al.
proposed a compiler testing technique called equivalence modulo inputs emi which generates a series of variants from an existing test program by guaranteeing the variants to be equivalent to the test program under a set of test inputs.
it then detects bugs by comparing the outputs of the given test program and those of the variants.
the above mentioned work on compiler testing is widely recognized.
for example the work on emi received the distinguished paper award from pldi and the work on rdt is widely used in actual compiler testing practice .
although existing studies have investigated the e ectiveness of the compiler testing techniques they either use only one compiler testing technique or focus on a small domain of dedicated compilers i.e.
opencl compilers .
to our best knowledge it is yet unknown which of the three techniques is more e ective in detecting general compiler bugs.
furthermore because of the particularity of compilers in the remainder of this paper test programs refers to the inputs of compilers and test inputs refers to the inputs of test programs.
ieee acm 38th ieee international conference on software engineering in this paper we present a systematic and comprehensive empirical comparison of the three automated compiler testing techniques rdt dol and emi .
we implement the three techniques and apply them to two mainstream opensource c compilers gcc and llvm which cover all c compilers used in existing studies of compiler testing .
to investigate the e ectiveness of the three compiler testing techniques we qualitatively and quantitatively analyze the bugs detected by these techniques and derive our ndings.
a key challenge in this empirical comparison is to measure the e ectiveness of the compiler testing techniques.
ideally compiler testing techniques should be measured in terms of the number of compiler bugs detected but there is no means for us to measure the number of bugs directly.
previous work has used two methods to approximate the ideal measurement.
lidbury et al.
and yang et al.
used the number of test programs that detect faulty behaviors in compilers.
however as will be shown in section .
this measurement is highly inaccurate because di erent test programs can trigger the same bug.
le et al.
asked compiler developers to identify the test programs that trigger the same bug but this method does not scale well.
in this paper we propose a new measurement correcting commits.
when a test program fails on an early version of the compiler we check subsequent compiler commits and determine which commits correct the bugs.
by using the number of correcting commits to approximate the number of bugs our measurement avoids many of the inaccuracies in previous studies.
our empirical study also investigates three factors that in uence the e ectiveness of compiler testing.
we study how the three techniques perform with respect to the three factors and the statistical impact of the three factors on the e ectiveness of compiler testing.
the three factors are e ciency how many test programs can be tested given a xed period of time?
strength of test oracles given the same test programs which technique detects more bugs?
e ectiveness of generated test programs emi generates new variants from the original program.
do the variants help discover more bugs than randomly generated programs?
the major ndings that we obtain from the empirical comparison are as follows.
dol is more e ective at detecting optimization related bugs and rdt is more e ective at detecting optimizationirrelevant bugs.
rdt can substitute emi and dol in detecting optimization irrelevant bugs but it can be substituted by dol in detecting optimization related bugs.
furthermore both emi and dol cannot be substituted in detecting optimization related bugs.
with respect to the three factors we nd the following.
dol is the most e cient technique whereas emi is the least e cient one.
rdt oracle is the strongest whereas emi oracle is the weakest.
the randomly generated programs are more effective than the variants generated by emi.
the impact of all the three factors is statistically signi cant.
e ciency has the most signi cant impact on the e ectiveness of compiler testing and the e ectiveness of generated test programs has the least signi cant impact.
the main contributions of this paper can be summarized as follows a systematic and comprehensive empirical comparison of automated compiler testing techniques and obtain many valuable ndings.
a new measurement correcting commits which better measures the e ectiveness of compiler testing than previous measurements.
.
compiler testing techniques in this section we introduce the three automated compiler testing techniques rdt dol and emi.
.
randomized differential testing rdt is a widely used compiler testing technique which addresses the test oracle problem in compiler testing using two or more comparable compilers that implement the same speci cation.
because these comparable compilers should produce the same results under the same set of test inputs it is easy to determine which compilers contain bugs through voting.
that is if more than half of the compilers generate the same results the results are regarded as the correct results.
given a set of compilers under test denoted as fc1 c2 cngwhere n the process for applying rdt to test these compilers is as follows.
each compiler cicompiles a test program pand generates an executable ei where i n. for any given set of test inputs for p denoted asi these executables produce di erent results denoted as o1 o2 o n. because the compilers under test are designed to follow the same speci cation their behaviors are expected to be the same.
therefore rdt detects compiler bugs through the voting among o1 o2 and on.
rdt is a well known testing technique which is applicable to both compilers and other complex software because it is e ective and easy to implement.
however there is an important limitation of rdt.
because these compilers could be implemented in a similar manner or with some common source code it is possible for most or all comparable compilers to produce the same wrong results under the same set of test inputs.
in this scenario rdt can hardly detect compiler bugs.
furthermore if there is a new programming language and only one compiler is available for this programming language rdt cannot be applied to test this compiler at all.
.
different optimization levels as mentioned before we consider a variant of rdt comparing compilation results under di erent optimization levels.
that is when a test program is respectively compiled under di erent optimization levels e.g.
o0 o1 os o2 and o3 in gcc and executed under the same set of test 181inputs it may produce di erent results thus we know that the compiler under test contains bugs.
for simplicity in this paper we informally call those bugs detected through di erent optimization levels as optimization related bugs and other bugs as optimization irrelevant bugs .
similar to rdt dol uses one test program each time thus it is easy to be implemented.
furthermore dol targets at only one compiler with di erent optimization levels thus it can directly test a speci ed optimizing compiler.
.
equivalence modulo inputs emi is a newly proposed compiler testing technique which addresses the test oracle problem through comparison between a test program and its variants whose behaviors are regarded as equivalent under a set of test inputs for this test program.
in particular for a test program emi identi es a set of statements that a ect its behavior given some test inputs and constructs variants whose behaviors are equivalent to the behavior of the test program.
emi introduces a pro le and mutate strategy on the statements of the given test program and uses this strategy to generate variants.
for a compiler under test denoted as c the process for applying emi to test this compiler is as follows.
for any given test program pand its test inputs i emi rst generates some variants of p denoted as q1 q2 qm through the following process.
first emi identi es a set of statements in punexecuted by ithrough dynamic analysis and generates variants by randomly deleting statements within this set.
then the test program pand each variant qi i m are compiled by the compiler c and thus the corresponding executables denoted as epandei are generated.
taking ias test inputs these executables produce results denoted as opan because the variants should behave equivalently to given program p under test inputs i emi detects the bugs in cby comparing each pair opan where i m. although emi is more complex than rdt and dol emi targets at only one compiler with without di erent optimization levels thus it can directly test any speci ed compiler and overcome the limitation of rdt and dol.
.
measurement correcting commits in this paper we propose a new measurement correcting commits.
the new measurement is based on the analysis of commit history of the compiler under test.
for any test program that triggers a bug of a compiler cwhose commit version is x we check subsequent commits of the compiler and determine which commits correct the bug.
to locate the commit that corrects the corresponding bug our approach rst nds a commit of the compiler that has already corrected the bug and then performs binary search between the commit with the bug and the commit without the bug.
in the repository branches can be created and later merged back.
however in the commit history of the compilers used in this study we observe only the creation of branches but not the merging of two branches.
therefore we ignore merge and represent the commit history by a tree which is illustrated by figure where nodes represent commits and edges represent the inheritance relation between commits.
to nd the correcting commit quickly we identify the v0 v1 v2 v3 v4 v5 figure tree model for the commit history nodes that incur branches e.g.
v0 and v1 and terminate branches e.g.
v2 and v4 which are called key nodes in this paper and use a tree structure with root node denoted astree to represent a commit history consisting of only key nodes and their inheritance relation.
in particular the root node is also regarded as a key node and represents the version under test.
based on these key nodes the commit history is divided into several segments e.g.
v0 v1 and v1 v2 each of which is denoted as linked list ls v s v e representing that there is an inheritance path from the key node v sto another key node v e. given the commit history composing of commits fv0 v1 v mg where v0 represents the compiler version under test and v m represents its latest version or commit and ps fp p2 p ngrepresents the set of test programs that trigger bugs we use algorithm to calculate the number of commits correcting the bugs triggered by ps.
we use a set setto record the correcting commits.
this algorithm repeats ntimes to nd the correcting commit for each test program piwhere i n. in particular lines deal with the event that the bugs triggered by piare not corrected at all.
line is to nd the correcting commit for pithrough the method find and add it to setif this correcting commit has never been added to set.
line is to produce the number of correcting commits for ps.
algorithm presents the method find whose parameter tree refers to the commit history and prefers to the test program that triggers a bug.
the variable flag represents the correcting commit if there exists for p. algorithm is a depth rst algorithm which searches the tree from the root node so as to nd a key node denoted as v0 that corrects the bugs detected by p. if no commit in the history corrects the corresponding bugs the return value is set to zero according to lines to otherwise the correcting commit is in the linked list ls v v0 .
in this case this algorithm nds the speci c correcting commit in this linked list through the widely used binary search algorithm implemented as binarysearch ls v v0 in this paper .
based on this algorithm for any set of test programs that trigger failing compiler behaviors we can learn the number of correcting commits automatically.
being a measurement for compiler testing the number of correcting commits tends to be more accurate than the number of test programs in approximating the number of bugs since one correcting commit is often for xing one bug.
that is this newly proposed measurement may avoid some inaccuracies in previous studies which will be further studied in section .
.
182algorithm correcting commits measurement foreach i i n do if!correct pi vm then set add else set add find tree p i end if end for output set size algorithm int find tree p v tree flag ifv children null then return end if foreach i i v children length do v0 v children ifcorrect p v0 then return binarysearch ls v v0 else flag find v0 p ifflag!
then return flag end if end if end for return .
study design .
subjects we use two mainstream open source c compilers gcc1 and llvm2for the x86 linux platform as the subjects of the empirical study which are c compilers used in existing studies of compiler testing .
because it is impossible to determine which compiler is wrong when applying rdt to only two compilers we add another c compiler icc3to our empirical study this is a commercial optimizing compiler from intel with high reliability.
the icc compiler serves as the golden compiler4in the rdt experiment.
in particular in the empirical study we use gcc .
.
and llvm .
.
we choose these versions because they are based on the same c99 speci cation.
therefore they can be viewed as comparable compilers thus satisfying the requirements of rdt.
.
measurement of testing effectiveness in the empirical study we use the number of test programs that reveal compiler bugs and the number of correcting commits obtained by the approach described in section to measure the e ectiveness of a compiler testing technique.
in particular in our study all the bugs detected by the three techniques have been xed by correcting commits.
if no confusion is caused we use the number of bugs to directly 2the llvm project is a collection of compiler and toolchain techniques which is accessible at to be consistent with previous work on compiler testing we also use llvm to represent the compiler used in llvm which is mainly clang.
4the golden compiler is used to determine which compiler is wrong if the two compared compilers produce di erent results.refer to the number of correcting commits in the remainder of this paper.
.
test programs to compare the e ectiveness of the three compiler testing techniques we use csmith to generate a set of test programs and use this set of test programs as the inputs to the compilers.
csmith is a widely used test generation tool for c compilers which randomly generates c programs without unde ned behavior.
in this study we use csmith .
.
with its default con guration.
the test programs generated by csmith do not require external inputs and its output is a checksum of their non pointer global variables at the end of the test program execution.
that is we do not need to generate test inputs for these test programs.
in particular for emi besides these test programs variants are generated when applying the standard pro le and mutate strategy described in section .
to the test programs.
in particular for each test program generated by csmith we generate eight variants5by deleting the unexecuted statements randomly following le et al.
.
.
process to reduce the in uence of test programs in the comparison of compiler testing techniques we prepare a xed sequence of randomly generated test programs so that the compared compiler testing techniques use the same test programs in this empirical study.
given a subject compiler we run each of the three compiler testing techniques for consecutive hours by taking these test programs as inputs and record the test programs with which the corresponding compiler testing technique detects bugs.
to compare the three compiler testing techniques we calculate the number of test programs that detect compiler bugs and the number of compiler bugs detected by each compiler testing technique.
the process of evaluating these compiler testing techniques in this study is as follows.
first we apply rdt to test the two compilers gcc and llvm.
following the prior work we compile each test program with gcc and llvm under the same optimization level which contain o0 o1 os o2 and o3.
we compiler each test program with icc without any optimizations.
we then execute the corresponding executables.
if the test results produced by gcc and llvm are di erent at least one compiler is wrong.
at this time by comparing the results produced by icc gcc and llvm we determine in which compiler the corresponding test program detects a bug.
that is we regard icc as the golden compiler when gcc and llvm produce di erent results.
second we apply emi to test the two compilers.
we execute the original test program and the eight variants and compare the result of each variant with the result of the original program.
following the prior work we use ve optimization levels i.e.
o0 o1 os o2 and o3 to compile the original test program and its variants respectively.
we determine whether the compiler under test contains bugs by comparing the output of the original test program and each of its variants.
if the output of the original test program is di erent from that of the variant this pair of programs detects a bug in the compiler.
third we apply dol to test the two compilers.
we compile each test program using the same compiler under dif5the number of variants is recommended by their paper .
183ferent optimization levels i.e.
o0 o1 os o2 and o3 and compare the execution results produced by each optimization level i.e.
o1 os o2 and o3 with that produced by o0 i.e.
no optimization at all .
our empirical study was conducted on a workstation with eight core intel xeon e5620 cpu .4ghz with 24g memory and ubuntu .
.
operating system.
.
results and analysis as measurement is the base of an empirical study in this section we rst quantitatively compare the newly proposed measurement i.e.
correcting commits with the mostly used measurement i.e.
the number of test programs on their accuracies in section .
.
that is this study aims to tell which measurement is more accurate in evaluating compiler testing.
based on the new measurement we compare the three compiler testing techniques in terms of their e ectiveness substitutability and the characteristics of detected bugs in section .
.
that is this study aims to tell which compiler testing technique should be applied in practice.
the inherent di erence of the three compiler testing techniques lies in the test programs and oracles.
for test programs rdt and dol do not have any novelty but emi de nes a new type of test programs i.e.
variants generated based on existing test programs.
for test oracles rdt dol and emi use various mechanisms i.e.
relation between compilers optimizations programs.
furthermore as compiler testing usually takes a long time the e ciency issue i.e.
how many test programs are used in compiler testing in a given period of time is also an important internal factor that in uences how a compiler testing technique performs.
therefore we further study the impact of these inherent factors in section .
so as to learn the secret why a compiler testing technique performs well.
besides many c compiler bugs reported in the literature are optimization related bugs.
therefore we further investigate how optimization levels in uence compiler testing in section .
.
the experimental data is available at the project webpage6.
.
measurement comparison as mentioned in section previous work measured the e ectiveness of compiler testing techniques by the number of test programs that detect faulty behavior in compilers but it may be inaccurate because di erent test programs may trigger the same bug.
in this section we evaluate the accuracy of their measurement.
we manually check ve commits of gcc each of which xes only one gcc bug.
table presents the number of test programs that trigger the ve bugs respectively.
from this table the distribution of the number of test programs that trigger each bug is extremely uneven because test programs trigger the 5th bug and only one test program triggers the 2nd bug.
that is the measurement that uses the number of test programs can obtain very inaccurate results.
however during the development of compilers one commit cannot correct hundreds of bugs.
in other words the number of correcting commits is much closer to the ideal measurement i.e.
the number of detected bugs than the number of programs that trigger bugs.
therefore this is evidence for the necessity of using the number of correcting commits rather than the number of test programs as a measurement in compiler testing.
table number of test programs triggering bugs bug 1st 2nd 3rd 4th 5th test programs triggering bugs furthermore table presents the number of bugs detected by the three compared techniques and the number of test programs that trigger bugs during the hours of experiments.
from this table we nd that the number of test programs can lead to the wrong conclusion in measuring the e ectiveness of compiler testing techniques because dol detects the largest total number of bugs under our measurement but its number of the test programs that trigger these bugs is smaller than that of rdt.
this is another evidence for the necessity of using the number of correcting commits rather than the number of test programs as a measurement in compiler testing.
finding the number of test programs that trigger bugs is an inaccurate measurement in compiler testing and thus the number of correcting commits is necessary as a measurement.
.
compiler testing technique comparison .
.
effectiveness number of detected bugs from table the total number of bugs detected by dol is larger than that by emi and rdt .
among the three compiler testing techniques emi detects the smallest number of bugs.
furthermore dol detects the largest number of gcc bugs whereas rdt detects the largest number of llvm bugs.
that is rdt and dol seem to be more e ective than emi.
table e ectiveness comparison compilers detected bugs test programs that trigger bugs rdt emi dol rdt emi dol gcc llvm total number of bugs detected per ten hours because compiler testing is costly compiler testing techniques are expected to detect bugs as early as possible.
therefore besides the total number of detected bugs we calculate the number of bugs detected per ten hours to measure the cost e ectiveness of the three compiler testing techniques.
figure presents the increased number of gcc and llvm bugs detected by the compared techniques with time increasing.
from figure a the number of gcc bugs detected by dol is always larger than that by rdt and emi and the increasing rate of dol and emi are obvious larger than that of rdt.
from figure b the number of llvm bugs detected by either rdt or dol is much larger than that by emi and their increasing rates are also larger than emi.
in summary dol is superior to rdt and emi in gcc and rdt and dol are superior to emi in llvm.
time spent on detecting the first bug it is desirable for a testing technique to reveal the rst bug early so that developers can start debugging early.
therefore we further compare how much time each compiler testing technique spends on detecting the rst bug and the re184time h 10number of bugs20 50dolemirdt a gcc time h 10number of bugs15 50dolemirdt b llvm figure increased number of detected bugs per ten hours sults are listed in table .
from this table dol requires the least time to nd the rst gcc bug whereas rdt requires the least time to nd the rst llvm bug.
table time to detect the first bug seconds compilers rdt emi dol gcc llvm finding dol seems to be the most e ective one at detecting gcc bugs and rdt seems to be the most e ective one at detecting llvm bugs in our experiments.
.
.
substitutability in the preceding analysis we investigate the three techniques based on one criterion the total number of detected bugs.
however there is another important criterion to compare the three techniques whether the bugs detected by one compiler testing technique can be detected by the others.
in other words we need to study the number of bugs that can be detected by only one compiler testing technique which are called unique bugs for the corresponding technique in this paper.
the more unique bugs a compiler testing technique detects the less substitutable the technique tends to be.
on the contrary if a compiler testing technique cannot detect any unique bug it can be substituted by other compiler testing techniques because all its detected bugs can also be detected by the latter techniques.
to visualize the number of unique bugs detected by each technique we use venn diagrams to represent the sets of bugs detected by these techniques as shown in figure .
the three circles represent the sets of bugs detected by each compiler testing technique.
each circle is divided into several areas each of which represents the set of bugs detected by the corresponding technique and it is marked by a letter from a to g for reference.
for example the area marked by a represents the set of unique bugs only detected by rdt.
the number in each area represents the number of elements in the corresponding set.
for example in figure a in area a denotes that zero unique bug is detected by rdt alone whereas in area d denotes that ve bugs are detected by both rdt and dol but not by emi.
from this gure the number of gcc unique bugs detected by rdt is zero thus the combination of emi and dol can completely substitute rdt in detecting gcc bugs.
in fact figure a shows that all gcc bugs detected by rdt are also detected by dol but ve gcc bugs detected by rdt are not yet detected by emi.
therefore only dol can completely substitute rdt in detecting gcc bugs.
however from figure b rdt has the largest number of llvm a c b d e f g rdt emi dol a gcc a c b d e f g rdt emi dol b llvm figure number of unique bugs unique bugs i.e.
ve .
moreover the number of unique gcc bugs detected by dol is the largest of all i.e.
three and the number of unique llvm bugs detected by dol is four.
therefore dol cannot be substituted by rdt and emi.
similarly emi cannot be also substituted by rdt and dol although it has the least e ectiveness and coste ectiveness described in section .
.
.
in summary dol detects the most gcc unique bugs and rdt detects the most llvm unique bugs and emi can complement the other two techniques because it can detect some unique bugs.
finding dol seems to be more e ective at detecting gcc unique bugs and rdt seems to be more e ective at detecting llvm unique bugs.
furthermore when detecting gcc bugs rdt can be substituted by dol completely.
.
.
optimization related irrelevant bugs in section .
we indicate that dol is designed to detect optimization related bugs.
that is if a bug can be detected by dol the bug is an optimization related bug.
therefore we compile and execute the test programs that trigger bugs by rdt and emi and determine whether the test programs also trigger the bugs by dol.
if a bug detected by rdt or emi is also detected by dol the bug is an optimization related bug otherwise it is viewed as an optimization irrelevant bug.
table presents the number of optimization related bugs and optimization irrelevant bugs detected by each compiler testing technique.
from this table all the bugs detected by emi are optimization related bugs and the bugs detected by rdt contain both types of bugs.
in particular dol detects the most optimization related bugs whereas rdt detects the most optimization irrelevant bugs.
therefore dol seems to be more e ective than rdt and emi at detecting optimization related bugs whereas rdt seems to be more e ective than emi and dol at detecting optimizationirrelevant bugs.
furthermore because all the gcc bugs detected by the three techniques are optimization related bugs gcc may have more optimization related bugs than optimization irrelevant bugs and this observation is consistent with the conclusion from le et al.
.
in particular we can complement the conclusion from figure based on the results in this section.
in figure ve bugs in area a of figure b are optimization irrelevant bugs and all the remaining bugs are optimization related bugs.
therefore rdt can completely substitute emi and dol at detecting optimization irrelevant bugs and dol can completely substitute rdt at detecting optimizationrelated bugs.
emi cannot be substituted by other techniques in detecting optimization related bugs because it detects ve 185unique optimization related bugs.
similarly dol cannot be substituted by other techniques in detecting optimizationrelated bugs because it detects seven unique optimizationrelated bugs.
table comparison on optimization related bugs and optimization irrelevant bugs bugs optimization related optimization irrelevant rdt emi dol rdt emi dol gcc llvm total finding dol seems to be more e ective at detecting optimizationrelated bugs whereas rdt seems to be more e ective at detecting optimization irrelevant bugs.
furthermore gcc may have more optimization related bugs than optimization irrelevant bugs.
.
impact of inherent factors .
.
efficiency in this subsection we rst investigate the impact of e ciency which is the number of test programs actually used in compiler testing in a given period of time.
table presents the number of test programs compiled and executed during the experimental period hours for testing gcc and llvm by rdt emi and dol respectively.
in particular the number of test programs for emi in this table refers to the number of original test programs.
this table indicates that during the same period of time dol uses the largest number of test programs whereas emi uses the smallest.
therefore dol and emi are the most and least e cient respectively.
the observation is as expected.
for each test program rdt needs compilations because it needs three compilers and it uses ve optimization levels for gcc and llvm and one optimization level for icc.
emi needs compilations because it generates eight variants for each original test program and also uses ve optimization levels for the compiler under test and dol needs ve compilations because it uses ve optimization levels for the compiler under test.
table number of test programs used during the experimental period compilers rdt emi dol gcc llvm furthermore based on the preceding analysis dol detects the largest number of bugs which contains many unique bugs and emi detects the smallest number of bugs.
that is the more e cient the technique is the larger the number of detected bugs is.
therefore e ciency is an important factor that in uences the e ectiveness of compiler testing.
finding dol is the most e cient technique whereas emi is the least e cient one.
.
.
strength of test oracles similarly in this subsection we investigate the strength of test oracles given the same test programs which technique detects more bugs.
this is the second internal factor that in uences the e ectiveness of compiler testing.
in fact all three techniques are proposed to address the test oracle problem.
rdt determines whether a bug is de tected by comparing the results produced by di erent compilers and dol determines whether a bug is detected by comparing the results produced by di erent optimization levels of the same compiler.
in particular emi consists of two novel components including a variant generation component and test oracle which determines whether a bug is detected by comparing the results of the test program and its variants produced by the same compiler.
in order to investigate the strength of test oracles we use the same programs including original test programs and their corresponding variants generated by emi to test gcc and llvm by the three test oracles.
table presents the results of investigating the strength of test oracles.
this table shows that when using the same programs including original test programs and their variants rdt detects the largest number of bugs and unique bugs whereas emi detects the smallest number of bugs and unique bugs.
in particular when testing gcc rdt detects the same number of bugs and unique bugs with dol.
therefore rdt oracle is the strongest whereas emi oracle is the weakest.
when testing gcc rdt oracle is as strong as dol oracle.
in practice if combining the variant generation component of emi and rdt dol oracle the e ectiveness of the combinations may be much better than that of emi.
therefore the strength of test oracles is another factor that in uences the e ectiveness of compiler testing techniques.
table strength of test oracles compilers detected bugs unique bugs rdt emi dol rdt emi dol gcc llvm total finding rdt and dol oracles are stronger than emi oracle and rdt oracle is not weaker than dol oracle.
.
.
effectiveness of generated test programs in this subsection we investigate the impact of the third factor e ectiveness of the generated test programs.
in this empirical comparison there are two types of generated test programs namely randomly generated programs and variants generated by emi.
in order to investigate the e ectiveness of generated test programs we use the same number i.e.
of randomly generated programs and variants generated by emi to test compilers using rdt and dol and record the number of bugs detected by them respectively.
we do not include emi in this experiment because emi cannot be applied when there is only the randomly generated programs.
table presents the results of comparing the quality of randomly generated programs and variants where random represents the randomly generated programs.
in particular the number of unique bugs means the number of bugs detected by the combination of a technique and a type of programs but not detected by the combination of this technique and the other type of programs.
table shows that when rdt uses randomly generated programs it detects more bugs and unique bugs than when it uses variants when dol uses randomly generated programs it detects more bugs and unique bugs than when it uses variants.
therefore randomly generated programs detect bugs more easily than variants.
that is rdt dol 186that uses randomly generated programs may be a better choice than rdt dol that uses variants in practice.
however the role of variants cannot be replaced because when rdt dol uses variants they also detect some unique bugs.
therefore the e ectiveness of generated test programs is also an important factor that in uences the e ectiveness of compiler testing techniques.
table e ectiveness of generated test programs compilers rdt dol random variant random variant gcc bugs llvm bugs gcc unique bugs llvm unique bugs finding the variants generated by emi are less e ective than randomly generated programs by csmith but variants can serve as a complement to randomly generated programs.
.
.
statistical significance in this subsection we analyze the impact of the three factors on compiler testing and analyze which factor has more signi cant impact.
in statistics this question can be regarded as a multivariable linear regression problem namely analyzing the impact of three independent variables on a dependent variable i.e.
the number of detected bugs .
in particular e ciency is a quantitative variable but the test oracle and generated test program are qualitative variables thus we use dummy variables to represent them.
there are three test oracles namely rdt oracle emi oracle and dol oracle.
there are two types of generated test programs namely randomly generated programs and variants generated by emi.
we test gcc and llvm under di erent combinations of test oracles and test programs.
in particular we use the same randomly generated programs or variants.
table presents the results of statistics analysis.
due to the lack of the combination of emi oracle and randomly generated programs we perform the statistical analysis in two steps.
first we analyze the impact of the three factors but the factor test oracles have only two values i.e.
rdt oracle and dol oracle .
second we analyze the impact of e ciency and the strength of test oracles but test oracles have three values this time rdt oracle emi oracle and dol oracle.
in this table rows to present the results of the rst statistical analysis and rows to present the results of the second statistical analysis.
the second column presents the coe cient of regression equation and the last column presents the signi cance value whose signi cant level is set to .
.
in particular the absolute value of the coe cient represents the degree of correlation and its sign represents positive correlation or negative correlation and the signi cance value re ect whether the factor has signi cant impact on the e ectiveness of compiler testing.
first from this table all the signi cance values are less than .
which means that the impact of the three factors on the e ectiveness of compiler testing is statistically significant.
then based on the results of the rst statistical analysis the absolute value of the coe cient of e ciency is the largest one and that of program random v.s.
variant is the smallest one thus e ciency has the most signi cant impact on the e ectiveness of compiler testing whereas the e ectiveness of the generated test program has the least signi cant impact on it.
furthermore the coe cient of testoracle rdt v.s.
dol is .
which is smaller than thus rdt oracle is stronger than dol oracle.
similarly the coe cient of program random v.s.
variant is .
which means that randomly generated programs are more effective than variants generated by emi con rming the conclusion of section .
.
.
besides based on the results of the second statistical analysis e ciency also has the most signi cant impact on the e ectiveness of compiler testing.
furthermore the coe cient of test oracle emi v.s.
rdt is .
which means that rdt oracle is stronger than emi oracle and the coe cient of test oracle emi v.s.
dol is .
which means that dol oracle is also stronger than emi oracle con rming the conclusion of section .
.
.
table statistics factors coe cient sig test oracle rdt v.s.
dol .
.
program random v.s.
variant .
e ciency .
test oracle emi v.s.
rdt .
test oracle emi v.s.
dol .
.
e ciency .
finding all the three factors have statistically signi cant impact on the e ectiveness of compiler testing where e ciency has the most signi cant impact and the e ectiveness of generated test programs has the least signi cant impact.
.
influence of optimization levels as many of the detected bugs are related to optimization according to the preceding experiment results we further analyze the in uence of optimization levels on triggering compiler bugs.
here we present only the analysis results of dol which is more e ective at detecting optimizationrelated bugs due to space limitation.
figure presents the number of bugs detected with di erent optimization levels i.e.
o1 os o2 and o3 respectively where the horizontal axis lists these optimization levels.
o1 is the lowest optimization level which implements the basic optimization operations when compiling.
from o1 to its right o3 is the highest optimization level and from o1 to its left os is higher than o1 because os is a special optimization level and adds some space optimization operations based on o1.
in particular oi oj represents the number of intersection of bugs detected at oi and bugs detected at oj where oi and oj are two adjacent optimization levels.
furthermore the vertical axis represents the number of detected bugs.
in figure a the numbers of bugs detected at os and o2 are the largest of all optimization levels and in figure b the numbers of bugs detected at os o2 and o3 are the largest of all optimization levels.
it is easy to take for granted that the higher the optimization level is the larger the number of detected bugs is because a higher optimization level contains all the optimization operations from the lower optimization levels.
however the assumption is invalid from figure a because o3 does not detect the largest number of bugs although it is the highest optimization level among o1 o2 and o3.
on the other hand the number of bugs detected with two adjacent optimization levels is usually smaller than the lower one.
that is when using a higher optimization level the bugs detected at a lower optimization level may disappear.
we suspect the reason for this observation to be the combination of opti187optimization levels o3 o2 o3 o2 o1 o2 o1 os o1 osnumber of bugs15 a gcc optimization levels o3 o2 o3 o2 o1 o2 o1 os o1 osnumber of bugs12 b llvm figure in uence of optimization levels mization options at certain optimization level.
this conclusion indicates that it is necessary to test a compiler under di erent optimization levels.
finding as some compiler bugs are only triggered by lower optimization levels alone it is necessary to test a compiler with various optimization levels.
.
threats to v alidity .
threats to internal validity the threats to internal validity mainly lie in the implementation of the compiler testing techniques.
first because the implementation of emi especially its pro le and mutate strategy is not available we implemented this technique using the same tool libtooling library of clang7 as le et.al used.
furthermore the number of variants and the deletion probability may also a ect the e ectiveness of emi we will explore their e ect in future.
second when implementing rdt we simply regard icc as a golden compiler although it may happen to contain the same bug as gcc or llvm.
to reduce this threat in our study we turned o the optimization features of icc when compiling test programs using icc because it is safer when optimizations are disabled .
.
threats to external validity the threats to external validity mainly lie in subjects and test programs.
subjects.
in this study we use two c compilers i.e.
gcc and llvm as subjects.
nevertheless the two compilers already cover all the c compilers used in existing studies of compiler testing .
in addition since csmith was used to nd bugs in gcc and llvm before the compilers used in our paper may have already acquired a certain amount of immunity to test programs generated by csmith which may have an impact on the e ectiveness of these techniques.
however all the three techniques are fed with the same test programs generated by csmith thus the threat may not be serious.
test programs.
in this empirical study we use only the test programs generated by csmith as the inputs to compilers.
in the previous work on compiler testing in addition to these generated programs compiler test suites and existing open source projects are used in compiler testing.
we do not use them in our study because compiler test suites are ine ective in detecting bugs in released compilers open source projects usually contain code with unde ned behavior and it is di cult to determine whether the detected abnormalities are bugs.
.
threats to construct validity threats to construct validity mainly lie in the con gurations of rdt and emi the measurement of experimental results the randomness in our experiments and the testing period of our experiments.
con gurations of rdt and emi.
in this study when testing compilers using rdt and emi we use ve optimization levels of the compilers under test and emi generated eight variants for each test program.
these con gurations may in uence the e ectiveness of these techniques.
in order to reduce this threat we set these con gurations of rdt and emi according to prior work .
measurement.
in our study we measure the e ectiveness of compiler testing techniques based on the number of correcting commits.
although this automatic approach facilitates a systematic empirical study on compiler testing the identi cation results may not be very precise.
that is the test programs that detect di erent bugs may be regarded as detecting the same bug in our study if these bugs are corrected in the same commit.
to verify the severity of this threat we check all the commits that we used in our study and nd that commits state explicitly which bugs are xed by them and each commit of them xes only one bug.
that is the threat may not be a serious threat in our study.
in the future we will use those known bugs to provide complementary evaluation in order to reduce the threat of our new measurement.
randomness.
the randomness i.e.
randomly generated test programs in our experiment may have an impact on our conclusions.
to reduce this threat we adopt an extended period of testing time and repeat the experiments.
for all the experiments except table we adopt an extended period of testing time i.e.
hours on each testing technique to o set the randomness threat because in our experimental settings adopting an extended period of testing time is equivalent to repeating the experiments.
for the results in table we repeat this experiment to reduce the threat of randomness.
based on ve runs the conclusion from table still holds in all runs and we select one of these runs as the representative.
testing period.
some testing techniques have been applied to extremely long periods of testing.
for example emi has been used in testing the trunk version of c compilers for months .
here is a question whether our results obtained from hours of testing can be generalized to extremely long periods or not.
we do not have a de nitive answer to the question yet.
however some trends can be observed from figure .
on the increasing rate of detected bugs from gcc rdt is obviously slower than emi and dol while no obvious di erence can be told between emi and dol.
in the case of llvm emi is obviously slower than dol and rdt while no obviously di erence can be told from dol and rdt.
.
discussion .
about optimization based on section .
e ciency has the most signi cant impact on the e ectiveness of compiler testing.
the higher the e ciency is the larger the number of detected bugs is.
that is to improve the e ectiveness compiler testing techniques should be designed to deal with as many test programs as possible in any given period of time.
we further analyzed the three compiler testing techniques and found 188that optimization levels in uence their e ciency a lot.
the more optimization levels are used the fewer test programs can be used in any given period of time.
that is using many optimization levels seems to harm the e ectiveness of compiler testing.
however due to the conclusion in section .
using all the optimization levels is preferable considering bug detection.
that is there is a dilemma in the choice of optimization levels.
therefore in the future we need to nd some combinations of optimization levels to maximize the e ectiveness of compiler testing.
.
about inherent factors of compiler testing techniques besides the widely concerned test oracles emi presents a new type of test programs which are variants generated based on existing test programs.
based on the preceding analysis these variants are less e ective than randomly generated programs but the former can still detect some unique bugs.
that is being a new type of test programs variants can serve as a complement to randomly generated test programs.
furthermore we nd both rdt and dol oracles are stronger than emi using rdt oracle or dol oracle as guide generating test programs aiming at speci c test oracle may be an e ective way of improving the e ectiveness of compiler testing.
besides as e ciency is more important for compiler testing than generated test programs and oracles compiler testing techniques should be designed to support the execution of more test programs in any given period of time.
in the future we need to explore how to balance these factors to improve the e ectiveness of compiler testing through the generation or optimization of test programs.
.
about practical usage our ndings suggest that in practice we could use all the three techniques to test compilers in the order of dol rdt and emi because dol is the most e cient technique and rdt is the second e cient technique and both rdt and emi can detect unique bugs.
.
related work the most relevant work are the studies about compiler testing.
yang et al.
and le et al.
investigated the e ectiveness of rdt and emi respectively and both of them analyzed compiler bugs in detail but they focused on only one compiler testing technique.
lidbury et al.
evaluated the e ectiveness of rdt and emi but they focused on a small domain of dedicated compilers opencl compilers.
in our work we present a systematic and comprehensive empirical comparison of all the three compiler testing techniques i.e.
rdt dol and emi on two mainstream open source c compilers i.e.
gcc and llvm and propose a new measurement correcting commits.
besides test program generation is also an important aspect in compiler testing.
when applying di erential testing to compiler testing one of the main challenge lies in the generation of test programs.
according to the survey conducted by boujarwah and saleh a large amount of work focuses on generating test programs to facilitate compiler testing.
mckeeman proposed to construct new c programs by adding or deleting some elements in di erent levels to any given c program.
to our knowledge his work is the rst to emphasize the importance of avoiding unde ned behavior in generated c test programs for testing c compilers.
however his work cannot generate c programs without unde ned behaviors.
bazzichi and spadafora proposed to generate programs through a tabular description of the source language.
hanford proposed to use a pl grammar to generate programs randomly.
kalinov et al.
proposed an approach to generating compiler test suite automatically based on several coverage criteria.
zhao et al.
developed an integrated tool jtt driven by test speci cation to automatically generate programs to test uniphier an embedded c compiler.
nagai et al.
proposed to generate c programs which contain randomly generated arithmetic expressions and successfully avoid unde ned behaviors to test c compilers arithmetic optimization.
lindig proposed to use randomly generated c programs to test the consistency of c compilers.
his tool quest is type directed and can be controlled by the user rather than depends on control ow and arithmetic.
sheridan proposed to test c99 compilers by comparing the behaviors of randomly generated programs using c99 compilers and using pre existing tools.
in addition sauder proposed to test the logic of the cobol compiler by placing random variables in the data sections of the programs.
pa lka et al.
proposed to randomly generate lambda terms to test an optimizing compiler which mainly addresses the type correct issue in generation.
callahan et al.
proposed to test the e ectiveness of vectorizing compilers by a collection of fortran loops.
recently csmith is proposed and implemented to randomly generate c programs without unde ned behavior for testing c compilers.
unlike random di erential testing le et al.
proposed to generate some equivalent variants for each test program and detect bugs by comparing their behaviors.
similarly tao et al.
proposed to detect bugs by comparing the behaviors of several programs whose metamorphic relation is equivalence relation.
recently le et al.
proposed an advanced emi to detect compiler bugs by using more mutation operations for test programs and by introducing markov chain monte carlo mcmc optimization to explore the search space.
furthermore le et al.
proposed to detect bugs of link time optimizers by randomized stresstesting and reported bugs.
besides in order to detect compiler bugs earlier chen et al.
proposed a test vector based approach to prioritize test programs for compilers.
.
conclusion this work is a systematic and comprehensive empirical study that compares di erent compiler testing techniques rdt dol and emi.
from our study we obtain some interesting ndings.
for testing compilers containing optimizationrelated bugs dol is more e ective and for testing compilers containing other types of bugs rdt is more e ective.
in addition there are three factors that in uence the e ectiveness of compiler testing namely e ciency strength of test oracles and e ectiveness of generated test programs and their impacts are statistical signi cant.
in particular dol is the most e cient technique whereas emi is the least e cient one rdt oracle is the strongest whereas emi oracle is the weakest the randomly generated programs are more e ective than variants generated by emi.
.