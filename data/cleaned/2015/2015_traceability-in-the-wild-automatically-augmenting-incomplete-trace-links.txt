traceability in the wild automatically augmenting incomplete trace links michael rath1 jacob rendall2 jin l.c.
guo3 jane cleland huang2 patrick m der1 technical university ilmenau ilmenau germany1 university of notre dame south bend usa2 mcgill university montreal canada3 michael.rath patrick.maeder tu ilmenau.de jrendal1 janeclelandhuang nd.edu jguo cs.mcgill.ca abstract softwareandsystemstraceabilityiswidelyacceptedasanessential element for supporting many software development tasks.
today s versioncontrolsystemsprovideinbuiltfeaturesthatallowdeveloperstotageachcommitwithoneormoreissueid therebyproviding the building blocks from which project wide traceability can be established between feature requests bug fixes commits sourcecode and specific developers.
however our analysis of six open sourceprojectsshowedthatonaverageonly60 ofthecommits were linked to specific issues.
without these fundamental links the entiresetofproject widelinkswillbeincomplete andthereforenot trustworthy.
in this paper we address the fundamental problem of missinglinksbetweencommitsandissues.ourapproachleverages acombinationofprocessandtext relatedfeaturescharacterizing issuesandcodechangestotrainaclassifiertoidentifymissingissuetags in commit messages thereby generating the missing links.
weconductedaseriesofexperimentstoevaluateourapproachagainst six open source projects and showed that it was able to effectively recommend links for tagging issues at an average of recall and precision.
in a related task for augmenting a set of existing tracelinks theclassifierreturnedprecisionatlevelsgreaterthan in all projects and recall of .
keywords traceability link recovery machine learning open source acm reference format michael rath jacob rendall jin.l.c.guo jane cleland huang patrick m eder.
.
traceability in the wild automatically augmenting incompletetracelinks.in proceedingsoficse 40thinternationalconferenceon softwareengineering gothenburg sweden may27 june3 icse pages.
introduction traceabilityprovidessupportformanydifferentsoftwareengineeringactivitiesincludingsafetyanalysis changeimpactanalysis test permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
selection and coverage analysis .
its importance has long been recognized in safety critical domains where it is often a prescribed part of the development process .
while traceability is relevant to all software development environments the effort needed to manually establish and maintain trace links in non regulated domains has often been perceived as prohibitively high.
however withtheubiquitousadoptionofversioncontrolsystems such as git andgithub and issue tracking systems such asbugzillaorjira ithasbecomecommonpracticefordeveloperstotagcommitswithissueids.inlargeprojects suchasthe onesfromtheapachefoundation thisprocedureisreflectedinthe guidelines which state that you need to make sure that the commit message contains at least a reference to the bugzilla or jira issue .
creating such tags establishes explicit links betweencommitsandissues suchasfeaturerequestsandbugreports.
however theprocessisnotperfect asdevelopersmayforget or otherwise fail to create tags when they make a commit .
whilethepracticeoftaggingcommitshasbecomepopularinopen source projects it is conceptually applicablein any projectwhere version control systems and issue trackers are used.
in this paper we propose a solution for identifying tags that are missing between commits and issues and augmenting the traceability data with these previously missing links.
as shown later in the paper our observations across six oss showed that an average of only about of commits were linked to specific issues.
the majority of papers addressing traceability in oss have focused on directly establishing a complete set of links between issues and source code.
in contrast we focus on generating the missing links atthecommitlevel.thishastheprimaryadvantageofproviding traceabilitysupportwithinthenaturalcontextinwhichdevelopers are creating trace links.
our approach leverages existing tags as well as information related to the commit process itself and also textualsimilaritiesbetweencommitmessages issuedescriptions and code changes.
we use these attributes to train a classifier to identify tags that are missing from commit messages.
furthermore we set a critical constraint on our work that the classifier must be populated trained andthenutilizedwithasimple buttonpress in order to make it practical in an industrial setting.
lowlevellinksbetweencommitsandissuesprovidethebuilding blocks for inferring project wide traceability between improvements bug reports sourcecode test cases and commits andalso allow associationsto be established between theissues and developers .
augmenting the set of trace links between commits and issues therefore results in a more complete set of project wide trace links.
this enables more accurate support for tasks such as acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. rath et al.
issue id groovy type improvement summary bytecode optimizations make use of ldc for class literals description class literals are currently loaded using generated get class methodswhichincreasebytecodesizeandmaypreventsome optimizations.
in most situations though we may use the lcd bytecode instruction to load the class literal.status closed created dec resolution fixed resolved jan figure example of an improvement in jira issue tracker defect prevention change impact analysis coverage analysis and even provides enhanced support for building recommendation systems to identify appropriate developers for fixing bugs .
we train and evaluate our approach on six open source projects in order to address three key research questions rq1 is the link classifier able to accurately reconstruct issue tags during the commit process?
rq2 isthelinkclassifierabletopreciselyaugmentanexistingset of incomplete commit to issue links in a fully automated way?
rq3 is the link classifier able to recommend additional tags?
the remainder of the paper is structured as follows.
section introduces the artifacts case projects process model and stakeholder model that form the fundamentals of our approach.
section describes the elements of our classifier.
section describes thesixprojectsinourstudy.sections5and6describescenariosand experiments associated with recommending tags for commits augmentingexistingsetsoftracelinks andconstructingtracelinksfor commits with no tags.
finally sections to discuss related work threats to validity and conclusions.
fundamentals we first introduce a motivating example and describe the artifacts projectenvironments andtheprocessandstakeholdermodelsthat form the fundamentals of our approach.
.
motivating example figure1depictstheimprovementrequest groovy 1retrieved from the groovy project s issue tracker jira .
the request consists of a unique issue id a short summary a longer textual description time stamps for issue creation and resolution the issue s currentstatus andinformationaboutitsresolution.thisparticular improvement requests an enhancement to an existing feature concerningclassloadingatbytecodelevel.figure2showsabugreport groovy 50822forthesameproject.itincludesthesamefieldsas the improvement except that the type is specified as a bug.
in this case thebugdescribesaproblemwithbytecodegenerationforthe groovy language.
finally figure shows an example of a commit3 submittedtothegit versioncontrolsystem.acommit change set includes a unique commit hash value a message describing its purpose thetimestampwhenitwassubmitted andfinallyalist of files modified by the change set.
id groovy type bug summary sometimesinvalidinnerclassreference left in .class files produced for interfaces description compilethis uponjavap ingtheresultweseethis innerclass attribute ...to x .
but there is no x produced on disk.... status closed created oct resolution fixed resolved feb figure example of a resolved bug in jira issue tracker hash b1bb2abfde414950238ff4d895bf5e182793500a message grovy removesyntheticinterfaceloadinghelper class in case it is not used committed feb files src main org codehaus groovy classgen asmclassgenerator.java figure example for a commit in git the common way to establish a trace link between a commit and an issue is by placing the unique issue id i.e.
groovy inthisexample intothebeginningofthecommitmessage.however acloseexaminationofthecommitmessageinthisexample shows that the committer made a subtle mistake and misspelled theissuekeyforthebugthatwasbeingfixed omittingan o .asa result traditional trace link construction techniques that rely upon matching the key to an issue will fail to create a trace link.
however even without a valid issue key there are numerous clues to suggest that the commit should be associated with the reportedbug.first thebugdescriptionexhibitstextualsimilarity to the commit message as well as to the text in the changed file asmclassgenerator.java .
second the commit was submitted on thesamedatethattheissuewasresolved andfinally theperson obfuscated for privacy reasons who submitted the commit was also responsible i.e.
the assignee for resolving the issue.
taken together these observationsprovide somedegree ofevidence that thecommitandbugshouldbelinked.thisexampleilluminatesthe thinkingbehindourproposedsolution.webuildaclassifierthat leverages all of this information plus additional attributes to learn which issues should be tagged to each specific commit.
.
software artifacts and their relations whileversioncontrolsystemsandissuetrackershaveseveraltypes of artifacts our approach leverages three of them to construct missingcommitlinks.theseare issues commits i.e.
changesets andsource code files.
issues ourmodelusesissuescollectedfromthejiraissuetracking system.
while there are several types of issues we focus on improvements andbugswhicharethemostcommonlyoccurring ones.animprovementrepresentsanenhancementtoanexisting feature in the software while a bug describes a problem which impairsorpreventsitscorrectfunctionality.intheremainderofthe paper theterm issueisusedinreferenceto bothimprovementsand bugs.independentoftheiractualtype allissuessharethefollowing properties a unique issue id asummary providing a brief one line synopsisoftheissue andamoreextensiveexplanationprovided in thedescription.
further every issue has a temporal life cycle it iscreatedat a given point in time and later resolved and may be assigned to an author responsible for its resolution.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
traceability in the wild augmenting incomplete trace links icse may june gothenburg sweden issue i commit c file legend artifact trace containmentbug improvement source code file f generalisation figure studied artifact model with issues i commits c source code files f and their relations.
commit change set ingitversioncontrol changesareorganizedasatomic commits.acommitbundlestogetherallmodified files and is uniquely identified by a hashvalue.
it includes propertiesconcerningthepersonwhomadethechange atimestamp committeddate and acommitmessagestating thepurposeof the change.
sourcecode multipletypesoffilesareassociatedwithasoftwareprojectincluding sourcecodefiles documentation examples andtests.
in this paper we focus on source code files which are explicitlylinkedtocommitmessages.thesourcecodefilesprovide support for our primary goal of establishing links between commit messages and issues.
relations wearealsointerestedinrelationsbetweenthethree fundamentaltypesofartifactsinourmodel.acommitatomically bundlesoneormoresourcefilestogether.thiscontainmentrelationbetweencommitandsourcecodeartifactsisanaturalresult of submitting the change set to the version control system.
further as previouslyexplained trace linksare explicitly createdbetween issuesandcommitswhenadevelopertagsacommitwithavalidissueid.wedenoteanissueas linked ifthereisatleastonetracelink fromtheissuetoacommit.issueswithoutanylinksaretermed non linked.figure4depictsthethreeartifactsaswellastheirstructuralinteractions.wedenote i ibu iimpasthesetofissues bugs and improvements cthe set of commits and fthe set of source code files in a project.
the function is linked c i returns if an explicit link exists and otherwise.
the function mod c c fcwithfc f c c calculates this set for a given commit.
a source code file may be part of multiple commits.
.
studied projects forourstudy weselectedsixprojectsfromdiversedomains that utilizedbothgitandjira.theyincluded buildautomation maven ma databases derby de infinispan in languages groovy gr pig pi and a rule engine drools do primarily selected becauseeachoftheseprojectshasexistedforseveralyears hasa non trivialnumberofcommitsandissues andlargelyfollowedthe practice of tagging commits with issue ids.
we analyzed each of the projects to gain an understanding of the numbers of links that existedbetweencommitmessagesandissues.further weanalyzed the number of issues that were linked to exactly one commit two or more disjoint commits n or had no links.
results are reported in table .
for example of the bug related issues in the derby project were linked to only one commit were linkedtomultiplecommits and1 272hadnoassociatedcommits.table1 existingbugandimprovementtocommitlinkcharacteristics in the studied project.
project link type profile de dr gr in ma pi 1bug imp.
nbug imp.
nonbug imp.
table2 existingcommittobugandimprovementlinkcharacteristics in the studied project.
project link type profile de dr gr in ma pi 1bug 1206imp.
n both non across all of the projects approximately .
of improvements and .
of bugs have no commits associated with them.
table depicts a similar analysis from the perspective of the commits.
it reports the number of commits with links to issues for the selected projects.
again we analyzed the distribution of 1links nlinksandnonlinkedcommits.inthederbyproject of the commits linked to only one bug to onlyone improvement linked to multiple bugs or improvements and553 commitshad nolinks.
however acrossallof theprojects approximately of the commits were not linked to any issue.
furthermore there was significant variance across the six projects withonly15 ofcommitsinderbyhavingnolinkscomparedtoapproximately of unlinked commits in maven.
clearly different practices exist across different projects leading to huge disparities in the extent to which issue tags are added to commit messages.
oneoftheprimarygoalsofourwork istoestablishatleastone linkforeachcommit.asthemajorityofcommitslinktoasingle issue we only attempt to generate links for currently unlinkedcommits.
for commits without links there are two viable cases first that an appropriate issue exists and a link can be generated and second that no appropriate issue exists for the commit.
.
process model as previously explained our approach leverages clues from the developmentprocesstoaidinthegenerationoflinks.firstweobserve thatthesoftwaredevelopmentprocessistimedependent bugsandimprovementsareconstantlycreatedandresolved andcommitsare submittedto theversion controlsystem.
figure5 exemplifiesthis scenario.
it contains six issues i i1...i4 b1 b2 nine commits c c1...c9 andsixsourcecodefileartifacts f f1...f6 .
theissueartifactsandcommitsareorderedacrossatimeline.inthis example theissues i1 i2 i4 b1 aswell ascommits c1 c5 c8 and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. rath et al.
issue i1 issue i2issue i3 bug b1 issue i4file f1 file f2 file f1bug b2file f3 file f5 file f6 file f4 file f6 file f1 file f3 file f2file f1 file f6 file f1file f4 file f6file f502 c1 c2 c3 c4 c5 c5 c6c7 c8c9tlegend issue artifacts commit artifact source code file artifact explicitly created trace link containment link figure temporal and structural relations between issue i commit c and source code file f artifacts.
c9are linked e.g.
is linked c1 i1 .
the figure also shows the relationbetweenissuesandcommitsaccordingtothetimeline.we definethefunctions created i nandresolved i n i i which returns the point in time when the issue was created and respectivelyresolved.duringthistime theissueisconsideredto be unfinished and source code modifications are required in order to implement the improvement or fix the bug.
in our study we focusonissuesthatareresolved e.g.
infigure5 created i1 andresolved i3 .
the function committed c n c c returns the time stamp at which a commit was submitted to the version control system.
e.g.
committed c6 in the example.
temporal relations consideringanonlinkedcommit c c the temporal structure imposes several constraints on the possible link candidates i i. the following three cases exist.
committed c created i duetocausality thecommit cis not considered to be a link candidate for i e.g.
in figure c2 is not a link candidate for i2 .
created i committed c resolved i this situation depicts the usual development work flow.
after issue creation the developers modify the source code and submit commits in ordertoresolvetheissue.thesecommitsaretracedtotheissue.
eventually theissueisresolved andinthisexample nofurther commits are made to the issue e.g.
in figure the non linked commitc6is a link candidate for i3 .
resolved i committed c intuitively inthissituationatrace link from ctoiis not considered since iwas already resolved before the commit occurred.
however this situation is notuncommon as table shows.
the obvious reasons might be thatadeveloperforgottosubmitthecommitbeforeresolving theissue.anothermightsimplybeclockdifferencesbetween the unconnected decentralized systems used by jira and git which prevents strict time comparisons.
in project derby there is sometimes a large discrepancy betweenthetimeatwhichanissueisresolvedandthelastcommit thattraces toit.
forexample theimprovement derby was resolved as fixed on mar yet on apr a commit 78227e45 was submitted and linked to this improvement.
howeverthisscenarioisquiterare affectingonly136commits.
interestingly in both the groovy and maven projects the median time difference for late commits is much lower only hours but affectsa huge numberof commits.
for example in commits linked to issues after issues resolution along withthemediantime.
theaveragefileoverlapofconsecutivecommits linked to the same issue.
project de dr gr in ma pi commits linked to already resolved issues number median time after resolved 150h 60h 5h 19h 5h 60h avg.
file commit overlap .
.
.
.
.
.
themavenproject weobservedthatbetween2005and2015therewasaconstantoffsetbetweenissueresolutionandcorrespondingcommitfromeitherfiveorsixhoursasillustrated inmng from2005 mng from2008 and mng from .
these temporal constraints limit the potential pairs of candidate linksbetweennonlinkedcommitsandnonlinkedimprovements and bugs.
structuralrelations table2reveals inrow1 n thatoftenmultiple commits ca cb ...are required in order to solve an issue i. ideally all of these commits are traced to the respective issue.
however oftenonlyonecommitinthisseriesisexplicitlylinked toi.in theothercommitsinthisseriesaretermed phantoms.
all commits in the series may share commonalities.
in addition to their succession in time the commits may modify a similarset of source code files since they are related to the same issue.
we define a function overlap ca cb mod ca mod cb max mod ca mod cb withca cb c. for example in figure the overlap of c1 and c2i soverlap c1 c2 andoverlap c3 c4 .
as shown in table the average overlap of consecutive commits linked to thesameissuevariesamongtheprojects.forexampleinderby the average overlap is .
meaning that on average one out of threefilesarethesameforcommitsinaseries.thehighestnumber .
is achieved in groovy where a few files are changed multipletimestoimplementanimprovementorbug.threecommits 51d4fee7 3d207378 and 974c9459 weresubmittedbetween jan 2009and6 jan 2009allmodifyingoneandthesamesource authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
traceability in the wild augmenting incomplete trace links icse may june gothenburg sweden codefile defaultgroovymethods.java andlinkedtoimprovement groovy .
this results in overlap for each commit pair in the series.
based ontemporal closeness and overlap thereare indications thatc2andc1maybelongtoaseriesofcommitsandthuscouldbe tracedto i1.thesituationmayalsooccurforwardintime i.e.
c7 andc9maybelongtoaseriesbecauseoftemporalclosenessand source file overlap and thus should be traced to bug b1.
.
stakeholder model issuesandcommitartifactsbothcarryinformationabouttheauthor.
the assignee of an issue also might be the person who contributes commits in solving the issue.
in the studied scenario there is no technicalconnectionbetweentheissuetrackerjiraandtheversion controlsystemgit.thuswecannotrelyonanavailablestakeholder model.
therefore we applied the following approach to identify individual developers in both systems.
in each system a developer isrepresentedbyanameandalogin nicknameoremail .inthefirst step weseparatelycollectedalldevelopersfromthetwosystems andbuilttwogroups.inthisstep wemergednamesiftheyusedthe sameloginandthereforewerealiasesforthesameperson.inthe secondstep weheuristicallymergedthetworesultingdeveloper lists and compared the names in order to identify the same person inbothsystems.inordertofullyprotectuserprivacyandtocomply withgithubprivacyrequirementsauniquenumber userid was assigned to every developer.
the function userid u nwith u c ireturns this user id for a given commit or issue.
the link classifier our goal was to create a classifier that could identify issues associated with a commit.
the classifier was therefore trained to predict whether any issue commit pair should be linked or not.
.
attributes of the commit issue relation based on the artifact model introduced in the previous section weidentified18attributesperinstance.theseattributesfallinto twocategories process relatedinformationandtextualsimilarity between artifacts using information retrieval techniques.
process related attributes weconsider thefollowing16process relatedfactorsto modelthe relationship between commits source code files and issues.
these factorscapturestakeholder related temporal andstructuralcharacteristics of the candidate pair c i withc c i i stakeholder relatedinformation a1... wecapturetheidentities of the committer as a1 userid c and the assignee of the issuesasa2 userid i .additionally wemarkedasabinaryattribute whether the two are identical as a3 ifuserid c userid i otherwise .
temporalrelationsbetweenissueandcommit a4... based on temporal properties of issue and commit we calculated a4 committed c created i anda5 resolved i committed c .
additionally wecaptureas a6whethercreated i committed c i.e.
whether cwas committed during the active development time of i. furthermore we capture close commits in relation to issue resolution as a7 a5 .w es e t .
days derived from observing that late commits occur on average within and hours of the issue resolution for the studied projects see table .
for example in figure the pair c6 i3 yieldsa4 a5 anda6 .
closest previous linked commit a8... wecapturetheset of previous commits linked to iascprev cx is linked cx i committed cx committed c .ifnon empty thecommit cp cprevwith the largest commit time stamp is taken and used to calculatea8 committed c committed cp a9 overlap cp c anda10 userid cp .
for example in figure the pair c2 i1 yieldscprev c1 and thuscp c1 a8 anda9 .
closest subsequent linked commit a11... analogous to theclosestpreviouslinkedcommit wecapturesubsequentcommits cnext.wecapture cnext cx is linked cx i committed c committed cx and selected cnwith the minimal commit time to calculatea11 committed cn committed c a12 overlap cn c anda13 userid cn .
for example in figure the pair c7 b1 yieldscnext c9 cn c9 a11 anda12 .
number of issues and existing links a14... we calculate the set of existing issues at time committed c iexist ix created ix committed c resolved ix ix i and capture its cardinality as a14 iexist .
takingiexist we deriveiuser ix ix iexist userid ix userid i representing non resolved issues for the assignee of iat that instant in time and captureitssizein a15 iuser .witha16 cx is linked i cx committed cx committed c cx c we capture the numberoflinksto ibeforecommit c.forexampleinfigure considering pair c7 b1 iexist b1 i3 i4 and thusa14 .
textual similarity attributes we leveraged information retrieval methods to compute textual and semantic associations betweencommit messages source code files and issues.
we explored three primary techniques for computingtextualsimilarity sim.thesewerethevectorspacemodel vsm vsmwithn gramenhancements vsm ngram andlatent semantic indexing lsi .
inthevsmmodel eachdocument i.e.
commitmessage issue description and source code file is treated as an unstructured bag of terms.
following common information retrieval techniques documents are pre processed to remove stop words to stem wordsto their morphological roots and to split camel case and snakecasewords e.g.
optionsparservs.options parser intotheirconstituent parts.
each document dis then represented as a vector vecd w1 d w2 d ... wn d wherewi drepresents the term weight associated with term ifor document d. each term tis assigned a weightusingastandardweightingschemeknownas tf idf .
thecosinesimilaritybetweenapairofvectorsinthencomputedas follows in order to estimate the similarity between two documents d1 and and d2 sim d1 d2 summationtext.1n i 1wi d1wi d2 parenleftbig radicalbig summationtext.1n i 1wi d1 radicalbig summationtext.1ni 1wi d2 parenrightbig authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. rath et al.
then gramenhancementtovsmutilizesn grammodels .
n gramisacontiguoussequenceof nwordsinadocument.each document is again represented as a vector but in this case the vectoriscomprisedofboththewordandthen gramsitcontains.
thedocumentsarepreprocessedinthesamewayasthebasicvsm.
based on initial experimentation we set nfrom to to include 2gram gramand gramsequences inthe vectorrepresentations.
the similarity between vectors was again calculated using the cosinemeasure equation withtf idfschemaasdescribed above.
weconductedaninitialcomparativestudyoflatentsemantic indexing lsi vsm andvsm ngram.basedonaninitial comparisonoftheresultsweselectedthevsm ngramapproachfor computing textual similarity scores.
this was because we observed thatvsm ngramoutperformedvsmonourdatasets andranmuch fasterthanlsi.infact thecomputationtimeoflsionourdatasets was prohibitively slow with runtimes of up to hours in some cases and so we rejected it as impractical.
furthermore several previous studies have shown that vsm tends to either outperform lsionsoftwareengineeringdatasetsorperforminequivalentways .
a detailed comparison of trace retrieval techniques withinourclassifierisoutsidethescopeofthisresearch.therefore basedonourinitialanalysis wechosevsm ngramtocomputethe following similarity attributes textual similarity of a commitand an issue a17 thesimilaritybetweenthecommitmessageandthetextualcontentoftheis sue forbothimprovementsandbugs iscapturedas a17 sim c i withc c i i. textualsimilarityofcommittedsourcefilesandanissue a18 for each commit issue pair the textual similarity between the content of the most similar committed source code file and the textualcontentoftheissueiscapturedas a18 max sim f i f mod c c c i i. .
studied attribute sets we studied the impact of the presented attributes in four subsets.
process this set solely contains the process related attributes i.e.astructure a1...a16 .itstudiestheimpactofallprocessrelated attributes without considering textual similarity.
similarity this set consists of the attributes asim a6 a17 a18 .
it solely considers textual similarity betweencommitandissuegiventheconstraintthattheissueexisted at the time of the commit.
all thisset aall a1...a18 containsallprocess similarity and stakeholder related attributes.
auto this set aauto aall addresses potentialcorrelations and dependencies among attributes.
it contains an automatically selectedsubsetderived byconsideringtheindividual predictive ability of each attribute along with the degree of redundancy betweenthem.weimplementedtheredundantattributeremoval process based on weka s inbuilt auto selection feature .
.
dataset profiles and splits weaimtoclassifylinksbetweencommitsandimprovementsand between commits and bugs.
we therefore construct two distinct profilesforeachproject constructedfromprocessandsimilarityattributes per commit issue pair.
profilep sp train sp test p bu imp each profile consists of a distinct training and a testing set.
we appliedthefollowingprocedure perprojecttocreateinstancesof candidatecommit issuepairsforthetrainingset sp trainaswell as the testing set sp test.
sp t c i is candidate c i c cp t i ip t p bu imp t train test with the function is candidate defined as is candidate c i created i committed c committed c resolved i the function limits the number of candidate commit issue pairs accordingtocausality.alinkcandidateisneverconsideredbetweenacommitiftheissuehasnotbeencreatedatthetimeofthecommit.secondly assuresthatacommitisnotunboundedlyconsideredas a candidate for issues resolved in the past.
based on an analysis of commitsontoclosedissues seetable3 wefoundthatthemedian commit time after the issue has marked resolved was between and hours for the studied projects and we decided to choose as hours.
the candidate sets cp tandip twere then created as cp train c committed c tsplit c c ip train i resolved i tsplit i ip cp test c committed c tsplit p bu imp ip test i created i tsplit .
the parameter tsplitdefines the point in time which splits the training and test set.
we choose a split and cal culated tsplitas follows.
first we ordered the improvements in the respective project according to their creation date in ascend ing order.
we selected the improvement isplit iimp which dividesthissequenceinto80 and20 ofallimprovementswhere tsplit resolved isplit i.e.
the resolution time of of all improvements.
each commit issue candidate in the profiles profilebu and profileimpforms an instance to train sp train or test sp test theclassifier wherethetestdata i.e.
ineveryproject isdistinctfromthetrainingdata.foreachinstance wecalculate18attributes a1...18that characterize the relation between commit and issue.
in addition eachinstanceisannotatedwiththeknownclass i.e.
linked ornon linked asextractedfromtheprojects data.
linkedmeans thatthedeveloperhadcreatedanexplicittagfromthecommitto the issue while non linked means that no such tag exists.
.
classifier training weinvestigatedthreedifferentsupervisedlearningclassifiersfor categorizing commit issue pairs as linkedornon linked.
these were n ive bayes j48 decision tree and random forrest.
we includedn ivebayesbecauseeventhoughtheassumptionofindependence rarely holds in software project data the algorithmhas been demonstrated to be effective for solving similar prediction problems .
we utilized weka s j48 decision tree with default pruning settings because of its previously reported effectivenessinothersoftwareengineeringstudies .finally we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
traceability in the wild augmenting incomplete trace links icse may june gothenburg sweden includedtherandomforestclassifierbecauseithasbeenshown to be highly accurate and robust against noise although it can be expensive to run on large data sets.
the profiles we created were severely unbalanced containing many more instances of non links thanlinks.
training against such unbalanced sets makes it likely that the classifier will favor placing instances into the majority class i.e.
in this case classifying all pairs asnon links .
we performed all experiments using weka andusedtheinbuiltsub samplingfeaturetocreatebalanceddata sets.
given a fixed number of explicit links weka randomly selects the same number of non links.
we trained each classifier in turn usingthebalancedsets sbu train andsimp trainforeachproject and then evaluated the classifier against the respective unbalanced testingsets sbu testandsimp test.tomitigatetherandomeffects of sub sampling we repeated the training and testing times and averagedtheachievedresults.wedidnotfollowanordinary10 fold crossvalidationapproachbecauseseveralofthestudiedvariables e.g.
attributes a4...a7 reflect temporal sequences in the development makingitnecessarytoensurethattemporalsequencing betweentrainingandtestdatawaspreserved.foreachtechnique the classifier returned a category i.e.
linked or non linked and also a score which we used to rank recommended links in order of likelihood.
data collection topreparethedatafortrainingandtestingtheclassifier weperformedatwostepdatacollectionprocessforeachofthesixprojects.
step analyzing project management and issue tracker system.we implementeda collectorto retrieveartifacts i.e.
improvements and bugs .
all six projects use the jira project management tool offering a web service interface.
our collector downloadedandparsedallartifacts.usingtheartifacttype wefiltered theartifactstoretrieve onlybugsandimprov ements.thereforewe appliedthefollowingmappingfromjiratypestoourmodel bug bug and improvement enhancement improvement.
in both cases the artifacts represented finished work i.e.
their status was resolved or closed and the resolution fixed or done .
step2 analyzingsourcecontrolmanagement scm system.asecondcollectorwasimplementedtodownloadallsource codechangesandcommitmessagesfromeachscmrepository i.e.
git .
we parsed the commit messages and applied the heuristic described in to retrieve existing trace links from commits to bugreportsandimprovementsbasedonsearchingandmatching the issue keys in commit messages.
given the goals of our trace ability experiment we excluded non source code files related to documentation and build automation based on their file name extensions.
additionally we analyzed file paths in order to exclude sourcecodefilesimplementingtestcases.inthestandardmaven directorylayout11 usedbyallsixofourprojectsprojects source files are placed in sub directories of src main and tests as subdirectories of src test java.
the results of these two steps were stored in an archive per project whichispubliclyavailable .datawerecollectedfrom each project until may 31th2017.
reconstructing known links weperformedatwo phaseevaluation.inthefirstphaseweaddress rq1 and rq2 by exploring two different usage scenarios.
the first uses the classifier as a recommender system to suggest a list of the most likely issues at the time a commit is submitted.
ideally this functionality would be integrated into the version control system and activated when the user presses the commit button.
in thisscenario high recall is imperative so that the relevant issue if itexists isincludedinthedisplayedlist.thesecondexperiment evaluatesthecase inwhichtheclassifierisusedto automatically augment an existing set of trace links for a project.
in this scenario high precision is essential because links that are automatically addedmustexhibithighaccuracy.inexperimentsrelatedtoboth ofthesescenarios weleveragedtheexistinglinkscreatedbythe projectdevelopersfromexplicitcommit issuetagsasan answer set totrainandevaluateourclassifiers.bothexperimentsthereforeevaluatewhethertheclassifierwouldhavebeenabletorecommend or create a known link if the committer had forgotten to create its tag manually.
we trained the three classifiers on the four attribute sets as described in section .
and section .
.
results were evaluated using commonly adopted traceability metrics.recallmeasures the fraction of relevant links that are retrieved while precision measures the fraction of retrieved links that are relevant.
finally f measure measures the harmonic mean of recall and precision .
we utilize two variants of the f measure namely f2which is weighted to favor recall and f0.
which is weighted to favor precision.
scenario1 recommendingissuestoassistcommits the goalofthisscenarioistocreateashortlistwithamaximumofthree recommended links to assist developers in tagging their new commits withissue ids.
thus we truncate theretrieved lists afterthe thirdrankandevaluateclassifierperformanceintermsofprecision recall andf2 measureatthispoint.f2 measureisselectedbecause theobjectiveofthisscenarioistoachievehighrecall.theresultsfor the best performing classifier random forest are shown in table .
the attribute set allachieves an average recall of and average precisionof33 whichincombinationmarksthebestperformance of the studied feature sets.
an application of the mann whitneyu test shows that the allapproach significantly p .
outperforms the other attribute sets in terms of f2score.
the other twoclassifiersalsoperformedbestwhenusingthe allfeaturessets.
however their achieved f2scores were significantly lower than that of random forest f2 .
for j48 and f2 .
for n ive bayes .generally thevaluesshowthattherandomforestclassifier is able topredict the onetrue link among thethree recommended links.theattributeset similarity exhibitsthelowest f2measure.
the feature set processperforms considerably well.
this is notable because it does not require resource intensive ir techniques to extractthenecessaryfeatures a17anda18.however addingthese features to the model results in overall better performance see theallattribute set .
an exception within the results is the derby project whichunderperformsonallattributesets.thelowrecall values indicate eg.
.
forprocess that the correct link is not in the ranked list for one out of two commits.
scenario2 fullyautomatedaugmentationoftracelinks between commits and issues the classifier performance for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. rath et al.
table trace recommender evaluation using the different attribute sets and random forest scenario similarity process auto all project profile p1r2f23pr f2pr f2 pr f2 derbybug .
.
.
.
.
.
.
.
.
.
.
.
improvement .
.
.
.
.
.
.
.
.
.
.
.
droolsbug .
.
.
.
.
.
.
.
.
.
.
.
improvement .
.
.
.
.
.
.
.
.
.
.
.
groovybug .
.
.
.
.
.
.
.
.
.
.
.
improvement .
.
.
.
.
.
.
.
.
.
.
.
infinispanbug .
.
.
.
.
.
.
.
.
.
.
.
improvement .
.
.
.
.
.
.
.
.
.
.
.
mavenbug .
.
.
.
.
.
.
.
.
.
.
.
improvement .
.
.
.
.
.
.
.
.
.
.
.
pigbug .
.
.
.
.
.
.
.
.
.
.
.
improvement .
.
.
.
.
.
.
.
.
.
.
.
precision1 recall2 f2measure3 table fully automated trace link augmentation using the different attribute sets and random forest scenario similarity process auto all project profile p1r2f0.53pr f0.5pr f0.
pr f0.
derbybug .
.
.
.
.
.
.
.
.
.
.
.
improvement .
.
.
.
.
.
.
.
.
.
.
.
droolsbug .
.
.
.
.
.
.
.
.
.
.
.87improvement .
.
.
.
.
.
.
.
.
.
.
.
groovybug .
.
.
.
.
.
.
.
.
.
.
.72improvement .
.
.
.
.
.
.
.
.
.
.
.
infinispanbug .
.
.
.
.
.
.
.
.
.
.
.78improvement .
.
.
.
.
.
.
.
.
.
.
.
mavenbug .
.
.
.
.
.
.
.
.
.
.
.74improvement .
.
.
.
.
.
.
.
.
.
.
.
pigbug .
.
.
.
.
.
.
.
.
.
.
.
improvement .
.
.
.
.
.
.
.
.
.
.
.
precision1 recall2 f0.5measure3 thesecondscenarioisevaluatedintermsofprecision recall and f0.5measure because the objective of this scenario is to achieve highprecision.resultsarereportedintable5fortherandomforest classifier whichperformedbest.afullyautomatedenvironment requires high precision thus we defined a project independent cut offpointbasedon score .
whichachievesaprecisionabove across all projects when using the allattribute set.
the otherclassifiers j48andn ivebayes wereunabletoachievethe requiredprecision.forrandomforest therecalldropsto50 on average as a consequence of required precision and thus only one out of two known links would be re created.
in project derby the recall for allis and similar values for the process and the autosets are achieved.
however the attributes set only containing textualsimilarity attributesperformsbest resultinginthe highest f0.5measure whichfavorsprecisionoverrecall.asintheprevious evaluation scenario structural attributes do not perform well on this project which is further discussed in the next section.
constructing unknown links the previous experiment was designed to reconstruct known links.
however therealvalueofourclassifierisinrecommendingtags for commits with no existing links.
while we have strong albeit notperfect confidencethattheexplicitlylinkedpairsofcommits andissuesarecorrectlylabeled howeverthenon linksconstituteacombination of true negative links i.e.
correctly labeled non links andfalsenegativelinks i.e.incorrectlylabelednon links .ofthese thefalsenegativesrepresentthe missinglinks thatwenowtarget.
thesemissinglinksresultfromcasesinwhichadeveloperfailed to associate a commit with an issue or created an incomplete set of tags.
previous studies have reported the difficulty of correctly classifying entities not represented in the original training set and we therefore need to evaluate the ability of the classifier to detect previously missing links.
since no answer set for the non linked commits is available we neededtoperformamanualinspectionoftheproposedlinks.as a sanitycheck wefirst evaluatedwhether itwould beplausible to classifylinksontheseunknownparts.inallsixprojectscommits with links are typically related to only one issue or to a very small number of them see table .
therefore we count the average numberofissuesclassifiedaslinksforeachofthecommitswithout any explicit link see table .
the classifier trained using attribute setallidentifiesanaverageof1 .54issuespercommitasacandidate link.
table and characterize the current linking situation in the studied projects.
based on these values we expect a value of .2linkspercommit.forexampleinprojectinfinispan there were commits linked to bugs and bugs linked to commits and thus .
commits per bug.
the ratio for improvementsis1 .
.however theclassifierproposes0 .69bugsper authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
traceability in the wild augmenting incomplete trace links icse may june gothenburg sweden table average number of classified links between issues and a non linked commit project profile similarity process auto all derbybug .
.
.
.
improvement .
.
.
.
droolsbug .
.
.
.
improvement .
.
.
.
groovybug .
.
.
.
improvement .
.
.
.
infinispanbug .
.
.
.
improvement .
.
.
.
mavenbug .
.
.
.
improvement .
.
.
.
pigbug .
.
.
.
improvement .
.
.
.
commit and .
improvements for every non linked commit.
that means that our approach is conservative.
for project derby our approachunderperformed.theexistingratioforlinkedcommits perbugis1675 .
asfortheotherprojects.but theclassifiersuggests4 .
.thismaystemfromtheimbalanceof non linked commits and non linked issues in the project.
there are 202nonlinkedissuesandonly553nonlinkedcommits.however thesameimbalanceofnonlinkedissuesandcommitsalsoexistsin project pig but in this context the classifier is unaffected.
thisanalysisshowsthatexceptforderby theclassifiednumber oflinksisplausible.however itisnotclearwhethertheselinksarecorrectlyclassified.toaccomplishthisgoalwemanuallyevaluated the correctness of a randomselection ofnew links proposed by the classifierusingthefollowingsystematicprocessforeachproject.
steps are independently performed by one researcher data preparer while steps are performed collaboratively by four additional researchers referred to as evaluators .
no communication wasallowedbetweentheresearchercreatingthedatasetandthe four evaluators during this process.
data set construction for missing links d1twenty commits without any explicitly tagged issues from the originaldatasetforagivenprojectwererandomlyselectedand randomly divided into two groups aandb.
were placed into group a and into group b. d2forcommitsingroup athemosthighlyrankedissueidwas selected as the candidate link while for commits in group b an issue tag that was not recommended by the classifier was selected.
group bwas added to mitigate evaluation bias and to ensure a mix of links and non links in the evaluation set.
d3arandomlyorderedlistofeachcommit issuepairselectedin the previous step was generated human evaluation of proposed links h1fourhumanevaluatorsworkedtogethertoclassifythefirstfive commit issuepairsfromonerandomlyselectedproject.they performedthistaskwithoutanyknowledgeofwhetherthelink was recommended by the classifier or not.
the evaluators then workedindividuallytoclassifythenextfivecommit issuepairs in the list.table links recommended to commits with no tags projectprofilel1nl2tp3fp4tn5fn6p7r8 derbybug .
.
imp .
.
droolsbug .
.
imp .
.
mavenbug .
.
imp .
.
links1 non links2 true positives3 false positives4 true negatives5 false negatives6 precision7 recall8 h2the fleiss kappa inter rater agreement was computed.
fleiss s kappa assesses the likelihood of more than two raters agreeing when classifying items into a set number of categories .
a kappa value of means that all raters are in agreement thoughavalueabove0.4indicatesstrongagreement.evaluators discussed results for commit issue pairs with the aim of achieving consensusin classifying the pair ashaving a link or not.
the fleiss kappa value for this evaluation was approximately0.
demonstratingthereliabilityoftheevaluators to agree on the link status between a commit and issue.
h3assatisfactoryinter rateragreementwasachieved theremainingpairsofcommit issuesweresplitamongsttheevaluators andallpairswereevaluated.thedecisionsmadebytheevaluators constitutes the answer set of previously unknown links against which the classifier is evaluated.
dueto thelaborintensive natureof thisanalysis we evaluated only three projects derby drools and maven.
recall and pre cision were computed by comparing the results returned by the classifier against the manually created answer set .
results obtainedforfortycommit issuepairsforeachprojectaresummarized in table .
resultsindicate thatall projectsexceptone returneda recallof i.e.
.
the exception was maven where recall of wasachievedforcommitto buglinks butonly50 forcommitto improvementlinks.inthiscase therewereonlytwotruelinks and oneofthemwasmissed.thismeansthattheclassifierfoundthe pair to be unconnected while the evaluator determined that a link didexist.
theprecisionreturned foreach ofthethree projectsfor both bugs andimprovement waslower than theprecision returned intheearlierexperimentswithexplicitlydefinedlinks.forexample inearlierexperimentsderby sprecisionwas0.30forbugsand0.
for improvements.
however these scores dropped to .
and .
respectively when the classifier was used to generate links for commits with no previously known issue tags.
similar trends were observedfordrools.however precisiondroppedconsiderablyfor maven returning .
for bugs but only .
for improvements.
a potential explanation for the poor precision result in the mavenproject is the fact that a majority of the commits represent code refactoring and in many cases were not associated with any issues at all resulting in several false positive links.
this was also thecase in other projects where several commits were not directlyassociated with any particular issue but addressed a more trivialtask such as correcting a typo or adding a comment in java docs.
these types of commit negatively impact overall precision.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. rath et al.
related work the most closely related work falls under the two areas of feature location and tracing bug reports to code.
feature location attempts to identify sections of source code relatedtoaspecificrequirementorissue.severalauthorshavelooked at static approaches based on information retrieval techniques.
for example antoniol et al.
used a probabilistic approach to retrieve trace links between code and documentation.
hayes et al.
used the vector space model vsm algorithm in conjunction with athesaurustoestablishtracelinks .otherstudiesappliedlatent semantic indexing latent dirichlet allocation lda or recurrent neural networks to integrate semantics or contextinwhichvarioustermsareused.otherresearchershave combinedresultsofindividualalgorithms appliedai swarm techniques and combined heuristic rules with trace retrievaltechniques .ourapproachleveragesinformationretrievaltocomputesimilaritybetweenvarioustypesofissues commit messages and code.
we investigated the use of lsi but rejected it for a pragmatic reason that it had a long execution time andfurther thatpriorstudieshavenotshownittooutperformvsm.
ultimately we adopted a vsm based approach that outperformed basic vsm and integrated natural language concepts.
researchers have also integrated structural analysis of the code tosupportfeaturelocation .wedidnotincludethisin our current classifier however we will consider itin future work.
structural analysis may be especially helpful for finding additional classesthatarerelatedtoanissueorbug.inlesscloselyrelatedwork researchers investigated the use of dynamic analysis for feature location .furthermore eisenbarthetal.
presenteda technique combining dynamic and static analyses to rapidly focus on the system s parts that relate to a specific set of features.
our work focuses not only on feature requests i.e.
improvements but also tracing bugs to code.
canfora et al.
used information retrieval techniques to identify files that were created or changed inresponsetoabugzillaticket .theyidentifiedfiles changedin responseto similarbug reportsin thepast usingstandardinformationretrievaltechniques.kimetal.predictedwhich sourcecode fileswouldchangeas aresultof bug fixrequests using mozilla firefox and core code repositories as their corpusin tandem with the public bugzilla database.
they first trained a classifier to recognize usable versus non usable bug reports and then using the bugs classified as usable trained a second classifier to identify impacted classes.
our approach differs from their work inthatourgoalistogeneratelinksdirectlyfromcommitstoissuessothatwecanmakedirectrecommendationstousersiftheyforget to taga commit.
ourgoal is thereforeto create trace links as the commitsaremade sothatdeveloperscan acceptorrejectthemin order to create a set of trusted links.
in the authors proposed two heuristics loners and phantoms to infer trace links between commits and issues.
we incorporate their concepts as one attribute in our classifier.
threats to validity there are several potential threats to the validity of our study.
internal validity wesplittheavailabledatasetforeachproject into of the issues retaining the temporal ordering of theproject.choosinganothersplitpointmayproducedifferenteval uationresults.weconsideredexplicitlyonly resolved bugsand improvements assuming that all required source code modificationshadalreadytakenplace.itmaybepossiblethattheprocessof resolving anissue does notmanifest incommits.
we triedto mitigate this by focusing on commits marked as fixed or resolved however somecommitsmightintentionallynotaddressanissue due to their triviality.
this was evidenced in our final experiment whereourclassifierrecommendedlinkseventhoughnolinksexisted.
furthermore our study focused on improvements and bugs asthesewerethepredominanttypesofinstancesinourprojects however we observed comparable commit link patterns for other issues types suggesting that our approach would generalize.externalvalidity ourstudyfocusedsolelyonopen sourceprojects.
a potential threat to external validity arises when we want to generalize our findings to a wider set of project including commercial development.wehaveobservedevidenceofsimilartaggingpractices in our own industrial collaborations and therefore expectsimilar results.
however internal company regularities might influencecommitpractices andthustheoverallapplicabilityofour approach is anopen question.
another threat that mightlimit the generalizabilityofourresultsistheuseofonlyonecombinationofissue tracking system jira and version control system git .
other tools and platforms might encourage and or provide different linking behavior.
conclusion in this paper we studied the interlinking of commits and issues in opensourcedevelopmentprojects.ananalysisofsixlargeprojectsshowedthatonaverageonly60 ofthecommitsarelinkedtoissues.
this incomplete linkage fundamentally limits the establishment of project wide traceability.
to overcome this problem we propose an approach that trains a classifier to recommend links at the time commits are made and also augments an existing set of commits and issues with automatically identified links.
we identified structural temporal stakeholder relatedandtextualsimilarityfactors as relevant information for automating this task and derived attributestoquantifytherelationbetweencommit issuepairs.arandomforestclassifierperformedbestonthetrainedattributes.
we evaluated this trained model through conducting four different experiments.twoexperimentsstudied classificationperformance for recommending links upon a new commit as well as for auto matically augmenting missing links.
we found that the classifier yielded on average recall in a short list of three recommendations and could on average automatically augment every secondlink correctly with an average error of .
finally we manually constructedasmallanswersetoflinksfromthesetofpreviously unlinked commits and showed that the classifier returned high recall results averaging .
and precision of .
.