self hiding behavior in android apps detection and characterization zhiyong shan wichita state university wichita kansas usa zhiyong.shan wichita.eduiulian neamtiu new jersey institute of technology newark new jersey usa ineamtiu njit.eduraina samuel new jersey institute of technology newark new jersey usa res9 njit.edu abstract applications apps that conceal their activities are fundamentally deceptive app marketplacesandend users shouldtreatsuch apps assuspicious.however duetoitsnatureandintent activityconcealingisnotdisclosedup front whichputsusersatrisk.inthis paper we focus on characterization and detection of such techniques e.g.
hiding the app or removing traces which we call self hiding behavior shb .
shb has not been studied per se rather it hasbeenreportedononlyasabyproductofmalwareinvestigations.
weaddressthisgapviaastudyandsuiteofstaticanalysestargeted at shin android apps.specifically we present a detailedcharacterization of shb a suite of static analyses to detect such behavior and a set of detectors that employ shb to distinguish betweenbenignandmaliciousapps.weshowthatshbrangesfrom hiding the app s presence or activity to covering an app s traces e.g.
byblockingphonecalls textmessagesorremovingcallsand messagesfromlogs.usingourstaticanalysistoolsonalargedataset of android apps benign as well as malicious we expose the frequencyof12suchshbehaviors.ourapproachiseffective ithas revealed thatmalicious appsemploy .
shbsper app onaverage.
surprisingly shbehaviorisalsoemployedbylegitimate benign apps which can affect users negatively in multiple ways.
whenusing our approach for separating malicious from benign apps ourapproachhashighprecisionandrecall combinedf measure .
.
our approach is also efficient with analysis typicallytaking just seconds per app.
we believe that our findings and analysistoolarebeneficialtobothappmarketplacesandend users.
ccs concepts securityandprivacy softwaresecurityengineering software reverse engineering software and its engineering automated static analysis keywords android static analysis malware mobile security acm reference format zhiyongshan iulianneamtiu andrainasamuel.
.self hidingbehavior inandroidapps detectionandcharacterization.in icse icse 40th permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
conference on software engineering may june gothenburg sweden.
acm newyork ny usa 12pages.
.
.
introduction mobilesecurityresearchhasmostlyfocusedonmalwareactivation malicious payloads permission abuse or leaking sensitive data.
little attention has been paid to deceptive mechanisms that areessential for the success of malware i.e.
how malware manages to get installed and continues operating on the phone without the users noticing anything suspicious.
to do so malware uses a range of shb e.g.
hiding the app hiding app resources blocking calls deletingcallrecords orblockinganddeletingtextmessages.surprisingly extremelypopular benign appssuchas airbnb truecaller andwazealso employ certain sh techniques in the name of user convenience.
webelievethatshbisfundamentallydeceptiveandthathaving tools that perform accurate and early detection of shb is key.
first app marketplaces e.g.
google play or apple store should be able to detect shb so that shb can be considered in the decision topublish an app or not.
even when an app with shb is published on the marketplace users should be forewarned about the shb so they can decide whether to install the app on their phone or not.
we address these problems on the android platform via several advances we shine a light on shb via detailed characterization we construct an shb detecting tool based on static analysis and weshowhowourapproachforidentifyingshbcanbeveryeffectiveatexposingmaliciousappsaswellasdeceptivepracticesinbenignapps.wechosetofocusonandroidbecauseandroidclearlydominatestheworldwidemobilemarket withan87 marketshareinthesecondquarterof2017 .whilepopular android ssecurity couldbeimproved researchersfromtheantivirusfirmgdatahave discovered that more than new malicious android apps havesprungoutduring2017 sfirstquarter andestimatethatthe total number will grow up to a staggering .
million by the end of .
therefore there is plenty of evidence that the threat level forandroidusers remainshigh andthereisan impetustodetect andweedoutmalwarebeforeitispublishedongoogleplayorit reaches users devices.
we start by presenting a detailed characterization of shb in section .
we group shb into three main categories shb that involveappobjects i.e.
hidingthepresenceoftheapp shbthat blockorremovetracesofremotecommunication e.g.
blockingcalls ordeletingtextmessages andsubvertingthesystem sreminders e.g.
hiding notifications or muting the phone.
1the tool and datasets are available at acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden zhiyong shan iulian neamtiu and raina samuel insection3wepresentourapproach atool consistingofasuite ofstaticanalyses thatexposespotentialshbinagivenandroid app.ourtoolworksdirectlyonapks i.e.
theformatandroidapps are distributed in and does not require access to app source code.
in section we evaluate our approach along several dimensions.
first we check our approach s accuracy via manual validation on a set of malware samples we found that it attains an .
f measure.
second we check whether our approach can be used to triage benign from malicious apps using a dataset of benign and malicious apps the attained f measure is .
.
insection 5weprovideadetailedexpos ofshb inwidely used apps and how these deceptive behaviors can affect users.
to summarize we make the following contributions anexpos ofofshbs includingnovelshbs asemployed by malware and widely used benign apps.
a static analysis based approach for detecting shb.
anevaluationofourapproachon9 452sampleapps both benign and malicious.
self hiding behaviors in this section we provide a comprehensive description of shbehaviors.
we define as sha behavior meant to hide the app or its actions from being viewed or heard!
by the user.
note that we exclude those behaviors meant to evade security mechanisms e.g.
anti malware tools or access control mechanisms they have been studied thoroughly and are outside the scope of this paper.
ourcharacterizationisbasedonmanualanalysisofabout200 maliciousappsandautomatedanalysisofabout3 000othermalicious apps.
we found shbs few of these are even mentioned in theresearchcommunity letalonecharacterizedthoroughly and some including hideicon and hideactivity arenot mentioned at all.
userscouldemploythreemainapproachesforidentifyingthe presenceofmaliciousapps inspectingappobjects icon app activity analyzingremotecommunication sms mms andphone calls orcheckingsystemreminders systemdialogs sound system logs notifications recent apps list etc .
there are two main issues with this approach though it requires a highly knowledgeable user who performs such inspections periodically and malware actively attempts to escape hide itself from such identification.
tosetupthediscussion infigure1weshowthenumberofshbs insamplesetsof1 000maliciousand1 000benignapps respectively the1 000benignappsarearandomsampleextractedfromthe6 benignapps whilethe1 000maliciousappsarearandomsample extractedfromthe3 219maliciousapps amorethoroughdataset description is provided in section .
.
app objects .
.
hideicon.
afterinstallation benignappsaddtheiricon to the home screen.
to hide itself a malicious app removes theicon so the user cannot notice the app s presence.
there are two methods for hiding the icon a modifying the app s manifest file to remove the app from the default launcher i.e.
home screen.
this can be done by deletingcategory android.intent.category.launcher from the app s main activitysectioninthemanifestfile.2forexample malware fake skype camouflages as the popular app skypeand runs in the background without an icon in the home screen.
b callinganandroidapimethodtodisabletheiconatruntime.
thiscanbedonebyinvokingmethod setcomponentenabledsetting .for example malware facebook otp full package name jgywwv.jvyjsd.
sordvd masquerades as the facebook app but disables its icon immediatelyafterinstallation.weshowthesegmentofthecodewe reverse engineered from this malware 1packagemanager pm getpackagemanager 2componentname cn newcomponentname jgywwv.jvyjsd.sordvd jgywwv.jvyjsd.sordvd.activity1 3pm.setcomponentenabledsetting cn packagemanager.
component enabled state disabled packagemanager.
dont kill app .
.
hide app.
when benign apps are running they typically show up in the running app list.
in contrast a malicious app can run as a service in the background hence does not show up in the list.inordertoautomaticallystartthemalwareasaservicewithout the user clicking the icon a malicious app creates a broadcastreceiver class and registers it to receive certain events like sms received boot completed etc.after receivingoneoftheregistered events the malware s broadcastreceiver launches the malware as a service inthebackground.asaresult theusercannotseethemalicious appintherunningapplist.forexample thespyware candy corn automatically records google voice calls in the background.
as showninthefollowingcodesegment candy corn monitorsseven kinds of events and starts itself as a service if the service is not running already 1public void onreceive context context intent intent ... 3string act intent.getaction if intent.action boot completed.equals act intent.sms received.equals act intent.new outgoing call.equals act intent.screen off.equals act intent.package install.equals act intent.package added.equals act intent.sig str.equals act if isservicerunning return intent serviceintent newintent context com.google.progress .androidclientservice.
class serviceintent .setaction com.google.
action start call record context.
startservice serviceintent ... .
.
hideactivity.
mostmalwarerunsasabackgroundservice.
however starting in android version .
apps cannot create a service without having an activity associated with that service.
therefore a malicious app must first create an activity.
next to hide the activity the app can employ two approaches making the activity transparent or destroying the activity before it becomes visible.
2the manifest file androidmanifest.xml bundled with the app contains a description of the app s capabilities system requirements resources permissions etc.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self hiding behavior in android apps detection and characterization icse may june gothenburg sweden figure the numbers of shbs in two sample sets of malware apps and benign apps respectively.
torenderanactivitytransparent amaliciousappneedstomake theactivity smainlayouttransparent settheactivityasfullscreen then remove the action bar and window title.
these values can be set in the app s manifest file.
in addition malware can also accomplishthisviacertainapimethods.forexample androidapi methods setbackground setbackgrounddrawable orsetbackgroundcolor canchangetheactivitytotransparent.methods addflags setflags o rrequestwindowfeature can change the window to full screen as well as remove the action bar and the window title.
we now illustrate this with malware droidkungfu3 .
first the manifest file is used to make the activity layout transparent style name theme.notitle parent android style theme item name android windowbackground android color transparent item item name android windownotitle true item item name android windowistranslucent true item item name android windowcontentoverlay null item style then atruntime theappsetsthewindowflagto flag not touch modal meaningthatevenwhenthewindowisfocusable itallows anypointereventsoutsidethewindowtobesenttothewindows behind it.
as a result the user cannot see the malware activity but can still use the activity of another app which is just below the malwareactivity defactothemalwareactivityhassuccessfully inserted itself between the unsuspecting user and the app below 1protected void oncreate bundle savedinstancestate super.oncreate savedinstancestate ... 4setcontentview r.layout.activity main 5getwindow .addflags windowmanager.layoutparams.
flag not touch modal ... to destroy an activity before showing it a malicious app will callfinish inoneofthethreelifecyclecallbackmethods oncreate onstart o ronresume .
thefinish method in turn calls ondestroy to finish the activity.
if finish is called in oncreate oronstart the activityisnotshownatall.butifitiscalledin onresume thescreen will flicker during the activity transition from the foreground to thebackground.topreventthis theactivityissettotransparent.
we show this being accomplished in the savemespyware 1protected void oncreate final bundle bundle super.oncreate bundle ... this.getpackagemanager .setcomponentenabledsetting this.
getcomponentname component enabled state disabled dont kill app this.
finish ... .
remote communication .
.
deletemessage.
sendingsms mmsmessagesfurtively inthebackground isacommonbehaviorinmalware.therefore several anti malware products focus on this to recognize malware.
after sending or receiving sms mms in the background android saves a copy of the sms mms in the outbox or inbox respectively.
tocoveritstracks malwareneedstodeletethiscopy.themalware usuallycalls delete onacontenturi i.e.
content sms inbox and content sms outbox respectively.furthermore malwarecanalso delete sms mms associated with a certain message id time or phone number.
an example is malware xtaoad.a that deletes a message upon receipt 1voidonreceive android.content.context context android.content.intent intent ... if android.os.build.version.sdk int android.os.build.
version codes.kitkat if !telephony.sms.getdefaultsmspackage context .equalsignorecase context.getpackagename context.getcontentresolver .delete uri.parse content sms null null ... .
.
deletecalllog.
aftermakingorreceivingaphonecall inthebackground androidwillgeneratearecordinthecalllog.
tocoveritstraces malwarehastodeletethisentryfromthecall log.anexampleisthe savemespyware.
savemehasaservicethat can make a call in the background e.g.
to a premium number as dictated by the malware s server.
we show this in figure .
in the left code snippet ext callis the number to be called.
after the phonecall themalwaredeletesthecorrespondingcalllogentry.in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden zhiyong shan iulian neamtiu and raina samuel therightcodesnippet thestring scontainsthenumberthatwas just called.
.
.
block message.
after a malicious app sends sms mms to sign up for a premium rate service in the background it will receive a confirmation sms mms sent from the service provider.
topreventusersfromknowingthis themalwarehastofilterthe received sms mms by calling abortbroadcast .
an example is trojan fakebank.b shown below please note that method achecks the intent to see whether the sms message has been received .
1voidonreceive android.content.context context android.content.intent intent ... if !telephony.sms.getdefaultsmspackage context .equalsignorecase context.getpackagename 4a intent.getextras context 5abortbroadcast ... .
.
block call.
for malware that is part of a botnet the commandandcontrol c c servercouldcalltheinfectedphonetoask the bot malware app to perform certain services the c c server isencodedinthephonenumber.topreventusersfromrealizing this the malware needs to block the phone call.
if the malware received an intent android.intent.action.phone state and the number of the caller is the c c server then the ringer mode is set to silent to suppress the notification of the incoming call and the phonecall is disconnected.
its corresponding entry from the call logs is also removed removing all traces of the phone call.
an example is malware fakeavthat uses endcall to cancel the incoming call 1voidonreceive android.content.context context android.content.intent intent ... 3telephonymanager tm telephonymanager context.getsystemservice context.telephony service try 5class c class.forname tm.getclass .getname 6method m c.getdeclaredmethod getitelephony 7m.setaccessible true 8com.android.internal .telephony.itelephony telephonyservice itelephony m.invoke tm 9telephonyservice.endcall catch exception e e.printstacktrace ... .
system reminders .
.
hide alert.
system dialogs could revealthe presence of malware by displaying alarms user account balances or otherabnormal behaviors to the user.
to avoid this malware has to dismissthesystemdialogbybroadcastingtheintent action close system dialogs as shown in the following code snippet 1public void onwindowfocuschanged boolean hasfocus super.onwindowfocuschanged hasfocus ... if !
hasfocus 5intent closedialog newintent intent.
action close system dialogs 6sendbroadcast closedialog ... .
.
hidenotification.
appscansendalertstotheuserbygeneratinganotificationonthe notificationbar.butthemalwarecan delete notifications by calling notificationmanager s methods cancel orcancelall when receiving notifications.
an example is malware bios.nativemaliciouscode.apk 1voidclearnotify android.content.context context ... android.app.notificationmanager context.getsystemservice notification .cancel ... .
.
mutephone.
tocovertheirpresence maliciousappsoften resort to muting the phone or disabling the vibrate function to prevent the user from hearing the sound of alarms notifications phone calls or incoming smss.
this can be accomplished in a varietyofways switchingtosilentmode callingthevibratorservice setting the phone to mute or adjusting the volume to the lowest level.
an example is the trojan ibanking 1voida android.content.context context ... android.media.audiomanager context.getsystemservice audio .
setstreammute audiomanager.stream alarm true ... .
.
exclude from recent apps list.
after an app has run the systemputsitsactivitiesintotherecentappslist.topreventthis malware can set the flag excludefromrecents in the manifest file or by calling activitymanager.setexcludefromrecents .
an example is trojan malapp .
activity android name com.yangccaa.chengaa.weyy android label string notification name android taskaffinity .
notificationactivity android excludefromrecents true intent filter action android name android.intent.action.main category android name android.intent.category.launcher intent filter activity .
.
deletesystemlog.
androidsavessystemactivityintothe system log which can be viewed via the logcat.
malware can call adb logcat c to delete the logs if the phone is rooted or if the androidapiislowerthan16.wepresentanexampleofsuchan action extracted from the trojan smsblocker 1r getruntime 2r.exec logcat c detecting sh behaviors our approach relies on a suite of static analyses to detect shbs.
figure shows an overview of our tool s design.
the input is an apkfile apkistheformatandroidappsaredistributedin .we passthebytecodetosoot flowdroid whichperformbasic tasks such as alias analysis call graph analysis as well as fixpoint computationstodealwithloopsandrecursion.next weperform authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self hiding behavior in android apps detection and characterization icse may june gothenburg sweden !
!
!
figure tool overview.
figure sapi analysis.
ourcoreanalyses describedshortly onbothbytecodeandxml files.
finally a report detailing the potential shbs is produced.
.
static analysis .
.
findingshcallinvocations sapianalysis .
ourfirstanalysisfindswhether shapicalls areinvoked wenamethis sapianalysisfor short .
we present the analysis in figure .
specifically the analysisstartsatan origin apporactivitystart .inthefirststage weusecontrol flowandcallgraphanalysistofindwhetheracertain sapi call isinvoked greennodesandedgesontheleftrepresent methods and call graph edges respectively.
in the second stage we use backward dataflow analysis to find if the call is invoked with certain sh indicating parameters more precisely we walk thedef usechainsbackwards showninblack untilwecanfindtheparameterdefinition e.g.
aconstantoranalias.intable1weshow the origins and sapi calls for each shb.
for example to detect the hide app shb our analysis will check whether the call to context.
startservice isreachablewhenstartingin broadcastreceiver.onreceive .
to check for delete message on the other hand we start trackingfrom broadcastreceiver.onreceive sms received action view tosee if we can reach contentresolver.delete next we walk the def use chainsbackwardstoseeiftheargumentis content sms .forcertainbehaviors e.g.
hideactivity weusealltheapp sentrypoints as origin app entry points are provided by flowdroid.wenowprovideanexamplefromtherealmalware droidkungfu1 which deletes all sms messages.
in this case we show simplified disassembledcode fromwhichwehaveremovedirrelevantinstructions.
1specialinvoke r3.
java.lang.
stringbuilder void init java.lang.
string content sms r4 virtualinvoke r3.
java.lang.
stringbuilder java.lang.string tostring r5 staticinvoke android.net.uri android.net.uri parse java.lang.
string r4 4virtualinvoke r2.
android.content.contentresolver intdelete android .net.uri java.lang.string java.lang.string r5 null null let us assume that our analysis has determined that an invocation of contentresolver.delete is reachable from broadcastreceiver.
onreceive phone state .
to check the value of delete s parameter we walk the def use chains backwards starting at r5 that is used at line and defined at line .
as line calls method parse w e proceed further on r4 and then r3.
eventually on line we see thedefinition i.e.
content sms .thisconcludesouranalysisand we report the potential delete message behavior.
.
.
pair action papi analysis.
another broad self hiding category consists of pair actions where an app first performs a malicious action then deletes traces of this action e.g.
deleting a text message after sending it.
our analysis we name this papi analysis for short detects six types of pair actions send message deletemessage log receive message delete message log receive block message make phone call delete call log receive phone call delete call log receive block phone call.
our pair action detector uses data flow analysis in a manner similartotaintanalysistoseeifdataflowsfroma pairstart toapair end.thepairedmethodsandtheshbarelistedintable2.
figure4 showsacodesnippetfromtherealmalware savemethatdeletesa callfromthecalllog.ourtooldetectsdataflowfrom startactivity tocontentresolver.delete .
actually ext callon line left and s on line right have the same value the phone number called.
therefore the pair context.
startactivity contentresolver.delete is detected indicating the shb delete call log .
.
.
user decision ud analysis.
toreducepotentialfalsepositivesincaseswheresapimethodsarealsousedbybenignapps we perform a user decision analysis that checks whether an api authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden zhiyong shan iulian neamtiu and raina samuel table sh call sapi analysis.
sh behavior origin sh call sapi hide app broadcastreceiver.onreceive action boot completed sms received new outgoing call screen off package install package added sig str context.
startservice hide activity any window.addflags flag not touch modal entry window.setflags flag not touch modal point window.requestfeature flag not touch modal delete message broadcastreceiver.onreceive sms received action view contentresolver.delete content sms delete call log broadcastreceiver.onreceive phone state contentresolver.delete content cal log calls phonestatelistener.oncallstatechanged telephonymanager.
call state ringing block message broadcastreceiver.onreceive sms received broadcastreceiver.abortbroadcast content sms block call broadcastreceiver.onreceive phone state itelephony.endcall phonestatelistener.oncallstatechanged telephonymanager.
call state ringing hide alert any entry point context.sendbroadcast intent.
action close system dialogs hide notification broadcastreceiver.onreceive notificationmanager.cancel notificationmanager.cancelall mute phone any vibrator.cancel entry audiomanager.setringermode ringer mode silent point audiomanager.setstreammute true audiomanager.adjuststreamvolume adjust lower delete system log any entry point runtime.exec logcat c figure code snippets of malware savemethat implement the delete call log shb.
table pair action papi analysis.
sh behavior pair start pair end delete message smsmanager.sendtextmessage sendmultiparttextmessage sendmultimediamessage contentresolver.delete smsmessage.createfrompdu delete call log context.
startactivity contentresolver.delete phonestatelistener.oncallstatechanged broadcastreceiver.onreceive block message smsmessage.createfrompdu broadcastreceiver.abortbroadcast block call broadcastreceiver.onreceive itelephony.endcall phonestatelistener.oncallstatechanged method invocation is the result of an user decision.
we name this ud analysis for short.theuser sguiactionscanbe decision related ordecision unrelated asexplainednext.decision relatedactionsincludeclickingabutton checking a checkbox or selecting a menu item in other words theusertakesdecisions andactsaccordingly inawaymeantto authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self hiding behavior in android apps detection and characterization icse may june gothenburg sweden change the app state.
examples of decision unrelated actions include scrolling down a window or changing focus.
if an sapi is invokedbyadecision relatedaction werulethatcallaslegitimate rather than an sh attempt.
however if invoked by a decisionunrelated action it can be an shb.
note that existing research can onlydetect whetheranapi isinvokedby agui whereas we further consider whether the gui can reflect decisions.
inordertopresenttheuser decisionanalysisapproach weintroduceseveraldefinitions.user decision gui udg isaninteractive gui element e.g.
button checkbox radio button toggle button spinner picker or menu.
user decision callback udc is a toplevelcallbackmethoddirectlyinvokedasaresultoftheuseraction e.g.
onclick oncheckedchanged .incontrast somecallbackmethods are due to decision unrelated actions e.g.
onbackpressed onscroll oneditoraction .
androidofferstwowaysfor creating acorrespondencebetween acallbackmethodandaguielement staticallydefiningthecallback as the handler of an event in the gui element s layout file or dynamically defining a callback for the gui element by registering a listener object we handle both.
we determine that a given callback isan udc if either of these two conditions is satisfied thecorrespondingguiofthecallbackisanudg andthe event to be handled by the callback is a decision related event e.g.
click.
note that there exist decision unrelated events e.g.
scroll and focus change.
thecorrespondingguiofthecallbackisanudg andthelistener of the callback is decision related e.g.
oncheckedchange listener.
note that there exist decision unrelated listeners e.g.
oncreatecontextmenulistener andonfocuschangelistener .
finally weinferthatanapiinvocationisuser decidedifallof its callbacks are udc which includes callbacks within the same componentandcallbacksinothercomponents.ifanycallbackis not udc we infer that the api call is not invoked by the user further if this call is an sapi it is potentially an shb.
.
.
activity finish analysis.
this analysis detects activity hiding i.e.
whetheranactivityisterminatedprematurely beforebeing displayed asillustratedinsection2.
.
.toachievethis theactivity callsfinish within oncreate onstart o ronresume or their descendants in the call graph .
therefore our analysis starts at the beginningofthesethreecallbackmethods.weperformacontrol flowanalysis tocheckwhetherthere existsapath fromthebeginning of the callback to the callback s end that includes finish i f suchapathexists itindicatespotentialactivityhiding.wename thisaf analysis for short.
.
.
attributeanalysis.
thepurposeofthisanalysisistocheck whether the app attempts to manipulate activity attributes in order to deceive the user.
the analysis checks both the xml mani fest file and the attribute related api methods.
for example theliner layout of an activity has an attribute background color .if the attribute value is the activity is transparent.
an app can set the value of an attribute in the manifest or layout files orbycallingcertainapimethods e.g.
setbackgrounddrawable setbackgroundcolor orsetbackgroundresource .anotherexampleistheattribute excludefromrecents which can be specified in the manifest file or set via the api methods setflags andaddflags .
.
detection rules weusesapi papi ud af andattribute todenotethefivestatic analyses.thedetectionrulesfortheshbsareshowninfigure5.if anyoftherulesfires thetoolwillreporttheappasmalicious.we now explain each rule.
rule reports hide icon when the main activity is removed from the home screen without user involvement.
rule detects hide app ifstarting anapp asa service withoutuser involvement.
rule3reports hideactivity whentheactivityfinishanalysisreturnstrueorthemainactivityistransparent.rule4infersbehavior delete message when deleting occurs after receiving or sending a message.rule5reports deletecalllog whendeletingoccursafter makingorreceivingaphonecall.rule6detects blockmessage if blocking received or sent messages.
rule reports block call when blocking incoming or outgoing phone calls.
rule reports hide alert if the app closes a system dialog without user involvement.rule9infersbehavior hidenotification whencancelinga notificationwithoutuserintervention.rule10detects mutephone whenmutingthephonesurreptitiously.rule11findsshb exclude from recent apps list if the attribute exclude from recents is set without user s involvement.
rule reports delete system log if that specific shell command is not launched by the user.
.
implementation we implementedour tool ontop ofthe soot andflowdroid static analysis frameworks.
these frameworks only analyze bytecode so we added modules to analyze xml files e.g.
categories and attributes in androidmanifest.xml style.xml etc .
our static analysis modules use both data flow and control flow analyses.
finally the analysis results are produced using the detection rules.
.
limitations limitations falsenegatives.
ourtoolhasseveralanalysislimitations.first ifanshbisinvokedbyguiinteractionbuttheguitext does not reflect the invocation of the shb the tool will not report it huang et al.
s idea of finding mismatches between user interface and app behavior could be used to address this limitation.
second therewereafewappsthat duetoobfuscation couldnotbe analyzed e.g.
tripadvisor com.tripadvisor.tripadvisor.apk andkcls com.bibliocommons.kcls.apk .
improvingprecision reducingfalsepositives.
ouranalysis built on top of flowdroid is based on over approximation and handles reflection native code conservatively this can be a source of false positives.
also the sapi functions with zero parameters tend to havemorefalsepositives amoreprecisealiasandflowanalysis would improve precision.
broader concerns.
there could be other classes of shbs beyond theones wehavediscovered.
nevertheless ourlist ofshbs is effectiveatmalwarediscrimination and exposesquestionable practices in benign apps.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden zhiyong shan iulian neamtiu and raina samuel hide icon !ud removefromhomescreen mainactivity hide app !ud sapi start service hide activity activityfinish !ud attributeanalysis transparent main activity sapi set flags delete message !ud sapi delete sms mms papi receive sms mms papi send sms mms delete call log !ud papi make phone call papi receive phone call sapi delete call log block message !ud sapi block sms mms papi receive sms mms papi send sms mms block call !ud sapi block phone call papi receive phone call papi make phone call hide alert !ud sapi close system dialog hide notification !ud sapi cancel notification mute phone !ud sapi cancel vibrate sapi mute sapi adjust volume sapi chang ringer mode exclude from recent apps list !ud attributeanalysis exclude from recents delete system log !ud sapi delete logcat figure detection rules.
finally our approach cannot recognize specific malware families certain shbs might span multiple malware families.
this is expected asourdesigngoalwasatalowerlevel automaticshb identification rather than clustering malware by family.
evaluation in this section we present an evaluation of our approach along severaldimensions istheapproacheffectiveatidentifyingshbs?
istheapproachefficient?whatarethemaincausesoffalsepositives falsenegatives?webeginbydescribingthetwodatasetsused in our evaluation.
datasets.
our first dataset which we name ma contains malware samples that were decompiled and analyzed manually in detail.
the samples come from the malware genome project drebin and androzoo .
the second dataset which we name all consists of benign apps3and malicious apps.4these apps were analyzed automatically.
to ensure that the benign set does not contain malware we sent all the apps in this set to virustotal a public malwarescanningservice.ifanappisreportedbyatleastonecommonanti virustoolasmalicious weremoveditfromthebenign set.
for the malware samples we performed a quick and simple static analysisto eliminatethe sampleswithout anypossibility to haveshbs.thisisdonebysearchingrequestedpermissions major sapi calls and intent actions.
for example if an app does not have permissions send sms andreceive sms it is impossible to have the shb delete message .
moreover in order to make sure that thesamples are malware we sent them to virustotal.
if an app was reported malicious by less than two scanners we removed it from the malware set.
platform.
the static analysis tool ran on an core intel xeon i7 8mb cache .
ghz with 32gb of ram.
the system ran ubuntu .
.
linux kernel version .
.
generic.
3the benign app samples are from google play and androzoo specifically of the benign apps are from google play and span all app categories as well as games.
4the malware samples are from drebin droidcat kharon andromalshare malware genome project and offensive computing .table effectiveness results on ma .
trueover reported under reported shbs shbs fp shbs fn precision .
recall .
f measure .
.
.
.
.
.
effectiveness the test for evaluating effectiveness consists of two steps shb detectionvalidation manual andlargescalemeasurement automatic .
.
.
manualcross checkingon ma .asthereisnoexisting oracle to determine shb we manually verified each static analysis report.
specifically we reverse engineered each app decompiled the app to source code via the jadx decompiler .
note that decompilationisnotalwayspossibleduetoobfuscation sosomeofourmanualanalysiswasbasedonsourcecodeinspection someon dalvik bytecode inspection.
the results are shown in table .
our toolhasreported265 shbsintotal ofthese 219weretrue shbs while shbs were over reported false positives and were falsenegatives i.e.
ourtoolmissedthoseshbs thereasonswillbe discussedinsections4.
.3and4.
.
respectively .thisyieldsan f measure of .
indicating that our tool is quite effective.
.
.
automated analysis on aa .we now turn to discussingthe large setresults shownin table4.
notethathere the numbers in columns indicate apps not shbs since we only have ground truth for app nature not shbs .
a sample is identified as malicious if it exhibited any one of the shbehaviors.thetoolmissed falsenegatives or fn 311samples from the malware set hence the recall value is .
.
the toolalso reported benign apps as having shb false positives or fp fromthebenignset hencetheprecisionis84.
.whilethese apps were not malicious their use of shb is questionable we discuss such uses at length in section .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self hiding behavior in android apps detection and characterization icse may june gothenburg sweden table effectiveness results on aa .
apps apps reported as shbsshbs malicious benign app malicious set .
fn benign set .
fp precision .
recall .
f measure .
.
.
.
.
figure fps generated by each shb.
finally thef measureis87.
themalwaresetexhibited1.
shb per sample on average5while the benign set exhibited only .2shbpersample.
webelievethatthehighf measurevalueand theper appfiguresof1.5shb malicious vs0.
benign indicatethat our approach is effective for detecting shb and perform shb based triaging in android apps.
.
.
falsepositives.
tobetterunderstandthecausesoffalse positives infigure6wehavegroupedthembyshbs.fiveshbs hideactivity hidenotification hideicon hideapp and delete system log generated the most false positives.
we investigated this and found that the false positives were due to several reasons certainappsemployshb suchasrunninginthebackground without the user having started the app or without the user beingabletoseethatrunningapp inthenameofimproving user experience see section .
staticanalysis alias data flow andcontrol flowanalyses are over approximating which is inherent in static analysis.
.
.
falsenegatives.
wehavecategorizedthefalsenegative sources as follows parametersofanshbaredynamicallysentfromaremote control server hence our static analysis cannot identify the behavior.
for example spyware savemehas a remote server 5m ed i a n m i n m a x .thatsendstheid timeorphonenumberthroughthenetwork to delete certain sms mms messages.
shbs are launched by gui interaction but the behavior mismatches the content shown on the gui.
for example appspure girlandicalendar employ this behavior.
some malware samples do not have shb though they sapi calls e.g.
towelroot andfakecmcc .
our tool did not identify these samples as malicious.
.
.
behavior statistics.
figure shows the number of each type of shbs detected per malware samples and benign samples respectively.6thetotalnumberofshbsdetectedinthe malwaresetis1502per1000sampleswhileinthebenignsetitis only185per1000samples.
hideapp hideactivity and block message are the three most common shbs in the malware set.
.
efficiency runningourtoolonthe9 452appstookabout10days.weshowthe detailedefficiencyresultsintable5.the bytecodesize grouped columns show that the datasets had substantial variety in termsof app size and some apps bytecode size was as large as mb.
the time groupedcolumnsshowrunningtimestatisticsforeach dataset.wefocuson aa asitislarger hencemorerepresentative.
the mean analysis time was seconds while the median was 37seconds whichshowsthatouranalysisispractical.finally we believethateventhemaximumanalysistimeof15 290seconds i.e.
hours minutes is acceptable for a static analysis.
to conclude with a median analysis time of seconds on a median app size of .4mb we believe that our approach is efficient at shb analysis.
self hiding behavior in benign apps for each shb category our tool has found in benign apps we performedatwo parttargetedmanualinvestigation first weanalyzed thedisassembledbytecode andthenrantheappwithinstrumentation to confirm the shb.
we focused this investigation on two categoriesofapps appsthatareverypopular e.g.
withmore than 100millioninstalls or lesspopular appswhich displayed severecasesofshb.ultimatelyweaimedtoanswerthequestions whydoesthisshbehavioroccurandwhataretheconsequences for the user?
this section summarizes some of our findings we limit the discussion to shbs for brevity.
.
hide app manypopularbenignapps suchas airbnbandbbmstartthemselves as an automatic service after receiving the boot completed event.
thisevent whichrequiresthepermission receive boot completed notifiestheappthatthesystemhasrebooted.inconjunctionwith thiseventandpermission thereisafunctionwhichlaunchesthe auto startservice.ourtoolreportsthisas hideapp shb.appsem ploythistechniqueasameanstoinitializeapp specificinformation and functions upon startup.
while it could be argued that the app isnothidinginthemalicioussense ratheritisrunninginthebackgroundtohaveaccesstocertaintypesofdata mostcommonly locationservices webelievethatusersshouldknowwhensuch 6the benign apps are a random sample extracted from the benign apps whilethe1 000maliciousappsarearandomsampleextractedfromthe3 219malicious apps.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden zhiyong shan iulian neamtiu and raina samuel table efficiency results.
dataset bytecode size kb time seconds minmaxaverage median minmaxaverage median ma aa apps are running so they understandwhy the battery is draining and so they understand the privacy implications of apps accessing and transmitting sensitive information e.g.
location in the background.
.
hide notification certain apps such as waze truecaller all in one toolbox quick healmobilesecurity andminifetion usenotificationmanager.cancel or notificationmanager.cancelall to block notifications without user intervention.
as a result these apps have been marked as having the hide notification shb.
this is due to the nature of cancel and cancelall whichcancelallpreviously shownnotifications.apps employ this technique as a meansto update the userto the most recentnotificationortoconsolidatenotifications especiallyincommunication apps such as minifetion andtruecaller .
lately many cleanup and devicemaintenance appshavestartedtoexhibit this behavior for the same reasons.
consolidated notifications may appear convenient to the user however the app does not have a means to show high priority notifications first other than through chronologicalorder .therefore usersmightprefertoreceivenotifications for all messages to reduce the risk of missing an important notification.
however in the case of waze the app blocks certain notificationsusingvanagonnotificationmanagerwhichcancelsall appnotificationswhentheuserisnotdriving.whiletheappmight betryingtoappearhelpful notificationcancellationandblocking without user s consent awareness is questionable at best.
.
mute phone our tool discovered the use of audiomanager.setringermode in the benign app camera360 .
as its name states this is a camera app which edits and takes photos it has more than million installs and was bestappof2016ongoogleplayinseveralcountries .7many cameraappsusevolumecontrolswhenrecordingaudio.ourtool alsodiscoveredthe mutephone shbincertainbenignpopular apps like smart truck route andall in one toolbox due to the use ofvibrator.cancel andaudiomanager.setringermode .
regarding smart truckroute theappdirectlychecksandmanipulatesthedevice s audiosettings includingitsringermode.asfor allinonetoolbox theappmutesthephonebasedonthesdkversionofthedevice.
thisisdubiousbehaviorforautilityappaimedatoptimizingthe android device.
to sum up even though it seems reasonable in someofthesecases webelievethatmutingthephoneshouldbe doneby the user through a system wide control rather than silently by the app.
block message as the broadcastreceiver is usually a dormant app component it is not surprising that its methods can be categorized as shbs especially abortbroadcast .asaresult manybenignappscanexhibit this behavior.
interestingly these apps are not limited to those which rely heavily on broadcastreceiver .
for example the popular navigation app wazeusesabortbroadcast which can be construed asthe blockmessage shb.
the abortbroadcast methodis usedto preventotherreceiversfromobtainingthebroadcast thusblocking the communication.
it might be justified that wazeemploys this tactic as a means to prevent itself from getting location based alerts that may be irrelevant or annoying to the user.
while theintentions of message blocking apps might appear benign such blocking removes decision making from the user and can interfere with usability.
.
block call appswhichuse itelephony.endcall areconsideredtohavethe block call shb.thebenignapp truecaller hasthesolepurposetoidentify andblockspamcalls henceitwasobviouslymarkedtohavethis behavior.
despite explicitly stating that it automatically blocks calls anappwhichdecidesfortheuserwhichcallsarespamcan be maliciously manipulated against the user s interest.
.
hide icon hideicon achievesitsgoalbydeletinganactivity s category.launcher fromtheandroidmanifest.whilethisdeletionmerelyindicates that that activity should appear as an initial activity of a task it isevidentthatadeceitfulappcanusehide icontopromoteother activities maskingthedeceitfulappbeneath.manypopularbenignapps such as es file explorer andnext launcher 3d shell lite have this behavior.
for example app next launcher 3d shell lite is a premium launcherforandroid shomescreen butoneofitskeyfeaturesis thatitdraws3diconsandwidgetsovertheiroriginalcounterparts.
appes file explorer has permissions to draw over apps which is surprising and might be regarded as excessive for a file manager.
by having the ability to promote certain activities and controlling the launcher s top level apps apps with this shb should be treated with caution.
.
delete call log the app quick heal mobile security exemplifies this shb.
the app usescontentresolver.delete to delete the call logs on the device.
the app has call filtering capabilities and has explicit permissions to readandwritecalllogsontheuser sdevice.nevertheless users may not be aware of the security implications of log deletion and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self hiding behavior in android apps detection and characterization icse may june gothenburg sweden the user does not initiate call deletion.
these two factors make this particular shb instance quite problematic.
.
delete system log minifetion an app from the baidu app marketplace sends free sms totheuser scontacts.despitetheseeminglystraightforwardnature oftheapp wefound twohighlyquestionablebehaviors.first the appdeletesthesystemlogvia logcat c .second theapphas an activity mobclickagent which uploads device logs to a third party server.
thus the app is able to manipulate as well as exfiltrate the systemlogswithouttheuser sawareness.whilenotmanypopular appshavethisshb usersneedtobeextremelysuspiciousofany app which send device logs and user information to third party servers.
related work behavior based malware detection for android has been long been studied due to the prevalence of malware in the android ecosystem a variety of methods for characterization and behavior based detection have been proposed.
malwarebehaviorcharacterization.
copperdroidcharacterizes malware behavior based on how it is initiated either through java jni or native code execution .
smartdroid uses a combination of static and dynamic analysis to detect conditions as a way to expose the behavior of android malware in ui based triggers .
machinelearning.
crowdroidusesc rowdsourcing toobtaintraces of an app s behavior it distinguishes between benign and malicious apps of the same name and version by detecting anomalous behaviorusingk means somelimitationsincludehavingtorelyon theandroid usercommunityasa sourceforapptraces aswellas having high energy consumption on devices.
puma evaluates the scope and use of permissions.
drebin uses both static analysisandmachinelearningtooptimizeanalysisanddetection patterns mama uses classifiers based on features to detect malware.
yerima et al.
use static analysis to build bayesian modelsasawaytodetectevasivemalware.andromalyappliesmachinelearning anomalydetectors toclassifyfeaturesandevents as benign or malicious .
droidranger uses a permission based footprinting scheme to detect malware followed by a heuristicbasedfilteringschemetoidentifybehaviorofunknownmalware families .droiddetectivedetectsmalwarebasedonpermission combination by obtaining permission combinations which have been requested frequently by malware it auto generates sets tobeusedasameansofidentifyingmalware.monetcombines runtime behavior with static structures to detect malware variantsandtogeneratearuntimesignatureofthemalware .avclass performsmassive scalemalware labelingthrough clustering anti viruslabels andidentifyingthemostlikelyfamilynamesfor each sample .
similarly euphony categorizes malware samples based on clustering the anti virus labels produced by anti virus vendors .
static analysis.
apposcopy uses static analysis to extract malware properties and takesa more semantics oriented approach to classify malware based on its signature .
however one of its biggestlimitationsisthatitcannotdetectobfuscationorself hiding.anothersignature basedtoolisdroidanalyticswhichcollects manages andextractsmalwareandanalyzesmutationsandrepackaging methods .similarly droidapiminerusesclassifiersbasedonsemanticinformationfromthebytecodeofapps namelyapicalls .
using dataflow analysis and frequency analysis it captures the mostcommonandrelevantapicallsusedbymalware.fengetal.
focus on a structure of information flows gathered through the sequenceofapicallsandthepatternsofbehaviorpresenttoidentify malware .
similarly we have employed such api and dataflow analysesinourworktoanalyzeshb.madamisahost basedmalwaredetectionsystemforandroiddevices itanalyzesfeatures at levels kernel app user and package which enables it to detect existing malware families.
rather than focusing on general behavior based analysis of malware weimplementarangeofstaticanalysestodetectshband malware.machinelearning whileusefulinbetterunderstanding malware behavior has several disadvantages e.g.
the models itlearns are opaque whereas we have a static analysis report that helpsusers developers marketplacestracetheshb precisely furthermore machinelearningmayoversimplifyshbresultinginto largenumbersoffalsepositives.moststaticanalysesofmalware are focused on behavior and do not employ attribute analysis as wedo thisanalysisiskeyinidentifyingshbsuchastransparent activities.
finally our work differs from dynamic analysis basedapproaches in the standard static vs. dynamic analysis way due to static analysis our approach is prone to false positives but does not require running the app.
dynamic analysis is prone to false negativesandrequireshigh qualityinputstoensuregoodcoverage.
conclusion motivated by the common tendency of android malware to selfhideinordertodeceiveusersandcovermalicioustraces wedefineasetofself hidingbehaviorsandconstructasuiteofstaticanalysestorevealsuchbehavior.ourexperimentsindicatethatthepresenceofself hidingbehaviorisstronglyassociatedwithmaliceinagiven app.
nevertheless we also found plenty of benign widely popular appsthatemployhidingtechniques whichsuggeststhatend users and marketplaces would benefit from using an approach like oursto shed light on potential nefarious behavior in android apps andimprove user experience.