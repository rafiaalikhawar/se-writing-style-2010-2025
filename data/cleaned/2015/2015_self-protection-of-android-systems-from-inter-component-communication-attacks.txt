self protection of android systems from inter component communication attacks mahmoud hammad joshua garcia and sam malek department of informatics university of california irvine irvine ca usa hammadm joshug4 malek uci.edu abstract the current security mechanisms for android apps both static and dynamic analysis approaches are insufficient for detection andpreventionoftheincreasinglydynamicandsophisticatedsecurityattacks.staticanalysisapproachessufferfromfalsepositives whereasdynamicanalysisapproachessufferfromfalsenegatives.
moreover theyalllacktheabilitytoefficientlyanalyzesystemswith incremental changes such as adding removing apps granting revoking permissions and dynamic components communications.
eachtimethesystemchanges theentireanalysisneedstoberepeated makingtheexistingapproachesinefficientforpracticaluse.
tomitigatetheirshortcomings wehavedevelopedsalma anovel self protectingandroidsoftwaresystemthatmonitorsitselfand adapts its behavior at runtime to prevent a wide range of security risks.
salma maintains a precise architectural model represented asamultiple domain matrix andincrementallyandefficientlyanalyzesanandroidsysteminresponsetoincrementalsystemchanges.
themaintainedarchitectureisusedtoreasonabouttherunning android system.
every time the system changes salma determines the impacted part of the system and the subset of the security analyses that need to be performed thereby greatly improvingtheperformanceoftheapproach.ourexperimentalresults onhundredsofreal worldappscorroboratesalma sscalability andefficiencyaswellasitsabilitytodetectandpreventsecurity attacks at runtime with minimal disruption.
ccs concepts security and privacy software security engineering keywords self protecting system android security software engineering acm reference format mahmoudhammad joshuagarcia andsam malek.
.
self protection of android systems from inter component communication attacks.
in proceedingsofthe201833rdacm ieeeinternationalconferenceonautomated software engineering ase september montpellier france.
acm newyork ny usa 12pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
introduction reusability is a major reason behind the meteoric rise in the popularityoftheandroidplatform andtheincreasingnumberof apps .todeveloprichapps androidpromotesreusabilityof information and services provided by third party apps through its flexibleinter componentcommunication icc model and sensitive resources protectedby a permission basedmodel.
however sincetheinceptionofandroid theiccandthepermission based modelshavebecomethemainattackvectorforandroidapps which can lead to serious security and privacy risks .
thecurrentstate of the artsecurity mechanisms forandroid apps both static and dynamic analysis approaches are insufficient fordetectingandpreventingtheincreasinglysophisticatedsecurity attacks.staticanalysisapproachessufferfromfalsepositivesdue totheirover approximationoftheanalyzedapps e.g.
producing warnings for vulnerabilities that are not executable at runtime.
on the other hand dynamic analysis approaches suffer from false negativesduetothe reachability problem wherevulnerabilitiesare missed due to inputs that fail to reach the vulnerable code.
moreover duetothecomplexanddynamicnatureofandroid systems e.g.
adding removinganapp granting revokingapermission and dynamic class loading their security posture changes overtime.simplyrepeatingtheentiresecurityanalysisofanandroidsystem eitherstaticallyordynamically everytimethesystem changes is prohibitively expensive for practical use.
to overcome the shortcomings of the current approaches we have developed salma a novel self protecting android software systemthat continuouslymonitorstherunningandroidsystem incrementally and efficiently analyzes the security posture of thesystem and dynamicallyenforcessecuritypoliciestopreventsecurity attacksat runtime.salmaleveragesstatic program analysis to automatically derive the initial abstract representation i.e.
a model of an android system.
salma then monitors the running system to keep the model synchronized with the running system.
whenever the model changes salma determines the impacted part of the system and the required security analyses thatneedtobeperformed.finally salmaadjustssecuritypolicies and enforces them at runtime thus ensuring the system is safe and protected at all times.
salmamodelsthesystemasamultiple domain matrix mdm which provides an elegant yet compact representation of all relationshipsamongprincipalelements suchascomponentsand permissions inasystem.ourimplementationofthemdmprovides aflexiblewaytoloadandanalyzepartsofthesystem improving thescalabilityandefficiencyoftheoverallapproach.salmacanbe used to protect android systems without modification of the apps implementation logic allowing our approach to be applied to all existingandroidapps.ourevaluationof salmausinghundreds of real world apps corroborates its efficiency and scalability in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mahmoud hammad joshua garcia and sam malek analyzing evolving android systems with minimal disruption to apps and their services while thwarting security threats to keep thesystemprotectedatalltimes.salmaachieves70 greater detection of attacks than state of the art approaches and greater prevention of attacks than those approaches.
therestofthispaperisorganizedasfollows.section 2describes the security attacks our approach can detect and prevent.
the research gap in the current security mechanisms for android apps ispresentedinsection .section 4illustratesanandroidsystemto motivate our research.
the approach and its implementation are discussedinsections 5and6 respectively.theevaluationresults are presented in section .
finally the paper concludes with an overview of the related literature and areas of future research.
android security attacks inter componentcommunication icc inandroidismainlyachieved either by sending intentsor using unified resource identifiers uris .
an intent is a message exchanged among apps whose payload includes an action to be performed along with the data that supports that action.
component capabilities are then specified as asetofintentfilters thatrepresentthekindsofrequestshandled byagivencomponent.componentinvocationscomeindifferent flavors including explicit or implicit and intra app or inter app.uris are used to access or manipulate the encapsulated data in content providers the database components in android apps.
android s icc allows for late run time binding between components in the same or different apps where the calls are not explicit in the code but instead are made through exchanging messages thatcorrespondwithcertainevents akeypropertyofevent driven systems.
android applies a permission based model to protect sensitiveresources bothsystemresourcesandapplicationresources that each app is allowed to access.
since android version googlechangedthepermissionmanagementsystemfromstatictodynamic allowing users to grant or revoke permissions at runtime.
the android icc interaction mechanism and the current permission model of android are the root cause of many security vulnerabilities.
they have become a vulnerable attack surface of an android system which threatens user privacy and has affected millions of users .
these attacks are widely discussed in the literature .
icc attacks are securityrisksfacilitatedby incorrectlyormaliciouslyusingthe message passing system in android or misusing the permissions in android.
salma provides self protection against these icc attacks.
this section briefly describes these attacks.
unauthorizedintentreceipt inthisattack amaliciouscomponent intercepts an implicit intent by declaring an intent filter that matches the sent intent .
in such an attack a malicious component can access all enclosed data in the intercepted intent and possibly perform a phishing attack .
intentspoofing insuchanattack amaliciouscomponentcan communicate with an exported component that is not expecting such communication .
if a victim component blindly trusts the received intent the malicious component can cause the victim component to perform undesirable actions .
privilege escalation this attack allows a malicious component to indirectly perform a privileged task .
in this attack ifavulnerablecomponentpossessesapermissionwithoutappropriatelyprotectingitsinterface amaliciouscomponentcanperform a privileged task such as sending a text message or tracking the location of a user by interacting with that vulnerable component.identical custom permission any android app can also defineitsownpermissionsandusethemtoprotectitscomponents.
eachpermissionmustdefineanameanda protectionlevel where eachlevel affectstheextentto whichapermissioncan begranted or revoked.
the notable protection levels for this paper are normal andsignature.a normalpermission is automatically granted to appsthatrequestthemwithoutaskingfortheuser sapproval.a signature permission is granted to apps that are signed with the same certificate as the app that declared the permission.
the custom permission model of android contains a vulnerability rooted in its design if two apps define the same custom permission whichever app is installed first is the one whose definition is used .
a malicious app can exploit this vulnerability to access a protected component with a custom permission by declaring another permission with the same name as that legitimate one.
passive data leak content providers canbeusedforboth intra appdatapersistenceaswellassharingdataacrossapps.ifthe readaccesstoa content provider isnotproperlyguardedwith apermission otherappscanexploitthisvulnerabilitytodisclose and leak sensitive data .
content pollution thisattackispossiblewhenthewriteaccesstoa content provider isnotproperlyguardedwithapermission .
thisvulnerability allowsa malicious appto manipulate sensitive data managed by a vulnerable app.
the manipulated data cancauseseveresideeffectssuchasalteringfirewallrulesorblocking incoming calls.
research gap thecurrentsecuritymechanismsforandroidapps bothstaticand dynamic analysis approaches are insufficient for detecting and preventing the increasingly dynamic and sophisticated attacks.
static analysis approaches sufferfromfalsepositives i.e.
false alarms.
the high number of false alarms generated by such approaches lower their applicability.
moreover static analysis approaches face severe limitations when it comes to analyzing obfuscatedordynamicallyloadedcode thusinpracticealso suffer from false negatives.
precise forms of static analysis also require significant amounts of computing resources and can take a substantial amount of time to execute.
dynamic analysis approaches are not sound and are thus prone to false negatives.
these approaches are susceptible to a variety of anti debugging and antimonitoring defenses as well as timebombs whichfurtherdecreasetheirefficacy.furthermore dynamicapproachesaretediousandtimeconsuming asexhaustive execution of apps can take a substantial amount of time.
to overcome the limitation of pure static or pure dynamic analysis holla and katti discussed the need for hybrid android securityapproaches.despitethat fewapproachesproposedhybrid techniques such as dr. android smartdroid and profiledroid .
nevertheless these tools provide detection capabilities butnotpreventionmechanisms.moreover theyrequirechangesto apps implementation logic which prevent their practical use.
alloftheseapproachesperformcompleteanalysisofandroid systems andhencelacktheabilitytoefficientlyanalyzesystemsas changes occur such as adding removing apps granting revoking permissions at runtime or dynamically loading code.
salma mitigatestheaforementionedshortcomingsthrough continuously monitoringtherunningsystem incrementallyandefficiently authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self protection of android systems from inter component communication attacks ase september montpellier france analyzing the system against a broad range of icc security vulnerabilities and enforcing adaptation tactics to prevent security attacks at runtime with minimal disruption.
illustrative example tofurthermotivateourresearchandillustrateourapproach we provide an example of an evolving android system that consists initially of two apps superphone and stayhealthy apps illustratedinfigure a .the makecalls activityinthe superphone allowsausertomakephonecallsanditstorescalls informationinthe callsdb a content provider component.
the history queries thestoredcallsin callsdbandliststhemtoauser.
stayhealthy is a fitness app that allows users to log their daily workouts via exercises andmeals via meals.bothoftheseactivitiesareaccessiblefromthe homeactivity.the loctracker isaservicethatruns in the background and tracks the user s location upon receiving an intent.
exercises uses loctracker to draw a route map of a user sworkout.
stayhealthy alsoallowsausertosharehislogged activities eitherworkoutsormeals withfriendsbysendingtextmessages.
the shareservice sends spatial data i.e.
tagged data with the current user s location as a text message to the phone number specified in the received intent.
shareis being used by both exercises andmealsactivities.
theshareserviceisavulnerableservicesinceitdoesnotcheck if the calling component has the appropriate permissions sms and location in this example before sending spatial data.
whereas theloctracker is a secure service since it checks for the granted permissions of the caller component.
such a check in android can be achieved using the checkcallingpermission api.
although shareis a vulnerable component in the android system illustrated in figure a the current system is not actively threatened since no component is exploiting this vulnerability.
at a later time a user installs a new app called braintease r as shown in figure b .brainteaser is a malicious app that challengesausertosolvemathematicalquestionsandthenmeasuresherintelligencequotient iq .the iqtestactivitydisplays questionsandcommunicateswiththe qgenerator servicetoget thenextquestion.
qgenerator isamaliciouscomponentthat once started communicates with the shareservice of the stayhealt hyapp.
since sharedoes not check if the caller components has the required permissions i.e.
sms and location permissions thiscomponentisvulnerabletoaprivilege escalationiccattack.
therefore thecommunicationbetweenthe qgenerator andshare results in exploiting this vulnerability which allows qgenerator to leak the user s location to any premium rate number without having the proper permissions to perform such a task.
theattackdescribedinthissectionisalegitimatescenariointhe current implementation of the android platform .
moreover performingacompleteanalysisofallandroidappsinthesystem everytimethesystemchangesisneitherefficientnorpractical.we showhow througharuntimemonitoringandincrementalanalysis salma can efficiently and effectively mitigate such a threat.
approach figure2depicts a high level overview of salma which contains two layers the protected layer and theprotecting layer.
the protected layer consists of our modified android framework and a set of apps that a user installs on a device.
the protecting layer realizestheibmmape kcontrolloop .mape kconsistsoffour componentsandaknowledgecomponent.the knowledge contains figure overview of salma.
an architectural model of the system.
the monitorobserves the systemandkeepsthemodelsynchronizedwiththerunningsystem.
theanalyzer assesses the system for security threats.
the planner determinesthebestsecuritypolicies a.k.a.adaptationtactics tobe enforced at runtime by the executor.
figure2depicts instantiations of each of the mape k componentsintheprotectinglayer monitorextractor synthesizer mes whichisa monitor incrementalsecurityanalyzer isa whichisan analyzer policysynthesizer whichisa planner andpolicyenforcer whichisan executor.
mesautomaticallyobtainsandmaintainsa preciseruntimearchitecturalmodelofanandroidsystem.when achangeoccursinthemaintainedruntimemodel the isa determines the impacted part of the system due to that change runsasubsetofsecurityanalysesthatneedtobeperformed and updates the security posture of the system by either adding newpotentialsecurityattacksorremovingexistingthreats.after that policy synthesizer takes the analysis results computed by the previouscomponentandconstructssecuritypoliciesintheform ofevent condition action eca rules whichthe policyenforcer enforces at runtime through various effectors.
.
model extractor synchronizer mes similartootherself softwaresystems salmaleveragesanabstract representation of the software to manage and adapt the systematruntime.priorresearchassumesthesemodelsaredeveloped in advance.
given the rich app ecosystem of android this assumption does not hold since users can install a variety of apps that are unknownapriori.toaddressthischallenge mesutilizesstaticand dynamic analysis techniques to automatically obtain and maintain a precise model of an android system.
to obtain an architectural model of an android system mes usesapktool a reverse engineering tool for android apk files torecoveranapp smanifestfile.
mesthenparsesthefiletoextract theapp scomponents theirproperties theirprovidedinterfaces the required permissions and the defined permissions if any.
parsingthemanifestfileisnotenoughtoobtainasystem sarchitecture sincealargeamountofinformationislatentintheapp s bytecode including all iccs programmatically registered components or defined interfaces.
icc communications are facilitated either by sending intents or using uris see section .
to obtainthisinformation mesutilizesic3 atoolthatextracts intentsand urisalong withtheir informationfrom apps bytecode.
mesdetermines the permissions enforced by components.
in android a component enforces permissions to either protect authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mahmoud hammad joshua garcia and sam malek figure an evolving android system before a and after b installing brainteaser app.
access to the entire component or restrict access to parts of the component using permission checks in the code e.g.
use of the checkcallingpermission api .mesextractsprotected accessof components from the manifest file and restricted access to parts of components from code.
mesleverages prior work of architectural modeling to extract enforced permissions from an app s bytecode.
finally mesdetermines permissions actually used by components either to access a protected content provider or call a protected api.
to determine such permissions regarding to werely on that mapsa protected contentprovider to therequiredpermissiontoaccessthatcontentprovider.regarding to weleveragepscout whichmapseachsensitiveapiin android with the required permission to call that api.
mescapturesthearchitectureofanandroidsystemasa multipledomain matrix mdm which is a matrix representation of all relationshiptypes i.e.
domains amongprincipalelements such as components and permissions in a system.
an mdm consists of multipledesign structured matrices dsms .
each domain is modeled as a dsm a simple matrix that captures the relationshipsofonetype.forthepurposeofsecurityanalysis salmamodelsan android system using seven domains four component interaction domains and three permission domains.
as a concrete example figure3shows the derived mdm of the example illustrated in figure1 a .tokeepthemdmvalidasthesystemchanges mes synchronizes the mdm with the running system.
the four component interaction domains in the mdm model of figure3representthevariouscomponent to componentcommunications.
each non empty cell in these domains indicates that there isacommunicationbetweentwocomponents eitherbysendingintents or using uris to access the encapsulated data in content providers.
rows representsender components columns represent receiver components.
the explicitand theimplicitcommunication domains show all component to component interactions using explicit and implicit intents respectively.
similarly the data access and the data manipulation domains show component to content providerinteractionsforreading i.e.
querying andmodifying i.e.
updating inserting or deleting stored data respectively.
thethreepermissiondomainsinthemdmmodeloffigure 3representthevariouscomponent to permissionrelationships.thepermissionusagedomainshowsthatapermissionismakingprotected api calls.
the permission granteddomain shows that a permission isgrantedtoacomponent tbecauseitiseither directlyusing the permission or its parent app requests that permission and tis interacting with another component that uses that permission.
the permission enforcement domain shows that a permission is enforced by a component through its manifest file or in its code.toderivethemdmrepresentationofanandroidsystem mes asynchronouslyinteractswiththe staticanalysisengine seefigure2 a cloud based web service that leverages various static analysis tools to extract a model of an android system.
once the static analysis engine analyzes the requested app s it returnsatuple s c i dbr dbw p tothemes.inthetuple s c isasetofcomponents iisasetofintents dbrisasetofdatabase readaccesses dbwisasetofdatabasewriterequests and pisa setofpermissions.usingthisextractedinformation i.e.
tuple s andsalma sknowledgeoftheandroidframeworkembodiedin a set of definitions formally presented below it derives the mdm representationofanandroidsystem.the explicitcommunication domain is derived using the following rule.
definition explicit communication .
letc1andc2be two arbitrarycomponentsinthesystem i.e.
c1 c2 c ibeanintent i.e.
i i. we say that c1can explicitly communicate with c2 i fiis sentbyc1 i.e.
i.sender c1 andc2isexplicitlyspecifiedintheintent ias a target component i.e.
i.tar et c2 and either both c1andc2 belongtothesameappor c1isgrantedthepermissionsenforcedby c2 communicate e c1 c2 i i i.sender c1 i.tar et c2 appc1 appc2 enforced c2 rantedc1 theexplicitcommunication domain in figure 3shows the resultsofapplyingdefinition 1toallextractedintents i.e.
theset i. according to definition component explicitly communicates with component since there is an explicit intent sent by hometo exercises recall figure a .
similarly the communications in the implicitcommunication domain are derived using the following rule.
definition implicit communication .
letc1andc2be two arbitrarycomponentsinthesystem i.e.
c1 c2 c ibeanintent i.e.
i i.wesaythat c1cancommunicatewith c2 ifiissentby c1 i.e.
i.sender c1 andc2isexportinganintentfilterthatcanhandle i i.e.
match i c2.f and either both c1andc2belong to the same app orc1is granted the permissions enforced by c2 communicate i c1 c2 i i i.sender c1 match i c2.f appc2 appc1 enforced c2 rantedc1 thematch i c2.f functionindefinition 2performsintentresolution to check if there is an intent filter declared by c2that can handle the intent i. theimplicitcommunication domain in figure3shows the results of applying definition 2to all extracted intents i.e.
theset i.accordingtodefinition component5implicitly communicates with component since there is an implicit intent sent by exercises in which loctracker can handle recall figure1 a .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self protection of android systems from inter component communication attacks ase september montpellier france figure an mdm representation of the system illustrated in figure a .
each colored box in the mdm corresponds to the matching colored app in figure a .
thedataaccess andthedatamanipulation domainsarederived using the following rules.
definition3 dataaccess .
letcbeanarbitrarycomponentin thesystem i.e.
c c cpbeacontentprovider i.e.
cp c anddbr be a database read query request in the system i.e.
dbr dbr.w e saythatccanaccessthestoreddatain cp ifcsendsadatabasequery dbr wheretheauthorityattributeof dbrmatchestheauthorityname ofcp andeither candcpbelongtothesameappor cisgrantedthe enforced read access permission by cp.
access c cp dbr dbr dbr.sender c dbr.authority cp.authority appc appcp readcp rantedc toillustrateaninstanceofdefinition 3ontheextracteddatabase requests i.e.
dbr figure1showsthatcomponent2accessesthe stored data in component which is also reflected in figure .
definition data manipulation .
letcbe an arbitrary component in the system i.e.
c c cpbe a content provider i.e.
cp c anddbwbe a database write insert delete or update request in the system i.e.
dbw dbw.
we say that ccan access the stored data incp i fcsends a database manipulation request dbw where the authority attribute of dbwmatches the authority name of cp and eithercandcpbelong to the same app or cis granted the enforced write access permission by cp.
manipulate c cp dbw dbw dbw.sender c dbw.authority cp.authority appc appcp writecp rantedc as an example of definition figure 1depicts component makescall updates the stored data in component callsdb which is further shown in figure .
table1shows a list of the events i.e.
changes in the system thatmestracks.inthispaper werefertotheseeventsas significant events.
for each significant event mesreceives a notification from thesystemandupdatesthemodelaccordingly.forexample whena userinstallsanewapp mesreceivesasystemnotificationwiththe action package addedintentaction.inthiscase mesobtainsthearchitectureofthenewapp i.e.
m c i dbr dbw p from the static analysis engine mergesmwiths and applies definitions1 4to add the new app to the current mdm.
to avoid substantial analysis time caused by running static analysis tools table the significant events that salma monitors.
id event id event add app new implicit comm remove app new explicit comm grant permission new data access revoke permission new data manipulation thestatic analysis engine can analyze android apps in advance without waiting for a user to install an app.
in our running example after a user installs the brainteaser app seefigure b mesupdatesthemaintainedmodel.themdm illustratedinfigure 4displaystheresultsofmerging brainteaser with the current mdm presented in figure .
figure 4shows that iqtestexplicitlycommunicateswith qgenerator whichimplicitly communicates with share see figure b .
tosynchronizethe runtimemodelwiththesystem mesrelies onreceivingsystemnotificationsfromthesensorsinfigure indicatingsignificantchangesthatoccurinthesystem.somesystem notifications arealready implemented inthe android framework such as add app andremove app events.
for these events the frameworksendsbroadcastintentswith action package added andaction package removed actions respectively.
whileinall othersignificantevents seetable theframeworksilentlyexecutes the event.
therefore we have introduced new system generatedbroadcast intents to the android platform.
the new broadcasts informmesofcertaineventswhenevertheyoccurinthesystem.
eachsystem generatedbroadcastintentcontainsinformationaboutaparticularevent.forexample incaseausergrantsapermissionto anapp theframeworksendsa grant permission broadcastintent with the permission name and the application package name.
.
incremental security analyzer isa androidsystemsarehighlydynamicsoftwaresystems.reanalyzing the entire system every time a change occurs is neither efficient norscalable.therefore ourapproachincrementallyanalyzesthe system whenever a change in the system occurs.
our approach leverages the fact that a change in the system impacts only part authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mahmoud hammad joshua garcia and sam malek figure an mdm representation of the system illustrated in figure b .
each colored box in the mdm corresponds to the matching colored app in figure b .
ofthesystemand oftenrequiresrunningasubsetofthesecurity analyses on the impacted part of the system.
in section .
.
w e describehowourapproachdeterminestheimpactedpartsofthe systemafterachangeoccurs.section .
.2describesthesecurity rulesthatourapproachappliesontheimpactedpartsofthesystem to detect the potential security attacks presented in section .
.
.
change impact analysis.
this analysis consists of two steps determining the impacted parts of the mdm and identifyingthesubsetofthesecurityanalysisrules formallyspecifiedin section5.
.
that need to be considered.
more specifically in step isadeterminestheaffectedpartsofthesystembycalculating mdme mdmt2 mdmt1 wheret2isatimeafteranevent e andt1 is a time before e. each cell in mdmhas a value of either or .
means a relationshipintheprevioussystemhasbeenremovedafter e e.g.
e istherevocationofapermission.0meansthereisnochangeinthat relationshipbeforeandafter e.1indicatesthatanewrelationshipis introduceddueto e.forexample emaybetheintroductionofanew communication between two components appearing at runtime due to installing a new app updating an existing app dynamically loadedcode orexecutionofobfuscatedcode.fromtheaffectedrela tionships isadeterminestheimpacteddomains.applying mdm toourrunningsystem describedinsection revealsthatthecommunicationsinrows9and10havebeenaddedtothesystemwhich belong to the explicitand theimplicitcommunication domains.
instep isadeterminesthesubsetofthesecurityrulesthat need to be considered in light of the affected domains.
to that end isauses table which is a lookup table that maps each security analysis with theinvolved domains in thatanalysis.
this tablealsoshowsthesecurityanalysesthatneedtobeperformed when a specific domain changes.
for example if the explicit domainchanges then isaneedstoperformonly3securityanalyses instead of all analyses.
in our running example where only the explicitandtheimplicitdomainshavebeenchangedafterinstalling brainteaser table2indicates that the security posture of the system should be checked against the following security attacks intent spoofing unauthorized intent receipt privilege escalation andidentical custom permission.table security analyses lookup table.
security analysis involved domain s intent spoofing explicit implicit unauthorized intent receipt implicit privilege escalationexplicit implicit granted usage enforcement identical custom permissionexplicit implicit granted enforcement passive data leak data access read permission content pollution data manipulation write permission .
.
security rules.
thissectiondescribesthesecurityrules thatsalmaappliesontheimpactedpartsofthesystem.eachrule whenappliedonaninteractionbetweentwocomponentswould reveal if that interaction is vulnerable to a given security attack.
securityrule1 unauthorizedintentreceipt .
letcmbe amaliciouscomponent cvbeavulnerablecomponent and cxbea componentthat cvintendstosendanimplicitintent ito.cvandcx belong to the same app and cxdeclares a provided interface i.e.
an intent filter through which cvaims to communicate with cxusing i. in an unauthorized intent receipt cmcan intercept ifromcvby declaringaprovidedinterfacesimilartotheonedeclaredby cx.a s such cmmaygainaccesstoallencloseddatainanymatchingintents meant to be received by cx.
communicate i cv cm appcv nequal appcm communicate i cv cx appcv appcx security rule intent spoofing .
letcmbe a malicious component cvbe a vulnerable component and cxbe a component intendingtocommunicatewith cv.cvandcxbelongtothesameapp.
cvdeclaresaprovidedinterface i.e.
anintentfilter throughwhich itaimstocommunicatewith cx.inintentspoofing cmcansendan intent tocvover the intent filter and force cvto perform a nefarious action upon receipt of the intent.
communicate e cm cv communicate i cm cv appcv nequal appcm communicate i cx cv appcv appcx authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self protection of android systems from inter component communication attacks ase september montpellier france securityrule3 privilegeescalation .
letpbeapermission cmbe a malicious component that is not granted p andcvbe a vulnerable component that is granted and uses pbut does not enforce the use of pas requested by other components.
in privilege escalation cmis able to indirectly obtain pby interacting with cv.
communicate e cm cv communicate i cm cv p used cv p nelement ranted cm p nelementenforced cv security rule identical custom permission .
letpmbea custompermissiondefinedbymaliciousapp appm i.e.
pm.definedby appm andpvbe a custom permission defined by the vulnerable app appv i.e.
pv.definedby appv.
bothpvandpmhave the same permissionname i.e.
pv.name pm.name.cmisamaliciouscomponent in appmthat is granted pm.cvis a vulnerable component inappvthatenforces pv.inanidenticalcustompermission cmcan communicate with cvsincepv.name pm.name e v e ni fpvandpm are semantically different permissions.
communicate e cm cv communicate i cm cv access cm cv manipulate cm cv appcm nequalappcv pm ranted cm pv enforced cv pv.name pm.name pm.definedby nequalpv.definedby security rule passive data leak .
letcpvbe a vulnerable content provider that does not enforce a read access permission cmbeamaliciouscomponentthataccesses queries thestoreddata incpv.
in a passive data leak cmcan passively disclose the sensitive data stored in cpv.
access cm cpv enforcer cpv indefinition enforcer cpv referstothereadaccesspermission enforced by the content provider cpv.
in our approach for each content provider component weaddtwocolumnsinthe permissiondomainsofthemdm oneforthereadaccesspermissionandtheotheroneforthewriteaccesspermission.forexample each permission domain in the mdm illustrated in figure 4containstwopermissionsforthe callsdbcomponent c3rfortheread permission and c3wfor the write permission.
securityrule6 contentpollution .
letcpvbeavulnerable content provider thatdoesnotenforceawriteaccesspermission cmbeamaliciouscomponentthatchanges inserts updates ordeletes thestoreddatain cpv.inthecontentpollutionattack cmcaninappropriately manipulate the sensitive data stored in cpv.
manipulate cm cpv enforcew cpv indefinition enforcew cpv referstothewriteaccesspermission enforced by the content provider cpv.
regarding our example salma determines that the security rules1 and4should be applied to all interactions in rows and columns and .
running these rules mainly rule 3on the communicationbetween qgenerator andshare revealsthatthe implicit communication in row and column of figure 4is vulnerable to privilege escalation attack.
.
policy synthesizer and policy enforcer afterisadetermines the security vulnerabilities in the system thepolicysynthesizer createscontext sensitive securitypoliciesto be executed at runtime.
the created security policies in our approach followtheevent condition action eca rulesparadigm suitable for rapid evaluation as the system executes.
our approach createsecarulesthat basedonaparticularsystemcontext will be executed to prevent security threats.
more specifically salmacreates eca rules to prevent the communication between the two componentsthatareinvolvedinanidentifiedsecurityvulnerability.
salmafurthertriestominimizethedisruptionthatthesecurity policiesmaycause.forexample inthecaseofaprivilegeescalation attack salma creates a security policy to prevent a vulnerable communication instead of revoking the escalated permission from the vulnerable app as proposed in .
the later solution disrupts allcomponentsinthevulnerableappfromusingthatpermission which may stop crucial services provided by the disrupted components such as sending text messages or getting driving directions.
as a concrete example since the communication between qgenerator and shareis marked as potential privilege escalation attack salma creates the following eca rule.
event i iccoccurs condition i.senderpk brainteaser i.sendercomp qgenerator i.receiverpk stayhealthy i.receivercomp share action prevent policy enforcer administers security policies at runtime through various effectors that we have added to the android runtime environment as shown in figure .policy enforcer applies security policies by intercepting the iccs both the intent based and the uri basedcommunications andtheresourceaccesstransactionsto check if theyare allowed or not.
forintent based communication policyenforcer canpreventorallowtransactions.fortheuri based icc transactions policy enforcer can prevent a component from accessing or manipulating either the entire content provider specified in the uri or a specific table or file in that content provider.
implementation we have implemented salma and its constituent components for our experiments and make it available online for reproducibility and reuse purposes .
to keep an android system s architecture synchronizedwiththerunningsystem the staticanalysisengine is implemented as a cloud based web service that leverages several prior static analysis tools .
each tool provides specific information that salma uses to tailor the architecture of the system.
mes policy synthesizer and policy enforcer are implemented on top of the android open source project aosp version marshmallow apilevel23.aospistheopen sourcerepositoryfor theandroidsystem.theenforcementmechanismintroducedanew package in the android runtime environment.
we also modified other components such as activitymanager contextwrapper contentprovider and packagemanager.
the total framework changes accountforapproximately600loc.thesechangesallowanyexistingandroidapp usingversion6and belowtorun inourversion of the android runtime environment without modification.
we havesuccessfullyinstalledthemodifiedandroidsystemimageona nexus 5x phone and an android emulator using android fastboot tools and android debug bridge .
experimental evaluation our evaluation addresses the following research questions rq1.how efficient is salma at incrementally analyzing the securitypostureofandroidsystemscomparedtoacompleteanalysis approach?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mahmoud hammad joshua garcia and sam malek rq2how effective is salma at reducing the unnecessary disruptioncausedbytheenforcementofsecuritypoliciestoprevent permission induced icc attacks?
rq3.howeffectiveissalmaatdetectingandpreventingsecurity attacks in real world apps?
.
rq1 efficiency for this experiment we downloaded apps comprising three datasets a dataset of benign apps randomly selected from google play a dataset of vulnerable apps identified in prior literature andadatasetof225maliciousappsobtainedfrom various malware repositories .
to measure the efficiency of salma s incremental analysis we compared the performance of salma with deldroid a prior approach that similar to our work analyzes the architecture of an android system for icc vulnerabilities and enforces the determinedarchitectureatruntime.however unlikesalma deldroid is not capable of continuous monitoring and incremental analysisofanevolvingandroidsystem.weranourexperiments on a macbook pro with .
ghz intel core i7 processor and gb 1600mhzddr3ram.werepeatedourexperiments10timesto achieve a confidence interval.
figure5contains box and whisker plots comparing the analysis timeofeachapproachasandroidappsareaddedtothesystem.we startedwithanandroidsystemof120appsandaddedoneappatatimeuntilthesystemcontained150apps.werandomlyselected120 apps from the benign dataset apps from the vulnerable dataset and apps from the malicious dataset.
everytimeanappisaddedtothesystem salmaincrementally analyzes the system whereasdeldroid reanalyzes the entiresystem.asillustratedin figure theanalysistimeof salmatakes on average seconds to incrementally analyze an android system whenever a new app is installed.
on the other hand deldroid takes on average seconds.
figure5 theanalysistimeof salmaanddeldroidasandroid apps are added to the system.
figure6compares the analysis time of each approach with a decreasingnumberofapps.westartedwithabundleof150apps then we removed one app at a time until the system contained apps.theaverageanalysistimeof salmais0.2secondswhilethe averageanalysistimeof deldroidis35.3seconds.duetospace limitations figures 5and6show the analysis results of adding removing30apps however theproject swebsite containsthe analysis results of an experiment of adding removing apps.
due to the use of code obfuscation and dynamic class loading inandroidapps notallcommunicationscanbediscoveredusing figure6 theanalysistimeof salmaanddeldroidasan droid apps are removed from the system.
staticanalysistools.asaresult somecommunicationappearsonly at runtime e.g.
a new explicit or implicit communication.
in such scenarios salmaalsoincrementallyreanalyzesthesecuritypostureofthesystemtodetermineifthenewcommunicationposes any threat to the system.
if so salma prevents the new communication.
in addition to add appandremove app we assessed the efficiency of salma with respect to other system events mentionedintable .wefoundthatsalmatakes onaverageacrossall events .
milliseconds while deldroid takes on average across all events .
seconds.
due to space limitations details of this experiment and the evaluation results are reported at the project s website .
salma takes about two hours to statically analyze an android systemwith50appsanddetermineitsinitialarchitecturalrepresentation.thereafter salmaincrementallydetermines thearchitectureoftherunningsystem.table 3showstheperformanceof salma in statically analyzing apps merging removing an appto from the architectural model and intercepting and checking anicctransactionagainstthestoredsecuritypolicies.tofurther improve efficiency the static analysis time can be performed in advanced without waiting for a user to install an app.
all other times in table3cannot be perceived as delays by users which follows recommendations from android development guidelines .
table salma s static analysis and runtime performance.
static merge app remove app validating analysis to the model from the model icc trans.
minute second second second average .
.
.
.
std dev.
.
.
.
.
overall these results corroborate the efficiency and the scalability of salma in incrementally analyzing android systems.
.
rq2 disruption enforcing security policies at runtime by preventing permissio n induced icc attacks may disrupt benign behaviors of an app.
permission inducedattacksaresecuritybreachesenabledbypermissionmisuse i.e.
privilegeescalation identicalcustompermissions contentpollution andpassivedataleaks.preventingpermissioninduced attacks can be applied at install time or runtime .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self protection of android systems from inter component communication attacks ase september montpellier france install time approaches such as kirin prevent the installation of vulnerable apps.
runtime prevention approaches can either prevent only the malicious communication whenever it occurs asperformedin salma deldroid sealant and separ or revoke permissions of vulnerable apps at runtime as in terminator and appguard .
for this experiment we analyzed a bundle of apps the apps used in rq1 and found that apps are vulnerable to various permission inducedattacks.wethencomputedthe disruption in eachvulnerableappcausedbytheenforcementofthevarioussecurity policy mechanisms discussed earlier.
disruption of an app a is computed using the following equation disruption a compsdisr a compstot a wherecompsdisr a is the set of components in app athat are disruptedand compstot a arethesetofallcomponentsinapp a. we consider a component cto be disrupted if cuses a permission p involvedinapermission inducedattack since cwillbeunableto provide its full services if pis revoked.
as an example consider an app avwith components where ofitscomponentsusepermission ptoprovidetheirservices.one component using pis vulnerable to a privilege escalation attack.
in this case to protect the user the install time approaches prevent the installation of av disrupting all of its components i.e.
disruption av .ontheotherhand approachesthatrevoke permission will revoke pto prevent the attack resulting in disruptionofthatapp i.e.
3componentswillnotbeabletoprovide theirfullservicesduetothelackoftherequiredpermission p.however salma whichonlypreventsmaliciouscommunicationwhen itoccurs resultsin0 disruption sinceallcomponentswillbeable to provide their full services while keeping the system protected.
figure7comparesthethreedifferentpermission inducedprevention mechanisms.
the diagram shows that salma has .
disruption meaningthatsalmadoesnotdisturbcomponentsfrom providing their services except in one identical custom permission case.
in that case salma created a security policy to revoke acustom permission from the malicious app so it will not be able to access the vulnerable app.
on the other hand the install time approachperformstheworst asitdoesnotallowinstallation of avulnerable app.
finally revoking permissions atruntime to prevent permission induced attacks would result on average per app in disruption.
meaning that on average of thecomponents in a vulnerable app will not be able to provide their fullservicesduetothelackofrequiredpermissionseventhough some of these components are not vulnerable or involved in any figure disruption results for each appvulnerability.
moreover revoking permissions from apps at runtime lead to crashes or unexpected behaviors due to inappropriate handling of dynamic permissions in android .
deldroid separ sealant andsalmaallattempttopreventmaliciouscommunicationwheneveritoccurs.however unlike salma the other three approaches assume that all permissions aregrantedtoallappsindefinitely.thisassumptionincreasesthose approaches false positives which in turn increases unnecessary disruption.
for example a privilege escalation vulnerability is not exploitable unless the escalated permission is granted to the vulnerable app.
howev er the three appr oaches prevent vulnerable communication at all times while salma prevents vulnerable communicationonlywhenthesystemisatrisk i.e.
thepermission is granted to the vulnerable app.
.
rq3 attack detection and prevention to evaluate salma s ability to detect and prevent security threats we conducted a thorough evaluation using malicious and vulnerablereal worldappswithknownsecurityattacks andcomparedthe detectionandpreventionresultsof salmawithstate of the art approaches.
we included state of the art approaches that are publically available provide detection and prevention mechanisms and extend the android framework.
to that end we includeddeldroid separ andsealant .deldroid determines the least privilege architecture of an androidsystem and enforces it at runtime.
separ provides an automatic schemeforformalsynthesisandenforcementofandroidiccsecurity policies.
sealant is a technique that combine static analysis withdynamicmonitoringtodetectsecurityvulnerabilitiesinandroid apps and prevent icc attacks.
toconductthisexperiment weused maliciousandvulnerable apps for which the steps and inputs required to create the attackswereknownanddocumented.theseappshavebeenused intheevaluationoftheincludedapproaches.intotal thesubject appscontain94iccattackswhere45ofthemarehiddenattacks i.e.
themaliciouscodeisnotpartoftheapps bytescodebutinstead is loaded at runtime using the dynamic class loading feature as describedin andtherest 49attacks arenothiddenattacks i.e.
themaliciouscodeispartoftheapps bytecode.weraneachapproachonthesubjectapps thendeployedtheappsontheandroid environment andmanuallyexercisedallknownattacks.wereport the number of detected and prevented attacks for each approach.
theattack detection column in table 4show the evaluation results of each approach for detecting the security attacks.
for example salma and deldroid detected all of the privilegeescalationinstancesthatarenotdynamicallyloaded i.e.
nothidden attacks whereas separ and sealant detected only and attacks respectively.accordingtotable salmaisabletodetect all attacks including the hidden attacks with no false positives or false negatives while the detection rate of the other approaches ranges from to .
given the reliance of the included approachesonstaticprogramanalysistodetectsecurityrisks allof them are unable to detect hidden attacks launched via dynamically loadedcode seethegrayareaintable .however sincesalmaincrementallyanalyzesthesecuritypostureofthesysteminresponse to system changes i.e.
new inter app communications added at runtime recall section .
salma is able to detect these attacks at runtime.
theattackprevention columnintable 4showstheevaluationresultsofeachapproachforthwartingthesecurityattacksatruntime.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france mahmoud hammad joshua garcia and sam malek table the ability of salma in detecting and preventing security attacks compared to the state of the art approaches.
attack typesecurity attack attacksattack detection attack prevention count deldroid separ sealant salma deldroid separ sealant salmanot hidden intent spoofing unauthorized intent receipt privilege escalation identical custom permission content pollution passive data leak 7hidden intent spoofing unauthorized intent receipt privilege escalation identical custom permission content pollution passive data leak total attacks detection prevention rate salma is able to prevent all security attacks in table 4at runtime while the prev ention rate of the other approaches ranges from to .
interestingly deldroid is able to prevent some of the icc attacksthatitdidnotdetect becauseitpreventsallcommunications that are not part of the statically determined architecture.
related work attackdetection.
numerousstaticanalysisapproacheshavebeen proposed in the literature for detecting icc attacks in android systems and .
covert presents an approach for compositional analysis of android interappvulnerabilities.didfail tracksdataflowsbetweenandroid components.
similarly iccta leverages an intent resolution analysis to identify inter component privacy leaks.
unlike salma alloftheseapproachescannotdetecticcattacksconductedthrough dynamic class loading.
attack prevention.
deldroid is an approach that determines the least privilege architecture of an android system and enforces it at runtime.
similar to salma deldroid analyzes the architecture of an android system for icc vulnerabilities and modifiestheandroidplatformtoenforcethedeterminedarchitecture.
unlikesalma deldroidisadesign timesolutionthat does notchangethederivedarchitectureasthesystemevolves assumes that all permissions are granted to apps indefinitely which increasesdisruption and assumesthatallhiddencommunications are malicious which further contributes to disruption.
otherapproaches suchas and statically analyze android apps and dynamically enforce security policies to preventiccattacks.ipc inspection isanosmechanismfor preventingprivilege escalationattacksthatreducesthepermissionsassignedtoanappwhenitcommunicateswithanapphavingfewer privileges.kirin detectssecurityvulnerabilitiesbyonlyanalyzinganapp sconfigurationfile.separ andsealant rely on the analysis results generated by covert to prevent icc attacks at runtime.
terminator performs temporal analysis forpreventingpermission inducediccattacks.allofthesetools do not update their models once the system changes.
anothersetofapproachesleveragedynamicanalysistechniques todetectandpreventsecurityattacks .appfence preventsappsfromexfiltrationofdataoutsidethedevice.quire prevents privilege escalation attacks from leaking data outside the deviceusingtheinternetpermission.saint extendsthefunctionalityofkirintoallowforinstall timepermissionassignment andtheirrun timeuseasspecifiedinthepoliciesprovidedbyan app s developer.
xmandroid presents a solution for privilegeescalationattacksbyrestrictingcommunicationatruntimebetween applications that could lead to dangerous information flows.
while salma automatically analyzes the system and creates security policiestopreventiccattacks allofthesetoolsdependupondefining securitypolicies bydevelopers and theyrequire modifications to apps implementation logic.
conclusion thispaperpresentssalma anautomatedself protectingandroid system that monitors itself and adapts its behavior at runtime to prevent icc security risks.
salma maintains a precise runtime model represented as a multiple domain matrix mdm and incrementallyandefficientlyanalyzesanandroidsysteminresponseto incrementalsystemchanges.themaintainedarchitectureisused toreasonabouttherunningandroidsystem.everytimethesystem changes salmadetermines theimpactedpartofthesystem and thesubsetofthesecurityanalysesthatneedtobeperformed therebygreatlyimprovingtheperformanceoftheapproach.ourexperimentalresultsonhundredsofreal worldappscorroborate salma s efficiency and scalability with minimal disruption.
android components are increasingly shipped with native binariesthatareshowntohavememory basedvulnerabilities e.g.
buffer overflow .
modeling native code in mdms building associatedsecurityrulesfornative codevulnerabilities andmodeling the interaction among managed and native code in mdms can provide further attack detection and prevention but complicate analyses and may lead to scalability issues.
such challenges are interesting avenues of future work.
acknowledgment wethankhamidbagheriforhiscontributionstothiswork.this work was supported in part by awards ccf cns and ccf from the national science foundation hshqdc c b0040 from the department of homeland security and fa95 from the air force office of scientific research.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
self protection of android systems from inter component communication attacks ase september montpellier france