energy profiles of java collections classes samir hasan computer science and software engineering auburn university szh0064 auburn.eduzachary king computer science and software engineering auburn university zok0001 auburn.edumunawar hafiz computer science and software engineering auburn university munawar.hafiz gmail.com mohammed sayagh mcis polytechnique montreal mohammed.sayagh polymtl.cabram adams mcis polytechnique montreal bram.adams polymtl.caabram hindle dept.
of computing science university of alberta abram.hindle ualberta.ca abstract we created detailed profiles of the energy consumed by common operations done on java list map and set abstractions.
the results show that the alternative data types for these abstractions di er significantly in terms of energy consumption depending on the operations.
for example an ar raylist consumes less energy than a linkedlist if items areinserted at the middle or at the end but consumes more energy than a linkedlist if items are inserted at the start of the list.
to explain the results we explored the memoryusage and the bytecode executed during an operation.
ex pensive computation tasks in the analyzed bytecode traces appeared to have an energy impact but memory usage did not contribute.
we evaluated our profiles by using them toselectively replace collections types used in six applicationsand libraries.
we found that choosing the wrong collec tions type as indicated by our profiles can cost even more energy than the most e cient choice.
our work shows that the usage context of a data structure and our measured energy profiles can be used to decide between alternative collections implementations.
categories and subject descriptors d. .
metrics complexity measures performance measures keywords energy profile collections api java .
introduction limiting energy consumption is an emerging concern in software research .
the scale of data centers and the limited battery lifetime of ubiquitous mobile devices have forced the owners and makers of these permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full cita tion on the first page.
copyrights for components of this work owned by others thanacm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
to monitor and budget for energy at all fronts software included.
although there is a growing need for de velopers to optimize the energy e ciency of their software they are typically unaware of how to do this .
researchers have recently started focusing on autotuning the energy consumption inside software to optimize energy e ciency .
g otz and colleagues contributed the initial work following the autotuning optimization approaches in performance improvement e.g.
.
bunse and colleagues focused on adapting systemsat runtime to use the most energy e cient sorting algorithm.
in recent work manotas and colleagues designed a tool for autotuning java applications by selecting the most energy e cient implementations for collections apis.
another approach to optimize energy e ciency is to inform developers about the energy consequences of their high level coding decisions specifically to find alternative coding idioms.
researchers have explored the energy impact of design patterns and refactoring .
however they were not able to provide specific guidelines perhaps because the energy footprints of these coding decisions were too small.
manotas and colleagues achieved significant energy saving only by replacing java collections classes butthey were not able to explain what is contributing to the im provement.
instead they followed a search based softwareengineering approach to find the alternative that produces the most energy e cient result.
our work focuses on creating energy profiles of popular java collections classes in order to guide developers.
specifically we created energy consumption profiles of commonly used api methods for variants of three collections datatypes list map and set.
then we investigated thereasons behind the di erence in energy profiles by considering memory usage and bytecode executed during an operation.
finally we explored how the collections instances are used in real applications and how the usage impacts the overall energy consumption.
using the per method energyprofiles as building blocks a developer can estimate the en ergy impact of each collections instance and choose a more e cient alternative if available.
an essential property is that the profiles respect the constraints developers are tied to since developers choose a collections class on purpose e.g.
a list instead of a set or a map.
hence proposing aset or a map to swap a list is confusing as a guideline.
this is di erent from an autotuning approach that aggressively swaps collections classes based only on api match .
ieee acm 38th ieee international conference on software engineering this paper presents profiles for collections types chosen from the java collections framework apache commons collections and trove .
we collected the energy usage data using the greenminer framework .
our profiles indicate how the energy consumption of these implementations varies with input sizes and data types.
wenoticed that for smaller lists size the energy consumption di erences are small while the di erences are more prominent if there are many elements.
we found that opera tions that contain expensive computation tasks in bytecodetraces appear to consume more energy.
surprisingly memory usage did not seem to have an impact.
in fact a list containing integer elements is more expensive than a listcontaining objects extra operations for auto boxing con tribute rather than the memory requirement of elements.
we evaluated our energy consumption profiles by modifying the list classes in four open source java libraries onejava application and one android application.
the energymeasurement shows that choosing wrong collections classes can impact energy consumption by over perhaps an extreme case while choosing a green option can improve energy consumption by as much as .
our results indicate that the di erences in energy consumption follow the trends suggested by our profiles.
theimpact is large when large collections are created during execution.
this paper makes the following contributions we describe a method in which the energy consumption profiles are measured on coding idioms in isolation and are then used to provide guidance for choosing alternative coding idioms.
we measure the energy profiles of various kinds of col lections classes obtained from di erent sources and also profile energy consumption for varying input sizes andelement types section .
we explored two possible alternatives to explain energy consumption di erences between operations section .
we evaluate on real applications whether the alternative collections classes can be swapped to predictablyimprove or worsen energy consumption section .
our results are encouraging since energy consumption profiles seem to have the potential to provide a developerguidance about choosing among java collections.
if energy profiles of alternative coding idioms are available developers can use them as a guideline to choose the green optionbased on their coding context.
.
collections classes in our study java collections classes store group of objects and provide apis to access modify or iterate over the elements.
javaships with the java collections framework jcf whichprovides reusable and convenient implementations of popular data structures and algorithms.
there are also many third party implementations of similar structures.
we studied two third party implementations apache commons collections acc and trove.
from acc we studied implementations that are alternative to those already in jcf.
the trove collections only hold primitivedata types since their goal is to reduce memory usage andimprove performance trove requires three times less heap space than jcf implementations for larger collections .
the collections classes we studied are shown in table .table profiled collections classes tintarraylist tintlinkedlisttinthashset tintinthashmap trovehashedmaplinkedmaptreelistapache collections framework acc listorderedsetmapbackedsethashsettreesetlinkedhashset arraylistlinkedlist hashmaptreemap java collections framework jcf set map list library we profiled the energy consumption of single api methods common across the implementations.
more results and profiles are available at the project webpage google.com site collectionsenergy .
.
energy measurement infrastructure setup we used greenminer s hardware infrastructure to measure the actual energy consumed in joules j by our testprograms.
each test was allowed to run to completion and the energy consumed by each test was recorded.
.
the greenminer infrastructure greenminer is a hardware software continuous testing suite.
it instruments numerous devices runs tests onthese devices and measures the energy consumption and power use of the entire device as the tests run.
the greenminer client is a raspberry pi that acts as a test bed it controls an android test device.
the pi executes tests on thedevice and collects the results from an arduino board that monitors the energy consumption of the test device.
energy is measured via an ina219 energy measurement chipthat samples and aggregates measurements times asecond.
the test bed records and uploads the ina219 aggregate measurements to the greenminer webservice.
.
measurement process to measure the e ect of using di erent workloads on different collections a basic android app was created.
this test app displays a blank screen and sits idle.
the screen energy consumption is constant throughout the test .
the test app is a sca old for junit tests to run the experiments.
each unit test for the test app is a separate experiment or run.
in each test a collections class was created and initialized and a workload insertion iteration etc.
was run against it.
the energy consumed by the test was measuredand recorded with greenminer.
each greenminer run executes unit tests for a specific use case.
for example for the use case insertions at the beginning of lists we wrote junit tests for the list alternatives .
in each test n items were added to the beginningof the list.
we varied the input size n from to 13di erent sizes and prepared tests for each of them.
thus for this use case the test device ran di erent tests kinds of lists x list sizes .
each test given all parameters was run times on greenminer and the results were collected.
we chose measurements per test to be able to measure a confidence interval and to have enough statistical power to distinguishbetween di erent energy e ciencies of the di erent collections.
the reports were downloaded and collated as they report the energy consumed during each run and also the mean of arraylist jcf linkedlist jcf tintarraylist trove tintlinkedlist trove treelist acc mean joules j elements in list a insertion at beginning arraylist jcf linkedlist jcf tintarraylist trove tintlinkedlist trove treelist acc mean joules j elements in list b insertion in middle arraylist jcf linkedlist jcf tintarraylist trove tintlinkedlist trove treelist acc mean joules j elements in list c insertion at end arraylist jcf linkedlist jcf tintarraylist trove tintlinkedlist trove treelist acc mean joules j elements in list d iteration arraylist jcf linkedlist jcf tintarraylist trove tintlinkedlist trove treelist acc mean joules j elements in list e random access figure energy profiles for insertion a c iteration d and random access e on list implementations.
runs.
we prepared the energy consumption profiles by plotting the means against the input size n. there were however a few issues with this approach.
first we needed to ensure that each unit test encounters the same overhead.
second since our code fragments were small their energy consumption could also be too small tobe observable.
finally the actual energy consumed by atest suite varies from device to device and the greenminersystem is attached to di erent devices thus we forced all of the tests to run only on a single device.
we took several measures to deal with these issues.
ensuring a fixed overhead.
we created a new instance of all tested collections inside setup irrespective of the one that is actually used for the particular test.
for instance when inserting items into a linkedlist all the list instances were first created throughthe setup method followed by the actual insertions.
producing observable changes.
inside a test method we repeated the api invocation multiple times.
for example when inserting items therewere runs of invoking setup inserting invoking teardown .
all the unit tests were designed similarly.
thus the numbers on our graphs are an aggregate insteadof the performance of a single run.
this produces an ob servable e ect on the energy consumption of the test suite.
ensuring device consistency.
we ran all our tests on a single device to remove inconsistencies.
all devices in the greenminer system use phonesof the same model but we chose to use one for all measure ments to minimize di erences in device specific performance.
although each phone may report slightly di erent energies the important measure here is not the absolute energy butrather the di erence between two readings.
as long as we use a single device we expect the di erences to be consistent.
.
energy profile results we profiled the energy consumption of some of the common api methods provided by list map and set imple mentations and recorded how this varies with input sizes.
specifically we asked six research questions.
rq1.
which list implementation is the most energy e cient for insertions iteration and random access?
rq2.
which map implementation is the most energy e cient for insertions iteration and random access?
rq3.
which set implementation is the most energy e cient for insertions iteration and random access?
rq4.
how does the input size a ect the energy consumption of the collections?
rq5.
how does storing di erent elements a ect the energy consumption of the collections?
rq6.
how can we use the profiles to choose the most energy e cient implementation of list map and set?
rq1 rq2 and rq3 compare the energy profiles created for list map and set implementations rq4 and rq5 are about measuring the impact of input sizes and data types rq6 is about using the results as a guideline for developers.
.
.
.
.
.
.
hashmap jcf linkedhashmap jcf treemap jcf tintinthashmap trove hashedmap acc linkedmap acc mean joules j elements in map a insertion hashmap jcf linkedhashmap jcf treemap jcf tintinthashmap trove hashedmap acc linkedmap acc mean joules j elements in map b iteration hashmap jcf linkedhashmap jcf treemap jcf tintinthashmap trove hashedmap acc linkedmap acc mean joules j elements in map c random query figure energy profiles for insertion iteration and query on random keys in map implementations.
rq1.
which list implementation is the most energy efficient for insertions iteration and ran dom access?
key result for insertions at the beginning jcf s linkedlist consumes the least energy followed by trove s linkedlist.
for insertions at the middle and at the end trove s arraylist is the most energy e cient followed by jcf s arraylist.
energy does not vary when lists expand.
insertion figures a b and c demonstrate the energy con sumption trends for insertion tests for list implementations.
for small sizes the di erence in energy consumption for insertions at the beginning of the list is evident only for treelist.
even at size treelist consumes more energy than arraylist.
for larger sizes linkedlist is more e cient.
at input size of linkedlist consumes less energy than tintlinkedlist the next best performer.
compared to the worst performing treel ist linkedlist consumes less energy.
when inserting items at the middle an interesting pattern emerges between the di erent list implementations.
arraylist and tintarraylist have very similar and quite ef ficient energy performance.
next treelist and linkedlistboth have similar yet not quite as e cient performance.
and finally tintlinkedlist has the worst performance byfar.
at input size of arraylist and tintarraylist perform better than tintlinkedlist a large di erence that increases to at size .
there is a substantial amount of extra energy required by treelist linkedlist and tintlinkedlist to perform insertion at the middle as opposed to at the beginning.
for insertions at the end of the list the energy di erences are not obvious for input sizes below for all lists with the exception of treelist which has a notice able degradation of for size figure c .
for larger sizes however the di erences become more evident.
tintarraylist saves energy compared to arraylist and when compared to treelist the next best and worst energy rated lists respectively.
we also gathered similar profiles for the case when arraylist and tintarraylist are not set to a predefined ca pacity during creation.
uninitialized array lists need toreallocate memory when current capacity is not su cient.
due to this dynamic resizing we expected a di erence in energy consumption trends compared to the previous initial ized version.
however there was no di erence in the energy consumption for the uninitialized version especially whenadding items at the middle and at the end of the list.
even with dynamic expansion arraylist and tintarraylist are still more energy e cient than others.
therefore initializing an arraylist variant with a capacity is not necessary it will perform well anyway.
iteration figure d shows the energy consumption profile for iter ation with an iterator.
for small sizes iteration over an arraylist is slightly more energy e cient while for items it has a maximum energy savings of .
the results show that there is not much di erence when comparing energy consumption of iteration over the lists.
random access when accessed through randomly generated indices we did not observe any major di erences in energy consumption for list sizes smaller than as shown in figure e .
for larger input arraylist tintarraylist and treelist were the most energy e cient producing a savings of compared to linkedlist and when compared to tintlinkedlist.
rq2.
which map implementation is the most energy efficient for insertions iteration and ran dom access?
key result hashmap is the most energy e cient alternative for insertions and random queries.
if insertion order should be preserved acc s linkedmap is slightly better on insertions than jcf s linkedhashmap.
treemap is energy hungry and should be avoided unless explicitly needed.
insertion figure a shows the energy consumed by inserting keyvalue pairs in map implementations.
unlike list implementations there are some variations in energy consumption even for smaller maps.
for sizes up to items all except treemap perform equally well.
treemap energy consumption increases drastically with larger input size.
for 000insertions it is more expensive than hashmap and more expensive than linkedhashmap.
all other maps perform equally well for sizes up to .
interestingly hashmap performs consistently better thanall other maps until size where linkedhashmap has a drop in energy consumption and saves energy over hashmap.
for most of the cases trove s tintinthashmap .
.
.
.
.
hashset jcf linkedhashset jcf treeset jcf tinthashset trove mapbackedset acc listorderedset acc mean joules j elements in set a insertion hashset jcf linkedhashset jcf treeset jcf tinthashset trove mapbackedset acc listorderedset acc mean joules j elements in set b iteration hashset jcf linkedhashset jcf treeset jcf tinthashset trove mapbackedset acc listorderedset acc mean joules j elements in set c random query figure energy profiles for insertion iteration and query on random keys in set implementations.
consumes more energy than hashmap.
this was surprising since the trove implementation with primitive data types did not improve upon jcf hashmap.
iteration similar to our findings for lists the iteration performance is almost the same for all implementations figure b .
for larger lists jcf s hashmap requires a little less energy while acc s hashedmap ended up being the most expensive.
however the di erences are very small for large lists and even more so for smaller ones.
random query the random query performance shows an interesting trend as shown in figure c .
for sizes up to treemap is con sistently one of the two most energy e cient maps.
however for larger lists treemap queries become the most expensive while hashmap consumes the least energy a minimum savings of compared to linkedhashmap and a savings of when compared to treemap.
rq3.
which set implementation is the most energy efficient for insertions iteration and ran dom access?
key result hashset is the most energy e cient alternative for insertions and random queries.
acc s listorderedset is the most energy e cient set for iterations though not by a large margin.
treeset is energy hungry and should be avoided unless explicitly needed.
insertion figure a shows the energy profiles for set insertions.
for input sizes less than all implementations are quite close but for a larger size noticeable di erences arise.
trove s tinthashset is consistently the most e cient saving energy over hashset and over treeset.
iteration the iteration performance is similar for all implementations figure b there are no apparent di erences for sizes up to .
for large lists acc s listorderedset is the mostenergy e cient with a maximum energy saving of .
again there are often larger energy savings between smallerinput sizes than there are between larger ones for example at size acc s listorderedset has an savings over jcf s linkedhashset whereas the savings between thesame implementations at size are only a mere .random query figure c shows the energy profiles for random queries.there are many energy spikes throughout the various input sizes.
interestingly the largest di erences between implementations are in the medium size inputs between sizes and .
another notable trend is that treeset starts out in the smaller inputs to be one of the most e cient implementations for smaller sizes then for larger sizes has an degradation from the optimal performing hashset.
however at size treeset actually saves over hashset.
rq4.
how does the input size affect the energy consumption of the collections?
key result for input sizes all alternative implementations of list map and set perform equally well.
to determine the statistical significance of energy di erences we determined for each alternative collection and each size the confidence intervals of the energy consumptionmeasurements.
for each size we then compared the confidence intervals of each alternative collection in terms of overlap.
non overlapping intervals indicate a significant difference between the corresponding collection types.
we found that smaller collections with less than elements do not show a significant di erence in energy consumption between alternative implementations.
the di erences get larger and become significant as we deal with more elements.
for example for list insertions at the beginning we compared arraylist and linkedlist among others andfound that for a size of the confidence intervals wereoverlapping.
however for elements the intervals became disjoint.
after comparing all other implementations in a similar way we found the size to be an appropriatethreshold across all collections types.
rq5.
how does storing different elements affect the energy consumption of the collections?
key result operations on primitive data types in lists surprisingly consume more energy than inserting small object types in a list.
when running list insertion and iteration tests on small objects we expected the energy consumption to be higher than the lists containing primitive elements.
yet the energy 229random accessinsertion iteration treelistlinkedlisttintarraylist tintlinkedlistat beginning at middle arraylistat end a list matrixquery insertion iteration treemaplinkedmaphashedmaptintinthashmap linkedhashmaphashmap b map matrixquery insertion iteration treesetlistorderedsetmapbackedsettinthashset linkedhashsethashset c set matrix1 65rank best worst figure color map showing the rank of each list map and set implementation per use case.
green identifies an implementation as energy e cient while red denotes it as energy hungry.
therefore the greener the color the better.
profiles of integer runs were consistently higher than those of the small objects.
figure shows a scatterplot comparing the energy consequences of a list of integers versus a list of small objects the results are shown for arraylist andlinkedlist.
some inputs of the arraylist are not shownsince they skew the graph.
the majority of the points liebelow the line y x whereas we were expecting all points to lie above it.
for size inserting an integer in the beginning of a jcf linkedlist is more expensive than inserting a small object.
the results are consistent with other list operations.
more details and graphs are on the project webpage.
since java generics do not support primitive types the integers are auto boxed as integer objects in order to be held in the collections.
the lists have to add and removethis wrapper at runtime.
the results are likely due to this behaviour.
rq6.
how can we use the profiles to choose the most energy efficient implementation of list mapand set?
key result in general tintarraylist is the most energy e cient list implementation followed by arraylist.
for maps hashmap is the best while for sets hashset is the most energy e cient with tinthashset as a close second.
above the minimum input size threshold of items as mentioned in rq4 we can use our profiles to choose the most energy e cient implementation based on the way the collections classes are used.
figure summarizes our findings as choice matrices that can help in making these decisions.
each color denotes a rank green identifies the most e cient implementation while red indicates the worstamong the alternatives.
in each table a row with more greenin it is likely to be more energy conservative on average.
in general tintarraylist hashmap and hashset not shown are the standout collections implementations followed closely by arraylist and tinthashset.
lists stored as arrays are preferred in general.
linked list variants onlywork better if they are required to behave like a stack i.e.
a datatype with items added and removed from the front.
figure may also help in finding the best collections im plementation instead of the best library since one can eas ily mix and match di erent implementations of di erent libraries.
choosing one collection from one of the libraries does not lock developers into that library.
.
why these energy differences?
we carried out further investigations to discover the key factors that may explain the di erent energy consumption .
.
.
.
.
.
arraylist jcf linkedlist jcf mean joules j small objects mean joules j integers figure comparing insertion of small objects to insertion of integers.
profiles.
we explored two possible factors memory usage during api operations and time consuming bytecodeinstructions executed during api operations.
here we explain the di erences in energy consumed during di erent kinds of insertion operations add methods on list implementations.
other collections types and api methods are covered on our project webpage.
.
memory usage we recorded memory consumption for list instances before and after invoking the add operation while adding items to the list.
we chose since rq4 showed that col lections with or more items show significant di erences in energy consumption.
figure shows the resulting memory usage graph when inserting at the beginning of the list.
the graphs for inser tions at the middle and at the end of the list were almostthe same which indicates that no matter how the itemsare inserted into the list the memory footprints are similar.
yet the energy profiles were di erent for the di erent insertion approaches figures a c .
therefore memory consumption is not a significant driving factor behind the di erences in energy consumption.
.
executed dalvik bytecodes we generated bytecode traces during the execution of anadd operation on two list instances arraylist and linkedlist and compared them.
first we used dexdump to extract the application s bytecode.
then we instrumentedeach line of the bytecode using the andbug debugger tool which implements the java debug wire protocol jdwp .
upon execution the tool prints out the executed bytecode and the corresponding source line.
arraylist jcf linkedlist jcf tintarraylist trove tintlinkedlist trove treelist acc memory usage kb elements in list figure memory usage of list implementations during insertion at the beginning.
comparing the traces we identified two bytecodes that may have an impact on the runtime and therefore energy performance iget object and invoke static .
when elements are inserted in the middle iget object is executed many more times than the other instructions.
this is be cause linkedlist traverses half of the list to reach to themiddle and locate the position for the new item.
the largerthe list becomes the more traversals are needed.
for example when the thelement is inserted to a list iget object is executed times more than the next frequently occurring instruction.
this may explain why linkedlist consumesmore energy than arraylist as shown in the energy profile figure b .
the impact of bytecodes are less obvious when elements are inserted at the beginning or at the end.
when inserting at the beginning invoke static dominates the execution for an arraylist used to execute the expensive system.arraycopy method .
this di erence in workload is probably why an arraylist instance consumes more energythan a linkedlist instance for insertions at the beginning as shown in our profiles.
however invoke static is also executed while inserting elements at the end.
in this case itsimpact is likely o set by many other bytecode instructionsonly found in linkedlist execution traces new instance and invoke direct .
hence this analysis is not enough to explain why arraylist performs better in this context.
this is left as future work.
.
evaluation the energy profiles compare the collections classes for each api method and suggest better alternatives cf.
rq6 .however when collections instances are used in applications multiple api methods are invoked on each object depending on the role of the object in the system and the load of the system.
hence we expect that the energy footprint of each collections object in an application is determined by a combination of the energy impact of all invoked api meth ods.
to analyze this we ask two more research questions rq7.
do the di erent collections classes have an energy impact in real applications compared to what we found for similar collections in the profiles?
how large is the impact?
rq8.
can we use the energy profiles to switch to an alternative collection and improve or degrade the energy consumption of an application?
app app test suite inter procedural program analysis manual analysiscollections usage profile good and bad use bytecode app test suite modified application original application analysis outputsource code script for rewriting source codesource code figure evaluation workflow.
to answer rq7 we modified real applications to use alternative collections classes and measured the energy consumed by the modified applications.
previous work hasdemonstrated that collections classes do have an impact .we extend this state of the art by selectively based on the usage profile of each instance modifying the collections instances using the energy profiles rq8 we create good and bad versions of the original program when possible and compare their energy consumption using greenminer.
using the methodology of figure we studied the energy consumption of four popular java libraries googlegson apache commons math xstream apachecommons configuration an open source email client k mail and a stock exchange trading simulator application.
each library came with a large test suite kloc .
we analyzed the collections instances used in thecode to create usage profiles i.e.
to determine which apimethods are being invoked and where.
we wrote an interprocedural program analyzer based on wala that automatically analyzes program bytecode.
our wala analyzer detected three kinds of collections instances collections instances declared as fields of aclass and used in multiple methods collections instances locally created inside methods and used in the same method and collections instances locally created inside methods but used in multiple methods since they are passed as a re turn value.
the inter procedural analysis uses call graphs and control flow graphs created by wala to collect usage profiles for these instances.
currently we do not supportthe analysis of collections instances when they are passedas an argument to a method.
adding this would require an other inter procedural analysis but we did not find enough such instances to justify the implementation.
we manually analyzed these remaining instances.
for each collections instance found by wala or our manual analysis we identified if it is used in an energy appropriate manner or a better alternative is available based on simple heuristics derived from rq6.
to create a good version welooked into the usage of collections instances to see whetherswapping to another collections class may save energy.
forexample our profiles suggest that arraylist is more energye cient than linkedlist when inserting items at the end of the list or when iterating over the list these two are the most common list methods .
so if a linkedlist is used ina program for these operations our wala program will detect it and indicate that we can improve energy consumption by replacing linkedlist with arraylist.
similarly we prepared bad versions by going against our profiles.
for example the profiles suggested that arraylistis more energy e cient than linkedlist for common list operations.
instead of following this recommendation a bad 231version replaces arraylist with linkedlist.
we expected this change to increase the energy consumption.
next we used a python script to perform lexical analysis on the source code and transform the list instances to alternatives that should improve or degrade the energy consumption.
a simple lexical analysis was su cient sincewe swapped between alternative collections instances with almost the same api similar to manotas et al.
.
furthermore we chose to deal only with lists during our eval uation.
there are two reasons behind this choice.
first changing arraylist to linkedlist or vice versa is safe the code if it compiles behaves the same way irrespective of the implementation.
this may not be the case if we changea hashmap to a treemap since if the key object does nothave an appropriate compareto method defined the maps may behave di erently.
it is even more di cult to convert a treemap to a hashmap since the sorting behaviorof a treemap may be desired in a usage scenario.
second lists are more widely used than other collections such as maps or sets gson k mail apache commons math xstream apache commons configuration stock exchange trading simulator .therefore the energy contribution from lists is probablyhigher than that from other collections.
eventually we created four bad versions and three good versions.
for the first three libraries the developers almostexclusively used arraylist whenever they needed a list datastructure and followed the common usage profile of addingan item at the end of a list and or iterating the list.
thus we found little scope to improve on the energy consumption for these libraries.
instead it was more interesting for thosethree systems to demonstrate worse energy performance bychanging most of the arraylist instances to linkedlist.
in k mail we had comparatively more linked lists so there was a scope to make improvements.
we therefore had both a good and a bad version for it.
we also made good versions of the apache commons configuration library and the stock exchange trading simulator application since their usage of lists could be optimized for energy consumption.
the next sections describe the results of our analyses for the six applications.
to address rq7 we report the energy impact when we used alternative collections instances while for rq8 we report the changes that we made guided by our profiles to get a good or a bad version.
.
google gson google gson is a serialization deserialization library that provides mechanisms to convert java objects to json and back .
we used version .
for our study consisting of about kloc and a test suite of kloc.
the gson api refers to most of the collection instances through collections interfaces e.g.
list map and set.
the developerchooses whether to use an arraylist or linkedlist instance for example where a list is required.
changes made.
we found arraylist instances in the codebase .
only of these instances are part ofthe library code while are in the test suite.
our walaprogram discovered instances on which end insertions and iterations were performed modifying these to linkedlist instances should be a bad change.
we studied the rest of the instances manually and changed instances to linkedlistthat had the same usage pattern.energy impact.
table shows the percentage of change in energy consumption of the modified application.
withlinkedlist the energy consumption increases by .
thereare two factors contributing to this large increase.
first the library performs times slower when linkedlist instances are used which may cause more energy consumption duringthe test run.
second the gson test suite has a number ofperformance tests that perform serialization and deserialization on large inputs mb .
our profiles as discussed in rq4 indicate that the energy di erences are more significant with larger collections which is directly reflected through these results.
.
apache commons math the apache commons math library provides implementations of mathematical and statistical algorithms that areotherwise unavailable in the standard java distribution .
we used version .
.
kloc app kloc test .
the library creates instances of arraylists.
there are arraylist instances in the test suite.
changes made.
since it was not possible to run all the tests on our device due to memory constraints and incom patibility issues in our study we selected a subset of tests that compiled successfully.
out of a total of instances of arraylist in the codebase and tests wala detected instances that wereused mostly for end insertions occurrences iterations occurrences and random access occurrences .
after manual inspection we found more instances that were used similarly.
our profiles suggest that linkedlist is a badchoice for these instances and we used this to make a bad version.
energy impact.
the modified version consumed more energy .
again the changed library runs .
times slower than the original version which may have caused more energy to be consumed.
.
xstream the xstream library can be used to serialize java objects in xml and deserialize it back .
xstream version .
has a library of kloc and a unit test suite of kloc.there are arraylist instances in the library code and instances in the test code.
changes made.
we choose a subset of the test suite as some tests were incompatible with the greenminer platform.
out of instances of arraylist wala detected instances that were used for end insertions occurrences iterations occurrences and random access occurrences .
we manually found another instances usedin the same way.
in total arraylist instances were con verted to linkedlist expecting higher energy consumption.
energy impact.
there is a degradation of when swapping the arraylist instances with linkedlist .
the modified version runs .
times slower than the original which may explain why it has a higher energy consumption.
.
k mail the k mail version .
codebase has kloc with a test suite of kloc.
there are a total of instances of collections used out of which only were covered by thetest suite.
to make sure more of the collections are exer2321.
k mail 0collections linkedlist apache commo ns ma th xstre amkloc 324arraylist google gson program changes good bad .
.
changes in energy consumption good bad apache commons configuration154 stock exchange trading simulator table libraries and applications for evaluating the energy profiles cised we augmented the original test suite by generating more test cases for the app.
we used jtexpert to automatically generate tests.
as this generates tests for the java platform and android tests should inherit from the class androidtestcase we modified the generated tests to adapt them to the android platform by using javaparser .
in order to know which collection method is called by the exe cuted tests we did a dynamic analysis using aspectj.
changes made.
k mail application uses arraylist instances and linkedlist instances .
with ourwala analysis we found that there was scope to prepare both a good and a bad version of the program.
our wala program found instances of arraylist that were used for arraylist friendly operations occurrences of end insertions occurrences of iterations and occurrences of random accesses .
we manually found other instances having a similar usage pattern.
we changed theseinstances to linkedlist thereby creating a bad version.
with our wala analysis we also found linkedlist instances in the codebase.
our heuristics suggested that we should change of these instances to arraylist because the lists were being used for end insertions insertions at a ran dom index and queries using the contains api.
according to our profiles arraylist is the most energy e cient choice in this context.
we therefore created a good version of theapp by changing these instances to arraylist.
energy impact.
table shows the di erences in energy consumption of the two versions.
for bad changes k 9mail performed only slightly worse with an overall degra dation of .
.
we did expect an increase in energy consumption although it is only by a small amount.
for the good changes we achieved an improvement of .
.
for both versions we noticed that the di erences were very small.
the k mail test suite is significantly di erent from the rest of the applications that we studied it does not exercise large collections.
in gson the tests were feeding a huge load mb to the lists.
on the contrary the k mail tests were dealing with lists of only a few elements.
therefore the impact was very small.
.
apache commons configuration the apache commons configuration library facilitates storage and retrieval of configuration information for javaapplications .
we studied version .
that has klocof library code and a test suite of kloc.
there are instances of linkedlist and instances of arraylist in the original codebase.
changes made.
we again choose a subset of the program that was compatible with the testing platform.
inthe reduced version we had arraylist instances and 12linkedlist instances.
out of these linkedlist instances wala detected that were used for end insertion and it eration.
we manually found the other of them to be usedin a similar way.
since our profiles indicate that arraylistis a better choice for these operations we changed these instances to arraylist expecting a decrease in the energy consumption of the test suite.
energy impact.
changing the linkedlist instances to arraylist improved the energy consumption by .
.
the modified version of the library ran .
times faster than the original which is probably why the energyconsumption was lower.
.
stock exchange trading simulator this is a java based simulation application developed inhouse at auburn university.
the program has kloclines of application code with instances of linkedlist usedin the codebase.
changes made.
our wala analysis detected instances of linkedlist that were used for end insertions and itera tions.
we manually found more instance being used in asimilar way.
since arraylist is better for both of these operations we made good changes by swapping the linkedlist instances with arraylist.
energy impact.
our modified program demonstrated a reduction in energy consumption and ran .
times faster.
.
discussion for all test applications we obtained di erences in energy consumption by changing the collections instances rq7 .the magnitude of change however depends on how aggressively the instances are exercised during program execution.
with significant usage we can get large increases in energy consumption for bad choices of collections instances rq8 .
we also noticed that for each of the applications the degradation factor for energy consumption was the same as the slowdown factor of the bad version of the program.
for example the version of gson with bad changes ran times slower and consumed times more energy than the original version.
however the power consumption of both versions i.e.
the rate of energy consumption per time unit was very similar which indicates that the bad version witharraylist instances changed to linkedlist just does morework during the extra time it is executing.
this may explain why it consumes more energy.
we found a similar trend in execution times while generating our profiles.
however to determine whether it is a consistent trend that more energy is only being consumed because of slower applications more investigation is needed.
in our wala analyzer we chose a simple heuristic to help 233us decide whether to change a collections instance.
this worked well owing to the fact that we dealt only with lists and that most of the arraylist instances that we found were performing end insertions and iterations anyway.
in the future we want to focus on developing a more sophisticated heuristic to handle other collections.
.
threats to validity a number of issues a ect the validity of our work.
first of all measurements of physical systems in particular phones inherently are a ected by noise and non determinism.
our test bed was designed to minimize such noise and to control for non deterministic di erences in measurements by repeating measurements times.
section .
discusses how we have addressed other measurement related issues.
how generalizable are our results?
the greenminer infrastructure uses android devices to perform the energy pro filing.
we ran our tests on a single phone that had a specificversion of the android os installed.
we expect these energy trends to be similar across android devices.
for example we found similar trends when we ran the tests on the otherthree devices on greenminer.
a more subtle issue may arise due to the range of the measurements that we achieved.
as we saw in the profiles the energy measurements are quite small especially for small collections.
this is expected since a single apiusage corresponds to a maximum of three lines of code performing an operation and there is a significant overhead introduced by setup and teardown methods of each test.
to validate whether this large noise could overshadow the oth erwise small energy consumption of a single api invocation we ran a separate baseline test running only the setup andteardown methods i.e.
the noise.
we found that each of our actual tests consumed substantially more energy than this baseline i.e.
our measurements reflect the energy contribution from the api usage.
.
related work there has been a large body of empirical work measuring the impact of code change in various domains.
sourcelevel modifications such as refactorings design pat terns and code obfuscation have been found to a ect an application s energy consumption.
hindle proposed green mining to study how changes across software versions a ect energy consumption .
others have worked on evaluating energy behavior of sorting algorithms web servers lock free data structures api usage of android apps recommending energy e cient android apps to users and developers and the e ect of advertisements and ad blocking on energy consumption .
li et al.
repeatedly profiled java bytecode instructions to link source code and bytecode to energy consumptionin order to estimate the energy consumption of a line of java code.
jalenunit uses powerapi and statisticalexecution sampling to automatically generate benchmarksto measure the energy consumption of an api.
researchers have measured energy in a number of ways.
hardware systems such as the atom leap platform and wattsup meters can measure actual power con sumed by an application.
cycle accurate simulators suchas softwatt sim panalyzer and simplepower provide an energy estimate by simulating cpu cycles foreach component used in executing the application.
estimation based approaches use empiricaldata to propose a model for estimating energy consumption.
pathak et al.
and aggarwal et al.
show that dynamic analysis of running systems specifically by extract ing system calls can produce accurate runtime models of asystem and estimate the energy consumption impact of achange.
similar work on execution logs by gupta et al.
fingerprinted modules for their energy consumption profile.
zhang et al.
describe an online profiler called powertu tor that models energy consumption by aggregate models ofindividual components such as network and cpu.
our work is closest to the approach taken by manotas et al.
.
the paper describes an autotuning framework seeds that aids in automatically choosing the most energye cient collection from the java collections api.
seeds achieves this by running an exhaustive trial and error on all compatible collection implementations and measuring the impact of each on the overall energy consumption of a giventest suite for the application.
our approach is significantlydi erent in making the comparison.
instead of an exhaustive search on which implementation is best for the partic ular application test suite we use empirical evidence i.e.
the energy profiles that we derived in this work and the apiusage patterns to predict the best alternative.
another closely related work is chameleon which is an autotuning approach for optimizing collection usage.however it is particularly focused on memory usage andruntime performance e.g.
clock time which could be a proxy for energy consumption.
we believe that an autotuning framework can be equipped with our profiles to make a more accurate and realistic tool.
the motivation of all of the above work comes from studies on developer and consumer knowledge about software energyconsumption that indicate that developers and consumers are not su ciently aware of how much energy their software consumes what are the energy bottlenecks and which programming practices should be avoided .
.
conclusion our results provide a guideline about the scenarios in which the energy consumption of alternative collections cla sses becomes an issue.
for insertion operations the energy di erences are significant but not that much for other list operations.
also for lists of small size the energy consumption does not vary much between the lists.
furthermore many of the di erences in energy consumption can be explained by expensive bytecode operations.
overall our results will be especially useful for developers of large scale software who commonly work with large col lections instances.
they can guide the developers and makethem aware of the consequences of their programming decisions.
our approach can also be used in making smarter autotuning tools.
most importantly this should motivatefuture work on creating better guidelines for many otheralternative programming choices.
more information is available on the project webpage