see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation recontest effective regression testing of concu rrent programs conf erence paper august .
ic se.
.
citations 29reads author s including valerio t erragni univ ersity of a uckland publica tions citations see profile shing chi cheung hong k ong univ ersity of scienc e and t echnolog y publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y valerio t erragni on sept ember .
the user has r equest ed enhanc ement of the do wnlo aded file.recontest effective regression testingof concurrent programsvalerio terragni shing chi cheung charles zhangdepartment of computer science and engineeringthe hong kong university of science and technology vterragni scc charlesz cse.ust.hkabstract concurrent programs proliferate as multi core tech nologies advance.
the regression testing of concurrent programsoften requires running a failing test for weeks before catching afaulty interleaving due to the myriad of possible interleavings ofmemory accesses arising from concurrent program executions.
asa result the conventional approach that selects a sub set of testcases for regression testing without considering interleavings isinsufficient.
in this paper we present recontestto address theproblem by selecting the new interleavings that arise due to codechanges.
these interleavings must be explored in order to uncoverregression bugs.
recontestefficiently selects new interleavingsby first identifying shared memory accesses that are affectedby the changes and then exploring only those problematicinterleavings that contain at least one of these accesses.
we haveimplemented recontestas an automated tool and evaluatedit using real world concurrent program subjects.
our resultsshow that recontestcan significantly reduce the regressiontesting cost without missing any faulty interleavings induced bycode changes.i.
introductionregression testing is known to be expensive when thesize of test suites grows over time as software evolves .
for instance under the incremental maintain and testprocesses e.g.
nightly build and test the time required toexecute all test cases can easily exceed the affordable timebudget .
the deficiency of regression testing is exacerbatedwhen testing multi threaded programs due to the much longerexecution time required to cover a reasonable amount of threadinterleavings i.e.
temporal order of a set of shared memoryaccesses .
the most widely adopted testing methodology forconcurrent programs isstress testingthat requires runningthe same multi threaded test many times to explore differentinterleavings.
thus the cost of running a single multi threadedtest is equivalent to thousands of sequential tests.to reduce the cost of regression testing researchers haveproposed to select prioritize or minimize those sequential tests that might fail after program revisions.however it is inadequate for concurrent programs to onlycover the changes of the sequential logic and forego theirramifications in the interleaving space.
as such a single multi threaded test case alone can require weeks of testing beforemanifesting faulty interleavings .like existing regression testing techniques for sequentialsoftware a common approach to reducing regressiontesting cost is to avoid re testing the unmodified portion ofthe program by assuming that all existing tests of the origi nal program run correctly p correct for t assumption .adapting to concurrent programs this assumption becomesthat all the interleavings manifested by any existing test suitetof the original programpare assumed to bebenign.suppose a test t is considered for regression testing afterrevising a concurrent programptop .
this paper studieshow to select thenew interleavingsthat can only be observedwhentruns withp denoted byp t .
exploring only newinterleavings reduces the cost of regression testing becausemost interleavings remain unchanged after program revision.achieving this goal requires to address the fundamentalchallenge of identifying the new interleavings without explor ing the unchanged ones.
naively computing thedifference setof the interleaving spaces ofp t andp t is apparently notfeasible due to it requires constructing the entire interleavingspace ofp t which is exactly the cost we want to eliminate.although there has been some effort in reducing theregressionverificationcosts for concurrent programs by reapplyingmodelcheckingtechniques e.g.
as software evolves .
to the best of our knowledge there are few prior studieson how new interleavings can be effectively selected forregression testingconcurrent programs.in this paper we presentregression concurrency testing recontest a regression testing framework for concur rency bugs.
the framework is inspired by two observations which enable us to effectively exploreonlynew interleavings.observation new interleavings must contain at least oneshared memory access impacted by the revision.
the impactcan happens in two ways.
first the access is observable inp t but not inp t because is triggered by the added mod ified statements or by a new execution path.
an example isthe access generated at line in figure .
second it is anaccess unaffected by the program modifications but there arechanges to itsconcurrency context cc characterized by itslock acquire release historiesand itshappens before relationswith respect to other threads e.g.
line in figure .intuitively all accesses ofp t with an affected cc couldinterleave in new ways with other accesses.observation a very small number of accesses are trulyaffected by program revisions.
for a testt a revision of aprogrampdoes not affect the ccs of most of the accessesappearing in the execution oft nor does it generate manynew accesses.
in our experiments with real world subjects ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee we only found on average of impacted accesses.
as aresult many accesses repeat and interleave with each other inthe same way atp t andp t the interleavings involvingthese accesses can be safely skipped in the regression testingofp t under the adaptedp correct for tassumption.leveraging these two observations recontestexploresnew interleavings in two phases phase i computes the impact set of accesses introduced by program revisions and phaseii explores only those interleavings that contain at least oneimpacted access.the key idea ofrecontestis to use theimpact set to infer new interleavings.
as a result new inter leavings can be selected without first exploring the entire inter leaving space ofp t .
since the number of new interleavingscould be enormous we guide the interleaving exploration bya concurrency coverage criterion.
the criterion considered inour experiments is the set ofproblematic interleavingsthatmatch the access patterns violatingatomic set serializability which subsumes race conditions as well as single andmultiple variable atomicity violations .these two phases addresses two research questions.
isthere an efficient mechanism to identify thetrulyimpactedaccesses?
note that existingchange impact analysisspecificto the concurrency semantics cannot guarantee tocompute a sound or a complete impact set.
given an impact set is there a way to exploreonlythe problematic interleavingsinvolving the impacted accesses?recontestaddresses the first question using a change impact analysis algorithm in phase i to compute the impact set based on theexecution tracesofp t andp t collectedby apredictive trace analysis pta technique.
thealgorithm considers a memory access to be impacted if itis observed only in the execution trace ofp t or its ccobtained from the collected execution traces is altered afterprogram revision.
the algorithm smartly handles two technicalchallenges matching an event inp t to its equivalence inp t and semantically comparing both the ccs of the pairof matched events inp t andp t .
phase ii addressesthe second question by adapting theoff lineinterleaving ex ploration of pta to searching problematic interleavings onlyamong those containing at least one impacted access.
theproblematic interleavings validated as feasible are outputtedby recontestas warnings ofregression concurrency bugs.we implement recontestas a fully automated prototypetool and evaluated it using real world java concurrencybugs.
the experiments show that our approach successfullydetected all these bugs with four orders of magnitude reductionover stress testing and pta.
recontestachieves reductionbecause the manifestation of most concurrency bugs are causedby problematic interleavings arising from a small set ofaccesses at most four .
there is a low probabilitythat these small set of accesses contain one of the few impactedones.
it is confirmed by our experiments that many problematic interleavings do not contain impacted accesses.recontestselects under two generally valid assumptionsthe interleavings of all regression concurrency bugs exhibitedbyp t .
we highlight our contributions as follows we present a dynamicchange impact analysis cia with a run time complexity linear to the length ofexecution traces section iii .
we propose heap abstractions for comparing cc acrossthe two program executions before and after revision section iii b .
we present the first algorithm to select problematic in terleavings for the regression testing of concurrency bugswithout constructing interleaving spaces section iv .
we implemented a prototype tool of our approach andevaluated it on real world java subjects section v .ii.
preliminaries concurrencycontext cc recontestleverages the execution trace collected by ptato compute the impact set and to explore new interleavings.in the following we introduce pta its execution trace model cc definition and how it is encoded by recontest.predictive trace analysis pta is a popular testingtechnique for concurrent programs e.g.
.pta detects problematic interleavings in three steps moni toring prediction and validation.
in themonitoring step ptaobserves an arbitrary concurrent program execution generatingan execution trace of memory accesses locking messagingand object creation operations.
during the trace collectionpta computes the cc of each memory access by leveragingthe concurrency operations collected.
this is because ptaneeds cc information during the validation step for pruninginfeasible interleavings.
in theprediction step pta analysesthe trace to explore problematic interleavings that could bemanifested in alternative executions by re shuffling the orderof occurrences of the memory accesses to match problematicaccess patterns e.g.
.
since the interleaving explorationis performedoff line many problematic interleavings so iden tified can be infeasible.
in thevalidation step pta therefore validates these interleavings with astatic lockset happens before checkerbased on the cc computed.
most ptas alsore execute the program to exercise the retained interleavings.an execution tracee ei captures a multi threadedprogram execution as a sequence of events.
let the events beuniquely labelled by indices in an ascending order accordingto their order of occurrences.
a program changes its states viastatement execution and generates one of the following events.
mem th loc a threadthaccesses a shared memory lo cationloc a write read is the access type acq th l threadthacquires a lockl rel th l threadthreleases a lockl snd th m threadthsends a unique messagem rcv th m threadthreceives a unique messagem objalloc th o threadthcreates an objectoin our presentation we useth x to denote the thread thatexecuted eventex ands x to denote the statement thatgeneratedex.emdenotes the ordered subsequence ofecontaining only mem events.
the set of objects created byobjalloc events is denoted aso.
a unique id denotedasid o is generated each time when an objecto oiscreated.
an acq event is generated when a synchronized 247block or method is entered and a rel event is generatedwhen exiting the block or method.
in java the snd rcvevents are generated at the call of join start wait notify andnotifyall .
for example ifo1.notify on threadth1signalso1.wait on threadth2 then eventssnd th1 m andrcv th2 m are generated wheremis a unique message.definition .givenex em t h econcurrency context cc ofex denoted byccx specifies how other events inemcan interleave withe.
it is defined by lockset ofex thehappens before relations betweenexand other events inem and the lock release history ofth x prior toex.
formally ccxis defined as a tuple lsx hbx lrx .lsxis the lockset ofexthat contains the locks heldbyth x while executingex .lsx l o ej acq th j l e ek rel th k l e j k x th x th j th k .hbxdenotes the happens before relations ofex.thesnd rcv events together with the total order of events ofthe same thread defines that is the smallest relationsatisfying the following conditions .
ifeiandejare events from the same thread andeicomesbeforeejin the trace thenei ej.
ifeiis the sending snd andejis the receiving rcv of the messagem respectively ei ej.
is transitively closed.lrxdenotes the lock release history ofexcontainingthe rel events executed byth x prior the execution ofex.lrx ek rel th k l e k x th x th k .cc encoding.we adopt the following encoding in orderto compare ccs across executions.
the inter thread relationis often computed using avector clock whose values arenot comparable across executions.
thus hbxis encoded asthe ordered sequence of snd rcv events generated byth x from its creation at the time when the eventexis generatedin the trace .
snd rcv events are presented as a couple o type whereo ois themessage objectandtype notify notifyall wait start join e.g.
o1.notify is encoded by o1 notify .
a lock inlsxis encoded as ao ofor lockobjects or a static reference for static locks e.g.
a.class .
forencodinglrxwe leverage that events triggered by the samethread are totally ordered.
each lock inlsxis tagged by aboolean value whose value istrueif it exists a rel eventbetweenexand the previous mem event performedth x andfalseotherwise.lrxis obtained by combining thelrxofall events generated byth x priorex.
section iii b presentsthe heap abstractions for comparing object s semantics.iii.
phasei change impactanalysis cia a key regression testing s step is to determine the effectsof source code modifications using softwarechange impactanalysis cia .
since there are few studies on the regres sion testing of concurrent programs most cias are obliviousto the concurrency semantics .
the only exceptions arepresented in capp and simrt they analyze thesource code reporting statements that arepotentially impactedby code changes.
they are inadequate for two reasons.
limitations of static cias.the impact sets derived bystatic cias are not sufficiently precise for regression testing due to the inclusion of many infeasible behaviors arising frominaccurate pointer aliasing analysis .
it was reportedthat of the events in the impact sets derived by staticcias can be spurious .
limitations of dependency based cias .existingtechniques first identify the changes that affectthe ccs of program entities e.g.
statements denoted bycc change and then identify the entities affected by thosechanges.
this approach is not practical because it requiresto enumerate a priori all possible cc changes that could bemanifested in a program.
as a result existing techniques cannot guarantee to detect all affected entitiesbecause they have not considered the changes of happens before relations e.g.
line figure and the changes thatindirectly affect lock operations e.g.
line figure .recontest s ciais a dynamic cia at memory accesslevel and it does not require to identify cc changes.
initially it treats each change as a cc change by assuming all accessesinp t are potentially impacted.
thus it does not miss anychanges that affect synchronization operations or happens before relations.
then it checks if the cc of each access inp t istrulyaffected by comparing it with the cc occurredwhen executing the original version of the program.
the checktakes three pieces of input information.
achange setthat contains the set of new statementsintroduced in the process of revisingptop .
let denote anequivalencerelation defined onp psuchthats sifs denotes the statementsthat has notbeen modified in the process of revisingptop .w eassume that relates each statement inp to at most onestatement inp.
given a relation change set is definedas s p s p s s p .
a regression test suitetof re testable multi threadedtests.
in subsequent discussion tdenotes a test case intandp t denotes the execution ofton programp.
for each testt t a pair of execution traceseande exhibited byp t and byp t respectively.the output of phase i is an impact set containing memevents ofe that could constitute new interleavings.
considerthe binary and symmetricexecution correspondencerelation denoted by one m em for aligning execution pointsacross executions.
without loss of generality we assume thatif a statementsis executed in bothemande m e y e mand ex emsuch thate y exands y s x s.definition .givene mandem theimpact setcontainsevents ine mthat satisfy either of the following conditions a new event that is observable ine mbut not inem an old event with a cc altered by code changes more formally impact set in ic e m where in e y e m s y change set ex em e y ex ic e y e m ex em e y ex ccx ccy 248obj.m1 obj.m2 ..... public class a intx y z object lock public void m0 intval1 intval2 y val1 x val2 z val1 val2 public void m1 public synchronized void m1 x get .. synchronized this m0 12345678910public synchronized void m2 booleancond true booleancond false if cond o.notify x public intm3 object lock this.lock new object this.lock lock synchronized this.lock if x returnx return0 1112131415161718192021222324252627282930313233e 1e 2e 3e e 5e e e 8e 9e 10e p t w x w y w x w z w x w x r x r x w x w y w x w y w x w x w x r x w x w y lock release rlfalse truefalse falselockset ls this this this this this happens before hb .notify .notify lockset ls lock lock line line ?
9999999icinconcurrency context cc e1e2e3e4 e5e6 e7 e8 a obj newa thread1thread2...............obj.m3 new b obj.m4 .....test case te p t outputpublic voidm4 public synchronized voidm4 synchronized this x synchronized this y fig.
.
phase i of recontest.
givenpandp achange set and a testt the output is the impact set in ic a. running examplewe illustrate our approach with a running example.
figure 1shows a java class.
inserted lines are denoted as whiledeleted lines as .
modified lines are characterized byinserted lines followed by deleted lines.
figure also showsthe execution traces obtained from executing the test caset.
w x denotes the memory access event of typewriteonvariable x. similarly r x for typeread.
the changes haveintroduced a regression bug inp t an atomicity violationis triggered if the interleaving e e e e is manifested.computinginis relatively simple.inrepresents two kindsof impacted mem events.
the first kind are events thatcorrespond to a new operation because they are triggered bya new statement.
for example e which is triggered by thechanged statement at line belongs toin.
the second kind areevents executed only inp .
for instance e an execution ofline is new because there is no event inecorresponding tothe execution of line .
after code changes the test evaluatesthe branch condition at line to a different result and hencetraverses a different path executing line .
note that differentfrom standard cia techniques the impact set excludesmem events that access different data values.
the triggeringof concurrency bugs depends on the exposure of erroneousinter thread memory dependencies which are irrelevant to thedata values of the shared memories involved .the challenge here is how to computeic the set of memevents with an affected cc.
to achieve that we need to alignexecution points in two traceseande .recontestestab lishes thate1 e 1because the statement at line is executedonly once ine.
thus e 1is aligned toe1.recontestinfersthate icbecause its lockset is empty while the lockset ofe1is not.
the eventse 2ande 3are not impacted because theirlocksets remain unaltered.
evente 5is impacted because thesnd event o.notify in line occurs only inp t .
hence e 5has a different happens before relation with other events inthe two traceseande .
similarly e 6is also impacted.the maintenance of lock release history is important.
anevent with an unchanged lockset and happens before relationcan induce new interleavings if it has an affectedlr.
forexample e 10is impacted even if its lockset is the same ase8 due to there is a new release lock event generated at line29.
after the lock has been released at line inp eventsof other threads could acquire the lock and interleave betweene 9ande .
such event interleaving is not possible inp.different from dependency based cias recontestdoesnot rely on the dependency between changes and other pro gram entities for computing the impact set it uses the change set only for identifying new events see def.
.
for thisreason deleted statements can be safely excluded from thechange set.
if deleting or adding statements affects subse quent memory accesses e.g.
deleting line affects the locksetofe it will be captured by our cia that scans all memevents ine identifying those new or with an altered cc.existing dependency based cia techniques spe cific to concurrency semantic are inadequate.
first they con sider only explicit changes of synchronization blocks as cc changes.
as a result they miss the impacted evente 7becausethe change contains no synchronized keyword.
second they misse 5ande 6due to ignoring changes that affectswait notify .
third they incorrectly includee e 3ande 9inthe impact set as they consider all statements inside a modifiedsynchronized block are impacted.b.
comparing ccs across executionswe have shown the simple case of cc comparison wherephase i identifies that two ccs are different when the havedifferent cardinality.
for example e 1has an affected ccbecausels 1is empty whilels1contains one lock.
in the casewhere both locksets to be compared have the same cardinalitysuch as the situation of evente 7ande6 recontestrequiresheap abstractions to compare cc s lock and message objectsacross executions.
aheap abstractionis a functionabsthatmap aconcrete objecto oto anabstract object .
theheap abstraction problem is challenging even for executionsgenerated by the same program version .
dynamicreferences of objects do not provide a useful abstractionbecause the memory addresses or unique ids of objects haveno relation across executions.
static