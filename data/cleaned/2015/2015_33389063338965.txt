a framework for writing trigger action todo comments in executable format pengyu nie rishabh rai junyi jessy li sarfraz khurshid raymond j. mooney and milos gligoric the university of texas at austin usa pynie rishabh.rai jessy austin.
khurshid ece.
mooney cs.
gligoric utexas.edu abstract natural language elements e.g.
todo comments are frequently used to communicate among developers and to describe tasks that need to be performed actions when specific conditions hold on artifacts related to the code repository triggers e.g.
from the apache struts project remove expectedjdk15 and if after switching to java .
.
as projects evolve development processes change and development teams reorganize these comments because of their informal nature frequently become irrelevant or forgotten.
we present the first framework dubbed trigit to specify triggeraction todo comments in executable format.
thus actions are executed automatically when triggers evaluate to true.
trigit specifications are written in the host language e.g.
java and are evaluated as part of the build process.
the triggers are specified as query statements over abstract syntax trees abstract representation of build configuration scripts issue tracking systems and system clock time.
the actions are either notifications to developers or code transformation steps.
we implemented trigit for the java programming language and migrated existing trigger action comments from several popular open source projects.
evaluation of trigit via a user study showed that users find trigit easy to learn and use.
trigit has the potential to enforce more discipline in writing and maintaining comments in large code repositories.
ccs concepts software and its engineering software maintenance tools domain specific languages software evolution .
keywords todo comments trigger action domain specific languages acm reference format pengyu nie rishabh rai junyi jessy li sarfraz khurshid raymond j. mooney and milos gligoric.
.
a framework for writing trigger action todo comments in executable format.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
introduction natural language elements such as todo comments are frequently used to communicate among developers .
some of these comments document that a developer should perform an action if a trigger evaluates to true e.g.
from the apache wave project remove this when htmlviewimpl implements getattributes action trigger we consider those comments where the trigger is a query over artifacts related to the code repositories and actions are either notifications to developers or code modifications.
we call these comments trigger action comments .
although trigger action comments are ubiquitous they are like other types of comments written in natural language.
thus as projects evolve development processes change and development teams reorganize these comments frequently become irrelevant or forgotten.
as an example consider the following comment from the apache gobblin project remove once we commit any other classes action trigger this comment followed by an empty class was included in december in the package info .java file to force the javadoc tool to generate documentation for an empty package.
three months later february classes were added to the package but the comment and the empty class in package info .java file were not removed.
more than three years later the comment and the empty class are still in the repository.
having pending actions i.e.
those actions that should have been done because the triggers evaluate to true and outdated comments may negatively impact program comprehension and maintenance .
additionally having comments written in an informal way presents a challenge for some software engineering tools such as refactorings as those tools may not know how to manipulate code snippets and identifiers embedded in comments .
developers in industry have recognized the problem with outdated todo comments and recently developed tools to help with maintenance of todo comments.
imdone extracts and maintains the list of pending todo comments at one place.
todo or die enables developers to write executable statements that will break the program execution if a todo comment is not addressed by a specific date.
the main developer of todo or diesays in the past the comment did nothing to remind myself or anyone else to actually delete the code this eventually resulted in an actual support incident long story .
to further motivate our work we also reached out to ten developers at large software companies including google dropbox groupon and palantir to ask if they write todo comments and esec fse august tallinn estonia pengyu nie rishabh rai junyi jessy li sarfraz khurshid raymond j. mooney and milos gligoric trigger action comments.
based on eight replies seven developers said that they have todo comments and trigger action comments.
these developers also highlighted the importance of improving the maintenance of todo comments e.g.
i m very tired of halfcomplete migrations and stale todos and we have a lot of todos at that get forgotten until something breaks .
with the goal to enforce more discipline in writing and maintaining comments we present the first framework dubbed trigit to specify trigger action comments in executable format the triggers are evaluated automatically at each build run and actions are taken based on users specifications.
trigit introduces a domain specific language dsl that can be used to write triggers and actions.
specifically triggers are written as query statements over asts build configuration scripts issue tracking systems and system clock time actions are either notifications to developers ortransformation steps over asts .
to provide a natural access to the ast elements and improve maintenance the trigit dsl is embedded in the host language.
however the semantics of the language enables the executable trigger action comments to be evaluated as part of the static program analysis phase prior to program execution .
we implemented the trigit technique in a tool for java we use the same name for both the technique and the tool.
trigit analyzes compiled code and modifies either compiled code source code or neither depending on user defined actions.
trigit allows users to force execution of actions for example during testing or during debugging of trigit specifications without modifying sources.
if a user chooses to modify source code with an action she would be provided with a patch once the action is taken.
trigit should be integrated in the build process after the compilation step.
ideally we envision trigit being used as a bot that sends a code review with changes whenever a trigger evaluates to true.
we evaluated trigit via a user study with participants which showed that users find trigit easy to learn and use most users correctly encoded trigger action comments in the trigit dsl with less than ten minutes of training.
additionally we evaluated trigit by manually migrating existing trigger action comments to the trigit dsl all the comments are from ten popular open source projects available on github.
in our experiments we also report the complexity of trigit statements measured in terms of the number of tokens in the specifications as well as the overhead introduced by the tool in the build process.
trigit does notintroduce any overhead at runtime.
our results show that trigit introduces negligible overhead in the build process and triggers and actions are short to write on average .
tokens .
the main contributions of this paper include idea we introduce an idea to encode trigger action comments currently written in natural language as executable statements in the host language.
having executable trigger action comments enables their maintenance e.g.
refactoring testing and automatic execution of the triggers and actions when artifacts related to the code repository change.
tool we implemented our idea in a tool dubbed trigit for java.
we also developed a maven plugin to simplify the integration of trigit with an existing build system.
user study and case studies we evaluated trigit via a user study with participants including developers working for abstractstreaminghasher.java protected abstractstreaminghasher int chunksize int buffersize todo kevinb check more preconditions as buffersize chunksize if this is ever public if trigitispublic checkargument buffersize chunksize checkargument buffersize chunksize ... trigtitmethod boolean trigitispublic return trigit.getmethod init int.class int.class .ispublic figure an example from the google guava project and trigit encoding to illustrate a local action.
freemarkerresultmockedtest.java void testdynamicattributessupport throws exception ... todo remove expectedjdk15 and if after switching to java .
if trigit.getjavaversion .ge trigit.java6 string expectedjdk16 input type text ... assertequals expectedjdk16 result else string expectedjdk15 input type text ... string expectedjdk16 input type text ... if result.contains foo bar ... assertequals expectedjdk15 result else assertequals expectedjdk16 result ... figure an example from the apache struts project and trigit encoding to illustrate a build configuration trigger.
mapper.java todo make this protected once mapper and fieldmapper are merged together public final string simplename return simplename trigitmethod void checkmerge if !trigit.hasclass mapper !trigit.hasclass fieldmapper trigit.getmethod simplename .setprotected figure an example from the elastic elasticsearch project and trigit encoding to illustrate a global action.
large software companies.
additionally we report our experience in manual migration of existing comments.
dataset a byproduct of our work is the first dataset of triggeraction comments and their executable counterparts.
additionally we manually added various labels on the comments that can be useful in future research projects.
our tool and the dataset are available at cozy.ece.utexas.edu trigit.
illustrative examples this section presents several existing trigger action comments from large open source projects and the encoding of these comments in thetrigit dsl andtrigit s workflow.
we chose the comments such that we can illustrate various aspects of the trigit approach.
figure shows a code snippet from the google guava project .
we show the encoding of the executable triggeraction comment within boxes.
this comment was added in commit c92e1c7 and is still present as of bf9e8fa .
in this case a developer wants to add more precondition checks if the method or constructor becomes public .
the trigger in trigit is encoded as a separate method that returns a boolean value and each trigit method needs to have the trigitmethod annotation.
trigitispublic finds the constructor and checks its modifiers.
386a framework for writing trigger action todo comments in executable format esec fse august tallinn estonia table examples of query expressions in the trigit dsl .
type query expression natural language description ast trigit .getclasses .findany c .ispresent checks if there is a class with name c build trigit .getjavaversion .ge trigit .java8 checks if the java version is greater or equal than java issue trigit .isclosed checks if the issue specified with url is closed time trigit .after checks if the system time is after the invocation of trigitispublic is aguard for an extra precondition check.
it is important to observe that in this case the action transformation step is local i.e.
we simply execute extra statements within the method.
as this comment is not specific enough i.e.
we do not know all the preconditions that developers would like to check we could include an extra action to print a warning to developers when the trigger evaluates to true.
recall that triggers are evaluated during the build process prior to the execution this means that methods annotated with trigitmethod ifstatements that guard actions and statements of either then or else branch are removed by trigit prior to the program execution.
as stated earlier ideally trigit is integrated in a bot that sends code reviews or pull requests once the trigger evaluates to true.
figure shows a code snippet from the apache struts project which is a web framework for creating java web applications.
the specified action was performed at commit a5812bf five months after the trigger evaluated to true.
unlike the previous example this one illustrates a query statement over the build configuration script.
specifically the trigger evaluates to true if the current java version is greater than .
.
regarding the action we guard the modified code in the then branch and the original code is in the else branch.
finally figure shows a code snippet from the elastic elasticsearch project which is a distributed search engine.
we use this example to illustrate the global code transformation action.
in this example developers want to change the access modifier of a method simplename from public toprotected if two classes mapper andfieldmapper are merged.
although there is no unique way to encode a trigger that checks if two classes are merged the check can be approximated in several ways.
our approach is to check that one of the classes is no longer available.
a better option might be to check that one class is removed while the other one is still present.
by knowing the relation between the classes fieldmapper extends mapper and their usage we believe that the original developers could provide a more precise trigger.
the action specifies that the modifier of the method should be changed to protected .
unlike prior examples the action is global i.e.
impacts code elements outside a method body and it is expressed as a transformation step over the class ast.
3trigit technique this section describes the trigit dsl presents the workflow and the integration with existing build processes and briefly describes the current implementation.
.
language specifications in the trigit dsl are written in a subset of java with slightly modified semantics.
the trigit dsl consists of three syntactic components query expression for triggers action statement for actions and trigit method .
a query expression is syntacticallypackage org.trigit.project public class classmodel extends modelbase public string getname ... public modifiersmodel getmodifiers ... public list fieldmodel getfields ... public list methodmodel getmethods ... public boolean ispublic ... public boolean isprotected ... public boolean isprivate ... public boolean ispackageprivate ... ... figure part of trigit s classmodel api.
equivalent to a java expression that evaluates to boolean .
an action statement is syntactically equivalent to a java statement.
a trigit method is syntactically equivalent to a java method declaration with either boolean or void return value and without arguments .
we first describe each component and then describe how they are combined into trigit specifications.
query expression .
each query expression is a logical expression such that each operand queries the state of the artifacts related to the code repository via the trigit application programming interface api .
the triggers supported in our design include queries over ast elements build configuration scripts issue tracking systems and system clock time.
our decision to support these trigger types is based on the most commonly seen types of triggeraction comments that developers write in open source projects.
table lists the types of triggers as well as one example for each type.
each trigger has to start with an invocation of the trigit api.
for the query over ast a user works with a stream of model classes.
once a developer obtains a stream the developer can use any standard java stream operation e.g.
map filter count etc.
to create a query.
in case the stream support is not available in the java version used by the project the developers may opt for equivalent operations available in the trigit api.
the result of each query has to be a boolean value.
clearly as arguments to stream operations the developer can use model classes fields methods etc.
to access ast elements and their properties including class name modifier return type and others.
we only show signatures of a few methods from classmodel in figure which is a model of a class in the project.
trigit model classes offer a rich api and many syntactic sugars are available e.g.
get a model of a method by name the complete trigit api is available on the accompanying web page .
additionally when constructing queries a developer can use constant values as well as field accesses and method invocations however the semantics for the latter two differ from the one specified by the java language specification as we discuss below.
for the last three query types trigit provides an api to get the build configuration an api to check the status of an issue on an issue tracking system as well as an api to check if the current system clock time is past a specific date.
387esec fse august tallinn estonia pengyu nie rishabh rai junyi jessy li sarfraz khurshid raymond j. mooney and milos gligoric action statement .
similarly to a query expression each action statement has to start with an invocation of the trigit api to obtain a stream of model classes.
we currently provide only an api for modifying asts of classes but not other artifacts related to the code repository.
unlike the instances of model classes that are available in the query expressions the instances of model classes available in actions can be both queried and modified i.e.
extra api methods are available to specify modifications this is similar to api s available in ides to perform ast rewrites .
the expressions used as arguments to stream operations may include constants field accesses and method invocations.
there are no limits on the number of action statements that can be guarded by a single query expression.
for example if we want to modify an access modifier of a field f in the current class we can write in a short form the following action statement trigit.getfield f .setprivate trigit method .
each trigit method should be a java method that has a return type boolean or void has no arguments and is annotated with trigitmethod.
trigit methods that return a boolean value need to have only a single statement return query expression that implements the trigger.
trigit methods that do not return any value i.e.
void can have multiple statements but the first statement has to be an if statement such that the conditional expression is a query expression other statements which are always a part of the then block are action statements.
the following are templates for trigit methods with a boolean return value and with a void return type respectively.
trigitmethod boolean modifiers name return query expression trigitmethod void modifiers name if query expression action statement trigit specifications .
a complete trigit specification consists of both a trigger part and an action part.
we differentiate two types of actions global and local.
we define a global action as a sequence of statements that specify modifications to the program structure .
these actions modify out of method code elements including method signatures class declarations etc.
figure from section illustrates a global action that updates a modifier of a method.
a trigit specification with a global action is written as a trigit method with a void return type where the query expression is the trigger part and the action statements are the action part.
we define a local action as a sequence of statements that should or should not be executed depending on a trigger that guards those statements.
we say that these actions modify in method code elements i.e.
a sequence of statements to be executed .
figures and from section illustrate local actions.
a local action is written as an if statement whose condition is a query expression or a trigit method with a boolean return value and whose then branch is the code that should be executed if the trigger evaluates to true while the else branch is the code that should not be executed in that case.
the following is the general format of a trigit specification with a local action if query expression trigit method name statement else statement if expr ... stmt this.f classname.f f this.m classname.m m this.m arg1 ... classname.m arg1 ... m arg1.type ... figure rewrite rules to prepare trigit methods for the evaluation by the framework.
when writing a local action statement a developer may opt to use an api call available only in a new version of a library e.g.
java .util .list .of ... from java .
however writing such code could result in compilation errors if project uses java .
one approach that the developer can take is to write a method invocation using the reflection mechanism .
semantics .
although evaluation of the trigit specifications closely follows java semantics there are two main differences.
first all method invocations and field accesses that do not belong to the trigit api are substituted with the names of methods and fields i.e.
those methods and fields are never invoked or accessed.
in case of a method invocation all the arguments are replaced with their corresponding types.
the trigit api uses the argument types to differentiate between overloaded methods.
for example the code snippet shown above that changes a filed access to private would be modified prior to the evaluation to trigit.getfield f .setprivate we made this decision to avoid using strings to refer to a field method or class name unless that is absolutely necessary.
our decision will help to keep comments up to date with code e.g.
during refactoring to avoid what researchers call fragile comments .
second prior to evaluating a trigit specification the class that contains the method is rewritten to remove anything other than the query expressions action statements in trigit methods and if statements.
this is done to enable evaluation of the executable trigger action comments without worrying about the environment that is required to execute any piece of code from the project itself.
for example even loading a class may require substantial setup and execution cost if a static block is present.
to prepare a class for evaluation with trigit we define a set of rewrite rules shown in figure .
each rule has the following format before after where before andafter are ast elements in java or an empty string denoted by condition defines when a rule is applicable.
the first two rules remove any statement from a class that is irrelevant for trigit specifications.
the last three rules rewrite each field access to the name of the accessed field and method invocation to the name of invoked method and types of its arguments if any .
we recursively apply the rewrite rules on the method until no more rewrite rules can be applied and then the obtained code can be evaluated by java.
rationale .
we would like to emphasize that our decision to enable the evaluation of trigger action comments independently of other code was to keep the separation between production code and comments to enable the evaluation of comments regardless of the requirements needed for running the project s code and to avoid the 388a framework for writing trigger action todo comments in executable format esec fse august tallinn estoniajava files compilerclass files test execute trigit specsrewrite2 evaluate3 apply build configuration issue tracker system timewarning messages patch to java filestrigit figure trigit s workflow.
query expression evaluate query expression m evaluate m if true stmt1 else stmt2 stmt1 if false stmt1 else stmt2 stmt2 modifiers m ... figure rewrite rules for applying the local actions and removing the trigit specifications.
performance overhead of evaluating comments at runtime.
as our decisions are inspired by examples found in open source projects and feedback from several developers working in industry some of these decisions might need to be revisited in the future to support the encoding of comments as executable statements for a broader class of comments.
.
workflow figure shows trigit s workflow.
trigit interposes between the compiler and test execution.
the first step to use trigit is to encode existing trigger action comments as executable trigit specifications.
once a project is compiled the query expressions action statements and trigit methods are part of the resulting classfiles.
having executable trigger action comments checked by the compiler is one advantage over informally written comments.
trigit accepts the compiled classfiles and works in four steps.
first step in figure trigit processes all the classfiles from the project to build the intermediate ast representation to be used by the query expressions and action statements trigit also retrieves build configurations issue status from an issue tracker and system time lazily upon request by the query expressions.
next step trigit modifies classfiles based on the rewrite rules in figure to prepare the trigit specifications for evaluation.
the modified classfiles are never stored on disk unless a developer specifies the debug option but they are only available in memory and they are dynamically loaded .
then step trigit evaluates each query expression and boolean trigit method in a non deterministic order.
we discuss potential dependencies between trigit methods in section .
if the project being built requires a java version prior to java which is currently required for trigit execution trigit methods are evaluated by spawning an external process.
finally step trigit takes actions and applies changes depending on the evaluation results.
if a query expression or a boolean trigit method evaluates to true there are three possible outcomes.
first trigit can notify a developer with the list of triggers that hold without executing any action.
in addition to printing which triggers hold trigit also includes a short explanation that justifiesthe outcome of the trigger e.g.
java version .
greater than .
at pom.xml .
second trigit can rewrite the classfiles on disk to apply the actions both global and local guarded by those triggers evaluated to true.
for global actions the action statements are executed to modify the asts.
then trigit applies a set of rewrite rules in figure to apply the local actions and to clean the trigit specifications from the classfiles we omit the condition in a rewrite rule if the rule always applies.
the first two rules inline the evaluation results of query expressions and boolean trigit methods.
the next two rules only keep the correct branches for local actions depending on the evaluation results.
the last rule cleans all trigit methods from the classfiles.
the resulting classfiles for test or execution contain no trigit specifications thus trigit introduces no runtime overhead.
finally trigit can be configured to create a patch for the source code which developers may inspect modify and apply.
the configuration provided by the user determines what option is taken.
the configuration options are not mutually exclusive.
as mentioned earlier ideally trigit will be used as a bot running on a continuous integration server that sends code review with changes when a trigger holds we do notexpect developers to run trigit in the default build profile on code that is automatically deployed.
.
implementation we implemented trigit as a standalone java library that can be used from the command line or integrated into a build system.
trigit uses the asm java bytecode manipulation and analysis framework to rewrite executable code check correctness of encoding and transform executable code.
more precisely trigit uses the visitor mechanism to build the model classes of the entire project which are queried with the stream operations.
trigit executes the action statements one by one which transform the underlying bytecode using asm.
additionally we implemented a maven plugin to simplify the integration of trigit into the build process as maven is still one of the most popular build systems for java.
we integrated the plugin in the maven lifecycle after the compilation phase.
trigit provides various options including debug to show execution steps and store stripped files used to evaluate trigit methods assume true to force the evaluation of triggers to true and no action to tell that no action should be taken.
assumetrue can be used to check the effect of executing the actions and no action can be used to check correctness of encoding and report what actions would be taken in the current build run.
we currently support basic checks of correctness of executable trigger action comments.
specifically trigit checks if a query expression and action statements refer to code elements that should exist.
as an example consider the following trigger trigit.getclass c .getfield f .isprivate if class cor field fdoes not exist we report the incorrect encoding.
these checks are important to detect modifications in code likely due to software evolution which invalidate executable comments and notify developers.
finally trigit can output a patch for the source code if the trigger evaluates to true and actions are executed.
our current approach for creating a patch utilizes the debug info to get the source 389esec fse august tallinn estonia pengyu nie rishabh rai junyi jessy li sarfraz khurshid raymond j. mooney and milos gligoric code location of the patch and aggregates the patches generated from each executed global action and local action.
the patch also removes any trigit specification if its trigger evaluates to true thus avoiding technical debt.
we expect that a developer would inspect a patch and revise their code manually.
user study this section describes our user study to evaluate whether developers can quickly implement correct triggers and actions using trigit .
.
study design initially we asked each participant to read a tutorial for up to ten minutes.
the tutorial provided a brief explanation of the trigit dsl with three examples.
next we asked each participant to do three tasks the tasks were chosen randomly from a set of executable trigger action comments from open source projects we encoded in the trigit dsl and are independent from the examples in the tutorial.
each task asked the participant to migrate an existing trigger action comment to the trigit dsl .
we did not ask the users to run trigit as that was outside the scope of our study recall that our goal was to evaluate encoding of comments.
we provided only a brief description of each task with the goal to clarify triggers and actions.
this was necessary because the participant unfamiliar with the project may not be able to infer the unspecified part of triggers and actions and our goal was not to evaluate the understanding of code and comments but rather to evaluate the complexity of encoding the comments.
due to space limit the detailed content of the tutorial and the descriptions are available on the accompanying web page .
we sent the tasks in the same order to each participant and we used the first task as a warm up task without telling this to the participants the warm up task was not considered in the evaluation.
we provided a bash script to install tools unpack projects that contain todo comments and start the tasks.
our script sets up intellij to provide a uniform environment with code completion.
we asked participants to track time spent on each task to rate the level of confidence of their solutions for each task separately and to send us their solutions.
then we asked them to rate the easiness of learning the trigit dsl on a scale of with being the easiest .
finally we asked them to tell us about their programming experience experience with java and experience with intellij.
we wrote scripts to process the responses and we manually checked the correctness of each solution.
participants .
our study was conducted in two batches.
in the first batch we sent the study to people including seven professionals six working for large software companies and one researcher and eight students three undergraduate and five phd .
we received valid responses in total.
one phd student participant did not follow the instructions.
two participants one phd student and one professional had issues with running our bash scripts on os x specifically because of incompatible versions of sed find and java development kit between linux and os x. in the second batch we sent the study to eight people including two professionals one working for large software company and one researcher and six students one undergraduate and five phd .
we received valid responses from all participants.table study results grouped by tasks and roles time spent unit minute participants confidence on a scale of and correctness tri.
act.
and syn.
are numbers of participants who got correct triggers actions and syntax.
grouped bytime confidence correctness avg.
med.
avg.
med.
tri.
act.
syn.
taska .
.
.
.
b .
.
.
.
c .
.
.
.
d .
.
.
.
roleprof.
.
.
.
.
stu.
.
.
.
.
all .
.
.
.
among all valid responses the participants have on average .
years median .
years of programming experience and have moderate java skills average self reported score .
on a scale of participants have used intellij before the study.
tasks .
we randomly chose tasks from the corpus of trigger action comments mined from open source projects that we previously encoded with the trigit dsl .
the tasks excluding the warm up task were taska from google guava check more preconditions as buffersize chunksize if this is ever public .
see figure .
taskb from apache struts this is to keep backward compatibility remove once when tooltipconfig is dropped .
see figure 8a.
taskc from apache ignite this comparison should be switched back to assertequals when .apache .org jira browse ignite is fixed .
see figure 8b.
taskd from jenkinsci jenkins remove once minimum supported remoting version is .
or above .
see figure 8c.
in the first batch we used taska and taskb in the second batch we used taskc and taskd.
we confirmed that none of our participants contributed to the open source projects used in the study.
.
results table summarizes the results grouped by tasks and roles professionals prof. students stu.
.
for each group we show the average and median time in minutes to complete the task time the average and median of participants confidence on scale confidence and the number of participants that wrote the correct solution correctness .
we access the correctness of different parts of the solution trigger tri.
action act.
and syntax syn.
that we defined as correct locations for triggers and actions.
we can see that on average the participants took .
minutes to migrate a trigger action comment in an unfamiliar project professionals took less time than students average time .
minutes vs. .
minutes .
most of the solutions were correct.
there was one mistake on the trigger part and one mistake on the action part both because of misunderstanding of the executable trigger action comments.
there were three mistakes on the syntax part of taska because the users put the local action inside the trigit method we show a representative mistake in figure 8d.
compared to the correct solution in figure the local action 390a framework for writing trigger action todo comments in executable format esec fse august tallinn estonia uibean.java public void evaluateparams ... todo this is to keep backward compatibility remove once when tooltipconfig is dropped if trigit.getcurrentclass .hasfield tooltipconfig string jstooltipenabled string getparameters .get jstooltipenabled if jstooltipenabled !
null this .javascripttooltip jstooltipenabled ... a taskb from the apache struts project.
ignitecachelockpartitiononaffinityruntest.java private static int getpersonscountsinglecache final igniteex ignite ignitelogger log final int orgid throws exception ... todo this comparison should be switched back to assertequals when is fixed.
if trigit.isclosed browse ignite assertequals partcnt sqlcnt assertequals partcnt sqlfieldcnt else if partcnt !
sqlfieldcnt assertfalse ... primarypartition ignite orgid if partcnt !
sqlcnt assertfalse ... primarypartition ignite orgid ... b taskc from the apache ignite project.
mastertoslavecallable.java todo remove once minimum supported remoting version is .
or above public channel getchannelorfail throws channelclosedexception ... trigitmethod void trigitminremotingversion throws exception if version trigit.getbuildconfigurations .getproperty remoting.minimum.supported.version .greaterequalthan .
trigit.getmethod getchannelorfail .remove c taskd from the jenkinsci jenkins project.
abstractstreaminghasher.java protected abstractstreaminghasher int chunksize int buffersize todo kevinb check more preconditions as buffersize chunksize if this is ever public checkargument buffersize chunksize ... syntax incorrect trigtitmethod void trigitpreconditioncheck if trigit.getmethod init int.class int.class .ispublic checkargument buffersize chunksize d an example of an incorrect encoding for taska.
figure tasks used in the user study taska is already shown in figure and one example of an incorrect solution to taska.
checkargument buffersize chunksize was incorrectly put in the trigit method.
after the study was done we implemented checks in trigit to prevent such mistakes.
the participants claimed to be confident with their solutions average score .
professionals are more confident than students average score .
vs. .
.
based on the results we can say that participants obtained correct solutions with very little training.
we consider these results even more encouraging because participants worked with unfamiliar projects.
we believe that participants would perform better in a familiar environment and avoid mistakes due to the misunderstanding of comments.
finally most participants consider trigit easy to learn average score .
.
case studies in this section we describe our process of mining trigger action comments in open source projects and encoding them as executable trigger action comments in trigit .
as additional evaluation we measure the overhead of trigit on the build process as well as the number of tokens needed to encode executable trigger action comments compared to the existing comments.
.
projects and comments in the first step we selected ten popular open source projects to find trigger action comments.
table shows the list of projects first column and revisions used in our experiments second column .
we selected projects that differ in size number of todo comments and application domain.
more importantly we selected projects based on our prior experience with codebases.
the last requirement was necessary to make the experiments feasible we wanted projects that we can build to ensure that we can run our tool after migratingtable projects used in our case studies number of comments with todo marker todo number of triggeraction comments tac and number of other types of comments other .
project revision todo tac other apache cayenne 9c07e18 apache ignite 299f557 apache struts e2c2ea8 elastic elasticsearch 850e9d7 google closure compiler 3d4f525 google guava ea66419 google j2objc e85caea java native access jna c333527 jenkinsci jenkins 043abd8 jenkinsci gmaven 80d5f66 avg.
n a .
.
.
n a the comments.
in the second step we extracted all todo comments from the selected projects.
we searched for todo which is the most common marker for todo comments .
column in table shows the number of todo comments for each project.
in the third step we manually inspected all todo comments and labeled each comment with yes if the comment is a triggeraction comment or no if the comment is not a trigger action comment .
columns and in table show for each project the number of labeled trigger action comments and the number of other types of comments.
the inspection was done by three authors of this paper together and in addition to the comment itself we inspected the context of the comment i.e.
surrounding source code and potentially other files in the project.
we discussed each comment until we reached unanimous agreement.
391esec fse august tallinn estonia pengyu nie rishabh rai junyi jessy li sarfraz khurshid raymond j. mooney and milos gligoric highmedium low triggerhighmedium lowaction in the fourth step we inspected trigger action comments that we annotated with yes in the previous step and assigned values to two more labels trigger specificity and action specificity.
specificity can take one of the following values high which means that we can understand the trigger action and migration should be feasible medium which means that we mostly understand the trigger action and migration could potentially be done and low which means that we cannot understand the trigger action or migration is not feasible.
the heatmap above shows the distribution of labels for trigger action comments.
we illustrate the assignment of labels using several examples this is to keep backward compatibility remove once when tooltipconfig is dropped from apache struts trigger specificity high action specificity high .
when fieldaccess detection is supported mark that class as reachable there and remove the containspublicfield flag here from google j2objc trigger specificity medium action specificity medium .
enable testing for unused fields when elementutil glitch is fixed from google j2objc trigger specificity low action specificity medium .
embedded derby mode... change to client server once we figure it out from apache cayenne trigger specificity low action specificity low .
finally we manually encoded trigger action comments as executable trigger action comments in trigit and used them as subjects in the following evaluations.
we randomly selected these trigger action comments from only those comments where trigger specificity high .
.
build overhead we compute the build overhead to illustrate the cost of trigit analysis and code transformation.
recall that trigit runs after compilation and prior to program test execution.
to compute the time overhead introduced in the build process we measured the build time e.g.
mvn test compile for maven projects for each project with and without trigit .trigit does not introduce any runtime overhead so we do not run tests during the build.
moreover transformations performed by action statements may impact tests i.e.
new or different code may be executed thus including test execution time might lead to misleading results.
if the build is run with trigit we include all the phases i.e.
building the model of the project evaluating the trigger and executing the action see section .
we run each configuration five times and compute the average time.
we ran experiments on an intel i7 6700u cpu .40ghz with 16gb of ram running ubuntu .
lts.
we find that the overhead varies between .
and .
the average overhead is .
and the median is .
.
we consider this to be acceptable overhead especially considering the sizes of the analyzed projects.
trigitmethod void checkmerge if !trigit .hasclass mapper !trigit .hasclass fieldmapper trigit .getmethod simplename .setprotected figure example of token counting we show number of tokens in the boilerplate code first line trigger second line and action third line .
.
complexity of the trigit dsl weestimate the complexity of writing executable trigger action comments with the number of tokens needed to encode triggers and actions.
concretely we count three parts for each executable triggeraction comment trigger which is the number of tokens to encode the trigger action which is the number of tokens to encode the action and boilerplate code which is the number of tokens to satisfy the trigit dsl syntax e.g.
method signature.
figure illustrates using an earlier example the way we count the tokens.
we compare the complexity of executable trigger action comments with their informal counterparts written in natural language.
we found that the average number of tokens in the original comments was .
median .
min max while the total number of tokens in the encoded comments trigger action boilerplate code was on average .
median .
min max .
additionally the number of tokens in the triggers was on average .
median .
min max the number of tokens in the actions was on average .
median .
min max the average number of tokens in the boilerplate code was .
median .
min max .
the results show that even if we count all the tokens in executable trigger action comments the increase in the number of tokens compared to the informal text is only .
.
if we take into account only the tokens in triggers and actions executable triggeraction comments are in some cases even shorter than the original comments.
additional benefits of the executable trigger action comments is that developers can utilize the features of ides such as auto completion and generation of method signatures which do not work for comments written in natural language.
anecdotal experience we briefly report on our experience on using trigit and interacting with open source developers to understand their comments.
to encode each comment we read the comment and encoded what we believe were valid triggers and actions.
in several cases we observed that trigit always executes the actions and we thought that there was a bug in our tool.
however by looking at those triggers manually we found that the triggers are satisfied but the actions have not been executed.
table shows the time when the comment was included in the code repository time when the trigger is satisfied and when the action is executed.
we only show comments where the trigger is satisfied.
note that freemarker resultmockedtest is a special case because the developer forgot to remove the todo comment even after the action was taken.
we found this todo comment interesting and used an older revision of the project in our evaluation.
we reported to the corresponding 392a framework for writing trigger action todo comments in executable format esec fse august tallinn estonia table timeline of the comments added column trigger satisfied column action executed column .
project classfirst added trigger satisfied action executed revision date revision date revision date apache cayenne deduplicationvisitor 39b70d1 b332610 after we reported apache struts freemarkerresultmockedtest 0f2c049 25cdfd6 a5812bf google closure compiler dependencyinfo fc465c1 62ba0ab n a n a google guava abstractfuture 0b76074 86fb700 n a n a google guava classpath 896c51a 9ebd95a n a n a google j2objc generatedexecutableelement 6eac122 bc5dbad n a n a developers five comments that have satisfied triggers but not executed actions.
we got responses from all developers just a few hours after we submitted the reports.
a developer of apache cayenne immediately performed the action and sent a note thank you for the reminder!
a developer of google j2objc confirmed that the trigger is satisfied and said it s time to cleanup the todos any volunteers?
.
developers of other comments explained that the comments were not specific enough unfortunately java still causes some issues with some googleinternal infrastructure.
java is allowed in tests but not in the main part of the code yet .
the comment should say something like when jdk8 is available to all flavors of guava.
we currently maintain a backport that targets jdk7 and older versions of android and we try to keep the backport and mainline mostly in sync.
that s not to say that we couldn t do this but we d have to weigh the benefits against the cost of diverging the two.
some of the responses confirmed the impression that we had while reading todo comments knowing the details of the project is likely necessary to do valid migration of comments to trigit .
however this is not surprising considering that todo comments are written to communicate among developers of the project.
discussion other observations related to comments .
we encountered a large number of interesting cases while analyzing the comments.
we describe only one case here due to the limited space.
we observed several examples with a trigger that depend on a test case e.g.
delete this variable and corresponding if statement when jdk fixed java.text.numberformat.format s behavior with float .
we plan to explore how to encode triggers based on test execution results.
na ve alternatives .
writing tests or throwing exceptions can be used to partially encode trigger action comments e.g.
a test can fail or an exception can be thrown when java version is .
trigit overshadows these na ve approaches in three ways trigit can perform actions that modify code trigit provides an api for querying the codebase build scripts bug tracking systems and system clock time and unlike trigit specifications exceptions would remain in compiled code which could lead to unexpected behaviors once software is deployed.
future work .
we qualitatively evaluated trigit s benefit via discussion with developers in industry and the user study we envision a systematic cost benefit analysis once trigit is adopted in real world developing process.
the current implementation does not consider dependencies and conflicts between executabletrigger action comments although we have not observed any yet.
for example a trigger from one comment may become true when the action of another comment is executed.
to support the correct order of execution we will need to maintain dependencies between comments.
with recent advances of general purpose code synthesis from natural language it is worth exploring training a semantic parser to automatically map natural language comments to trigit specifications which will remove the burden from developers.
our initial work in this direction focused on identifying trigger action comments in a given repository .
threats to validity external .
we extracted only comments containing todo markers however developers use other markers including fixme xxx hack etc.
our decision was based on prior work that showed that todo is the most common marker .
the projects that we used in the evaluation may not be representative of all open source projects.
to mitigate this threat we used popular open source projects that are actively maintained.
trigit supports only projects written in the java programming language.
we chose java because it is one of the most popular languages and prior work on analyzing todo comments showed the need for automating comment maintenance see section .
however the idea behind trigit is broadly applicable.
we encountered challenges in recruiting a large number of experienced participants in our user study.
however we consider participants including eight professionals to be a sufficiently large group for our kind of study.
internal .
our scripts for mining repositories and trigit code may contain bugs.
we used scripts already utilized in prior work and we manually inspected the results of some of those scripts.
construct .
the focus of trigit is on triggers and actions related to the content of compiled code build files issue tracking systems and system clock.
many comments belong to these categories.
support for queries that check data available only in the source code e.g.
compile time annotations are left for future work.
time taken to perform the study was self reported by the participants.
although we were considering to capture the screen participants rejected this option.
as reported times are similar with the time it took us to write those comments we have no reason to believe that anybody reported incorrect numbers.
related work comment analysis and automation .
ying et al.
were among the first to identify the importance and frequency of todo comments.
they analyzed two groups of comments that are a subset 393esec fse august tallinn estonia pengyu nie rishabh rai junyi jessy li sarfraz khurshid raymond j. mooney and milos gligoric of trigger action comments communication self communication and future task once the library is available... .
empirical studies done by storey et al.
and haouari et al.
confirmed that todo comments are ubiquitous and may lead to maintenance issues.
sridhara developed a rule based system for identifying out ofdate todo comments.
nie et al.
proposed several techniques for comment and program analysis to support todo comments as software evolves.
pascarella and bacchelli performed manual classification of comments and showed that machine learning has potential to automate the classification.
innobuilt software developed imdone an online tool that extracts and tracks todo comments by creating and updating issues e.g.
on github or jira .
trigit is motivated by prior work on identifying and analyzing todo comments and our main goal is to simplify maintenance of comments and code.
prior work studied detecting and eliminating the inconsistency between code and comments.
for example fluri et al.
studied co evolution of code and comment tan et al.
developed icomment and tcomment to detect code comment inconsistencies ibrahim et al.
found that rare inconsistent updates lead to bugs in future revisions of software svensson developed a program for manual comment consistency checks ratol and robillard and zhou et al.
looked at the identifiers in api or comments that may become inconsistent as the result of a code refactoring e.g.
renaming .
todo or die is a tool for keeping todo comments up to date by specifying a date for each comment and breaking the execution upon outdated todo comments.
trigit is the first solution towards avoiding inconsistencies between code and trigger action comments by automatically maintaining code repository and executing actions when associated triggers hold.
trigit also removes the need for detecting identifiers in comments as the trigger action comments are encoded as executable java code which would be refactored together with other code.
work on self admitted technical debt satd identifies comments that document temporary code fixes.
unlike work on identifying satd trigit could be used to clean up the codebase when the trigger condition is satisfied.
work on generating comments from code generating code specifications from comments and both directions are other approaches to keep a repository consistent.
trigit provides a way to write executable comments that automatically and consistently update both code and comments as the codebase evolves.
code query languages .
jquery and codequest are source code querying tools the former uses a logic programming language while the latter uses datalog.
recently urma and mycroft proposed source code queries with graph databases.
while prior work mostly targeted program comprehension trigit targets encoding of trigger action comments with a language embedded in java.
another difference is that trigit supports querying various other artifacts e.g.
build configuration files.
ozdemir et al.
developed a tool built on their prior work codeaware for monitoring code repositories and notifying developers if some code metrics e.g.
complexity change trigit is for encoding executable comments querying code repositories and transforming the program.the reflection api can be used to query code but other types of queries supported in trigit cannot be written using this api.
program transformations .
actions available in trigit are closely related to behavior preserving transformations i.e.
refactorings .
most relevant work is that on scripting refactorings i.e.
providing simple building blocks that can be composed in sophisticated transformations.
one of the key differences is that trigit actions may not be behavior preserving e.g.
using new api calls or removing a statement.
if actions that we discover in the future would require complex code transformations offered by existing refactoring engines it would be worth integrating our actions with those engines.
trigit methods and their encoding follow similar patterns as the aop condition action patterns .
however in trigit the aspect code lives in the same place as the regular code and global actions can change the internal and external api.
ifttt if this then that recipe synthesis .
researchers have studied synthesizing ifttt recipes from natural language .
ifttt recipes are short scripts of trigger action pairs in daily life domains such as smart home personal well being and social networking shared by users on websites such as ifttt.com.
frequently a recipe is accompanied by a short natural language description.
in ifttt recipes triggers and actions are functions from apis and services e.g.
instagram .
in our work triggers and actions are drawn from unstructured todo comments during software development.
instead of translating from natural language to an already developed target programming language our goal is to develop the target programming language.
conclusion we presented the first approach dubbed trigit to encode triggeraction comments as executable statements.
a developer can use a java like language to encode triggers as query statements over artifacts related to the code repository and actions as code transformation steps.
trigit integrates into the build process and interposes between the program compilation and execution.
we migrated trigger action comments from several large open source projects.
evaluation of trigit via a user study showed that users find trigit easy to learn and use.
additionally we showed that trigit introduces negligible overhead in the build process and the number of tokens needed to encode the comments differs only slightly from the original comments written in natural language.
although trigit could be extended in several ways we believe that timely code updates enabled by trigit can already have positive impact on code comprehension and maintenance.