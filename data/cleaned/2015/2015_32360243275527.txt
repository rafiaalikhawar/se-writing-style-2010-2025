regression test selection for tizenrt ahmet celik university of texas at austin usa ahmetcelik utexas.eduyoung chul lee samsung south korea yc207.lee samsung.commilos gligoric university of texas at austin usa gligoric utexas.edu abstract regression testing running tests after code modifications is widely practiced in industry including at samsung.
regression test selection rts optimizes regression testing by skipping tests that are not affected by recent code changes.
recent work has developed robust rts tools which mostly target managed languages e.g.
java and c and thus are not applicable to large c projects e.g.
tizenrt a lightweight rtos based platform.
we present selfection an rts tool for projects written in c we discuss the key challenges to develop selfection and our design decisions.
selfection uses the objdump and readelf tools to statically build a dependency graph of functions from binaries and detect modified code elements.
we integrated selfection in tizenrt and evaluated its benefits if tests are run in an emulator and on a supported hardware platform artik .
we used the latest revisions of tizenrt available on github.
we measured the benefits of selfection as the reduction in the number of tests and reduction in test execution time over running all tests at each revision i.e.
retestall .
our results show that selfection can reduce on average the number of tests to .
and end to end execution time to .
when tests are executed in the emulator and to .
and .
when tests are executed on the actual hardware.
our results also show that the time taken to maintain the dependency graph and detect modified functions is negligible.
ccs concepts software and its engineering software evolution keywords regression test selection tizenrt static dependency analysis acm reference format ahmet celik young chul lee and milos gligoric.
.
regression test selection for tizenrt.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction regression testing running available tests to check correctness of recent code changes is widely practiced in industry including at samsung.
despite the widespread use regression testing is costly due to a large number of tests and large number of changes .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
high cost of regression testing impacts developers productivity and developers may miss bugs if they manually select to run only a subset of available tests .
regression test selection rts techniques optimize regression testing by automatically detecting and skipping to rerun a subset of tests whose behavior is not affected by recent code changes .
traditionally rts techniques track dependencies for each test on code elements e.g.
statements basic blocks functions or files and skip from the run in a new project revision those tests that do not depend on any of the modified code elements.
rts has been studied for over three decades and researchers and practitioners have developed rts techniques for various programming languages including c c java c etc.
however there are only a few rts tools available that implement these techniques.
most of the available tools target managed code i.e.
languages that compile to java bytecode or .net clr .
our work is mainly motivated by the lack of an rts tool for the c programming language and numerous questions about potential benefits that such tools could provide.
we present the design implementation and evaluation of selfection a novel rts tool for projects written in c which are compiled to arm elf.
selfection uses static analysis to collect dependencies for each test by utilizing the call graph i.e.
each test depends on functions that might be transitively invoked from the test.
in a new project revision selfection detects modified functions by comparing the current checksum with the old checksum for each function and propagates the information about non modified functions to identify tests to skip.
selfection performs the analysis on an executable image by extending objdump and readelf tools.
to evaluate the benefits of selfection we integrated the tool in tizenrt a lightweight runtime operating system developed by samsung.
we used the latest revisions and replayed the code changes.
we measured the benefits of selfection as the reduction in the number of executed tests as well as the reduction in endto end execution time compared to retestall i.e.
running all tests at each revision .
to execute the tests we used two environments qemu emulator and an actual hardware board these environments are used by tizenrt developers and the set of tests that can run in each environment differs e.g.
network tests only run on the board.
our results for runs with the qemu emulator show that selfection reduces on average the number of executed tests and test execution time to4.
and .
respectively.
our results for runs on the board show that selfection reduces on average the number of executed tests and test execution time to5.
and .
respectively.
finally our results show that time taken to maintain the dependency graph and select tests is negligible.
2selfection selfection follows traditional rts tools most notably testtube and includes three phases analysis execution and collection.
we esec fse november lake buena vista fl usa ahmet celik young chul lee and milos gligoric describe the task of each phase the way we implement these phases and the reasoning behind our implementation decisions.
.
phases analysis phase a phase .
the goal of the analysis phase is to select tests to be run in a new project revision.
in other words the goal is to detect tests that are affected by recent code changes.
to detect affected tests selfection analyzes the executable image extracts functions and computes the checksum of each function our current implementation uses adler32 algorithm to compute the checksum but any other algorithm can be used.
once modified functions are detected selfection computes the transitive closure using a dependency graph collected in prior c phase see below to find affected tests.
selfection uses symbols instead of absolute addresses for function calls and global variables referenced in a function body and relative addresses for branches inside a function.
if these absolute addresses were not ignored even a simple change e.g.
adding a line of code could change checksum of every function.
execution phase e phase .
the goal of the execution phase is simply to run selected tests.
although this step is rather trivial for projects that use testing frameworks such as junit xunit or similar because those frameworks support test filtering i.e.
excluding a subset of tests there is no straightforward way to exclude some tests in c projects as those tests are frequently explicitly invoked from the main function.
to enable selection of some tests we pass as arguments to main the list of test functions that should be skipped.
this approach ensures that newly added tests are always run.
any project that would like to utilize selfection would have to adjust its test code to invoke our filtering library instead of invoking tests directly.
we automatically modified tizenrt test code to include necessary invocations for the sake of evaluation we describe the details of our experiment setup in section .
collection phase c phase .
the goal of the c phase is to collect dependencies for each test which will be used in the next test run and next a phase .
to collect dependencies selfection statically analyzes the executable image and builds a function call graph which is then used to find transitive dependencies for each test.
selfection uses objdump and readelf tools to build the call graph.
the dependency data is maintained in the root directory of the project.
if selfection is integrated in a continuous integration service e.g.
travisci the dependency data could be kept either in the cache or as an external repository on github.
in the dependency data we associate checksum with each function.
the persisted data is used in the a phase for the next revision.
.
design implementation decisions source vs. binary analysis .selfection as mentioned earlier analyzes an executable image in a phase and c phase.
an alternative approach would be to analyze source code of the project e.g.
via a compiler plugin to build the call graph and dependencies for tests.
both approaches have advantages and disadvantages.
binary analysis may be seen as more generic because any language e.g.
ocaml that compiles to the same executable format would be supported.
however depending on the architecture and compiler used the binaries frequently differ.
on the other hand analyzing source code would require dependencies on a specific compiler platform.
although our preference would be a compiler plugin because it wouldtable test suites available in tizenrt execution time of each test suite on artik and number of tests in each test suite note that the execution time depends on platform environment and can be much longer test suite time test arastorage i tests .
arastorage u tests .
drivers tests .
filesystem tests .
sys io u tests .
network tests .
kernel tests .
171. simplify the implementation we chose to analyze binaries simply because the compiler used to compile tizenrt gcc arm none eabi4 9 2015q3 does notsupport compiler plugins.
additionally gcc compiler plugin infrastructure in general is poorly documented.
static vs. dynamic analysis .selfection statically analyzes binaries in a phase and c phase static analysis overapproximates the set of dependencies .
an alternative would be to dynamically collect dependencies for each test.
in other words while a test is running we could collect dependencies on functions that are executed which would improve precision of the technique i.e.
test would depend only on functions that are actually used.
there are several technical reasons why we chose static analysis.
first dynamic approach would require code instrumentation.
considering that our target project tizenrt is run in restricted environment using standard instrumentation frameworks e.g.
dyninst would not be feasible.
second dynamic instrumentation would require extra memory to maintain dependencies and store those dependencies to disk.
extra memory for keeping dependencies could be too large for the environment used to run tizenrt tests e.g.
artik .
finally transferring collected dependencies from a board and even from an emulator at the end of each test run would introduce additional technical challenges and cost.
case study to assess the benefits of selfection we answer the following research questions rq1 how many tests does selfection skip on average across a large number of revisions?
rq2 what is the reduction on average in end to end test execution time across a large number of revisions?
rq3 how does time for a phase e phase and c phase compare to other build steps?
we first describe the subject used in our case study the experiment setup and then answer the research questions.
.
subject we use tizenrt developed by samsung as the main case study.
at the latest revision 0a3d2deb available at the time of our study tizenrt has functions and test functions cases.
table shows for each test suite the number of test cases and execution time.
note that a set of test suites differs for various platforms and 846regression test selection for tizenrt esec fse november lake buena vista fl usa workst a tionusb ar tik 053usb build anal yze collect transfer image select tests trigger execution fetch resul ts execute figure experiment setup with artik the numbers reported in table are obtained by running tests on artik execution time may be substantially different on other hardware platforms used at samsung.
.
experiment setup we briefly describe our experiment setup.
specifically we describe the way we prepare tizenrt for evaluation data collected during experiments i.e.
independent variables metrics used to evaluate the benefits i.e.
dependent variables and environments used to execute the experiments.
annotated repository .
recall section that selfection skips non selected tests by passing the list of test cases to skip to the main function.
we expect that these changes would be performed by developers when they integrate selfection into their projects.
as we performed the evaluation retroactively on the tizenrt repository those changes are not available so our first step was to rewrite the repository and insert the appropriate filtering code.
the result of rewriting is a new repository that contains the same files and changes as the original repository but also includes code that guards skips tests.
specifically we perform the following steps a clone the latest revision of the repository from github we will call this repository originalrepo b go revisions back into history we consider as in recent work on rts only revisions that are on the master branch i.e.
git log first parent c create a new repository named annotatedrepo that will be used to host annotated code d copy all the files from originalrepo to annotatedrepo e annotate all the tests by surrounding each test with code that will guard the test execution we automate this step with several bash scripts f commit all files in annotatedrepo g if the current revision in originalrepo is the latest revision finish the process otherwise checkout the next revision and go to step d .
data collection .
to answer aforementioned questions we performed the steps below on annotatedrepo.
we follow as closely as possible recent work on rts .
a checkout the oldest revision from the used set of revisions b execute tests using retestall and collect number of executed tests nretestall as well as test execution time tretestall c runselfection to select tests execute selected tests and collect new dependencies we collect number of executed tests nselfection as well as execution time for all phases ta phase te phase and tc phase d if there are no more revisions then finish the process otherwise checkout the next revision and go to step b .we will use tselfection to denote the end to end execution time i.e.
ta phase te phase tc phase tetc .
tetc .denotes execution time for other build steps e.g.
compilation.
dependent variables .
using the collected data we compute two variables.
first we compute test selection ratio sel as the ratio of the number of selected tests and the total number of tests i.e.
sel nselfection nretestall .
second we compute savings in end to end execution time.
arguably the most important metric for developers used to evaluate an rts technique is the reduction in end to end execution time.
we compute reduction in time as the ratio of end to end time taken by selfection and end to end time taken by retestall i.e.
time tselfection tretestall .
execution environments .
we use two execution environments qemuenv and artikenv to run the experiments both environments and several other platforms are used by tizenrt developers.
qemuenv uses qemu to emulate necessary hardware and run the tests.
only a subset of tests kernel tests in table is enabled on qemu.
we installed qemu on a machine with an intel r core tm i7 cpu .40ghz with 16gb of ram running ubuntu .
.
we set up our experiment to automatically build tizenrt transfer the image to a qemu instance execute tests and log the execution time and test results this setup was not automated prior to our work.
note that a phase and c phase are run on the host machine as already discussed in section .
artikenv uses the actual hardware an artik board to execute tests.
therefore all tests in table are enabled.
figure illustrates artikenv.
we connected the board via serial port to the machine described in the previous paragraph.
our scripts automatically build the project transfer the image to the board select tests initiate the test runs and collect logs and test results.
as in qemuenv a phase and c phase are run on the host machine.
for each test case run in either qemuenv or artikenv we compute percentage of functions on which the test case depends.
figures 2a and 2b show distribution of the percentage of test dependencies.
we can see that tests frequently depend on a small number of functions which is an ideal scenario for using an rts tool.
.
results .
.
average savings in the number of tests.
plots in figures 3a and 4a show the number of executed tests using retestall and selfection at each revision for qemuenv and artikenv respectively.
note that the set of tests run in qemuenv is not necessarily a subset of tests run on artikenv because the configuration in makefiles differ.
also we were unable to run builds for artikenv for first revisions.
we can observe that for most revisions selfection selects very small number of tests if any .
for each revision we compute sel .
our results show that sel on average across all revisions is .
and .
for qemuenv and artikenv respectively.
.
.
savings in the execution time.
plots in figures 3b and 4b show end to end execution time using retestall and selfection at each revision for qemuenv and artikenv respectively.
clearly execution with selfection is substantially faster than using retestall1.
as expected at the first revision selfection takes equal or more 1time for selfection increases initially due to the lack of cleanup in filesystem tc which was added by developers in revision 07b740ae .
847esec fse november lake buena vista fl usa ahmet celik young chul lee and milos gligoric a qemuenv b artikenv figure distribution of the percentage of dependencies per test case revision testsselfection retestall a number of tests revisiontime selfection retestall b end to end execution time figure number of executed tests left and end to end execution time right using retestall and selfection when tests are run using qemuenv revision testsselfection retestall a number of tests revisiontime selfection retestall b end to end execution time figure number of executed tests left and end to end execution time right using retestall and selfection when tests are run using artikenv time than retestall due to the analysis cost.
for each revision we compute time .
our results show that time on average across all used revisions is .
and .
of the retestall time for qemuenv and artikenv respectively.
the reduction in test time for artikenv is lower than for qemuenv because testing is not the only phase that dominates the build as we discuss below.
we also observed in figure 4b an interesting case between f1f53f6f and d99f5451 when execution time drops sharply.
this happens due to a code change that removes several sleep statements.
.
.
execution time for various build steps.
we were curious not only about the end to end execution time which was discussed in the previous answer but also about the portion of time taken by various selfection phases.
specifically we compare time for a phase c phase e phase build time except time to run selfection and tests and transfer time in case of the artikenv .
stacked plots in figures 5a and 5b show time for each step.
we can observe that a phase c phase takes negligible time.
interestingly as onlya few tests are selected on average test execution time for tizenrt becomes faster than building the project and transferring the binary to the board.
future work could optimize the transfer time by incrementally patching previously transferred binaries .
discussion different sets of tests .
we inspected several revisions used in our experiments to confirm the correctness of selection.
for example for the middle two revisions when selfection selected many tests for qemuenv c560cf79 and 93b205 but only a few for artikenv we found that those changes mostly impact binaries that are run in the emulator.
specifically the change is in up assert.c file which is not included in the binary run in artikenv.
in other words some part of code or some files are included in the binary depending on the target platform.
test order dependencies .
the order in which tests are executed may impact the results of test execution .
therefore selecting 848regression test selection for tizenrt esec fse november lake buena vista fl usa revisiontime build a phase c phase e phase a qemuenv revisiontime build a phase c phase transfer e phase b artikenv figure execution time for various build phases at each revision when tests are run using selfection only some tests may expose an unexpected behavior.
we have encountered one of these cases in our experiments.
namely we observed kernel panic due to an illegal memory access occasionally if only one test is selected in arastorage itc .
interestingly we found that there is a bug in the test case as the test should deinitialize the database after removing relations rather than the other way around .
our patch was accepted by samsung developers .
precision and safety .
rts is considered safeif it guarantees that all affected tests are selected and precise if it selects only those tests that are affected but no other tests .
we currently provide no strong guarantees about safety of selfection because we are aware that specific type of changes a change to a global variable of non primitive type and a change to an array without symbolic name may not be detected by our tool.
we leave it as future work to improve and test safety of the tool combining analysis of elf and source code would solve most of the problems.
selfection could also be more precise if we were to track dependencies on individual statements however considering the current positive results improving precision is not an immediate goal of our work.
excluded tests and always executed tests .
ten test cases in the sysio itc test suite are excluded i.e.
commented out from our experiments as their block forever even without selfection .
we believe that this has no impact on our conclusions as the number of these test cases are rather small compared to the total number of tests.
we are in touch with samsung developers about this issue and we hope to enable experiments with those tests in the near future.
on the other hand we always run some tests in the network tc and arastorage utc test suites.
this was necessary as there are testorder dependencies e.g.
a test that is querying a database depends on another test that is initializing the database.
future work .
although we made substantial progress towards practical rts tool for projects written in c there are several directions for future work.
we plan to improve safety of our tool by collecting dependencies on global variables detecting usage of function pointers etc.
evaluate selfection on other projects and optimize transfer of binaries to the board.
threats to validity external .
our results may not generalize beyond tizenrt.
we claim no such generalization and the evaluation to other c projectsremains as a future work.
our goal in this paper was to report on our experience on building rts to support tizenrt in the first place and document design decisions and challenges.
for each environment qemuenv and artikenv we use only a single host machine.
the savings could different on different platforms.
additionally although tizenrt tests could be run on different hardware boards samsung developers confirmed that artik is among the most relevant at the moment as they are heavily using this platform.
internal .selfection and the scripts we wrote to perform the experiments may contain bugs.
to mitigate this threat we extensively tested the tool and inspected the results of our experiments.
interestingly by inspecting one of the outliers we discovered the bug in tizenrt that was described in section .
construct .
we evaluated selfection on revisions in qemuenv and revisions in artikenv.
using different number of revisions or a different sequence of revisions could lead to different conclusions.
to mitigate this threat we used the latest available revisions at the time of our experiments and we went into history as far as we could before the build would start failing or our scripts for rewriting the repo would be invalidated with changes in the repo.
in the future we plan to further expand the sequence of revisions although building old revision is known to be challenging .
in our experiments we compare selfection only to retestall although many rts techniques have been proposed over the years.
to the best of our knowledge no rts tool is available for c c projects.
even if there was a tool for c c projects it would likely not be readily applicable to tizenrt.
our contribution is the experience on bringing rts into tizenrt.
related work we briefly discuss the most related work on rts evaluation of regression testing tools in industry and work on build systems.
rts techniques .
several recent survey papers extensively discuss work and progress on rts .
rothermel and harrold presented a test selection algorithm based on control dependency graph.
testtube combines static and dynamic analysis and builds dependencies of tests on functions.
although selfection is directly inspired by testtube selfection does not use code instrumentation for reasons described earlier.
recently 849esec fse november lake buena vista fl usa ahmet celik young chul lee and milos gligoric there has been substantial effort to enable rts with coarse grained dependencies to work with managed languages and perform large scale evaluations.
gligoric et al.
presented ekstazi an rts tool for projects that compile to java bytecode.
ekstazi tracks dynamic dependencies on class level .
several studies have shown that ekstazi can reduce end to end time by over and several companies and open source projects adopted the tool.
work by legunsen et al.
implemented and evaluated rts with static class dependencies.
their results showed similar savings to ekstazi with small negative impact on safety of the technique.
the idea behind ekstazi was reimplemented for .net and evaluated together with microsoft developers .
unlike most of the recent work on rts our focus was on c projects and specifically on evaluating rts for tizenrt.
regression testing tools in practice .
srivastava and thiagarajan implemented echelon a test case prioritization tool that analyzes binaries and prioritizes tests based on the number of basic blocks that they cover.
elbaum et al.
proposed an approach to perform unsafe rts in the pre submit phase this rts selects a set of tests that failed in the given time window.
herzig et al.
introduce theo a tool for accelerating testing process based on a cost model.
our work differs as our goal was to make a step towards an rts technique for c. build systems and continuous integration systems .
many modern build systems e.g.
bazel condor etc.
compute static file dependencies for each target or those dependencies are explicitly provided by developers .
as these systems keep dependencies for each target they are commonly imprecise i.e.
they may run more tests than necessary.
our work improves precision for c projects as we detect changes on function level.
hilton et al.
studied usage cost and benefits for continuous integration ci .
we plan to integrate selfection in tizenrt to run as part of ci.
conclusions we presented selfection a novel regression test selection rts tool for projects written in c. selfection implements static functionlevel rts and analyzes binaries to collect dependencies and find affected tests.
to evaluate selfection we integrated the tool in the latest revisions of tizenrt an open source project developed by samsung.
we measured savings in terms of the number of executed tests and test execution time compared to retestall i.e.
running all tests from scratch for each revision .
we used two environments to execute tests qemu emulator and the actual hardware board artik .
our results for qemu emulator show that selfection reduces the number of tests and end to end execution time to .
and .
on average compared to retestall.
our results for artik show that selfection reduces the number of tests and time to .
and .
on average compared to retestall.
we are currently working closely with samsung developers to deploy selfection at the company.
we believe that extending selfection with support for other binary formats or creating a variant that works as a compiler plugin can result in a valuable tool for many other c developers.