a cross tool communication study on program analysis tool notifications brittany johnson rahul pandita justin smith denae ford sarah elder emerson murphy hill sarah heckman caitlin sadowskiy nc state university googley raleigh north carolina usa mountain view ca usay bijohnso rpandit jssmit11 dford3 seelder ncsu.edu emerson heckman csc.ncsu.edu supertri google.comy abstract program analysis tools use noti cations to communicate with developers but previous research suggests that developers encounter challenges that impede this communication.
this paper describes a qualitative study that identi es kinds of challenges that cause noti cations to miscommunicate with developers.
our resulting noti cation communication theory reveals that many challenges span multiple tools and multiple levels of developer experience.
our results suggest that for example future tools that model developer experience could improve communication and help developers build more accurate mental models.
ccs concepts human centered computing !user studies keywords program analysis tools human factors communication .
introduction program analysis tools such as static analysis tools refactoring tools and code smell detectors can ease manual and sometimes tedious software development tasks by automatically analyzing and modifying source code .
output from these tools such as warnings and errors come in the form of textual or visual noti cations that vary from tool to tool.
in our previous interviews professional developers reported not using static analysis tools one type of program analysis tool because noti cations can be di cult to interpret .
the goal of our research is to understand what makes it challenging for developers to interpret program analysis tool noti cations.
to motivate this goal consider ann a hypothetical professional developer.
while using the findbugs static analysis tool she encounters the noti cation acm isbn .
i ncorrect lazy initialization and update of static eld javax... m anagingfocusforwardtraversalkeys injavax...installdefaults th is method contains an unsynchronized lazy initialization of a static eld.
after the eld is set the object stored into that location is further u pdated or accessed.
the setting of the eld is visible to other threads a s soon as it is set.
if the further accesses in the method that set the eld serve to initialize the object then you have a very serious mu lti threading bug unless something else prevents any other thread fro m accessing the stored object until it is fully initialized.
ev en if you feel con dent that the method is never called by multiple t hreads it might be better to not set the static eld until the value you a re setting it to is fully populated initialized.
f igure a noti cation from findbugs concerning incorrect lazy initialization fb2 .
in figure .
at rst glance the concept of multi threading is familiar from her experience with the java compiler.
however she is not familiar with lazy initialization or findbugs and realizes that she has to learn the terminology used by findbugs before she can understand the problem.
because she has limited time and no prior experience with lazy initialization she enlists the help of outside resources and hopes for a speedy resolution.
while ann is hypothetical her challenges are not this example is based on the challenges encountered by several participants in the study described in this paper.
moreover the challenges are not unique to findbugs we found these challenges occurred when participants used di erent program analysis tools.
in this paper we describe a thinkaloud study where we asked developers with varying backgrounds to interpret noti cations from three tools findbugs the eclipse java compiler and eclemma.
we chose to study multiple program analysis tools to understand cross tool challenges not just challenges with individual tools.
to identify challenges we examined tool use through the lens of communication theory .
based on existing research on how computers should talk to people the main contribution of this paper is that it proposes an explanatory theory that describes permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
fse november seattle wa usa acm.
... .
why developers encounter di culties when interpreting tool noti cations.
our theory encompasses categories of challenges that emerged from our study the rst crosstool noti cation study of which we are aware.
we apply our theory by presenting ways that program analysis tools can improve communication with developers such as by collecting modeling and leveraging developer experience.
.
related work existing research has focused on easing the process of understanding and resolving noti cations from one particular tool.
rather than studying program analysis tools separately we believe it is more fruitful to understand the challenges developers encounter across multiple program analysis tools.
as we describe in this section existing studies that examine multiple tools typically either focus on tools of the same type i.e.
multiple compilers or helping developers make informed choices among tools.
our work is related in that our ndings can be used to improve the design of tools to better support developers.
our work di ers in that we investigate di erent types of tools to identify common challenges developers encounter when interpreting noti cations across tools.
much of the research on improving developers ability to interpret tool noti cations has focused on compiler noti cations .
hartmann and colleagues developed a social recommender system helpmeout to better assist novices with understanding and resolving compiler noti cations .
they found their tool provides useful xes about half of the time.
traver investigated why developers have di culty with compiler noti cations and ways to improve compiler noti cation design .
based on his ndings traver developed compiler noti cation design principles which includes using consistent messages and including more visual aids.
mu slu and colleagues developed quick fix scout an extension to eclipse quick fix to ease the process of determining an optimal x .
they found programmers could more quickly assess and apply quick xes when able to easily reason about x trade o s. barik and colleagues studied how developers reason about compiler noti cations to improve tool support for understanding and resolving tool noti cations .
compiler noti cations are not the only type of noti cations a developer might encounter further supporting the need for cross tool investigations.
studying tool noti cations across tools as we have increases the likelihood our ndings can generalize to a variety of tools.
cross tool studies that do exist focus on helping developers decide what tools to use rather than tool improvement.
mettrey evaluated ve expert systems tools on factors such as performance to aide developers in selecting one for their projects .
wagner and colleagues compared two analysis tools that detect defects to evaluate their e ciency .
other tool evaluations have had the same goal .
though to our knowledge there are no studies that explore the applicability of communication theory to tool use there are studies that explore the applicability of other theories to tool use .
one is our prior work on how developers visualize compiler messages we found that selfexplanation theory can be used to explain how developers work through compiler error messages .
in other prior work we used di usion of innovation theory to explore factors that in uence security tool adoption .
similarly rienmenschneider and hardgrave explored why tools do not get used using the technology acceptance model based largely on the theory of reasoned action .
lawrance and colleagues used information foraging theory to propose a theory of information foraging for how programmers navigate code when debugging .
in contrast we apply communication theory to understand the challenges developers encounter when interpreting tool noti cations.
.
methodology we next describe our study design.
our research materials are available on line to aid other researchers in replication and exploration.
.
research question in a previous study we asked developers to recall experiences with static analysis tools and brie y use findbugs.
we found that some developers do not use static analysis tools due to di culty interpreting the noti cations tools use to communicate .
to nd out how tools could better communicate with developers our study is designed to answer the question why do developers encounter challenges when interpreting program analysis tool noti cations?
using hannay and colleagues guidelines we frame our question as whyrather than what to support our building of a theory that explains the challenges developers encounter.
.
participants we recruited twenty six participants using mailing lists classroom recruitment and personal contacts.
participants include undergraduate students graduate students and professional developers with varying amounts of development and tool usage experience.
figure shows the distribution of participants development experience based on self reports in a pre study questionnaire.
increasing participant numbers indicate increasing software development experience and throughout the paper we use boxes orpartial boxes to indicate participant job roles professional graduate and undergraduate respectively .
for example the gure indicates that p24 is a professional developer with fteen years of development experience.
three graduate students p15 p18 p22 reported having industry experience.
ten participants had prior experience using eclemma.
nineteen participants had prior experience with findbugs.
all participants had experience with the eclipse java compiler.
.
program analysis tools investigated our study focuses on tools that can be used in the eclipse integrated development environment ide .
we chose eclipse because it is one of the most widely used ides making it easier to recruit quali ed participants and because it is compatible with a variety of tools.
we selected findbugs the eclipse java compiler and eclemma as mature popular tools.
findbugs findbugs version .
noti cations communicate with the developer about defects in her code based on code patterns.
bug icons in the gutter are colored red to indicate the scariest code patterns orange for scary patterns yellow for troubling patterns and blue for of concern.
text 0p9 p10 p12 p8 p6 p7 p14 p16 p17 p19 p21p24 p13 p4 p26p20 18yearsp2 p1 p25 p23 p11p15 p18 p22undergraduate graduate professional 4p5p3figure distribution of participants years of development experience.
a source code n ullcheck of e at line of value previously dereferenced in javax.
s wing.text.defaultstyleddocument.getparagraphelement int b short description a value is checked here to see whether it is null but this value can t b e null because it was previously dereferenced and if it were null a null p ointer exception would have occurred at the earlier dereference.
es sentially this code and the previous dereference disagree as to wh ether this value is allowed to be null.
either the check is redundant o r the previous dereference is erroneous.
c full description figure a noti cation of a previous null check from findbugs fb4 .
descriptions are available by hovering over or clicking the ic on as seen in figure .
eclipse java compiler eclipse java compiler jdt version .
noti cations communicate with developers when their program cannot compile and provide warnings about suspicious code .
noti cations are typically shown as squiggly underlines in the editor.
like findbugs the compiler uses color to represent severity errors are shown as red underlines warnings as yellow underlines.
underlines are augmented with gutter icons as shown in figure at line .
when the developer mouses over the underlined code or the i con the noti cation displays a text description figure b .
unlike findbugs clicking the gutter icon does not provide a detailed description.
instead clicking the icon sometimes provides possible xes that can be automatically applied to the code called quick xes.
eclemma eclemma v2.
is a code coverage tool that executes a program typically with junit as the driver to communicate with the developer about code paths that did and did not get exercised.
although eclemma communicates about a source code th e type new abstractinterrruptiblechannelinterruptible m ust implement the inherited abstract method new abstractinterru ptiblechannel.interruptible.interrupt b text description figure an eclipse compiler noti cation about unimplemented methods cmp5 .
a source code with highlighting of branches missed b text description figure an eclemma noti cation about partial branch coverage ecl3 .
one particular execution as with the other tools it provides information to the developer regarding code during runtime rather than compile time .
eclemma uses highlighting to indicate code execution code highlighted in green was executed red was not executed and yellow was partially executed.
figure shows an example of coverage reported by eclemma on an ifstatement.
when the developer mouses over the ic on the tool noti es her of how many paths got executed on the associated branch statement at line figure b .
these tools may seem quite di erent but we chose them speci cally to identify challenges developers experience across tools.
despite the di erences these tools attempt to communicate similar concepts to developers using similar textual and visual noti cations.
for example both findbugs and eclemma communicate information about control ow and both findbugs and the eclipse java compiler communicate about data ow.
all three tools use color codes in a largely consistent manner such as using red to indicate the highest level of urgency.
and as a nal example most noti cations communicate information about program elements such as methods and classes and information about program execution be it potential or actual.
75table noti cations used in our study noti cation tool problem category fb1 findbugs string comparison using or !
pointers