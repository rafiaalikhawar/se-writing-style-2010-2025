target driven compositional concolic testing with function summary refinement for effective bug detection yunho kim kaist daejeon south korea yunho.kim03 gmail.comshin hong handong global university pohang south korea hongshin handong.edumoonzoo kim kaist daejeon south korea moonzoo.kim gmail.com abstract concolic testing is popular in unit testing because it can detect bugs quickly in a relatively small search space.
but in system level testing it suffers from the symbolic path explosion and often misses bugs.
to resolve this problem we have developed a focused compositional concolic testing technique focal for effective bug detection.
focusing on a target unit failure v a crash or an assert violation detected by concolic unit testing focal generates a system level test input that validates v. this test input is obtained by building and solving symbolic path formulas that represent system level executions raising v. focal builds such formulas by combining function summaries one by one backward from a function that raisedvtomain .
if a function summary aof function aconflicts with the summaries of the other functions focal refines ato a by applying a refining constraint learned from the conflict.
focal showed high system level bug detection ability by detecting out of the real world target bugs in the sir benchmark while other relevant cutting edge techniques i.e.
afl fast katch mixccbse detected at most bugs.
also focal detected new crash bugs in popular file parsing programs.
ccs concepts software and its engineering software testing and debugging .
keywords automated test generation target driven compositional concolic testing function summary refinement craig interpolant dynamic symbolic execution acm reference format yunho kim shin hong and moonzoo kim.
.
target driven compositional concolic testing with function summary refinement for effective bug detection.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
introduction concolic testing and software model checking have been popular in unit level i.e.
exploring a function fwith symbolic unit driver stubs environments after separating ffrom an entire target program p because they can detect bugs quickly in a relatively small search space .
however concolic unit testing has a weakness in that most of the detected failures infare false alarms raised by infeasible unit executions i.e.
unit executions that are infeasible at system level .
this is because concolic unit testing uses approximate symbolic driver stubs which do not accurately represent the real context s of finp.
note that false alarms are serious obstacles for unit testing .
in contrast system level concolic testing does not suffer from false alarms because it generates concrete system level test inputs that execute pfrommain .
however system level concolic testing often fails to detect bugs due to a huge symbolic path space.
to resolve these weaknesses of unit testing and system testing we have developed focused compositional concolic testing focal .
instead of exploring a huge symbolic search space from scratch to detect failures focal identifies target failures quickly by using concolic unit testing and to focus on generating system level test inputs that validate the failures.
thus it can detect many bugs in a limited time without false alarms.
focal operates as follows .identifying target failures v focal applies concolic unit testing to every function in pand checks whether a failure occurs i.e.
a crash or an assert violation .
this unit level concolic testing can identify many more failures although many of them are false ones than system level concolic testing in a limited testing time.
.generating a system level test input that validates the identified target failures v for each function a focal builds a function summary fs awhich is a disjunction of the explored symbolic paths i.e.
a under approximate fs .
focal tries to construct a validating system level symbolic path formula vwhose solution is a system level test input that validates v. suppose that a static function call graph of phas a call chain from main toa1where a1calls fvwhich raisedvin concolic unit testing i.e.
main an ... a2 a1 such thatmain calls an ancalls an and so on .
focal obtains vby combining the summaries of the functions in main an ... a2 a1 and the unit executions of fv that raisev calling it v one by one backward i.e.
combining vwith a1first and then with a2 and so on .
if an intermediate symbolic path formula spf generated by combining vwith the summaries of functions in the call chain ak ... a1 is satisfiable but that of a grown esec fse august tallinn estonia yunho kim shin hong and moonzoo kim call chain ak ak ... a1 with vis unsatisfiable ak conflicts with the combined summaries of the functions in ak ... a1 and v. then focal refines akto akto resolve the conflict by applying a refining constraint which is learned from the conflict by using an smt solver i.e.
craig interpolants in sect.
.
.
.
note that this target driven refinement of under approximate fses using the craig interpolants is a new technique and crucial in generating a system level test input for v sect.
.
.
and sect.
.
.
we performed experiments on the sir benchmark programs and case studies to detect new crash bugs in real world file parsing programs.
the experiments showed that focal achieved high system level bug detection ability it detected out of the realworld target bugs while relevant cutting edge testing techniques i.e.
afl fast katch mix ccbse detected only and bugs respectively sect.
.
.
also focal successfully detected new crash bugs in popular file parsing programs sect.
.
.
the contributions of this paper are as follows focal is the first technique that detects bugs effectively in a limited testing time by combining the advantages of concolic unit testing i.e.
quick target failure identification and systemlevel concolic testing i.e.
validating target failures without false alarms .
without exploring a huge symbolic search space from scratch it focuses on generating system level test inputs that validate the target failures identified by concolic unit testing.
we have developed the following techniques to construct v effectively and efficiently by composing fses construction of a realistic fs of a function aibased on ai s extended unit which provides realistic contexts to ai sect.
.
.
extended units can reduce false target failures as well as nonvalidating spfs i.e.
satisfiable spfs whose solutions do not validate the target failures and increase validating spfs sect.
.
.
target driven refinement of under approximate fses using craig interpolants to guide concolic testing to construct more validating spfs sect.
.
.
and sect.
.
.
we performed systematic empirical evaluations of the bug detection ability of focal and relevant cutting edge testing techniques i.e.
afl fast katch mix ccbse and several variants of focal on the sir c programs.
in the experiments focal detected out of the target bugs without any false alarms while the other techniques detected at most sect.
.
focal detected new crash bugs in popular file parsing programs.
these were reported with the crashing system test inputs generated by focal to the original developers and confirmed by the developers sect.
.
.
we made real world bug data for the sir benchmark programs publicly available these data were collected and organized after examining the bug reports of the last years so that researchers can use them for various testing research purposes sect.
.
.
.
the paper is organized as follows.
sect.
shows an illustrating example.
sect.
describes details of focal.
sect.
explains the experiment setup used to evaluate focal for comparison with other techniques.
sect.
reports the experimental results.
sect.
discusses observations from the experiments.
sect.
discusses related work.
finally sect.
concludes the paper with future work.
figure example target program illustrating example we explain how focal generates a system level input that fails through an example three functions main f andg in fig.
.
step .
identifying a target failure line ving in fig.
focal identifies line in gas a failure line by concolic unit testing i.e.
vis line and fv g .
the spf of the unit execution of fvthat fails at v v is s c s .
step .
generating summaries of functions in p focal generates a fs of every function in pusing concolic unit testing.
suppose that during the concolic unit testing of fin a limited testing time salways starts with b i.e.
s b at line .
then the fs of f f will be as follows f s b s s b s .
.
.
s .
.
.
step .
constructing a system level symbolic path formula that validates v to construct a system level symbolic path formula spf from a target function that raises a failure at v i.e.
g tomain focal selects one of the g s callers and combines vwith the fs of the selected caller.
among multiple callers focal first chooses a caller having the highest function relevance with g the function relevance is given as a label between function nodes in fig.
.
among the two callers of g i.e.
fandmain focal first chooses fbecauseg has a higher function relevance with f i.e.
.
than main .
.
oncefis chosen focal conjoins v step and f step and finds that f vis unsatisfiable because s b in f conflicts with v s c s .
to refine f first focal obtains a craig interpolant iof vand f i.e.
i s c using z3.1then it inserts assume i at the beginning of f i.e.
at the end of line as a refining constraint 1i s c is a craig interpolant of vand f see corollary because v i i.e.
s c s s c and i fis unsatisfiable i.e.
s c s b s ... 17target driven compositional concolic testing with function summary refinement for effective bug detection esec fse august tallinn estonia figure an extended unit of f5and two failure contexts main f1 f3 and main f2 f3 in a static call graph of p. we assume that f5has a target failure line v i.e.
fv f5 .
whereassume exp immediately terminates a current execution if expis false.
by re running concolic unit testing of fwithassume s c at line focal obtains a refined fs f s c .
now f v s c s c s becomes satisfiable.
then focal continues to construct a systemlevel spf for the failure by conjoining main with f v. finally if the final spf v main f v is satisfiable focal generates a system level input i.e.
a solution of v that crashes the program at line .
if vis not satisfiable focal tries to refine main into main then it checks if v main f v is satisfiable.
if vis not satisfiable focal tries to build a different validating spf by backtracking to combine vand main instead of f and checks if main vis unsatisfiable it refines main into mainif necessary .
if main v and main v is still unsatisfiable focal tried all possible call chains from main tog but failed to generate a test input to validate the target failure vat line .
focused compositional concolic testing technique focal this section explains how focal operates using a target program pin fig.
as an example.
fig.
shows a static call graph of pwhich consists of functions i.e.
main f1 ... and f10 including the program entry function main .
.
overview fig.
shows the overall process of focal.
focal takes as inputs a target program pand a set of system level seed test inputs tand generates system level test inputs that make pfail.
focal operates in the following four phases see fig.
.
measuring function relevance sect.
.
first focal generates system level test inputs by fuzzing the given system level seed test inputs.
then from the function call profile obtained by executing the fuzzed system tests it measures relevance between every pair of the functions in p. this information is used for target failure line identification fs generation and system level spf construction.
.
identification of a target failure line v sect.
.
to identify a target failure line v i.e.
a line of program code where a crash or an assert violation occurs focal applies concolic unit testing to every function in p. we call a function that hasvasfv.
for example focal applies concolic unit testing to each of main f1 ... and f10in fig.
separately.
suppose that f5is written in lines and f5crashes at line during concolic unit testing off5.
then we set line as a target failure line vandfv f5.
.
construction of function summaries sect.
.
for each function ainp focal builds a fs awhich is a disjunction of spfs explored by concolic unit testing i.e.
an underapproximate fs .
.construction of system level spfs to validate a failure at v sect.
.
to validate a failure at vin system level i.e.
generating a test input that makes pfail atv focal builds spfs by combining unit failure executions v i.e.
a set of unit executions of fvthat fail atv and the summaries of the functions in v sfailure context e.g.
ak ... a1 which is a call chain to a1that calls fv .
for example of fig.
suppose that concolic unit testing of f5 crashes at line in f5 i.e.
fv f5 .
then focal builds spfs by combining vand the summaries of the functions in the failurecontext of v e.g.
f1 main f1 f3 f1 f3 main f1 f3 f2 f3 and main f2 f3 until it constructs a validating spf whose solution makes pfail atv.
.
function relevance metric focal computes function relevance metric using the conditional probability based on the function call profiles observed from system test executions.
to obtain accurate function relevance focal generates a large number of system test inputs by fuzzing a given set of system level seed test inputs t. focal considers that fand are highly relevant if it frequently observes that fcalls immediately or transitively denoted by f or calls fin system test executions.
intuitively speaking if caller callee functions execute together frequently they closely interact with each other which means that they are highly relevant to each other.
we measure the relevance between fand denoted by r f as x y 2such that xisp f or f f which is calculated byw zwhere wis the number of the system test executions where f or foccurs zis the number of the system test executions where foccurs yisp f or f ex.
suppose that we have the following test executions in fig.
t1 main f1 f1 f5 f5 f7 t2 main f1 f1 f5 f5 f8 f8 f9 t3 main f1 f1 f5 f5 f7 f5 f8 f8 f9 f8 f10 t4 main f1 f1 f3 f3 f6 f6 f10 in this example r f5 f7 .
2because p f5 f7 f5 andp f5 f7 f7 and r f5 f10 .
2because p f5 f10 f5 3andp f5 f10 f10 .
.
identification of a target failure line v focal applies concolic unit testing to each function ainpand identifies a target line vinaifafails.
to reduce false target lines 18esec fse august tallinn estonia yunho kim shin hong and moonzoo kim figure focused compositional concolic testing focal caused by infeasible unit executions focal applies concolic unit testing to an extended unit ofa denoted by e a .e a consists ofa a sclosely relevant callee functions b1...bn i.e.
functions reachable from ain a static call graph and symbolic stubs to replace callee functions of athat are not closely relevant to a symbolic stubs return unconstrained symbolic values .
note that concolic unit testing e a instead of aalone can reduce false alarms by removing infeasible unit executions of a because a s closely related functions can provide realistic environment to a. the relevance between functions aandb denoted by r a b is measured based on how frequently acalls bor vice versa among system test executions sect.
.
.
note that e a should only contain functions b1...bnwhich are closely relevant to a i.e.
r a b is among the top of the relevancies between all function pairs inp since including more functions will enlarge symbolic path space and degrade unit testing effectiveness and efficiency.
for example of fig.
suppose that e f5 is f5 f7 f8 f9 because r f5 f7 is high i.e.
among the top of the relevancies between all function pairs in p .
similarly suppose that r f5 f8 andr f5 f9 are also high but not r f5 f10 .
when focal applies concolic unit testing to f5 it explores e f5 consisting of f5 f7 f8 f9 .
.
function summary construction focal builds a fs of every function aofpas a disjunction of all explored spfs is one a i.e.
adef i during the target failure line identification process sect.
.
.
this approach of building fses is applicable for complex real world programs with nested loops external binary libraries complex pointer arithmetic etc.
the syntax and semantics of fs follow qf bv in smtlib2.
to focus on exploring diverse behaviors of ain a given time budget focal applies concolic unit testing to e a using a weighted random negation search strategy.
this search strategy randomly negates a branch in a current symbolic path while giving four times higher chance to the branches in athan the branches in the other functions in e a .
.
construction of system level spfs to validate a failure at v .
.
preliminaries.
fvis the function which has a target failure line v. cvis a set of functions that directly call fv.
for example of fig.
fv f5andcv f1 f3 .
vis a set of failure executions in fv i.e.
a disjunction of the spfs of e fv generated by concolic unit testing that fail at v .
adenotes a fs of a function a. ais a disjunction of the spfs of e a generated by concolic unit testing i.e.
a iwhere iis a spf of e a .
afailure context sv ak ... a2 a1 of a target failure line v is a call chain path in a static call graph of psuch that akcalls ak ak 1calls ak 2and so on and a1 cv.
for example the failure contexts of vin fig.
are f1 main f1 f3 f1 f3 main f1 f3 f2 f3 and main f2 f3 .
slice ai ai is a sliced formula of ai 1with regard to the invocation of a function ai i.e.
for ai j slice ai ai jwhere jis a prefix of jonly up to an invocation of ai .
v a fora cvdenotes a combined spf of vand the fs of athat directly calls fv i.e.
v a slice a fv v .
for a failure context skv ak ... a1 v skv denotes a combined spf of vand v s symbolic calling context formula which is the combined sliced summaries of the functions in svin a backward order i.e.
v skv slice ak ak v ak ... a1 .
combined fses capture effects on visible variables parameters return values in ssa form i.e.
all variables in fses are expressed as expressions over the symbolic input variables .
for example of fig.
v main f1 f3 slice main f1 v f1 f3 slice main f1 slice f1 f3 v f3 slice main f1 slice f1 f3 slice f3 f5 v .
.
strategies for function summary composition.
to generate spfs that validate a failure at vquickly focal uses function relevance metric to select a fs to combine as follows i.e.
giving a high priority to a function which has high relevance with a most recently combined function .
suppose that focal has built v sk 1v where the failure context sk 1vis ak ... a1 andak 1is called byb1 ... bm.
focal selects biwhose relevance with ak 1is the highest and combines biwith v sk 1v .
if focal fails to generate vafter selecting bito combine with v sk 1v it backtracks to select and combine bi which has the second highest relevance with ak 1and so on.
this function relevance based fs composition can be effective because if bis more relevant with ak 1than b it will be easier to refine bto be compatible with ak 1than b because bandak share more common contexts than b andak i.e.
bmay need less refinement steps to become compatible with ak 1than b .
19target driven compositional concolic testing with function summary refinement for effective bug detection esec fse august tallinn estonia figure fsr using the craig interpolants .
.
generation of symbolic path formulas by combining function summaries.
to generate a spf vto validate a failure at v focal combines the summaries of the functions in a failure context main ... a1 ofvand vin a backward order.
if the combined spf is satisfiable focal uses a solution of the formula obtained by an smt solver as a system level test input to validate a failure at v. for fig.
where fv f5 focal generates spfs as follows .suppose that r f3 f5 r f1 f5 .
focal generates v f3 slice f3 f5 v. if v f3 is satisfiable and r f1 f3 r f2 f3 focal increases a failure context of vto f1 f3 .it generates v f1 f3 slice f1 f3 v f3 and checks if v f1 f3 is satisfiable.
if yes focal increase a failure context ofvto main f1 f3 .
.finally if v main f1 f3 slice main f1 v f1 f3 is satisfiable focal obtains a solution of v main f1 f3 by using a smt solver and uses the solution as a system level test input to validate a failure at v. meanwhile a combined spf may be unsatisfiable if a fs conflicts with the other fses.
for example suppose that akcalls ak 1in a failure context of v i.e.
sk 1v ak ... a1 and akdoes not contain a symbolic path that provides a context necessary for v sk 1v to invoke a failure at v. then the combined formula slice ak ak v sk 1v will be unsatisfiable.
in such cases focal refines akas shown in sect.
.
.
.
.
.
function summary refinement fsr .
fig.
shows how focal refines a fs.
suppose that focal combined akand v sk 1v where a failure context sk 1vis ak ... a1 akcalls ak 1and v sk 1v is satisfiable.
if the combined formula is unsatisfiable due to the conflict between akand v sk 1v to continue construction of spfs to validate a failure at v focal refines akinto ak.
it builds akusing concolic testing2one ak with a craig interpolant of v sk 1v andslice ak ak as a refining constraint.
craig interpolation theorem is given as follows 2to build a refined fs quickly focal extends cfg search heuristic to guide the search to reach the lines where akcallsak 1quickly.theorem craig .suppose a cis a valid implication in first order logic i.e.
a c .
then there is a craig interpolantisuch that a i and i c. corollary .
suppose that a bis unsatisfiable in first order logic i.e.
a b .
then by thm.
there is a craig interpolant isuch that a i andi bis unsatisfiable.
suppose that ais v sk 1v bisslice ak ak and v sk 1v slice ak ak is unsatisfiable.
then by corollary there exists a craig interpolant iof v sk 1v andslice ak ak such that i slice ak ak is unsatisfiable.
note that slice ak ak represents the already explored paths in ak.
thus craig interpolant i can work as a guide in concolic unit testing of akto avoid revisiting already explored paths i.e.
i slice ak ak .
and at the same time ican lead the concolic unit testing to explore paths compatible with v sk 1v i.e.
v sk 1v i .
now we propose the following heuristic to build aksuch that v ak ... a1 is satisfiable.
when focal generates akusing concolic testing focal enforces a craig interpolant iof v sk 1v andslice ak ak as a fs refining constraint so that akcan be different from ak and thus akmay not conflict with v sk 1v .
this strategy constructs a new fs akthat can be compatible with v sk 1v .
this is becauseiguides concolic testing to make ak contain symbolic paths different from the ones in akby pruning slice ak ak becausei slice ak ak is unsatisfiable .
focal implements this strategy by inserting assume i at the beginning of the body of ak which guides concolic execution to explore paths that satisfy iby terminating an execution of ak immediately ifiis violated.
suppose that akdoes not resolve the conflict in the first function summary refinement step.
we call the craig interpolant used in this first function summary refinement step as i1and the first refined fs as 1ak ak .
then focal obtains the second interpolant i2 i v sk 1v slice 1ak ak .
then it builds a new refined fs 2akusingi2 i1as a new refining constraint and checks whether 2akresolves the conflict.
if not this step repeats until a newly refined fs does not increase branch coverage of akthree times in a row i.e.
until this step does not explore new search space of akmuch or the conflict is resolved.
.
.
example of constructing symbolic path formulas to validate a failure at vin fig.
.
suppose that fv f5andr f5 f3 .
r f5 f1 .
r f3 f1 .
and r f3 f2 .
.
first focal selects f3to build v f3 by combining f3and vbecause r f5 f3 r f5 f1 .
suppose that v f3 is satisfiable.
then focal continues to select f1 because r f3 f1 r f3 f2 to combine f1and v f3 and obtains v f1 f3 .
suppose that v f1 f3 is unsatisfiable.
then focal refines f1into f1by using a craig interpolant i v f3 slice f1 f3 .
suppose that v f1 f3 slice f1 f3 v f3 is satisfiable.
then focal 3corollary is just another form of theorem .
a cin thm is equivalent to that a bis unsatisfiable in cor because if we replace cin thm with bin cor then a b a b a b .
also i cin thm is equivalent to i bin cor which indicates that i bis unsatisfiable because i b i b i b .
20esec fse august tallinn estonia yunho kim shin hong and moonzoo kim table programs of the known crash bug benchmark target lines of of seed branch func of target programs func.
sys.
tcs cov.
cov.
bugs bash .
.
.
flex .
.
.
.
grep .
.
.
gzip .
.
.
.
make .
.
.
sed .
.
.
vim .
.
.
sum n a n a average .
.
.
.
.
.
finally combines main and v f1 f3 to build v main f1 f3 see a dotted circle on a failure context main f1 f3 in the middle of fig.
.
however suppose that v main f1 f3 is unsatisfiable and focal fails to refine main to be compatible with v f1 f3 .
then focal backtracks to f3and combines f2 instead of f1 with v f3 to build v f2 f3 .
suppose that v f2 f3 is satisfiable.
then focal continues to build v main f2 f3 see a dotted circle on a failure context main f2 f3 in the right part of fig.
.
if v main f2 f3 is satisfiable focal generates a solution to the formula and uses the solution as a system level test input to validate a failure at v. experiment setup .
research questions rq1.
bug detection ability how many target bugs does focal detect compared to fuzzing afl fast and the guided concolic testing techniques katch and mix ccbse ?
rq2.
effect of the craig interpolants in fsr how much does the craig interpolants in function summary refinement fsr affect the number of the detected bugs and the execution time to build spfs?
rq3.
effect of the extended units for bug detection and execution time how much do the extended units affect focal s number of the bugs detected and execution time compared to focal without the extended units focal e and focal with randomly built extended units focalr ?
rq4.
new crash bug detection how many new bugs does focal detect compared to afl fast katch and mix ccbse?
.
target bugs to measure bug detection ability of the techniques we target crash bugs although focal can detect non crash bugs if test oracles are provided as assertions because they e.g.
null pointer dereference divide by zero buffer overflow cause serious reliability and security problems and can be detected with automatically generated assertions.
focal automatically inserts assertions e.g.
assert ptr!
null to detect crash bugs in the target programs.
we use two sets of target programs known crash bug benchmark for rq1 and new crash bug benchmark for rq4.
.
.
known crash bug benchmark.
we collected real world crash bugs of the seven sir c programs shown in table that are larger than kloc and were fixed by the original developers from dec to july .
each program is the same version of the programs in sir because they are widely used for the software testing research.
from the revision histories we collected bugs such that the bug report shows that the bug crashes the program the original developers confirmed the bug report and released a patch to fix the bug and the bug exists at the version chosen for the benchmark i.e.
the same version in sir .
we collected total bug fix commits of the target programs.
then we extracted crash bugfix commits by searching keywords like overflow segfault etc.
we manually analyzed the changed code and commit logs of the crash bug fix commits and identified crash bugs.
we consider a program line lbas a faulty line of a bug biflbis included in the patch i.e.
the bug fix commits for b .
we did not use any artificially inserted bugs in sir.
.
.
new crash bug benchmark.
to evaluate the effectiveness of focal for discovering new crash bugs we target the popular c programs that parse regular expression xml and json .
we choose the latest versions of the target text parsing c programs as of july .
the programs consist of .
loc and .
functions on average details of the new crash bug target programs are available at the text parsing libraries are widely used in various software including server applications and smartphone apps and the crash bugs in these libraries can cause severe reliability and security problems.
.
focal setup .
.
fuzzing .
to compute function relevance from diverse system behaviors focal applied the afl fast fuzzer to generate various system test inputs.
using all system tests provided in a target program as seed test inputs focal ran afl fast for hour no target bug detected .
for known crash bug target programs it generated system test inputs that executed previously unexplored execution paths on average per program achieving .
branch coverage .4for new crash bug target programs it generated system test inputs that executed previously unexplored execution paths on average per program achieving .
branch coverage .
.
.
construction of extended units.
for each function a focal constructs an extended unit of a i.e.
e a based on the function relevance between aanda s immediate or transitive callee functionb i.e.
r a b .
ifr a b is in the top of the relevancies of all pairs of functions in p i.e.
bis closely relevant to a bis included ine a if not bis not included in e a and replaced by a symbolic stub function.
.
.
timeout of concolic unit testing.
for concolic unit testing for target failure line identification sect.
.
fs construction sect.
.
4the quality of the seed test inputs does not affect bug detection ability of focal much because it uses diverse test inputs generated by fuzzing the seed test inputs.
for example when we randomly selected and used only of the seed test inputs achieving branch coverage .
on average per program focal still detected out of target bugs.
21target driven compositional concolic testing with function summary refinement for effective bug detection esec fse august tallinn estonia and fsr sect.
.
.
we set ten minutes timeout for each function inp.
.
.
implementation.
we have implemented focal and its variants in lines of c code using clang llvm .
.
focal uses afl fast for fuzzing crown for concolic testing and z3 for solving smt constraints and computing craig interpolants.
.
automated test generation techniques to compare we have evaluated focal and the following testing techniques fuzzing technique afl fast afl fast guides the search based fuzzing to cover rarely explored code locations.
we used all system test inputs generated to compute function relevance as seed test inputs for afl fast.
we set the timeout of afl fast as the same amount of the total execution time of focal.
directed concolic testing techniques katch and mix ccbse katch takes a program a patch and a set of regression tests to generate test inputs to cover the code locations changed by the patch.
to guide katch to execute the target failure line videntified by concolic unit testing of focal we make a patch that adds a crash assertion at vto a target program.
mix ccbse takes a program and a target line as inputs and performs concolic testing to cover the target code lines.
we give each of the target failure lines videntified by concolic unit testing of focal to mix ccbse as the target line.
we implemented our own prototype of mix ccbse on klee .
in lines of c code since we could not use the mix ccbse implementation due to technical problems the implementation has not been maintained since .
we set the timeout of katch and mix ccbse for each target failure line vas the same amount of the execution time spent for the most time consuming target failure line of pby focal.
for example if focal spends one hour to validate the most time consuming target failure line in p we give one hour to katch and mix ccbse for each target failure line in p. focal i it is a variant of focal that performs fsr without the craig interpolants.
for fair comparison with focal focal i builds a refined fs in minutes which is more than the largest amount of time minutes spent by repeated fsrs using the craig interpolants sect.
.
.
.
focal e it is a variant of focal that does not use extended units i.e.
concolic unit testing performs on a single function a with symbolic stubs that replace all callee functions of a .
focalr it is a variant of focal that uses randomly constructed extended units i.e.
e a contains aandrandomly selected callee functions of a with a probability .
and symbolic stubs that replace the other callee functions of a .
for example of fig.
suppose that focalrrandomly adds f8toe f5 but not f7.
then it continues to randomly add f10 a callee of f8 toe f5 but not f9.
as a result focalrconstructs e f5 as f5 f8 f10 .
.
measurement to reduce the random variance on the experiment we repeated the experiments ten times and report the average numbers.
.
.
bug detection.
for a known crash bug b we report that b isdetected if a technique generates a system level test input that makes preach lb one of the faulty code lines of b and then crash at a target failure line.
if one system execution has covered the faulty lines of multiple target bugs we manually analyzed the system execution to identify which bug causes the failure at a target failure line.
for a new crash bug we report the number of the target failure lines where crashes are validated by the generated system test inputs as the number of detected bugs.
this is because we do not know which bug covers which failure line s .
.
.
execution time.
we report the execution time of a technique on a single machine for a fair comparison of focal with other testing techniques.
the execution time of focal and its variants consists of fuzzing and function relevance measurement fz one hour spent to fuzz the seed test inputs and negligible amount of time to calculate the function relevance using the fuzzed test inputs target failure line identification fli time spent by concolic unit testing each e a to identify target failure lines satisfiability check sc time spent for checking satisfiability of constructed spfs sect.
.
.
craig interpolant calculation cc time spent for computing the craig interpolants for fsr function summary refinement fsr time spent for running concolic unit testing to obtain a refined fs in rq1 and rq4 we report the sum of fz fli sc cc and fsr time as the execution time of focal to compare with afl fast katch and mix ccbse.
in rq2 to rq3 we report the sum of sc cc and fsr time because focal and its variants share the same target failure lines and have the same amount of fz and fli time.
.
testbed setting since the experiment scale is large the experiments were performed on machines equipped with intel quad core i5 4670k .
ghz and 8gb ram running ubuntu .
bit version.
each machine runs four instances of testing processes.
.
threats to validity a threat to external validity is the representativeness of our target programs.
we expect that this threat is limited since the target programs are widely used real world ones and tested by many other researchers.
also the set of target bugs might not be complete because we might fail to extract one from the bug reports or a target program has an unknown i.e.
not reported bug.
we expect that this threat is also limited because we did our best to thoroughly review the bug reports and the target programs are actively maintained.
a threat to internal validity is possible bugs in the implementations of focal and the other concolic testing techniques we studied.
we extensively tested our implementations to address this threat.
experiment results this section presents experiment results to answer the research questions.
all detailed data are available at view focal icse19.
22esec fse august tallinn estonia yunho kim shin hong and moonzoo kim table of the target bugs detected by and the execution time hours on a single machine of afl fast katch mixccbse and focal afl fast katch mix ccbse focal targets det.
time h det.
time h det.
time h det.
time h bugs bugs bugs bugs bash .
.
.
.
flex .
.
.
.
grep .
.
.
.
gzip .
.
.
.
make .
.
.
.
sed .
.
.
.
vim .
.
.
.
sum .
.
.
.
avg.
.
.
.
.
.
.
.
.
.
rq1 bug detection ability focal showed high bug detection ability.
table shows the numbers of the target bugs detected by and the execution time of aflfast katch mix ccbse and focal.
it shows the total execution time in hours spent on a single machine for fair comparison between the techniques .
the wall clock execution time is roughly of the reported time e.g.
focal spent hours to perform all experiment because the experiment was run on quad core machines in parallel.
in each run focal always detected the bugs in .
hours on average .
hours on average per program which consist of fuzzing and function relevance measurement fz hour target failure line identification fli .
hours satisfiability check sc .
hours craig interpolant calculation cc .
hours fs refinement fsr .
hours in contrast afl fast detected only bugs with the same amount of time as that of focal.
katch and mix ccbse detected only and bugs after spending .
and .
times larger amount of the execution time than focal i.e.
total .
and .
hours respectively.
since katch and mix ccbse do not perform concolic testing in a compositional way they need to explore large execution space to guide concolic testing to raise a failure at v. all bugs detected by these techniques were also detected by focal.
.
rq2 effect of the craig interpolants in fsr table shows that the craig interpolants in the fsr improved bug detection ability.
focal detected .
times more bugs than focal i.5also the table shows that the craig interpolantsbased fsr refines fses effectively in terms of branch coverage i.e.
acovers a largely different set of branches than a .c a is a branch coverage of aachieved by a set of execution paths in aand c a a is a branch coverage of aachieved by a set of execution paths in aor a.6table shows that focal increases the branch coverage of each function by .
p c a a c a by using fsr with the craig interpolants it generates .
interpolants on 5focal ialways detected the bugs in each of the runs.
the bugs detected by focal iare also detected by focal.
6for focal which repeats the fsr step ais the final refined fs sect.
.
.
.
for focal i ais a fs refined for the same amount of the total refinement time spent by focal.table of the detected target bugs the time hours to build spfs and the effect of fsr of focal iand focal focal ifocal tar det.
time branch cov.
det.
time i branch cov.
gets bugs h c a c abugs h c a c a a a bash .
.
.
.
.
.
flex .
.
.
.
.
.
grep .
.
.
.
.
.
gzip .
.
.
.
.
.
make .
.
.
.
.
.
sed .
.
.
.
.
.
vim .
.
.
.
.
.
sum .
n a n a .
n a n a avg.
.
.
.
.
.
.
.
.
.
table of the detected bugs and the execution time to build spfs of focal e focalr and focal.
focal efocalrfocal targets det.
time det.
time det.
time bugs h bugs h bugs h bash .
.
.
.
flex .
.
.
.
grep .
.
.
.
gzip .
.
.
.
make .
.
.
.
sed .
.
.
.
vim .
.
.
.
sum .
.
.
.
avg.
.
.
.
.
.
.
average per program .
in contrast focal iincreases the branch coverage of each function by only .
p. the execution time of focal ito build symbolic path formulas is shorter than that of focal i.e.
.
vs. .
which correspond to sc cc fsr because fsr without craig interpolants was not effective in resolving the conflicts and focal igenerates much fewer spf than focal sect.
.
.
.
rq3 effect of the extended units on bug detection and execution time the experiment results show that utilizing extended units contribute to high bug detection ability because focal detected more than twice the number of bugs bugs than focal e bugs and focalr .
bugs .
table shows the numbers of the detected target bugs and the execution time to build spfs of these techniques.
also focal spent only of the time spent by focal e i.e.
.
vs. .
hours because focal eidentified .
times more target failure lines than focal and target failure lines respectively .
focalridentified .
times more target failure lines i.e.
.
vs. and spent .
times larger amount of time i.e.
.
vs. .
hours than focal.
7focal ealways detected the bugs in each of the runs.
the bugs detected by focal eare also detected by focal.
23target driven compositional concolic testing with function summary refinement for effective bug detection esec fse august tallinn estonia .
rq4 new crash bug detection focal detected new crash bugs in the target c programs in .
hours on average8.
we have reported the new bugs with crashing system level test inputs to the developers of the target programs.
eight of them were confirmed by the developers and we have not received a response for the remaining five we uploaded all responses in for example of libxml2 .
.
focal identified target failure lines and detected two bugs in hours one buffer overflow bug crashing at htmlparser.c and one null pointer dereference bug crashing at xmlregexp.c .
for example to validate the buffer overflow bug of libxml2 .
.
focal generates a pair of command line options html and push and an input file a bytes long xml file as a test input.
discussion .
effectiveness of the craig interpolants guided fsr for bug detection ability since the amount of the execution time of focal is proportional to a number of spfs generated reducing non validating spfs i.e.
satisfiable spfs that correspond to the executions from main tov but those whose solutions do not validate the target failures is important in detecting bugs effectively in a limited testing time.
focal uses under approximate fses to reduce non validating spfs because over approximate fses may lead compositional concolic testing to generate many non validating spfs.
fsr is crucial for focal in detecting bug effectively because under approximate fses might not provide necessary execution contexts for v. with the help of the craig interpolants as fs refining constraints focal generates .
validating spfs each of which consists of .
fses on average that reach main from the target failure lines and whose solutions validate the target failures per program on average which is .
times .
.
more than the validating spfs generated by focal i. consequently focal detects .
times more bugs than focal i. thus we can conclude that fsr using the craig interpolants as refining constraints significantly improves bug detection ability of focal.
.
effectiveness of function relevance based extended units for execution time and bug detection ability realistic fses are important for compositional concolic testing techniques to detect bugs effectively in a limited testing time.
focal uses function relevance based extended units sect.
.
and sect.
.
to obtain realistic fses.
sect.
.
demonstrates that the function relevance based extended units contribute in reducing the execution time and improving bug detection ability of focal.
first since the amount of the execution time of focal is proportional to a number of target failure lines the extended units saved the execution time in a large degree by reducing false target failure lines.
focal and focal eidentified .
and .
target failure lines and spent .
and .
hours on average per program respectively.
8afl fast katch and mix ccbse detected and crash bugs in .
.
and .
hours respectively.
all bugs detected by them were detected by focal.second the extended units help focal to reduce non validating spf generation.
for example focal egenerated .
satisfiable spfs that reach main from the target failure lines on average per program.
but only .
test inputs obtained by solving these spfs validate target failures .
.
.
.
focal generated .
satisfiable spfs that reach main from the target failure lines and .
test inputs that validate the target failures .
.
.
on average per program.9thus we can conclude that the extended units contribute to build spfs that closely represent realistic systemlevel behaviors of a target program.
third the extended units also improve bug detection ability i.e.
vs. bugs detected by focal and focal e .
this is because the fses based on extended units i.e.
focal are more realistic and more compatible to combine to build spfs than the ones based on single function i.e.
focal e .
for example focal generates .
.
.
satisfiable spfs that reach main per target failure line while focal egenerates only .
.
.
satisfiable spfs that reach main per target failure line.
.
comparison of the directed compositional concolic testing techniques we compare focal with smash and alter which are the most closely related work.
since the implementations of these techniques are not publicly available we compare them in an analytic way.
focal uses an under approximate summary of a function based on its extended unit and then repeatedly refines the summary to cover program behaviors that are compatible with the target failures by using the craig interpolants.
smash generates an over approximate summary i.e.
maysummary by predicate abstraction and an under approximate summary i.e.
must summary by dynamic symbolic execution of a function.
it uses both summaries to prune the execution space that do not lead to a target failure.
unlike focal smash does not refine a must summary and may fail to detect bugs.
the experiment results with device drivers showed that smash is three times faster than a non compositional may must analysis technique dash but detects no more bugs than dash.
alter explores symbolic space of a program in a goal driven way with selectively composing over approximate fses.
alter uses craig interpolants to check if the current search scope cannot have a solution towards a target failure.
but focal uses craig interpolants to refine fses to build satisfiable spfs targeting v. the alter paper does not show a system level bug detection ability because alter generates only test inputs to a public method nearest to a target failure a method call distance from a nearest public method to a target failure is usually short not to a program entry function e.g.
main in c programs .
in contrast focal generates a test input that runs pfrommain to validate a target failure at vand thus fully demonstrates its bug detection ability as a system level bug detection technique.
9a system level test input obtained by solving a satisfiable spf still may not validate reproduce the target failure because amay not represent real behaviors of a due to a s symbolic stubs that may return infeasible values.
24esec fse august tallinn estonia yunho kim shin hong and moonzoo kim related work .
compositional symbolic analysis smart generates a fs as a disjunction of function wise symbolic path formulas i.e.
conjunctions of constraints over inputs and outputs of a function .
however since smart does not refine fses the bug detection ability may be low.
godefroid et al.
reported only a case study on message parsing modules in osip without reporting bug detection ability.
anand et al.
extends smart by generating fses as first order formulas with uninterpreted functions.
it refines a fs by refining uninterpreted functions on demand not using craig interpolants .
however unlike focal that focuses on generating test inputs to validate target failures that were quickly identified by concolic unit testing anand et al.
may not detect bugs effectively in given limited time as it targets all uncovered code locations.
anand et al.
reported three small case studies on c programs where the proposed technique detects only one more bug than pex .
qiu et al.
proposed a compositional symbolic execution for heap manipulating programs.
they reported the execution time performed by the proposed approach to explore all feasible program paths but did not report bug detection ability of the proposed approach.
for bounded model checking funfrog and hifrog construct over approximate fses using craig interpolants in a propositional logic and a quantifier free linear real arithmetics with uf theory respectively.
asadi et al.
proposed an on demand fsr using different theories for bounded model checking.
unlike these techniques which use craig interpolants to generate over approximate fses focal constructs and refines under approximate fses using craig interpolants as refining constraints.
.
directed symbolic analysis mix ccbse combines backward call chain exploration and forward shortest distance guided symbolic execution to reach a given target code line but without using fses.
cilocnoc combines symbolic backward execution and search based concrete forward execution such that forward execution handles complex code which symbolic backward execution cannot analyze e.g.
external function calls or complex loops .
since cilocnoc does not adopt compositional approach it may suffer from search space explosion problem.
cilocnoc s bug detection ability is evaluated on seven toy programs by comparing time to reach the given goal line between cilocnoc jcute and symbolic pathfinder.
bugredux generates a system level test input that reproduces a failure from the system level failed execution information such as a call stack dump or a call sequence obtained from the failed system level execution.
similarly to bugredux hercules generates a system level test input that reproduces a crash in realworld binary programs from a crash report e.g.
call stack dump program state .
first hercules identifies a crash condition from the crash report.
then it performs symbolic execution and computes a minimal unsatisfiability core if a symbolic path formula conflicts with the crash condition.
hercules guides symbolic execution to resolve the conflict by negating every clause in that appears in the minimal unsatisfiability core.
in contrast focal uses a craig interpolant for fsr to resolve a conflict between akand summariesof a current failure context.10in addition focal can detect unknown failures where as bugredux and hercules cannot detect unknown failures but reproduce failures only if information on a corresponding system level execution is available.
jaffar et al.
use a craig interpolant based search strategy to prune symbolic paths.
unlike focal that utilizes compositional concolic testing jaffar et al.
s work analyzes a whole program by performing function inlining i.e.
limited scalability.
jaffar et al.
reported the execution time spent by the proposed technique to explore all feasible execution paths in relatively small target benchmark programs i.e.
sv comp12 but did not report bug detection ability.
katch uses a directed forward search strategy to cover changed portion of source code i.e.
a patch effectively by using regression tests as initial tests of symbolic executions.
conclusion we present focal which detects many bugs in programs without false alarms.
a core idea of focal is to effectively and quickly identify the target failures using concolic unit testing and focus to generate system level tests that validate the target failures using compositional concolic testing with the craig interpolants based function summary refinement.
the evaluation with the real world c programs shows that focal outperforms fuzzing afl fast and directed concolic testing klee and mix ccbse techniques.
as future work we will improve the fs composition strategy to prune the failure contexts from which validating spfs may not be generated.
also we will improve the accuracy of function relevance metric by using machine learning techniques with various static and dynamic code features.
furthermore we will expand the target domain of the compositional approach to invasive software testing to reduce computational cost and mutation based fault localization mbfl to improve fault localization precision by generating more failing test inputs.