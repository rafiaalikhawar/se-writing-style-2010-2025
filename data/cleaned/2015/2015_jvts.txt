a symbolic justice violations transition system for unrealizable gr specifications aviv kuvent shahar maoz jan oliver ringert school of computer science tel aviv university israel abstract one of the main challenges of reactive synthesis an automated procedure to obtain a correct by construction reactive system is to deal with unrealizable speci f ications.
existing approaches to deal with unrealizability in the context of gr an expressive assumeguarantee fragment of ltl that enables efficient synthesis include the generation of concrete counter strategies and the computation of an unrealizable core.
although correct such approaches produce large and complicated counter strategies o f ten containing thousands of states.
t his hinders their use by engineers.
in this work we present the justice violations transition system jvts a novel symbolic representation of counter strategies for gr .
t he jvts is much smaller and simpler than its corresponding concrete counter strategy.
moreover it is annotated with invariants that explain how the counter strategy forces the system to violate the speci f ication.
we compute the jvts symbolically and thus more efficiently without the expensive enumeration of concrete states.
finally we provide the jvts with an on demand interactive concrete and symbolic play.
we implemented our work validated its correctness and evaluated it on unrealizable speci f ications of autonomous lego robots as well as on benchmarks from the literature.
t he evaluation shows not only that the jvts is in most cases much smaller than the corresponding concrete counter strategy but also that its computation is faster.
ccs concepts so f tware and its engineering formal methods so f tware veri f ication keywords reactive synthesis gr unrealizability introduction reactive synthesis is an automated procedure to obtain a correctby construction reactive system from its temporal logic speci f ication .
rather than manually constructing an implementation and using model checking to verify it against a speci f ication synthesis offers an approach where a correct implementation of the system is automatically obtained for a given speci f ication if such permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro f it or commercial advantage and that copies bear this notice and the full citation on the f irst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permi t ted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci f ic permission and or a fee.
request permissions from permissions acm.org.
esec fse paderborn germany acm.
... .
.
.3106240an implementation exists.
in the case of reactive synthesis an implementation is typically given as a controller i.e.
an automaton that accepts input from the environment e.g.
from sensors and produces the system s output e.g.
commands for actuators to always satisfy the speci f ication.
if such a controller exists the speci f ication is considered realizable.
otherwise the speci f ication is unrealizable there exists an environment that can force the system to violate some of its guarantees.
gr is a fragment of ltl which has an efficient symbolic synthesis algorithm and whose expressive power covers most of the well known ltl speci f ication pa t terns of dwyer et al.
.
gr speci f ications include assumptions and guarantees about what needs to hold on initial states on all states safety and in f initely o f ten on every run justice .
gr synthesis has been used and extended in different contexts and for different application domains including robotics scenario based speci f ications aspect languages event based behavior models hybrid systems and device drivers to name a few.
previous work has shown how the debugging of an unrealizable speci f ication in the context of gr can be done via the extraction of a counter strategy cs which the engineer may explore in order to analyze the source of unrealizability .
first a rabin game is played over the speci f ication and then intermediate values saved during the game are used to extract the concrete cs.
t he extracted concrete cs can be viewed as a labeled transition system lts that represents a deterministic choice for the environment for every choice by the system.
t he lts can contain cycles in which all environment assumptions are satis f ied while at least one system justice guarantee is violated states which can force the system to these cycles and states from which every system choice violates a safety guarantee.
although correct such concrete cs lts is o f ten large and complex making it expensive to compute and difficult to explore effectively.
in this work we introduce the justice violations transition system jvts a new abstract symbolic representation of a cs with three key properties.
first unlike a concrete cs the jvts is acyclic and is typically small.
t hus in comparison to the concrete cs it is much simpler and easier to explore.
second although it is abstract it is complete every in f inite and f inite play on the concrete cs has a corresponding play on the jvts.
t hird the jvts states are annotated with invariants that relate them to the speci f ication and explain exactly how the cs can force the system to violate the speci f ication.
t he jvts is comprised of cycle states which represent sets of concrete states that the system can visit in f initely o f ten and a t tractor states which represent sets of concrete states that the system can visit at most once.
we formally de f ine the jvts discuss its properties and present a symbolic algorithm to compute it in sect.
.esec fse september paderborn germany aviv kuvent shahar maoz jan oliver ringert 1env boolean dockrequest 2sys boolean ready 3sys boolean docking don quotesingle.vart dock before ready 6asm g dockrequest once ready 8gar ready gfready respond to dock requests 12gar dockingresponse prespondstos dockrequest docking 15gar g docking dockrequest 17gar g docking !
next docking listing excerpt of the docking mechanism speci f ication in addition to statically computing and presenting the jvts we introduce an interactive approach to dynamically concretize parts of it and execute it step by step while alternating between the concrete and the symbolic representations.
we describe the interactive simultaneous play of concrete and symbolic cs representations in sect.
.
we further minimize the jvts by merging of a t tractor nodes described in sect.
.
we have implemented all the above ideas in a gr synthesis framework and integrated them into an eclipse based environment.
we present a preliminary evaluation of our work using speci f ications of autonomous lego robots created by students in a project class that we have taught as well as using benchmarks from the literature.
t he evaluation provides evidence that in many speci f ications the size of the jvts is much smaller than that of the concrete cs and that its computation is faster.
we present the evaluation in sect.
.
previous works on debugging unrealizable speci f ications for reactive synthesis e.g.
have considered the notion of unrealizable core and the idea of semi automatic discovery of possible assumptions to repair an unrealizable speci f ication.
to the best of our knowledge all have used concrete css and none has considered a symbolic representation such as the jvts.
we discuss related work in sect.
.
running example we start off with a running example of an unrealizable speci f ication of the docking mechanism of a space station.
t he speci f ication shown in lst.
is deliberately small to f it and be simple enough to explain in the paper format.
t he speci f ications used in our evaluation see sect.
are larger and more complex.
.
example speci f ication t he docking mechanism described by the speci f ication in lst.
receives as input a docking request represented by the boolean environment variable dockrequest and outputs whether the space station is ready to receive docking requests the boolean system variable ready and whether the requesting spacecra f t should proceed with docking the boolean system variable docking .
t he speci f ication contains an assumption that a docking request is only sent if the mechanism was in a ready state at some point previously as expressed in the environment assumption gdockrequest once ready .
all systems satisfying the speci f ication will eventually be ready to accept docking requests expressed by justice s0 s1 s3 s2 s7 s8s6 s9 s10 s11 ready true docking true dockrequest true aux once true aux must respond false s4ready false docking false dockrequest true aux once true aux must respond false s5figure concrete cs lts for the docking mechanism speci f ication as computed by existing tools such as .
guarantee ready gfready .
t he guarantee dockingresponse prespondstos dockrequest docking ensures that every docking request will eventually receive a response allowing the spacecra f t to dock.
t his is de f ined using the prespondstos pa t tern which is translated to g dockrequest fdocking .
t he last two guarantees require that there is a docking request when the mechanism allows docking gdocking dockrequest and that there should not be two consecutive docking responses gdocking !next docking .
t his speci f ication is unrealizable.
to try to understand the problem using existing tools the engineer can generate a concrete cs as shown in fig.
the complete result will list in each state the assignments to all of the variables to avoid clu t ter we show assignments only for states s4ands7 .
while the concrete cs in fig.
does not contain many states one can see that even for such a simple and small speci f ication the concrete cs as computed by existing tools is already relatively complicated.
moreover computing an unrealizable core as suggested by some tools will not help here because the core for this example speci f ication contains all guarantees and system variables.
.
t he justice violations transition system we present an alternative the justice violations transition system jvts a symbolic representation of a cs which is much smaller simpler acyclic and informative.
fig.
shows the jvts we compute for the same example speci f ication.
t his ltl formula is not in gr .
we use here its equivalent gr translation see .
attractor cycle !dockingresponse cycle !ready ready false docking false dockrequest false aux once false aux must respond false aux once true aux must respond false docking false dockrequest false aux once true aux must respond true attractor docking true dockrequest false q1 q2 q3 q4 figure jvts for the docking mechanism speci f ication.
states are labeled with invariants.jvts esec fse september paderborn germany s2s6 s7s4s5 figure t he concretization of attractor q1in the jvts of the space station docking mechanism shown in fig.
.
t he names of concrete states are the ones appearing in fig.
.
from the jvts the engineer sees that the system can initially choose whether to set ready for docking requests or not.
if it never sets the variable ready it remains in a cycle state q2 where it will violate the system justice of ready .
if it sets ready at any point it moves to an a t tractor state q1 from which the environment can force the system to a second cycle state q3 where the system justice of dockingresponse is violated.
in addition in every state the system can choose to set docking when the environment sets !dockrequest which will get it to a t tractor state q4 representing the violation of the safety gdocking dockrequest .
to be t ter understand the f low when the system chooses to set ready the engineer can begin by selecting the cycle state q3and viewing the invariants over the concrete states it contains as shown in fig.
.
auxmust respond is an auxiliary variable indicating that there was previously a docking request to which the system must respond.
from these invariants it is clear to the engineer that indeed the system violates the justice guarantee of dockingresponse since previously there was a state where dockrequest is set but the environment does not provide this value again invariant !dockrequest and the system cannot therefore setdocking without violating the safety guarantee gdocking dockrequest .
.
concretizing a jvts state to be t ter observe how the environment can force the system to q3 once the system sets ready the engineer can concretize only the a t tractor state q1 resulting in the concrete lts shown in fig.
.
t he engineer can choose each of the states in the concretized a t tractor to view the variable assignments as she would do in the concrete cs.
in fig.
the states are named using the equivalent states in the concrete lts of fig .
t he initial state s2is the state where ready !dockrequest !docking .
t his state has successor states which depend on the system choice.
in all of them dockrequest holds.
however the system can choose whether to respond immediately to this request resulting in states s6ors7 where docking is set or not to respond immediately resulting in states s4ors5 where !docking .
even if the system responds the environment sends dockrequest immediately and the system cannot respond to it immediately without violating the safety guarantee g docking !next docking .
t herefore in states s4ands5it also holds that dockrequest .
finally in the next step the environment will not send a docking request and hence trap the system in the previously described cycle state q3.
t he above example demonstrates how the jvts provides the engineer with a high level view of the cs and then focus on speci f ic areas of interest for more in depth examination.
concretization of a jvts state is done only on demand.
t he engineer can also choose to start an interactive play from a jvts state where theengineer plays the role of the system moving between concrete states contained in it based on the engineer choices of output.
we describe state concretization and interactive play in sect.
.
preliminaries .
ltl and gr we repeat some of the standard de f initions of linear temporal logic ltl e.g.
as found in a modal temporal logic with modalities referring to time.
t he syntax of ltl formulas is typically de f ined over a set of atomic propositions apwith the future temporal operators x next and u until .
de f inition .
.
t he syntax of ltl formulas over apis pj j jx j u forp2ap.
for 2ap a computation u u0u1 2 is a sequence where uiis the set of atomic propositions that hold at the i th position.
for position iwe use u ij to denote that holds at position i inductively de f ined as u ij piffp2ui u ij iffu i6j u ij 1 2iffu ij 1oru ij 2 u ij x iffu i 1j u ij 1u 2iff9k i u kj 2and 8j i j k u jj 1 we denote u 0j byuj .
we use additional ltl operators f f inally g globally once andh historically f true u g f u ij once iff90 k i u kj u ij h iff80 k i u kj .
ltl formulas can be used as speci f ications of reactive systems where atomic propositions are interpreted as environment input and system output variables.
an assignment to all variables is called a state.
a strategy for an ltl speci f ication prescribes the outputs of a system that from its winning states for all environment choices lead to computations that satisfy .
a speci f ication is called realizable if a strategy exists such that for all initial environment choices the initial states are winning states.
t he goal of ltl synthesis is given an ltl speci f ication to f ind a strategy that realizes it if one exists.
gr synthesis handles a fragment of ltl where speci f ications contain initial assumptions and guarantees over initial states safety assumptions and guarantees relating the current and next state and justice assumptions and guarantees requiring that an assertion holds in f initely many times during a computation.
a gr synthesis problem consists of the following elements x input variables controlled by the environment y output variables controlled by the system eassertion overxcharacterizing initial environment states sassertion overx y characterizing initial system states e1x y xotransition relation of the environment s1x y x yo transition relation of the system j.alte i21 njustice goals of the environment j.alts j21 mjustice goals of the system.esec fse september paderborn germany aviv kuvent shahar maoz jan oliver ringert gr synthesis has the following notion of strict realizability sr 1 e!
so 1 e!g11h eo!
soo 1 e g e!1 i21 ngf j.alte i!
j21 mgf j.alts joo speci f ications for gr synthesis have to be expressible in the above structure and thus do not cover the complete ltl.
efficient symbolic algorithms for gr realizability checking and controller synthesis for srhave been presented in .
t he algorithm of piterman et al.
computes winning states for the system i.e.
states from which the system can ensure satisfaction of sr. .
unrealizability and rabin game a speci f ication sris unrealizable if there is a cs in which the environment can force the system to violate one of its guarantees while satisfying all the environment assumptions.
in such a cs there is an initial environment choice for which the initial states are not winning for the system.
a cs can be represented as a labeled transition system lts .
de f inition .
cs lts .
given an unrealizable speci f ication sr a cs is an ltshq t i liwhere qis a set of states lis a labeling function l q!2x y t q qis a transition relation where 8q2q qis a deadlock for the system q0 t1q q0oiff 9x2x e1q xo y.alt2y s1q hx y.altio or the transitions from qare environment deterministic and system complete 91x2x e1q xo y.alt2y s1q hx y.altio!
9q02q l1q0o hx y.alti t1q q0o iis a set of initial states such that the environment initially deadlocks the system i iff 9x2x e1xo y.alt2y s1x y.alto or the initial states are environment deterministic and system complete 91x2x e1xo y.alt2y s1x y.alto!9q2i l1qo hx y.alti and every in f inite path q1q2 of the lts violates sr i.e.
l1q1ol1q2o 6j sr unrealizability .
for a cs we say that a state qison a cycle iff the system has a strategy to visit the state in f initely many times.
de f inition .
state on a cycle .
given a cs ts hq t i li a state q2qis on a cycle in tsif there exists an in f inite path q1q2 oftss.t.qrepeats in f inite times in .
it is obvious that for every such cycle there exists at least one justice guarantee j.alts ithat is not satis f ied by any state on the cycle.
konighofer et al.
and maoz and sa ar show how to derive a cs for an unrealizable speci f ication from the intermediate results of a rabin game.
t he game computes the environment swinning states displayed here using calculus notation wen v.alt z m j 1 y n i 1 x j.alts j 1zoo 1yo j.alte i 1xoo where j.alte iis environment justice i j.alts jis system justice j and 1ro fq22x yj9x2x e1q xo y.alt2y s1q hx y.altio h x y.alti2rog t he rabin game algorithm computes css based on cycles violating at least one justice guarantee j.alts iwhile satisfying all justice assumptions j.alte j. cycles can be le f t by the system iff the environment can force it to a future cycle ensures termination or to a safety guarantee violation.
note that the above still allows css that are larger than the ones we compute.
importantly all the ones we compute satisfy def.
.
.
note that a cs can have memory and jqj2o1nj2x yjo.
during the computation of the rabin game the following intermediate results are collected z array of sets of concrete states.
cell z i1 4contains concrete states which either violate system justice guarantee i1mod mo or from which the environment can force the system to a cell z j1 4with j i. x a three dimensional array of sets of concrete states.
for indices ifrom tojzj cell z i1 jfrom to n for justice assumption j.alte j and k maximal number of steps required to satisfy current j.alte j each step consisting of a concrete state the cellx i1 j1 k1 4contains a set of concrete states which for k satisfy environment justice assumption j.alte jand have a successor inx i1 j01 k01 4forj0 1j 1mod noand some k0or are a step towards satisfying j.alte jand have a successor in x i1 j1 k01 4with k0 k. based on the rabin game we de f ine the z rank of a state de f inition .
z rank .
t he z rank of a state scontained in the intermediate results of the rabin game is zrank1so minfijs2z i1 4g.
by construction of the rabin game all states on a cycle have the same z rank iand avoid satisfaction of at least the justice guarantee j.alts imodm.
we denote all states of z rank ibyzranks1io z i1 .
for a set of states s all of z rank i we de f ine zrank1so i. the justice violations transition system jvts we are now ready to present the main contribution of our work namely the justice violations transition system jvts .
we de f ine the jvts in sect.
.
and describe the symbolic algorithm to compute it in sect.
.
.
.
de f ining the jvts a justice violations transition system jvts is an acyclic lts consisting of two types of states cycle states and a t tractor states.
each state in the jvts represents a set of states in some cs andjvts esec fse september paderborn germany each transition in the jvts represents a set of transitions in the cs.
we call this cs a cs of the jvts.
de f inition .
justice violations ts jvts .
given an unrealizable gr speci f ication a jvts is an acyclic lts tsj hqj tj ij lji s.t.
there exists a concrete cs tsc hqc tc ic lci extracted from the intermediate values of a rabin game note that every qc2qchas a zrank per def.
.
where qjis a partition of qcwhere for each qj2qjeither qjis a cycle state i.e.
8qc2qj qcis on a cycle in tsc see def.
.
or 9c1 c2 qcrepresenting cycles in tsc s.t.
zrank1c1o zrank1c2oandqcis on a path from c1toc2in tsc i.e.
in between cycles with same z rank or qjis an a t tractor state i.e.
8qc2qj qcis on a path leading to a deadlock or cycle only through a t tractor states or 9c1 c2 qcrepresenting cycles in tsc s.t.
zrank1c1o zrank1c2o andqcis on a path from c1toc2intsconly through a t tractor states i.e.
in between cycles with decreasing z ranks ljis a labeling function 8qj2qj lj1qjo flc1qcojqc2qjg tj qj qjis a transition relation where tj1qj qj 2oiff qj qj 9qc 12qj qc 22qj tc1qc qc 2o and ijis a set of initial states qj2ijiff1qj ico .
example .
.
in our running example sect.
fig.
shows a jvts.
a cs of the jvts is shown in fig.
.
t he label of a t tractor state q1is lj1q1o flc1s2o lc1s4o lc1s5o lc1s6o lc1s7og where s2 s4 s5 s6 ands7are the concrete states contained in q1 as can be seen in fig.
.
from the de f inition of lcin def.
.
the label lj1q1ois the set of assignments to input and output variables in the concrete states contained in q1.
note that def.
.
allows for multiple jvtss for the same cs we look at a minimal jvts in sect.
.
t he following states the completeness of the jvts in terms of paths in its concrete cs computed by the rabin game algorithm.
t h.sc e.sc o.sc r.sc e.sc m.sc .
jvts c o.sc m.sc p.sc l.sc e.sc t.sc e.sc n.sc e.sc s.sc s.sc .
given a concrete cs lts tscof a jvts tsj the following holds for every in f inite path c qc 1qc intsc exists a single corresponding f inite path j qj qj kintsjs.t.qj kis a cycle state for justice j.alts iand c6j gf j.alts i for every f inite path c qc qcrintsc exists a single corresponding f inite path j qj qj k k r intsjs.t.lc1qcro2 lj1qj ko and for every pre f ix ca qc qcrof a f inite or in f inite path c b qc qcr intsc exist unique corresponding f inite paths j aand j bintsjs.t.
j ais a pre f ix of j b. p r.sc o.sc o.sc f.sc.
sketch by de f inition of the jvts as a partition of the cs and by the correctness of the existing algorithm of the rabin game for cycles avoiding justice guarantees .
example .
.
in our example sect.
the in f inite path c s2 s4 s8 s9 s8 s9 in the concrete cs has a single f inite corresponding path ending in a cycle state in the jvts j q1 q3.
t he f inite path c s2 s4 s8 s9 s8 s10in the concrete cs has a corresponding f inite path in the jvts j q1 q3 q4.algorithm computing the jvts if deadendini ini then attr fromstate afii10069.italetdeadendini1inio j v.altts add1attr fromstateo returnhj v.altts en v.altchoicesi end if rt s comprankingts forstate in rts reverse z rank order do hattr fromcands en v.altchoicesi compattrfromcands x f ilterx1x z rank1stateo1 4o hpaths en v.altchoicesi comppaths c y.altclestate compcyclestate attrt ostate compattrtostate attr fromstate compattrfromstate j v.altts add1c y.altclestate attrt ostate attr fromstateo end for returnhj v.altts en v.altchoicesi t he following theorem states lack of redundant states and transitions in the jvts.
t h.sc e.sc o.sc r.sc e.sc m.sc .
jvts s t.sc a.sc t.sc e.sc a.sc n.sc d.sc t r.sc a.sc n.sc s.sc i.sc t.sc i.sc o.sc n.sc s o.sc u.sc n.sc d.sc n.sc e.sc s.sc s.sc .
given a concrete cs lts tscof a jvts tsj every state qj2qjand every transition tj2tjappears on at least one path in tsjcorresponding to a concrete path in tsc.
example .
.
in our example the states q3andq4and the transition between them in the jvts appear in the path j q1 q3 q4 which corresponds to the concrete cs path c s2 s4 s8 s9 s8 s10.
.
computing the jvts a naive method to compute the jvts could have been to f irst extract a cs using the methods described in and then compute the jvts from the cs.
however this method would require the enumeration of all states in the cs and is therefore inefficient.
our algorithm presented below is purely symbolic and thus avoids the costly enumeration.
t he algorithm uses an efficient symbolic representation and manipulation of sets of concrete states.
we consider this to be an important part of our contribution.
alg.
presents our symbolic algorithm for computing the jvts.
its input is the set of initial states iniand the intermediate values collected during the rabin game sect.
.
the z array z and the three dimensional x array x .
t he output of the algorithm is a jvts and a set envchoices which contains all possible transitions between states deterministic for the environment inputs.
we start by checking if the set of initial states inicontains a dead end state for the system i.e.
the environment can force the system to violate a safety guarantee .
if such a state exists it constitutes the cs.
it is added to the jvts alg.
line and the algorithm ends.
else we compute the ranking ts alg.
line a ts representation of zcells reachable from the initial set of states sect.
.
.
.
t he algorithm then traverses the ranking ts states in reverse z rank order.
each ranking ts state is split into at most jvts states a cycle state and a t tractor states.
in line of alg.
a set of concrete state candidates to be in one of the a t tractor states the a t tractor from cycle state are computed with the relevant environment choices sect.
.
.
in line of alg.
the a t tractor from cycle state candidates are removed from the array x in line of alg.
a set of paths along the cells with the relevant environment choices in xare computed.
each such pathesec fse september paderborn germany aviv kuvent shahar maoz jan oliver ringert represents a series of steps ending in a cycle which satis f ies all environment assumptions while violating a system guarantee sect.
.
.
in lines and of alg.
the set of concrete states to be contained in the cycle state and in the a t tractor to cycle state are extracted from the computed paths sect.
.
.
and sect.
.
.
in line of alg.
the set of concrete states to be contained in the a t tractor from cycle state are computed using the previously computed a t tractor from cycle state candidates the a t tractor tocycle state and cycle state sect.
.
.
.
finally the algorithm adds the computed states to the jvts.
as it follows the general steps of the concrete cs extraction described in and relies on the intermediate values of the rabin game the result of the algorithm is a valid jvts symbolically representing a concrete cs.
t h.sc e.sc o.sc r.sc e.sc m.sc .
.
algorithm outputs a valid jvts as de f ined in def.
.
which is minimal in the number of cycle states.
.
.
ranking ts.
t he ranking ts is an acyclic ts which groups concrete states according to their z rank.
concrete states of zrank iare part of the ranking ts only if they are reachable from initial states inithrough other concrete states of z ranks j i. t he intermediate ranking ts is non deterministic as opposed to the more re f ined jvts we later compute from it.
de f inition .
ranking ts .
given a set of concrete initial states iniand an array zof disjoint sets of concrete states the ranking tshq t iiis an acyclic ts where q 22x yis the set of states 8q2q i jzj q zranks1ios.t.
all concrete states in qare reachable from inivia states of higher z rank 8s2q 9 s1 sk s12ini sk s j k 1sj sjo zrank1sj 1o zrank1sjo transition t1q1 q2oexists for q1 q2iff9s12q1 s22q2 1s1 s2o and i qinitial states q2iiffq ini .
t he symbolic removal of duplicate concrete states from z keeping their z rank copy only ensures that we advance to the lowest z rank for the correctness of the algorithm as explained in .
.
.
computea t trfromcands.
a f ter computation of the ranking ts we compute the sets of concrete states which are the candidates to be contained in the a t tractor from cycle state.
t his computation is done for every state rankstate of the previously computed ranking ts hq t ii.
we return the set of candidate states attrfromcands and environment choices collected between the candidate states envchoices .
t he computation of attrfromcands is the standard a t tractor computation done to the set of concrete states contained in all ranking ts states of lower z rank value lower fsj9q2q zrank1rankstateo zrank1qo s2qg.
in addition we store the environment choices taken at each step of the f ixed point computation of the a t tractor in envchoices .
t he envchoices stored here are used in sect.
.
.
to compute the valid reachable per environment choices taken set of concrete states contained in the a t tractor from cycle jvts state.
.
.
comppaths.
we now describe the symbolic computation of paths along the cells in x zr1 4array of arrays where zr zrank1rankstateo.
each such path will represent a series of steps ending in a cycle which satis f ies all of the environment assumptions while violating a system guarantee.
t he f irst step of the computation is done in the f iltering of x zr1 performed in alg.
line .
t he f iltered x filterx is constructed thus 8i j s2filterx zr1 i1 j1 iff s2x zr1 i1 j1 i.e.
scomputed by rabin game and k j s x zr1 i1 k1 i.e.
sclosest to satisfying j.alte i and s attrfromcands i.e.
paths through send in a cycle.
a f ter removal of duplicate states in step we can perform an algorithm similar to the one described for concrete cs extraction in in order to compute the paths.
t he algorithm in enumerates the concrete states beginning with the initial state.
for each concrete state reached the original algorithm locates to which zcell it belongs its z rank zr and to which x zr1 j1 4cell it belongs.
it then de f ines an environment choice for this concrete state based on the following order of priorities if there exists an environment choice for which all successors of this concrete state are in a zcell of lower z rank than the cell of the current concrete state this environment choice is taken else the environment choice taken has successors in a cell closest to index in the current x zr1 j1 array or in the next array x zr1 1j 1omod n1 4if the current concrete state is already in index .
t he concrete successor states are then added to the concrete cs and are iterated over in turn if they were not already visited previously as a result of a concrete cycle .
our symbolic algorithm follows a similar f low except that instead of checking for successors of concrete states at each step and iterating over them it performs a symbolic step between sets of states composed of two parts in the f irst part a valid environment choice which leads to the target set of states dstis selected for the source set of states src for which an environment choice was not yet taken newsuccstrans1src dst others envchoiceso fhs xijs2src x2x e1s xo hs xi envchoices y.alt2y s1s hx y.altio!h x y.alti21dst otherso y.alt2y s1s hx y.altio h x y.alti2dstog others are additional destination states which can be reached via a different system choice for the taken environment choice.
t he srcanddstsets of states are subsets of states in some x zr1 k1 cells determined according to the f low in .
in the second part we take all relevant successors in dstaccording to the environment choices taken for states in src succs1src dst envchoiceso fs2dstj9s02src x2x hs0 xi2envchoices y.alt2y hx y.alti sg t he successors which are the result of succs are then used as the srcstates in the next step.
despite the similar f low there are two key differences between our computation and the one described in .
first due to the removal of states that are in attrfromcands done in step the resulting cs represented by the jvts will a t tempt to force to states with the lowest z rank possible in one or more steps.
in the choice of moving to a state in a lower z rank is only donejvts esec fse september paderborn germany by looking one step ahead.
second during computation of a path when performing steps over the filterx we consider sets of states and not a single concrete state.
.
.
compcyclestate.
t he concrete states contained in a jvts cycle state are computed using the previously calculated paths.
t here are two types of concrete states inside a cycle state states which are part of a concrete cycle in a single path and states which are between concrete cycles in different paths computed from the same ranking ts state see def.
.
.
we identify states on cycles by iterating over the computed paths and for each path computing the set of all concrete states which are a part of the cycle.
we denote these states on cycles by s. we identify states in between cycles busing a least f ixed point computation of successors of swithin paths b c s succs1c a envchoiceso where aare all the states in the paths for this ranking ts state.
.
.
compa t tractortostate.
t he concrete states contained in the a t tractor to cycle state are computed using the previously computed cycle state and the paths.
t he a t tractor to cycle state contains all concrete states in paths that are not in the calculated cycle state.
.
.
compa t tractorfromstate.
t he set of concrete states contained in the a t tractor from cycle state are computed from the attrfromcands using the ranking ts the previously computed attrto andcycle states the concrete states contained in the previously computed jvts states pand the envchoices .
t he computation begins by f inding states start attrfromcands reachable in a single step from p start fs02attrfromcandsj 9s21attrto cycle po x2x y.alt2y hs xi2envchoices e1s xo s1s hx y.altio s0 hx y.altig we then compute attrfrom as the least f ixed point of states reachable from start attrfrom a start fs02attrfromcandsj 9s2a x2x y.alt2y hs xi2envchoices e1s xo s1s hx y.altio s0 hx y.altig .
computing jvts annotations on top of the jvts computation for its presentation to the engineer we annotate its states with the following information state type a t tractor state or cycle state for each cycle state the speci f ic violated justice.
from the construction of the zarray in the rabin game the z rank identi f ies a system justice guarantee being violated by the states in the relevant z array cell and therefore by the states in the cycle state constructed from this z array cell and invariants we annotate each jvts state with invariants of the form var value .
computation of the invariants is performed by iterating over the values of each variable and checking if a restriction to the value constitutes an invariant.
in the worstcase the computation of all invariants requires o1jx yjo many efficient symbolic operations.
as a performance improvement we only check for variables that appear in the symbolic representation as only their values might constitute an invariant.note that the annotations present aggregated information.
t hey are not the labels from def.
.
.
concretization and interactive symbolic and concrete play to further assist the engineer in the exploration of the cs we implemented an interactive play over the jvts.
t he engineer can select a jvts state cycle or a t tractor and can either concretize the state or perform interactive play starting from concrete states in the jvts state.
concretizing a jvts state.
concretizing a jvts state results in generating all concrete states contained in it allowing the engineer to view the concrete cycle violating at least one justice guarantee or an a t tractor path towards the next cycle.
generation of concrete states entails enumerating all concrete states contained in the jvts state.
t herefore this can be in the worst case as expensive as computation of the concrete cs.
example .
.
in our running example fig.
shows the result of concretizing the a t tractor state q1.
in the f igure we see the concrete states it contains and the transitions between them.
t he computation of concrete states contained in a jvts state is immediate from the jvts structure returned by alg.
and the envchoices accumulated in memory.
each jvts state consists of a symbolic representation of the set of concrete states it contains and we simply extract these concrete states by enumerating all assignments to environment and system variables representing a state in this set.
we build the transitions between the states using theenvchoices .
interactive symbolic and concrete play.
t he engineer can perform an interactive play starting from a jvts state.
t he play consists of steps t he engineer chooses as a starting point a concrete state contained in a jvts state t he concrete state and all its possible concrete successors in the same jvts state and in other jvts states are displayed to the engineer t he engineer chooses a concrete successor we return to step .
example .
.
in our running example the engineer chooses to perform interactive play starting from the a t tractor symbolic state q1 in fig.
.
she selects assignments to environment and system variables in order to pick a concrete state of her interest within jvts state q1.
she chooses to give the value of true to all variables and is shown only the concrete state s7and its immediate successors s4 ands5 all of which are in the a t tractor q1 as seen in fig.
.
she then continues the play from state s4 which will display its immediate successors s8 s9 s10 and s11 as they appear in the concrete graph in fig.
.
note that these successors are in a different jvts state q3 this is indicated to the engineer during the interactive play.
using the interactive play the engineer can traverse the concrete states of the cs on demand while seeing the context provided by the jvts states in which they are contained e.g.
the system justice guarantee which the cs a t tempts to violate or invariants shared by this concrete state and other concrete states in the jvts state.
computation of an interactive play is done in the same way a concretization of a jvts state is performed except that in each step the only concrete states extracted are the ones chosen by theesec fse september paderborn germany aviv kuvent shahar maoz jan oliver ringert attractor cycle !dockingresponse cycle !ready attractor attractor ready false docking false dockrequest false aux once true aux must respond false dockrequest true aux once true aux must respond false attractor ready true docking true dockrequest true aux once true aux must respond false q1a q1cq1bq2 q3 q4 figure jvts for docking mechanism speci f ication with unmerged attractors.
attractors q1a q1b and q1ccan be merged to attractor q1 as is shown in fig.
.
t he invariants ofq2 q3 and q4are the same as shown in fig.
.
engineer and its immediate successors.
t his allows instantaneous on demand computation of concrete states and is thus very efficient.
a set of screenshots demonstrating interactive symbolic and concrete play in our eclipse based environment is available from .
merging of jvts attractor states since the jvts computation is based on the intermediate values of the rabin game as shown in sect.
.
it may contain sequences of a t tractor states that were computed from zcells of different z ranks def.
.
.
in our experience these sequences may be relatively long and do not always provide valuable information to the engineer.
t hus our default implementation merges such sequences of a t tractor states into one.
still in some cases the engineer may be interested in a more re f ined version of the jvts where such a t tractors are not merged.
we therefore provide the engineer with a means to unmerge and merge such sequences of a t tractor states on demand.
example .
.
using our running example in sect.
running the jvts algorithm without merging of a t tractor states results in the jvts shown in fig.
where state q1a q1b andq1care unmerged.
t he version of this jvts shown earlier in fig.
has these a t tractors merged to a single a t tractor q1.
as can be seen in our example without merging the resulting jvts is not the minimal jvts which is also acyclic.
t he algorithm which merges a t tractors traverses the jvts and merges neighboring a t tractors that can be merged without creating a cycle.
t his merging minimizes the number of a t tractor states of the jvts.
t hus the resulting jvts a f ter merging is minimal not only in the number of cycle states see sect.
.
but also in the number of a t tractor states.
evaluation we have implemented alg.
the interactive play discussed in sect.
and the merging discussed in sect.
in our synthesis environment based on cudd as a bdd library and integrated into eclipse.
our implementation includes also the computation of concrete cs extraction based on .
it is important to notetable t he unrealizable speci f ications of lego robots created by our students in the workshop class and used for the evaluation in this paper.
for each speci f ication we report the number of justice assumptions and guarantees nandmresp.
number of safety assumptions and guarantees afii10069.italeand afii10069.itals number of input and output variables jxjandjyj and number of auxiliary variables jau xj added due to the use of patterns and past ltl formulas.
name n mj afii10069.italej j afii10069.italsj jxj jyj j au xj gyro rev710 gyro var2 rev710 humanoid rev458 humanoid rev503 humanoid rev531 humanoid rev741 humanoid rev742 pcar rev769 pcar rev870 pcar rev888 pcar un2 colorsort rev790 colorsort rev791 selfparkingcar rev974 that the concrete cs computed might not be the one represented by the jvts i.e.
the concrete cs computed by the original algorithm might have a slightly different size than the one represented by the jvts.
both algorithms work on the same results of the rabin game but jvts computation might prefer leaving cycles early as mentioned in sect.
.
.
.
we consider the following research questions r1is the jvts computation efficient and how does it compare to concrete cs construction?
r2is the jvts smaller than the concrete cs?
.
speci f ications used only few gr speci f ications are available and these were usually created by authors of synthesis algorithms or extensions thereof.
for the purpose of evaluation we have used unrealizable speci f ications created by 3rd year cs students in a workshop project class that we have taught.
over the course of a semester the students have created speci f ications for the following systems which they actually built and run colorsort a robot sorting lego pieces by color humanoid a mobile robot of humanoid shape pcar a self parking car gyro a robot with self balancing capabilities and selfparkingcar a second version of a self parking car.
t he speci f ications were notcreated speci f ically for the evaluation in our paper but as part of the ordinary work of the students in the workshop class.
during their work the students have commi t ted many versions of their speci f ications to the repository.
most of these were realizable but some unrealizable.
we use here all of the unrealizable speci f ications from the repository.
in total we have collected speci f ications.
we consider these gr speci f ications to be the most realistic and relevant examples one could f ind for the purpose of evaluating our work.
tbl.
provides basic information regarding the size of the speci f ications number of justice and safety assumptions and guarantees jvts esec fse september paderborn germany number of input and output variables and number of auxiliary variables.
as can be seen the number of justice guarantees is small ranging from to .
t he total number of safety guarantees ranges from to .
t he state space input output and auxiliary variables ranges from 210to .
in addition to the speci f ications created by the students we considered the arm amba ahb arbiter which is the most popular gr example in literature used e.g.
in .
we looked at different sizes of amba to masters each in the variants of unrealizability described in with a justice assumption removed with a justice guarantee added and with a safety guarantee added .
we have thus run our experiments on amba speci f ications.
all speci f ications used in our evaluation the raw results and the code to reproduce our experiments are available from .
.
validation we have systematically validated the correctness of our implementation by model checking the symbolic jvts constructed for the speci f ications mentioned in this paper and for many more.
we f irst transformed the jvts into a symbolic controller.
t he initial states of this symbolic controller are the union of the initial states in the jvts states.
t he transitions of this symbolic controller are the transitions accumulated in envchoices see sect.
.
.
we then used a model checker to check whether this symbolic controller satis f ies the speci f ication sr as described in sect.
.
.
in addition we validated the completeness of jvts with regard to system choices by ensuring that given a concrete state and an environment choice represented in the jvts every system choice either violates a safety guarantee or leads to a successor which is also represented in the jvts.
our validation helped us f ind a number of bugs in our earlier implementation and to increase our con f idence in the correctness of its latest version.
.
results r1 computation time.
we run all experiments on an ordinary pc intel i7 cpu .4ghz 16gb ram with windows bit os java 64bit and cudd compiled for 64bit using only a single core of the cpu.
we measured the running time of concrete cs extraction and of symbolic jvts computation with and without merging of a t tractors for the speci f ications shown in tbl.
as well as for amba ahb speci f ications from .
times we report are median values of runs per speci f ication measured by java in milliseconds.
even though the jvts computation algorithm is deterministic we performed runs since jvm garbage collection and bdd dynamic reordering add variance to running times.
as it is well known that bdd based implementations performance is sensitive to variable order it is important to note that in all our experiments we used cudd s automatic variable reordering for the rabin game and no variable reordering for strategy extraction.
our experience shows that this con f iguration provides the fastest results for both the concrete cs extraction and the jvts computation across all the speci f ications we examined.
tbl.
le f t displays the running time quartiles for concrete cs extraction for the speci f ications from tbl.
and ratios of jvts computation times.
we see that the jvts computation istable running time in ms quartiles of the concrete cs extraction and ratios of jvts computation including annotations for the speci f ications from tbl.
and the amba speci f ications.
t o represents running time of over minutes.
lego robots amba ahb q uartile concreteconcrete jvtsratio concreteconcrete jvtsratio min q1 q2 q3 max t o1 table size quartiles and ratios for the speci f ications of tbl.
upper part and the amba speci f ications lower part comparing the concrete cs numbers of states qcand transitions tcand the ratios of jvts states and transitions with merged attractors unmerged attractors in parentheses .
we use 1as the size of empty sets of states and transitions to avoid division by .
q uartilesjqcj j tcjjqcj jqjjratiojtcj jtjjratio min q1 q2 q3 max min q1 q2 q3 max signi f icantly faster for these speci f ications.
in fact for half of the speci f ications the jvts running time is more than times faster than the concrete cs extraction and for the running time is more than times faster.
tbl.
right displays the running time quartiles and ratios for the amba speci f ications.
here as well we see the that jvts computation is faster than the concrete cs extraction.
for half of the speci f ications the running time of the jvts is faster than the concrete cs by a factor of and for of the speci f ications the jvts computation is faster by a factor of .
in all the speci f ications evaluated a t tractors merging added only very small overhead at most ms to the jvts computation time.
to answer r1 computation time of the jvts is faster than extraction of a concrete cs for both the lego robot more than times faster for half of the speci f ications and the amba speci f ications more than times faster for half of the speci f ications .
r2 size.
we have measured the number of states and transitions for the css of the speci f ications listed in tbl.
as well as for the amba ahb speci f ications for concrete css and for jvtss with without merging of a t tractors.
tbl.
upper part shows the quartiles of the number of states qcand transitions tcof the concrete cs and the ratios of the jvts sizes with merged a t tractors and unmerged a t tractors for the speci f ications listed in tbl.
.
for all of these speci f ications theesec fse september paderborn germany aviv kuvent shahar maoz jan oliver ringert number of states and transitions in the jvts is signi f icantly smaller than the number of states and transitions in the concrete cs.
in more than half of the speci f ications the number of states in the jvts is smaller by a factor of at least than in the concrete cs and in about the factor is more than .
for half of the speci f ications the number of transitions in the jvts is smaller by a factor of than the number of transitions in the concrete and for of the speci f ications the number of transitions is smaller by a factor of .
merging of a t tractors further reduces the number of states and transitions.
tbl.
lower part shows the quartiles of the number of states and transitions of the concrete cs and the ratios of the jvts sizes with without merging of a t tractors for the amba ahb speci f ications listed in sect.
.
.
t he results show that in all the amba speci f ications the size of the jvts is smaller than or equal to the size of the concrete cs.
half of the jvtss of these speci f ications are smaller than the concrete css by a factor of or more.
merging of a t tractors further decreases the size of the jvts in some cases.
to answer r2 t he size of the jvts states and transitions is much smaller than the size of the concrete cs in most the examined speci f ications.
.
t hreats to validity we brie f ly discuss threats to the validity of our results.
internal.
t he jvts computation is not trivial and our implementation may have bugs.
to mitigate this we performed a thorough validation sect.
.
using all speci f ications available to us.
external.
first we did not perform a user study with engineers to examine how the jvts achieves its ultimate goal of aiding them in debugging unrealizable speci f ications.
however the orders of magnitude smaller size of the jvts and its simplicity in comparison with the concrete cs as seen in sect.
as well as the annotations added to the jvts states directly referencing elements in the speci f ication all hint that the jvts will indeed be easier for engineers to explore and use.
second we have based most of our evaluation on speci f ications created by 3rd year cs students with no prior experience in writing ltl speci f ications.
due to the lack of other real world unrealizable speci f ication examples the speci f ications chosen were all unrealizable speci f ications available to us.
related work gr synthesis was introduced in and has since been used and investigated in many works.
to list a few d ippolito et al.
used gr to deal with fallible domains and non anomalous eventbased behavior models kress gazit et al.
used gr in robotics maoz and ringert showed gr synthesis for speci f ication pa t terns .
several tools support gr synthesis including ratsy tulip and slugs .
we give an overview of existing approaches to dealing with unrealizable gr speci f ications.
counter strategies and core.
cima t ti et al.
suggest to use a cs to provide an explanation for unrealizability and use a core to explain a single speci f ic unrealizability cause.
konighofer et al.
compute a core not only for system guarantees but alsofor output variables.
maoz and sa ar present css for scenariobased speci f ication.
all works use concrete css.
our work is the f irst to suggest a symbolic cs.
it can be composed on top of a core calculation.
interactive play.
some previous works suggest the use of an interactive play where the engineer explores the cs by playing the role of the system against the winning environment.
again all these approaches to interactive play rely on a concrete cs.
no previous work provides an interactive play which is based on a symbolic representation of the cs as we have introduced and implemented here.
repair using strengthened assumptions.
finally alur et al.
proposed a method for semi automatic strengthening of assumptions.
it analyses the concrete cs and suggests candidate assumptions that may solve the cause of unrealizability.
t he use of our symbolic cs representation in the context of repair is a very interesting future work direction.
conclusion we presented the justice violations transition system jvts a novel symbolic representation of css for gr .
t he jvts is much smaller and simpler than its corresponding concrete cs and is annotated with invariants that explain how the cs forces the system to violate the speci f ication.
we compute the jvts symbolically and thus efficiently without expensive enumeration of concrete states.
finally we provide the jvts with an on demand interactive concrete and symbolic play.
we implemented our work validated its correctness and evaluated it on unrealizable speci f ications of autonomous lego robots and on benchmarks from the literature.
t he evaluation shows not only that the jvts is in most cases much smaller than a concrete cs but also that its computation is signi f icantly faster.
we consider the following future work directions.
first one may propose an analogous symbolic representation of strategies for the realizable case to allow engineers to efficiently explore a synthesized controller.
second as we mentioned in sect.
some works investigate the use of concrete css to generate candidate assumptions that will repair the unrealizable speci f ication.
based on the jvts it may be possible to develop a symbolic and hence much more efficient repair mechanism.
t he work is part of a larger project2on bridging the gap between the theory and algorithms of reactive synthesis on the one hand and so f tware engineering practice on the other.
as part of this project we are building engineer friendly tools for writing and understanding temporal speci f ications for reactive synthesis see e.g.
.