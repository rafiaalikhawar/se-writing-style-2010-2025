code anomalies flock together exploring code anomaly agglomerations for locating design problems willian oizumi alessandro garcia leonardo da silva sousa bruno cafeo informatics department puc rio rio de janeiro brazil woizumi afgarcia lsousa bcafeo inf.puc rio.bryixue zhao dept.
of computer science usc los angeles usa yixuezha usc.edu abstract design problems affect every software system.
diverse software systems have been discontinued or reengineered due to design problems.
as design documentation is often informal or nonexistent design problems need to be located in the sourcecode.
themaindifficultytoidentifyadesignproblem intheimplementationstemsfromthefactthatsuchproblem is often scattered through several program elements.
previousworkassumedthatcodeanomalies popularlyknownas code smells may provide sufficient hints about the location ofadesignproblem.
however eachcodeanomalyalonemay represent only a partial embodiment of a design problem.
in this paper we hypothesize that code anomalies tend to flock together to realize a design problem.
we analyze to what extent groups of inter related code anomalies named agglomerations suffice to locate design problems.
we analyze more than agglomerations found in seven software systems of different sizes and from different domains.
our analysis indicates that certain forms of agglomerations are consistentindicatorsofbothcongenitalandevolutionarydesign problems with accuracy often higher than .
.
introduction design problems are structures that indicate violations of key design principles or rules .
every software system suffers from design problems introduced either during original development or during evolution.
examples of design problemsare fat interfaces overused interfaces and scattered concerns .
these problems may have different degrees of severity but all of them should be detected and possibly removed from the source code.
software systems have been often discontinued or have had to be fundamentally reengineered when design problems were allowed to persist in a system and to be compounded by other design problems introduced later.
design problems are introduced and allowed to remain in a system because their localization in the source code is difpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
as design documentation is often informal or nonexistent code anomalies popularly known as code smells are used as surface indicators of design problems.
examples of code anomalies are long method feature envy andgod class.
even though each code anomaly can provide somehinttodevelopers italonemightnotsufficetoindicate the presence of a design problem.
each design problem is rarely localized in a single anomalous element instead it is scattered into different code elements of the implementation .
as an example let us assume a developer is in charge of identifying fat interfaces .
he will need to go through all code anomalies affecting each interface in the program.
in particular he will need to inspect all the classes that implement the interfaces in the source code.
then he will have to analyze all the clients of such classes.
furthermore it is hard and time consuming to identify which code anomalies he should focus.
even for small software systems there are hundreds of code anomalies and thousands of possible relationships to examine.
the relation between design problems and their counterpart code anomalies is often complex.
unfortunately there is no understanding of which relationships between code anomalies are frequent indicators of design problems in an evolving program.
there is a recent growing interest in conceptually characterizing interactions between code anomalies .
however the relation of code anomalies and design problems is rarely investigated.
empirical studies only address how individual occurrences of code anomalies emerge during software evolution or affect quality attributes .
they do not analyze how individual anomalies and their relationships in the code might help developers to spot design problems.
in this paper we hypothesize that code anomalies flock together in order to embody different design problems in the implementation.
therefore we investigate whether and how code anomaly relationships can help developers to locate design problems.
to achieve this purpose we propose a strategy to identify groups of inter related code anomalies i.e.
code anomalies that flock together .
we call agglomerations these groups of inter related code anomalies.
we perform a multi case study in order to investigate them focusing on agglomerations of code anomalies that are syntactically or semantically related sections .
and .
.
we analyze seven systems of different sizes ksloc to ksloc and from different domains.
our analysis involves a total of code anomalies and agglomerations.
ieee acm 38th ieee international conference on software engineering we investigate the circumstances under which agglomerations are related or not to design problems.
the analyzed circumstances involve i the statistical significance of the relation between agglomeration types and design problems ii the strength of this relation and iii the extent to which agglomerations manifest themselves at different stages of a system s lifetime i.e.
in early vs. late versions of a system.
the aforementioned analysis results in several findings .
overall approximately of the syntactic agglomerations are related to design problems.
their use can help developers to discard almost non agglomerated code anomalies that are irrelevant to locate design problems.
in general at least code anomalies of each syntactic agglomeration are related to the same design problem in all the systems.
.
however syntactic agglomerations do not suffice to assist developers in locating all design problems.
semantic agglomerations are much more consistent indicators of design problems across our target systems.
on average of the semantic agglomerations are related to design problems.
several design problems in all the analyzed systems can only be revealed with semantic agglomerations.
.
analysis of history co changes has been recently used to identify design problems during software evolution .
however we observe this approach is ineffective in locating a significant proportion of design problems.
the reason is that those problems are congenital i.e.
they were already introduced in the system s initial version.
co changes affecting the corresponding anomalous elements might occur only in later versions of a software system but it is usually too late to identify and remove congenital design problems.
many clients already depend on the anomalous code elements that realize the design problem.
the paper is organized as follow.
section presents the background to understand the paper.
section describes the settings of our study including the research questions and the procedure for data collection and analysis.
section summarizes the main results of our study.
sections and present the related work and the threats to validity respectively.
finally section concludes the paper.
.
background this section presents the background required to understand our study settings.
section .
presents key concepts and section .
introduces a motivating example.
.
code anomalies and design problems a code anomaly popularly known as code smell is a micro structure in the program that represents a surface indication of a design problem .
examples of code anomaly types vary from method level smells such as long method andfeature envy to class level smells such as god class data class shotgun surgery and divergent change .
even in small programs developers often have to face hundreds or thousands of code anomaly instances.
they need to analyze all these anomalies in order to discard postpone or further consider them.
in fact multiple anomalies mayinteract in the source code structure at which each one possibly represents a partial hint of a design problem.
on the other hand many anomalies may not contribute at all in helping developers to locate any design problem .
an important set of code anomalies actually represents design problems.
design problems are structures that indicateviolationofintendeddesignrulesorfundamentaldesign principles and they negatively impact design quality .
examples of relevant design problems are fat interface andunwanted dependencies .
the former is a general ambiguous entry point of a design component that provides non cohesive services thereby complicating the logic of its clients.
this design problem violates the well known principles of cohesion abstraction and separation of concerns.
the latter represents the violation of a design rule that specifies that two design components should not communicate.
in this study we focus on such design problems that affect a system s design decomposition into major sub systems components andtheirinterfaces.
suchdesignproblemsare often targets of major maintenance efforts and they are very often associated with design degradation that leads to partial or full discontinuation of a software system .
therefore they should be removed as early as possible from a system.
design problems often affect multiple code elements and are hard to identify in the source code.
then code anomaliesanalyzedindividuallymaynotbesufficienttohelpdevelopers in diagnosing a design problem.
additionally certain anomaly types convey micro structures that are the natural implementation solutions given the role of the code element.
for instance some types of classes e.g.
lexicalanalyzer classes naturally address several concerns while some methods e.g.
command processing and dispatching arenaturallylong .
thus certaincodeanomaliesneither cause nor contribute to the location of a design problem.
.
motivating example let us consider the example shown in figure extracted from apache oodt object oriented data technology .
oodt is a data grid system aimed at supporting the management and storage of scientific data.
oodt s versioning component which exports the versioner interface is responsible for managing and storing versions of different product types using different storage strategies.
all classes implementing versioner interface have to implement thecreatedatastorereferences method.
one of the parameters of this method is a product instance.
product class can represent several types of structures like flat and hierarchical.
as there are no classes for each product type each createdatastorereferences implementation has to decideifitisdealingwiththeright producttype.
forexample themetadatabasedfileversioner class only deals with flat products.
over time oodt developers realized that there may be a design problem located in the versioning component.
scattered changes involving this sub system have been a major source of maintenance effort.
they ran a static analysis in order to identify code anomalies that point to the design problem.
the analysis output consisted of several dozens of code anomalies scattered across several classes and methods of the versioning component.
they analyzed several anomalies individually and decided to discard some of them as they did not represent a threat to the program structure.
441finally developerszeroinonafrequentlychangedmethod ofbasicversioner called createdatastorereferences.
infact this method is simultaneously affected by four anomalies long method feature envy shotgun surgery anddivergent change.
however suchlocalanalysisdoesnotsufficetoconcludewhetherthisispartofamajordesignproblem.
oodt developers begin looking for other anomalies at neighboring methods and classes i.e.
those methods and classes that have syntactic relationships with createdatastorereferences and basicversioner.
they work their way outward by navigating in the hierarchy structure and they move up to analyzing all clients of the versioner interface such as genericfilemngobjfactory andxmlrpcfilemngrclient.
afterobservingalltheanomaliesaffectingthehierarchical structure of versioning and its direct clients the developers are able to infer that the component is being affected by the fat interface problem the versioner interface is a single entry point of the component but only the anomalies e.g.
feature envies scattered in its four implementations reveal the non cohesive nature of the interface.
those classes need to change every time that each of the different product types are changed i.e.
divergence changes .
the scatteredoccurrencesof shotgun surgeries inthe versioning component s clients reinforce the interface is providing several non cohesive services which should be segregated into separate interfaces.
each client also needs to change every time the list of products and their details are changed.
all the components that are related to versioner and have both anomalies feature envy andshotgun surgery are inside of the dashed line in the figure .
these are the components affected by fat interface.
thepresenceof fat interface inthe versioning component is causing other problems.
while a fat interface decouples components it makes the component less understandable and analyzable.
determining the actual services exposed by such component requires inspecting its implementation details.
furthermore the generality of the interface also makes it easier to misuse since different functionalities are exposed by the same interface.
yet the only way this potentially critical design flaw can be discovered is by reflecting upon multiple related code anomalies that are located in syntactically related modules the interface its subclasses and the interface clients.
.
study definition ourstudyinvestigateswhetherandhowinter relatedcode anomalies referred to anomaly agglomerations are related to design problems.
section .
describes and motivates our research questions.
sections .
and .
present the types of agglomerations we are investigating.
section .
describes the target systems of our study.
finally section .
addresses the procedure for data collection and analysis.
.
research questions existing techniques usually assume that individual anomalies suffice for assisting developers in locating design problems in the program.
the previous section showed that each design problem may be realized by various inter related code anomalies scattered in the program.
however thereisnounderstandingwhethercertainanomaly relationships can help developers in better locating design problems than individual code anomalies.
we are primarily interested in groups of syntactically related code anomalies figure fat interface affecting versioner implementation i.e.
syntactic agglomerations for short section .
.
two anomalies are syntactically related if their host program elements are connected through method calls or inheritance relationships.
wefirstinvestigatewhethersyntacticagglomerations often embody design problems in the source code.
if this hypothesis holds the inspection of such agglomerations can help developers in locating design problems.
this reasoning leads to our first research question rq1 are syntactic anomaly agglomerations sufficient indicators of design problems?
syntactic agglomerations may not suffice to locate all design problems.
thus other forms of code anomaly agglomerations may be required to locate design problems in the source code section .
.
therefore we address rq1 by analyzing the relation between diverse forms of agglomerations and design problems in the context of seven software projects.
we also analyze this relation in early versions of each project.
recent studies revealed that most of thetime programsareaffectedbycodeanomaliessincetheir creation.
in addition it might be that some design problems are congenital i.e.
they manifest in the initial versions of a program section .
.
however there is no understanding about the relation between early code anomalies and congenital design problems and more importantly between anomaly agglomerations and design problems.
this gap motivates our second research question rq2 whatproportionofdesignproblemsmanifestasanomaly agglomerations in early versions of a program?
we address rq2 by investigating the relation of design problemsandcodeanomalyagglomerationsinearlyversions of a system.
if this relation holds early detection of congenital design problems can be improved by using code anomaly 442agglomerations.
we address rq2 by analyzing the available initial versions of the analyzed software systems.
.
syntactical agglomerations asyntactic agglomeration isagroupofatleasttwoanomalous code elements explicitly related in a program.
a code element is anomalous when it is affected by one or more code anomalies.
in our study we consider the following code elements classes interfaces methods constructors and fields.
an explicit relationship is established between two anomalous elements when they have at least one of the following dependencies shared attribute method call class extension or method overload.
we classify syntactic agglomerations according to their scope in the program i intra component agglomerations i.e.
those entirely located withinasinglecomponent and ii inter component agglomerations i.e.
those located in two or more components.
in our study we consider each component is realized by a package in the analyzed java programs section .
unless the system developers specify otherwise.
developers may state a component is realized by a set of classes that are not necessarily located in the same package.
inter component agglomeration is a syntactic agglomeration that involves two or more design components with at least one anomalous code element located within each of them.
the example in section .
illustrates an inter component agglomeration in the oodt system.
the agglomeration is formed by anomalous code elements located in three oodt components versioning utiland system.
in figure the inter component agglomeration is surrounded by the dashed black line and the green circles represent the code anomalies located in the syntactically related code elements that compose the agglomeration.
listing illustrates the algorithm pseudo code for computing inter component agglomerations.
the algorithm has two parameters i dc a set of design components and ii agglomthreshold a threshold value for the minimum agglomeration size.
first the algorithm identifies all anomalous elements of a design component by using the function getanomalouselemsofcomp line .
the anomalous elements of the program are recorded in the anomalouselemsattribute.
the algorithm generates a graph graphinterelems with the syntactic relationships edges between anomalous elements vertices located in different design components line and lines .
to find the relationships between elements the algorithm uses the function isrelated line .
in order to detect the agglomerations the algorithm finds the subgraphs within the graph in which any two vertices are connected the subgraph formed by the relationships among the anomalous elements .
finally only theagglomerationswiththesizegreaterthan agglomthresholdare included in the resulting set of inter component agglomerations i.e.
interagglomerations lines .
intra component agglomeration is a syntactic agglomeration composed of anomalous code elements located in the same design component.
given space constraints the algorithm is available in our on line supplementary material .
however the algorithm for computing intracomponent agglomerations is similar to the previous algorithm for identifying inter component agglomerations.
the only difference is that the algorithm generates a graph with the relationships edges between the anomalous elements vertices within each design component.listing inter component agglomeration algorithm .public list getinteragglomeration set dc int agglomthreshold .
interagglomerations .
anomalouselems .
.for each design component dc in the program .
anomalouselems .
addall getanomalouselemsofcomp dc .
.
.
adding anomalous code elements as vertices in the graph .
graphinterelems new graphinterelems .
addvertex .
addall anomalouselems .
.
for each e1 in anomalouselems .
for each e2 in anomalouselems .
creating the inter component graph .
if isrelated e1 e2 e1.
getdesigncomponent !
e2.
getdesigncomponent .
graphinterelems .
addedge e1 e2 .
.
.
.
.
adding the connected components as agglomerations .
interagg new interagg .
addall getconnectedcomponents graphinterelems .
.
selecting only agglomerations above the predefined threshold .
for each a in interagg .
if size a. getanomalies agglomthreshold .
interagglomerations .add a .
.
return interagglomerations .
.
semantic agglomerations based on the example of section .
we hypothesized that code anomalies might somehow interact through the program structure because of the presence of a single design problem.
in that example the syntactic relationships amongst the anomalous elements would be sufficient to help developers in revealing the design problem.
however this might not be the case for all occurrences of design problems.
in some cases design problems might be related to semantically connected anomalies.
anomalies are semantically connected if their host elements are addressing the same concern.
concern is a property or functionality of interest to the designers of a system but it is not necessarily modularized in a single component.
in such cases the semanticrelationshipmayhelpthedeveloperstolocatecertain design problems better than the syntactic relationships.
letusconsideranexampleextractedfromthemobilemedia system .
mobile media is a software product line to derive applications that manipulate photos videos and music on mobile devices .
figure depicts a partial view of three components of mobile media design controller screens and sms.
classes of the screenscomponent are affected by the divergent change anomaly while classes of thecontroller andsmscomponents were infected by the divergent change andshotgun surgery anomalies.
these code anomalies did not represent isolate problems.
many of theseclassesarenotsyntacticallyconnected buttheirmethods partially address the same concern called photo label management.
therefore the anomalous code elements are altogether realizing the design problem scattered concern i.e.
multiple components realizing a crosscutting concern .
the realization of photo label management should be modularized in the controller component.
this problem was the cause of major design refactorings along mobile media evolution.
however the design problem would be better spotted if the scattered anomalies divergent changes and shotgun surgeries realizingthesameconcernareconsidered altogether.
in our study we chose concern based agglomeration as a representative type of semantic agglomerations.
figure scattered concern in mobile media semantic agglomeration is composed of anomalous code elements realizing a single concern which is not modularized by design components.
examples of design relevant concerns can be classified in domain specific concerns such asphoto label management or general purpose concerns such as persistence error handling security and the like.
semantic relationships between two or more code anomalies occur when their host code elements are intended to partially realize a single design s purpose or concern i.e.
the semantic relationship appears in code elements that implement the same concern and also have code anomalies.
listing presents the algorithm pseudo code for detecting semantic agglomerations.
the full algorithm is available in our supplementary material .
the basic idea of the algorithm is searching for agglomerations for each concern conthat satisfies the following conditions i conis located in one or more components line and ii at least one of thesecomponentsisnotmainlydedicatedtorealize con line .
the components in ii are named weakly dedicated components.
the identification of weakly dedicated components is implemented by the function weakdedicatedcomponents line .
this function computes for each component realizing a concern if code elements in the component are mostly dedicated to realize other concerns.
in other words a component dcis weakly dedicated to a concern con if conis not the main concern of the code elements within dc.
although dcpartially implements con the predominant concern of dc is not con.
the minimum degree of dedication is captured based on a percentage threshold named weakthreshold .
thus the main algorithm uses four inputs a set of design components dc themappingsforeachconcern con athreshold for the minimum agglomeration s size agglomthreshold default and weakthreshold default .
in our case study the developers provided the concern mappings section .
but the concerns can be automatically extracted from the source code using an automatic concern locationtable characteristics of the target systems system type design ksloc hw web framework layers mm software product line mvc s1 desktop application client server s2 desktop application client server s3 desktop application client server s4 web application mvc oodt middleware layers tool.
once the concerns are recovered the algorithm can locate the code elements that implement an concern conand also are infected by code anomalies line .
the anomalous code elements contributing to weakly dedicated components of a crosscutting concern are grouped into an agglomeration candidate lines to .
if the agglomeration candidate has a number of anomalies higher than the agglomthreshold line then this agglomeration is included in the results line and confirmed as an actual agglomeration.
listing semantic agglomeration algorithm .public list getsemanticagglomeration set dc set con int agglomthreshold int weakthreshold .
semanticagglomerations .
.for each design concern con in the program .
w weakdedicatedcomponents con weakthreshold .
agglomeration .
if size w .
ae getanomalouselemsperconcern w con .
agglomeration .
addall ae .
.
if size agglomeration agglomthreshold .
semanticagglomerations .
add agglomeration .
.
.
return semanticagglomerations .
.
target systems in order to address the two research questions we analyzed systems with a wide range of characteristics.
we selected systems of different sizes leveraging different design styles and spanning different domains.
table summarizes the general characteristics of each system.
we focused on these systems because i their designs had degraded ii they present a wide range of design problems and iii their developers were available to provide us with a reliable list of design problems which are causes of major maintenance effort and the mappings of their design s concerns.
the first system is the health watcher hw a web framework system that allows citizens to register complaints about the health issues in public institutions .
the second is mobile media mm an academic software product line to derive applications that manipulate photos videos and music on mobile devices .
the next four systems are proprietary and due to intellectual property constraints we will refer to them as s1 s2 s3 and s4.
s1 and s2 manage activities related to production and distribution of oil.
s3 manages the trading stock of oil and s4 supports the financial market analysis.
finally the last system is apache oodt whose goal is to develop and promote the management and storage of scientific data .
for all the target systems several classes implement each component.
in oodt for instance each design component is implemented by an average of classes.
there was always a to map444table analyzed design problems name description instances f at interfaceinterface of a design component that offers only a general ambiguous entry point that provides non cohesive services thereby complicating the clients logic.
un wanted dependency dependency that violates an intended design rule.
comp onent overloaddesign components that fulfill too many responsibilities.
cyclic dependencytwo or more design components that directly or indirectly depend on each other.
delegating abstractionan abstraction that exists only for passing messages from one abstraction to another.
scattered concernmultiple components that are responsible for realizing a crosscutting concern.
ov erused interfaceinterface that is overloaded with many clients accessing it.
that is an interface with too many clients .
un used abstractiondesign abstraction that is either unreachable or never used in the system.
ping between components and packages in three systems mm hw oodt s3 and s4.
for s1 and s2 the developers provided the set of classes implementing each component.
.
data collection procedure thedatacollectionprocesscomprisedthefollowingactivities i identifying design problems with help of the systems developers ii detecting code anomalies concern mappings andagglomerations and iii correlatingagglomerationsand design problems.
next we describe each activity.
identifyingdesignproblems.
weproduceda ground truth of design problems for each target system.
we performed two steps to incrementally develop the ground truth.
first original developers of the systems provided us with an initial list of design problems.
they listed the problems and explained the relevance of each one through a questionnaire .
theyreportedwhichwasthemaintenanceeffortcaused by the presence of each design problem.
they also described which code elements were contributing to the realization of each design problem.
second we performed other steps to validate the initial list for correctness and completeness.
an additional identification of design problems was performed using the source code and the system design.
for systems without design documentation we relied on a suite of design recovery tools .
the procedure for deriving the list of design problems with developers was the following i an initial list of design problems was identified using detection strategies presented in ii the developers had to confirm refute or expand the list of identified design problems iii the developers provided a brief explanation about the relevance of the design problem and iv when we suspected there was still inaccuracies in the list of design problems we asked the developers for further feedback.
table describes the types of design problems and number of instances identified in our sample of systems.
concern mappings.
the initial lists of concerns and their mappings in the source code were provided with the assistance of systems developers.
for each concern in their initial lists they provided a list of methods or classes realizing those concerns.
given the large size of certain systems developers could eventually not produce complete concern mappings.
therefore we also relied on the mallet tool.
mallet is a concern location tool that explores topic modeling in order to automatically generate a list of concerns and identify the code elements realizing each concern in a program.
then we computed and compared two sets of semantic agglomerations one based on the concern mapping produced by developers and the other based on the concern mapping generated by mallet.
we will discuss the comparison of such agglomerations in section .
.code anomalies and agglomerations.
we considered7typesofcodeanomalies data class divergent change god class shotgun surgery feature envy long method andlong parameter list.
they were selected because they represent different types of symptoms at class and method levels.
the detection of code anomalies was performed using well known metrics based strategies .
these detection strategies are similar to those typically used in previous empirical studies e.g.
.
such strategies have been proven to be effective for detecting code anomalies in other systems with precision higher than .
once the anomalies were detected we computed the syntactic and semantic agglomerations.
the detection of anomalies and agglomerations were carried out with a tool called organic .
organic implements i the detection strategies for code anomalies and ii the algorithms for computing agglomerations section .
and section .
.
the results of these steps are available at the supplementary material .
correlatingagglomerationsanddesignproblems.
asaforementioned developersindicatedthelocationofeach design problem.
in order to answer our research questions we defined a criterion for correlating design problems with anomalies and agglomerations.
a design problem is related toanindividualcodeanomalyiftheformeriseitherpartially orfullyrealizedbythecodeelementaffectedbytheanomaly.
weconsiderthatadesignproblemandanagglomerationare related if they co occur in at least two code elements.
even though agglomeration and design problem may be located in more than two anomalous elements our criterion considers sufficient if they co occur in two elements.
thus an agglomeration fails to indicate design problems when either none or only one of its code anomalies is related to a design problem.
finally we computed the strength of the relation between agglomerations and design problems i.e.
the number of anomalies in agglomeration that contributed or not to a design problem section .
.
we checked the statistical significance of our results using the fisher s exact test and computing the odds ratio with the r tool .
.
results and analysis this section presents the results and analysis of our study.
section4.1discusseswhethersyntacticagglomerationsassist the location of design problems.
then section .
analyzes to what extent syntactic agglomerations suffice to locate all design problems and if not whether semantic agglomerations can further improve this task.
section .
discusses if agglomerations can also be effective to assist the location of design problems in early versions of a system.
.
exploring syntactic agglomerations before answering our first research question we reflect upon the relation of syntactic agglomerations and design problems.
first we check whether syntactic agglomerations are more related to design problems than non agglomerated codeanomalies.
non agglomeratedanomaliesare detached anomalies that do not take part of any agglomeration.
the results are presented in the first three columns of table .
the first column named agglomeration lists the agglomeration types analyzed in our study.
the second column named ag dp shows the amount of agglomerations for each category related to design problems.
the third column named noag nodp presents the number of detached anomalies that are irrelevant to locate design prob445table contingency table and fisher s test results agglomeration ag dp noag nodp p value ors in tra component .
in ter component .
syn tactic .
seman tic .
all .
lems i.e.
they are not related to any design problem.
we discuss the data of the last two columns later in this section.
the data of the row semantic is discussed in section .
.
reducing the search space for design problems.
table confirms that syntactic agglomerations are good indicatorsofdesignproblems.
almost300syntacticagglomerations are related to design problems.
each row shows how many detached anomalies could be discarded when developersareexploringaspecifictypeofsyntacticagglomeration in order to look for design problems.
for instance if developers are inspecting inter component agglomerations they will be able to i find design problems in their systems and ii discard more than code anomalies returned by their static analysis tools.
this result suggests that syntactic agglomerations can assist developers in locating design problems.
when identifying design problems in the source code the scope of analysis can be reduced to the list of code anomalies taking part in the agglomeration rather than an unmanageable list of individual code anomalies.
syntactic agglomerations as design problems strength of the relation.
even though the previous analysis is interesting it does not consider that anomaly agglomerations have higher probability of being related to design problems than a single code anomaly since agglomeration involves more code.
the latter affects a single code element a method or a class while the former involves at least two code elements.
the size of an agglomeration ranged from to in all systems.
therefore we investigated the strength of the relation between agglomerations and design problems.
we performed further analyses to check to what extent various code elements of the agglomeration are in fact contributing to the realization of a design problem.
first we calculated the odds ratio for each type of agglomeration ors column of table which shows how much higher is the chance of code elements taking part in agglomerations to be related to design problems than individual anomalous elements.
the chance of each anomaly within a syntactic agglomeration being related to a design problem is more than five times higher than each detached anomaly.
similar results are observed for both intra component and inter component syntactic agglomerations.
second we also observe that almost all syntactic agglomerations had at least anomalous code elements simultaneously related to the same single design problem in most of the systems.
thus when fixing a particular design problem developers are more likely to reveal several anomalous code elements involved in the refactoring strategy.
syntacticagglomerationsasdesignproblems statistical significance.
finally we used the fisher s exact test to analyze the statistical significance of the relation between syntactic agglomerations and design problems.
the fourth column p value in table shows this correlation for each agglomeration type.
we assume a confidence level higher than p value threshold .
as the threshold value to the significant level of the test.
applying thetest we observe that for all agglomeration types the p value was lower than .
.
there is a high correlation between both forms of syntactic agglomerations and design problems in the target systems.
however it does not necessarily mean that syntactic agglomerations should not be complemented with other forms of agglomerations to further improve the locationofdesignproblems.
therefore weexplicitlyaddress our first research question in the next section.
.
do syntactic agglomerations suffice?
even though syntactic agglomerations are statistically related to design problems it is important to understand if syntactic agglomerations alone suffice to locate all design problems.
thus this section addresses rq1 are syntactic anomaly agglomerations sufficient indicators of design problems?
in order to answer rq1 we first analyzed the proportion of syntactic and semantic agglomerations un related to design problems for each target system.
we compared how often syntactic and semantic agglomerations relate to design problems.
table shows for each agglomerationtype thefollowingmeasures i precision ii recall and iii absolute number of design problems related to agglomerations dp .
moreover for each agglomeration type table shows the median and the standard deviation for the columns pandr.
the numbers between parentheses in thedpcolumns are discussed later in this section.
precision indicates the fraction of identified agglomerations that are correctly related to design problems.
recall indicates the fraction of design problems successfully identified by agglomerations.
we calculate precision and recall measures using the following standard equations p tp tp fp r tp tp fn where tp true positive and fp false positive encompass all agglomerations that respectively are or are not related to design problems.
fn false negative occurs when a group of code elements is affected by a design problem but none of them is part of an agglomeration.
table shows the relation between agglomerations and design problems in terms of precision and recall.
the syntactic column indicates the aggregate results for both types of syntactic agglomerations intra component second column and inter component third column .
we highlight that the values of the syntactic column cannot be directly obtained by the data in the previous columns.
in other words the number of design problems in the fourth column is not the result of summing the numbers of design problems for both types of syntactic agglomerations.
the reason is that there are intersections between instances of intraand inter component agglomerations.
that is an intercomponent agglomeration might be composed of anomalies that are also members of one or more intra component agglomerations.
this happens because the search of each type ofagglomerationoccursindependently.
thus adesignproblem might be related to more than one agglomeration.
syntactic agglomerations suffice to indicate several design problems.
table indicates that inter componentagglomerationsarehelpfulforlocatingmoreinstances of design problems than intra component agglomerations.
in four out of seven systems at least almost half of the inter component agglomerations were related to design problems.
however table also reveals that both types of syntactic agglomerations are useful to locate different de446table relation of agglomerations and design problems precision and recall agglom.
intra component inter component syntactic semantic system p r dp p r dp p r dp p r dp oodt mm hw s1 s2 s3 s4 median sd0.
.
.
.
.
.
.
.
number of design problems exclusively related either to intra component or to inter component agglomerations.
number of design problems exclusively related to semantic agglomerations.
sign problems in most systems.
as we expected these two types of syntactic agglomerations are complementary.
this finding can be observed by comparing the numbers of the sub columns dp from the second to the fourth columns.
in the column syntactic there are additional numbers between parentheses close to the numbers of design problems sub column dp .
these numbers represent the amount of designproblemsthatwereexclusivelyrelatedtoeitherintracomponent or inter component agglomerations.
therefore the subsets of design problems related to intra and intercomponent agglomerations in six systems are significantly different.
the only exception was the health watcher.
the reasonisthatallthedesignproblemsfoundinitwererelated to the communication between two components.
semantic agglomerations are consistent indicators.semantic agglomerations were the most consistent indicators of design problems.
this finding is based on the fact that semantic agglomerations were a good indicator of design problems across all the systems.
the 5th column ors of table shows that the chance of each anomaly within a semantic agglomeration being related to a design problem is more than seven times higher than each detached anomaly.
this likelihood is higher than anomalies within syntactic agglomerations.
in addition semantic agglomerations presented the highest correlation with design problems when compared to all other syntactic agglomerations.
for example of the semantic agglomerations in oodt were related to instances of design problems.
semantic agglomerations are also often related to design problems even for the other systems where the absolute number of related design problems is lower i the percentage of true positives was high from to and ii the percentage of false positives was low from to .
considering the data from all systems we observed a median of of semantic agglomerations related to design problems.
the standard deviation of .
is low as well.
that is the percentage of semantic agglomerations related to design problems was high in all the target systems.
regarding the absolute number of design problems dp the semantic agglomerations were related to a high number of design problems in all the systems.
syntactic and semantic agglomerations are complementary.
considering each type of agglomeration recall values were below for most of the target systems .
our results suggests that this occurs because syntactic and semantic agglomerations are complementary.
in the last column of table dp there are additionalnumbers between parentheses close to the numbers of design problems.
these numbers represent the amount of design problems exclusively related to semantic agglomerations i.e.
design problems that could not be located only with syntactic agglomerations.
figure shows an example of design problem located only in the context of semantic agglomeration.
approximately of the design problems related to semantic agglomerations have no relation to syntactic agglomerations in most of the systems.
these design problems were often cases of scattered concerns component overload overused interface anddelegating abstraction.
this result suggests that semantic agglomerations are useful to complete the location of several design problems.
these design problems are also hard to be located by developers as there is no syntactic relationship among the anomalous elements forming the agglomerations.
however existing work only focuses on characterizing code anomalies based on their syntactic relationships .
moreover these design problems cannot be detected through the use of only concern location techniques.
several crosscutting concerns in the analyzed systems are not harmful i.e.
their implementations did not contain code anomalies and they were not actual sources of design problems.
design problems indirectly related to agglomerations.
we observed occurrences of design problems affecting methods or classes that are indirectly related to agglomerations even not participating of one.
we observed three recurrent patterns of indirect relation two for methods and one for classes.
the first occurs when a method is implemented inside a class that is part of an agglomeration.
the second is observed when a method is implemented in a class that have another method in an agglomeration.
finally the third occurs when a class have one or more methods in agglomerations.
we expect an increase in the recall values because considering indirect relation makes the correlation rule less strict.
for instance in s3 the recall value for semantic agglomerations increases from to .
this suggests that an agglomeration may be helpful to identify design problems even without a direct relation.
this becomes possible when developers analyze the full context of agglomerations instead of analyzing anomalies individually.
reducing false positives of syntactic agglomerations.
even though syntactic agglomerations are often related to design problems developers would still have to inspect and discard several irrelevant agglomerations.
table shows that the number of false positives is higher than in two systems.
however we observed that the combined use of semantic and syntactic agglomerations would significantly reduce the number of false positives yielded by the use of only syntactic agglomerations.
if we only consider syntactic agglomerations that intersect with semantic agglomerations the number of false positives for syntactic agglomerations would be reduced to or less in all the systems.
there is an intersection between a syntactic agglomerationxandasemanticagglomerationywhenatleast one anomalous elements take part of both x and y. in summary the joint use of syntactic and semantic agglomerations significantly enhances the location of design problems.
fullautomationofsemanticagglomerations?
the computation of semantic agglomerations relies on mapping of system concerns to indicate design problems.
tables and show the results for semantic agglomerations computed with concern mappings produced by the systems developers.
however it is important to check whether semantic agglomerations can also improve the location of design problems when concern mappings are automatically generated.
as mentioned in section .
we also relied on concern mappings provided by mallet in order to generate a second set of semantic agglomerations.
comparing to the developers mapping we noticed mallet generates longer lists of concerns and concern mappings.
as a consequence the use of mallet results in a higher number of semantic agglomerations which was related to more design problems than our original computation .
semantic agglomerations generated with mallet s output lead to an average increase of39.
intheidentificationofdesignproblemswhencompared to semantic agglomerations generated with developers mappings.
the mallet configuration and all the detailed results are available in our supplementary material .
.
agglomerations as congenital problems?
this section addresses the rq2 what proportion of designproblemsearlymanifestthemselvesasagglomerations?
earlymanifestationmeansthedesignproblemswerepresent in the first versions of a system.
therefore they are likely to represent congenital design problems i.e.
they were introduced at design time.
in order to answer this question we computed for all the systems i the number of design problems in the first versions of our target systems and ii theproportionofdesignproblemsrelatedtoagglomerations.
theanalysisofallinitialversionsrevealedthataconsiderable number of design problems was introduced in the first version of each target system.
as opposed to our expectation all the initial versions presented a high correlation between agglomerations and design problems.
we expected most of the design problems would be evolutionary i.e.
theywouldbeintroducedduringthesystemevolution.
however the proportion of design problems related to agglomerations in early versions was approximately for mm s1 s2 and s4.
the proportion for the other systems was close to .
we also observed that a considerable proportion of design problems are exclusively related to either syntactic or semantic agglomerations already in the first version.
these results show that change history analysis would not be an effective solution to reveal many instances of design problems.
many design problems are congenital and they are already born as agglomerations.
it would be harder to remove them in later versions when eventually the agglomeration s anomalous elements start tosuffer co changes through the later versions.
an example of this case is the fat interface in the versioning component in oodt section2.
.
itwouldbecumbersometorestructure theversioner interface in later releases.
the number of client classes for this interface increased from one in the first release to more than fifteen last release .
comparing early and late versions.
we also compared the nature of design problems and agglomerations in early and late versions of mm an hw systems.
the comparison of the different versions of these two systems serves to illustrate most of our findings.
for instance let us consider the versions and of the mm system.
version of mm .
ksloc is smaller than version ksloc .
therefore the number of code anomalies and agglomerations is proportionally smaller in version .
even with fewer code elements the first version already contained oftheagglomerationspresentinversion8.
oneofthem for example is related to the basecontroller class.
in the first version this class was identified as part of an intracomponent agglomeration.
that is this anomalous class was related to another anomalous code element of the same component.
this agglomeration was related to the component overload problem.
in the subsequent versions this agglomeration expanded to several code elements including those located in other components.
more specifically in version we identified that the same agglomeration became an inter component agglomeration involving classes that use the basecontroller class.
the inter component agglomeration was related to emerging instances of fat interfaceandoverused interface problems.
for the hw system we compared versions and .
in this case version ksloc was only somewhat smaller than version ksloc .
however as in the case of the mm system we observed again that some agglomerations found in a late version had already started to form in the first version.
the first version already contained of syntactic and semantic agglomerations found in version .
all these observations suggest that agglomerations are effective to assist the identification and removal of design problems in the early versions of a system which can prevent the introduction of more severe problems in subsequent versions.
.
related work do individual anomalies suffice?
tufano et al.
investigated when and why code smells are introduced in the context of evolving systems.
kim et al.
lozano et al.
and olbrich et al.
investigated the effect of individual code anomalies throughout the system s evolution.
these studies analyzed whether the number of code anomalies tend to increase over time and how often they result in code changes.
there is also a large body of work aiming at assessing the impact of individual occurrences of code anomalies on certain software quality attributes.
for instance khomh et al.
studied the relation between code anomalies and software change proneness.
they concludedthatanomalousclassestendtobemorechange prone.
in addition corroborating with the work of li and shatnawi and d ambros et al.
they also observed that classes infected by code smells tend to be more fault prone than other classes .
j rgens et al.
and kapser et al.
found that one specific code anomaly adversely impacts onsoftwaremaintenance.
sjobergetal.
showedthatsingle code anomalies were not related to maintenance effort.
448therefore some of the results of these studies are controversial regarding the usefulness of individual code anomalies as indicators of software maintenance effort.
however none of the aforementioned studies have investigated the relation between anomaly agglomerations and design problems.
agglomerations and design problems.
while many authors investigated the impact of individual code anomalies a few studies have focused on inter related code anomalies.
abbes et al.
brought up the notion of interacting code anomalies and they studied its effects.
they concluded that classes and methods identified as god classes andgod methods inisolationhadnoeffectonmaintenanceeffort but when appearing together they led to a statistically significant increase in maintenance effort.
yamashita and moonen observed that inter smell relationships negatively affect the maintenance.
macia cataloged a set of patterns of inter related code anomalies.
however none of these authors studied the impact of inter related code anomalies on designproblems andnoneofthemcharacterizedorexplored semantic relationships between code anomalies.
architecturallyconnectedproblems.
therearesome studies that explored architecturally connected files to spot design problems in software systems.
kazman et al.
explored architecturally connected files to identify and quantify architectural debts in large scale systems.
similarly to us the authors identified design problems in the systems under analysis.
however we focus on the relation among code anomalies rather than the architectural connection among files.
mo et al.
proposed the detection of recurring architectural problems called hotspot patterns by the combination of history and architecture information.
the hotspot patterns identify error and change prone files and pinpoint specificarchitectureproblemsthatmaybetherootcausesof bugs and changes.
the author s strategy to identify design problems is also based on structural dependencies among files.
however we showed that some design problems cannotberevealedbasedonstructuraldependenciesonly.
they require to taken into account the semantic relation among anomalous code elements during their identification section .
.
in addition the approaches mentioned above rely on system s revision history.
consequently they cannot be applied to early versions of the systems under analysis.
.
threats to v alidity constructvalidity.
themajorriskhereisrelatedtoerrorsintheidentificationofdesignproblemsandcodeanomalies.
the original developers reported the lists of design problems they found to be relevant in their systems.
therefore these lists could be inaccurate and include irrelevant design problems.
to mitigate this threat we recruited developers with extensive knowledge of their system s design and with previous experience on design reviews and source code inspections.
moreover we solicited a brief explanation about the severity of the reported design problems.
whenever we could not understand the nature and relevance of a design problem we asked for further clarification.
we discarded design problems that were not properly explained.
regarding the code anomalies we selected detection strategies and thresholds that presented satisfactory results in a previous study section .
.
in any case if these strategies resulted in false positives or false negatives they would have asimilareffectonthecomputationofalltheagglomerations.
conclusion validity.
the main threat for conclusionvalidity is the number of evaluated versions of each system.
a study involving several versions of each system is always desired.
however it was impracticable in our study due to the number of systems and the limited availability that original developers and architects had to participate in the study.
we tried to mitigate this threat by selecting for each different system versions in a different lifecycle stage.
internal and external validity.
the threats here concern the degree to which the findings can be generalized to the wider classes of subjects.
in the experiment reported upon here these threats are somewhat mitigated by the factthatweusedsystemswithdifferentsizes purposes academic commercialandopen source anddomains thatwere implemented using different design styles and that suffered from a different set of design problems.
furthermore the target systems were developed by teams of different sizes and with different levels of software development skills.
.
concluding remarks recent empirical studies suggest that individualcodeanomaliesdonotsufficetoidentifydesignproblems.
this finding represents a challenge for developers because they often need to spot design problems exclusively based on source code analysis especially because of the lack of upto date design documents .
in order to decide whether and where a relevant design problem is prevailing in the program programmers first need to know i which are the code anomalies realizing the design problem ii how these code anomalies are related to each other and iii how these anomaly relationships are connected to the design problem.
the gathering of all this scattered knowledge is time consuming and error prone.
in this work we analyzed to what extent code anomaly agglomerations can help developers to locate design problems.
we confirmed that code anomalies often flock together in order to embody a design problem.
we studied the relation of design problems with both syntactic and semantic agglomerations in a longitudinal multi case study involving systems.
syntactic agglomerations are relevant indicators of design problems and help to discard an average of irrelevant anomalies per system.
we also found the combined use of syntactic and semantic agglomerations represents a more effective approach for locating design problems.
many congenital and evolutionary design problems were only related to semantic agglomerations.
moreover a considerable proportion of design problems are congenital and manifest as agglomerations in the implementation.
this result means that state of the art solutions based on change history analysis are not adequate to promptly detect such problems.
we plan to perform further investigations with the twofold goal of i identifying efficient criteria for ranking code anomaly agglomerations in order to prioritize critical design problems and ii conceiving a technique to analysis how anomaly agglomerations relate to each other throughout the software system histories.
.