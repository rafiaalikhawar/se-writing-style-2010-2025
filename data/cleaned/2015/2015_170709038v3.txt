enabling mutation testing for android apps mario linares v squez universidad de los andes colombiagabriele bavota universit della svizzera italiana switzerlandmichele tufano college of william and mary united states kevin moran college of william and mary united statesmassimiliano di penta university of sannio italychristopher vendome college of william and mary united states carlos bernal c rdenas college of william and mary united statesdenys poshyvanyk college of william and mary united states abstract mutation testing has been widely used to assess the fault detection effectiveness of a test suite as well as to guide test case generation or prioritization.
empirical studies have shown that while mutants are generally representative of real faults an effective application of mutation testing requires traditional operators designed for programming languages to be augmented with operators specific to an application domain and or technology.
this paper proposes mdroid a framework for effective mutation testing of android apps.
first we systematically devise a taxonomy of types of android faults grouped in categories by manually analyzing software artifacts from different sources e.g.
bug reports commits .
then we identified a set of mutation operators and implemented an infrastructure to automatically seed mutations in android apps with of the identified operators.
the taxonomy and the proposed operators have been evaluated in terms of stillborn trivial mutants generated and their capacity to represent real faults in android apps as compared to other well know mutation tools.
ccs concepts software and its engineering software verification and validation keywords mutation testing fault taxonomy operators android acm reference format mario linares v squez gabriele bavota michele tufano kevin moran massimiliano di penta christopher vendome carlos bernal c rdenas and denys poshyvanyk.
.
enabling mutation testing for android apps.
inproceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
introduction in the last few years mobile apps have become indispensable in our daily lives.
with millions of mobile apps available for download on google play and the apple app store mobile users have access to an unprecedentedly large set of apps that are not only intended to provide entertainment but also to support critical activities such as banking and health monitoring.
therefore given the increasing relevance and demand for high quality apps industrial practitioners and academic researchers have been devoting significant effort to improving methods for measuring and assuring the quality of mobile apps.
manifestations of interest in this topic include the broad portfolio of mobile testing methods ranging from tools for assisting record and replay testing to automated approaches that generate and execute test cases and cloud based services for large scale multi device testing .
despite the availability of these tools approaches the field of mobile app testing is still very much under development as evidenced by limitations related to test data generation and concerns regarding effective assessment of the quality of mobile apps test suites.
one way to evaluate test suites is to seed small faults called mutants into source code and asses the ability of a suite to detect these faults .
such mutants have been defined in the literature to reflect the typical errors developers make when writing source code .
however existing literature lacks a thorough characterization of bugs exhibited by mobile apps.
therefore it is unclear whether such apps exhibit a distribution of faults similar to other systems or if there are types of faults that require special attention.
as a consequence it is unclear whether the use of traditional mutant taxonomies is enough to asses test quality and drive test case generation selection of mobile apps.
in this paper we explore this topic focusing on apps developed for android the most popular mobile operating system.
android apps are characterized by gui centric design interaction eventdriven programming inter processes communication ipc and interaction with backend and local services.
in addition there are specific characteristics of android apps such as permission mechanisms software development kit sdk version compatibility or features of target devices that can lead to a failure.
while thisarxiv .09038v3 aug 2017esec fse september paderborn germanym.
linares v squez g. bavota m. tufano k. moran m. di penta c. vendome c. bernal c rdenas and d. poshyvanyk set of characteristics would demand a specialized set of mutation operators that can support mutation analysis and testing there is no available tool to date that supports mutation analysis testing of android apps and relatively few eight mutation operators have been proposed by the research community .
at the same time mutation tools for java apps such as pit and major lack any android specific mutation operators and present challenges for their use in this context resulting in common problems such as trivial mutants that always crash at runtime or difficulties automating mutant compilation into android packages apks .
paper contributions.
this paper aims to deal with the lack of i an extensive empirical evidence of the distribution of android faults ii a thorough catalog of android specific mutants and iii an analysis of the applicability of state of the art mutation tools on android apps.
we then propose a framework mdroid that relies on a catalog of mutation operators inspired by a taxonomy of bugs crashes specific for android apps and a profile of potential failure points automatically extracted from apks.
as a first step we produced a taxonomy of android faults by analyzing a statistically significant sample of candidate faults documented in i bug reports from open source apps ii bug fixing commits of open source apps iii stack overflow discussions iv the android exception hierarchy and apis potentially triggering such exceptions and v crashes bugs described in previous studies on android .
as a result we produced a taxonomy of types of faults grouped in categories four of which relate to android specific faults five to java related faults and five mixed categories figure .
then leveraging this fault taxonomy and focusing on android specific faults we devised a set of android mutation operators and implemented a platform to automatically seed of them.
finally we conducted a study comparing mdroid with other java and android specific mutation tools.
the study results indicate that mdroid as compared to existing competitive tools i is able to cover a larger number of bug types instances present in android app ii is highly complementary to the existing tools in terms of covered bug types and iii generates fewer trivial and stillborn mutants.
related work this section describes related literature and publicly available stateof the art tools on mutation testing.
we do not discuss the literature on testing android apps since proposing a novel approach for testing android apps is not the main goal of this work.
for further details about the concepts recent research and future work in the field of mutation testing one can refer to the survey by jia and harman .
mutation operators.
since the introduction of mutation testing in the 70s researchers have tried not only to define new mutation operators for different programming languages and paradigms e.g.
mutation operators have been defined for java and python but also for specific types of software like web applications and data intensive applications either to exercise their guis or to alter complex model defined input data .
the aim of our research which we share with prior work is to define customized mutation operators suitable for android applications by relying on a solid empirical foundation.to the best of our knowledge the closest work to ours is that of deng et al.
which defined eight mutant operators aimed at introducing faults in the essential programming elements of android apps i.e.
intents event handlers activity lifecycle and xml files e.g.
gui or permission files .
while we share with deng et al.
the need for defining specific operators for the key android programming elements our work builds upon it by i empirically analyzing the distribution of faults in android apps by manually tagging documents ii based on this distribution defining a mutant taxonomy complementing java mutants which includes a total of operators tailored for the android platform.
mutation testing effectiveness and efficiency.
several researchers have proposed approaches to measure the effectiveness and efficiency of mutation testing to devise strategies for reducing the effort required to generate effective mutant sets and to define theoretical frameworks .
such strategies can complement our work since in this paper we aim at defining new mutant operators for android on which effectiveness efficiency measures or minimization strategies can be applied.
mutation testing tools.
most of the available mutation testing tools are in the form of research prototypes.
concerning java representative tools are java jester major jumble pit and javalanche .
some of these tools operate on the java source code while others inject mutants in the bytecode.
for instance java jester and major generate the mutants by modifying the source code while jumble pit and javalanche perform the mutations in the bytecode.
when it comes to android apps there is only one available tool namely mudroid which performs the mutations at byte code level by generating one apk i.e.
one version of the mobile app for each mutant.
the tools for mutation testing can be also categorized according to the tool s capabilities e.g.
the availability of automatic tests selection .
a thorough comparison of these tools is out of the scope of this paper.
the interested reader can find more details on pit s website and in the paper by madeysky and radyk .
empirical studies on mutation testing.
daran and th venodfosse were the first to empirically compare mutants and real faults finding that the set of errors and failures they produced with a given test suite were similar.
andrews et al.
studied whether mutant generated faults and faults seeded by humans can be representative of real faults.
the study showed that carefully selected mutants are not easier to detect than real faults and can provide a good indication of test suite adequacy whereas human seeded faults can likely produce underestimates.
just et al.
correlated mutant detection and real fault detection using automatically and manually generated test suites.
they found that these two variables exhibit a statistically significant correlation.
at the same time their study pointed out that traditional java mutants need to be complemented by further operators as they found that around of faults were not related to mutants.
a taxonomy of crashes bugs in android apps to the best of our knowledge there is currently no i large scale study describing a taxonomy of bugs in android apps or ii comprehensive mutation framework including operators derived fromenabling mutation testing for android apps esec fse september paderborn germany such a taxonomy and targeting mobile specific faults the only framework available is the one with eight mutation operators proposed by deng et al.
.
in this section we describe a taxonomy of bugs in android apps derived from a large manual analysis of un structured sources.
our work is the first large scale data driven effort to design such a taxonomy.
our purpose is to extend complement previous studies analyzing bugs crashes in android apps and to provide a large taxonomy of bugs that can be used to design mutation operators.
in all the cases reported below the manually analyzed sets of sources randomly extracted represent a statistically significant sample with a confidence interval.
.
design to derive such a taxonomy we manually analyzed six different sources of information described below bug reports of android open source apps .
bug reports are the most obvious source to mine in order to identify typical bugs affecting android apps.
we mined the issue trackers of open source android apps hosted on github.
such apps have been identified by locally cloning all java projects identified through github s api and searching for projects with anandroidmanifest.xml file a requirement for android apps in the top level directory.
we then removed forked projects to avoid duplicated apps and filtered projects that did not have a single star or watcher to avoid abandoned apps.
we utilized a web crawler to mine the github issue trackers.
to be able to analyze the bug cause we only selected closed issues i.e.
those having a fix that can be inspected having bug as type.
overall we collected issues from which we randomly sampled for manual inspection.
bug fixing commits of android open source apps .
android apps are often developed by very small teams .
thus it is possible that some bugs are not documented in issue trackers but quickly discussed by the developers and then directly fixed.
this might be particularly true for bugs having a straightforward solution.
thus we also mined the versioning system of the same android apps considered for the bug reports by looking for bug fixing commits not related to any of the bugs considered in the previous point i.e.
the ones documented in the issue tracker .
with the cloned repositories we utilized the gitcommand line utility to extract the commit notes and matched the ones containing lexical patterns indicating bug fixing activities e.g.
fix issue fixed bug similarly to the approach proposed by fischer et al.
.
by exploiting this procedure we collected commits from which we randomly selected a statistically significant sample of commits for manual inspection.
android related stack overflow so discussions .
it is not unusual for developers to ask help on so for bugs they are experiencing and having difficulty fixing .
thus mining so discussions could provide additional hints on the types of bugs experienced by android developers.
to this aim we collected all discussions tagged android from so.
then we randomly extracted a statistically significant sample of of them for the manual analysis.
the exception hierarchy of the android apis .
uncaught exceptions and statements throwing exceptions are a major sourceof faults in android apps .
we automatically crawled the official android developer javadoc guide to extract the exception hierarchy and api methods throwing exceptions.
we collected items from which we sampled of them for manual analysis.
crashes bugs described in previous studies on android apps .
papers related to android testing1were analyzed by looking for crashes bugs reported in the papers.
for each identified bug we kept track of the following information app version bug id bug description bug url.
when we were not able to identify some of this information we contacted the paper s authors.
in the papers a total of bugs were mentioned reported however we were able in some cases with the authors help to identify the app and the bug descriptions for only bugs issues from nine papers .
given the limited number in this case we considered all of them in our manual analysis.
reviews posted by users of android apps on the google play store .
app store reviews have been identified as a prominent source of bugs and crashes in mobile apps .
however only a reduced set of reviews are in fact informative and useful for developers .
therefore to automatically detect informative reviews reporting bugs and crashes we leverage clap the tool developed by villarroel et al.
to automatically identify the bug reporting reviews.
such a tool has been shown to have a precision of in identifying this specific type of review.
we ran clap on the android user reviews dataset made available by chen et al.
.
this dataset reports user reviews for multiple releases of 21k apps in which clap identified reviews as bug reporting.
our statistically significant sample included reviews that we analyzed.
the data collected from the six sources listed above was manually analyzed by the eight authors following a procedure inspired by open coding .
in particular the documents e.g.
bug reports user reviews etc.
to manually validate were equally and randomly distributed among the authors making sure that each document was classified by two authors.
the goal of the process was to identify the exact reason behind the bug and to define a tag e.g.
null gps position describing such a reason.
thus when inspecting a bug report we did not limit our analysis to the reading of the bug description but we analyzed i the whole discussion performed by the developers ii the commit message related to the bug fixing and iii the patch used to fix the bug i.e.
source code diff .
the tagging process was supported by a web application that we developed to classify the documents i.e.
to describe the reason behind the bug and to solve conflicts between the authors.
each author independently tagged the documents assigned to him by defining a tag describing the cause behind a bug.
every time the authors had to tag a document the web application also shows the list of tags created so far allowing the tagger to select one of the already defined tags.
although in principle this is against the notion of open coding in a context like the one encountered in this work where the number of possible tags i.e.
cause behind the bug is extremely high such a choice helps using consistent naming and does not introduce a substantial bias.
1the complete list of papers is provided with our online appendix .esec fse september paderborn germanym.
linares v squez g. bavota m. tufano k. moran m. di penta c. vendome c. bernal c rdenas and d. poshyvanyk in cases for which there was no agreement between the two evaluators of the classified documents the document was automatically assigned to an additional evaluator.
the process was iterated until all the documents were classified by the absolute majority of the evaluators with the same tag.
when there was no agreement after all eight authors tagged the same document e.g.
four of them used the tag t1and the other four the tag t2 two of the authors manually analyzed these cases in order to solve the conflict and define the most appropriate tag to assign this happened for of the classified documents .
it is important to note that the web application did not consider documents tagged as false positive e.g.
a bug report that does not report an actual bug in an android app in the count of the documents manually analyzed.
this means that for example to reach the bug reports to manually analyze and tag we had to analyze bug reports since were tagged as false positives .
it is important to point out that during the tagging we discovered that for user reviews except for very few cases it was impossible without internal knowledge of an app s source code to infer the likely cause of the failure fault by only relying on what was described in the user review.
for this reason we decided to discard user reviews from our analysis and this left us with documents to manually analyze.
after having manually tagged all the documents overall additional documents since false positives were encountered in the tagging process all the authors met online to refine the identified tags by merging similar ones and splitting generic ones when needed.
also in order to build the fault taxonomy the identified tags were clustered in cohesive groups at two different levels of abstraction i.e.
categories and subcategories.
again the grouping was performed over multiple iterations in which tags were moved across categories and categories merged split.
finally the output of this step was i a taxonomy of representative bugs for android apps and ii the assignment of the analyzed documents to a specific tag describing the reason behind the bug reported in the document.
.
the defined taxonomy figure depicts the taxonomy that we obtained through the manual coding.
the black rectangle in the bottom right part of figure reports the number of documents tagged as false positive or as unclear .
the other rectangles marked with the android and or with the java logo represent the high level categories that we identified.
categories marked with the android logo e.g.
activities and intents group together android specific bugs while those marked with the java logo e.g.
collections and strings group bugs that could affect any java application.
both symbols together indicate categories featuring both android specific and java related bugs see e.g.
i o .
the number reported in square brackets indicates the bug instances from the manually classified sample belonging to each category.
inner rectangles when present represent sub categories e.g.
responsiveness battery drain innon functional requirements .
finally the most fine grained levels represented as lighter text describe the specific type of faults as labeled using our manually defined tags e.g.
theinvalid resource id tag under the sub category resources in turn part of the android programming category.
the analysis of figure allows to note that we were able to classify the faults reported in documents e.g.
bug reports commits etc.
.
this number is obtained by subtracting from the tagged documents the tagged as false positives and the tagged as unclear .
of these are grouped in categories only reporting android related bugs.
this means that more than one fourth of the bugs present in android apps are specific of this architecture and not shared with other types of java systems.
also this percentage clearly represents an underestimation.
indeed android specific bugs are also present in the previously mentioned mixed categories e.g.
innon functional requirements out of the instances present in the responsiveness battery drain subcategory are android specific all but performance unnecessary computation .
from a more detailed count after including also the android specific bugs in the mixed categories we estimated that of the identified bugs are android specific.
as expected several bugs are related to simple java programming .
this holds for of the identified bugs .
take away.
over one third of the bugs we identified with manual inspection are android specific.
this highlights the importance of having testing instruments such as mutation operators tailored for such a specific type of software.
at the same time of the bugs that are typical of any java application confirm the importance of also considering standard testing tools developed for java including mutation operators when performing verification and validation activities of android apps.
mutation operators for android given the taxonomy of faults in android apps and the set of available operators widely used for java applications a catalog of androidspecific mutation operators should i complement the classic java operators ii be representative of the faults exhibited by android apps iii reduce the rate of still born and trivial mutants and iv consider faults that can be simulated by modifying statements elements in the app source code and resources e.g.
thestrings.xml file .
the last condition is based on the fact that some faults cannot be simulated by changing the source code like in the case of device specific bugs or bugs related to the api and third party libraries.
following the aforementioned conditions we defined a set of operators trying to cover as many fault categories as possible out of the categories in figure and complementing the available java mutation operators.
the reasons for not including operators from the other four categories are api libraries bugs in this category are related to api library issues and api misuses.
the former will require applying operators to the apis the latter requires a deeper analysis of the specific api usage patterns inducing the bugs collections strings most of the bugs in this category can be induced with classic java mutation operators device emulator because this type of bug is device emulator specific their implementation is out of the scope of source code mutations multi threading the detection of the places for applying the corresponding mutations is not trivial therefore this category will be considered in future work.enabling mutation testing for android apps esec fse september paderborn germany activities and intents android programming api and libraries back end services collections and strings connectivity data objects parsing and format database device emulator general programming gui i o non functional requirements threading invalid data uri invalid activity name activitynotfoundexception invalid intent issues with manifest file invalid activity path in manifest missing activity definition in manifest bad practices api misuse improper call activity methods errors implementing activity lifecycle invalid context used for intent call in wrong activity lifecycle method other bug in intent implementation issues in oncreate methods invalid data uri invalid gps location invalid id in findview package name not found issues with app s folder structure android app folder structure executable command not in right folder issues with manifest file android app permissions issues with high screen resolution other issues with peripherals ports controller quirk on android games resting value of analog channel bad practices argument object is not parcelable component decl.
before call setcontentview declaring loader fragment inside the fragment missing override isvalidfragment method multiple instantiation of a resource opengl issues parcelable not implement for intent call service unbinding is missing system service invoked before creating activity wake lock misuse wakelock on wifi connection 65k methods limitation in a single dex file resources invalid drawable invalid path to resources invalid resource id missing string in resources folder resources.notfoundexception wrong version number of obb file other call restricted method in accessibility service google api key configuration setup invalid application package using context.mode private to open file issues with preferences issues with timers miss return in listener event implementation stale data in app timeout values for location services running out of loopback devices errors in managing the apps fragments internationalization unregistered receivers errors missing 3g interfaces state not saved app change and fault proneness generic api bug impact of api change operation on deprecated api device emulator with different api android compatibility apis build.version.sdk int unavailable in andr.
x.y image viewer bug in android x.y and below invalid tpl version invalid lower sdk version unsupported operation at run time bad practices api misuse general api misuse bluetooth api misuse camera web api misuse other errors with api library linking meta data tag for play services conflicts between libraries library bug authentication invalid auth token for back end service invalid certificate for back end service invalid data uri return from back end service not well formed special characters in http post other back end service not available returns null error while invoking back end service size related miss check for indexoutofboundexception operation on empty string issues with collections size operations on empty collections other arraystoreexception missing implementation of comparable accessing typedarray already recycled invalid operation on collection invalid string comparison in condition udp bypass smtpsendfailedexception authent.
failure network connection is off lost data loss in network operations http request issue httpclient usage network errors during authentication using infinite loop to check wifi connection player crashes on slow connection network timeout sipexception voip missing checks missing null check null uninitialized object null parameter nullpointerexception general uri url error parsing url in html website invalid uri used internally invalid uri provided by the user url unsupportedencodingexception xml related invalid sax transformer configuration saxexception xml format error xmlpullparserexception domexception data parsing errors numeric data numberformatexception parsing numeric values other dataformatexception json parsing errors invalid user input sql related db table column not found sql injection invalid field type retrieval query syntax error cursor closing null empty cursor issues when using db cursors other database file cannot be opened bug in database access on sd card database locked wrong database version code database connection error bug in database descriptor device android rom specific issues emulator specific issues keyboard not showing up in webview directories space missing in filesystem device rotation bugs in application logic invalid parameter error in numerical operations classcastexception genericsignatureformaterror missing precondition check empty constructors are missed errors implementing inner class override method missing super not called date issues error in loop limit exception error handling invalid constant missing break in switch syntax error regex error wrong relational operator uncaught exception error in console command invoked from app issues executing telnet commands data race bug in loading resources illegalstateexception components and views component with wrong dimensions invalid component view focus text in input label view disappears view component is not displayed component with wrong fonts style wrong text in view component issues in component animation findviewbyid returns null issues with manifest file button should not be clickable component undefined in xml layout files layout issues in layout files visual appearance layout issues unsupported theme bad practices viewholder pattern is not used improper call to getview inappropriate use of listview inappropriate use of viewpager inflating too many views large number of fragments in the app setcontent before content view is set message dialog error messages are not descriptive notification warning message missing notification warning message re appear other issues in gui logic general multi line text selection is not allowed bug in gui listener bug in webviewclient listener dismiss progress dialog before activity ends gui refresh issue tab is missing listener wrong onclicklistener fragm.
without implement.
of onviewcreated fragment not attached to activity visual appearance data is not listed in the right sorting order showing data in wrong format texture error invalid colors buffer buffer overflow bufferunderflowexception shortbufferexception mutation operation on non mutable buffer invalidmarkexception channel socket connection asynchronouscloseexception closedchannelexception errnoexception nonwritablechannelexception socketexception file file i o error file metadata issue file permissions operation with invalid file using symbolic link in backup issue creating file folder in device system filenotfoundexception invalid file path streams closing unverified writer connect pipedwriter to closed connected reader file operation on closed reader file operation on closed stream scanner keyexception release stream without verifying if still busy next token cannot translate to expected type flush of decoder at the end of the input operations on closed formatter memory oom canvas texture size oom general oom large arrays oom large bitmap oom loading too many images oom resizing multiple images oom saving json to sharedpreferences uncaught oom exception responsiveness battery drain expensive operation in main thread gui lags anr unnecessary computation in handler performance lengthy operation creating db performance unnecessary computation gui updated unnecessarily often lengthy operations on background thread network request in the gui thread security keychainexception privilegedactionexception securityexception invalid signed public key callback message not removed from handler data race threads synchronization gui operation out of main thread inappropriate use of threads async tasks instantiating handler without looper synchronized access to methods wrong gui update from async task wrong gui update from thread wrong handler import bug in threading implementation runnable does not stop invalid operation on asynktaskloader invalid operation on interrupted thread invalid operation on phaser set thread as deamon when it already runs media bad call of syncparams.getaudioadjustmode flush on initialized player getting token from closed media browser discarded false positive unclear images failed binder transaction bitmaps images without default dimensions inducing gc operations because of images large bitmaps persisting images as strings in db resizing images in gui thread figure the defined taxonomy of android bugs.esec fse september paderborn germanym.
linares v squez g. bavota m. tufano k. moran m. di penta c. vendome c. bernal c rdenas and d. poshyvanyk table proposed mutation operators.
the table lists the operator names detection strategy ast or text ual the fault category activity i ntents a ndroid p rogramming b ack e nd services c onnectivity d ata d atabase g eneral p rogramming gui i o non f unctional requirements and a brief operator description.
the operators indicated with are not implemented in mdroid yet.
mutation operator det.
cat.
description activitynotdefined text a i delete an activity android name activity entry in the manifest file differentactivityintentdefinition ast a i replace the activity.class argument in an intent instantiation invalidactivityname text a i randomly insert typos in the path of an activity defined in the manifest file invalidkeyintentputextra ast a i randomly generate a different key in an intent.putextra key value call invalidlabel text a i replace the attribute android label in the manifest file with a random string nullintent ast a i replace an intent instantiation with null nullvalueintentputextra ast a i replace the value argument in an intent.putextra key value call with new parcelable wrongmainactivity text a i randomly replace the main activity definition with a different activity missingpermissionmanifest text ap select and remove an uses permission entry in the manifest file notparcelable ast ap select a parcelable class remove implements parcelable and the override annotations nullgpslocation ast ap inject a null gps location in the location services sdkversion text ap randomly mutate the integer values in the sdkversion related attributes wrongstringresource text ap select a string entry in res values strings.xml file and mutate the string value nullbackendservicereturn ast bes assign null to a response variable from a back end service bluetoothadapteralwaysenabled ast c replace a bluetoothadapter.isenabled call with tru nullbluetoothadapter ast c replace a bluetoothadapter instance with null invaliduri ast d if uris are used internally randomly mutate the uris closingnullcursor ast db assign a cursor to null before it is closed invalidindexqueryparameter ast db randomly modify indexes order of query parameters invalidsqlquery ast db randomly mutate a sql query invaliddate ast gp set a random date to a date object invalidmethodcallargument ast gp randomly mutate a method call argument of a basic type notserializable ast gp select a serializable class remove implements serializable nullmethodcallargument ast gp randomly set null to a method call argument buggyguilistener ast gui delete action implemented in a gui listener findviewbyidreturnsnull ast gui assign a variable returned by activity.findviewbyid to null invalidcolor text gui randomly change colors in layout files invalididfindview ast gui replace the id argument in an activitity.findviewbyid call invalidviewfocus ast gu irandomly focus a gui component viewcomponentnotvisible ast gui set visible attribute from a view to false invalidfilepath ast i o randomly mutate paths to files nullinputstream ast i o assign an input stream e.g.
reader to null before it is closed nulloutputstream ast i o assign an output stream e.g.
writer to null before it is closed lengthybackendservice ast nfr inject large delay right after a call to a back end service lengthyguicreation ast nfr insert a long delay i.e.
thread.sleep .. in the gui creation thread lengthyguilistener ast nfr insert a long delay i.e.
thread.sleep .. in the gui listener thread longconnectiontimeout ast nfr increase the time out of connections to back end services oomlargeimage ast nfr increase the size of bitmaps by explicitly setting large dimensions the list of defined mutation operators is provided in table and these operators were implemented in a tool named mdroid .
in the context of this paper we define a potential failure profile pfp that sipulates locations of the analyzed apps which can be source code statements xml tags or locations in other resource files that can be the source of a potential fault given the faults catalog from section .
consequently the pfp lists the locations where a mutation operator can be applied.
in order the extract the pfp mdroid statically analyzes the targeted mobile app looking for locations where the operators from table can be implemented.
the locations are detected automatically by parsing xml files or through ast based analysis for detecting the location of api calls.
given an automatically derived pfp for an app and the catalog of android specific operators mdroid generates a mutant for each location in the pfp.
mutants are initially generated as clones at source code level of the original app and then the clones are automatically compiled built into individual android packages apks .
note that each location in the pfp is related to a mutation operator.
therefore given a location entry in the pfp mdroid automatically detects the corresponding mutation operator and applies the mutation in the source code.
details of the detection rules and code transformations applied with each operator are provided in our replication package .it is worth noting that from our catalog of android specific operators only two operators differentactivityintentdefinition and missingpermissionmanifest overlap with the eight operators proposed by deng et al.
.
future work will be devoted to cover a larger number of fault categories and define implement a larger number of operators.
applying mutation testing operators to android apps thegoal of this study is to i understand and compare the applicability ofmdroid and other currently available mutation testing tools to android apps ii to understand the underlying reasons for mutants generated by these tools that cannot be considered useful for the mutant analysis purposes i.e.
mutants that do not compile or cannot be launched.
this study is conducted from the perspective of researchers interested in improving current tools and approaches for mutation testing in the context of mobile apps.
the study addresses the following research questions rq are the mutation operators available for java and android apps representative of real bugs in android apps?
rq what is the rate of stillborn mutants e.g.
those leading to failed compilations and trivial mutants e.g.
those leading to crashes on app launch produced by the studied tools when used with android apps?enabling mutation testing for android apps esec fse september paderborn germany rq what are the major causes for stillborn and trivial mutants produced by the mutation testing tools when applied to android apps?
to answer rq we measured the applicability of operators from seven mutation testing tools major pit java javalanche mudroid deng et al.
and mdroid in terms of their ability of representing real android apps faults documented in a sample of software artifacts not used to build the taxonomy presented in section .
to answer rq we used a representative subset of the aforementioned tools to generate mutants for open source android apps quantitatively and qualitatively examining the stillborn and trivial mutants generated by each tool.
finally to answer rq we manually analyzed the mutants and their crash outputs to qualitatively determine the reasons for trivial and stillborn mutants generated by each tool.
.
study context and data collection to answer rq we analyzed the complete list of mutation operators from the seven considered tools to investigate their ability to cover bugs described in artifacts2 exceptions hierarchy and api methods throwing exceptions bug fixing commits from github closed issues from github and questions from so .
such documents were randomly selected from the dataset built for the taxonomy definition see section .
by excluding the ones already tagged and used in the taxonomy.
the documents were manually analyzed by the eight authors using the same exact procedure previously described for the taxonomy building i.e.
two evaluators per document having the goal of tagging the type of bug described in the document conflicts solved by using a majority rule schema tagging process supported by a web app details in section .
.
we targeted the tagging of documents per evaluator overall documents considering eight evaluators and two evaluations per document .
however some of the authors tagged more documents leading to the considered documents.
note that we did not constrain the tagging of the bug type to the ones already present in our taxonomy figure the evaluations were free to include new types of previously unseen bugs.
we answer rq 1by reporting i the new bug types we identified in the tagging of the additional documents i.e.
the ones not present in our original taxonomy ii the coverage level ensured by each of the seven mutation tools measured as the percentage of bug types and bug instances identified in the documents covered by its operators.
we also analyze the complementarity of mdroid with respect to the existing tools.
concerning rq 2andrq we compare mdroid with two popular open source mutation testing tools major and pit which are available and can be tailored for android apps and with one context specific mutation testing tool for android called mudroid .
we chose these tools because of their diversity in terms of functionality and mutation operators their compatibility with java and their representativeness of tools working at different representation levels source code java bytecode and smali bytecode i.e.
android specific bytecode representation .
2with cover we mean the ability to generate a mutant simulating the presence of a give type of bug.to compare the applicability of each mutation tool we need a set of android apps that meet certain constraints i the source code of the apps must be available ii the apps should be representative of different categories and iii the apps should be compilable e.g.
including proper versions of the external libraries they depend upon .
for these reasons we use the androtest suite of apps which includes android apps from google play categories.
these apps have been previously used to study the design and implementation of automated testing tools for android and met the three above listed constraints.
the mutation testing tools exhibited issues in of the considered apps i.e.
the apps did not compile after injecting the faults.
thus in the end we considered subject apps in our study.
the list of considered apps as well as their source code is available in our replication package .
note that while major and pit are compatible with java applications they cannot be directly applied to android apps.
thus we wrote specific wrapper programs to perform the mutation the assembly of files and the compilation of the mutated apps into runnable android application packages i.e.
apks .
while the procedure used to generate and compile mutants varies for each tool the following general workflow was used in our study i generate mutants by operating on the original source byte smali code using all possible mutation operators ii compile or assemble the apks either using the ant dex2jar orbaksmali tools iii run all of the apps in a parallel testing architecture that utilizes android virtual devices avds iv collect data about the number of apps that crash on launch and the corresponding exceptions of these crashes which will be utilized for a manual qualitative analysis.
we refer readers to our replication package for the complete technical methodology used for each mutation tool .
to quantitatively assess the applicability and effectiveness of the considered mutation tools to android apps we used three metrics total number of generated mutants tngm stillborn mutants sm and trivial mutants tm .
in this paper we consider stillborn mutants as those that are syntactically incorrect to the point that the apk file cannot be compiled assembled and trivial mutants as those that are killed arbitrarily by nearly any test case.
if a mutant crashes upon launch we consider it as a trivial mutant.
another metric one might consider to evaluate the effectiveness of a mutation testing tool is the number of equivalent and redundant mutants the tool produces.
however in past work the identification of equivalent mutants has been proven to be an undecidable problem and both equivalent and redundant mutants require the existence of test suites not available for the androtest apps .
therefore this aspect is not studied in our work.
after generating the mutants apks using each tool we needed a viable methodology for launching all these mutants in a reasonable amount of time to determine the number of trivial mutants .
to accomplish this we relied on a parallel android execution architecture that we call the execution engine ee .
ee utilizes concurrently running instances of android virtual devices based on the android x86 project .
specifically we configured avds with the android x86 v4.
.
image a screen resolution of 1900x1200 and 1gb of ram to resemble the hardware configuration of a google nexus device.
we then concurrently instantiated these avds and launched each mutant identifying app crashes.esec fse september paderborn germanym.
linares v squez g. bavota m. tufano k. moran m. di penta c. vendome c. bernal c rdenas and d. poshyvanyk out of bug types covered by the bug taxonomy in figure .
out of the tagged bug instances are covered by one of the bug types in figure .
bug taxonomy coveragemutation tools coverage out of the bug types are not covered by any of the considered mutation tools.major pit mudroid mujava javalanche deng et al.
mdroid bug type coverage major pit mudroid mujava javalanche deng et al.
mdroid bug count coverage union of all tools but mdroid all tools u mdroid union of all tools but mdroid all tools u mdroid figure mutation tools and coverage of analyzed bugs.
.
results rq figure reports i the percentage of bug types identified during our manual tagging that are covered by the taxonomy of bugs we previously presented in figure top part of figure and ii the coverage in terms of bug types as well as of instances of tagged bugs ensured by each of the considered mutation tools bottom part .
the data shown in figure refers to the bug instances for which we were able to define the exact reason behind the bug this excludes the entities tagged as unclear and the identified as false positives .
of the bug types are covered in our taxonomy.
in particular we identified new categories of bugs that we did not encounter before in the definition of our taxonomy section .
examples of these categories full list in our replication package are issues with audio codecs improper implementation of sensors as activities and improper usage of the static modifier .
note that these categories just represent a minority of the bugs we analyzed accounting all together for a total of bugs of the bugs considered .
thus our bug taxonomy covers of the bug instances we found indicating a very good coverage.
moving to the bottom part of figure our first important finding highlights the limitations of the experimented mutation tools including mdroid in potentially unveiling the bugs subject of our study.
indeed for out of the bug types none of the considered tools is able to generate mutants simulating the bug.
this stresses the need for new and more powerful mutation tools tailored for mobile platforms.
for instance no tool is currently able to generate mutants covering the bug in webviewclient listener and thecomponents with wrong dimensions bug types.
when comparing the seven mutation tools considered in our study mdroid clearly stands out as the tool ensuring the highest coverage both in terms of bug types and bug instances.
in particular mutators generated by mdroid have the potential to unveil of the bug types and of the bug instances.
in comparison the best competitive tool i.e.
the catalog of mutants proposed by deng a stillborn mutants major mudroid mdroid b trivial mutants major pit mudroid mdroid c of mutants per app majorpitmudroidmdroid figure stillborn and trivial mutants generated per app.
et al.
covers of the bug types less as compared to mdroid and of the bug instances less as compared to mdroid .
also we observe that mdroid covers bug categories and as a consequence bug instances missed by all competitive tools.
indeed while the union of the six competitive tools covers of the bug types of the bug instances adding the mutation operators included in mdroid increases the percentage of covered bug types to of the bug instances .
examples of categories covered by mdroid and not by the competitive tools are android app permissions thanks to the missingpermissionmanifest operator and the findviewbyid returns null thanks to the findviewbyidreturnsnull operator.
finally we statistically compared the proportion of bug types and the number of bug instances covered by mdroid by all other techniques and by their combination using fisher s exact test and odds ratio or .
the results indicate that the odds of covering bug types using mdroid are .
times greater than other techniques although the difference is not statistically significant p value .
.
similarly the odds of discovering faults with mdroid are .
times greater than other techniques but the difference is not significant p value .
the odds of covering bug types using mdroid combined with other techniques are .
times greater than the other techniques alone with a statistically significant difference p value .
.
similarly the odds of discovering bugs using the combination of mdroid and other techniques are .
times greater than other techniques alone with a significant difference p value .
.
rq figure depicts the achieved results as percentage of a stillborn mutants sm and b trivial mutants tm generated by each tool on each app.
on average .6k and .5k mutants were generated by mdroid major pit and mudroid respectively for each app.
the larger number of mutants generated by pit is due in part to the larger number of mutation operators available for the tool.
the average percentage of stillborn mutants sm generated by mdroid major and mudroid over all the apps is .
.
and .
respectively while no sm are generated by pit figure 3a .
mdroid produces significantly lessenabling mutation testing for android apps esec fse september paderborn germany sm than major wilcoxon paired signed rank test p value .
adjusted with holm s correction cliff s d .
large and than mudroid adjusted p value .
cliff s d .
medium .
these differences across the tools are mainly due to the compilation assembly process they adopt during the mutation process.
pit works at java bytecode level and thus can avoid the sm problem at the risk of creating a larger number of tm.
however pit is the tool that required the highest effort to build a wrapper to make it compatible with android apps.
major works at the source code level and compiles the app in a traditional manner.
thus it is prone to sm and requires an overhead in terms of memory and cpu resources needed for generating the mutants.
finally mudroid operates on apks andsmali code reducing the computational cost of mutant generation but significantly increasing the chances of sm.
all four tools generated trivial mutants tm i.e.
mutants that crashed simply upon launching the app .
these instances place an unnecessary burden on the developer particularly in the context of mobile apps as they must be discarded from analysis.
the mean of the distribution of the percentage of tm over all apps for mdroid major pit and mudroid is .
.
.
and .
respectively figure 3b .
mdroid generates significantly less tm than mudroid wilcoxon paired signed rank test adjusted p value .
cliff s d .
large and than pit adjusted p value .
cliff s d .
large while there is no statistically significant difference with major adjusted p value .
.
while these percentages may appear small the raw values show that the tm can comprise a large set of instances for tools that can generate thousands of mutants per app.
for example for the translate app out of the mutants generated by pit were tm.
for the same app mudroid creates tm out of the it generates.
for the blokish app out of the mutants generated by major were tm.
conversely while mdroid may generate a smaller number of mutants per app this also leads to a smaller number of tm only in total across all apps.
this is due to the fact that mdroid generates a much smaller set of mutants that are specifically targeted towards emulating realfaults identified in our empirically derived taxonomy and are applied on specific locations detected by the pfp.
rq in terms of mutation operators causing the highest number of stillborn and tm we found that for major the literal value replacement lvr operator had the highest number of tm whereas the relational operator replacement ror had the highest number of sm.
it may seem surprising that ror generated many sm however we discovered that the reason was due to improper modifications of loop conditions.
for instance in the a2dp.vol app one mutant changed this loop for int i i cols i and replaced the condition i cols with false causing the compiler to throw an unreachable code error.
for pit the member variable mutator mvm is the one causing most of the tm for mudroid the unary operator insertion uoi operator has the highest number of sm although all the operators have relatively high failure rates and the relational value replacement rvr has the highest number of tm.
for mdroid the wrongstringresource operator had that highest number of sm whereas the findviewbyidreturnsnull operator had the highest number of tm.table number of generated stillborn and trivial mutants created by mdroid operators.
mutation operators gm sm tm wrongstringresource nullintent invalidkeyintentputextra nullvalueintentputextra invalididfindview findviewbyidreturnsnull activitynotdefined invalidactivityname differentactivityintentdefinition viewcomponentnotvisible missingpermissionmanifest invalidfilepath invalidlabel closingnullcursor lengthyguicreation buggyguilistener lengthyguilistener sdkversion nullinputstream wrongmainactivity invalidcolor nullouptutstream invaliddate invalidsqlquery notserializable nullbluetoothadapter lengthybackendservice nullbackendservicereturn notparcelable invalidindexqueryparameter oomlargeimage bluetoothadapteralwaysenabled invaliduri nullgpslocation longconnectiontimeout total to qualitatively investigate the causes behind the crashes three authors manually analyzed a randomly selected sample of crashed mutants per tool.
in this analysis the authors relied on information about the mutation i.e.
applied mutation operator and location and the generated stack trace.
major.
the reasons behind the crashing mutants generated by major mainly fall in two categories.
first mutants generated with the lvr operator that changes the value of a literal causing an app to crash.
this was the case for the wikipedia app when changing the in the invocation setcachemode params.getstring to .
this passed a wrong asset url to the method setcachemode thus crashing the app.
second the statement deletion std operator was responsible for app crashes especially when it deleted needed methods invocations.
a representative example is the deletion of invocations to methods of the superclass when overriding methods e.g.
when removing the super.ondestroy invocation from the ondestroy method of an activity .
this results in throwing of anandroid.util.supernotcalledexception .
other std mutations causing crashes involved deleting a statement initializing the main activity leading to a nullpointerexception .
mudroid.
this tool is the one exhibiting the highest percentage of stillborn and tm.
the most interesting finding of our qualitative analysis is that of the crashing mutants lead to the throwing of ajava.lang.verifyerror .
averifyerror occurs when android tries to load a class that while being syntactically correct refers to resources that are not available e.g.
wrong class paths .
in theesec fse september paderborn germanym.
linares v squez g. bavota m. tufano k. moran m. di penta c. vendome c. bernal c rdenas and d. poshyvanyk remaining of the cases several of the crashes were due to the inline constant replacement icr operator.
an example is the crash observed in the photostream app where the value has been replaced with in bitmap.compress bitmap.compressformat.png out .
since represents the quality of the compression its value must be bounded between and .
pit.
in this tool several of the manually analyzed crashes were due to i the rvr operator changing the return value of a method to null causing a nullpointerexception and ii removed method invocations causing issues similar to the ones described for major.
mdroid .
table lists the mutants generated by mdroid across all the systems information for the other tools is provided with our replication package .
the overall rate of sm is very low in mdroid and most failed compilations pertain to edge cases that would require a more robust static analysis approach to resolve.
for example the closingnullcursor operator has the highest total number of sm across all the apps with and some edge cases that trigger compilation errors involve cursors that have been declared final thus causing the reassignment to trigger the compilation error.
the small number of other sm are generally other edge cases and current limitations of mdroid can be found in our replication package with detailed documentation.
the three operators generating the highest number of tm are nullintent findviewbyidreturnsnull and invalididfindview .
the main reason for the nullintent tm are intents invoked by the main activity of an app i.e.
the activity loaded when the app starts .
intents are one of the fundamental components of android apps and function as asynchronous messengers that activate activities broadcast receivers and services.
one example of a trivial mutant is for the a2dp.vol app in which a bluetooth service inteneded to start up when the app is launched causes a nullpointerexception when opened due to nullintent operator.
to avoid cases like this more sophisticated static analysis could be performed to prevent mutations from affecting intents in an app s mainactivity.
the story is similar for the findviewviewbyidreturnsnull and invalididfindview operators tm will occur when views in the mainactivity of the app are set to null or reference invalid ids causing a crash on startup.
future improvements to the tool could avoid mutants to be seeded in components related to the mainactivity.
also it would be desirable to allow developers to choose the activities in which mutations should be injected.
summary of the rqs .mdroid outperformed the other six mutation tools by achieving the highest coverage both in terms of bug types and bug instances.
however the results show that androidspecific mutation operators should be combined with classic operators to generate mutants that are representative of real faults in mobile apps rq1 .mdroid generated the smallest rate of both stillborn and trivial mutants illustrating its immediate applicability to android apps.
major and mudroid generate stillborn mutants with the latter having a critical average rate of .
stillborn mutants per app rq2 .
all four tools generated a relatively low rate of trivial mutants with mudroid again being the worst with an .
average rate of trivial mutants rq3 .
our analysis shows that the pit tool is most applicable to android apps when evaluated in terms of the ratio between failed and generated mutants.
however mdroid is both practical and based on android specific operations implemented according to an empirically derived fault taxonomy of android apps.
threats to validity this section discusses the threats to validity of the work related to devising the fault taxonomy and carrying out the study reported in section .
threats to construct validity concern the relationship between theory and observation.
the main threat is related to how we assess and compare the performance of mutation tools i.e.
by covering the types and by their capability to limit stillborn and trivial mutants.
a further even more relevant evaluation would explore the extent to which different mutant taxonomies are able to support test case prioritization.
however this requires a more complex setting which we leave for our future work.
threats to internal validity concern factors internal to our settings that could have influenced our results.
this is in particular related to possible subjectiveness of mistakes in the tagging of section and for rq .
as explained we employed multiple taggers to mitigate such a threat.
threats to external validity concern the generalizability of our findings.
to maximize the generalizability of the fault taxonomy we have considered six different data sources.
however it is still possible that we could have missed some fault types available in sources we did not consider or due to our sampling methodology.
also we are aware that in our study results of rq 1are based on the new sample of data sources and results of rq 2on the set of apps considered .
conclusions although android apps rely on the java language as a programming platform they have specific elements that make the testing process different than other java applications.
in particular the type and distribution of faults exhibited by android apps may be very peculiar requiring in the context of mutation analysis specific operators.
in this paper we presented the first taxonomy of faults in android apps based on a manual analysis of software artifacts from six different sources.
the taxonomy is composed of categories containing types.
then based on the taxonomy we have defined a set of android specific mutation operators implemented in an infrastructure called mdroid to automatically seed mutations in android apps.
to validate the taxonomy and mdroid we conducted a comparative study with java mutation tools.
the study results show that mdroid operators are more representative of android faults than other catalogs of mutation operators including both java and android specific operators previously proposed.
also mdroid is able to outperform state of the art tools in terms of stillborn and trivial mutants.
the obtained results make our taxonomy and mdroid ready to be used and possibly extended by other researchers practitioners.
to this aim mdroid and the wrappers for using major and pit with android apps are available as open source projects .
future work will extend mdroid by implementing more operators and creating a framework for mutation analysiss.
also we plan to experiment with mdroid in the context of test case prioritization.