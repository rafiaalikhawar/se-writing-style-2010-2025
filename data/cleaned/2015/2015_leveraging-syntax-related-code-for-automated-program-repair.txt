leveraging syntax related code for automated program repair qi xin steven p. reiss department of computer science brown university providence ri usa fqx5 sprg cs.brown.edu abstract we present our automated program repair technique ssfix which leverages existing code from a code database that is syntax related to the context of a bug to produce patches for its repair.
given a faulty program and a fault exposing test suite ssfix does fault localization to identify suspicious statements that are likely to be faulty.
for each such statement ssfix identifies a code chunk or target chunk including the statement and its local context.
ssfix works on the target chunk to produce patches.
to do so it first performs syntactic code search to find candidate code chunks that are syntax related i.e.
structurally similar and conceptually related to the target chunk from a code database or codebase consisting of the local faulty program and an external code repository.
ssfix assumes the correct fix to be contained in the candidate chunks and it leverages each candidate chunk to produce patches for the target chunk.
to do so ssfix translates the candidate chunk by unifying the names used in the candidate chunk with those in the target chunk matches the chunk components expressions and statements between the translated candidate chunk and the target chunk and produces patches for the target chunk based on the syntactic differences that exist between the matched components and in the unmatched components.
ssfix finally validates the patched programs generated against the test suite and reports the first one that passes the test suite.
we evaluated ssfix on bugs in the defects4j bug dataset.
our results show that ssfix successfully repaired bugs with valid patches generated and that it outperformed five other repair techniques for java.
index terms automated program repair code search code transfer i. i ntroduction a typical automated program repair technique accepts as input a faulty program and a fault exposing test suite.
as output it produces patched programs that pass the test suite.
a significant fraction of current repair techniques adopt a searchbased approach they define a set of modification rules to generate a space of patches and search in the space for patches that are plausible i.e.
the corresponding patched programs pass the test suite .
a study by long and rinard shows that the search space though huge could be insufficient to contain a correct patch and the search space often contains hundreds of plausible but incorrect patches which could simply block the finding of a correct one.
within a hour time limit the state of the art repair techniques spr and prophet generated patches for less than bugs in a dataset containing bugs with more than of thefirst found patches being incorrect.
early repair techniques are shown to have poor performance as shows the majority of patches generated by genprog ae and rsrepair are incorrect.
to address the problem the study suggests leveraging repair information beyond the test suite to create a search space that is likely to contain a correct patch and is targeted so that the correct patch could be effectively identified.
one idea is to leverage existing code fragments to produce effective patches.
we call the code fragments that contain the correct forms of expressions statements etc.
and can be used for generating a correct patch the repair code fragments.
genprog assumes the faulty program itself contains the repair code fragments at the statement level for patch generation.
the study by barr et al.
has demonstrated the feasibility of this assumption.
if the repair code fragments may exist in the local program they may also exist elsewhere in many non local programs.
the study by sumi et al.
supports this assumption.
they found up to of the repair code fragments in the form of code lines can be obtained possibly with identifier renaming from both the local program and non local programs.
the study is based on the uci dataset containing java projects.
we believe it is more likely to find the repair code fragments for bug1repair in smaller granularity e.g.
at the expression level and from a larger code database e.g.
github which is huge and is still rapidly growing .
repair code fragments could possibly exist in the faulty program itself and or in non local programs.
then the problem is how to find and leverage such code fragments to produce patches.
one idea is to use semantic code search i.e.
finding code fragments that are likely to be semantically correct.
however semantic code search is often expensive and it may fail to find many repair code fragments that do not represent the correct implementation they may contain more functional features than the correct implementation does they may use different data types or side effect processing mechanisms etc.
but can be leveraged to produce a correct patch.
codephage cp and searchrepair are two repair techniques that use semantic code search.
cp s code search relies on code execution and it can only find code that can process the given inputs.
searchrepair uses symbolic execution to 1in this paper we use bug and fault interchangeably.
.
c ieeease urbana champaign il usa technical research660 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
encode program semantics as constraints.
symbolic execution however has limited expressive power for program semantics.
searchrepair s code search is based on constraint solving which is undecidable in general and is often expensive.
currently searchrepair was only shown to work for small c programs.
if semantic code search is still limited the natural question would be does syntactic code search work?
our paper answered this question.
we propose a novel repair technique ssfix which performs syntactic code search to find and leverage existing code fragments from a codebase which consists of the local faulty program and an external code repository to produce patches for bug repair.
we assume a repair code fragment that can be effectively leveraged for bug repair to be syntax related i.e.
structurally similar and conceptually related to the fault located part of the faulty program.
intuitively such a repair code fragment is likely to implement a coding task similar to what is implemented in the faulty code fragment e.g.
both as iterating a list of data items to look for certain values having similar names and implements it correctly.
compared to searchrepair and cp ssfix is not directly targeted at finding code fragments that are semantically correct.
instead ssfix uses a lightweight syntactic code search based on a boolean model and a tfidf vector space model to find syntax related code fragments where a repair code fragment is likely to exist.
given such a fault related code fragment as a candidate code chunk ssfix translates the code chunk by unifying the identifier names in it with those in the faulty code fragment the target code chunk matches the components between the two chunks and produces patches for the target chunk based on the syntactic differences that exist between the matched components and in the unmatched components.
for a candidate chunk that is syntax related to the target chunk the syntactic differences are small and the search space is largely reduced.
through experiments we demonstrated the feasibility of the assumption on which ssfix is built and the effectiveness of ssfix for bug repair.
in this paper we make the following contributions we developed a novel automated repair technique ssfix which performs syntactic code search to leverage existing code from a codebase to produce patches for bug repair.
ssfix is currently available at we evaluated ssfix on all the bugs in the defects4j dataset.
our results show that ssfix successfully repaired bugs with valid patches generated.
the median time for producing a patch is about minutes.
compared to five other repair techniques for java our results show that ssfix has a better performance.
ii.
o verview in this section we show an overview of ssfix and explain how it works with an example.
ssfix accepts as input a faulty program a fault exposing test suite and a codebase consisting of the faulty program and a code repository we used the1public static boolean issamelocaltime calendar cal1 calendar cal2 2if cal1 null cal2 null 3throw new illegalargumentexception the date must not be null 5return cal1.get calendar.millisecond cal2.get calendar.millisecond 6cal1.get calendar.second cal2.get calendar.second 7cal1.get calendar.minute cal2.get calendar.minute 8cal1.get calendar.hour cal2.get calendar.hour 9cal1.get calendar.day of year cal2.get calendar.day of year 10cal1.get calendar.year cal2.get calendar.year 11cal1.get calendar.era cal2.get calendar.era 12cal1.getclass cal2.getclass fig.
.
the faulty method of l21 the fault is in red merobase repository .
as output ssfix either produces a patched program that passes the test suite or nothing if it cannot find one within a given time budget.
ssfix goes through four stages to repair a bug fault localization code search patch generation and patch validation.
we use an example to go through the four stages.
the faulty method as shown in figure is from a faulty program bug id l21 in the defects4j bug dataset.
it accepts as parameters two calendar objects cal1 andcal2 and checks whether they represent the same time.
the fault is at line where the 12hour calendar field calendar.hour is used for comparing two local hours.
given two calendar objects whose hour fields are different e.g.
one is and the other is but all the other fields are identical the faulty program may treat them as identical although they represent different times one is early morning and one is late afternoon .
for bug repair the following modification should be made cal1.get calendar.hour cal2.get calendar.hour cal1.get calendar.hour of day cal2.get calendar.hour of day where the hour calendar field calendar.hour of day is used.
the modification is relatively simple but none of the repair tools that ssfix is compared to succeeded for this bug.
by leveraging existing code that is syntax related to the bug context ssfix successfully repaired the bug with the correct patch generated.
a. fault localization in the first stage ssfix employs the fault localization technique gzoltar version .
.
to identify a list of suspicious statements in the program that are likely to be faulty.
the statements in the list are ranked by their suspiciousness measured as scores from high to low.
for bug repair ssfix goes through the list each time it looks at one statement the target statement and works on generating patches for a local code area as a code chunk including the statement we will explain how to generate such a code chunk later .
currently ssfix can only produce patches that make local changes i.e.
within the local code chunk in the faulty program though this may involve modifying more than one statement.
note that if the faulty program crashed with a stack trace printed ssfix will first follow the stack trace to look at each statement in the stack trace first if the statement is from the faulty program.
gzoltar does not use the stack trace information to compute a statement s suspiciousness.
to repair a failure which causes the program to crash we assume the statements from the stack trace are more suspicious than the other statements in the faulty program.
the faulty return statement starting at line authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1gregoriancalendar calend new gregoriancalendar 2calend.settimeinmillis end.gettime 3if calstart.get calendar.hour of day calend.get calendar.
!hour of day calstart.get calendar.minute calend.get calendar.minute calstart.get calendar.second calend.get calendar.second calstart.get calendar.millisecond calend.get calendar.
!millisecond calstart.get calendar.hour of day calstart.get calendar.minute calstart.get calendar.second calstart.get calendar.millisecond start.before end 12return true fig.
.
a candidate code chunk retrieved from the merobase repository the fix expression is in purple .
the chunk s enclosing method isallday checks whether the two time values obtained by start.gettime not shown and end.gettime both as millisecond values represent the starting time of two days from of one day to of the next day .
the full class name of the chunk is org.compiere.util.timeutil.
in figure is the second statement ssfix looks at among all the suspicious ones.
b. code search given a target statement identified as suspicious ssfix goes through three steps to find syntax related code fragments from the codebase target chunk identification token extraction and candidate retrieval.
as the first step ssfix generates a code chunk tchunk including the statement itself and possibly its context.
ssfix then searches for code fragments in the codebase ascchunk s that are syntax related i.e.
structurally similar and conceptually related to tchunk .
atchunk to be used as the query for code search should not be too small e.g.
including only a simple statement as return x because it does not include enough context.
on the other hand it should also not be large.
the study by gabel and su shows that a code fragment with more than tokens can be too unique in general to have similar code fragments retrieved for code search at the repository level.
based on this result we develop a simple chunk generation algorithm algorithm to generate atchunk including the target statement and its local context if the statement is not too large to determine its size we use a threshold based on the loc of the statement .
for our example ssfix uses this algorithm to produce a tchunk with only the return statement included.
as the second and third steps ssfix extracts the structural k gram tokens and the conceptual tokens from tchunk and invokes the apache lucene search engine to do a document search to obtain a list of indexed code fragments treated as documents from the codebase.
the retrieved list of code fragments which we call the candidate code chunks orcchunk s are ranked from the ones that are the most syntax related to tchunk to the least measured by the scores computed by lucene s default tf idf model from high to low .
later ssfix goes through the list and leverages each cchunk to produce independent patches for tchunk .
more details can be found in section iii a. the retrieved cchunk shown in figure is what ssfix later uses to produce a correct patch for tchunk .
this cchunk is ranked no.
among all the retrieved chunks.c.
patch generation ssfix leverages a candidate chunk cchunk to produce patches for tchunk in three steps candidate translation component matching and modification.
tchunk andcchunk may use different identifier names for variables fields types and methods that are syntactically and semantically related.
for example the two chunks in figure and in figure use different names cal2 andcalend for a related variable.
as the first step ssfix translates cchunk if retrieved from a non local program by unifying the identifier names in cchunk with those that are syntactically related in tchunk .
without such a translation ssfix would often fail to directly use statements and expressions from cchunk to produce patches fortchunk the patched program could simply fail to compile for using unrecognized names.
we developed an heuristic algorithm algorithm which ssfix uses to match variables fields types and methods between tchunk andcchunk based on how they are used in the two chunks.
ssfix then renames the variables fields types and methods in cchunk to their matched counterparts in tchunk to achieve the translation.
for our example ssfix determines calstart to match cal1 andcalend to match cal2 based on pattern matched expressions like the following three pairs see section iii b1 for more details .
cal1.get calendar.millisecond cal2.get calendar.millisecond calstart.get calendar.millisecond calend.get calendar.millisecond cal1.get calendar.second cal2.get calendar.second calstart.get calendar.second calend.get calendar.second cal1.get calendar.minute cal2.get calendar.minute calstart.get calendar.minute calend.get calendar.minute ssfix creates a translated version of cchunk asrcchunk by renaming the two variables calstart andcalend to their respective matched ones cal1 andcal2 intchunk .
the translated chunk rcchunk may not represent the correct patch but may contain the correct forms of components expressions and statements to be used in tchunk or indirectly suggest a faulty statement in tchunk to be deleted for producing a correct patch.
instead of replacing tchunk withrcchunk at the chunk level for patch generation ssfix matches components that are syntactically related between the two chunks and produces patches based on the syntactic differences that exist between the matched components and in the unmatched components.
specifically ssfix uses a modified version of the tree matching algorithm used by changedistiller to do component matching and it modifies tchunk to produce patches using three types of operations replacement insertion and deletion see section iii b2 and section iii b3 .
for our example ssfix found the following pair of components and others from tchunk andrcchunk to match.
cal1.get calendar.hour cal2.get calendar.hour cal1.get calendar.hour of day cal2.get calendar.hour of day intchunk it then replaces the first component with the second from rcchunk to produce the correct patch.
d. patch validation for each cchunk ssfix produces a set of patches.
it filters away patches that are syntactically redundant and patches that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
have been tested earlier generated by other cchunk s .
ssfix next sorts the filtered patches based on the modification types and the modification sizes to make a correct patch likely to be found before an overfitting patch such a patched program can pass the test suite but does not actually or fully repair the bug .
more details can be found in section iii c. ssfix reports the first patched program that passes the test suite.
if no such program can be found ssfix looks at the next cchunk from the retrieved list and repeats the patch generation and patch validation processes.
for our example ssfix successfully found the correct patch after validating individual patched programs that failed the testing the majority of those simply failed the fault exposing test case .
it took ssfix less than seven minutes to find this patch.
iii.
m ethodology in this section we elaborate on the last three stages that ssfix takes for bug repair.
fault localization itself is a research field and is not the focus of this paper.
ssfix simply uses the approach described in section ii a to do fault localization.
a. code search the code search stage of ssfix starts with a target statement sidentified as suspicious in the first stage.
ssfix generates a local code chunk tchunk including sitself and possibly the local context of s. ssfix then extracts the structural and conceptual tokens from the text of tchunk .
ssfix treats the extracted tokens as a vector of terms and uses lucene s boolean model and its tf idf vector space model to find candidate code chunks cchunk s that are syntax related to tchunk from the codebase.
algorithm generating a local target code chunk input s th .
s target statement th loc we use output tchunk .a target code chunk function chunk gen s th tchunk fsg ifgetsize tchunk ththen return tchunk .
getsize returns the loc of a code chunk s0 get the parent statement of s ifs0exists then tchunk fs 0g ifgetsize tchunk ththen return tchunk s1 get the statement before sin its block s2 get the statement after sin its block ifboths1ands2exist then tchunk fs s s 2g ifgetsize tchunk ththen return tchunk else if s1exists but s2does not exist then tchunk fs sg ifgetsize tchunk ththen return tchunk else if s1does not exist but s2exists then tchunk fs s 2g ifgetsize tchunk ththen return tchunk else return tchunk chunk generation atchunk with some context of s included could provide information about what sintends to do with the semantics potentially common to a large amount of existing code fragments in the codebase.
although it is often necessary to include some context of s especially when sis too simple in its form as return x for example and does not contain enough semantics it can be a bad idea to include alarge context e.g.
a method that implements multiple tasks .
as the study shows for repository code search significant syntactic redundancies were observed for code containing only up to tokens or lines approximately .
a larger code fragment is likely to be too unique.
based on this observation we developed a simple algorithm chunkgen which generates a tchunk including only the local context of swith a chunksize threshold th loc specified.
as shown in algorithm if the size of sis equal to or larger than th ssfix simply produces a tchunk including sitself lines .
otherwise ssfix produces a tchunk including either the enclosing parent statement of sup to the declared method not inclusive if any exists lines or a maximum of sand its two neighboring statements lines as long as the size of tchunk is no larger than th.
the way ssfix generates cchunk s is similar for each java source file in the codebase ssfix looks at every method defined in every class defined in the file.
it extracts the following code fragments within the method as cchunk s every compound statement which contains children statements and every sequential three statements within each code block e.g.
a body block of a for statement .
note that for any compound statement which has a non block single statement as its body ssfix will create a new block as the body containing the statement.
also note that if a code block contains no more than three statements all the statements are then included in the chunk .
ssfix produces a cchunk using and to cover the two cases it produces a tchunk using the target statement s parent statement and the target statement itself plus its neighboring statements.
note that ssfix does not use any chunk size threshold to produce a cchunk .
this makes ssfix be able to find a cchunk that is smaller or larger than tchunk for statement deletion and insertion .
currently ssfix produces a relatively small tchunk with only the suspicious statement sand possibly its local context included used for both code search and patch generation.
our experiments show that this works reasonably well.
but it is still possible to use a larger tchunk including more than the local context of sto do code search possibly with different query weights put on different context levels to have a cchunk in a comparable size retrieved and later to find smaller chunks e.g.
using clone detection techniques like within the original two chunks for patch generation.
we consider exploring this as our future work.
token extraction given either tchunk orcchunk ssfix extracts the structural k gram tokens and the conceptual tokens from the text of the chunk.
for every generated cchunk in the codebase ssfix employs lucene to create an index for the extracted tokens to facilitate code search.
given tchunk ssfix searches in the codebase for cchunk s that have similar tokens using lucene s boolean model and its tf idf vector space model.
extracting the structural k gram tokens ssfix first tokenizes the text of a chunk and gets a list of tokens.
to mask names number constants and literals that are program specific ssfix symbolizes different types of tokens ssfix uses authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the symbol v for non jdk variables and fields t for non jdk non primitive types m for non jdk methods lb for boolean literals true orfalse ln for number constants and ls for string literals that contain whitespace characters e.g.
as an exceptional message .
ssfix does not symbolize jdk tokens primitive types character literals or string literals that do not contain whitespace characters since they are often semantics indicative.
we call the symbolized tokens the code pattern tokens and we call the string of these tokens concatenated by single spaces the code pattern.
ssfix next splits the list of code pattern tokens into sub lists by curly brackets and semicolons to avoid generating k grams that are not very interesting e.g.
a k gram that starts at the end of one statement but ends at the start of another .
finally ssfix concatenates with no space in between every sequential k we set k tokens within every sub list of tokens to get the structural k gram tokens.
note that if a sub list contains less than k tokens ssfix would produce a less than kgram token.
given a statement as str.charat e where charat is a jdk method ssfix splits the statement into a list of tokens symbolizes the tokens changing str to v and1to ln splits the symbolized list into a sublist of tokens by semicolon and finally gets a list of four 5gram tokens f v .charat ln .charat ln charat ln ln e g. extracting the conceptual tokens two chunks that are conceptually related often use common tokens such as time iterator or buffer .
ssfix extracts such conceptual tokens as follows ssfix first tokenizes the text of a chunk and gets a list of tokens containing java identifiers only.
for any token that is camel case or contains underscores or numbers ssfix splits the token into smaller tokens and appends them to the list.
ssfix finally changes each token in the list into lower case and eliminates any tokens whose string lengths are less than or greater than as well as the stop words and the java keywords.
for example the list of conceptual tokens for str.getchars strlen buffer size isf str getchars chars strlen str len buffer size g note that get is a stop word that is eliminated .
candidate retrieval for candidate retrieval ssfix invokes lucene s query search with the query tokens being the extracted tokens from tchunk2.
it uses lucene s default tf idf vector space model which uses lucene s practical scoring function defined in to retrieve cchunk s. the retrieval process ignores any cchunk whose the number of matched tokens the tokens that are matched with those in tchunk is less than n 8where nis the total number of tokens intchunk .
to do so ssfix uses lucene s boolean model.
for each tchunk ssfix obtains a list of cchunk s that have the highest relatedness scores ranked from high to low.
currently it only looks at the top at most cchunk s that are not syntactically redundant for bug repair.
2it is also possible to invoke lucene s query search twice using the structural tokens and the conceptual tokens independently and then merge the results but we did not experiment this.b.
patch generation in this stage ssfix leverages a candidate chunk cchunk to produce patches for tchunk in three steps candidate translation component matching and modification.
algorithm creating an identifier mapping input tchunk cchunk output imap .
idbind is an identifier binding imap empty cmap empty tcompts ccompts get the component lists of tchunk cchunk components visited in pre order matched compts match components between tcompts andccompts by code pattern equality for all tcompt ccompt matched compts do tptokens cptokens get the code pattern tokens of tcompt ccompt .
tptokens cptokens are two lists having identical elements for all tptoken cptoken tptokens cptokens at every list index do iftptoken andcptoken are both identifier symbols then tidbind get the identifier binding of tptoken cidbind get the identifier binding of cptoken if cidbind tidbind is an entry in cmap then c cmap.get cidbind tidbind cmap.add cidbind tidbind c else cmap.add cidbind tidbind for all cidbind fromcmap do tidbind get the mapped identifier with the max value of c tie breaking by the levenshtein similarity between identifier strings imap.add cidbind tidbind return imap candidate translation a candidate chunk cchunk and the target chunk tchunk may use different identifier names for variables fields types and methods that are syntactically and semantically related especially when they are not from the same program.
we developed an heuristic algorithm shown in algorithm to map variable field type and method identifiers appeared in cchunk to those in tchunk that are syntactically related and may thus be semantically related based on matching the code patterns of their contexts.
the code pattern used here is identical to what we defined in section iii a2 but with all non jdk identifiers number constants and literals symbolized to increase matching flexibility .
given a cchunk that is not from the local faulty program where tchunk is from ssfix uses the algorithm to match their identifiers and renames every identifier in cchunk which has a match as its matched identifier in tchunk to get a translated version of cchunk asrcchunk .
since a cchunk and a tchunk from the same faulty program use identifier names consistently ssfix does not create a translated version for such a cchunk .
algorithm accepts as input tchunk andcchunk .
it outputs an identifier mapping imap that maps an identifier that appears incchunk as a reference binding or a binding to an identifier that appears in tchunk also as a binding.
ssfix matches and renames all identifiers that have the same binding consistently.
the algorithm starts by collecting in pre order a list of components statements and expressions in the tree structure of the chunk for either tchunk orcchunk that are not number constants literals boolean null character andstring literals or identifiers line .
these components represent all the contexts of all the identifiers in the chunk.
the algorithm then matches the components line by comparing their code patterns.
two components can match iff their code authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
patterns as two strings are identical.
for every matched components whose code patterns are identical and thus share an identical list of code pattern tokens the algorithm obtains the two lists of code pattern tokens line .
at every index where the two code pattern tokens are both identifiers the algorithm gets the identifier bindings matches them and saves this match with a count in a map cmap lines .
finally the algorithm iterates cmap for each identifier binding in cchunk cidbind it finds its matched identifier binding in tchunk tidbind with the maximum matching count.
if there are more than one such matched tidbind s the algorithm breaks the ties by comparing the string similarity of the identifier bindings lines .
component matching ssfix matches components between tchunk andrcchunk to identify their syntactic differences at the component level.
later it leverages the syntactic differences that exist between the matched components and in the unmatched components to produce patches for tchunk .
ssfix extends the tree matching algorithm of changedistiller fig.
in to do component matching based on the component types structures and contents.
the original algorithm performs tree matching at the statement level and is used for code evolutionary analysis.
the algorithm used by ssfix follows its basic idea to match leaf nodes first using the match 1function and then inner nodes using the match function in a bottom up way.
we make changes to the original algorithm on the definitions of leaf and inner nodes node compatibility and node similarity.
specifically we define a leaf node to be either a simple statement which has no children statements or an expression that is not a number constant a literal or an identifier.
we define an inner node to be a compound statement that has children statements.
we give a new definition for the node compatibility the lfunction in as follows a leaf node is not compatible with an inner node two leaf nodes are compatible if a their node types are equal e.g.
both as return statements and b they follow the node type specific rules forarrayaccess orarraycreation the array types should be compatible i.e.
the array dimensions are equal and the element types are equal for classinstancecreation the class types should be identical for infixexpression postfixexpression or prefixexpression the expression operators should be identical for assignment the assignment operators should be identical and for methodinvocation the method names should be identical and two inner nodes are compatible if their node types are equal or they are both loop statements for while or do statements .
as for the node similarity metrics used in the match 1andmatch 2functions in we make two changes we decrease the values of the thresholds f andtand we ignore the bigram string similarity part for the similarity metric in match .
changedistiller was designed to match nodes that are highly similar for evolutionary analysis.
in our context we decrease the thresholds fandtto allow components that are syntactically related but are not highly similar to match.
currently ssfix uses 2forfand fortand it works reasonably well with these thresholds fortable i sub component replacement rules for certain types of matched components component rule if statements1.
replace condition .
replace then branch .
replace else branch .
combine conditions with .
combine conditions with jj for statements1.
replace initializers .
replace condition .
replace updaters .
replace initializers condition updaters .
replace body loop statements not both as for statements .
replace condition .
replace body switch statements1.
replace expression .
replace body try statements1.
replace try body .
replace catch clauses .
replace finally body synchronized statements1.
replace synchronized expression .
replace body return statements with boolean returned expressions .
combine the expressions with .
combine the expressions with jj catch clauses1.
replace caught exception .
replace body assignments infix expressions1.
replace left hand side .
replace operator .
replace right hand side method calls super method calls1.
replace caller expression .
replace method name .
replace arguments constructor calls i.e.
this ... .
replace arguments super constructor calls1.
replace caller expression .
replace arguments prefix postfix expressions1.
replace operator .
replace operand ssfix may produce multiple patches by replacing each individual argument of tcpt with the corresponding argument of ccpt in the same argument index.
this only happens when the two components have the same number of arguments.
our experiments.
we do not consider the similarity of two conditions as if conditions or loop conditions as a factor to match two compound statements as two inner nodes because a bug could make one condition dissimilar to the other.
in such case we still allow the two statements to match as long as they have similar children according to the dice coefficient similarity used in the match 2function in so that the faulty condition has a chance of being repaired.
modification in the final step of patch generation ssfix modifies tchunk based on the matched and unmatched components between tchunk andrcchunk to yield an initial set of patches using three types of modifications replacement insertion and deletion.
we next discuss each in turn.
replacement for every matched components tcpt ccpt where tcpt is a component from tchunk andccpt is a component from cchunk ssfix replaces tcpt withccpt and the sub components of tcpt with the sub components of ccpt to produce patches.
specifically ssfix first replaces tcpt with ccpt to produce a patch if tcpt is not syntactically identical to ccpt.
ssfix may do more replacements on the sub components oftcpt andccpt based on their types following the rules we created in table i. recall that if tcpt matches ccpt either they have the same component type or they are both loop statements.
for each row in table i there is more than one rule.
ssfix follows the rules to produce patches independently each time it follows one rule to produce one patch it would not produce a patch if the replacement makes no actual syntactic changes.
note that ssfix may make multiple changes using one replacement.
for example it may follow rule for loop statements to replace a loop body with another which may make changes to several statements within the body.
insertion deletion ssfix inserts an unmatched statement authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
component cstmt from rcchunk intchunk to produce a patch.
for any component cstmt in rcchunk ssfix first checks whether it is qualified for insertion i.e.
whether it is a statement that has no match in tchunk and whether it has no matched children statements.
if not qualified ssfix ignores the insertion of cstmt because the potential occurrence ofcstmt intchunk could lead to statement redundancy caused by itself or by its children statements.
if cstmt is qualified ssfix computes estimated positions where cstmt is likely to fit intchunk and later inserts cstmt at every estimated position to yield patches.
specifically ssfix first finds the two sibling statements of cstmt in its parent block as cslandcsh that are closest to cstmt and have matches.
ssfix gets their matched statements tslandtshintchunk and inserts cstmt at every position in between if they both exist and are from the same block .
otherwise if at least one of tslandtshexists ssfix inserts cstmt at every position after tslin its located block and or at every position before tsh in its located block to yield patches.
if neither tslnortshexists ssfix ignores the insertion for cstmt since there is no matching evidence that cstmt is needed.
for deletion ssfix deletes any statement component in tchunk that has no matched statement in rcchunk .
similar to insertion if the unmatched statement has matched children statements ssfix ignores its deletion.
c. patch validation ssfix leverages a cchunk retrieved from the codebase to produce a set of patches for tchunk .
in this stage ssfix first filters aways patches that are syntactically redundant and patches that have been tested earlier generated by other cchunk s next sorts the patches by the modification types and sizes then validates each patched program against the test suite and finally reports the first one if any that passes the test suite.
like every repair technique that uses a test suite as the correctness criterion for patch evaluation it is possible that ssfix produces an overfitting patched program that passes the test suite but does not actually or fully repair the bug.
studies have shown that a repair technique is more likely to produce an overfitting patch using deletion than using other types of modifications and a simple patch is less likely to be overfitting than a complex patch.
based on these results we created the following rules to rank two patches a patch generated by replacement or insertion always has a higher rank than a patch generated by deletion if there is a tie a patch with a smaller modification tree height has a higher rank and if there is still a tie a patch with a smaller edit distance has a higher rank.
we define a modification tree height of a patch to be the maximum heights of the tree structures of the modification related components cptandcpt0 for insertion or deletion if a component is null the height is .
we define an edit distance of a patch to be the edit distance between the content strings of cptandcpt0 if a component is null the content string is empty .
ssfix follows the rules to rank patches and does patch sorting.note that ssfix may produce hundreds of patches given a cchunk that is dissimilar to tchunk .
for efficiency ssfix only selects a maximum of the top sorted k we set k patches that it produced for tchunk using a cchunk for validation.
if a patched program compiles ssfix first tests it against the test case s that the original faulty program failed.
if the patched program succeeds ssfix then tests it against the test suite.
iv.
e mpirical evaluation to evaluate the performance of ssfix we used the defects4j bug dataset version .
.
which contains a set of real bugs.
we ask two research questions.
rq1 how many bugs can ssfix repair?
what is the performance of ssfix on repairing these bugs?
rq2 compared to other techniques how effective is ssfix?
we conducted two experiments to answer them.
we next show each experiment in turn.
a. rq1 we implemented ssfix and evaluated its performance on all real bugs in the defects4j bug dataset.
our results show that ssfix repaired bugs with valid patches generated.
the median time for generating a plausible patch is about minutes.
experimental setup a bug dataset the defects4j dataset consists of real bugs from five java projects jfreechart c closure compiler cl commons math m joda time t andcommons lang l .
each bug in the dataset is associated with a developer patch showing how the bug can be correctly repaired.
the dataset has been commonly used for evaluating an automated repair technique for java .
b ssfix s running setup our implementation of ssfix used the merobase repository which contains about .
million java source files or about million loc as the external code repository and five versions of the projects c8 cl14 l6 m33 and t4 as the local faulty programs3.
to avoid using a fixed version of a bug to produce patches in the code search stage ssfix ignores any candidate chunk cchunk retrieved from the codebase if the full class name ofcchunk s located class is the same as that of the target chunk s or tchunk s located class4and the signature of cchunk s enclosing method is the same as that of tchunk s method.5we ran ssfix to repair each bug within a time budget of minutes on machines with eight amd phenom tm ii processors and 8g memory.
3for each of the three bugs m53 m59 and m70 the fault s located class contains a repair statement.
the repair statement however is not contained in the class of m33 whose class name is identical to that of the fault s located class.
so we additionally indexed the fault s located class for each bug three classes in total .
4the commons lang the commons math projects may use either lang3 math3 orlang math as parts of their package names respectively.
we unified these name differences for comparing two class names.
5even so we still manually found in our initial experiments the two cchunk s for l43andl33 that ssfix used to yield patches are suspicious to be from the fixed versions of the two faulty programs.
we created a black list for the enclosing methods of those cchunk s. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii allplausible patches generated by ss fix project bugs time in minutes plausible valid correct sem syn cchunk rank cchunk locality tested patch min max med min max med local non local min max med jfreechart .
.
.
closure compiler .
.
.
commons math .
.
.
.
joda time .
.
.
.
commons lang .
.
.
.
total .
.
.
.
we manually compared a generated patch to the developer patch to determine its validity and correctness.
results table ii is a summary6of the repair performance of ssfix.
from left to right the table shows the project name and the number of bugs in the project the repairing time min max and median the number of bugs for which plausible patches were generated a patch is plausible if the patched program passes the test suite the number of valid patches generated we consider a patch to be valid if the patched program passes the test suite and does not introduce regressions in general the number of correct patches generated we consider a patch to be correct if it is semantically equivalent to the developer patch associated with the bug in a stricter case such a patch can be syntactically equivalent to the developer patch the ranks in min max and median from to of the candidate chunks used for generating the patches the numbers of chunks retrieved from the local project and from the external code repository and the number of failed patches ssfix created and tested against at least one test case before finding a plausible patch.
as shown ssfix produced plausible patches for bugs in total a patch is plausible if the patched program passes the test suite .
the running time in minutes for repairing these bugs ranges from .
to .
with the median being .
.
a plausible patch is produced and identified by ssfix automatically.
to determine whether a generated plausible patch does not introduce regressions and whether it is semantically correct in general we manually compared the patch with the corresponding developer patch contained in the defects4j dataset.
among the plausible patches generated for the bugs we determined patches to be valid.
among the valid patches we determined patches to be semantically equivalent to the developer patches associated with their repaired bugs and of the patches to be not only semantically but also syntactically equivalent to the corresponding developer patches.
in terms of passing the test suite without introducing regressions in general we determined patches to be valid though they are not semantically equivalent to the developer patches.
below is one such patch generated for the bug m57 double sum by developer float sum by ssfix int sum ssfix patched the program by changing the declared type of sum from inttofloat to avoid precision loss.
the patched program now passes the test suite.
although the patch is not semantically equivalent to the developer patch we consider it as 6the complete result can be found at we manually determined of the plausible patches to bedefective and thus overfitting they introduce regressions to their original programs and are thus invalid and incorrect.
for four of them ssfix deleted the expected program semantics.
for the remaining patches it is not easy for us to manually determine their validity since the patches are not syntactically equivalent or similar to the developer patches so we released them for other reviews.
all the plausible patches and the corresponding candidate chunks can be found under for each of the valid patches we provided an explanation as to why we believe it is valid correct.
ssfix failed bugs with no patches generated.
to understand the failures we manually examined the developer patches for all the bugs and found that there are complex bugs for which the correct patches are not within the search space of ssfix recall that ssfix can currently only repair relatively simple bugs by making modifications within a relatively small code chunk .
among the failed bugs there are such complex bugs for which ssfix cannot produce correct patches.
but note that ssfix did produce valid patches for of the complex bugs cl115 m30.
each such patch makes and only makes some but not all of the changes made by the developer patch and the corresponding patched program passes the test suite.
among the other simple bugs ssfix produced plausible patches for bugs and it failed bugs with no patches generated.
one challenge lies in the accuracy of fault localization.
we found gzoltar simply failed to identify the target faulty statements for bugs among the failed ones .
we also found there are bugs for which the suspicious ranks of the target statements are greater than with the median rank being and ssfix did not actually looked at any of these target statements under the current running setup.
another challenge lies in ssfix s code search ability in finding effective candidates.
the current way ssfix does code search is not effective for all cases.
the bug cl10 is one example.
ssfix produces a target chunk as shown below.
if recurse return allresultsmatch n may be string predicate return anyresultsmatch n may be string predicate else return maybestringhelper n since all the identifier names are locally defined by the faulty program ssfix creates a code pattern with all the names symbolized and extracts a list of structural tokens that are a little too general which roughly say that the code chunk contains an if statement and two method calls to be returned .
the extracted conceptual tokens together are a little too unique authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to be used for finding related candidate chunks in the codebase.
as a result ssfix failed to find candidate chunks that are truly syntax related from merobase.
the candidate chunks found from the local program however do not contain the correct expression to be used for bug repair.
so ssfix failed to repair the bug.
in the last part of section iii a1 we propose a way for improvement and consider to explore it as our future work.
in principle the ways ssfix uses to do candidate translation component matching and modification can also limit ssfix from producing a valid correct patch.
but we found these are not actual problems when a target statement is accurately located and an effective candidate chunk is found.
since ssfix uses a test suite as opposed to a formal specification as the correctness criterion for patch evaluation it can generate a defective patch which introduces regressions.
an inaccurate fault localization technique and an ineffective candidate could both lead to a defective patch being generated.
we actually found that it can be problematic to produce patches by deletion using a candidate chunk that is not very related to the target chunk.
ssfix produced four defective patches by deleting the non buggy statements.
b. rq2 we compared ssfix to five other repair techniques for java jgenprog jkali nopol version hdrepair and acs on the same dataset.
compared to these techniques our results show that ssfix has a better performance it produced larger numbers of patches that are valid and correct with the efficiency of producing a plausible patch being either comparable or better.
note that we did not compare ssfix to other repair techniques that are written for c e.g.
searchrepair codephage spr prophet and angelix or are not publicly available as of august e.g.
par .
experimental setup we ran jgenprog jkali nopol hdrepair and acs each to repair all the bugs in the defects4j dataset on machines that have the same configurations with the ones on which we ran ssfix.
the time budget for repairing a bug is two hours the same for ssfix .
since jgenprog and hdrepair use randomness for patch generation we ran the tool either jgenprog or hdrepair in three trials7to repair a bug and we considered the tool to have a valid correct patch generated if it did so in at least one trial.
for the other three techniques we ran them each only in one trial to repair each bug.
results table iii shows the repairing time min max and median and the numbers of plausible valid and correct patches generated by all the six techniques.
figure shows the ids of the bugs for which the techniques produced valid patches.
our results show that ssfix significantly outperforms jgenprog jkali and nopol ssfix produced many more valid 7note that our experiment was very expensive and we only ran jgenprog hdrepair in three trials.
we believe our current running setup is sufficient to show that ssfix outperforms the two tools the number of valid and correct patches generated by ssfix in one trial is about four times larger than the number of those patches generated by jgenprog or hdrepair in three trials.table iii allplausible patches generated by ss fix and fiveother techniques seefigure 3for the specific bugs for which valid patches were generated by the six techniques tooltime in minutes plausible valid correct min max med sem syn ssfix .
.
.
jgenprog .
.
.
jkali .
.
.
nopol .
.
.
hdrepair .
.
.
23y 10y acs .
.
.
23z 18z the numbers in parentheses in the 5th and 7th columns are copied from the results reported in where the reported results in are based on four of the five projects except the closure compiler project and the reported result in is based on all the five projects .
our results not in parentheses are based on all the five projects.
ythe results reported in are based on a repair experiment on selected bugs using a fault localization technique performed at the method level with a faulty method known in advance .
for each bug the authors of looked for a correct patch within the top generated patches if any .
our results are based on all the bugs.
the fault localization was performed at the project level.
for a consistent comparison we only checked the validity and correctness of the first generated patch if any .
zin our experimental setup we found that acs available at took longer than what is reported in the paper to produce a plausible patch and we did not reproduce many correct patches reported in .
ssfix m50 m53 m70 m75 l51 m94 m79 c1 cl14 l43 l59 c20 c24 m30 l21 l6 cl115 m33 l33 m80 m57 m41 m59 jgenprog jkali hdrepair l24 m85 t15 acs nopol empty fig.
.
valid patches generated by different techniques patches using either less or comparable time than these techniques did.
all the valid patches generated by these techniques were actually generated by ssfix.
jgenprog cannot practically produce a correct patch when the repair statement does not exist in the faulty program.
it deletes a statement in high probability and this often leads to a defective patch generated.
jkali can only delete a statement so it is not expected to produce any correct patch that does not involve statement deletion.
nopol uses a conditional synthesis technique to produce patches related to an if statement.
our results show that it is prone to produce a patch with a synthesized condition being too constrained or too loose.
an example m85 is shown below.
if fa fb .
... the faulty statement if fa fb .
... the correct patch if fa fb ... nopol s patch although nopol created a patch by constraining the original if condition to make the test suite pass it is overly constrained and would not be correct in general.
hdrepair is an extension of genprog.
it uses more modification operations than genprog does but leverages the bug fix patterns mined from existing bug fixing instances to make the patch search process guided.
however our results show that hdrepair s bug fix pattern driven algorithm is not truly effective.
compared to jgenprog it only produced two more valid patches with the median repairing time being longer.
overall ssfix outperforms hdrepair.
but hdrepair did produce three authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
valid patches that ssfix failed to produce.
for example to produce one of such patches for m75 hdrepair reused a statement return getpct long.valueof v from the class of the faulty statement return getcumpct comparable ?
v and applied a modification to replace getcumpct with getpct.
ssfix did not find the repair statement since its local context is not similar to that of the faulty statement.
acs is a recently developed technique that also uses condition synthesis to repair a program.
it leverages techniques of test case analysis document analysis dependency analysis and predicate mining to produce an if statement with a synthesized condition that is likely to be correct.
our results show that acs generated valid patches for three bugs that none of the other techniques successfully repaired.
m85 is an example that acs successfully repaired by synthesizing a correct if condition as fa fb .
!
fa fb .
it first identified a target expression fa fb then performed keyword search over the github repositories to find relevant predicates and produced the expression !
fa fb .
and it finally produced the correct condition by conjoining this expression with fa fb .
.
through using relevant expressions from github acs synthesized a correct condition that is neither too constrained nor too loose.
although acs produced three valid patches that no other techniques produced our results show that ssfix still outperforms acs in terms of the number of valid patches generated and the repairing time.
since acs is designed to repair bugs related to if conditions it is not easy for acs to produce a direct valid patch for bugs like l59 for which ssfix produced a correct patch by replacing a method argument strlen with another width.
c. discussion in our experiments we referred to the developer patch associated with a bug to manually determine the validity and correctness of a patch generated by a repair technique.
there can be in general other ways to define the validity and correctness of a patch.
for a fraction of plausible patches generated by ssfix and other techniques we cannot easily determine their validity or correctness but it is possible that some of the generated patches are valid and correct even though they are not syntactically equivalent or similar to the developer patches.
even so we do not believe there can be a significant fraction of valid correct patches among such plausible ones and we released all the plausible patches at though possibly biased a manual evaluation method like ours is commonly used to evaluate the quality of patches generated by current automated repair techniques.
the problem however can be mitigated through using a held out test suite to quantify overfitting and or other approaches that can identify overfitting patches e.g.
.
the repair performance of ssfix significantly depends on the performance of code search and we think there is still room for ssfix s code search to be improved e.g.
through using the proposed solution we mentioned in the last part of section iii a1 and or using a larger code database .
with a bettercode search ssfix can be more efficient and can produce more valid correct patches and less overfitting patches.
to produce less overfitting patches ssfix may also be combined with techniques like .
v. r elated work ssfix leverages existing code fragments to produce patches for bug repair.
searchrepair and codephage are two repair techniques that are built on a similar idea.
the main difference between ssfix and the two techniques lies in how they perform code search to find code for bug repair.
ssfix uses syntactic code search while the two techniques use semantic code search based on symbolic execution and constraint solving and program execution respectively .
ssfix is related to a branch of automated repair techniques that work by first defining a set of modification rules to have a search space of patches created and then using different ways to search in the space for patches that are likely to be correct.
relifix is one of the techniques that is related to ssfix in that it produces patches based on the changed statements between two programs.
however relifix only targets on repairing regression errors and it does not do cross project code search code translation or component matching.
relifix uses more modification operations than ssfix does to produce patches.
it uses randomness for patch generation while ssfix does not.
another branch of repair techniques leverage synthesis techniques to produce patches.
spr is a staged repair technique combines using modification operations and using condition synthesis to generate patches.
prophet is built upon spr and uses a probabilistic model for patch ranking.
ssfix is related to these techniques but does not use any synthesis techniques to produce patches.
ssfix is also related to many repairing techniques using formal specifications e.g.
focusing on specific fixing tasks e.g.
and providing suggestions and feedbacks e.g.
.
techniques like sydit lase r efazer and genesis can extract synthesize and infer code transformations for bug repair and for other purposes.
different from these techniques ssfix does not learn any transformations but directly leverages existing code from a database to produce patches for bug repair.
the way ssfix produces patches can be thought of as creating a hybrid of two pieces of code i.e.
the target and the candidate chunks of code .
ssfix is thus related to works that do code transfer or transplantation .
vi.
c onclusion in this paper we presented our automated repair technique ssfix which performs syntactic code search to find existing code from a code database that is syntax related to the context of a bug and further leverages such code to produce patches for bug repair.
our experiments have demonstrated the effectiveness of ssfix in repairing real bugs.
in the future we will look at using different code search techniques on a larger code database for a potential performance enhancement.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.