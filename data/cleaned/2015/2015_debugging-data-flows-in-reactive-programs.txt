debugging data flows in reactive programs herman banken delft university of technology delft the netherlands hermanb ch.tudelft.nlerik meijer delft university of technology delft the netherlands h.j.m.meijer tudelft.nlgeorgios gousios delft university of technology delft the netherlands g.gousios tudelft.nl abstract reactive programming is a style of programming that provides developers with a set of abstractions that facilitate event handling and stream processing.
traditional debug tools lack support for reactive programming leading developers to fallback to the most rudimentary debug tool available logging to the console.
in this paper we present the design and implementation of rxfiddle a visualization and debugging tool targeted to rx the mostpopularformofreactiveprogramming.rxfiddlevisualizes the dependencies and structure of the data flow as well as the data insidetheflow.weevaluaterxfiddlewithanexperimentinvolving 111developers.theresultsshowthatrxfiddlecanhelpdevelopers finishdebuggingtasksfasterthanwithtraditionaldebuggingtools.
ccs concepts software and its engineering software testing and debugging data flow languages software maintenance tools keywords reactive programming debugging visualization program comprehension acm reference format herman banken erik meijer and georgios gousios.
.
debugging data flowsinreactiveprograms.in proceedingsoficse 40thinternational conference on software engineering gothenburg sweden may june icse pages.
introduction software often needs to respond to external events and express computations as data flows.
traditionally handling asynchronous eventswasdoneusingthe observerdesignpattern inobjectoriented environmets or callback functions when the host language supports higher order functions .
using these patterns the system consuming the data does not have to block waiting for new data to arrive but instead it yields control until new data isavailable.
while these patterns decouple the data producer from permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
consumers they typically lead to dynamic registration side effects on the consumer side and inversion of control .
reactive programming rp is an alternative to these patterns for event driven computation.
rp defines event streams as lazy collections and provides operators that allow developers to deal with thecomplicationsofasynchronouseventhandling.rpstartedin academiaintheformoffunctionalreactiveprogramming frp but in recent years the use of rp has exploded.
languagessuchaselm andlibrariessuchasreactor akka and rx are being used by companies like netflix microsoft and google to build highly responsive and scalable systems.
frontend libraries like angular1 that use rp in their foundations are used by many large sites .
of quantcast top 10k websites2 .
agroupofdevelopersandcompanieshasstandardized reactive programming in the form of the reactive manifesto .
while reactive programs offer more declarative and concise syntax for composing streams rp does not work well with traditional interactive debuggers shipped with most ides .
rp borrows from functional programming fp for its abstractions its laziness and its use of pure functions.
those features contribute to a controlflowthatishiddeninsidetherpimplementationlibraryand leadtonon linearexecutionofusercode.thisresultsinnon useful stack traces while breakpoints do not help either as relevant variables are frequently out of scope.
furthermore using a low level debuggermakesithardertointeractwiththehighlevelabstractions thatrpprovides.comparedtoimperativeprogramming thereis limitedknowledgeonhowtoefficientlydebugreactiveprograms.
traditional imperative program debugging practices do not apply to rp .
in this work we address the issue of rp debugging by designingandimplementingahighleveldebuggercalledrxfiddlefora popularversionofrp namelyreactiveextensions rx .rxfiddle providesanoverviewofthedependenciesinthedataflow enables introspection of both the data flow and the timing of individual events and enables developers to trace values backthrough the data flow.
to guide our design we conducted interviews among professional developers.
after building rxfiddle we validateditwithauserexperimentinvolvingover100developers.
wefoundthatrxfiddlecanhelpdeveloperscomprehendanddebug rp data flows faster.
to steer the research we formulate the following research questions rq1how do developers debug rp?
beforedesigningtoolsitisimportanttounderstandthepractices they must support along with the problems in the currentstateoftheart .forthis weperformedanextensive accessed acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden banken et al.
analysis of the literature both scientific and practitioneroriented and conducted interviews with rp practitioners.
rq2how can we design a tool that helps developers debug rp?
byexaminingtheresultsofrq1 thelimitationsoftraditional debuggers and the opportunities that rp programs offer in terms of structure and explicit dependencies between data flows we design a novel rp debugger.
we validate the design sfeasibilitybyprovidingan implementationforthe popular javascript rp library rxjs.
rq3can our specialized rp debugger speed up comprehension debugging?
to validate our design and examine whether specialized tooling can improve the debugging experience we measure thespeedand correctnessofcomprehensionwithanopen experiment.
background reactive programming and rx rpisadeclarativeprogrammingparadigmforworkingwithstreams of input data.
according to a definition of reactivity3a reactive program must interact with the environment at a speedwhichis determined by the environment .
conceptually when a reactive programisrun itsetsupadataprocessingpipelineandwaitsuntil input arrives i.e.
when the environment changes.
reactive programming languages and libraries provide developers with a set of abstractions and methods to create such programs.
many rp implementations share a notion of a collection that abstractsover time incontrastto spacelikestandardcollections.this collectioncomesindifferentflavors suchasobservable rx signal elm signal event rescala or behavior event frp .the implementationsdifferinthe precisesemanticsof their collections their execution model push pull and the set of availableoperators.in thispaper wefocus ontherxformulation but our work is applicable to other rp implementations to some extent.
understanding how we derive our visualization requires a minimal understanding of the internals of rx.
rx introduces two basic types observable andobserver.observablesdefinethedataflow and produce the data while observers receive the data possibly movingthedatafurtherdownthestream.figure1ashowsavery basicexampleofan insitu dataflowinrx.initially anobservableiscreated hereusingthestatic of method thendependent observablesare createdusing the map andfilter methods on theobservableinstance.finallywe subscribe tostartthedata flow and send the data to the console.
assembly.
itisimportanttonotethatobservablesarelazy initiallytheyonlyspecifyablueprintofthedesireddataflow.creating this specification is called the assembly phase.
in figure 1a the assembly phase consists of the calls to of map andfilter creating respectively observables o1 o2ando3 figure 1b .
subscription.
whenthe subscribe methodofanobservable is called the data flow isprepared by recursively subscribing up the stream every subscribe call creates an observer that is passed reactive programs maintain a continuous interaction with their environment at aspeedwhichis determined by the environment not the program itself.
to the input observable which again subscribes an observer to itsinput observable until finally the root observables are subscribed to.wecallthisthe subscription phase.infigure1a insidethesingle subscribe call theobserverobject s1iscreated andpassedto o3 which in turn will recursively subscribe to o2with a new observer s2with destination s1 until the full chain is subscribed figure 1b .
runtime.
after the root observables are subscribed to they can start emitting data.
this is the runtimephase.
depending on the nature of the observable this might attach event listeners to ui elements opennetworkconnectionsorstartiteratingoverinmem ory data.
events are pushed to s3 t os2and finally to s1which calls console.log in figure 1a.
rx identifies three types of events that can occur during the runtime phase next errorandcompleteevents.nextevents contain the next value in the flow an errorevent signifies an unsuccessful termination to a stream while a complete event denotes the successful termination of the stream.
there are restrictions on theirorder anobservablemayfirstemitanunlimitedamountof next events andtheneitheran errororacomplete event.observables do not need to emit any nextevents and do not need to terminate.
morecomplexprogramsfeatureoperatorsthatmergeobservables4 split observables5or handle higher order observables6 resultinginmorecomplexgraphs.anexampleofahigher orderobservable operation flatmap is shown in figure 1d.
while merging and splitting happens on an observable level the source property still points to one or more dependencies higher order observable flattening only manifests within observer structures thereisnoreferencebetweentheobservables .figure1eshows this with an innerobservable that is subscribed twice for both values2and3 value1isskipped resultingintwoidenticaldata flowsover o1.thedataflowthrough s4 nands4mispushedinto s1 flattening the data flow.
marble diagram.
the term marble diagram comes from the shape of the glyphs in the images used to explain rx in the official documentation.anexampleisshowninfigure1c.thediagrams contain one or more timelines containing the events that enter and leave observables.
next events are typically represented with a circle error events with a cross and complete event with a vertical line.fromthediagramdeveloperscanunderstandhowoperators work by inspecting the difference between the timelines where events might be skipped added transformed or delayed.
mapping timeonthex axisprovidesinsightthatismissingwheninspecting only a single time slice.
research design to answer our research questions we employ a three phase sequential exploratory strategy one of the mixed methods research approaches .
first we interview professional developers andreviewavailabledocumentation rq1 toformaunderstanding about current debugging practices.
second we apply this understandingtodesignadebuggerandimplementittotestitsfeasibility rq2 .finally wevalidatethedebuggerusinganexperiment rq3 .
4concat merge combinelatest and zip 5partition or through multicasting with share or publish 6flatmap mergemap and concatmap authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging data flows in reactive programs icse may june gothenburg sweden observable.of .map x x .filter x x .subscribe console.log a rx code example o1 o2 o3 s3 s2 s1source sourcemap filter destination destinationsubscribe subscribe subscribeof b rx graph example multiplybyten a c marble diagramletinner rx.observable.of a b letouter rx.observable.of .skip .flatmap inner .subscribe d higher order flatmap operation o2 o3 o4 s3 s2 s1 o1 s4 n s4 msource sourceskip flatmap inner destination destinationsubscribe subscribe subscribe subscribe destination subscribedestinationo1 s4 n s4 msubscribe subscribeinnerof e higher order rx graph example figure samples of rx observables rq1 rp debugging practices to validate the need for better tools we must first understand how existing tools are used rq1 .
for this we interview developers as wewanttoexploreandunderstandhowtheyuseexistingtoolsand techniques to debug rx code.
the questions are semi structured.
we first establish a general understanding of the experience of the subjects.wethenaskseveralopenquestionsregardingtheiruseof rp how subjects debug rp and test rp.
table lists the questions used as a guideline for the interviews.
fivedeveloperswithprofessionalprogrammingexperiencerangingfrom 4to12 yearswere interviewed.thefirst fourdevelopers d1 d4 work in company a which builds reactive systems usingvariousrpsolutions.developerexperiencewithrxranges from a month to over a year.
the fifth developer d5 works incompany b and is concerned with building and maintaining a large scale distributed server application that uses rx to handle asynchronous events.
.
interviews in the following paragraphs we discuss the results of q6 q10 in detail.noteverysubjectansweredeachquestioninthesamedetail so we discuss the answers that provide meaningful insights in the current practice.
testing.ofthe4subjectsofcompanya noneperformedtests specificallyforrxlogic.
justrunningtheapplication isenough accordingtod3 sayingthattheyonlytestthebusinesslogicintheir application and consider the rx code as glue which either works or not.
in contrast d5 and his team at company b extensively testtheir application using the rx library s built in test facilities like marbletests andthe testscheduler .usingtests thesubject confirms his beliefs about the behavior of the chain of operators while tests are also helpful when refactoring code.
debugging.
all subjects independently mention using temporaryprintf debugging statements printing messages to the system output e.g.
with console.log in javascript .
subjects use printf debuggingto addmorecontext d1 totheirdebugsessions.
printing which values flow through the flow allows them to quicklyreasonwhathappens d3 .breakpointsareonlyusedwhen thecostofrecompilationishigh forexamplewhentypescriptis used insteadof javascript developers preferto attach theirdebugger to a running program session rather than inserting printf statements and restarting the session.
often it isdifficulttouse existingdebuggersto inspectthelife cycle of observables subscribe anddispose as the corresponding code lives within the rx library.
debugging inside the rx librarywasdescribedas painful byd2 whenusingthenode.js debugger to step through the inners of rx.
alternative solutionsused by our subjects are creating a custom debug operator whichprintstheselifecycleevents d5 and creatingcustom observables with observable.create thatoverridethedefault lifecycle methods with facilities to print life cycle events d2 d5 .
whileprintf debugging and breakpoints are useful in various degrees when executing a single observable chain these methods bothbecomeconsiderablymoredifficultand overviewiseasilylost when executing multiple chains concurrently d3 d5 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden banken et al.
question undestanding the subjects q1 explain your professional experience.q2 assess your experience on a scale from beginner to expert.
q3 explain your professional reactive programming experience.
q4 assess your rp experience on a scale from beginner to expert.q5 have you ever refactored or reworked rp code?
content questionsq6 how do you test or verify the workings of rx code?
q7 how do you debug rx code?
q8 how do you use documentation on rx?
q9 what difficulties do you experience with rp?
q10 what is your general approach to understand a piece of rx?
table interview questions documentation.
subjects give different reasons to consult the documentation butthemostcommonreasonisto findanoperator for what i need d1 .
they feel that there might be an operator that precisely matches their needs however knowing all operators by heart is not common the javascript rx observable apihas static methods and instance methods therefore subjectssometimesendup operator.
another reason to visit the documentation is to comprehendhowoperatorsinexistingcodework.forthis subjectsuse themarblediagramsatrxmarbles.com d2 d5 therxjs4 documentationongithub d2 d5 therxjs5documentationatre activex.io d1 d4 d5 andtheonlinebookintrotorx.com d4 .d1specificallymentionstheneedformoreexamplesinthe documentation.
difficultiesexperienced.
the idedoes nothelp withdeveloping rx d2 d4 accordingtod4 rxismoreabouttimingthanabout types and ...you miss some sort of indication that the output is what you expect .
it is not always clear what happens when you execute a piece of code mostly due to observables sometimes being lazy d2 .
flows are clear and comprehensible in the scope of a single class or function but for application wide flows it becomes unclear d3 d4 and d5 .
d3 mostly used rxscala and mentions that creating micro services helps in this regard.
d1 mentions that you need to know a lot as a starting developer giving the example of the many ways to cleanup.
d1 used both logging while analyzing existing code and learning to overcome inexperience.
understanding.
subjects first look at which operators are used thenthey reasonaboutwhattypesandvaluesmightflowthroughthe stream d2 d3 d4andd5 usingvariousmethods.byanalyzingthe variablenamesd2formsanexpectationoftheresultingvaluetypes thenreasoningbackwards toseehowthisdataisderived.
running thecode isusedwhenpossiblebyd5 toobservetheoutcomeofthe stream asthis showstheintentionsoftheoriginaldeveloper .if it remains unclear how the data is transformed the subject injects adebug operator or looks up operators in the documentation.
.
analysis of literature developers can learn rx through several sources such as the of ficial documentation at reactivex.io books online courses andblog posts.
we gathered resources to be analyzed by selecting 4popular books about rx and complement this with the officialdocumentations and an article by a core contributor of rxjs.
all reviewed resources eithermention debugging briefly andsuggest using the do operator for printf debugging or teach the developerprintf debugging via code samples.
therxjs4documentation andtwobooks propose theuseofthe do operatorfordebugging.espositoandciceri furtherexplainhowtobestformatthelogstatementsandintroduce ways to limit the logging by modifying the observable through meansofthrottlingandsampling.therxjavabook alsocontains tips to use the various do operators to integrate with existing metric tools.
to our knowledge the only article addressing issues of debugging rx is by staltz one of the contributors of rxjs noting that conventional debuggers are not suitable for the higher levelofabstractionofobservables.staltzproposesthreewaysto debug rx tracing to the console manually drawing the dependency graph and manually drawing marble diagrams.
we analyzed a set of books about rxjs which was created by selecting books matching rxjs from the o reilly safari catalogue andfurtherreducingthesetbyfilteringontheterms debug and debugger .while noneoftheremainingbookshad achapteraboutdebugging manyofthesebooksuse printf debuggingintheircodesamples.notably blackheathsuggests in a future directions chapter that special debuggers could provide a graphical representation of frp state over time and would allow debugging without stepping into the frp engine.
.
overview of practices theavailableliteraturematchestheresultsoftheinterviews printf debugging is both commonly advised and used.
while the conventionaldebuggerworksinsomecases thisismostlythecaseforthe procedural logic that interleaves rx logic.
rx specific debuggers are suggested but not implemented.
we found that developers use printf debugging to learn the behavior of observables behavior meaningboththeirvaluesflowingthroughandtheir oneormany subscriptions.
overall weidentifiedfouroverarchingpracticeswhendebugging rx code gaining high level overview of the reactive structure.
understanding dependencies between observables.
finding bugs and issues in reactive behavior.
comprehending behavior of operators in existing code.
rq2 debugger design inthissection wedescribethedesignofavisualizerforthereactivex rx family of rp libraries to answer rq2.
given the findings of rq1 the requirements for our visualizer are req1provideanoverviewofobservableflows.
thisoverviewshould support practices and by graphically representing the relations between all observables and their interactions.
req2provide detailed view inside the data flow.
this view should support practices and by giving access to both data flow andlife cycleeventsandshouldbeabletoshowthebehavior of an operator visually.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging data flows in reactive programs icse may june gothenburg sweden of map x x filter x x a dfg of figure 1bof skip flatmap inner of a b b dfg of figure 1e figure2 simplifieddfgscorrespondingtoexamplesinfigure to meet those requirements we propose a visualizer consisting of two parts a data flow graph and a dynamic marble diagram.
the data flow graph satisfies req1 by providing a highlevel overview and by showing how different flows are created combined and used.
the dynamic marble diagram offers a more in depthlookintoasingledataflow byshowingthecontents in terms of values and subscriptions of the flows.
developers can use it to learn the behaviors and the interplay of operators.
.
data flow graph simplifiedgraphs.
whenrunninganrpprogram observables arecreatedthatdependonotherobservables their source andobserversarecreatedtosendtheirvaluestoadefinedsetofobservers theirdestination .figure1bshows theserelations ina graph.for the simplest of programs the relations between the observables o o1 o2 o3 and those between observers s s1 s2 s3 share an equally shaped sub graph after a reversal of the observer edges.
to provide more overview we process the graph to merge the two observable and observer sequences together simplifying it in the process resultingina dataflowgraph dfg asinfigure2a.todo so weretainonlytheobserversubgraphnodes complementing them with the metadata of the corresponding observable nodes.
higher orderrelationsareretained asshowninfigure2.figure3b shows the dfg in practice.
layout.layout isused toadd anextralayer of information to the graph.
if multiple subscriptions on the same observable are created multiple flows are kept in the graph and they are bundled togetherintheresultinglayout.usingit developerscanfindrelated flows.theycanalsoidentifypossibleperformanceoptimizations for example when they see observables to be reused often they can introduce the share operator to optimize subscriptions.
our layout engine is based on storyflow .
storyflow was initially introduced to visually describe complex storylines involving multiple characters and interactions between them in a way thatminimizesstorylinecrossings.7whereasstoryflowclusterson physicalcharacterlocation weclusterflowsperobservable.furthermore storyflowsupportsinteractivityinvariouslayoutstages ofwhichweusethealgorithmsfor straightening anddragging.a selected flow is thus highlighted straightened and positioned at the right in order to align with the marble diagram.
7an example visualization of the lord of the rings character storylines can be found here usedtoidentifythesameobservableinmultipleplacesinthegraph.
for example in figure 1e the innerobservable is reused twice which we denote visually by applying the same color to its two occurrences in the dfg.
.
dynamic marble diagrams weextendtheoriginalnotionofthemarblediagrambyintroducing animation our dynamic marble diagrams update live when new eventsoccurandarestackedtoshowthedatainthecompleteflow.
this allows developers to trace a value back through a flow an operation which is impossible using a classic debugger.
handcrafted marble diagrams can use custom shapes and colors to represent events butforthegenericdebuggerweuseonlythreeshapes nexteventsareagreendot errorsareablackcrossandcompletesare a vertical line as shown in figure 3c.
for our generic debugger itisunfeasibletoautomaticallydecidewhichproperties content shape and color to apply to events as the amount of events anddistinguishing features might be unbounded.
instead the event values are shown upon hovering the mouse cursor on the marble.
.
architecture to support the visualization we design a debugger architecture consistingoftwocomponents ahostinstrumentationandavisualizer.bysplittingtheinstrumentationfromthevisualization the debugger can be used for the complete rx family of libraries by only reimplementing the first component.
thehost instrumentation instruments the rx library to emit useful execution events.
depending on the language and platform specific instrumentation is required.
what the instrumentationdoes is wrap calls to functions that i create or modify the dfg and ii introduce events to observers.
the instrumentation uses an operationalprotocolconsistingof4functionstodrivethedebugger interface.
thevisualizer takes the output of the host instrumentation the initial graph and simplifies it into a data flow graph.
then it laysoutthedataflowgraphandcreatesthedebugger suserinterface.
by separating the visualizer we can export generated graphs and visualize them post mortem for example for documentation purposes.
the components can run in their own environment.
the instrumentation must run inside the host language while the visualizer can use a different language and platform.
.
implementation to validate our design and to provide an implementation to the developer community we created rxfiddle.net.
the rxfiddle project is a reference implementation of our reactive debugger design.
besides the visualizer the website also contains a code editor for javascript code with sharing functionality for developers to share snippetswiththeirpeers asshowninfigure3a.inthissectionwe willexplaindifferentpartsoftheimplementation.forrxfiddle we initially focused on rxjs javascript .
instrumentation.
with javascript being a dynamic language we use a combination of prototype patching and proxies to instrument the rxjs library the observable and observer prototypes authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden banken et al.
ab c figure screenshot of rxfiddle.net showing the code editor a the dfg b and the dynamic marble diagram c are patchedto returnproxies wrappingthe api methodcalls.
the instrumentation passes every method entry and method exit to the linking step.
linking.wedistinguishbetweenmethodcallsfromthedifferentphases section2 .fromtheassemblyphase wedetectwhen observablesareusedastargetorargumentsofacallorasreturn value andcreateagraphnodeforeachdetectedobservable.we add an edge between the call target and call arguments and returnedobservables denotingthe sourcerelation.also wetagthe returnedobservablewiththecallframeinformation time method name arguments .
in the subscription phase we detect calls to subscribe the destination observers are passed as arguments sowecreatethegraphnodesandsavetherelationasanedge.in the runtime phase we detect next errorandcomplete calls on observers and add these as meta data to the observer nodes.
graphloggers.
fromthelinkingstepthegraphmutationsare streamed to the environment of the visualizer where the graph is rebuilt.
depending on the host language a different protocolis used rxfiddle s code editor executes the code in a worker and transmits events over the postmessage protocol while rxfiddle for node.js transmits over websockets.
being able tosupport multiple protocols extends the possible use cases our prototype implements a code editor for trivial programs a node.js plugin for server applications and chrome devtool extensions8 for web applications.
visualizer.
the visualizer receives the current state in the form of a graph from the logger.
it then uses the observers in the graph tocreatethedfg.tolayoutthedfgusingstoryflow wefirstrank thegraphusingdepthfirstsearch removeslack andreverse edges in order to create a directed acyclic graph.
we then add dummynodestoreplacelongedgeswithedgesspanningasingle rank.finally weorderandalignthenodesintheranksassigning fast asitrunseverytimethedfgischanged.torenderthemarble diagrams theflow toandfromtheselectedobserverisgathered by recursively traversing the graph in the direction of the edges.
rq3 evaluation in this section we evaluate our debugger to assess the efficacyof our approach.
to do so we use an experiment in which we controlforthedebuggerfacilitiesthatsubjectsuse.the control groupisprovidedaclassicwebdevelopmentenvironment while the treatment group uses rxfiddle.
ko et al.
describes two commonly used measures for experiments regarding tools in software engineering successon task andtimeontask.thegoalofourexperimentistomeasurethe time requiredtosolveprogrammingproblemscorrectly.ifourreasoning for rq2 is right and our debugger design lends itself for rp we expecttoseethatthegroupusingrxfiddlecanmorequicklyreason about the reactive code at hand and can trace bugs faster.
we do not use success or correctness as a measure for the experiment as weexpectbothgroupstobeabletocompletethetaskscorrectly whilethecurrentdebuggingsituationisnon optimal itisstillused in practice indicating that it works at least to some extend.
the construct of time also matches debugging better developers need to continue debugging untilthey find an explanation or a solution to their problem while assumptions can be tested and corrected.
we measure the time from the moment the participant received the question until the correct answer is given.
participants useeither the built in chrome browser debugger group console o r the rxfiddle debugger group rxfiddle .
this single alternative console debugger togetherwith the experiment ui whichacts as a small ide offers all the debugging capabilities subjects of our preliminary interviews rq1 reported to use.
the experiment consists of a questionnaire a warm up task and fourprogrammingtasks allavailableinasinglein browserapplication ofwhichthesourcecodeisavailableat .thequestionnaire authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging data flows in reactive programs icse may june gothenburg sweden containsquestionsregardingage experienceinseveralprogramminglanguagesandseveralreactiveprogrammingframeworks.we usethisselfestimationasameasurementofskillinsteadofapretest sinceitisafasterandbetterestimator .thewarm up program is placed in the same environment as the programming problemsandcontainsseveraltasksdesignedtolettheparticipants useeverycontrol ofthistestenvironment.
thefirsttwoprogrammingproblemsrequirestheparticipantstoobtainanunderstandingaboutthebehavioroftheprogramandreportthefindings.thelast two programming problems contain a program with a bug.
the participants are asked to find the event that leads to the bug in the thirdproblemandtoidentifyandtextuallyproposeasolutionin the fourth problem.
the first two problems are synthetic examples of two simple data flows taken and adapted from the rx documentation while the latter two are carefully constructed to match the documented use of rx operators and contain some mocked oth erwise remote service which behaves like a real world example.in t3 an error in an external service propagates through the rx stream.
in t4 concurrent requests lead to out of order processing of responses.
weuseabetween subjectsdesignforoursetup.whilethiscomplicatestheresults subjectshavedifferentexperienceandskills wecannotuseawithin subjectsdesignasitwouldbeimpossibleto controlforthelearningeffectincurredwhenaskingsubjectstoperform survey questions with and without the tool.
this also allows us to restrict the amount of tasks to incorporate in the experiment requiring less time from our busy subjects.
in the experiment environment subjectscananswerthequestionandthenhit submit alternatively they can pass if they do not know the answer.
.
context theexperimentwasrunbothinaofflineandinanonlinesetting.
the offline experiment was conducted at a dutch software engineering company.
subjects are developers with several years ofprogramming experience ranging from little to several years ofexperience with rp.
as we did not try to measure the effect of learning a new tool we explained rxfiddle in the introductory talk and added the warm up question to get every participant to a minimum amount of knowledge about the debugger at hand.
the online experiment was announced by the authors on twitter and consequently retweeted by several core contributors to rp libraries andviavariousothercommunicationchannels suchas rx relatedslackandgittertopics.subjectstotheonlineexperiment tookthetestattheirownpreferredlocationandhavepossiblyverydifferentbackgrounds.wecreatedseveralshortvideo tutorialsand included these in the online experiment to introduce the participantstothedebugtoolavailabletothemandthetaskstheyneeded to fulfill.
the introductory talk given to the offline subjects was usedasthescriptforthevideos inanattempttogetallparticipants to the same minimum level of understanding.
.
results theonlineexperiment wasperformedoutsideofour control and someparticipantsquittheexperimentprematurely.intotalwehad 111subjects 13offline 98online startingthesurvey ofthose98 completed the preliminary questionnaire and and 58subjects startedrespectively t1 t2 t3 and t4.all of thesubjects in the offline setting started all tasks.
figure 4b shows the outcome ofthetasks intheremainderofthissectionweconsideronlythe outcomes marked as correct .
overall.figure 4b shows the time until the correct answer was given per task.
here we consider the combined results from theoffline experiment and the online experiment.
we make no assumptions about the underlying distribution so we perform a nonparametric wilcoxon mann whitney u test h0 times for the console group and rxfiddle group are drawn from the same population to see if the differences are significant and a cliff s delta test for ordinaldatatodeterminetheeffectsize.theresultsareshownin figure 4a.
fortaskt3 wecanreject h0withhighsignificance p .
the rxfiddle group is faster.
for the tasks t1 t2 and t4 we can not rejecth0 p .
meaning the rxfiddle group and console group perform or could perform equally.
control for experience.
to investigate this further we split the results for different groups of subjects.
when we control for the self assessed rx experience we see bigger differences for all tasks for groups with more experience as shown in figure 4c and figure4d wesplitatthemedian exp rx beginner level .still for tasks t1 t2 and t4 we can not reject h0 but the results are more significant comparing only experienced subjects.
discussion wenowdiscussourmainfindings howrxfiddleresolvesthedebugging problem of rx and contrast our design to other design choices and possibilities of future work.
.
main results quick and dirty debugging.
through interviews and literature weestablishthatcurrentdebuggingpracticesforrpconsistmostly ofprintf debugging.
the shortcomings of this method were evidentfromtheinterviews itworksreliablyonlyforsynchronousexecutionorwhensmallamountsofeventsbeinglogged otherwise theoverviewislost.furthermore thetime contextofeventsand dependency contextofflowsarenotavailableusingthismethod.
weattributetheprevalenceof printf debuggingtothis quick and dirty method being available in every language and on every platform without a viable alternative.
improved context being complete disposing doubts.
with our designandcomplementaryimplementation weshowthatourabstract model of rp is suitable for visualization on two levels overviewand detail.
at the overview level we complement the dependenciesvisibleinsourcecodewithagraphoftheresultingstructure showing the run time effect of certain operators on the reactive structure.
at the detail level we add the time context by showing previous values on a horizontal time line and the dependency context by showing input and output flows above and below the flow ofinterest.whiletheresultsofourevaluationcouldbeobserved as a negative rxfiddle is a new tool where subjects have only just been exposed to the tool and received only a short training.
we expectthatbydesigningadebuggermodelsoclosetotheactualabstractions our debugger works especially well for users with some authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden banken et al.
console rxfiddle w p value cliff s t134 .
.
t232 .
.
t323 .19e .
t413 .
.
a results comparing the console and rxfiddle groups t1 t2 t3 t4 tasktime s mode console rxfiddle b time until correct answer per task overall console rxfiddle w p value cliff s t116 .
.
t214 .
.
t310 .88e .
t4 .34e .
c resultscomparingtheconsoleandrxfiddlegroups withrxexperience above beginner level.
t1 t2 t3 t4 tasktime s mode console rxfiddle d time until correct answer per task for subjects with more than beginner level of experience with rx.
figure experiment results overall top row and experienced developers only bottom row .
knowledgeoftheseabstractions whileonlyt3showsbetterperformance with high significancy we observe slightly better results when controlling for experience.
future research might investigate theeffectofexperienceinmoredetail includingtheuseofmore complicated tasks with larger samples.
in the presented research we did not perform tests with subjects using their own code.
however during piloting and after the release of rxfiddle we received positive feedback regarding the completeness of the visualization.
as one user put it by using rxfiddle when learning and understanding what rxjs does in ourproject i have a feeling of improved control over our observables subscriptions and the reactive parts of our app .
specifically the lifecycle events which are generally hard to debug using printf debugging are more clear initially we were reluctant to manually subscribe butafterseeingthat complete oftentriggersa dispose theteam became more confident to sometimes use subscribe directly .
future research might address this evaluation aspect by designing experiments specifically using code owned by the users.
.
implications the developers using rx in practice now have an alternative to printf debugging.developerscantryrxfiddleontheircodebase to better understand the reactive behavior of their application and potentiallydetectandverify performance bugstheyarenotaware of.
at least one example of this has already occurred in practice one of our interview subjects reported a bug 9in thegroupby implementation of rxjs which resulted in retention of subscriptions increasedmemoryusageandfinallyledtoanout of memory exception.
the subject detected the bug in practice and required extensive amount of debugging involving the node.js debugger to tracedown thesamebugisimmediatelyobviousinrxfiddlewhen examining the life cycle events using the visualization.
of rp libraries could use tools like the rxfiddle visualizer in documentation to provide executable samples which would allow for a better learning experience and at the same time would introduce novice developers to other ways of debugging thanprintf debugging.
.
limitations and future work multiple inputs and outputs.
if we compare our debugger visualizationtothevisualizationoflearningtools likerxmarbles or rxviz the main difference is that those tools show all input and output observables of a single operator concurrently whilerxfiddle shows one input and output observable per marble di agram part of a single full flow a path through the graph .
the choicetoshowafullflowallowsdeveloperstotraceeventsfrom thestartuntiltheendoftheflow butrestrictsusinshowingonlya single ancestor flow per node at each vertical position as adding a third dimension would clutter the currently 2d visualization.
for future research it would be interesting to compare the different waysobservablestreamscanbecombinedinmarblediagramsand which visualization elements can be added to explicitly show causality andlineagefor events and show durations for subscriptions.
edgevisualization.
inourgraphvisualization theedgesrepresent the dependencies and the path of the events.
nodes with multiple incoming edges mergethe events however users could falsely think that all event data ends up in the outgoing path besides data flows rx also uses observables for timing as durations window as stop conditions takeuntil or as toggles pausable .
different visual representations for joining paths could be explored to distinguish between using observables for data or for timing.
graph scalability.
debugging large reactive systems over longer periods of time can result in significantly larger observable graphs authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging data flows in reactive programs icse may june gothenburg sweden and marble diagrams than currently evaluated.
during tests of rxfiddlewithlargerapplicationslikerxfiddleitselfandanexisting angularapplication thegraphbecametoolargetorenderinreal time.besidesrenderingperformance apotentiallyevenbiggerissue is with communicating large graphs to the developer.
we propose severalextensionstorxfiddletoremedythisissue pruningthe graphofoldflowstoshowonlytheactiveflows bundlingflows thathavethesamestructure andonlyrenderingasingleinstance offering a picker into the flow of interest collapsing certain partsofthegraphthatarelocaltoonesourcefileorfunction addingsearchfunctionalitytoquicklyidentifyflowsbyoperator or data values support navigation between code graph.
marble diagram scalability.
our experience shows that while marble diagrams are useful for small to medium amount of events bothbetterperformanceandbetterfunctionalitycouldbe achievedbyprovidingadifferentinterfaceforhighvolumeflows.
above a certain threshold of events this high volume interface could be the default offering features like filtering watch expressions tolookdeeperintotheevent svalue andadvanced featureslike histograms fastfouriertransform fft views.
moreover manuallyexaminingthesedistincteventscouldtakea long time a debugger could leverage the run time informationabout the events that actually occur to provide a ui.
advanced features like histograms could help the filtering process while fft could offer new ways to optimize the application by smarter windowing buffering and sampling later on in the chain.
breakpoints.
placing traditional breakpoints in a reactive programstopsthesystemfrombeingreactive andthereforecanchange the behavior of the system.
breakpoints can be used by developers in two ways i tomodify the application state by interacting with the variables in scope and ii to notify them of an event occurrence.whilethefirstisarguablynotdesirableforreactivesystems the notification property might be a good addition to rxfiddle.
bigdebug a debugging solution for systems like spark introduces simulated breakpoints for this purpose.
when a simulated breakpoint is reached the execution resumes immediately and the required lineage information of the breakpoint is collected in a new independent process.
implementing this for rxfiddle isa matter of creating the right ui as the required lineage data is already available.
other rp implementations.
rxfiddle is specific to rx but the debugger design is applicable to other rp implementations.
the visualization should work for every rp collection abstracting over time andwouldbedirectlyapplicabletolanguagessuchasrescala andvarious javascriptrpimplementations.future workcouldinvestigatewhetherthedebuggerprotocolcanbegeneralizedsuch thatotherrpsemanticscanbecapturedtoo forexamplebyproviding extension points for the language specific features.
threats to validity externalvalidity.
fortheinterviewsweselected5professional developers thatwerebothavailable and workedon projects involv ingrxjs.theonlineexperimentwasopentoanyonewhowantedtoparticipate andsharedpublicly.theserecruitmentchannelsposea threattogeneralizability differentpracticesmightexistindifferentcompanies differentdevelopercommunitiesandfordifferentrp implementations languages.futureworkisneededonvalidating the debugger in these different contexts.
our code samples for the tasks are based on documentation samples and common use cases for rx rxfiddle might perform differently on real world code especially when the developer is familiarwiththeprojectordomain.theexperimentconsistsof2 smalland2mediumtasks forlargertaskstheeffectofusingthe debugger could be bigger and therefore be better measurable.
still we chose for these smaller tasks in the limited time of the subjects they could answer only so many questions.
constructvalidity.
wemeasurethetimebetweenthemoment aquestionisdisplayedandthemomentitscorrectanswerissubmitted.
even though our questions and code samples are short and were designed to be read quickly still some variation is introduced by differentreading speedsofsubjects.a setup wherethe question and code can be read before the time is started can remedy this threat butintroduces the problemof planning when givenunlimited time subjects can start planning their solution before the timestarts.furthermore subjectsmighthavedifferentstrategiesto validatetheir potentiallycorrect assumptionsbeforesubmitting ranging from going over the answer once more to immediatelytesting the answer by submitting it.
however explicitly stating thatinvalid answersdonot leadtopenalty mightintroducemore guessingbehavior.futurestudiescoulduselongertasks withprepa ration time to read the sample software at hand with a wizard like experiment interface presenting one short question at a time.
internal validity.
as a result of the recruitment method of the experiment a mixed group of developers took part attracting eventhose without rx experience.
to reducethe variation in experience that this introduces we separately examined the results of more experienced developers.
at the time of the experiment rxfiddle was already available online for use and furthermore some of the experiment subjects hadalreadyusedrxfiddleduringpiloting.wemitigatethisissue partially by providing a instruction video at the start of the experiment howeversubjectswithextensiveexperiencewithrxfiddle might bias the results.
thesubject expectancy effect poses a validity concern since subjects whoexpect acertain outcome may behavein away that ensures it.
our subjects had the opportunity to learn the context of the experiment and thus could be more motivated to use rxfiddle than using the traditional debugger.
our online experiment cap tures motivation to some extend as drop out defined as quiting before havingstarted all tasks happens the approximately equal drop out in both groups rxfiddle .
console .
suggests nosignificantmotivationaldifferences.futurestudiescouldoffer subjects external motivation e.g.
by ranking contenders and gamification oftheexperiment ororganizingaraffleamongtop contenders to limit the threats introduced by motivation.
related work rp debugging.
rescala is an rp library for scala based on scala.react.
recently a debugger model was created for rescala authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden banken et al.
called rpdebugging featuringadependencygraphvisualization breakpoints aquerylanguageandperformancemonitoring.
thedebuggerfullyintegrateswiththeeclipseideandthescala debuggerfacilities creatinga scala developerexperienceanda featurerxfiddlecurrentlydoesnotoffer reactivebreakpoints.our debuggerdesignsupportsmultiplelanguages andworksoutside oftheide inthebrowserenvironmentand orconnectingtoaproductionsystem.rxhasdifferentreactivesemanticsandarguably amorepowerful butalsomoreextensiveapi whichincludesoperators acting in the time domain delay etc.
.
therefore we argue that seeing values in a flow over time is very valuable rp debugging shows the latest values at the selected time.
rp visualization.
rxmarbles visualizes single rx operators for the purpose of learning and comprehension.
users can drag to modify only thetimingofeventsandinstantlyseethechangesreflectedintheoutput.byusingspecificprecodedinputsandtimings the essence of the operator is made clear.
in rxviz moroshko takes a similar approach but provides a code editor instead of prepared inputs and visualizes the output of the stream.
rxmarbles doesnotsupporthigher orderstreams whilerxvizsubscribesto the one outer and multiple inner streams when it detects a higherorder stream showing them concurrently.
in contrast to our work these tools are not debuggers focus is on teaching the behavior of single operators or stream outputs instead of full programs.
omniscientdebugging.
omniscientdebuggers trace store andqueryalleventsinaprogramexecution.whenstoringvasts amountofprogramexecutioninformation performanceandeffi ciencybecomesaproblemandresearchinomniscientdebuggers focusesonthisspecifically.wealsotraceeventsoftheentireexecution ho wever in contrast to omniscient debuggers we only store trace events regarding rp data flows.
the rp semantics allow us to createfutureoptimizations forexampleretainingonlytheactive flow structure while the flow s data is kept in a rolling buffer.
dynamicanalysis.
thestudyofprogramexecutioniscalled dynamicanalysis .inmanycases dynamicanalysisinvolvesa post mortem analysis where first the program is run collecting anexecutiontrace andthenthetracedataisanalyzedtocreatea visualization.derivedvisualizations likeclassandinstanceinteraction graphs function invocation histories invocation views and sequence diagrams show the possibility to use trace information for debugging.
arguably on line analysis is more useful for debugging than the standard post mortem analysis.
reiss in reference mentions the compromises that have to be made to makeanon lineanalysis reducedtracingisrequiredtonotslow downthesystem knownastheobservereffect andfastanalysis isrequiredtolowerthecostofgettingtothevisualization tonot discouragetheusers.inourdesign wehandlethesamecompromisesastheyarerelevantforrpdebuggingtoo andourjavascript traceimplementationbearsresemblancetothatofprogramvisualiser .
understandingdebugging.
debuggingforgeneralpurposelanguages revolves around attaching a debugger stepping through the code attaching code or data breakpoints navigating along different calls in the call stack and examining variables and resultsof expressions .
however existing research measuring howthesedifferenttasksarepartofthedevelopersworkday foundthat whiledevelopersspendmuchtimeoncomprehendingcode they donotspendmuchtimeinsidetheide sdebugger .belleret al.
foundthatonly23 oftheirsubjectsactivelyusetheide s debugger with the most common action being adding breakpoints followedbysteppingthroughcode.theautomatedtoolingofthese studies did not measure different kinds of debugging other than usingtheideprovidedtools howeverbeller ssurveyindicatesthat also uses printf statements for debugging.
no indication was given of any rp language and libraries used by the subjects in the study but the observation that printf debugging is common matches our experience with debugging reactive programs.
debuggingforprogramcomprehension.
developersneedtoboth comprehend and debug code almost daily.
initially comprehension wasseenasadistinctstepprogrammershadtomakepriortobeing able to debug programs .
this distinction is criticized by gilmore debugging a design activity part of creating andcomprehendingprograms.maalejetal.
interviewedprofessional developers and found that developers require runtime information to understand a program and that debugging is frequently used to gather this runtime information.
this supports our view that debugging is not only used for fault localization but also for comprehension.
conclusions through analysingthe current rpdebugging practices this work showstheprevalentmethodforrpdebuggingis printf debugging.
to provide a better alternative we present an rp debugger designanditsimplementationfortherxjslibray rxfiddle which enablesdevelopersto gainahigh leveloverviewofthereactivedataflowstructureanddependencies and investigatethevalues and life cycle of a specific data flow at run time.
throughanexperiment weshowthatrxfiddleisanviablealternative for traditional debugging and in some cases outperforms traditional debugging in terms of time spent.
there are several promisingdirectionsforimprovingourdesign.specificallyscalability could be improved and different edge visualizations could be explored toimprovetheusabilityofthetool.furthermore bylever agingalreadycapturedmetadataabouttimingofevents evenmore insight could be provided.
at the implementation level we plan to extend rxfiddle to other members of the rx family of libraries.
in this paper we make the following concrete contributions a design of a generic rp debugger initally tuned for the rx rp variant theimplementationofthedebuggerforrxjs andtheservice rxfiddle.net inthemonthafterthereleaseofrxfiddle.netthesitewasvisited by784peoplefrom57differentcountries.thedebuggerwasalready used by developers excluding the use inside of the experiment.
during that same period interactions with the visualizations of the debugger have been recorded such as selecting observables or inspecting values by hovering the mouse over the event.
thedebuggerandtheplatformareopensourceandareavailable online at .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging data flows in reactive programs icse may june gothenburg sweden