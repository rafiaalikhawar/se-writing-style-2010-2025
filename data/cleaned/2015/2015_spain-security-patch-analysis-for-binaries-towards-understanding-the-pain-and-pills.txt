spain security patch analysis for binaries towards understanding the pain and pills zhengzi xu bihuan chen mahinthan chandramohan yang liu and fu song school of computer science and engineering nanyang technological university singapore school of information science and technology shanghaitech university china corresponding author abstract software vulnerability is one of the major threats to software security.
once discovered vulnerabilities are often fixed by applying security patches.
in that sense security patches carry valuable information about vulnerabilities which could be used to discover understand and fix similar vulnerabilities.
however most existing patch analysis approaches work at the source code level while binary level patch analysis often heavily relies on a lot of human efforts and expertise.
even worse some vulnerabilities may be secretly patched without applying cve numbers or only the patched binary programs are available while the patches are not publicly released.
these practices greatly hinder patch analysis and vulnerability analysis.
in this paper we propose a scalable binary level patch analysis framework named spain which can automatically identify security patches and summarize patch patterns and their corresponding vulnerability patterns.
specifically given the original and patched versions of a binary program we locate the patched functions and identify the changed traces i.e.
a sequence of basic blocks that may contain security or non security patches.
then we identify security patches through a semantic analysis of these traces and summarize the patterns through a taint analysis on the patched functions.
the summarized patterns can be used to search similar patches or vulnerabilities in binary programs.
our experimental results on several real world projects have shown that i spain identified security patches with high accuracy and high scalability ii spain summarized patch patterns and their corresponding vulnerability patterns for vulnerability types and iii spain discovered security patches that were not documented and discovered zero day vulnerabilities.
i. i ntroduction program vulnerability is one of the major threats to software security.
however it is almost impossible to avoid vulnerabilities at the development stage and it is even difficult to discover vulnerabilities at the production stage.
security experts usually leverage dynamic fuzzing e.g.
symbolic execution e.g.
or static code auditing e.g.
to find vulnerabilities.
however none of these techniques can provide a complete solution to win the war against vulnerabilities.
dynamic fuzzing suffers from the code coverage problem and the initial seeds problem .
symbolic execution cannot scale well to realworld programs due to path explosion and constraint solving problems.
static code auditing often requires human expertise and cannot scale well when the program complexity increases.
vulnerabilities once discovered are often fixed by applying security patches.
in that sense security patches carry important information about vulnerabilities.
by focusing on the remedy of vulnerabilities instead of the vulnerabilities themselves patchanalysis has been proposed to discover n day vulnerabilities whose patches have been released but not deployed to every instance of the software in the world.
since patch analysis is relatively accurate to find vulnerabilities it has gained the popularity in both industry and academia.
also security patches are good entry points to understanding the program weaknesses and how the vulnerabilities work inside the program especially for security participants who do not have access to the source code.
moreover the underlying information of patches has been used to build automatic bug fixing tools generating valid patches for similar vulnerabilities.
however up till today most existing researches on patch analysis work at the source code level but very few works have been done to tackle this problem at the binary level.
binary level patch analysis can only be performed on machine instructions for closed source programs without symbol tables which often requires a significant amount of human efforts and expertise to understand the semantics of instructions.
due to this complex nature the existing techniques often heavily rely on manual or heavy program analysis which becomes infeasible for real world programs.
on the other hand software companies may tend to patch the vulnerabilities they find themselves in a secret way instead of making them public and applying common vulnerabilities and exposures cve numbers due to their security regulations or policies.
as a result security analysts cannot know the existence of particular vulnerabilities which hinders the understanding and analysis of vulnerabilities.
even worse in some cases only the patched binary programs are available while the patches themselves may not be publicly released which hinders the existing patch analysis techniques that often rely on the availability of patches.
moreover due to the application of patch obfuscation and patch modification techniques such as honeypatching the patch patterns in open source binaries may differ greatly from close source ones.
to address these problems we propose a scalable binarylevel patch analysis framework named spain to automatically identify security patches and summarize patch patterns and their corresponding vulnerability patterns.
in particular given the original and patched versions of a binary program spain locates the functions that have been changed from the original binary to the patched binary.
then it detects the changed traces i.e.
a sequence of basic blocks for each patched function to capture the function level changes.
these traces may contain ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
security or non security patches.
finally it identifies security patches through a semantic analysis of these traces and summarizes the patterns through a taint analysis on the patched functions.
as we run more binary programs we can maintain a database of patterns that will be continuously enriched to embrace the evolving and emerging of various vulnerabilities.
there are many impactful applications of the learned patterns in binary security like patch detection vulnerability detection automatic patch synthesis and even patch vulnerability trend analysis with the help of data analytic techniques.
a more detailed discussion can be found in section iii e .
we evaluated spain on several real world projects.
the experimental results demonstrated that spain can identify security patches with high accuracy and high scalability and summarize security patch patterns and their corresponding vulnerability patterns for types of vulnerabilities.
moreover we discovered undocumented security patches and found zero day vulnerabilities in adobe pdf reader.
in summary our work makes the following contributions.
we proposed a scalable binary level patch analysis framework spain which can identify security patches and summarize patch patterns and their corresponding vulnerability patterns.
we implemented spain in a prototype and conducted experiments to demonstrate the accuracy scalability and application of spain.
we discovered undocumented security patches and found zero day vulnerabilities in adobe pdf reader.
ii.
p reliminaries and overview a. preliminaries in this work we assume that binary programs are in the x86 32bit format.
each binary program contains a number of functions with an entry point starting function .
this section introduces several basic concepts in binaries i.e.
basic block control flow graph and partial trace.
definition abasic block in a binary function is a straightline sequence of x86 instructions with no branches in except to the entry and no branches out except at the exit.
definition given a binary function the control flow graph cfg of the function is a tuple g n e n s n t wherenis a finite set of nodes and each node represents a basic block in the function e n nis a set of edges that connect two nodes and represent the control flow from one basic block to the another ns n t nare respectively the sets of start and end points of the function and is a function associating every node n nwith the basic block n .
notice that there might be more than one start point for a function because it is hard to precisely identify the boundary of a function at the binary level .
definition given a cfg g n e n s n t of a function a partial trace tingis a finite sequence of nodes angbracketleftn1 n ... n k angbracketrightfor some k where ni n i e for every i i k .call bnnew mov edi eax ... cmp eax ...bb call bnnew test eax eax mov edi eax jz errorbb ... cmp eax ...bb 2error ...bb patched version original version1 a b c fig.
running example null pointer dereference vulnerability and its patch from openssl .
.1l.
b. running example figure 1lists the partial x86 assembly code of one null pointer dereference vulnerability abstracted from the openssl .
.1l that consists of the original version and patched version.
in the original version the program first calls the function nb new by which the return value is stored in the register eax .
then it assigns the return value to the register edi at the location1.
later the return value is directly used to dereference the memory at the location .
this vulnerability is patched in openssl .
.1m by checking whether the return value of the function call nb new isnull or not.
this checking is implemented in the patched version by adding two instructions test eax eax andjz error .
it first tests the return value at the location abytest eax eax which performs a bitwise and operation on the operand eax .
the test operation sets the carry flag cf and overflow flag ofto0.
the sign flag sfis set to the most significant bit of the result of the bitwise and operation.
the zero flag zfis set to1if the result of and operation is 0otherwise.
the parity flag pfis set to1if the number of ones in that byte is even 0otherwise.
the value of the adjust flag afis undefined.
after assigning the return value to the register edi it checks whether the zero flag zfis1or not i.e.
the value of eax is null or not at the location b.i fi ti s1 i.e.
eax isnull the control flow will jump to the location error for error handling.
otherwise the return value is used to dereference the memory at the location c. in this running example there are one basic block bb1 and three basic blocks bb1 b b 2andbb3respectively in the original version and patched version.
the cfg of the original version is go n1 n1 n1 where ni bb1.
the cfg of the patched version is gp n1 n2 n3 n1 n2 n1 n3 n1 n2 n3 where ni bbifor every i i .
there are two partial traces angbracketleftn1 n angbracketrightand angbracketleftn1 n angbracketrightingp which corresponds to two possible execution traces of the patched program.
while there is only one partial trace angbracketleftn1 angbracketrightingo.
c. framework overview figure 2presents the overview of spain which consists of four components.
taking the original and patched versions of a binary program as inputs spain first locates the functions that have been changed from the original version to the patched version and detects the changed traces in each patched function to capture the function level changes.
then spain determines whether such changes are caused by security or non security authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g50 g85 g76 g74 g76 g81 g68 g79 g3 g37 g76 g81 g68 g85 g92 g51 g68 g87 g70 g75 g72 g71 g3 g37 g76 g81 g68 g85 g92 g47 g82 g70 g68 g87 g76 g81 g74 g3 g51 g68 g87 g70 g75 g72 g71 g3 g41 g88 g81 g70 g87 g76 g82 g81 g86 g44 g71 g72 g81 g87 g76 g73 g92 g76 g81 g74 g51 g68 g87 g70 g75 g72 g71 g3 g37 g68 g86 g76 g70 g3 g37 g79 g82 g70 g78 g86 g44 g71 g72 g81 g87 g76 g73 g92 g76 g81 g74 g3 g54 g72 g70 g88 g85 g76 g87 g92 g3 g51 g68 g87 g70 g75 g72 g86 g54 g88 g80 g80 g68 g85 g76 g93 g76 g81 g74 g51 g68 g87 g70 g75 g18 g57 g88 g79 g17 g3 g51 g68 g87 g87 g72 g85 g81 g86 g51 g68 g87 g70 g75 g18 g57 g88 g79 g17 g3 g51 g68 g87 g87 g72 g85 g81 g86 fig.
framework overview of spain patches through semantic analysis and then summarizes the patterns of security patches and their corresponding vulnerabilities through taint analysis.
as we run more binary programs spain has the capability to continuously learn and accumulate the knowledge of security patches to embrace the evolving and emerging of various vulnerabilities.
locating patched functions.
given the original and patched versions of a binary program this component first uses the disassembler tool ida pro and the binary comparison tool bindiff to obtain matched function pairs in the original and patched versions.
such pairs are called candidate pairs that may contain security or non security patches.
to reduce the size of pairs for further analysis and hence improve the scalability this component removes the pairs from the candidate pairs in which the functions have no changes or only compilerintroduced changes.
identifying patched basic blocks.
for each function pair in the candidate pairs i.e.
the patched and the original functions this component first leverages the pairwise basic block matching to identify the patched basic blocks within the patched function identifies the relationships among these patched basic blocks in terms of patched partial traces see definition that capture the locality of a patch and finally determines the original partial traces in the original function that are relevant to each patched partial trace.
identifying security patches.
for a patched partial trace and its corresponding original partial traces this component decides whether the changes are caused by a security or non security patch.
it is realized by a semantic analysis to compute the semantic difference between the patched partial trace and each of the original partial trace.
we use small semantic difference as the indicator for security patches based on the heuristic that security patches are less likely to introduce new semantics than non security patches e.g.
feature upgrades .
example recalling the running example in figure the difference between the original and patched versions is the sanity check namely test eax eax andjz error in the patched version.
the semantic difference between the patched and original versions is very minimal e.g.
.2in our experiments and hence we can safely conclude that it is a security patch see section iii c for details .
summarizing patch and vulnerability patterns.
once a security patch is identified this component summarizes the patch pattern and the corresponding vulnerability pattern through a taint analysis from security sensitive instructions in the patched function.
the patterns capture the security critical sources sinks and sanity checks.
one potential application of the summarized patterns is to search for similar patches or vulnerabilities in binary programs.example consider the running example the function nb new is an external unknown function.
the return value of nb new is therefore regarded as the taint source input.
this taint source is directly used to perform the security sensitive operation memory dereferencing which is regarded as the taint sink.
there is no checking of the tainted source between the source and sink points.
from this vulnerability the vulnerability pattern summarized by spain is shown in the 4th row null pointer dereference of table iv.
intuitively this pattern specifies that there is an untrusted function call whose return value is directly used to dereference memory without any sanity checking on them.
while in the patched version of the running example the return value from the external unknown function nb new is checked for null value.
if it is null the program jumps to an error handler.
otherwise the return value is used to perform the security sensitive operation that is memory dereferencing.
the patch pattern learned by spain is shown in the 4th row null pointer dereference of table iv.
intuitively this patch pattern expresses that before using the return value of an untrusted function call to dereference memory there must be a sanity checking of the return value.
d. assumptions spain has a few underlying assumptions which may limit its application and threat its validity.
first we focus on patches in which only one function is modified for one patch but do not support patches where multiple functions are changed for one patch.
second we assume that the function matching results generated by ida pro and bindiff are correct although no tools can reach accuracy .
third we cannot identify every type of patches since some patches especially for logical vulnerability patches may behave like the normal code.
currently we cover the patches for most common vulnerabilities such as buffer overflows integer overflows and double free use after free.
fourth we focus on the x86 32bit binary format.
we will discuss these assumptions in section v. iii.
m ethodology a. locating patched functions spain starts with locating the matched pairs of functions f angbracketleftfp fo angbracketright fis a function in a binary program where fo i.e.
the original function is changed to fp i.e.
the patched function during the patching process.
fis a set of candidate pairs that may contain security or non security patches.
function matching in the first step we leverage the disassembler tool ida pro and the binary comparison tool bindiff to match functions in the original and patched versions of a binary program.
in particular we use ida pro to extract the assembly instructions and construct the cfg for each function.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g76 g81 g86 g87 g66 g20 g76 g81 g86 g87 g66 g21 g76 g81 g86 g87 g66 g22 g76 g81 g86 g87 g66 g23 g76 g81 g86 g87 g66 g20 g76 g81 g86 g87 g66 g21 g77 g80 g83 g3 g79 g68 g69 g72 g79 g79 g68 g69 g72 g79 g29 g76 g81 g86 g87 g66 g22 g76 g81 g86 g87 g66 g23 g11 g68 g12 g11 g69 g12 fig.
an example of compiler introduced changes then for open source binaries i.e.
with the symbol table we directly use function names to perform the matching.
while for closed source binaries i.e.
without the symbol table we leverage bindiff s function matching functionality.
finally we get the initial candidate pairs where each function is represented by its cfg.
note that this step is not one of our contributions and we briefly introduce it to make our methodology complete.
function filtering patches usually change a small part of the whole binary program and many functions remain the same.
therefore in the second step we remove the function pairs with no changes from the candidate pairs to reduce the size of pairs for further analysis and thus improve the scalability.
to this end we apply the 3d cfg based hashing technique to compute the hash value for fpandfo and then remove angbracketleftfp fo angbracketrightfrom the candidate pairs fiffpandfohave the same hash value.
further some changes are introduced by compilers due to the compilation context or optimization level .
one common case is that the compiler may split one basic block into two basic blocks as illustrated in figure .
the basic block in figure a becomes two basic blocks connected by a jmp instruction in figure b in the second run of a compiler.
however these two versions are semantically equivalent to each other.
therefore for any basic block which has only one successor and its successor has only one predecessor we merge it with its successor and remove the additional jmp instruction.
another common case is that the compiler might change the operands of the instruction in different runs.
for example the memory addresses are associated with the function position in the binary program and they will change if the function position is changed which always happens in different runs of a compiler.
to account for such changes introduced by compilers we normalize each basic block as shown in algorithm .
it takes a basic block as an input and returns the normalized basic block.
it iteratively normalizes each assembly instruction in the basic block line .
an assembly instruction consists of a mnemonic and up to operands where a mnemonic represents the specific operation that an instruction performs while an operand is a variable length sequence of elements cf.
ia .
thus it gets the mnemonic line and normalizes the operands of each instruction according to their operand types lines .
an operand can be a register an immediate value or a memory which is respectively normalized to its type reg imm o rmem .
for example mov eax 0x40 is normalized to mov reg imm .
after the merging and normalization of basic blocks for each functions in f we use the same hashing technique to further remove the pairs that only have some compiler introduced changes.
our filtering step is designed to be conservative such that security changes are kept.algorithm normalize a basic block input basic block b output normalized basic block b prime 1b prime angbracketleft angbracketright sequence of normalized inst.
2foreach instruction iinbdo m getmnemonic i ifm negationslash nop then op prime angbracketleft angbracketright sequence of operand type foreach operand oinoperands i do t getoperandtype o t mem reg imm op prime op prime t end i prime angbracketleftm op prime angbracketright normalized inst.
b prime b prime i prime end 13end 14return b prime b. identifying patched basic blocks both security and non security patches can lead to the modifications of various basic blocks and in the worst case such modified basic blocks can lie scattered all over a function.
thus spain proceeds to investigate the candidate pairs fto identify the basic blocks that are modified i.e.
patched basic blocks in the patch identify the relationships among these patched basic blocks in terms of partial traces see definition and identify their relations to the original function.
algorithm gives this procedure which computes the matched trace pairs t angbracketlefttp t1 o ... tn o angbracketright tis a partial trace in a function for each function pair angbracketleftfp fo angbracketrightinf wheretpinfpmight be relevant to t1 o ... tn o info.
in detail we leverage the pairwise basic block matching to identify the patched basic blocks within the patched function lines .
in particular for each basic block bpin the patched function fp we search for an equivalent basic block boin the original function fo.
if there is no such a matching basic block boinfo bpis identified as a patched basic block.
once the patched basic blocks are identified we proceed to determine the relationships among these basic blocks line i.e.
to connect the patched basic blocks to infer the effect of a patch.
to this end for each patched basic block we leverage the predecessor successor information to connect related patched blocks i.e.
b1 pandb2 pare connected when there is a predecessor successor relationship between them.
in such a manner patched partial traces i.e.
tp are constructed.
to get a clear understanding of how a patched partial trace tpis related to the original function we extract the unmodified first degree neighbors of the patched partial trace line .
specifically for each basic block in the patched partial trace we identify the first degree neighboring blocks that are unmodified from the original function.
these unmodified neighboring basic blocks capture the locality of the patch and help to locate the corresponding basic blocks in the original function line .
in this fashion for each patched partial trace we identify the corresponding basic blocks of interest in the original function and construct the original partial traces t1 o ... tn o in the same authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm identify partial traces input patched function fp original function fo output set of matched partial trace pairs t 1t 2bp set of patched blocks 3foreach basic block bpinfpdo foreach basic block boinfodo ifbp bothen f oundmatch tru e break end end ifnotf oundmatch then bp bp bp end 13end 14tp linearconnectedcomponents bp 15foreach patched partial trace tpintpdo neighbors getfirstdegreeneighbors tp fp 17bo getrelevantoriginalblocks neighbors fo 18to linearconnectedcomponents bo 19t t angbracketleft tp to angbracketright 20end 21returnt way to construct patched partial traces line .
example consider the original and patched functions in figure where each letter represents a basic block.
we can see that in the patched function the basic block bin the original function is modified to b primeand a new basic block g prime is added.
from the patched function only one patched partial trace can be extracted i.e.
angbracketleftb prime g prime angbracketright where its unmodified firstdegree neighbors are a c d .
by looking at the first degree neighbors of the patched partial trace we can infer that only the basic block bis the corresponding basic block of interest in the original function and only one original partial trace can be constructed i.e.
angbracketleftb angbracketright.
hence in this case the patched partial trace angbracketleftb prime g prime angbracketrightis only related to one original partial trace angbracketleftb angbracketright.
c. identifying security patches once the patched partial traces and their related partial traces in the original function are identified we proceed to determine for each pair angbracketlefttp t1 o ... tn o angbracketrightintwhether the changes are caused by a security patch or non security patch.
to this end we perform a semantic analysis on both the patched partial tracetpand the set of original partial traces t1 o ... tn o .
the idea underlying our semantic analysis is that a security patch is less likely to change the semantics of the underlying function while a non security patch is more likely to introduce new semantics .
therefore we compare the semantic summaries generated for the patched partial trace and each of the original partial traces by equation .
d sp s o dis the semantic difference between the semantic summary sp of the patched partial trace tpand the semantic summary so of the original partial trace toin t1 o ... tn o .
if there exists one original partial trace such that the semantic difference is g68 g69 g70 g71 g72 g68 g69 g182 g70 g71 g72 g74 g182 g11 g68 g12 g3 g50 g85 g76 g74 g76 g81 g68 g79 g3 g41 g88 g81 g70 g87 g76 g82 g81 g11 g69 g12 g3 g51 g68 g87 g70 g75 g72 g71 g3 g41 g88 g81 g70 g87 g76 g82 g81 fig.
an example of the original and patched functions small we mark the patch as a security patch.
otherwise we mark the patch as a non security patch.
in detail we leverage the technique in our previous work to generate the semantic summary from a partial code segment i.e.
a partial trace .
here semantics are expressed as the effects of executing the partial code segment on the machine state.
the machine state sis characterized by a tuple angbracketleftmem reg flag angbracketright denoting the memory mem the generalpurpose registers reg and the condition code flags flag .
the machine state before and after executing the partial code segment is referred to as pre state and post state respectively.
for example one possible pre state before executing the code segment in figure a is given in figure b where all registers flags and memory are assigned by the value and in the corresponding post state the registers eax and ebx hold the values 0x04 and 0x04 respectively while the sign flag sfholds the value 1due to the negative result inebx .
then the semantic summary is the difference between the pre state and post state as shown in equation .
s spost spre for example the semantic summary of the code segment shown in figure a is eax prime 0x04 andebx prime eax 0x04 where primed variables denote final values and non primed variables denote initial values.
in our semantic analysis for both patched and original partial traces we first generate various configurations of pre state and run the partial traces and measure the corresponding post state values.
then we compute the semantic summary for patched and original partial traces and compare them following the techniques in .
finally if the semantic difference is below a pre defined threshold value i.e.
d .
we determine that the patch is a security patch.
otherwise it is a non security patch.
in our experiment we empirically fix dto be .
.
example let us consider the running example in figure .
there are in total machine artifacts involved in the semantic summary computation that are register status flags and one memory location among which only three status flags sf zfandcf are influenced by the newly added instruction test eax eax in the patched partial trace.
given a fixed pre state in which all values of artifacts are set to 0but ebx to as shown in figure b the post state can be computed easily.
in the post state only the zero flag zfis set to1 while all the other artifacts keep same as the original trace.
from the pre state and post state we get authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mov eax 0x04 sub ebx eax a sample code segment pre state reg eax ebx .
.
flag zf sf .
.
mem ... post state reg prime eax prime 0x4 ebx prime 0x0 .
.
flag prime zf prime sf prime .
.
mem prime ... b pre and post state before and after executing the code segment fig.
an example of pre state and post state that the semantic difference between the patched and original partial trace is equal to .
d which implies that the patch in figure 1is a security patch.
d. summarizing patch and vulnerability patterns once the security patches are identified spain proceeds to summarize patch patterns and the corresponding vulnerability patterns from the original and patched partial traces.
to this end we introduce a light weight program analysis technique.
specifically given a patched partial trace tpand the relevant original partial traces t1 o ... tn o spain identifies the newly added and security sensitive instructions in tp.
in general newlyadded control transfer instructions especially the ones that depend on comparison instructions such as cmp andtest are of the interest for security analysts which are more likely to reflect the newly introduced sanity checks in the patch.
in the next step we pass the source and destination operands of those interesting instructions to the taint engine to track their sources and sinks that are key indicators of vulnerabilities.
for example in the instruction cmp eax ebx register ebx is the source operand and register eax is the destination operand.
in particular non immediate source and destination operands are passed to the taint engine to track their origins or sources using backward taint analysis while the non immediate destination operand is passed to the taint engine to track its destinations or sinks using forward taint analysis.
it is important to note that taint analysis is performed within the patched function i.e.
intra procedural taint analysis.
finally the tracked sources and sinks are combined to summarize the vulnerability and security patch patterns.
in figure we show the abstract vulnerability and patch patterns where source sink and sanity check are defined as follows.
definition sources taint sources are the user external inputs i.e.
tainted inputs that can reach the patched function and are used by those interesting instructions.
for example external function parameters or return values of security sensitive system apis e.g.
scanf are considered as taint sources.
definition sinks taint sinks are the security critical operations that involve the tainted inputs.
for example memory dereference operations e.g.
mov eax or arithmetic subtraction operations e.g.
mov eax sub ebx eax that involves taint sources are considered as taint sinks.
g55 g68 g76 g81 g87 g72 g71 g3 g44 g81 g83 g88 g87 g3 g11 g54 g82 g88 g85 g70 g72 g12 g54 g72 g70 g88 g85 g76 g87 g92 g16 g54 g72 g81 g86 g76 g87 g76 g89 g72 g3 g50 g83 g72 g85 g68 g87 g76 g82 g81 g3 g11 g54 g76 g81 g78 g12 g55 g68 g76 g81 g87 g72 g71 g3 g44 g81 g83 g88 g87 g3 g11 g54 g82 g88 g85 g70 g72 g12 g54 g72 g70 g88 g85 g76 g87 g92 g16 g54 g72 g81 g86 g76 g87 g76 g89 g72 g3 g50 g83 g72 g85 g68 g87 g76 g82 g81 g3 g11 g54 g76 g81 g78 g12 g54 g68 g81 g76 g87 g92 g3 g38 g75 g72 g70 g78 g71 g68 g87 g68 g3 g71 g72 g83 g72 g81 g71 g72 g81 g70 g72 g71 g68 g87 g68 g3 g71 g72 g83 g72 g81 g71 g72 g81 g70 g72 g71 g68 g87 g68 g3 g71 g72 g83 g72 g81 g71 g72 g81 g70 g72 g11 g68 g12 g3 g57 g88 g79 g81 g72 g85 g68 g69 g76 g79 g76 g87 g92 g3 g51 g68 g87 g87 g72 g85 g81 g11 g69 g12 g3 g51 g68 g87 g70 g75 g3 g51 g68 g87 g87 g72 g85 g81 fig.
abstract vulnerability and security patch pattern definition sanity checks sanity checks are operations performed on the tainted inputs before they are involved in security critical operations.
e. applications of patterns the patch patterns can be used in many applications.
one main application is to search for the similar patches and corresponding vulnerabilities in the binaries.
besides spain is orthogonal to several patch analysis tools and hence can provide patch patterns as input for them.
for example prophet can learn a probabilistic model from the correct code to automatically generate patches.
spain can provide possible locations where a patch is needed.
tedem c a n identify binary code regions that are similar to code regions containing vulnerabilities.
spain can provide such vulnerable regions through pattern matching so that tedem may have more candidates to search for.
honey patch was proposed as a trap to monitor attack information and misinform the attacker through redirecting the attack to an unpatched decoy.
spain can help to identify the patches that can be converted into honey patches making the whole process fully automatic.
a survey on repeated patches has been conducted to show the general trend of bug fixes.
spain can enable the trend analysis on a large number of programs to gain a complete understanding of how programmers fix bugs.
iv .
e v alua tion in this section we conduct an experimental study on several real world projects to answer the following research questions.
rq1 what is the accuracy and scalability of spain to identify security patches?
rq2 what are the security patch patterns and their corresponding vulnerability patterns summarized by spain?
rq3 what are the potential application scenarios of the summarized patterns of spain?
the experiments were conducted on an hp z420 workstation with 32gb ram and intel xeon cpu e5 v2 .70ghz.
all the experimental data is available at our website .
we used the following real world software in our evaluation openssl is an open source software with around number of locations loc and developed since .
linux kernel is an open source software with around loc and developed since .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i accuracy and performance on openssl ve r. cvesec.
pat.
non sec.
pat.t.p.
f.p.
t. s g.t.
iden.
g.t.
iden.
a .
a b b c .
c d .
d e .
e f .
.
f g .
.
g h .
.
h i .
.
i j .
.
j k .
.
k l l m .
.
m n .
.
n o o p .
p q .
.
q r .
r s .
sum.
.
.
adobe pdf reader is a closed source software.
we use two of its libraries 3difr.x3d andaxsle.dll which have around and functions respectively.
a. accuracy and scalability rq1 accuracy to evaluate the accuracy of spain on identifying security patches we manually identified all the security and non security patches of all the versions of openssl .
.
by analyzing its commits on github.
they were used as the ground truth to evaluate the true positive and false positive of spain.
for each security patch we also manually analyzed the type of the patched vulnerability.
table ireports the detailed results of our accuracy evaluation on openssl.
the first column lists the version numbers of two consecutive versions of openssl which are respectively served as the original and patched binaries.
the second column reports the number of cves that are documented.
the third and fifth columns respectively show the number of security and nonsecurity patches we manually identified.
the fourth column reports the true security patches spain successfully identified and the sixth column gives the false security patches spain incorrectly identified.
note that spain only reports security patches here the sixth column gives the false positive cases generated by spain.
the last three columns compute the true positive false positive and execution time of spain.
from table iit can be seen that among the security patches spain successfully identified of them while it incorrectly identified of the non security patches as security patches.
it achieved the true positive rate of and the false positive rate of which indicated that spain can identify security patches with high accuracy.
besides compared with the number of identified security patches only a small number of cves are documented which demonstrates that spain can discover undocumented patches.
moreover spain took around seconds on average to analyze the binaries.
in addition table iishows the accuracy of spain with respect totable ii accuracy on openssl w.r.t vulnerability types vulnerability type g.t.
spain accuracy buffer overflow .
null pointer dereference .
memory leak .
double free .
integer overflow .
initialization .
off by one .
side channels .
use after free others .
sum.
.
nine vulnerability types.
note that of the security patches patched some tricky vulnerabilities that do not belong to these nine common types.
the results indicate that spain can identify security patches for different types of vulnerabilities with high accuracy.
by closely looking into the security patches spain failed to identify we find two main causes for the false negatives.
first a patch is so simple that our function filtering step may fail to detect the changes.
for example one unidentified security patch in openssl simply increased the buffer size in a function by a constant value.
as a result the patched function is the same to the original one except for that particular constant.
after the basic block normalization they become the same and will not be further analyzed.
second a patch is so complicated that our semantic analysis may identify it as a non security patch due to the large amount of newly introduced semantics.
for example developers may rewrite part of a function to fix a vulnerability or some different patches happen to patch the same function.
in such cases our semantic analysis may detect significant semantic difference between the patched function and the original one failing to identify the security patch.
similarly we investigated the causes of the false positives.
one main reason is that some non security patches only slightly modify the program especially for fixing some performance bugs or adding the consideration for some missed corner cases.
for example a patch added a simple conditional statement that would be executed only when certain criteria have been met.
it follows the similar pattern of security patches since most security patches can be seen as a conditional functionality which redirects the execution to safe places if some variables have unexpected values.
therefore such kinds of non security patches are difficult to be distinguished.
we argue that false positives only have a small impact on our analysis as the number of false positive is small and a simple manual validation can identify them.
summary.
based on these observations we can positively answer rq1 that spain can identify security patches for different types of vulnerabilities with a high true positive rate as well as acceptable false positive rate.
further spain can discover security patches that are not documented.
scalability to evaluate the scalability of spain to analyze large binaries we ran spain on both open source linux kernel and closed source adobe pdf reader.
in particular we used versions .
.
and .
.
of linux kernel and compiled authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii performance on linux and adobe pdf reader v ersion total func.
sec.
patched t. s linux .
.
.
.
difr.x3d .
.
.
.
difr.x3d .
.
.
.
difr.x3d .
.
.
.
axsle.dll .
.
.
.
them using the o2 optimization level i.e.
the most common commercial setting with all the functions included.
for adobe pdf reader we analyzed the library 3difr.x3d of versions .
.
.
.
.
.
.
.
.
.
and .
.
as well as the library axsle.dll of versions .
.
and .
.
.
table iiipresents the performance of spain on linux kernel and adobe pdf reader.
the first column gives the versions of the original and patched binaries and the second column reports the average number of functions in them.
the third and fourth columns list the identified security patches by spain and the corresponding time overhead.
we can see that spain analyzed the whole linux kernel in seconds and analyzed the two adobe libraries in seconds.
note that because we do not have the ground truth for security patches we did not show the accuracy of spain on them but reported the identified security patches.
summary.
based on the results from table iii we can positively answer rq1 that spain scales well to large binaries.
b. patch and vulnerability patterns rq2 table ivpresents the vulnerability and patch patterns summarized for the key vulnerability types patched in the versions of openssl.
among them one of most common ones is double free vulnerability i.e.
an error that occurs when free is called more than once with the same memory address as an argument.
it is summarized in the first row where the memory address is obtained from an untrusted function as a return value and it is freed more than once which leads to the vulnerability.
to patch this one needs to sanity check for validity of the memory address and remove all the occurrences where it is freed for more than once.
the integer overflow underflow is summarized in the second row where it occurs when an arithmetic calculation produces a result that is greater or smaller in magnitude than that a given register or storage location can store or represent.
in general arithmetic operations are vulnerable to integer overflow or underflow when they take the inputs from untrusted sources and perform some security sensitive operation such as memory dereferencing and memory indexing on the calculated results.
to patch such vulnerable cases one needs to perform a sanity check on the untrusted inputs before allowing for any securitysensitive arithmetic operation.
the third row summarizes the use after free vulnerability pattern where the obtained pointer from an untrusted source to the memory object is freed without checking for liveness property of the pointer.
for patching such vulnerabilities one needs to check whether the object is in use if so the pointer to it should not be freed.
the fourth row summarizes null pointer dereference vulnerability the most frequently occurredvulnerability in openssl.
as discussed in section ii i ti sv e r y common to obtain a pointer from an untrusted source hence before involving it in any security sensitive operation such as memory dereferencing it needs to be checked whether the pointer is null or valid.
finally the fifth row summarizes the other most commonly observed vulnerability buffer overflow or underflow where the patch suggests that any pointer to a memory object should be properly bounds checked before involving it in any security sensitive operation.
apart from the vulnerability types summarized in table iv we observed other class of vulnerabilities patches that cannot be generalized for pattern matching.
such vulnerability types include side channel information leakage memory leakage and uninitialized variables whose patterns are particular to the openssl binaries.
however summarizing these pattern will enable us to identify clone or copy paste type vulnerabilities that are very commonly observed in the wild .
due to the space limitation we provide the vulnerability and patch patterns for such class of vulnerabilities and the patterns for linux and adobe in our website .
c. application of patterns rq3 using spain and the summarized patterns we used pattern matching techniques to discover three zero day vulnerabilities cve cve and cve in the two libraries in adobe pdf reader.
we start the experiment with an adobe reader vulnerability cve which has already been patched in .
it is a vulnerability that reads the memory out of bound due to the insufficient check on the string length of line set block.
our tool successfully identifies the patch by diffing the two versions of adobe reader .
.
and .
.
i.e.
finding the place where two additional checks have been added to the function.
after the checks the program returns to the normal execution.
therefore our tool identifies security patches with high confidence.
it is a very typical patch pattern which is the buffer overflow pattern in the fifth row of table iv.
then we use the corresponding vulnerability pattern to search for similar vulnerabilities in different versions of adobe reader.
specifically we find cve and cve having the same vulnerability pattern which later have been confirmed by manual analysis.
cve is a vulnerability in adobe reader 3difr.x3d before version .
.
.
cve also resides in 3difr.x3d while it is in version .
.
.
we also find cve which shares the similar pattern with the previous vulnerability although it is indeed an integer overflow vulnerability in adobe xslt library.
once triggered it will cause an out of bound write to the memory and remote code execution.
after adobe reader had patched the aforementioned vulnerabilities we used spain to diff the patched version with the original vulnerable version.
we successfully located the three vulnerability patches using the tool as shown in table iii which demonstrates that our tool has the capability to capture patches in closed source binaries.
a more detailed explanation of the patterns can be found at our website .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv patch patterns vs. vulnerability patterns where tnt denotes taint in denotes input and sstv denotes sensitive.
vul.
concrete vulnerability concrete patch type vulnerability pattern patch pattern double freecall bn toasn1 integer test eax eax mov esi eax ... mov esi call asn1 string clear free ... mov esi call asn1 string clear freecall angbracketleftuntrusted func angbracketright angbracketleftsanitycheck angbracketright angbracketleftreturn value angbracketright ... mov angbracketleftfunc param angbracketright angbracketleftreturn value angbracketright call angbracketleftfree angbracketright ... mov angbracketleftfunc param angbracketright angbracketleftreturn value angbracketright call angbracketleftfree angbracketrightcall bn toasn1 integer test eax eax mov esi eax ... mov esi call asn1 string clear free ...call angbracketleftuntrusted func angbracketright angbracketleftsanity check angbracketright angbracketleftreturn value angbracketright ... mov angbracketleftfunc param angbracketright angbracketleftreturn value angbracketright call angbracketleftfree angbracketright ... underflow overflowinteger mov eax ... mov ecx eax sub ecx add ecx ... mov esi mov ecx mov esimov angbracketlefttnt in angbracketright angbracketleftuntrusted src angbracketright ... angbracketleftarith op angbracketright angbracketlefttnt result angbracketright angbracketlefttnt in angbracketright ... mov angbracketleftsec sstv sink angbracketright angbracketlefttnt result angbracketrightmov eax ... mov edi cmp eax edi jl error mov ecx eax sub ecx add ecx ... mov esi mov ecx mov esimov angbracketlefttnt in angbracketright angbracketleftuntrusted src angbracketright angbracketleftsanity check angbracketright angbracketlefttnt in angbracketright ... angbracketleftarith op angbracketright angbracketlefttnt result angbracketright angbracketlefttnt in angbracketright ... mov angbracketleftsec sstv sink angbracketright angbracketlefttnt result angbracketright use after free mov ebp ... mov ebp call ssl3 release readmov angbracketlefttnt in angbracketright angbracketleftuntrusted src angbracketright ... mov angbracketleftfunc param angbracketright angbracketlefttnt pointer angbracketright call angbracketleftfree angbracketrightmov ebp ... mov eax mov eax test eax eax jnz angbracketleftdo not release angbracketright ... mov ebp call ssl3 release readmov angbracketlefttnt in angbracketright angbracketleftuntrusted src angbracketright angbracketleftsanity check angbracketright angbracketlefttnt pointer angbracketright ... mov angbracketleftfunc param angbracketright angbracketlefttnt pointer angbracketright call angbracketleftfree angbracketright dereferencenull pointer callbn new mov edi eax ... cmp eax call angbracketleftuntrusted func angbracketright ... angbracketleftmem deref angbracketright angbracketleftreturn value angbracketrightcall bn new test eax eax mov edi eax jz error ... cmp eax call angbracketleftuntrusted func angbracketright angbracketleftsanity check angbracketright angbracketleftreturn value angbracketright ... angbracketleftmem deref angbracketright angbracketleftreturn value angbracketright overflowbuffer mov ebx ... mov ebx call eaxmov angbracketlefttnt in angbracketright angbracketleftuntrusted src angbracketright mov angbracketleftfunc param angbracketright angbracketlefttnt in angbracketright ... call angbracketleftuntrusted func angbracketrightmov ebx cmp ebx jl error ... mov ebx call eaxmov angbracketlefttnt in angbracketright angbracketleftuntrusted src angbracketright angbracketleftsanity check angbracketright angbracketlefttnt in angbracketright ... mov angbracketleftfunc param angbracketright angbracketlefttnt in angbracketright call angbracketleftuntrusted func angbracketright v. d iscussion our framework has the following limitations.
first our framework tries to look for patches and vulnerabilities with patterns.
however some real world vulnerabilities are actually the corner cases which have unique signatures and patches may fix bugs in unusual ways.
spain may not be able to achieve high accuracy when dealing with these special cases in which almost all the patches are usually complex.
second vulnerabilities may be patched in some places other than the places where they are triggered.
therefore trying to hunt them from patches may not be straightforward.
our current tool can only look for vulnerabilities that are patched within the one function where the patch has been found.
in future we plan to adopt some other techniques such as function summarization more advanced slicing and symbolic execution to handle the vulnerabilities that are patched across functions.
third building a general solution for all kinds of binary architectures requires lifting the instruction into intermediate representation.
we did not do that because we want to obtain the exact patterns of the patches and vulnerabilities.
binary lifting may result in loss of a certain amount of information or inaccuracy which may be critical for our pattern summarization.
therefore throughout this work all the binaries used are in x86 32bit format.
it is worth mentioning that our approach is general and can be adapted to other binary formats.
fourth the framework shares the common drawback of static vulnerability searching approaches.
although we can identify the location of the vulnerability we cannot reproduce it inreal world if the program is too complicated.
the user input may travel through many functions and be transformed several times until it reaches the location that triggers the vulnerability.
hence we may not have a concrete proof of concept poc to validate the vulnerability whether it has a real impact on the program s security.
however unlike other searching methods since we are searching the vulnerability based on its patch we have a relatively high confidence to say that it is a severe bug which is needed to be patched.
vi.
r ela ted work our work attempts to understand patches and the corresponding vulnerabilities and summarize their patterns for discovering similar patches or vulnerabilities.
hence we discuss the related work in the areas of patch analysis and vulnerability modeling.
a. patch analysis and diffing pvdf computes the semantic of patches for privilege elevation vulnerabilities.
the patch semantic is then used to guide fuzzy testing to discover new vulnerabilities in binary programs.
it takes the vulnerable binary and the corresponding patch as the inputs and leverages forward and backward taint analysis to extract the semantics.
this work is similar to ours but it assumes the availability of patches and only focuses on one particular vulnerability type.
differently spain attempts to summarize patterns for different vulnerability types and only requires the binary programs but not the patches.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
bissam uses binary patch diffing information to develop signatures for the security update.
then it executes the binary with malicious inputs under dynamic monitoring to obtain the execution paths.
it identifies the vulnerability by determining whether the path includes one of the signatures.
its effectiveness heavily relies on the malicious inputs and assumes the availability of security patches.
differently we can automatically identify the security patches in a static way.
binhunt can automatically find the semantic differences in binary programs.
it lifts the binary instructions to intermediate representation ir and constructs cfgs at the ir level.
then it uses graph isomorphism to find the differences and performs symbolic execution on them to obtain the semantics for theorem proving.
unlike it spain is much more scalable since we apply function level filtering which enables us to search for patches in real world programs.
apart from these binary level patch analysis there are many source level approaches.
tian et al.
attempt to identify linux patches based on the commit messages and the source code diffing analysis.
they extract features and leverage machine learning techniques to predict whether a commit is a bug fix or not.
soto et al.
investigate java projects to get a deeper understanding of each patch s signature to guide automatic program repairing.
bugtrace aims at building the link between the bug and the fix through patch analysis.
kim and notkin build a diffing tool to infer the structural differences between codes which helps programmers to discover bugs by comparing two versions of a program.
these works all use patch analysis to gain the understanding at the source code level which may not work if the source code is not available.
instead spain directly works at the binary level.
b. vulnerability modeling and searching indio leverages symbolic execution to analyze binaries and detects integer overflow vulnerabilities.
it uses some heuristic patterns to find the potential vulnerability candidates.
then it ranks the vulnerable possibility for the candidates.
finally it selectively executes symbolic execution to remove the false positives further.
it discovered known cves as well as unknown integer overflow vulnerabilities in real world window binaries.
similarly intscope employs symbolic execution to detect integer overflow vulnerabilities in x86 binaries and firmalice uses symbolic execution to detect authentication bypass vulnerabilities in firmware.
brumley et al.
showed that automatic patch based exploit generation apeg was possible.
they combine dynamic symbolic execution and static control flow graph analysis to summarize the constraint formulae of the vulnerabilities which were successfully used to generate exploits for real world vulnerabilities.
gueb searches for use after free vulnerability patterns in the binary programs.
it builds an abstract memory model for the binary functions.
then it uses value set analysis to reason each variable in the assignment and free instructions.
if a variable is used after the free instruction gueb reports it as avulnerability.
it found one real world use after free vulnerability in proftpd program.
loongchecker also uses value set analysis to statically detect potential vulnerabilities in binaries.
the aforementioned works leverage program analysis methods to extract semantics of the binary program and compare them with certain models to discover potential vulnerabilities.
they require expertise to build such models specifically for a specific type of vulnerabilities.
differently our work aims at automatically summarizing the patterns for different types of vulnerabilities and using them to search for vulnerabilities.
apart from these binary level vulnerability modeling and searching approaches there are many works targeting vulnerability modeling at the source code level.
yamaguchi et al.
use a taint style pattern to search vulnerabilities and filter out irrelevant code.
it can reduce the code base by .
on average to improve the code audit efficiency.
wagner et al.
reduce the searching of the buffer overflow vulnerabilities to an integer range analysis problem which discovered vulnerabilities in the sendmail software.
averinos et al.
proposed an automatic exploit generation tool and analyzed open source programs.
they use preconditioned symbolic execution to generate control flow hijack attacks and discovered unknown vulnerabilities.
however those approaches work on the source code level but they fail to analyze binary level patches.
moreover more attention has been paid to address the gap between the source code and the compiled binaries .
the compiler will introduce bugs even if the source code is correct.
therefore we choose to work on binary level to be closer to the machine so that ideally the framework can capture all possible vulnerabilities.
vii.
c onclusion in this paper we proposed a patch analysis framework spain to automatically learn the security patch patterns and vulnerability patterns and identify them from the program binary executables.
it has built the bridge from the binary diffing to the automatic patch understanding.
the experiments have shown that spain can correctly locate more than half of the vulnerability patches in the binaries and find n day vulnerabilities in major commercial software.
spain can be useful in vulnerability and patch understanding similar bug hunting binary code auditing and eventually the program security enhancement.
in the future we plan to extend the framework to generate more detail and precise report of each patch and vulnerability through program slicing and symbolic execution as well as to make it capable of analyzing binaries with other instruction sets like arm.
also we would like to set up binary vulnerability databases with the help of the tool.
viii.
a cknowledgements this research has been supported in part by the national research foundation singapore under its national cybersecurity r d program award no.
nrf2014ncr ncr001 and partially been sponsored by the national science foundation of china no.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.