semistructured merge in javascript systems alberto trindade tavares paulo borba guilherme cavalcanti s rgio soares federal university of pernambuco att phmb gjcc scbs cin.ufpe.br abstract industry widely uses unstructured merge tools that rely on textual analysis to detect and resolve conflicts between code contributions.
semistructured merge tools go further by partially exploring the syntactic structure of code artifacts and as a consequence obtaining significant merge accuracy gains for java like languages.
to understand whether semistructured merge and the observed gains generalize to other kinds of languages we implement two semistructured merge tools for javascript and compare them to an unstructured tool.
we find that current semistructured merge algorithms and frameworks are not directly applicable for scripting languages like javascript.
by adapting the algorithms and studying merge scenarios from javascript projects on github we find evidence that our javascript tools report fewer spurious conflicts than unstructured merge without compromising the correctness of the merging process.
the gains however are much smaller than the ones observed for java like languages suggesting that semistructured merge advantages might be limited for languages that allow both commutative and non commutative declarations at the same syntactic level.
index t erms collaborative development software merging semistructured merge version control systems javascript.
i. i ntroduction in a collaborative development setting programmers often work on simultaneous tasks that involve common project artifacts source code build files etc.
.
consequently when integrating changes from independent tasks programmers might have to deal with conflicting changes.
such conflicts impair development productivity because they may cause project delays by demanding substantial effort to understand and manually resolve conflicts .
to detect and automatically resolve conflicts merge tools adopt approaches that differ in a number of dimensions two way versus three way merging state based versus operation based merging etc.
.
they especially differ on how they represent the artifacts to be merged.
industry widely uses unstructured merge tools which rely on a textual line based representation often leading to spurious conflicts false positives that waste developer effort to manually resolve them.
semistructured merge tools go further by partially leveraging syntactic information about the artifacts to be merged .
for languages such as java for instance semistructured merge represents class method and field declarations as ast nodes and merges them using tree matching and combination algorithms.
such trees however do not include full structural information.
method bodies for example are represented as plain text in leaf nodes.
so to merge bodies a semistructured tool simply uses unstructured merge line based algorithm.previous studies compare these merge approaches showing that semistructured merge reports fewer conflicts than unstructured merge.
apel et al.
report an average reduction of compared to unstructured merge.
cavalcanti et al.
replicate this study finding an average reduction of in the number of conflicts reported by semistructured merge.
considering only java projects the same authors go further and propose an improved semistructured merge tool and show that it has significant advantages over unstructured merge reduces by half the number of reported conflicts reports no false positives in addition to the ones reported by unstructured merge and has a slightly smaller number of false negatives actual non reported interference between the integrated changes .
while these results are expected to generalize to javalike languages such as c there is little evidence that they also hold for other kinds of languages including scripting languages such as javascript php and ruby .
it is also not clear whether fstm erge the underlying semistructured merge engine and framework used in the mentioned studies could also be effectively instantiated to create merge tools for such languages.
in this context to clarify these issues and better understand the practical potential of semistructured merge and the fstm erge engine we experiment with a vanilla instantiation of this engine for javascript and implement two javascript semistructured merge tools that adapt and extend fstm erge .
we then compare these tools to unstructured merge which is language independent.
from the experience with the tool implementations we find that current semistructured merge algorithms and frameworks are not directly applicable for scripting languages like javascript which support statements at the same syntactic level of commutative and associative elements such as function declarations.
in particular a vanilla instantiation of fstm erge for javascript yields an inaccurate merge tool that is inferior to unstructured merge and has no chance of practical adoption.
fstm erge was not designed to handle ordered statements for example and unordered function declarations for example program elements at the same syntactic level.
however by adapting the fstm erge engine and the input grammar we can build competitive semistructured merge tools for javascript.
this result shows that the expected smaller effort for creating semistructured merge tools one of the main advantages of semistructured merge over structured merge might not be as small as expected at least for scripting languages.
to evaluate these javascript merge tools we analyze 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
merge scenarios from javascript projects on github.
for each scenario which consists of the three revisions involved in a three way merge base left and right we replay the merge operation with the two semistructured merge tools we implemented and compare the results with the ones generated by unstructured merge.
we measure the frequency of false positives and false negatives .
we find evidence that our javascript tools report fewer spurious conflicts than unstructured merge without compromising the correctness of the merging process.
the gains however are much smaller than the ones observed for java like languages suggesting that semistructured merge advantages might be limited for languages that support both commutative and non commutative declarations at the same syntactic level.
we can then conclude that to be effectively adopted in practice semistructured javascript merge tools require substantial adaptation improvements and tuning.
ii.
s emistructured merge semistructured merge partially represents programs as trees program structure trees and uses algorithms that know how to merge nodes and their subtrees .
with fstm erge a semistructured merge tool for a given language can be created by annotating the language grammar.
the annotations specify whether a language element should be represented as a node or as plain text in leaves.
elements represented as nodes in a program structure tree are three way merged via a process called superimposition which merges trees recursively composing nodes that have the same name and type.
leaves are by default merged by traditional three way unstructured merge.
to simply instantiate fstm erge for the 5th edition of ecmascript es5 1we decided to annotate its off the shelf grammar partially shown in the following.
angbracketleftprogram angbracketright angbracketleftsourceelement angbracketright angbracketleftsourceelement angbracketright angbracketleftstatement angbracketright angbracketleftfunctiondeclaration angbracketright it defines a program as a sequence of statements and or function declarations.
first we decided to represent function declarations as nodes because fstm erge assumes that the order of nodes in a program structure tree is arbitrary and in javascript the order of function declarations does not matter as a result of hoisting.2semistructured merge can automatically solve the so called ordering conflicts like when two developers declare different functions in the same area of the program text based on this observation that the order of some elements may change without affecting the semantics of the program.
furthermore we can specify that function 1chosen for popularity reasons and for better representing scripting languages.
2hoisting is a javascript mechanism that loads variable and function declarations into the memory prior to a program execution allowing a function to be used before its declaration .
a merge scenario b unstructured merge c semistructured merge using tostring name for statements fig.
.
example of merge scenario and respective merges produced by unstructured and semistructured based on an off the shelf grammar with tostring names for statements tools declarations are non terminal nodes as function declarations may contain other function declarations.
concerning statements we initially annotate them as terminal nodes implying that their content is represented as plain text in a leaf.
in each element annotation we can specify how the corresponding nodes should be named so that they can be properly matched during the merging process.
while function declarations have a natural name the function identifier statements do not .
for instance there is no general way to properly name an ifstatement in such a manner that the corresponding element in a different revision with potential changes can be accurately matched.
by default all nodes are named with the following constant .
an alternative for statements is to name them with its textual representation specified by tostring in an annotation.
in either case using default or tostring names annotating individual statements as terminal nodes compromises the correctness of merged revisions produced by superimposition.
consider the three way merge scenario presented in figure 1a.
as shown in figure 1b unstructured merge produces the desired output integrating independent contributions from each developer and changing the first and third statements.
contrasting semistructured merge representing statements as nodes does not produce a valid merge.
using tostring naming for statements makes semistructured merge too sensitive to minor changes failing to match statements when one of them is edited by a revision.
the consequence is that any statement edited by a revision but not by the other is interpreted as a statement deletion with the old content followed by a statement addition with the new content .
issues arise as superimposition does not guarantee the order of new nodes.
differently from function declarations which are associative and commutative the order of statements is relevant once they may cause side effects.
an example of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
this problem can be seen in the generated merge in figure 1c.
the declaration of the variable host was moved to after its usage in line causing a referenceerror during runtime.
additionally if both derived revisions add changes to the same statement instead of reporting a conflict the desired result semistructured merge interprets this as deletion of the statement by both revisions and addition of new statements.
using the default name for statements in turn would cause superimposition to mistakenly match nodes that do not refer to the same statement.
the matching between terminal nodes that do not refer to the same statement from the base revision launches unstructured merge that reports spurious conflicts.
this shows that for any three way merge scenario that involves javascript programs with statements changed by both left and right revisions a vanilla instantiation of fstm erge for javascript will either report spurious conflicts or produce an invalid merge.
in section v we better illustrate how inefficient is a vanilla implementation of fstm erge for javascript.
considering those issues we opted for not including such vanilla instantiations in our empirical study they are too far from being reliable as a replacement for commercial unstructured tools.
instead we implement and evaluate new semistructured tools.
in these cases we first change the grammar to better handle statements already diverting from a vanilla instantiation that simply annotates an existing grammar in a plug in fashion .
iii.
p roposed semistructured merge tools in order to overcome some of the problems described in the previous section we first grouped consecutive statements into astatementlist element as shown in the following excerpt of our modified grammar angbracketleftprogram angbracketright angbracketleftsourceelement angbracketright angbracketleftsourceelement angbracketright angbracketleftstatementlist angbracketright angbracketleftfunctiondeclaration angbracketright angbracketleftstatementlist angbracketright angbracketleftstatement angbracketright this modified grammar is given as an input for fstm erge to support the two semistructured merge tools proposed in this paper jsfstm erge v and jsfstm erge v .
in this grammar statementlist is annotated as a terminal node so statements are no longer individually represented as nodes in the program structure tree.
instead there is only a single node for each contiguous sequence of statements separated by function declarations that is we have an opaque leaf with statements as textual content.
the difference between jsfstm erge v and jsfstm erge v come from further adaptations to the fstm erge merge algorithm.
a. jsfstmerge v1 our adapted grammar provides a more reasonable level of granularity by not representing most program elements as nodes in the tree.
however having default or tostringnames for statement lists still would cause matching issues as seen in the previous section.
to ensure statement lists are properly handled in the superimposition we first changed the original fstm erge merge implementation to assign new names to statement lists replacing the default one according to their position as child nodes.
these new names must be unique for each statement list among children of the same parent but they do not need to be unique across the full program structure tree.
our strategy to generate such names is to use incremental counters for each parent node assigning names recursively.
for a parent node its nchildren that are statement lists are respectively named stmtlist1 stmtlist2 ... stmtlistn .
with that change in the merge algorithm to name statement lists we implement jsfstm erge v which works in a consistent manner producing merged revisions that are often semantically correct.
a drawback of this version however is that it relies on the maintenance of one to one relationships between statement lists from two revisions.
when one of the new revisions introduces changes that add or remove a statementlist node from the respective program structure tree the tool might report spurious conflicts.
to illustrate that figure 2a shows an example of a threeway merge scenario in which there is no one to one mapping between statement lists from a base revision to a new revision.
in the base revision there are two statement lists at the top level.
then left removes the unused variable financepath and function getcurrenturl .
the deletion of this function makes statements which were in different statement lists in base to be in a sequence composing a single statementlist node.
on the other hand right keeps the number of statement lists at the top level just changing the content of s tmt list2.
as a result when merging left and right superimposition does not understand that the statement from s tmt list2i n base revision line is now in left within s tmt list1.
the algorithm simply interprets that left removed s tmt list2 while right edited it which causes jsfstm erge v to report a conflict figure 2c .
an unstructured merge tool is able to merge left and right without reporting conflicts figure 2b .
b. jsfstmerge v2 to avoid that type of false positive in semistructured merge we implemented another tool jsfstm erge v which handles matching and statement lists ordering by using a different approach.
instead of position based naming the strategy used by jsfstm erge v to deal with statement lists is based on a recursive operation performed on program structure trees prior to superimposition.
this operation takes for a given parent node sibling statement list nodes and concatenate them into a single statementlist node keeping the order of their statements.
the idea behind that strategy comes from the observation that as long as we keep the statements in order it does not matter their order with respect to function declarations because of the hoisting semantics.
this allows us to freely rearrange group of statements in relation to function declarations without changing program semantics.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a merge scenario b unstructured merge c semistructured merge using jsfst merge v1 fig.
.
additional false positive of jsfstm erge v figure illustrates such program transformation that is applied to revisions by jsfstm erge v during merging.
the transformed program is obtained from the base revision presented in figure 2a by joining its statement lists into a single one both programs are semantically equivalent.
a drawback of jsfstm erge v is that it potentially changes code format by rearranging groups of statements.
differently jsfstm erge v keeps the original order of elements.
as we can see in figure only the first statement list given a parent node maintains its position.
all the other statement lists are moved to after the end of the first one.
the trade off between additional false positives introduced by jsfstm erge v and code reformatting added by jsfstm erge v2 is discussed in section v. fig.
.
transformed program used by jsfstmerge v2 iv .
c omp aring merge approaches to compare unstructured merge with semistructured merge we would ideally measure how often each merge tool is able to detect interference between development contributions so that it reports interfering changes as conflicts and automatically integrates non interfering ones .
changes introduced by two developers are considered to be non interfering when they do not affect each other .
as interference is not computable in our context we adopt the study design proposed by cavalcanti et al.
.
they relatively compare unstructured and semistructured merge approaches in terms of the occurrence ofadditional false positives conflicts that do not represent interference and are reported by just one of the tools and false negatives actual interference missed by one of the tools but reported by the other .
to guide this kind of relative comparison we first manually analyzed a small sample of merge scenarios to identify considering javascript programs and our implementations categories of false positives and false negatives.
these categories were enriched along the execution of our empirical study whenever we observed new kinds of false positives and false negatives and are detailed in the following subsections.
as semistructured tools we use both jsfstm erge v and jsfstm erge v .3as unstructured tool we use kdiff3 4one of several unstructured tools available and a representative implementation of the diff3 algorithm .
a. additional false positives of unstructured merge a shortcoming of unstructured merge is its inability to identify commutative and associative elements.
for the version of javascript we consider here only function declarations due to the hosting semantics are commutative and associative.
however in the context of our jsfstm erge v semistructured merge tool statement lists can also be rearranged with respect to function declarations in particular a joined statement list node can be freely permuted with its siblings.
all this is ignored by unstructured tools which simply rely on textual analysis leading to the so called ordering conflicts.
3throughout this section for the purpose of analyzing false positives and false negatives we refer to both versions of jsfstm erge as semistructured merge tool unless a specific version is mentioned.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a merge scenario b unstructured merge c semistructured merge fig.
.
additional false positive of unstructured merge ordering conflict a merge scenario b unstructured merge c semistructured merge fig.
.
additional false positive of semistructured merge function renaming conflict to illustrate an ordering conflict figure 4a shows a merge scenario in which two developers try to add different functions sendtext andsendjson to the same area of the program text.
an unstructured merge tool reports a conflict see figure 4b .
in contrast semistructured merge identifies that each function declaration corresponds to a distinct element and yields the desired output without conflicts by superimposing the program structure trees see figure 4c .
b. additional false positives of semistructured merge as previously noted renaming is a challenge for semistructured merge.
when an element is renamed in a revision the semistructured merge algorithm is not able to detect that.
in fact it can detect that the revision does not have an element with the original name but the element could have been deleted or even renamed with body changes making it hard to accurately map the renamed element to its original version in the base revision.
to illustrate that we use the merge scenario in figure 5a.
unstructured merge does notreport conflicts as the changes introduced by revisions left and right occur in distinct text areas.
it generates a program that combines contributions from both developers using the new function name and the new function body figure 5b in the resulting program.
semistructured merge on the other hand is not able to understand that left renamed xhr .
instead the algorithm interprets the function renaming as a deletion and assumes that left deleted a function modified by right thus reporting a conflict figure 5c .
two additional kinds of semistructured merge false positives are special cases of renaming conflicts because they are all caused by the same root problem transformation of function declarations in one revision triggering deletion of nodes that are edited in the other revision.
the first one comes from the conversion in one revision of a function declaration into the assignment of a function expression to a variable.
the false positive is reported if the other revision changes the function involved in the conversion function conversion conflict .
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a merge scenario b unstructured merge c semistructured merge fig.
.
additional false negative of unstructured merge duplicate function declaration same kind of false positive is reported when the assignment is converted into a declaration.
the second kind of false positive might arise when a developer moves a function declaration into a sibling node e.g.
a statementlist .
this causes the semistructured merge algorithm to interpret such change as a deletion of the moved function.
a function declaration displacement conflict is then reported when one revision moves such a function declaration and the other revision changes the same declaration.
usually such conflicts occur when a developer moves a function declaration into an immediately invoked function expression iife .
all the aforementioned cases of additional semistructured merge false positives are reported by both jsfstm erge v and jsfstm erge v .
however as explained in the previous section there is an extra type of false positive that is exclusive tojsfstm erge v which occurs when one to one mappings between statementlist nodes are not kept.
c. additional false negatives of unstructured merge similarly to the findings obtained by cavalcanti et al.
for java systems duplicate function declarations are additional false negatives of unstructured merge for javascript.
when function declarations with the same name are added to different areas of the program an unstructured merge tool reports no conflict.
in javascript there is no function overloading or checking of duplicate function declarations when two functions no matter their formal parameters are declared with the same name within the same scope the last function declaration simply overrides the previous one .
not reporting a conflict is often a problem in such cases.
for instance consider the merge scenario in figure 6a.
unstructured merge yields a program with two error functions see figure 6b as they are declared in disjoint areas.
this program is perfectly valid for javascript interpreters but its behaviour might be disappointing for at least one of the developers responsible for the revisions.
the integrated changes interfere once the developer who introduced the first 5iife is simply a function expression either named or anonymous which is executed immediately right after its creation.
this pattern is useful to avoid polluting the global scope .function relies on the behaviour of its implementation and not on the behaviour of the overriding function.
in contrast semistructured merge is able to match the functions by name and type signature via superimposition correctly identifying a conflict see figure 6c .
function renaming can also be an additional false negative of unstructured merge.
this occurs when a developer renames a function and another developer in addition to changing its body adds a call to it by referring to the original name.
unstructured merge only detects such conflict by accident when changes occur in the same text area.
otherwise it unsoundly performs the merge and generates a program that throws a runtime error for not being able to find a function declaration.
likewise converting a function declaration into an assignment of a function expression to a variable can be an additional false negative of unstructured merge as well.
when the developer who is still relying on the hoisting property of a function declaration adds new