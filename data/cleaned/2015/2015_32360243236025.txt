datarace detectiononcompressedtraces dileepkini akunacapital llc usa dileeprkini gmail.comumang mathur universityof illinois urbana champaign usa umathur3 illinois.edumahesh viswanathan universityof illinois urbana champaign usa vmahesh illinois.edu abstract we consider the problem of detecting data races in program traces that have been compressed using straight line programs slp which are special context free grammars that generate exactly one string namely the trace that they represent.
we consider two classical approaches to race detection using the happens before relation and the lockset discipline.
we present algorithms for both these methods that run in time that is linear in the size of the compressed slp representation.
typical program executions almostalwaysexhibitpatternsthatleadtosignificantcompression.
thus ouralgorithmsareexpectedtoresultinlargespeedupswhen compared with analyzing the uncompressed trace.
our experimental evaluation of these new algorithms on standard benchmarks confirmsthis observation.
ccs concepts software and its engineering software testing and debugging formal softwareverification keywords dynamicprogram analysis racedetection compression acmreference format dileep kini umang mathur and mahesh viswanathan.
.
data race detection on compressed traces.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november 4 9 lake buena vista fl usa.
acm new york ny usa 12pages.
.
introduction dynamic analysis of multi threaded programs is the problem of discovering anomaliesin a programby examining asingle or multiple traces of a program.
while dynamic analysis is sometimes performed online as the program is running it is often performed offline onastoredtraceoftheprogram.thereasonsforperforming offlinedynamicanalysisaremany.theoverheadofanalyzingthe trace astheprogram is running maybe large causingundesirable slowdowns.thisis especiallytrue forexpensive dynamicanalysis techniques which employ heavy weight machinery such as the permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse november 4 9 lake buenavista fl usa copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
of smt solvers graph based analysis or even vector clocks .
often it is desirable to perform multiple different analyses on a single trace and the kinds of analyses to be performed may even be unknown at the time the program is beingobserved.finally storingthetraceandlaterreplayingitin acontrolledenvironment canhelpindebuggingprograms inunderstanding performance overheads and in performance tuning.
trace driven simulations are used widely in computer architecture for quantitative evaluations of newideasanddesigns .
however program traces are often huge recording millions and billions of events.
when debugging a large software application long tracesare oftennecessary toensure adequatecode coverage.
this is especially acute for multi threaded programs where subtle concurrency bugs are often revealed only under specific thread schedules.
therefore useful traces are those that exercise the same programfragmentmultipletimes underdifferentscenarios thisis substantiated by the observation that some concurrency bugs only manifest themselves in traces with millions of events .
in such circumstances the only way to alleviate the warehousing needs of storingsuch traces isto compress them .
in this paper we study the problem of detecting data races in programsbyexaminingcompressedtraces.dataracesarethemost common symptom of a programming error in concurrent programming.
the na ve approach to solving this problem would be to uncompress the trace and then process it using any one of the manyalgorithmsthathavebeendevelopedfordynamicdatarace detection .
but is this necessary?
is this na ve algorithm asymptotically the best one can hope for?
studying the complexity of problems where the input is represented succinctlyhasalonghistory.startingfromtheseminalpaperby galperinandwigderson wheretheystudiedthecomplexity ofgraphproblemswhentheinputgraphisrepresentedbyacircuit it has been observed that typically there is an exponential blowup inthecomplexityofproblemswhentheyaresolvedoncompressed inputs .thus oftenthena vealgorithmis the bestalgorithm asymptotically.
our results in this paper fortunately are the exception to the aboverule.weconsidertwoclassicalracedetectionapproaches a sound1methodbasedoncomputinglamport shappens beforerelation andthelightweightlockset basedalgorithmoferaser and extend them to work directly on the compressed trace withoutfirstuncompressingit.ouralgorithmsrunintimethatislinear inthesizeofthecompressedtrace.thus weshowthatcompression can in fact be used as an algorithmic principle to speedup the analysisinthis context.
1we say a race detector is sound if it never issues any warning on race free programs orexecutions.thisisoften referred to as precise in the race detectionliterature.
esec fse november4 9 lake buena vista fl usa dileep kini umang mathur andmahesh viswanathan public class testextends thread static final longiters 1000000000l staticinty publicvoidinc y override publicvoidrun for longi i iters i inc public static voidmain string args throwsexception finaltest t1 newtest finaltest t2 newtest t1.start t2.start t1.join t2.join system.out.println y actual y system.out.println y expected iters figure asimpleconcurrentprogram injava tounderstandwhycompressionactuallyspeedsuptheanalysis considerthe simple program shown infigure .
a singleexecution ofthisprogramgeneratesabout680millionevents takingabout1.
gbdiskspace.however whenthistraceiscompressedusingthe sequitur algorithm the compressed representation only occupiesabout34mbofdiskspace.thereasonforthiseffective compressionisthattheprogramhasasimpleloopstructurethat is executed multiple times.
thus the program trace has a regular structure that the compression algorithm exploits.
an algorithm processing the uncompressed trace is agnostic to this regularity andisforcedtorepeatthesameanalysiseachtimethesub trace correspondingtotheloopbodyisencountered.compressionmakes this regular structure visible and an algorithm working on the compressed representation can exploit it by only performing an analysisonly oncefor eachdistinct sub trace.
weconsidercompressionschemesthatcompresstracesasstraight line programs slps .
slps are a special class of context free grammarswherethelanguageofthegrammarconsistsofasinglestring namely thetracebeingcompressed.severallosslesscompression schemes like run length encoding and the family of lempel ziv encodings can be converted efficiently to slps of similar size.
ouralgorithmson slpsproceed inductivelyon thestructure of the grammar and compute in a compositional fashion bookkeeping informationfor eachnon terminalinthe grammar.thus a sub tracegeneratedbyanon terminal thatmayappear in many positions in the uncompressed trace is analyzed only once.
for happens before based race detection our algorithm is inspired by thegoldilocksmethod where thebook keepinginformation iscapturedbyasetofthreads andlocks.
we have implemented our algorithms in a tool called ziptrack .
thetracesarecompressedusingapopularslp basedcompresssion algorithm called sequitur .
our experiments on standard benchmark examples reveal that the algorithms on compressed traces performwell andonlargetraces oftenhaveanorderofmagnitude improvementoveralgorithmsrunningintheuncompressedsetting.
the rest of the paper is organized as follows.
after discussing closely related work we introduce basic notation and classical race detection algorithms in section .
in section we briefly present our happens before based data race detection algorithm on compressed traces.
our algorithm for checking violations ofthelocksetdisciplineoncompressedtracesispresentedbrieflyin section4.detailsofthesealgorithmsandtheirproofofcorrectness arepresentedinourcompaniontechnicalreport .wepresent our experimental results insection .
related work.
type systems topreventdataraces have beendeveloped .
since the race detection problem is undecidable theseveralstaticanalysistechniques sufferfromtwoproblems theydon tscaleandtheyraisemany false alarms since they are typically conservative.
dynamic race detection techniquescan beclassifiedintothree categories.there aretheunsoundlockset basedtechniques whichmayraisefalse alarms .
techniques like random testing and static escape analysis can reduce the false alarms in such algorithms but not eliminate them.
the second category of dynamic analysis techniquesarepredictiveruntimeanalysistechniques where the race detector explores all possible reorderings of the given trace to search for a possible witness of a data race.
since the number of interleavings of a given trace is very large these donotscaletolongtraces.thelastcategoryofdynamicracedetection algorithms are those based on identifying a partial order ontheeventsofatrace andthensearchingforapairofconflicting data accesses that are unordered by the partial order.
these techniquesaresoundandscaletolongtracessincetheytypically run inlineartime.
the simplest andmostcommonly usedpartial orderishappens before .earlyvector clockbasedalgorithms to compute happens before on traces have been subsequently optimized .
a lockset based method for computing the happens before partial orderwasproposed in .
structured parallelismhasbeenexploitedtooptimizethememoryoverheadin detecting happens before .
more recently partial order that are weaker than happens before have been proposed for detecting data races including causal precedence and weak causal precedence .sofya androadrunner are tools thatprovideaframeworkforimplementingdynamicanalysistools.
preliminaries in the sectionwe introduce basic notation our assumptions about concurrent programs the happens before ordering on events and someclassicalalgorithms for racedetection.
traces.wewillanalyzetracesofconcurrentprogramssynchronizingthroughlockswhileaccessingsharedmemorylocations also referredtoasglobalvariables orsimply variables .tracesare finite sequencesofeventsoftheform t o wheretisthethread performing the operation o2.
operations can be one of the following forkingofanewchildthread fork t joiningofachildthread join t acquiringandreleasingalock acq l andrel l and readingandwritingtoavariable r x andw x .wewillassume that achildthread isforked andjoined bythe sameparent thread.
locksareassumedtobe reentrant.thatis athread tmayacquirea locklmultiple times as long as tholdsl.
however tmust release l as many times as it was acquired before lbecomes available for 2formally each event in a trace is assumed to have a unique event id.
thus two occurences of a thread performing the same operation will be considered different events.
eventhoughwe will implicitlyassumetheuniqueness of eacheventina trace to reducenotationaloverhead wedo not formally introduce eventids.
27data racedetectionon compressedtraces esec fse november4 9 lake buena vista fl usa thread thread 1w x 2fork r x acq l w y rel l 7r x 8acq l 9rel l 10w y r x acq l w y rel l 15join 16w y s ab a cd c ef e w x fork f r x acq l w y rel l d r x acq l rel l w y b fg g join w y figure example trace 1and itsslp representation beingacquiredbysomeotherthread.therefore witheveryrelease evente t rel l we can associate a unique acquire event e t acq l whichisthelast acq l eventinthread tbefore ethat is not matched with any rel l event in thread tbeforee.
thisacq l evente issaidto bethe matchingacquire of e andis denoted by match e .
similarly for an acquire event e such that e match e we will say that eis the matching release of e and wewillalsodenotethisby match e .foratrace twilldenote the subsequenceofeventsperformedbythread t. notation.
let us fix a trace .
for an event e we will say e to denotethefactthat eappearsinthesequence .thesetoflocks acquired or released in will be denoted by locks .threads willdenotethesetofthreadsperformingsomeeventin inthe presenceofforksandjoins this isabit subtleandwe defineitas threads t e .e t o for some o ore t fork t ore t join t for somethread t .
foravariable x thesetof w x eventswillbedenotedby wevents x andthesetof r x eventsperformedbythread t threads will be denoted by revents t x .
we will use rd to denote the set ofpairs t x forwhich revents t x nequal .similarly wewilluse wr to denote the set of variables xfor which wevents x is non empty.when isclear from the context we maydropit.
for a non empty subset of events s we will denote by last s the unique event e s that is latest in among the events ins.
similarly first s is the event e sthat is earliest in amongsttheeventsin s.whensisempty wesayboth first s andlast s are undefined.
example .
.
we illustrate the above definitions on the example trace 1shown in figure .
we will follow the convention ofrepresentingeventsofatracefromtop to bottom wheretemporally earlier events appear above the later ones.
we use eito denote the ith event in 1. lets1 revents 1 x e3 e11 ands2 wevents 1 y e5 e10 e13 e16 .
the set rd 1 x x whilewr 1 x y .
finally last 1 s1 e11 and first 1 s2 e5.
ordersontraces.
letusfixatrace .ifanevent e1appearsearlier in the sequence thane2 then we say e1istrace ordered before e2anddenoteitas e1 tre2.wesaye1isthreadorderedbefore e2 denoted by e1 toe2 ife1ande2are events performed by the samethreadand e1 tre2.ourracedetectionalgorithmwillrely oncomputingthe happensbefore strictorder whichwedefinenext.
definition2.
happensbefore .
eventeintrace saidtohappen beforeevente denoted e hbe if and only if there is a sequenceofevents e e1 e2 e3 ...en e suchthatforeverypair ei ei i n ei trei 1andoneof the following holds.
ei toei ei t rel l andei t acq l for some t t l ei t fork t andei t o for some t t o or ei t o andei t join t for some t t o. for anyp tr to hb prefers to the partial relation p where denotes the identity relation on the events of .
when isclearfromthecontextwewilldropthesuperscriptfrom theserelations for example we willuse hbinstead of hb.
finally wesayapairofevents e1 e2areconcurrent w.r.t.happensbefore ifneither e1 hbe2 nore2 hbe1 we denote this by e1 hbe2.
wenowdefineracesidentifiedbythehappens beforerelation.
a pair of events e1 t1 a1 x ande2 t2 a2 x for some variablex issaidtobe conflicting denoted e1 e2 ift1 nequalt2andat leastoneoutof a1anda2isw.atrace issaidtohavea happens before race hb race for short if there is a pair of events e1 e2 such that e1 e2ande1 hbe2.
example .
.
we illustrate the happens before relation through thetrace 1infigure .e1 hbe3becausee2happensbeforeevery event in thread 2since it forks thread .
similarly we can conclude thate13 hbe16becausethejoinevent e15isaftereveryeventin thread2.
another interesting pair is e5 hbe10.
this is because e4 e5 e6ande8 e9are critical sections over the same lock l and thus e6happens before e8.
therefore e5 toe6 hbe8 toe10.
itisusefultopayattentiontoacoupleofconcurrentpairsofevents.
eventse3ande7areconcurrent butdonotconstitutean hb race becausee3ande7beingreadeventsarenotconflicting.however thereisan hb racebetweenevents e10ande13 theyareconcurrent andaconflicting pair ofevents.
the standard fasttrack style vector clock algorithm detects if a given trace has a race and runs in time o ntlogn andusesspace o v l t tlogn foratracewith nevents tthreads llocksand vvariables.
goldilocks algorithm.
goldilocks algorithm is another algorithm that detects the presence of hb races.
in order to formally describe the algorithm let us first fix some notations.
consider the functionafter definedas follows after e t threads e t o .e hbe t threads e t fork t .e hbe l locks e t rel l .e hbe thus informally after e isthesetofallthreadsandlocksthat have an event hb aftere.
then for every prefix of the trace and for every thread t and variable xin the goldilocks algorithm maintains the set glsr t x definedby glsr t x after last revents t x 28esec fse november4 9 lake buena vista fl usa dileep kini umang mathur andmahesh viswanathan andfor every variable xin the set glsw x after last wevents x where after undefined isassumedto be the emptyset.
finally a race is declared after observing an event esuch that one ofthe following hold e t w x and either t nelementglsw x ort nelementglsr t x for somethread t threads e t r x andt nelementglsw x .
where istheprefixuntiltheevent e.thisalgorithmrunsintime o n l tv andusesspace o tv t l foratracewith nevents tthreads llocksand vvariables.
eraser s lockset algorithm.
the lockset algorithm is a low overheadtechniquetodetectpotentialraces.thebasicideahere is to maintain for every variable x the set of locks that protect each accesstox andcheckifthissetbecomesemptyastheexecutionproceeds.
we recall the details of this technique here.
we will assume thatnoneoftheelementsintheset d t tisathread are locksusedbytheprogram.theelementsoftheset dare dummy orfakelocksintroducedbythealgorithmtoensurethatalarmsare not raised when a global variable is only read and never written to and when a variable is accessed by only one thread .
for a read write event event e t a x whereais eitherr orw in trace locksheld e is the set of locks held by twhen eis performed.
using this for an event e t a x we define lockset e to be lockset e braceleftbigg t locksheld e ifa r t locksheld e ifa w for a variables xand thread t letaccess t x be the set of all eventsin twhosecorrespondingoperationsareeither r x or w x .then lockset t x intersectiondisplay e access t x lockset e .
as per convention when access t x i.e.
thread tnever accessesthevariable x therighthandsideoftheaboveequation is assumed to be locks d. a few observations about these definitionsareinorder.first lockset t x isalwaysnon empty because t lockset t x .
second if all events in access t x arereadevents then lockset t x .thelocksetdisciplineis said to be violatedintrace if for somevariable x intersectiondisplay t threads lockset t x .
notethattheeraseralgorithmcruciallydependsupontheaccurate computation of locksheld e .
to compute this for traces having reentrant locks we need to record for each thread tand lockl thenumberoftimes lhasbeenacquired withoutbeingreleased whichcan be maintainedusing an integervariable.
we briefly highlight the importance of the locks in dthat were introduced.
let ls x t threads lockset t x .
if the variablexis only accessed by a single thread t1 thenls x is nonempty because it contains t1.
and if a variable xis only read and neverwrittento then ls x isagainnon emptybecauseitcontains .
the eraser algorithm checks for violation of the lockset principlebymaintainingthelocksetforeachthread variablepair.thread thread 1r x 2acq l 3w y 4rel l acq l r x w y rel l r x 10w z s uv u wx w r x acq l x w y rel l acq l v yz y r x w y z rel l r x w z figure example trace 2and itsslp representation itrunsintime o n l logr andusesspace o tllogr v t l wheren t landvarethenumberofevents threads locks and variables respectively and ris the maximum number of times a thread acquires alockwithoutreleasing it.
example2.
.
weillustrate thelocksetalgorithm onacoupleof examples.considerthetrace 2infigure .therelevantlocksets are as follows.
lockset 2 x 1 lockset 2 x 2 lockset 2 y 1 l lockset 2 y 2 l lockset 2 z 1 lockset 2 z 1 2 l observethat lockset 2 z isthesetofalllocksbecausethread2 doesnotaccess z.thetrace 2doesnotviolatethelocksetdiscipline.
informally the reason for this is because variable xis only read by both threads accesses to variable yis always protected by lock l and variable zis local to thread .
trace 2also contains no hb race.
for trace 1from figure lockset 1 x 1 lockset 1 x 2 lockset 1 y 1 lockset 1 y 2 l .
the lockset discipline is violated on both variables xandy.
on theotherhand thereisan hb raceonlyonvariable y events10 and13 seeexample .
.thus thelocksetdisciplinemayfalsely concludethepresenceofraces itisonlyalightweightapproximate approach.
straightlineprograms slp .
weconsidertracesthat arecompressed using special context free grammars called straight line programs slp .recallthatacontext freegrammar inchomsky normal form is g t n s r wheretis the set of terminals nthe set of non terminals t nis the set of symbols s n is the start symbol and ris the set of rules in which each rule inris eithera aora bc fora b c nanda t. a straight line program is a context free grammar such that a for every non terminal a there is exactly one rule where aappears on theleft and b thenon terminals are rankedinsuch that way that in every rule the non terminals on the right are of larger rank than the non terminal on the left of the rule i.e.
for rules a bc a banda c. it is easy to observe that the language of the grammar contains a single string namely the one that is being succinctlyrepresentedbytheslp.withoutlossofgenerality we will assume that every non terminal in the slp is useful i.e.
every non terminalinthegrammarappearsinsomesententialformin theuniquederivationinthegrammar.thus thelanguageassociated with any non terminal ahas a singlestring.
we will callthis 29data racedetectionon compressedtraces esec fse november4 9 lake buena vista fl usa unique string generated by non terminal aachunk and denote it by llbracketa rrbracket.wewilloftenabusenotationandrefertoboth llbracketa rrbracketanda as a .for example locks a willmean locks llbracketa rrbracket .
thesizeof an slp g t n s r will be taken to be t n notethatthismeasureofsizeislinearlyrelatedtoothermeasuresof sizeonemightconsiderlike r orsumofthesizesofalltherulesin r.wemakeacoupleofobservationsaboutthesizeofanslpversus thesizeofthetraceitrepresents.first everytrace e1 e2 ...en can berepresentedby a trivial slpofsize o n asfollows.
the non terminals are a i n a i n with startsymbol a .intuitively a representsthestring ei while a represents the prefix of length i. this is accomplished by the rules a eianda a a for each1 i n. second theslprepresentationofastring maybeexponentially smaller than itself.
for example take a2n.
ano n slp representation for is as follows n ai i n with rulesa0 a andai aiai.
one can inductively observe that llbracketai rrbracket a2i andso llbracketan rrbracket .
example2.
.
figure2describesanslprepresentationoftrace 1.therulesfor e f d andgarenotstrictlyintheformatofan slp butitcaneasilybeconvertedintoone therepresentationin figure2is sufficient for our illustrative purposes.
we will again useeito denote the ith event of 1. chunkerepresents e1 e2 f represents e3 e4 e5 e6ande11 ...e14 drepresents e7 e8 e9 e10 andgrepresents e15 e16.thesub tracesrepresentedbytheother non terminals can be similarly discovered.
as mentioned before wewillconfusethenotationdistinguishingbetweenanon terminal andthestringitrepresents.thus forexample threads e .
similarly theslpfor 2isshowninfigure .thesub tracesrepresented by non terminals need not conform to thread and critical section boundaries.
for example the chunk llbracketx rrbrackethas partial critical sections ofdifferentthreads.
severalwellknownalgorithmsforslpbasedcompressionare known in the literature.
the most basic and popular one is sequitur .sequiturtakesastringasaninput andgenerates an slp representing the trace.
it runs in time and space linear in the size of the input string.
the sequitur algorithm works in an online incrementalfashion itreads the input stringone character atatime andupdatestheslpgeneratedso far.
it maintainsalist ofdigrams symbolpairs that occur somewhere intheslpso far.
onseeinganewcharacter thealgorithmappendsitattheendof therulecorrespondingtothestartsymbol.thenewdigramformed byappendingthenewcharactertothelastsymboloftherule is addedtothelistofdigrams ifitisnotalreadypresent.otherwise a newrule withafreshnonterminalgeneratingthedigram isadded to the slp and every occurence of the digram is replaced by the freshlyintroducednon terminal.ateverystep non terminals that are not useful are also removed.
other popular grammar based compressionschemesincludesequential lz77 lzw bisection longestmatch andre pair .
3hb races incompressedtraces inthissection wewillpresentouralgorithmfordetecting hb races incompressedtracesrepresentedbyslps.thealgorithm srunning time will be linear in the size of the slp as opposed to algorithms analyzinguncompressedtraces withrunningtimesatleastlinear e ejt ej e e lejtt ej 1l e e ejfork t tt ej e e ejt t ej 1join t e b c a figure illustrating the various scenarios that establish ej bc hb ej .in l represents acq l l isrel l .
in the size of the uncompressed trace .
while it is very different fromtheclassicalvectorclockalgorithm itissimilarinflavorto the goldilocksalgorithm.
.
detecting cross races our algorithm will proceed inductively.
starting from the nonterminals of largest rank we will proceed to determine for each non terminal a whetherthereisan hb raceamongsttheeventsin thechunkthat agenerates.inotherwords foreachnon terminal a we will determine the predicate race?
a which is true if and only if there is an hb race between events in llbracketa rrbracket.
for a non terminal a whose only rule is of the form a a whereais an event race?
a is clearly false because llbracketa rrbracket in this case has only one event.
let usnowconsider the casewhenthe rule correspondingto a hastheform a bc wherebandcarenon terminalsofhigher rank.
if there isaracein chunk llbracketa rrbracketbetween events say eande then it is one of two kinds.
the first case is when eande both belong to chunk llbracketb rrbracketor both belong to chunk llbracketc rrbracket.
the existence of such races can be determined by computing inductively the predicates race?
b andrace?
c .
the other possibility is that e llbracketb rrbracketwhilee llbracketc rrbracket.
how we discover the presence of such cross races isthe main challenge we needto overcome.
considertwoevents e e suchthate llbracketb rrbracketande llbracketc rrbracket.suppose e bc hbe .
then there is a sequence e e1 e2 ...en e that satisfiestheconditionsindefinition .
.thus for i n we havethetraceorder ei bc trei .also e e1 llbracketb rrbracket anden e llbracketc rrbracket.thismeansthatthereexists jsuchthatforall i j ei llbracketb rrbracket and for all i j ei llbracketc rrbracket.
in other words ej ej is how the sequence e1 ...en crosses the b cboundary see figure .
observe that we have e e1 b hbejandej c hben e .
it is important to note that the relationship between eandej andej ande only depends on the events in chunk llbracketb rrbracket llbracketc rrbracket .
depending on which of the conditions and of definition .
holdfor thepair ej ej we haveone ofthefollowing either ej andej 1are events of the same thread or ejis a release event and ej 1is an acquire event on the same lock or ejis a fork event and ej 1is an event of the child thread or ejis a join event and ej isaneventof theparentthread.thesescenarios areillustratedin figure4.
thus if an event e bhappens before an event e c thenthereisacommonthreadoracommonlockthroughwhichthe 30esec fse november4 9 lake buena vista fl usa dileep kini umang mathur andmahesh viswanathan orderingis communicated acrossthe b cboundary.theconverse ofthisobservationisalsotrue.wenowmakethisintuitionprecise.
for atrace andevent e recallthe function after after e t threads e t o .e hbe t threads e t fork t .e hbe l locks e t rel l .e hbe wecan dually definethesetoflocks threadsthathaveanevent hb beforeein .
before e t threads e t o .e hbe t threads e t join t .e hbe l locks e t acq l .e hbe themainobservationthatunderliesthealgorithmisthat afterand beforesets can be used to discover hbordering between events acrosschunks.
lemma .
.
consider events e llbracketb rrbracketande llbracketc rrbracket.e bc hbe iff afterb e beforec e nequal .
lemma3.1suggests that cross races in chunk bccan be discovered by maintaining the after and before sets of data access events.
however wedon tneedtomaintainthesesetsforallaccessevents instead wecan contentofthe nextlemma.
lemma .
.
if there is no hb race in llbracketb rrbracketor in llbracketc rrbracket and if there isanhb racebetweenevents e llbracketb rrbracketande llbracketc rrbracketthen thereisan hb racebetween laste bandfirste c where laste b braceleftbigglastb revents b t x ife t r x lastb wevents b x ife t w x and firste c braceleftbiggfirstc reventsc t x ife t r x firstc wevents c x ife t w x lemma3.2suggests that in order to check for crossraces it is enough to inductively maintain the after sets of the last read write events and the before sets of the first read write events of each variable and thread.
we will denote these sets by alrd alwr bfrdandbfwr.formally alrdd t x afterd lastd revents d t x alwrd x afterd lastd wevents d x bfrdd t x befored firstd revents d t x bfwrd x befored firstd wevents d x wherewesetboth afterd undefined andbefored undefined to be .
based on all of these observations we can conclude that for a non terminal awithrule a bc we have race?
a race?
b race?
c logicalortext x wr b wr c alwrb x bfwrc x logicalortext x wr b t x rd c alwrb x bfrdc t x logicalortext t x rd b x wr c alrdb t x bfwrc x thus our race detection algorithm will be complete if we can effectively compute thesets alrdb t x alwrb x bfrdc t x andbfwrc x .we embarkonthis challenge inthe nextsection.
nextwe state the correctness ofthe race?predicate.theorem .
.
for any non terminal a race?
a trueif and only ifthereareevents e1 e2 llbracketa rrbracketsuchthat e1 e2ande1 hbe2.
example .
.
let us illustrate the ideas presented in this section throughsomeexamples.we willconsider traces 1anditsslpin figure2 and 2withits slp infigure .
we begin bygiving examples of beforeandaftersets.
aftere e1 afterc e1 l beforeg e16 beforeb e16 l afterw e1 afteru e1 l beforex e3 beforeu e3 l let us highlight the significant aspects of these examples.
aftere e1 because of e2 fork andl afterc e1 becauseofevent e6 rel l .ontheotherhand l nelementafterw e1 because there is no rel l event in chunk llbracketw rrbracket of 2 .
but when consideringthechunk llbracketu rrbracket of 2 wehavel afterw e1 because of the event e4 rel l .
next beforeg e16 because of the join event e15 andl beforeb e16 because ofacquire event e12.in trace 2 l beforeu e3 because of acquire event e2.
now let us consider the computation of cross races for the chunks in figure .
form d e f g it is easy to see that race?
m false becauseeachofthesechunksonlycontainevents of one thread.
let us look at the interesting pairs of events we considered in example .
.
the absence of race between e1ande3can be seen because alwre x andbfrdf x both ofwhichhavethethread 2incommon andthustheintersection alwre x bfrdf x is non empty.
in fact what this reasoningdemonstratesisthatthereisnoracebetweenany w x event ineand anyr x event in f. similarly the absence of a race betweene13ande16can be seen because alwrf y bfrdg y l nequal .
to reason about the events e5ande10 observe that alwrf y l andbfwrd y l both of which have thelin common.
thus we can conclude there is no racebetween any pair of w y eventscrossing the chunk fd.
ourreasoningalsorevealstheexistenceof hb concurrentevents.
for example alrdf x l andbfrdd x .
since these setsare disjoint itreveals thatthere area pair of r x events namely e3ande7 that are hb concurrent it is not a hb race because these events are not conflicting none of e3ande7is a writeevent .theracebetween e10ande13canbeseenasfollows.
alwra y andbfwrb y l .wecanseethatthereis acrossraceinchunk ab because thesetwosetsare disjoint.
.
computing beforeandaftersets our discussion in section .1suggests that if we manage to inductivelycomputethesets alrd alwr bfrd andbfwr equation foreachchunkinthegrammar thenwecanuseequation to determine if a chunk has a race.
in this section we present such an inductive computation for these sets.
we will only describe the computation of sets alrdandbfrd.
the computation of the sets alwrandbfwrissimilar andispresentedin .
the base case for non terminals with rule a a whereais anevent isstraightforward.toconservespace thisdefinitionis skippedhere butpresentedin .sowefocusontheinductive step when we have anon terminal withrule a bc.
31data racedetectionon compressedtraces esec fse november4 9 lake buena vista fl usa first consider the case of alrda t x which is equal to the setaftera e whereeis the last event amongst the read events revents a t x .
if variable xis never read by thread tin the chunk a i.e.
revents a t x we will have alrda t x .
otherwise depending upon where the last read event eoccurs in the chunk llbracketa rrbracket we have two cases to consider.
in the first case this last read event ebelongs to the chunk llbracketc rrbracket.
in this clearly e lasta revents a t x .
observe that since e e c hbe e e a hbe we have aftera e afterc e .
thus in this case alrda t x alrdc t x .
the interesting case is when reventsc t x isemptyand revents b t x nequal i.e.
thelastread eventebelongs to the chunk b. since e llbracketb rrbracket e b hbe e llbracketa rrbracket e a hbe we have afterb e aftera e .
consider e llbracketc rrbracketsuch that e a hbe .
as in the discussion on cross races in section .
this means there is a pair of events e1 llbracketb rrbracketand e2 llbracketc rrbracketsuch that e b hbe1 e2 c hbe and either e1 e2are eventsofthesamethread or e1isaforkeventand e2isanevent of the child thread or e1is an event of a child thread and e2is a join event or e1is a release event and e2is an acquire event on the same lock.
in each of these cases e1witnesses the membership of some thread lock uinafterb e ande ishb after the first event namely e2 ofuin chunk c. the definition of what it means foraneventtobe after the first eventofathread lock uissubtle andiskey inaccurately capturingthe intuitions justoutlined.
for anon terminal dandthread t define afd t afterd firstd theventsjoin d t wheretheventsjoin d t e d e t o ore t join t .
similarly for alock l define afd l afterd firstd acqeventsd l whereacqeventsd l istheset e d e t acq l .asbefore we setafterd undefined .
we nowformalize our intuitions inthe following lemma.
lemma .
.
letabe a non terminal with rule a bcand let e llbracketb rrbracket.then aftera e afterb e uniondisplay u afterb e afc u the proof of lemma .5is in our technical report .
its statementgives usthe following inductive definitionfor alrda t x .
alrda t x alrdc t x ifalrdc t x nequal alrdb t x otherwise uniontext u alrdb t x afc u notice that the secondexpressionis ifalrdb t x .
to complete the formal definition of alrda x we need to give an inductive definition for the sets af.
again defining afafor a ais straightforward and is deferred to .
consider the inductive step of a non terminal awith rule a bcand lett be some thread.
if firsta theventsjoin a t llbracketb rrbracketthen lemma .
formsthebasisofourdefinition.however itispossiblethattheset theventsjoin b t is empty while firsta theventsjoin a t llbracketc rrbracket.
inthiscase afa t afc t .asimilarreasoningappliesforalock las well.
putting alltheseobservations together we get afa u afb u uniondisplay u u afb u afc u letusnowdiscusstheinductivedefinitionoftheset bfrda t x for thread tand variable x. as before the first event e llbracketa rrbracketof the kind t r x caneitherbelongto llbracketb rrbracketorto llbracketc rrbracket.intheformercase we havebeforea e beforeb e .
on the other hand if e llbracketc rrbracket inamannersimilartothecasefor afterb e weneedto compose beforec e withthe before setsassociatedwiththe lasteventsof threads locksinchunk b. for anon terminal d threadtandlockl bld t befored lastd theventsfork d t bld l befored lastd relevents d l wheretheventsfork d t e d e t o ore t fork t andrelevents d l e d e t rel l .
the dual oflemma .5isthe following lemma.
lemma .
.
letabe a non terminal with rule a bcand let e llbracketc rrbracket.then beforea e beforec e uniondisplay u beforec e blb u using lemma .
the inductive definitionof bfrda t x is bfrda t x bfrdb t x ifbfrdb t x nequal bfrdc t x otherwise uniontext u bfrdc t x blb u to complete the algorithm we need to give the inductive definition of bla u for thread lock u. again the interesting case is theinductivecaseofanon terminal awithrule a bc.asimilar reasoningas inthe caseof afsetsgives the following definition.
bla u blc u uniondisplay u u blc u blb u thiscompletesthedescriptionofthe hb algorithmoncompressed traces.itscorrectnessisprovedin .foratrace compressedas an slp of size this algorithm runs in time o t l l tv and uses space o t l l tv wheret landvdenote the number ofthreads locksandvariables in .
example3.
.
weconcludethissectionbyshowingthatthebefore andaftersetsgiveninexample .4arecomputedcorrectlyusing ourinductivecharacterization.wewillfocusontrace 1anditsslp grammarinfigure .letusconsiderthecomputationof alwrc x .
observe that the last w x eventin cise1.further alwre x aff aff l hereaff because thereis no event ofthread in f. using theinductivedefinitionsimilartoequation wegetalwrc x l whichiscorrect.
next consider the computation bfwrb y .
notice that the first w y event in bise13 which is in the chunk f. this immediately givesbfwrb y bfwrf y l using a characterization similar to equation .
32esec fse november4 9 lake buena vista fl usa dileep kini umang mathur andmahesh viswanathan t e1 l1 e2 l1 l2 t l1 l2 e1 l1 e2 l1 lockshelda e1 l2 lockshelda e1 l1 nelementlockshelda e2 l2 lockshelda e2 t e3 l3 l3 l3 t l3 l3 l3 e3 l3 lockshelda e3 b c a figure unmatched acquire release events protect all the events of the same thread in the neighboring chunk when not matched intheentirechunk and .re entrantlocksprotecttheneighboringchunkwhentheoutermostunmatchedacquire releaseisunmatched and .
li represents acq li li isrel li .
lockset algorithm forcompressed traces similar to our algorithm for detecting hb races on compressed traces wewillformulateanalgorithmfordetectingviolationsof thelocksetdisciplineonslpsinaninductivefashion.thechallenge here again is similar violations occurring inside a chunk llbracketb rrbracketare also violations of any other chunk that contains llbracketb rrbracket and detecting cross violationsis therefore thekeychallenge.inthissection we willoutlinetheseideasindetail.
.
cross violations recallthat forathread tandvariable x lockset t x istheset ofallthelocks includingthedummylocksin d thatprotectevery access eventof xperformedby t in .
inthissection weshowhowtocompute lockseta t x forevery non terminal aand for every pair t x of thread and variable by inductingonthenon terminalsindecreasingorderoftheirrank.
checking if t threadsalockseta t x then followseasily.
thebasecasefor non terminalswithrule a aisstraightforward and is presented in .
now consider the inductive step for non terminals having rules of the form a bc.
to understand what lockseta t x will be it is useful to examine what locksheld a e for an event elooks like.
consider a data access evente llbracketb rrbracketperformed by thread t. clearly locksheld b e locksheld a e .
but are they equal?
the answer turns out to be no.
suppose a locklwhich isreleased in llbracketc rrbracketby thread tbut doesnot have amatching acquire in llbracketa rrbracket and hence neither in llbracketb rrbracket .
such a locklwillprotectalltheeventsperformedbeforeitin llbracketa rrbracket.thus trivially it will enclose all the events performed by tin chunk llbracketb rrbracket.
as a consequence lmust be included in the set locksheld a e for everyevent e b t.lockl2infigure illustratesthis.similarly for an event e llbracketc rrbracketperformed by thread t the setlocksheld a e mustadditionallyincludelockswhichhavebeenacquiredbythread tin llbracketb rrbracketbuthavenotbeenmatchedin llbracketa rrbracket seelockl2infigure .
however onemustbecareful.alock lwhichwasreleasedby tinc ateventerel l andwhosematchingacquireisin b eventeacq l does not affect the locks held by any event in b for those events e b twhichwere after eacq l lwasalready in locksheld b e whilefortheevents ebeforeeacq l ldoesnotanywayprotect e andthusl nelementlocksheld b e .thisisillustratedthroughlock l1in figure5 .
inthepresenceofre entrantlocks weneedtoaccountforanother fact.
since locks can be acquired and released multiple times a lock that is released more times in c by thread t than it is acquired in b by thread t will protect all events of tinb because theoutermostreleaseisstillunmatchedin a.thesameholdsfor locks that have been acquired more times than they are released in c.both thesescenarios are showninfigure .
to formalize the above notions we will now introduce some notation.
for a non terminal d let us first define the number of unmatched acquire eventsof lock linthread tas openacqd t l e t acq l d match e nelement llbracketd rrbracket andthe number ofrelease eventsas openreld t l e t rel l d match e nelement llbracketd rrbracket our intuitions as discussed above can then be captured for the more complex caseofre entrant locksas follows.
lemma .
.
letabe a non terminal with rule a bc.
lete b tande c t be read write events performed by threads t t .
then locksheld a e locksheld b e l openrelc t l openacqb t l locksheld a e locksheld c e l openacqb t l openrelc t l buildingonlemma .
wecannowstatetheinductivedefinition oflocksetinterms of openacq andopenrel.
lockseta t x parenleftbig locksetb t x l openrelc t l openacqb t l parenrightbig parenleftbig locksetc t x l openacqb t l openrelc t l parenrightbig the basecasefor computing lockseta t x see .
example4.
.
considertheslpfor 2fromfigure .openacq andopenrel for variousnon terminals isgiven below.
openacqw l 1openrelx l openacqx l 1openrelz l openacqu l 1openrelv l .
the values for all other combinations are .
note how the unmatched acquire in wand the unmatched release in xon thread getmatchedintheconcatenatedchunk u givingopenacqu l openrelu l .
this is essentially the insight we will explore insection .2to inductivelydefine openacq andopenrel.
let us now see how locksetcomputation takes place.
first locksetw x 1 sincetheonlyeventof xinwisaread bythread1.also locksetx y l 1 ase3isprotectedbythe unmatched release e4inx.
in chunk y locksety x 2 andlocksety y 2 interestingly the locksets for ydoes notrevealthatboth e6ande7areenclosedwithinthecriticalsection oflockl.ontheotherhand usingtheinductiveformulationdiscussedabove wecaninferthat locksetv y locksety y 33data racedetectionon compressedtraces esec fse november4 9 lake buena vista fl usa l which evaluates to 2 l as expected.
the universal set is described in .
again the lock ldoes not appear in locksetu x eventhough it is unmatched in x because it gets matched with e2inw.
this also follows from the inductive definitionoflocksetu x .
given equation our inductive formulation will be completeoncewecaninductivelycomputethefunctions openacq and openrel.we describe this next.
.
computing openacq andopenrel the base case for non terminals having rules of the form a ais straightforward and can be found in .
in the inductive case we have a non terminal awith production rule of the form a bc.
for this case let us first attempt to characterize the acquire eventsin llbracketa rrbracketthat have not been matched.
notice that if a lockisacquired withoutamatchingrelease inthechunk llbracketc rrbracket it would remain unmatched in the bigger chunk llbracketa rrbracket.
in addition the unmatched acquire events acquired in llbracketb rrbracketwhose matching release is not present in llbracketc rrbracketwill also contribute to the unmatched acquire eventsin llbracketa rrbracket.this reasoningisformalizedbelow.
openacqa t l openacqc t l max openacqb t l openrelc t l noticetheuseofthe maxoperatorinequation .ifthequantity openacqb t l openrelc t l is negative then there are more unmatched rel l eventsin c t whichshouldbeaccountedforin openrela t l insteadofaffectingthecontributionof llbracketc rrbrackettowards the unmatchedacquire eventsof a t. similar reasoninggives the inductive formulation for openrel openrela t l openrelb t l max openrelc t l openacqb t l thiscompletesthedescriptionofouralgorithmforcomputinglocksetsandcheckingviolationsoflocksetdisciplineforcompressed traces.
for a trace compressed as an slp of size this algorithm runsintime o tl logr v andusesspace o tl logr v wheret landvare the number of threads locks and variables respectivelyin andrdenotesthemaximumnumberoftimesa thread acquires alockwithoutreleasing itin .
evaluation inordertogaugetheeffectofcompressiononthesizeoftraces and thesubsequenteffectontimetakentoanalyzethesecompressed traces for races we conducted experiments on a large variety of benchmarks and evaluatedour algorithms empirically.inthissection we describe the details of our implementation and experimental setup andanalyze the results oftheseexperiments.
.
implementation andsetup implementation.
our algorithms for detecting races on compressed traces discussed in section 3and section 4have been implemented in our tool ziptrack which is publicly available at .ziptrack is written primarily in java and analyzes traces generated byjavaprograms.
ziptrack firsts collects tracelogsassequence of events which include read write to memory locations acquire releaseoflocks andjoin forkofthreads.forthis weuse the logging library provided by the commercial tool rvpredict .
after having generated the trace logs ziptrack calls the sequitur algorithm availableat tocompressthesetracesasstraightline programs see section .ziptrack then analyzes these slps to detectthe presenceofhb racesandlocksetdiscipline violations.
optimizations.
the slps generated using the sequitur algorithm arenotstrictlycnfgrammars productionrulesinthegrammarcan havelength 2aswell.thisissimilartothegrammarshowninfigure2 whereboththenon terminals fanddhaveproductionrules of length .
for detecting an hb race on slps ziptrack employs thefollowingoptimizationsthatrelyonexistenceofsuchlongproductionrules.foraruleoftheform a a1a2 ak whereeachof a1 ...akareterminals ourtool ziptrack usesaslightmodificationofthebasichbvectorclockalgorithmandusesthevectorclock values to i determine if race?
a holds and ii compute the various sets associated with a such asalrda bfrda etc.
.
next for production rules where the right hand side has both terminals and non terminalsandhaslongcontiguoussequences orsubstrings ofterminals weintroducenewproductionrulesinthegrammar withfreshnon terminals correspondingtotheselongsequences.
for example for a rule of the form a b1 bkcd1 dm where bisanddisareterminals wewillintroducetwonewnon terminals bandd with production rules b b1 bkandd d1 dk andreplacetheproductionruleof abya bcd.thisallowsus to betterexploit the vector clockoptimization.
setupandbenchmarks.
our experiments were conducted on an core2.6ghz64 bitintelxeon r linuxmachine with30gbheap space.tocompareagainsthappens beforeandlocksetbasedanalysisonuncompressedtraces weuse rapid whichimplements the standard djit vector clock algorithm epoch optimizations like in fasttrack the goldilocks algorithm and eraser s lockset algorithm as described in .
our evaluationbenchmarks column1intable arecarefullychosenwith the goal of being comprehensive and have been primarily derived from .
the first set of small sized loc benchmarks accounttopingpong is derived from the ibm contest benchmark suite .thesecondsetofmediumsized loc 3k benchmarks moldyntoraytracer isderivedfromthejavagrandeforumbenchmarksuite .thethirdset derbytoxalan ofbenchmarks loc 30k 500k comes from the dacapo benchmark suite version .
andlargerealworldsoftwareincludingapacheftpserver w3c jigsaw webserver and apache derby.columns 4and 5in table1report the number of threads locks and variables in the traces generatedfrom the corresponding programs incolumn .
.
results compression ratio.
to analyze the effect of compression on the size of traces consider the compression ratios ratio of the size of the original trace and the size of the grammar representation shown in column in table .
the compression ratios are not significant for the small and medium sized benchmarks barring boundedbuffer compression ratio .
moldyn compression ratio .
and the most notable bufwriter compression ratio 34esec fse november4 9 lake buena vista fl usa dileep kini umang mathur andmahesh viswanathan table columns describe the benchmarks and traces.
columns and describe the size of the compressed traces and thecompressionratiosachieved.columns8 10describetheperformanceofvarioushb racedetectionalgorithmsonuncompressedtraces.column11 12reportstheperformanceof ziptrack shbracedetectiononcompressedtracesandtheresulting speedup achieved.
column and report the performance of respectively eraser s lockset algorithm on uncompressed traces ziptrack sperformanceon compressed traces andtheresultingspeedupachieved.
memory grammar compr.
hb ms lockset ms program events threads locks loc.
size ratio djit f.track goldi.
compr.
speedup eraser compr.
speedup account .
airline .
.
array .
boundedbuffer .
.
.
bubblesort .2k .3k .
.
.
bufwriter .8m 20s .5s .3s .
critical .
mergesort .
.
.
pingpong .
moldyn 164k 88k .
.
montecarlo .2m 3876k .1m .
.
raytracer .2k .6k .
.
.
derby .3m 186k 735k .
26s .
eclipse .6m .2m .5m .
.6s .5s 3776s .4s .
ftpserver 49k 30k .
.
jigsaw 3m 103k 908k .
.
lusearch 216m .2m .6k .
xalan 122m .4m 71m .
.
.
the compression ratios for the large benchmarks are impressive aslargeas3.
.thiscanbeattributedtothefactthat inlargeexecutions thelargeamountofredundanciesmakethem amenable to larger compression.
despite smaller lines of code in thesourcecodeof bufwriter thesizeof the execution observed is quitelarge andthus the excellentcompressionratio.
hb race detection.
columns8 9and10intable 1representthe time taken to detect the presence of an hb race by respectively djit fasttrack and goldilocks.
column denotes the time takenbyour hb racedetection algorithmforanalyzing the traces compressedasslpsandcolumn12reportsthespeedupachieved over the bestofthe three valuesincolumns 9and10.
first inthesmallerexamples account pingpong thespeedupisnotsignificantformostexamples.thiscanbeattributedto thelowcompressionratios andsignificantinitialset uptimes.in particular the bubblesort examplehasasignificantslow down.one noteworthy small example that shows the power of compression is bufwriter wherethecompressionratioandtheresultingspeedup for racedetection isvery high 2500x .
forthe mediumsizedexamples the compression ratios range in .
.
.thespeedupfor moldynandmontecarlo isabout3 8x while for raytracer we encounter a large slowdown.
a possible explanationforthedegradedperformanceinboth bubblesort and raytracer is that while thefirst race pair e1 e2 occurs very early in the uncompressed trace the slp generated is such that in order to discover any race the entire grammarneedsto be processed.
the performance improvements for the large benchmarks are noteworthy and the speed ups shoot to the order of 100x.
thefasttrackvectorclockalgorithm isthegoldstandardfordetecting hbraces andourevaluationindicatesthatanalysisoncompressed traces beats the advantages offered by vector clocks and further epoch likeoptimizations.infactouralgorithmis inspirit closerto thegoldilocksalgorithm forwhichtheperformancedegradationdeeply intensifies on larger benchmarks also noted before in .
the speedups over fasttrack achieved by our approach despite this similarity must be attributed to the non trivial compression ratios achieved.
overall the average speed up is about .9x over fasttrack andaround 200x over the goldilocksalgorithm.
locksetviolationdetection.
columns13and14denotethetime for detecting lockset violations on uncompressed and compressed traces respectively.
since the compression on smaller examples isnotlarge wecanobservethatthespeedupinsuchexamplesis not extraordinary.
however there is little or almost no slowdown.
forthemediumandlargeexamples ziptrack detectsviolations of lockset discipline on compressed traces much faster than on uncompressed traces.
in fact the speed ups shoot upto more than 000x and the time taken is almost always of the order of a fewmilliseconds.theaveragespeed upachievedovertheeraser algorithm isaround 173x.
clearly these large real world examples illustrate the benefit of compression compression can be leveraged not only for smaller storagespaces butalsoforamoreefficientracedetectionanalysis.
conclusions we considered the problem of detecting races in traces compressed byslps.wepresentedalgorithmsthatdetect hb racesandviolations of the lockset discipline in time that is linear in the size of thecompressed traces.experimentalevaluationofour implementation of these algorithms in the tool ziptrack demonstrated that analyzing compressedtraces can leadto significant speedups.