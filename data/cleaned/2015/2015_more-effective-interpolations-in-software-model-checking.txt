more effective interpolations in software model checking cong tian zhao duan zhenhua duan and c. h. luke ongy ictt and isn lab xidian university xi an p.r.
china ctian mail.xidian.edu.cn duanzhao stu.xidian.edu.cn zhhduan mail.xidian.edu.cn ydepartment of computer science university of oxford uk luke.ong cs.ox.ac.uk abstract an approach to cegar based model checking which has proved to be successful on large models employs craig interpolation to efficiently construct parsimonious abstractions.
following this design we introduce new applications universal safety interpolant andexistential error interpolant of craig interpolation that can systematically reduce the program state space to be explored for safety verification.
whenever the universal safety interpolant is implied by the current path all paths emanating from that location are guaranteed to be safe.
dually whenever the existential error interpolant is implied by the current path there is guaranteed to be an unsafe path from the location.
we show how these interpolants are computed and applied in safety verification.
we have implemented our approach in a tool named interp checker by building on an open source software model checker.
experiments on a large number of benchmark programs show that both the interpolations and the auxiliary optimization strategies are effective in improving scalability of software model checking.
i. i ntroduction software model checking is an approach to program verification that promises accurate analysis with push button automation.
model checking approaches can achieve precision because they are path sensitive.
on the flip side because they often track too many facts state explosion gets in the way of scalability.
an extensively studied method called counterexample guided abstraction refinement cegar can automatically tune the precision of the analysis using false positives.
in a cegar analysis predicate abstraction is used to extract a coarse abstract model from a program.
the model is iteratively refined by adding facts to make the abstraction precise enough to refute spurious counterexamples.
these facts are predicates that relate values of program variables.
the scalability of cegar based analyses depends crucially on the ability to efficiently analyze a false positive so as to learn from it a small set of sufficiently accurate predicates and to use the discovered predicates parsimoniously.
to this end craig interpolation has been employed effectively to construct abstractions that are locally useful and only those that are required for proving correctness .
by integrating various techniques notably lazy abstraction and parsimonious abstraction via craig interpolation zhenhua duan is the corresponding author.great strides have been made in the development of efficient model checking that scales to large programs.
software model checkers such as blast and cpachecker have achieved impressive success in recent software verification competitions .
however see section v for details the development of precise andscalable model checking tools that are fit for real world applications remains a daunting challenge.
our approach to scalable cegar based model checking is to exploit craig interpolation to learn abstractions that can systematically reduce the program state space which must be explored for a given safety verification problem.
in addition to the interpolants for parsimonious abstraction which is called reachability interpolants in this paper for clarity we introduce two new kinds of interpolants called universal safety interpolants and existential error interpolants.
a universal safety interpolant orsafety interpolant for short is useful for determining whether all the paths emanating from a state are safe without exploring all the possible branches from it while an existential error interpolant orerror interpolant for short is useful for determining whether there exists an unsafe path emanating from a state without exploring all the possible branches from it.
the safety interpolant at a location of a control flow graph cfg collects predicates that are relevant to a yes instance of the safety verification so that whenever the safety interpolant is implied by the current path all paths emanating from this location are guaranteed to be safe.
dually whenever the error interpolant at a location of a cfg is implied by the current path there is guaranteed to be an unsafe branch from it and so one can immediately conclude that the program is unsafe.
we show how safety interpolants and error interpolants are learnt from spurious error traces throughout the cegar based program verification process.
to maximise the effect of the proposed interpolations we also present two kinds of optimizing strategies.
we have implemented the approach in a tool named i nter pchecker by augmenting the open source tool cpachecker with the proposed interpolations and the optimizing strategies.
to evaluate it a large number of experiments on more than million lines of c programs mostly linux driver programs between to kloc have been carried out.
empirical results show that the proposed interpolations are effective in reducing the explored state space so that more .
c ieeease urbana champaign il usa technical research183 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
programs can be successfully verified within the given time bound.
in particular the experiments indicate that the tool is most effective when all three kinds of interpolations and the optimization strategies are applied together.
the rest of the paper is structured as follows.
section ii presents the preliminaries and a motivating example.
in section iii we introduce error interpolants and safety interpolants and discuss their formalization and use in detail.
two optimizing strategies are then presented in section iv.
in section v we present an empirical evaluation of our approach.
finally section vi discusses related work and section vii concludes the paper.
ii.
p reliminaries this section briefly presents control flow graphs abstract reachability trees craig interpolation and an interpolationaided cegar approach to program verification with a motivating example.
a. control flow graphs acontrol flow graph cfg is a directed graph that captures the control flow of a program.
formally a cfg is a tuple g l t l f wherelis the set of program locations l02lis the initial location f2lis the final location t l ops lis the transition relation and ops is the set of instructions.
an instruction op2ops is i a basic assignment statement ii an assume predicate corresponding to the condition that must hold for the control to flow across an edge iii a function call with call by value parameters or iv a return statement.
a transition t2tis a triplet l op l0 denoting the flow of control from ltol0by executing the instruction op.
an example cfg is depicted on the lhs of fig.
.
to clearly express our approach we further decorate a cfg with three location attributes e s andrrespectively and onetransition attribute w. intuitively l e l s andl r respectively denote the e interp s interp and r interp to be defined later at a location l andt w gives the weight of the transition t. how these attributes are initialized and updated throughout the verification process will be discussed later.
b. abstract reachability trees anabstract reachability tree art is generated by unwinding a cfg.
an art a sa ea obtained from a cfgg l t l f consists of a set saof abstract states and a seteaof edges.
an abstract state s2sais a triple s l c p wherelis a location in the cfg cis the current call stack i.e.
a sequence of cfg locations representing return addresses and pis an abstract predicate indicating the reachable region of the current state.
as we shall see the reachable region i.e.
s of a state sis determined by the reachable interpolant r interp of the location s in the cfg.
given two states sands0 we saysiscovered bys0just ifs s0 s s0 ands !s0 .
notation for a tuplee we write e for thei th component of e. further ifsis covered by s0and all the future of s0 i.e.
all abstract states reachable from s0 has been explored then the future ofscan be saved from exploring because the result will be the same as the future of s0 .
an edge e2eais a triple e s op s0 wheresands0are abstract states in sa and opis an instruction in ops including assignment expression assume expression function call and return expression.
a branch path of an art denoting a possible execution of the program is a finite alternating sequence of states and edges hs0 e0 en sni such that for all i n ei siandei si .
the length of a path is the number of edges occurring in it.
given a path of an art we write pf for the path formula ssa e0 ssa en obtained from .
here ssa op is the static single assignment ssa form of an operation opwhere every variable occurring in is assigned a value at most once.
in this paper the ssa form is obtained by introducing a new subscript to a variable whenever it is newly assigned.
fig.
gives an example of an art.
c. craig interpolation given two formulas aandbsuch thata bis unsatisfiable a craig interpolant cis a formula that satisfies the following conditions aimpliesc the conjunction c b is unsatisfiable and all variables in care common to a andb.
for convenience we use c craig a b to denote the craig interpolant of formulas aandb.
in software model checking craig interpolation has been used successfully with abstraction refinement so that more precise abstractions can be constructed from spurious counterexamples in order to eliminate them.
for clarity the resulting interpolants are called reachability interpolants or r interp for short in this paper.
definition reachability interpolant r interp let hs0 e0 en snibe a spurious path of an art.
for i n set r interp si r interp si craig pf s0 si pf si sn .
note that for every locationlof a cfg initially r interp l ftrueg.
d. interpolation aided cegar verification approach we present a version of cegar safety verification that uses r interp.
the procedure starts with the most abstract model no predicates are considered and checks whether a counterexample i.e.
error path can be detected.
if no error path is found the procedure terminates reporting the nonexistence of counterexamples.
otherwise if a counterexample path is found we check satisfiability of the relevant path formula i.e.
pf to determine if is genuine.
in case pf is satisfiable the procedure terminates by reporting as a counterexample.
if pf is unsatisfiable new predicates are discovered at each location involved in according to definition .
observe that at each location of the path we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
infer the relevant predicates as an interpolant between the two formulas that define the past and the future segments of the path.
each interpolant r interp l is a relationship between current values of program variables and is relevant only at the particular location l. in the following we use an example program exa.c shown in the lhs of fig.
to illustrate how r interp aided cegar works and motivate our work at the same time.
in program exa.c if the code in line is executed the program is unsafe otherwise it is safe.
the rhs of fig.
gives the cfg of the program where l11is the error location.
thus the problem of whether the program is unsafe is reduced to the reachability analysis of l11in the cfg.
fig.
.
program exa.c and its cfg in the r interp aided cegar approach by depth first traversal of the cfg the branch p1in the art of fig.
is explored in the first run.
in fig.
we annotate each abstract state s i.e.
node of the art with the r interp r r and reachability predicate p at that abstract state i.e.r interp s f j 2rg ands .
note that for clarity if the r interp at a location is updated we ignore the element true in fig.
.
note that for every state sinp1 we haver interp s ftruegands true.
then the verification process proceeds straightforwardly to the second run wherep2is explored since l11is not reached in p1.
even though the error location is reached in p2 we need to determine if the path is genuine or spurious.
to do so we check satisfiability of the path formula pf p2 s !
a1 !
i1 s2 s1 s2 obviouslypf p2 is unsatisfiable since s2 ands2 are contradictory.
thus p2is a spurious counterexample.
as a result ther interp at each location of the cfg involved in p2 is updated and s at each state of p2is updated accordingly as illustrated in fig.
.
note that p false atl10ofp2 indicates that l10cannot be reached.
subsequently in the third run p3is explored.
when l8is analyzed it is found that l8 inp3is covered by l8inp1.
thus we can conclude that p3is not a counterexample at l8without further exploration.
this process is repeated until a real counterexample i.e.
p8 is found.
note that similar to l8inp3 l8inp5andp7are also covered by l8inp1.
in summary in fig.
in the worst case states are saved from being explored before the real counterexample p8is found.
nevertheless as we can see the explored state space is still large.
thus we are motivated to seek further reduction of the state space by using more interpolations throughout the verification process.
two ideas can be gleaned from this example.
if we already know l10inp2is unreachable thenl10inp4is also unreachable since the value of satl7 ofp4is obviously smaller than the value of satl7ofp2.
by analyzing p6 we can infer that the error location is reachable from l15ifs 3holds there.
thus when exploring l15inp7 we can conclude that a real counterexample can certainly be found if the path formula of the prefix from l1 tol15satisfies s .
iii.
m ore interpolations to further reduce the state space to be explored universal safety interpolation andexistential error interpolation which we abbreviate to s interp ande interp respectively are formalized in this section.
a. universal safety interpolation definition universal safety interpolation s interp let lbe a location of a cfg.
the universal safety interpolation orsafety interpolation for short of lis a pairs interp l f is where fis a variable with value forhindicating whether the interpolant is fullorhalf and isis a conjunction of predicates.
initialization for each location lin a cfg the default value of its safety interpolant is s interp l f false iflis an error location f true iflis a final location h true otherwise update s interp the safety interpolant at each location is updated whenever a spurious counterexample is found in an art .
let hs0 e0 en snibe a prefix of a spurious pathhs0 e0 em smiwheresnis the last reachable state andn m. for each i n the first component f value of the safety interpolant at si i.e.f si is updated by f si f ifs interp of all successors of si are full ori n h otherwise the second component i s value of the safety interpolant at si i.e.is si is updated by is si is si craig a b if0 i n and f si f is si !pf si ei si ifi n wherea pf s0 si andb pf si ei si !
is si .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
explored paths uses safety interpolants are helpful in checking whether all the paths departing from a state are safe without exploring all the possible branches emanating from it.
for any prefixpath hs0 e0 ei siiwherei we can conclude that all the paths that have as a prefix are safe if f si fandpf s0 e0 ei si !is si when applying safety interpolation in verifying program exa.c the state space explored is depicted in fig.
.
first p1is explored as usual.
when p2is explored we still check whether it is spurious and find that l7is the last reachable state.
then by the update rule of s interp we have f l7 f andis l7 true s subsequently the s interp ofl6 l4 l3andl2are also updated as shown in fig.
.
note that the s interp ofl1is not updated since the s interp ofl2is half.
after that when exploringl6ofp3 we can conclude that p3is safe since f l6 f andpf l1 l6 !is l6 holds.
here pf l1 l6 s !
a1 i1 s2 s1 andis l6 s obtained in p2 .
this process is repeated until the real counterexample p8is found.
obviously more states are saved from being explored than using only r interp as shown in fig.
.
note that in this art all the grey states unexplored reachable from the states in green are pruned because of safety interpolation.
b. existential error interpolations in contrast to universal safety interpolation existential error interpolation is for checking whether there exists an unsafe path departing from the current state without exploring all the future ones.
definition existential error interpolation e interp letl be a location of a cfg.
the existential error interpolation orerror interpolation for short at lise interp l ie where ieis a disjunction of predicates.
initilization for each location lof a cfg its default error interpolant is e interp l true iflis an error location false iflis a final location false otherwise update e interp error interpolants are also updated whenever a spurious counterexample is found.
given a spurious counterexample hs0 e0 en sniwheresn is an error location let hsi ei en sniwith i n be the maximal feasible suffix of .
thee interp of locations involved in hs0 e0 si ei siiare updated by e interp si e interp si craig a1 b1 wherea1 pf si sn e interp sn andb1 pf s0 si .
for each j i set e interp sj e interp sj craig a2 b2 wherea2 pf sj ei sj e interp sj and b2 pf s0 sj .
uses error interpolants are useful for checking whether there exists an unsafe path departing from a state without exploring all the possible branches emanating from it.
for any prefix path hs0 e0 ei siiwithi it can be concluded that there exists at least one unsafe path with being prefix if pf s0 e0 si is satisfiable and pf s0 e0 si !e interp si now we show how error interpolation is used in verifying program exa.c.
as shown in fig.
when p2is explored as a spurious counterexample we first find out the maximal authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
explored paths under r interp ands interp feasible suffixhl10 l11iofp2.
then e interp l10 is updated by e interp l10 e interp l10 craig true pf l1 l10 true then e interp s of locations l7 l6 l4 l3 andl2are updated in order e interp l7 s e interp l6 s e interp l4 s e interp l3 s e interp l2 s when exploring l15ofp7 we can conclude that there exists at least one feasible unsafe path since pf l1 l15 !e interp l holds.
here pf l1 l15 s1 a1 !
i1 s2 s1 ande interp l15 s .
the eventually explored state space is depicted in fig.
.
the states in grey are not explored while the ones reachable from the yellow state are pruned because of error interpolation.
c. interpolations together now we show how the three kinds of interpolations rinterp s interp and e interp work together to reduce state space to be explored for checking safety properties of programs.
given a cfg whose locations are enriched with default values of r interp s interp and e interp we produce the art for exploring a real counterexample by starting from the root i.e.s0 l0 true .
the flowchart in fig.
gives a bird s eye view of our approach to safety verification with reachability safety and error interpolations.
when a state s l c p is being explored and lis not an error location reversely traverse the current path for other possibilities if one of the following three conditions holds p false p6 false f l f andpf s0 s !is l or p6 false andsis covered by a visited state s0.
report the program is unsafe if p6 false and pf s0 s !e interp l .
explore the succeeding state s00 suc l c p0 otherwise.
whenlof the current state s l c p is an error location we first check whether the current path hs0 siis spurious.
if is not spurious we conclude that the program is unsafe.
otherwise by update s interp update e interp and update r interp definition the s interp e interp and r interp of locations involved in are updated respectively.
subsequently we reversely track the current path for other possibilities and treat a new current state s l c p in the same way until the program is reported as unsafe or there are no states can be explored the program is safe .
with the three interpolations working together we apply the verification procedure to the example program exa.c.
in the worst case when the program is proved unsafe we present the state space explored in fig.
.
in this figure the unexplored states reachable from a state in green are pruned because of safety interpolants and those reachable from a state in yellow are pruned because of error interpolants.
as we can see more states are saved from being explored than r interp r interp e interp or r interp s interp.
iv.
o ptimization this section presents optimizing strategies in two directions pruning and accelerating formation of full safety interpolants byweight guided search strategy.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
explored paths under r interp ande interp no y es explore state s l c p a fsa eag no y es safe y es no no no produce state s00 l00 c p00 y es adds00insa y es exist new states l is an error location p false sis covered bys0 y es no y es unsafe no spurious update e interp forward search reverse search use s interp use e interp update s interp update r interp pf q !is l f l fand pf q !e interp l fig.
.
interpolations work together a. pruning cfg when verifying real world programs there may exist some locations in a cfg which can never reach any error location.
for instance for the example program exa.c in fig.
l8 andl9in the cfg can never reach the error location l11.
to avoid exploring these locations when verifying the program we prune the cfg by removing these locations and the relative control flow edges before generating the art.
to do that we start from the error location and traverse the cfg against the flow of control in depth first order then we remove all of edges and locations which are not visited.
with the aid of such a pruning strategy the state space explored when utilizing all the three kinds of interpolations shown in fig.
can be further reduced by eliminating the suffix of p1starting from l7 as depicted in fig.
.
b. weight guided search strategy as discussed in the previous section a safety interpolant works only when it is full.
hence the earlier full safetyinterpolants are formed the better the effect will be.
theintuition is that if one side of a branch is explored we expect to explore the other side as early as possible so as to form full interpolants.
to achieve the goal we introduce an attribute weight to transitions of a cfg.
when generating an art the branch with the largest weight will be explored first.
note that the default weight value of each transition of a cfg is undefined denoted as ?
.
throughout the verification process for a transition t l op l0 we reset weight t iff l0 is changed from htof weight t jf l0 j l0 is a succeeding transition oftgj 1ifl0is the last reachable state in the current path of the art and f l0 h. weight t weight l0 ?
weight l0 jf l0 jweight l0 ?gj for anyt l op l0 if the weight value of some transition departing from l0 is changed.
note that a weight value can be an integer larger than denoted ?
and .
here we decree ?
.
if the weight values of all the possible transitions are the same we just randomly explore one the them.
as an example for the cfg in fig.
the weight of all edges are undefined initially.
when p1is explored as shown in fig.
the weight of all the reachable edges are updated.
then p2 is explored as shown in fig.
.
since l11is unreachable no weights are updated.
subsequently in the third run p3 the real counterexample is explored under the rule since the weight values of both l2 s l and l6 !
a l are?while those of their opposites are both .
note that without the guidance of weight values in the worst case paths are required to be explored in order to find the real counterexample.
v. i mplementation and experiments we have implemented the proposed interpolations and optimization strategies in a tool called i nterp checker authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
explored paths with all interpolations fig.
.
explored paths by pruning strategy by building on the open source software model checker cpachecker abe configuration which supports reachability interpolation aided cegar verification.
our tool augments cpachecker with safety interpolations and error interpolations as well as the optimizing strategies proposed in section iv.
note that abe configuration of cpachecker combines predicate abstraction with cegar to verify the programs.
almost all of the new features some of them are not publicly available of cpachecker are also implemented based on this configuration.
to evaluate the proposed interpolations in the safety verification of programs we selected packages as shown in table i from the benchmark suite of sv comp1where a large number of programs cannot be successfully verified within a specified time bound.
these packages constitute the category device drivers linux in sv comp.
experiments in this paper were done on a linux virtual machine which is configured on a pc running octa core windows with ghz and 64gb ram.
the virtual machine applies ubuntu .
lts operation system with 4ghz and 4gb ram.
table i describes the results of the original cpachecker abe and another three tools smack corral uautomizer and satabs which perform well in the competitions.
the third column of table i gives the number of programs contained in each package and the fourth column gives the total number of lines of programs in each package.
the remaining four columns give the respective numbers of programs which are successfully verified in mins using cpachecker abe smack corral satabs and uautomizer.
as shown in table i cpachecker abe performs best with still .
of the programs fail to be verified within the time bound.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
exploration with weight table i benchmark programs no.
package names programs kloccpachecker abe smack corral satabs uautomizer suc.
suc.
suc.
suc.
ldv linux .
.
.
ldv challenges .
ldv validator v0.
.
ldv validator v0.
.
ldv linux .
rc1 .
ldv linux .
.
ldv consumption .
ldv commit tester .
ldv linux .
rc1 .
ldv linux .
rc1 .
ldv linux .
simple .
total .
.
.
.
.
the most recent sv comp competitions also show that cpachecker was the strongest performer on this category2.
hence we benchmark the performance of our implementations of safety interpolations and error interpolations against cpachecker abe .
by comparison with cpachecker abe it can embody directly the advantage of our approach.
note that the result of cpachecker presented in table i might be inconsistent with the one reported in the competitions because of different experimental environment.
to examine the effectiveness of the various interpolations we verify the programs in table i using our tool in different modes namely r e r s r s e r s w and r s e w where r e and s denote r interp e interp and sinterp respectively and w indicates the weight guided search strategy.
recall that weight based searching strategy is only for the formation of safety interpolants.
table ii presents the verification results where the sub column suc.
gives the number of programs that are verified successfully and the sub column t.o.
gives the sum of programs that failed to be verified within the time bound of mins.
it is emphasized 2this category is not included in sv comp .that a program is successfully verified with a tool indicates that the verification results safe or unsafe is correctly reported within the given time bound.
that is false positives or false negatives are not counted in the sub column suc.
from the experimental results we observe that verification using each of r e r interp ande interp and r s r interp ands interp is more accurate than verification using only r r interp .
more programs are verified using r s e than either r e or r s. verification using r s w is more accurate than r s. verification using r s e w is the most accurate.
thus we can say that each of the proposed interpolations and the optimization strategies improves the accuracy and hence effectiveness of program verification.
further false positive may occur in principle since the interpolations are overapproximations of a program.
however our experience shows that smtinterpol tool for computing craig interpolation in cpachecker always produces good predicates in practice.
in the experimental results no false positives are introduced because of the new interpolations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii comparing with r no.r cpachecker abe r e r s r s e r s w r s e w suc.
t.o.
suc.
t.o.
suc.
t.o.
suc.
t.o.
suc.
t.o.
suc.
t.o.
total1424 .
.
.
.
.
.
.
.
.
.
table iii time consumption no.time consumption s r r e r s r s e r s w r s e w .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
in addition to the number of programs which are successfully verified with different kinds of interpolations we are also interested in the ratio of programs successfully verified using s interp and e interp to those successfully verified using the original cegar r interp cpachecker abe .
similarly we are interested in the ratio of programs that fail to be verified using s interp ande interp to those that fail to be verified using the original cegar r interp.
fig.
a shows the percentage n suc of the programs verified under each mode and fig.
b shows the percentage n fail of the programs that fail to be verified under each mode.
note thatnsucis the number of verified programs in the respective modes from the original set of r interp verified programs and nfailis the number of the unverified programs in the respective modes from the original set of r interp unverified programs.
as shown in fig.
a of the programs verified under r interp remain successfully verified under each of r e r s and r e s modes and .
of them remain successfully verified under r s w and r e s w. the rate is lower than the modes without weight guided searching strategy since the order in which the branches are explored are changed.
as shown in fig.
b the ratios of the unverified programs under r e r s and r e s to the unverified programs under rare in descending order and the rate is lower when the weight strategy is utilized.
we also compare the time consumption of each mode.
as shown in table iii r e and r s take less time than r r e s takes less time than both r e and r s r s w takes less time than r s and r s e w takes less time than all others.
thus both the interpolations and the optimization strategy are useful in improving the runtime efficiency of software model checking.
vi.
r elated work in recent years craig interpolation has been extensively applied to software model checking symbolic execution and testing.
an important advantage of these applications is a much reduced program state space.
a. program verification in pioneering work mcmillan computes interpolants to build unbounded symbolic model checking of finite state systems according to the refutations counterexamples produced in bounded model checking.
the approach was extended to the verification of infinite state systems in by employing lazy abstraction to refine the abstract model on demand thus producing a sequence of interpolants according to spurious authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
experimental results counterexamples.
vizel and grumberg then applied the idea of interpolant sequence to sat based unbounded model checking.
a three step interpolant computation process was proposed by cabodi loiacono and vendraminetto to reduce the size of the generated craig interpolants in satbased unbounded model checking.
it improves over standard interpolation by reducing memory and time.
chu and jaffar proposed a framework to synergize partial order reduction with state interpolation so as to reduce the state explosion problem in the safety verification of concurrent programs.
wachter kr oning and ouaknine combined lazy abstraction with interpolants and partial order reduction when a spurious counterexample is found craig interpolation is used to refine and adjust the precision.
the approach by brillout et al.
uses an expressive interpolating calculus that extends to the full theory of quantifier free presburger arithmetic with uninterpreted predicates.
this setting enables the synthesis of quantified invariants about arrays.
the algorithm whale introduced by albarghouthi et al.
uses interpolation to compute a function summary by generalizing from an under approximation of a function.
it can verify recursive programs and produce modular safety proofs.
cardinalityconstrained extension of craig interpolation is proposed by von gleissenthall et al.
to synthesize formulas that satisfy a given cardinality constraints based on cegar.
in it casts the new concept of error invariants for fault localization.
an error trace provides sufficient information to repeat the program s behavior that violates the correctness assertion.
in order to localize the cause of an error efficiently it uses errorinvariants to rule out irrelevant transitions from an error trace and compact the actual cause of an error.
error invariants are also computed by craig interpolants.
the work in extracts interpolants in both forward and backward manner and exploits them for an interwined approximated forward and backward reachability analysis.
it applies craig interpolants to obtain useful information that is computes forward and backward interpolants.
in this paper error interpolants represent an overapproximation of the pre image of the bad states.
we extract the useful information from spurious counterexample paths by craig interpolants.
b. abstraction refinement based verification henzinger et al.
have successfully applied craig interpolation to efficiently construct given an infeasible abstract error trace a refined abstraction that removes the trace.
the approach has been integrated into an explicit value analysis which tracks explicit values for a specified set of variables by beyer and l owe .
they use craig interpolation to refine spurious counterexamples in order to construct more precise abstractions of the explicit value domain.
in this paper we refer to interpolants thus employed in as reachability interpolants.
the difference is that we additionally compute safety interpolants and error interpolants from spurious counterexamples so as to further reduce the state space to be explored when verifying safety properties of programs.
c. symbolic execution and testing in jaffar murali and navas applied interpolations to program testing to subsume paths with similar actions.
in symbolic execution when the search fails to reach a goal an annotation on the cfg of the program called lazy annotation is constructed by craig interpolation.
these notations are used to check whether the current state can reach the goal .
vii.
c onclusion in this paper we have introduced new applications of craig interpolation designed to systematically reduce the program state space to be explored in safety verification.
experiments on a large number of benchmark programs show that the new interpolants and the auxillary optimization strategies are effective in improving scalability of software model checking.
in future work we plan to develop further optimization techniques and extend our approach to verify liveness properties of programs.
an important problem is the reduction of overheads in the construction of interpolants throughout the verification process.
acknowledgement this research is supported by the national natural science foundation of china under grant no.
and .
the work was done partially while duan and ong were visiting the institute for mathematical sciences national university of singapore in .
the visit was partially supported by the institute.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.