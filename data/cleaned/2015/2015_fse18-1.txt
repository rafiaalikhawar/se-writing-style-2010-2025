symbolic execution with existential second order constraints sergey mechtaev national university of singapore singapore mechtaev comp.nus.edu.sgalberto griggio fondazione bruno kessler italy griggio fbk.eu alessandro cimatti fondazione bruno kessler italy cimatti fbk.euabhik roychoudhury national university of singapore singapore abhik comp.nus.edu.sg abstract symbolic execution systematically explores program paths by solving path conditions formulas over symbolic variables.
typically the symbolic variables range over numbers arrays and strings.
we introduce symbolic execution with existential second order constraints an extension of traditional symbolic execution that allows symbolic variables to range over functions whose interpretations are restricted by a user defined language.
the aims of this new technique are twofold.
first it offers a general analysis framework that can be applied in multiple domains such as program repair and library modelling.
secondly it addresses the path explosion problem of traditional first order symbolic execution in certain applications.
to realize this technique we integrate symbolic execution with program synthesis.
specifically we propose a method of second order constraint solving that provides efficient proofs of unsatisfiability which is critical for the performance of symbolic execution.
our evaluation shows that the proposed technique helps to repair programs with loops by mitigating the path explosion can enable analysis of applications written against unavailable libraries by modelling these libraries from the usage context.
ccs concepts software and its engineering automatic programming software testing and debugging keywords program synthesis program repair library modelling acm reference format sergey mechtaev alberto griggio alessandro cimatti and abhik roychoudhury.
.
symbolic execution with existential second order constraints.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
introduction symbolic execution se is a widely used program analysis technique that has found many applications including automated test generation software verification input filtering program debugging and program repair .
in symbolic execution program inputs are assigned symbolic variables instead of concrete values.
the result of executing a program with symbolic inputs is a set of constraints over these symbolic variables called path conditions.
path condition of a program path captures all inputs that would drive the execution along this program path.
symbolic variables used in existing symbolic execution systems typically range over numbers arrays and strings.
we introduce symbolic execution with existential second order constraints se esoc that extends traditional symbolic execution by allowing symbolic variables to range over functions.
a function in a program can be marked as symbolic via a second order symbolic variable.
then the goal of se esoc is to synthesize an interpretation of this function that satisfies certain reachability properties of the analyzed program the properties depend on the application .
se esoc collects constraints on second order variables and solves them through program synthesis.
example .
.
assume that search data pred returns the index of an element of the array data that satisfies the predicate pred .
consider the question what predicate would make search return given the array ?
.
se esoc can answer this question by executing search symbolically with a second order variable and synthesizing e.g.
b x.x .
contrary to works utilizing the theory of uninterpreted functions se esoc aims to discover implementations of symbolic functions.
thus se esoc takes in a language of interpretations for second order variables.
similar to the syntax guided program synthesis approach a language of interpretations is defined in our approach via a context free grammar and a size bound.
applications.
in this work we describe two applications of seesoc an application to program repair and a novel application to library modelling from the usage context.
in the context of program repair suspicious statements in the buggy program can be replaced with second order symbolic variables.
thus a fragment of code in a program can be abstracted as a second order symbolic variable.
instantiations of the second order variable then amount to alternate code fragments to replace the current one thereby bringing out the connection between se esoc and program repair.
se esoc 389esec fse november lake buena vista fl usa s. mechtaev a. griggio a. cimatti a. roychoudhury size t search int data size t len int pred int size t i for i i len i if pred data return i return len a search function.inputs 1 2 3are integer variables int pos int x return x search int 1 2 3 pos symbolic execution results path condition input output 1 1 2 1 2 3 1 2 3 b traditional se.input is a functional second order variable search int symbolic execution results path condition input output x.true x.x x.x x.false c se esoc.
figure testing search function via traditional se and se esoc.
can directly synthesize a patch by finding interpretations of the symbolic functions.
in the context of library modelling se esoc can enable symbolic analysis of applications written against unavailable libraries this might be useful for example for analyzing partially released applications with proprietary software components .
specifically unknown library functions can be replaced with second order symbolic variables which can be complemented with library sketches.
then se esoc can synthesize a model of the library by analyzing how the library is used inside the application.
in both of these applications se esoc synthesizes interpretations of second order variables that enable the reachability of test assertions which is equivalent to passing the tests.
addressing path explosion.
the proposed technique alleviates the path explosion problem in program repair algorithms relying on first order symbolic execution.
program repair techniques such as semfix and angelix split patch generation into two steps.
first they replace suspicious statements with first order symbolic variables and infer specification via symbolic execution.
as a second step they synthesize patches that satisfy the inferred specification.
an important limitation of these approaches is that they have to potentially explore an infinite number of paths e.g.
if the suspicious statements are inside a loop.
however by raising the order of path constraints we can efficiently prune irrelevant paths.
the pruning is achieved by avoiding paths that are infeasible in the context of considered language of interpretations the space of patches .
technical challenges and solutions.
to implement se esoc it is sufficient in principle to apply a syntax guided synthesizer for solving queries with second order variables.
however existing synthesis algorithms are not suitable for this application.
smt solvers used in symbolic execution engines cannot solve the considered kind of second order constraints however our goal was to support second order variables without switching to a specialized solver.
the reason for not switching to specialized solvers is that we might have second order variables as well as first order variables in various theories in a single path condition.
then a suitable approach to support second order variables is to encode second order formulas through first order formulas as proposed by jha et al.
.
however our experiments demonstrated that the mentioned encoding provides highly inefficient unsatisfiability proofs.
meanwhile the performance of symbolic execution critically depends on the performance of unsatisfiable queries for on the fly pruning of infeasible paths.
to address the above challenges we introduce a newmethod of second order constraint solving that relies on propositional encoding which substantially improves the efficiency of unsatisfiability proofs compared with previous techniques.
contributions.
the contributions of this work are the following.
first we introduce se esoc an extension of symbolic execution that allows symbolic variables to range over functions whose interpretations are restricted by a user defined language.
secondly we propose a method of second order constraint solving based on propositional encoding that provides efficient unsatisfiability proofs.
finally we conduct an evaluation that demonstrates that in the context of program repair se esoc helps to repair programs with loops by alleviating the path explosion and in the context of library modelling se esoc can enable analysis of applications written against unavailable libraries by modelling them from the usage context.
overview this section describes second order formulas considered in this work the difference between traditional se and se esoc an application of se esoc to program repair and an application of se esoc to library modelling.
.
second order formulas we view second order constraint solving as an instance of program synthesis .
formally we consider second order formulas with existentially quantified second order variables and a henkin nonstandard semantics of satisfiability definition .
.
specifically each second order variable is associated with a domain of interpretations defined via a user provided language.
example .
.
assume that is a second order variable whose domain is restricted by the language lia defined as follows term var constant term term term term constant term then is satisfiable by b x. x while is unsatisfiable since all functions in lia are monotonic.
since we rely on a non standard semantics of satisfiability we cannot use the theory of uninterpreted functions supported by most smt solvers as in previous works .
thus we have to add support for this semantics in an existing smt solver.
to make the problem more tractable we bound the size of interpretations by a user defined constant d. however even with this restriction 390symbolic execution with existential second order constraints esec fse november lake buena vista fl usa scanf d x for i i i int t x i if t printf else printf a buggy program.scanf d x for i i i int t if t printf else printf b symbolic state.scanf d x for i i i int t i x if t printf else printf c symb.
function.
1b 1 2 ... 2b 1 2 ... 3b 1 2 ... d first order pcs.
1b ... 2b ... 3b ... e second order pcs.
figure repairing program using different approaches.
an integration of second order solving with symbolic execution remains challenging since existing synthesis algorithms are not optimized for unsatisfiable queries .
this motivated us to design a new smt based synthesis method described in section .
.
.
comparing se esoc with traditional se consider the function search in figure 1a.
this function takes an array data a value lenrepresenting its length a pointer to a predicate function pred and returns the index of the first element of the array that satisfies the predicate.
in traditional symbolic execution numeric inputs are replaced with logical variable as shown for the elements 1 2 3of the array in figure 1b.
assume that the predicate pred is a function posthat checks if a given value is positive.
in this context symbolic execution explores four paths as shown in the table in figure 1b in which the path conditions are constraints over the variables 1 2 3. the corresponding test inputs are concrete values of the elements of the array and .
in contrast to traditional symbolic execution se esoc enables us to explore possible program executions depending on the definition of the predicate pred .
assume that pred is represented by a variable for which the language of interpretations is as follows boolterm term term term term term term true false where term is defined in example .
.
then the path conditions are constraints over as shown in the table in figure 1c.
the corresponding test inputs are interpretations of x.true x.x x.x and x.false.
note that it is possible to combine first order and second order symbolic variables in the same symbolic execution session by executing search int 1 2 3 .
then the synthesized predicates will be parameterized by the variables 1 2 3. .
application to program repair the goal of program repair is to modify a buggy program to eliminate the observable failures.
its important subtask is to fill a hole in the program e.g.
replace a buggy statement to enable the program to satisfy the requirements e.g.
to pass the tests .
we review existing approaches to solve this subtask relying on traditional se and show how se esoc addresses their limitations.void main int argc char argv int a atoi argv printf d n a a program pusing atoi.p p b tests.
int accumulation char arr int acc i for i i strlen arr i acc acc arr return acc c sketch of atoi.
b xy.
10x y d model.
figure library modelling from usage context.
consider a program pin figure 2a that reads a number performs loops iterations and at each iteration prints or depending on the sign of the variable t. for instance for the input it prints .
assume that the correct output should be and our goal is to repair the program by replacing x iwith an expression from lia defined in example .
that would enable the program to pass the test e.g.
x i .
semantics based repair approaches infer a specification using symbolic execution and synthesize a patch based on this specification.
first they replace the identified buggy expression with a symbolic variable as shown in figure 2b.
then they symbolically execute the program with the input and infer path conditions 1 2 ... 1024shown in figure 2d.
finally a patch is synthesized by solving the following second order formula e term .
i i stdout where stdout is a variable that captures the standard output of the application i is a formula obtained from iby substituting with the term e. such techniques suffer from the path explosion problem.
for instance there are loop iterations and therefore the algorithm has to explore paths as shown in figure 2d.
we now demonstrate how se esoc can be used to address the aforementioned limitation of previous techniques.
instead of using first order variables to infer synthesis specification we replace the buggy statement with a symbolic function as shown in figure 2c.
then se esoc is applied to directly synthesize a patch by finding an interpretation of that satisfies a test passing path.
the key benefit of this approach is that it substantially reduces the number of explored paths.
for the described example it will explore at most execution paths as shown in figure 2e and the rest of the paths are infeasible which can be non constructively proven as follows.
proof.
there are totally possible execution paths.
among them paths consist of clauses ... i i ... or ... i i ... for some i that is changes its sign once with the increase of its first argument.
meanwhile the other paths contain the clauses l n m or the clauses l n m for some l n m that it changes its sign at least twice with the increase of its first argument.
all these path conditions are unsatisfiable since for any term x. x is monotonic.
391esec fse november lake buena vista fl usa s. mechtaev a. griggio a. cimatti a. roychoudhury lo1 lo2lo3 lo4li1 4li1 li2 3li2 3xy lo5li1 li2 a circuit of term x y below are locations .lo1 lo2 lo3 lo4 li2 li1 b l variables.
figure encoding via integer location variables.
note that monotonic functions in this example are given for clarity.
our approach does not rely on monotonicity and is effective in more general cases as shown experimentally in section .
.
se esoc enables a reduction of the number of explored paths since it takes the language of symbolic function interpretations into account i.e.
it is syntax guided .
the reduction of the number of explored paths has important implications since it might increase the efficiency of program repair or increase the probability of finding a patch when repairing programs with loops.
.
application to library modelling real world applications rely on libraries and frameworks which complicates analysis of these applications.
we consider the scenario when a library used in the analyzed application is unavailable e.g.
proprietary as in .
se esoc can be applied to synthesize an approximate model of the library from the usage context i.e.
by analyzing how the library should behave to satisfy certain properties of the application e.g.
pass given tests .
then this model can be used to perform symbolic analysis of the application.
consider a program pin figure 3a.
this program uses a function atoi from the standard library to parse the command line argument.
assume that the standard library is not available then it is impossible to symbolically analyze the program since atoi affects the input output relationship.
se esoc can address this problem by synthesizing a model of the function atoi from the usage context using existing tests given in figure 3b.
to synthesize a model it is sufficient to replace the function call with a second order functional variable and find an interpretation as explained in section .
.
however this approach scales to only relatively simple models.
to make the technique more practical we complement it with sketches of unknown functions.
for example since atoi takes an array and returns a number we provide a generic accumulator sketch that iterates through the array and applies a symbolic function at each iteration figure 3c .
then se esoc can synthesize an interpretation of this function the body of the loop that is sufficient to pass the tests e.g.
the function in figure 3d is the ascii code of .
this model can be used to perform symbolic analysis of the application e.g.
to generate a new input that triggers a division by zero error.
background jha et al.
proposed to semantically encode a space of terms using linear integer arithmetic constraints.
in this approach terms are represented as circuits built from user provided components such as addition subtraction etc.
connections between components are captured using integer location variables .
xy node s1 1s2 1s3 1s4 xy s1 2s2 2s3 2s4 xy s1 3s2 3s3 3s4 3node node a tree with abstract nodes.s1 x s3 s1 s2 x y s4 s1 x t t term b selectors to terms.
figure encoding via propositional selector variables.
assume that outiis the output of i th component loiis the location of the output of the i th component inj iis the j th input if the i th component lij iis the locations of the j th input if the i th component cis the number of components niis the number of inputs of the i th component fjis the semantics if the j th component e.g.
xy.x yfor addition .
the set of well formed terms is encoded using wpfb range cons acyc such that rangeb i loi c j lij i c consb i j i jloi loj acycb i j loi lij i where range constraints range allocate inputs and outputs within a legal range consistency constraints consensure that all outputs have unique locations and acyclicity constraints acycforbid loops.
besides connection constraints connbind location variables and connections between components and semantic constraints sem define the relation between components inputs and outputs connb i j k loi lik j outi ink j semb i outi fi in1 i in2 i ... inni i a term is constructed from an assignment of locations variables that satisfies wpf conn semusing a function lval2term .
this function connects inputs and outputs of components that have the same location.
for example xy.x yis constructed from the assignment in figure 4b as in the circuit in figure 4a .
methodology in this section we first formally describe second order constraints used in our approach and a method of solving these constraints.
secondly we demonstrate how second order solving is integrated with symbolic execution and describe implemented constraint optimizations.
finally we show how the resulting technique can be applied for program repair and environment modelling.
.
second order solving as is usual in smt literature we consider formulas and terms built from predicate and function symbols e.g.
from a given signature .
we denote the set of all such formulas and terms as l .
we also consider a background theory tthat fixes the 392symbolic execution with existential second order constraints esec fse november lake buena vista fl usa interpretations of the symbols in .
in this work we are interested in an extended set of formulas and terms l pconstructed from the symbols in and an additional set of predicate and function symbols p b 1 ... n without interpretations in t that we refer to as second order variables or symbolic functions .
for a formula over a second order variable and a term t l with a designated set of variables x1 ... xn we say that a first order formula is a substitution of with t if it is obtained by replacing each sub term t1 ... tn of for some terms t1 ... tn with a term computed as the result of beta reduction of the lambda expression x1...xn.t t1...tn.
for instance let be a andtbex1 x2 then is defined as a .
definition .
second order satisfiability .
let l pbe a second order formula l p 2l a mapping from second order variables to sub languages of l be domains of interpretations.
then is satisfiable iff for some terms t1 l 1 ... tn l n the first order formula is satisfiable w.r.t.
t. the key part of this definition is the domains of interpretations lthat are sub languages of l for each second order variable.
in our approach the sub languages are either provided by the user or by a tool algorithm that relies on se esoc.
particularly a sublanguage is defined as a pair g d of a context free grammar g with the symbols from as terminals as in sygus format and an integer value dthat describes the maximum depth of considered terms i.e.
the maximum number of nodes in a path from the root of a term to its leaf .
similar to the prior approach described in section we rely on a library of components to encode a space of terms from a given language of interpretations.
note that for a synthesis problem with a language defined via a pair g d it is straightforward to encode it as a component based synthesis problem by considering each grammar rule n f n1 ... nn for non terminals n n1 ... nn ofgas a component fwith inputs n1 ... nn.
thus without the loss of generality we assume later that instead of a grammar g our language is defined through a set of components f1 ... fc.
one way to implement a solver for the considered kind of secondorder formulas is to encode them through first order formulas using e.g.
the approach described in section .
however this approach relies on linear integer arithmetic to encode a space of terms which results in inefficient proofs of unsatisfiability.
on the other side se esoc critically depends on the performance of unsatisfiable queries to avoid infeasible paths as shown in section .
.
in order to optimize unsatisfiable queries we introduce an new encoding of second order formulas through propositional selector variables instead of integer location variables.
intuitively this increases the effectiveness of conflict clause learning in cdclbased smt solvers and therefore significantly improves the performance on unsatisfiable queries which is shown experimentally in section .
the key idea of the introduced propositional synthesis encoding is to represent the space of terms constructed from a given library of components via a tree with abstract nodes as shown in figure 5a.
specifically each intermediate node of the tree has as many subnodes as the maximal number of inputs of a component in a given component library.
each leaf of the tree corresponds to componentsthat have no inputs.
the semantics of each node is defined through the semantics of a component activated via selector variables.
assume that sj iis the j th selector of the i th node outiis the output of i th node cis the number of components fjis the semantics if the j th component e.g.
xy.x yfor addition .
for each node iwith subnodes i1 i2 ... ik a set of terms is encoded as ib node choice such that nodeb j sj i outi fj outi1 outi2 ... outik choicebexactlyone s1 i s2 i ... sc i in this encoding nodedescribes how the output value of a node depends on the values of its subnodes choice ensures that exactly one of the components is selected inside each node the cardinality constraint exactlyone is implemented using sorting networks .
a term is constructed from an assignment of selector variables using a function sval2term that at each node picks a component that is activated by the corresponding selector variable as shown in figure 5b.
for instance the term x yis constructed by enabling the component of the node via the selector s3 the component xof the node via the selector s1 and the component yof the node via the selector s2 .
using the above encoding a second order constraint solver can be implemented on top of a first order solver.
specifically for a given formula over a second order variable we define the procedure encode as follows each occurrence of a subterm t1 ... tn in for some terms t1 ...tn is assigned a unique index i for each occurrence of a subterm t1 ... tn in with index i for some terms t1 ...tn the formula is conjoined with i ... im where mis the number of tree nodes and the terms t1 ... tnare treated as components without inputs each occurrence of a subterm t1 ... tn in with index i for some terms t1 ...tn is replaced with the variable outi representing the root of the i th tree in the encoding.
using this procedure a second order formula is transformed into a first order formula over selector variables which can be solved using an off the shelf smt solver.
from any satiafying assignment of the selector variables an interpretation of that satisfies can be reconstructed using sval2term as stated formally below proposition .
.
for any assignment of selector variables sb s17 b1 ... sn7 bn that satisfies bencode the assignment 7 sval2term s satisfies .
.
extension of symbolic execution algorithm describes the overall workflow of symbolic execution with our extension.
the function exesymbolic takes an instruction pointer a program state a mapping from variables to concrete value or logical terms and a path condition performs symbolic execution of the corresponding instruction and recursively continues execution.
for an assignment vbe this function updates the state by replacing the value of vwith eevaluated in the context s denoted as jeks .
then the execution continues from the next instruction.
for a conditional if e then c 1else c this function checks whether the if condition is consistent with the current path 393esec fse november lake buena vista fl usa s. mechtaev a. griggio a. cimatti a. roychoudhury algorithm extension of symbolic execution procedure exesymbolic instruction pointer ip program state s path condition pc i getinstruction ip switch ido case assignment vbe s s ip increment ip exesymbolic ip s pc end case conditional if e then c 1else c pc jeks ifissatisfiable then ip getpointer c1 exesymbolic ip s pc jeks end ... check the other branch end otherwise ... handle other instructions end endsw procedure issatisfiable formula encode ip return underlyingsolver condition and whether the negation of the if condition is consistent with the path condition the later case is omitted .
if the constraint is satisfiable the algorithm continues execution of the corresponding branch with an augmented path condition.
compared with traditional se se esoc modifies the function issatiafiable highlighted in algorithm .
specifically it adds support for second order constraints by implementing the approach described in section .
.
the function issatiafiable encodes each query using encode before passing it to the underlying smt solver.
later a model of can be reconstructed from the model computed by the underlying smt solver using sval2term .
definition .
second order infeasible paths .
letpbe a program taking a function as an input be a second order variable and lbe a sub language of l .
then a path along which se esoc computes a path condition by executing pwith the symbolic input is infeasible iff the second order formula is unsatisfiable w.r.t.
the domain of interpretations 7 l .
this definition of infeasible path depends on the syntax of the language of interpretations l. this property is crucial for mitigating the path explosion as will be shown in section .
.
.
program repair and library modelling se esoc can be used among others to synthesize patches for program defects or models for unavailable libraries.
similarly to prior works the workflow of both these applications consists of three steps injecting second order symbolic variables performing specification inference and synthesizing patches models.
symbolic variable injection.
in the context of program repair suspicious program statements are substituted with applications of symbolic functions to local program variables.
suspicious program statements can be identified using for instance statistical fault localization .
for each of the identified suspicious statements we iteratively apply the following transformation schemas parameterized with second order variable changing the right hand side of an assignment xbe xb v1 ... vn changing a condition if e ... if v1 ... vn ... adding an if guard s if v1 ... vn s where sis a statement eis an expression and v1 ...vnare visible program variables.
specifically we adopted a recently proposed heuristics to select up to local program variables whose definitions are the closest to the considered suspicious location.
in the context of library modelling symbolic functions are used to replace calls of unknown library functions.
specifically we replace all calls of an unknown function either with a fresh secondorder variable or a generic sketch parameterized with depending on the signature of this function func has integer inputs and an integer output func e1 ... en e1 ... en func has integer and array inputs and an integer output func e1 ... en accumulation e1 ... en func has integer and array inputs and an array output func e1 ... en transformation e1 ... en where e1 ...enare expression and the sketches accumulation and transformation are defined in the following way int accumulation char arr ... int acc i for i i strlen arr i acc acc arr ... return acc void transformation char arr char out ... int i for i i strlen arr i out acc arr ... in principle an arbitrary c function parameterized with first order and second order variables can be used as a sketch.
specification inference.
the purpose of specification inference is to collect constraints over the injected second order variables such that any interpretation that satisfies these constraint would meet our requirements.
specifically our goal is to find interpretations of the symbolic functions that would enable the program to pass given tests.
assume that pis the original program and p is a program obtained by injecting a second order variable intop.
assume also that ini i i is a set of tests where iniis the input of the i th test and iis the test assertion.
for each test i we execute the program p using se esoc with the concrete input iniand obtain a set of path conditions i ... i k which are constraints over the variable .
then the specification is defined as follows n i k j 0 i j i the above second order formula captures the property that for each test with index ithere should be at least one path i jalong which the test assertion iholds.
394symbolic execution with existential second order constraints esec fse november lake buena vista fl usa patch model synthesis.
to synthesize interpretations of symbolic functions that satisfies the formula we apply the second order constraint solving method described in section .
.
for program repair these interpretations constitute patches and for library modelling these interpretations constitute models of the unknown library functions.
in the context of program repair and also library modeling tests are typically insuffient to guarantee the correctness of patches which causes the test overfitting problem .
the proposed approach is orthogonal to the problem of test overfitting however it is straightforward to integrate it with existing techniques for alleviating overfitting such as synthesizing minimal change via maximum satiafiability or applying anti pattens or applying correctness assertions by conjoining the encoding with additional constraints over selector variables.
.
implementation we implemented se esoc as an extension1of klee a widely used symbolic execution engine for c programs.
firstly we extended klee to support second order variables and implemented the generation of second order path conditions in the symbolic execution runtime.
secondly we implemented the encodings described in section and section .
on top of the underlying smt solver.
klee provides an intrinsic function klee make symbolic for injecting symbolic variables.
for example the following call marks the memory corresponding to the variable fooas symbolic.
klee make symbolic foo sizeof foo foo to let users introduce second order variables we added an intrinsic function klee apply symbolic .
this function applies a symbolic function to program expressions.
for instance the following code can be used to inject a call of in example 2c int t klee apply symbolic rho int i x where rho is the name of the second order variable 2is the number of arguments and int i x is the array of arguments.
evaluation this evaluation addresses the following research questions rq1 does se esoc reduce the number of explored paths compared with program repair techniques relying in first order symbolic execution?
does it improve the effectiveness of program repair?
rq2 can se esoc synthesize library models from the usage context that improve symbolic execution based test generation?
rq3 does the introduced second order solving method based on propositional encoding improve se esoc performance compared to previous encodings?
.
experimental setup to address the research questions we conducted experiments with programs from gnu coreutils2 gnu findutils3and gnu grep4 mature and widely used implementations of unix utilities included 1our second order klee extension 2gnu coreutils 3gnu findutils 4gnu grep subjects of dbgbench dataset program description defects find search for files in directory hierarchy grep search for lines containing match to specified pattern table modelled library functions function description sketch read read bytes from file with specified descriptor transformation write write bytes to file with specified descriptor transformation stat return information about file seek change read write position of file descriptor chmod change permissions of file chown change ownership of file malloc allocate block of memory strtol convert string to int accumulation strlen return string length accumulation strcmp compare two strings accumulation table usage of library functions.
program description used functions base64 compute base64 read write cat concatenate files strcmp stat read malloc cp copy file read write chown chmod stat malloc head print beginning of file read write seek malloc strcmp ls list files in directory write stat malloc strcmp strlen pr convert text files strtol pwd print current directory malloc stat sort sort lines write malloc strcmp test evaluate expression stat wc count words strtol read in the majority of linux distributions that have been also employed in previous symbolic execution studies .
in the context of program repair we used a recently introduced dbgbench dataset .
dbgbench is a collection of bugs from gnu findutils and gnu grep shown in table .
we chose this benchmark because it contains real error in widely used software and because this dataset was designed for evaluating among others program repair techniques.
to evaluate our library modelling method we first selected standard c library functions that are frequently used by c programs and that have been studied in related works .
these functions include file systems related functions read write seek chmod chown and stat malloc and string functions strtol strlen strcmp .
to synthesize models of these functions we used predefined sketches specified in table .
note that some of the functions e.g.
memory allocation depend on os kernel that cannot be modelled using our method.
for these function we modelled only the part of functionality that does not rely on os kernel behavior such as computing the real allocation size for malloc .
to perform modelling we selected programs from gnu coreutils that rely on these functions.
we run provided tests for all programs from gnu coreutils .
with ltrace5in order to identify which of the selected library functions are used by these programs.
5ltrace 395esec fse november lake buena vista fl usa s. mechtaev a. griggio a. cimatti a. roychoudhury bool int int int int int int bool bool bool bool !
bool int var constant int int int int int a boolean functions.
term var constant term term term term term bool ?
term term b integer functions.
figure language of interpretations search space .
then we chose programs from gnu coreutils that rely on different combinations of library functions as shown in table .
to examine the effect of second order constraints on the path explosion we compared our approach with angelix a stateof the art program repair system that relies on first order symbolic execution.
specifically we used the following three configurations foangelix that relies on first order symbolic execution.
so cbs se esoc that uses the encoding by jha et al.
for second order constraint solving.
so pse se esoc that uses the introduced propositional encoding for second order constraint solving.
since the proposed library modelling method is the first that synthesizes library models from the usage context we compared it against the baseline approach treating all outputs of unknown library functions as symbolic and manually written models.
specifically we used the following configurations baseline treating outputs of unknown functions as symbolic.
se esoc using models synthesized by se esoc.
manual using models provided by klee.
we do not experimentally compare our approach with the modelling technique by qi et al.
since their approach executes the library to collect output values while our goal is to synthesize models when the library is not available.
we conducted all experiments on an intel core tmi7 cpu .40ghz machine running ubuntu .
with 8gb of memory.
.
program repair to investigate the effect of second order constraints on path explosion we compared se esoc configurations with angelix fo .
particularly we executed repair algorithms described in section .
on the subjects of dbgbench using developer provided tests as the correctness criteria for patches.
for each suspicious program location we bounded6the number of explored paths to and used a minutes time limit.
se esoc configurations used the languages of interpretations given in figure 6a and figure 6b.
the same languages were used by angelix fo synthesizer.
besides we specified the depth bound db3 for the synthesized functions.
table summarizes the results of our experiments.
the column subject lists subject program and their versions commit hashes .
the columns patch show if a patch was generated by each configuration we present only versions for which at least one configuration 6it is common for synthesis based program repair techniques to rely on path bounds.
for instance an enumerative approach spr uses the bound of paths.generated a repair.
in these columns correct indicates that the generated patch is syntactically equivalent to the developer patch otherwise the patch is classified as plausible .
in order to investigate the cause of failures of some configurations to find a patch we collected additional statistics of symbolic execution sessions.
for each configuration we collected data for the session in which the program is executed symbolically with the failing test and a symbolic variable is installed in the fix location.
specifically the columns paths in table denote how many paths were explored by each configuration during this symbolic execution session.
the columns time show the time taken by each configuration to explore these paths.
overall the configurations based on second order constraints generated all the patches generated by the approach based on firstorder constraints and so pse also found three additional patches for find.091557f6 find.dbcb10e9 and grep.54d55bba.
for each of these three cases fo reached the limit of paths during exploration while so pse reduced the number of explored paths to which led to the successful generation of patches.
however so pse required slightly more time on average for path exploration compared with fo 1m 24s for so pse and 1m 5s for fo .
in all three cases for which so pse exclusively generated patches the modified statements are executed multiple times by the failing tests.
to explain how the reduction of explored paths is achieved in this case we consider the experiments with the bug find.091557f6 in greater details.
this bug in find utility is caused by a wrong handling of symbolic link loops when searching for files in a directory.
one of the possible correct fixes is to add the disjunct ent fts errno eloop to the condition shown in figure 7a.
to synthesize a patch angelix fo replaces the buggy condition with a first order variable and performs symbolic execution to infer synthesis specification.
the condition is evaluated multiple time during an execution of the failing test and angelix fo fails to infer sufficient specification to synthesize a patch due to the path explosion since it terminates after reaching the limit of paths .
contrary to angelix se esoc injects a second order variable applied to local program variables as shown in figure 7a.
it also associates the language in figure 6a and the bound db3 with that effectively define the search space of patches.
this enables se esoc to take advantage of the stronger notion of infeasibility definition .
to prune irrelevant paths.
specifically it determines that only execution paths are feasible w.r.t.
the considered language of interpretations and synthesizes the interpretations 1 ... 16in figure 7b corresponding to the feasible paths.
in order to prune infeasible paths se esoc has to solve more complex constraints than fo which results in additional performance overhead.
however the execution time of se esoc is less dependent on the bounds of symbolic execution.
to demonstrate this we executed fo and se pse with the example in figure 7a ranging the number of explored paths max forks klee options from to .
the results of our experiment are presented in figure 7c.
as can be seen the time taken by fo increases with the increase of the path bound while the time taken by se pse does not depend on the path bound since it only has to explore paths.
overall se esoc helps alleviate path explosion when repaired expressions are executed multiple times during program execution.
396symbolic execution with existential second order constraints esec fse november lake buena vista fl usa table program repair results.
subjectpatch paths time sat unsat fo so cbs so pse fo so cbs so pse fo so cbs so pse so cbs so pse find.091557f6 correct 2m 35s timeout 2m 29s .5s timeout .2s .8s find.24bf33c0 plausible plausible plausible 2s 3s 3s .
.5s find.24e2271e correct correct correct 39s 1m 1s 1m 43s .1s .2s find.07b941b1 plausible plausible plausible 29s 41s 31s .7s .5s find.e6680237 correct correct correct 56s 2m 41s 2m 23s .2s .1s find.dbcb10e9 correct 3m 31s timeout 3m 1s .0s timeout .7s .8s find.e1d0a991 plausible plausible plausible 5s 5s 5s .2s .9s grep.55cf7b6a correct correct correct 3s 3s 3s .8s .4s grep.3220317a plausible plausible plausible 41s 1m 5s 1m 11s .2s .1s grep.db9d6340 plausible plausible plausible 2s 3s 2s .8s .6s grep.c96b0f2c plausible plausible plausible 1m 19s 1m 59s 2m 11s .2s .3s grep.5fa8c7c9 correct correct correct 55s 2m 43s 1m 35s .9s .8s grep.54d55bba plausible 2m 42s timeout 2m 59s .1s timeout .4s .2s overall .
.
.
1m 5s 1m 21s 1m 24s .2s .6s .9s ... else if ent fts info fts dc issue loop warning ent error severity return ent fts info ent fts errno prev depth else if ent fts info fts slnone if symlink loop ent fts accpath error eloop ent fts path error severity return ... a buggy condition in find.091557f6.
1b ent fts info 2b!
ent fts errno prev depth 3b ent fts info prev depth ent fts errno 4b!
ent fts errno 5b ent fts info ent fts errno prev depth 6b ent fts info prev depth 7b prev depth ent fts errno ent fts info 8b ent fts errno prev depth ent fts info 9b ent fts info ent fts errno 10b ent fts info ent fts errno 11b!
ent fts info 12b prev depth 13b!
ent fts info 14b!
prev depth 15b ent fts errno prev depth ent fts info 16b ent fts errno prev depth ent fts info b interpretations of found along feasible paths.
c time and explored paths.
figure repairing wrong handling of symbolic link loops in find.
.
library modelling to evaluate the effect of library modelling on the effectiveness of symbolic analysis we computed the coverage of test suites generated by symbolic execution using the synthesized models.
first we used the available tests of gnu coreutils to synthesize models of the unknown library functions using se esoc.
to check the efficacy of our modelling technique we used three sets of library templates baseline se esoc and manual that are defined in section .
.
using these three approaches we generated test suites using klee.
we used the recommended configuration for testing gnu coreutils available on klee website7 and set the time limit of a half an hour for test generation.
then to check the efficacy of the library models we check the efficacy of the generated test suites in the three approaches as follows.
we linked application programs that use the libraries with the real libraries not the models .
then we computed the line coverage of the generated test suites in the programs linked against the real libraries.
table summarizes the statistics of the generated test suites.
the columns tests contain the number of tests generated by klee using different models.
the columns coverage depict the line coverage produced by the test suites and computed using gcov .
the coverage achieved using models synthesized by se esoc is .
which is greater than .
coverage achieved using baseline 7klee configuration for coreutils library modelling results.
programbaseline se esoc manual tests coverage tests coverage tests coverage base64 .
.
.
cat .
.
.
cp .
.
.
head .
.
.
ls .
.
.
pr .
.
.
pwd .
.
.
sort .
.
.
test .
.
.
wc .
.
.
overall .
.
.
.
.
.
approach.
however the automatically generated library models using se esoc achieve lower coverage than the carefully crafted hand written models which achieve around .
coverage.
.
second order solving since our approach relies on the notion of infeasibility definition .
to prune explored paths it is critical that it can efficiently handle unsatisfiable second order queries.
to investigate how existing component based synthesis cbs encoding section and the introduced propositional pse encoding section .
perform 397esec fse november lake buena vista fl usa s. mechtaev a. griggio a. cimatti a. roychoudhury on unsatiafiable formulas that occur in the context of symbolic execution we collected solver statistics in table .
the columns sat unsat demonstrate the average time taken by satisfiable and unsatisfiable queries during path exploration indicates that no such queries are performed .
as can be seen both cbs and pse demonstrated comparable performance on satisfiable formulas on average cbs requires .2s and pse requires .6s .
however cbs did not solve any unsatisfiable queries within the time limit minutes while the average time taken by pse on unsatisfiable queries is .9s which is similar to the time taken by satisfiable queries.
thus pse is crucial in enabling se esoc to avoid infeasible paths.
related work symbolic execution.
godefroid proposed to use higher order constraints to model imprecision of symbolic execution.
specifically this approach replaces unknown complex instructions with uninterpreted functions and generates inputs by solving universal constraints over uninterpreted functions.
the main difference of our approach is that it solves existential constraints over functions whose interpretations are restricted by a user defined language which implies different methodology and applications.
first the approach with uninterpreted functions cannot reduce the number of explored paths as shown in section .
in the context of program repair since this reduction is achieved by restricting of the space of interpretations.
second the approach with uninterpreted functions cannot be used for library modelling as shown in section .
since it relies on input output function sampling that cannot be performed when the library is not available.
palikareva et al.
proposed to test divergences between program versions by encoding two versions in a single symbolic execution session.
our approach differs in that it encodes a potentially infinite number of program versions inside a single symbolic execution session.
program synthesis and second order constraint solving.
from the logical point of view program synthesis is existential second order constraint solving .
several techniques have been proposed for solving such second order constraints.
enumerative techniques that explicitly generate and test individual terms cannot be applied in the context of symbolic execution because they would require checking satisfiability of path constraint for each possible expression in the search space.
reynolds et al.
introduced an algorithm for synthesizing programs inside an smt solver.
this approach tends to synthesize complex solutions consisting of thousands of nodes8that cannot be understood by humans which makes it unsuitable for program repair.
the encoding of second order formulas proposed by jha et al.
relies on linear integer arithmetic constraints which results in inefficient proofs of unsatisfiability.
symbolic execution requires checking unsatisfiability of path constraints to avoid infeasible paths needing efficient unsatisfiability proofs.
the second order formula encoding introduced in this work addresses the above limitations of existing techniques.
program repair algorithms.
various program repair techniques have been recently proposed .
the most relevant works to our approach are techniques that employ first order symbolic execution to infer patch synthesis specification .
8sygus comp results these techniques rely on symbolic execution they suffer from the path explosion problem as shown in section .
.
se esoc alleviates the path explosion which leads to repairing more defects in programs with loops.
specification inference and modelling of libraries.
in order to enable analysis of code written against libraries a common approach is to provide a library model summary or specification.
klee symbolic execution engine relies on manually written posix libraries models to analyze system software.
qi et al.
proposed to synthesize a library model for symbolic execution by using the library as an oracle for program synthesis i.e.
it executes the library to collect output values.
our approach differs in that it is designed for the case when the library is not available.
several techniques have been proposed to derive specification by analyzing the library usage context when library is not available.
bastani et al.
infer data flow library specification from the usage context.
albarghouthi et al.
synthesize a maximal library specification to ensure the correctness of a given program that uses this library.
our library modelling technique differs from the approach by albarghouthi et al.
in that we synthesize a code fragment that captures inputoutput relationship of library functions to enable generation of tests that reach certain locations rather than a specification for proving program properties for all inputs and our technique is unsound it relies on inductive generalization without verification and imprecise symbolic execution but more applicable it can be used with real world software without formal specification .
test equivalence analysis.
test equivalence is a property of two modifications of a program to behave equivalently for some definition of equivalence when executing a given test.
this property has been applied in multiple domains such as mutation testing program repair and compiler testing .
the analysis technique proposed in this paper can be considered as a generalization of previously used test equivalence analyses.
specifically a second order path constraint captures the set of all modifications of a given program that would drive the test execution along the corresponding path as in section .
.
thus it defines path based test equivalence relation on the space of program modifications.
conclusion we have proposed symbolic execution with existential second order constraints.
we developed a method for second order constraint solving that provides efficient proofs of unsatisfiability which is needed for efficient symbolic execution.
we described two applications namely automated program repair and library modelling.
we experimentally showed that the proposed technique can reduce path explosion when applied for program repair which helps to repair more bugs in programs with loops.
besides it can be used to synthesize models of unavailable libraries.
our work is being made available as an extension of klee