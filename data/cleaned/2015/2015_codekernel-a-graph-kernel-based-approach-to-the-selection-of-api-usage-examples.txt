codekernel a graph kernel based approach to the selection of api usage examples xiaodong gu1 hongyu zhang2 sunghun kim1 1hong kong university of science and technology hong kong 2the university of newcastle australia3clova ai research na ver corporation 1guxiaodong1987 .com hunkim cse.ust.hk 2hongyu.zhang newcastle.edu.au abstract developers often want to find out how to use a certain api e.g.
filereader.read in jdk library .
api usage examples are very helpful in this regard.
over the years many automated methods have been proposed to generate code examples by clustering and summarizing relevant code snippets extracted from a code corpus.
these approaches simplify source code as method invocation sequences or feature vectors.
such simplifications only model partial aspects of the code and tend to yield inaccurate examples.
we propose codekernel a graph kernel based approach to the selection of api usage examples.
instead of approximating source code as method invocation sequences or feature vectors codekernel represents source code as object usage graphs.
then it clusters graphs by embedding them into a continuous space using a graph kernel.
finally it outputs code examples by selecting a representative graph from each cluster using designed ranking metrics.
our empirical evaluation shows that codekernel selects more accurate code examples than the related work muse and exoadocs .
a user study involving developers in a multinational company also confirms the usefulness of codekernel in selecting api usage examples.
i. i ntroduction api usage examples have shown importance in many software engineering tasks such as api documentation code search and code completion .
developers frequently need to use apis e.g.
filereader .read in jdk library that they are unfamiliar with or do not remember how to use.
it is common practice for developers to search for usage examples i.e.
sample code to understand the apis.
the api usage examples provide exemplar code that demonstrates the typical usage of an api.
accurate and understandable code examples can help developers overcome obstacles caused by unfamiliar apis .
yet acquiring accurate and understandable api usage examples is not without difficulty.
the most common way is to directly read manually written examples from api documentation.
however such examples are usually insufficient covering only a small portion of common apis.
there are a large number of apis e.g.
jdk has 86k apis which are constantly evolving.
it is time consuming for library developers to manually write examples for all of them.
furthermore api usage examples cannot answer programming questions that are not directly related to a specific api.
another way is to search from developer q a forums such as stackoverflow .
however it is often difficult to find relevant code for unpopular apis or programming tasks.
the answers could be either too general or too detailed and might not be up to date .
developers could also exploit code examples using code search tools such as github search .
yet the accuracy of answers is highly dependent on the search engine.
users may encounter too many project specific code snippets extracted from open source projects.
for example a search of filereader .read over github returned java code snippets.
it would be time consuming to explore a large number of project specific code snippets to understand how to implement this functionality.
therefore it is desirable to be able to automatically select a small yet effective code example.
many approaches have been proposed to generate api usage examples from a code corpus .
for example mapo and up miner abstract code snippets into method call sequences and mine usage patterns by clustering similar sequences and mining frequent patterns in each cluster.
kim et al.
proposed exoadocs which approximates code snippets as ast element vectors.
these vectors are clustered and ranked according to their vectorial similarities.
the api usage examples are then selected from the clusters.
the aforementioned approaches simplify source code as method call sequences or feature vectors.
such simplifications only model partial aspects of the source code.
the structural information of the code such as control structures and data dependency is lost.
therefore these source code representations could result in imprecise code similarity measurement.
the produced code examples are often inaccurate and difficult for developers to reuse in programming practice.
nguyen et al.
proposed grouminer which is a graph based approach to mine api usage patterns .
grouminer utilizes frequent pattern mining which tends to yield redundant results.
moreno et al.
proposed muse which applies a code clone detection technique simian to group code snippets and select code examples.
muse could produce redundant code examples as it is based on text based clones of code instead of a source code abstraction.
we will describe more about the limitations of the existing approaches in section ii.
to address the limitations of existing approaches we propose a novel approach called codekernel which is a graph 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
kernel based approach to the selection of api usage examples from relevant code corpus.
codekernel has two distinctive characteristics first instead of abstracting source code into method call sequences feature vectors and raw code codekernel represents source code as object usage graphs .
an object usage graph can be seen as an abstraction of source code.
it abstracts away syntactical details a raw code representation brings but it keeps complete information about code such as texts structures sequences and data dependencies.
second instead of using frequent pattern mining or similarity heuristics codekernel clusters the similar graphs through graph kernel which embeds the graphs into a high dimensional continuous space.
such an embedding conserves full aspects of the original graphs thus is more accurate than methods that are based on feature extraction or similarity heuristics.
given a code corpus which consists of code snippets from open source projects codekernel first builds object usage graphs for each function.
it then clusters the graphs through graph embedding.
finally codekernel selects the representative graph of each cluster using ranking metrics.
we empirically evaluated the accuracy of codekernel on java apis.
our results show that codekernel s code clustering achieves an average f1 score of .
outperforming two stateof the art approaches muse and exoadocs .
in a human study involving developers in a multinational company of our code examples were preferred over the state of the art technique and developers considered codekernel useful for selecting api usage examples.
the results confirm the accuracy and usefulness of codekernel in programming practices.
the main contributions of our work are as follows to our knowledge we are the first to apply a graph kernel method to source code which yields more accurate code examples than the state of the art techniques.
we develop codekernel a tool that generates api usage examples.
our evaluation confirms the accuracy and usefulness of the selected code examples.
ii.
m otiv a tion in this section we show the motivation behind our approach by reviewing the limitations of the state of the art approaches.
a. call sequence based methods a number of techniques such as mapo and upminer represent source code as method call sequences.
figure shows a screenshot of up miner an api usage pattern mining approach based on call sequences.
the example in figure shows that when both sqlconnection.new and sqlconnection.createcommand occur it is highly probable that the api sqlconnection.open will occur next.
for a set of call sequences that are relevant to an api method up miner first performs clustering of the call sequences.
it then mines fig.
an api usage pattern mined by up miner api usage patterns from each cluster using a frequent sequence mining algorithm and performs clustering again to group the frequent sequences into patterns.
given a usage pattern upminer also returns a list of code examples that contains the pattern ranked by their similarity values.
although call sequences show effectiveness in characterizing api usage patterns they fail to capture the structural information of the source code such as loops branches and third party method invocations.
missing such information could cause inaccurate calculation of code similarity yielding inaccurate api usage patterns.
b. feature v ector based methods instead of abstracting source code as api sequences a considerable number of existing approaches use feature extraction and similarity heuristics for source code .
one typical approach exoadocs approximates the semantic features of code as ast element vectors for clustering.
the ast element vector characterizes a fragment as occurrence counts of single ast node types.
however like call sequences feature vectors are also insufficient to capture structural information .
figure shows two code fragments of different structures .
unfortunately they have very similar ast element vectors e.g.
both contain four type declarations one for statement one if statement and four identifier names in their ast trees .
they even have similar identifiers x and n and data types int .
thus they could be incorrectly clustered by exoadocs s vector based approach.
intsum intx n ints for inti x i n i if i s s i returns intpower intx n intp p for inti x i n i p p x returnp fig.
different fragments that have similar element vectors of single node types c. code clone based methods muse is a typical code example selection approach which utilizes program slicing and text based clone detection technology.
however methods based on text based clone detection could yield redundant examples as they detect authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
3dwwhuq if stringutils.isblank pattern if group.get definition !
null ... namedregexcollection.put name index group.get subname !
null?
group.get subname group.get name 3dwwhuq if stringutils.isblank pattern if m.find ... namedregex stringutils.replace namedregex group.get name ?
name index grokpatterndef.get group.get pattern index 3dwwhuq if stringutils.isblank pattern if group.get definition !
null ... namedregexcollection.put name index group.get subname !
null?
group.get subname group.get name if namedregex.isempty throw new grokexception pattern not fount 3dwwhuq if stringutils.isblank pattern if m.find ... namedregex stringutils.replace namedregex group.get name ?
name index grokpatterndef.get group.get pattern index if namedregex.isempty throw new grokexception pattern not fount fig.
patterns minined by grouminer for the api stringutils.isblank type and type clones over raw code instead of an abstraction.
the similarity measures between code snippets could be adversely affected if the example contains too much information that is specific to local context.
figure shows code examples generated by muse for the java api fileutils.writestringtofile which are directly extracted from its website1.
as we can see the examples selected by finalfileinfo template finalfileinfo filter finalstring outputbasepath string outputdir createoutputdirectory template filter outputbasepath finalstring templatefilename template.getfile .getname finalstring outputfilename filenameutils.separatorstosystem outputdir templatefilename finalstring rawtempl fileutils.readfiletostring template.getfile finalproperties properties readfilterintoproperties filter finalstring processedtemplate strsub.replace rawtemplate properties newfile outputfilename the file to write processedtemplate the content to write to the file fileutils.writestringtofile newfile outputfilename processedtemplate example example publicjobmanagerconfiguration jobmanagerconfiguration stringwriter results newstringwriter file temppbsfile null string scriptcontent results.tostring .replaceall n if scriptcontent.startswith n scriptcontent scriptcontent.substring intnumber newsecurerandom .nextint number number ?
number number temppbsfile newfile integer.tostring number jobmanagerconfiguration.getscriptextension temppbsfile the file to write scriptcontent the content to write to the file fileutils.writestringtofile temppbsfile scriptcontent location of repository.
private final transient string path notnull finalstring name notnull finalstring content finalfile dir newfile this.path finalfile file newfile dir name file the f ile to write content the content to write to the file fileutils.writestringtofile file content example fig.
excerpts of usage examples for the java api fileutils.writestringtofile selected by muse muse contain much redundancy.
in their results example and are presented as different examples because they commons io .
examples writestringtofile .html original space continuous space fig.
illustration of the kernel based graph embedding prepare file names string and contents string in different ways.
example reads a string content and replaces it with a filter.
example removes special characters from a string.
example directly writes a string.
however from developers perspective different ways of preparing contents e.g.
string.replaceall string.substring are not related to the api usage.
they are specific to local context.
in fact all the examples follow the same usage of the api creating a file with a filename string preparing a context string then invoking the api fileutils.writestringtofile to write the context to the file.
clone detection techniques are often specific to such local context and could produce redundant examples.
a better approach should treat these examples as similar ones and merge them into one example.
d. graph based frequent pattern mining representing source code as graphs could alleviate the aforementioned problems as graphs are effective to carry structural information.
grouminer is a typical graph based approach that is successful for mining api usage patterns .
however it is based on frequent pattern mining which tends to suffer from the high redundancy problem that is patterns could be subsets of other larger patterns .
figure shows patterns returned by grouminer for the java api stringutils.isblank in the same code corpus of muse .
more results are available online1.
we can see that many patterns are redundant pattern is a subset of pattern and pattern is a subset of pattern .
such redundancy incurs extra effort for developers in finding patterns of interest.
this indicates that more improvement is required for graph based approaches and graph clustering could be a better choice than frequent pattern mining.
iii.
b ackground the limitations of the existing approaches require an efficient approach that allows manipulation of structural data such as source code while being computationally cheap .
in this section we review the kernel method an efficient technique to measure data similarities.
in particular we will introduce graph kernel a specific kernel method designed for graphs.
a. kernel method for similarity measure suppose we have data in a space whose coordinates are too difficult or expensive to compute e.g.
sequential data or authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
graphs .
our goal is to manipulate the data directly.
specifically we embed the original data into a high dimensional continuous space where their inner products can be calculated accurately and is computationally cheaper.
then conventional clustering methods can be applied directly to the embedded data points.
the kernel method is an efficient and well studied approach to achieve such embedding .
figure illustrates the basic idea.
the kernel method assumes that there exists a transformation function s tthat maps data in the original space sinto a continuous space t.a sw ed on o t know the explicit formulation of the transformed data in spacetis still implicit.
fortunately there exists an important principle that the inner products of data in the space tcan be calculated simply by a kernel function defined in the source spaces .
that is k g1 g2 g1 g2 .
a kernel functionk s s ris a function that satisfies mercer s conditions .
it enables us to operate non vectorial data in a continuous space by simply defining a function on the original data.
the embedding conserves full aspects of the original data and is therefore more accurate than methods that extract features from data .
kernel functions have been introduced for sequence data graphs text images as well as vectors .
the most commonly used kernel functions include the gaussian kernel the linear kernel and the polynomial kernel .
b. graph kernel especially for graph data there is a class of kernel functions named graph kernel .
graph kernels are kernel functions that compute inner products on graphs .
they can be intuitively understood as functions that measure the similarities of pairs of graphs.
they enable kernelized learning algorithms such as support vector machines to work directly on graphs without having to do feature extraction to transform them to fixed length real value feature vectors.
graph kernels have seen successful applications in many areas such as chemoinformatics e.g.
molecule kernels bioinformatics and social network analysis .
in our approach we employ a highly efficient and widely used graph kernel the shortest path graph kernel .
given two graphs g1andg2 their kernel is defined as k g1 g2 summationdisplay e1 sd g1 summationdisplay e2 sd g2 kwalk e1 e2 wheresd g denotes a new graph which has the same nodes asg.
each edge e u v insd g is a new edge with a weight being the shortest distance between uandvin the original graph g.kwalk e1 e2 represents the path kernel which is defined as kwalk e1 e2 knode u1 u2 kedge e1 e2 knode v1 v2 whereknode andkedge refer to kernel functions for comparing two nodes or edges.
we define a node kernel as knode u1 u2 braceleftbigg1 if label u1 label u2 otherwise.
api query api usage exampleapi list code repo sitorycode snippets for each apioffline processing code example repository codekernelvoid foo a map a.put void foo a map a.put void foo a list a.append void foo a map a.put void foo a map a.put void foo a array a.add void foo a map a.put void foo a map a.put void foo a map a.put filereader.read voidread stringfname newfilereader fname .
read fig.
the application of codekernel to the selection of api usage examples which means that we assign a kernel value of one to two nodes with identical labels and assign zero to two nodes with different labels.
we define an edge kernel as a brownian bridge kernel of edge weights.
the brownian bridge kernel has shown good performance in many graph kernel studies .
it is defined as kedge e1 e2 max c w e1 w e2 wherewreturns the weight of an edge and cis a positive constant.
the kernel means that we assign the highest kernel value to edges that are identical in weight and assign zero to edges that differ in weight by more than a constant c.w e empirically set c as it was validated and performed well in .
for each pair of graphs we compute their kernel value using equation .
this results in a positive definite kernel matrixkn nwherenis the number of graphs.
kernel matrix is also known as inner product matrix which can be viewed as a similarity matrix.
it represents pair wise inner products of graphs in the new continuous space.
the inner product matrix can be directly manipulated by machine learning algorithms such as classification and clustering .
iv .
a pproach our primary lever for selecting code examples is to cluster source code according to their usages and select typical snippets from clusters.
to accomplish this we propose an approach named codekernel which models source code as graphs and directly clusters the graphs using the graph kernel method .
figure illustrates the application scenario of our approach.
the offline processing is responsible for selecting code examples.
it gathers relevant code snippets for each api and selects api usage examples using codekernel.
at runtime for a given api query such as filereader.read it identifies and presents relevant code examples to users.
the overall pipeline of codekernel is shown in figure .
it takes as input raw code corpus i.e.
code snippets from open source projects or code search results and outputs code examples.
the raw code is first transformed into object usage graphs .
then graphs are embedded into a continuous space using the graph kernel method resulting in an inner product matrix.
codekernel clusters the graphs in the new authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
graph embedding clustering graph construction example selection code ex amples ... .
.
.
.
... .
... .
... .
.
.
code snippets graphs graph clusters inner product matrixvoid foo a map a.put void foo a map a.put void foo a map a.put void foo a map a.put intpower intx n intp for inti x i n i p p x returnp stringprint intx n strings hello word for inti x i n i s s i number returns fig.
the workflow of codekernel space by applying a clustering algorithm to the inner product matrix.
finally the representative graph of each cluster is selected with ranking metrics and recovered as code examples.
these procedures are offline and the selected code examples are returned in response to user s queries figure .
we describe our approach using pseudo code in algorithm .
the details are explained in the following sections.
a. graph representation for source code we begin by representing source code as graphs.
a graph model contains information about text sequence structures and data dependencies hence is capable of representing a complete aspect of source code.
meanwhile it ignores the syntactical details so it is not sensitive to local contexts.
in particular in our approach we employ the object usage graph which is a graph model for source code.
object usage graph has proven to be successful in many software engineering tasks such as object usage pattern mining code completion and api recommendation .
an object usage graph is a directed acyclic graph defined as g v e wherevstands for a set of nodes controls actions and data and e v vdenotes a set of edges representing call sequences or data dependencies .
each node is associated with a label representing a class method name or a control unit .
figure illustrates an example of an object usage graph.
the action nodes such as stringbuffer .new and bufferedreader .readline stand for method calls or field accesses.
the data nodes such as stringbuffer and bufferedreader represent objects of a class.
the control nodes such as while represent controls for branches or loops.
there are two types of edges sequential edges and data edges.
sequential edges connect nodes with strict orders.
for example bufferedreader .new must be executed before bufferedreader .readline .
data edges connect a data node with action nodes if action nodes use objects or parameters of the data node.
for example bufferedreader .readline and bufferedreader .close are connected with data node bufferedreader since they both use the object brdefined in the data node.
to ease further computation we represent each graph as an adjacency matrix accompanied with a label vector.
the adjacency matrix is an n nmatrix where ndenotes the number of nodes and each entry indicates the edge type between the corresponding nodes.
we set the entry to if there is no edge between two nodes if there is a sequential edge or if there is a data edge.
the label vector lscript angbracketleftc1 ... c n angbracketright is an n dimensional vector where ndenotes the number of1 stringbuffer sb new stringbuffer bufferedreader reader new bufferedreader new filereader string line while line reader.readline !
null sb.append line n reader.close filereader.new bufferedreader.newfilereader bufferedreaderstringbuffer.new stringbuffer bufferedreader.readline while stringbuffer.append bufferedreader.close02 ..... fig.
schematic illustration of graph generation from source code algorithm high level pseudo code of codekernel input code corpus corp output code examples examples graphs buildgraphs corp letkn n n n for all graph pair g i gj graphs do ki j graphkernel gi gj end for clusters spectralclustering k letexamples for all c clusters do repr selectrepr c k examples examples coderecover c repr end for examples rank examples return examples nodes in the graph and each cirefers to the global index of the label for the i th node.
in our experiments we generate object usage graphs by applying grouminer at the function level line alg.
.
b. graph embedding with the graph representation we compute pairwise similarities between graphs for clustering line alg.
.
instead of extracting graph features such as ast element vectors n grams and statement se594 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
quences we do direct computation over graphs.
specifically we employ the graph kernel to embed the original graphs into a high dimensional continuous space in which their inner products can be accurately calculated while being computationally cheap.
for each pair of object usage graphs we compute their kernel value using equation .
this results in a positive definite kernel matrix kn nwithkijbeing the kernel value between graph iandjandnrepresenting the number of graphs.
kernel matrix can be considered as a similarity matrix which represents pair wise similarities inner products between graphs in the new continuous space.
we implement graph kernel by adopting borgwardt s code in matlab .
c. graph clustering after embedding graphs into a continuous space we cluster graphs in the new space line alg.
.
we employ a typical clustering algorithm in machine learning namely spectral clustering .
the most important reason we use the spectral clustering is that it fits our data well.
in our problem data in the continuous space is not vectorial.
therefore algorithms that require vectorial inputs such as k means gaussian mixture model and em are not applicable.
spectral clustering on the other hand takes as input similarity pairs instead of vectors.
the pairwise inner products embedded in the new space are exactly suitable for the algorithm.
spectral clustering also outperforms other clustering algorithms in many tasks .
in our approach the spectral clustering algorithm takes as input the kernel matrix generated by graph embedding and performs clustering.
we adopt a tool named spectral clusterer for weka in our implementation.
d. example selection after clustering codekernel selects code examples from code clusters line alg.
.
for each cluster the algorithm first selects a representative graph according to the designed ranking metrics.
then it presents a code example by recovering the original code of the selected graph.
rank metrics we design two ranking metrics for selecting a representative graph for each cluster.
centrality we first want the representative graph to be as generic as possible in the cluster.
that is to say the graph should have high similarity to other graphs in the cluster.
inspired by a clustering algorithm k me we define a metric centrality which measures the average distance from a graph to other graphs in the cluster.
for each graph giin a clusterc the centrality is defined as centralityi sigmoid c summationdisplay gj c j negationslash iki j wheresigmoid is a commonly used function to normalize values to the interval of .
the higher the centrality ofgi the more generic giis in the cluster.
specificity the graphs with high centralities may tend to be the larger graphs since they are more likely to be similar toothers.
unfortunately larger graphs tend to have more specific elements i.e.
edges that are rare in the cluster making the code example difficult to understand.
to penalize graphs with too many specific edges we also design the specificity metric.
for each graph giin a cluster c the specificity is defined as specificityi sigmoid egi summationdisplay e giwid f e where egi denotes the number of edges in gi sigmoid is a normalization function and wid f e represents the idf inverse document frequency weight of edge e. the idf weight measures the rareness of each edge which is defined as wid f e log c ne where c denotes the cluster size neis the number of times that edge eappears in the cluster c. the more specific the edges the higher specificity a graph has.
representative graph selection with the two ranking metrics we select a representative graph from each cluster.
we first define a ranking score for each graph in a cluster as score centrality specificity where stands for a parameter to control the penalty of specificity.
we empirically set .
.
then we rank graphs in a cluster according to their ranking scores and select the graph with the largest score as the representative graph.
finally for the selected graphs we recover their original code and rank them according to the sizes of clusters they belong to.
the examples from larger clusters are ranked with higher priorities than those from smaller ones.
v. e mpirical ev alua tion we verify the proposed codekernel model for code example selection in two aspects accuracy and usefulness.
specifically our evaluation addresses the following research questions rq1 how accurate are the api usage examples selected by codekernel?
rq2 how useful is codekernel for selecting api usage examples?
rq3 does graph kernel help improve the graph clustering performance ?
a. accuracy of selected examples rq1 accuracy is the key aspect of evaluating api example selection.
inaccurate examples may have large redundancy and low recall so developers must examine a large number of results to find useful api examples.
accuracy of code clustering we first evaluate codekernel s accuracy in code clustering namely assigning relevant code snippets to the same example.
this is important because it determines the succinctness and recall of final examples.
we selected a few typical java apis run codekernel for each api and compare the clustering accuracy against the baseline methods.
table i lists the selected apis for rq1 and their statistics.
they are widely used in the corpus provided authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i summary of selected apis for evaluating the accuracy of code clustering rq1 task1 selected apis library code corpus o f snippets api usages fileutils.writestringtofile commons io2.
projects used in ioutils.tostring filenameutils.normalize fileutils.forcemkdir ioutils.tobytearray stringutils.isblankcommons lang353 projects used in stringutils.isnotblank servant.
poa corba top results by window.pack java.awt driver.connect java.sql properties.loadfromxml java.util printerjob.pagedialog java.awt graphics2d.fill java.awt selectablechannel.register java.nio by the baseline methods.
the colunm code corpus shows the code corpus that the api usage examples are selected from.
the snippets column shows the number of methods in the code corpus that use the corresponding api.
the last column api usage shows the number of usages of each api in the code corpus.
they are determined according to our manual labels to be introduced.
accuracy measure we measure the clustering accuracy with f1 score.
the f1 score is a widely used accuracy measure for clustering in the data mining literature .
it treats clustering results as a series of decisions one for each of then n 2pairs of the instances .
for example if there are snippets s1 s2 s3 s4 which belong to cluster a a b c respectively.
to evaluate a clustering method we compare times for the pairs angbracketlefts1 s2 angbracketright angbracketlefts1 s3 angbracketright angbracketlefts1 s4 angbracketright angbracketlefts2 s3 angbracketright angbracketlefts2 s4 angbracketrightand angbracketlefts3 s4 angbracketright.
if a clustering method outputs a a a c we can see that the pairs angbracketlefts2 s3 angbracketrightand angbracketlefts1 s3 angbracketrightare grouped incorrectly.
a clustering algorithm aims to assign two snippets to the same cluster if and only if they are similar.
a true positive tp decision assigns two similar snippets to the same cluster whereas a true negative tn decision assigns two dissimilar snippets to different clusters.
there are two types of errors it can make.
a false positive fp decision assigns two dissimilar snippets to the same cluster.
a false negative fn decision assigns two similar snippets to different clusters.
f1 score is defined as f1 p r p r wherep tp tp fpandr tp tp fn .
the pvalue measures the precision of assigning snippet pairs to clusters.
a higher precision means less fps indicating that a smaller number of dissimilar snippets are assigned to the same cluster.
therefore a higher p value indicates higher coverage of clustering.
the r value measures the recall of cluster assignments of snippet pairs.
a higher recall means less fns which indicates that a smaller number of similar snippets are assigned to different clusters.
therefore a higher r value indicates less redundancy in clustering.
to evaluate the accuracy of the clustering methods we need the ground truth clusters for each api.
in our experiments table ii f1 scores of codekernel and muse apimuse codekernel p r f1 p r f1 fileutils.writestringtofile .
.
.
.
.
.
ioutils.tostring .
.
.
.
.
.
filenameutils.normalize .
.
.
ioutils.tobytearray .
.
.
.
.
.
fileutils.forcemkdir .
.
.
.
.
.
stringutils.isblank .
.
.
.
.
.
stringutils.isnotblank .
.
.
.
.
.
average .
.
.
.
.
.
we manually labeled ground truth clusters for the raw code snippets that contain the apis under study.
to reduce the labeling bias two developers independently labeled examples in the original corpus.
then they discussed for disagreements and relabeled again until agreements are reached.
baselines we compare the accuracy of our approach against muse and exoadocs .
clone detection is a widely studied task utilizing code similarity measure and muse is a successful clone based approach for code example selection.
exoadocs is the state of the art code example selection approach which clusters and ranks code snippets with similarity heuristics such as distances between ast element vectors.
as we cannot obtain the original implementation of muse and exoadocs3 to facilitate comparison we collected the code corpus stated in their papers as well as the raw results produced by their tools4.
we then run codekernel to select code example for the selected apis table i from the same code corpus provided by each paper.
finally we compare our results with the published code examples of muse and exoadocs .
for muse as we can only obtain the selected code example for each cluster from its published results we cannot compute the exact p r and f1 values.
to this end we make a relaxation by assuming that all the missing examples are assigned to a correct group.
specifically we assign missing code examples to the corresponding groups according to their ground truth labels.
therefore the p r and f1 values we compare against are upper bounds.
results table ii and iii show the accuracy results of muse exoadocs and codekernel.
as the results indicate codekernel yields code examples with higher coverage and less redundancy with average p and r values of .
and .
respectively which are greater than those of muse p .
r .
and exoadocs p .
r .
.
overall codekernel outperforms muse and exoadocs for all studied apis with an average f1 score of .
which is significantly greater than that of muse .
and exoadocs .
.
the results confirm the effectiveness of the clustering method used by codekernel.
accuracy of example selection we also evaluate the accuracy of codekernel in selecting representative examples 3the exoadocs website was down and the authors no longer maintain the code but one of them kept the code corpus as well as the raw results.
4muse published an api documentation in their website com lmorenoc icse15 muse appendix.
the documentation includes their raw results of api examples.
results and code corpus of exoadocs are provided by its authors and are the same as what used in their paper .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii f1 scores of codekernel and exoadocs apiexoadocs codekernel p r f1 p r f1 servant.
poa .
.
.
.
.
.
window.pack .
.
.
.
.
.
driver.connect .
.
.
.
.
.
properties.loadfromxml .
.
.
.
.
.
printerjob.pagedialog .
.
.
.
.
.
graphics2d.fill .
.
.
.
.
.
selectablechannel.register .
.
.
.
.
.
average .
.
.
.
.
.
from each code cluster section iv d2 .
as the ranking of code examples could be subjective we conducted a user study to evaluate the accuracy.
the user study involved developers in a multinational company m all having more than years of programming experiences.we randomly selected java apis that are not too simple nor too common5.
participants were asked to read api examples selected by codekernel as well as the code snippets in the corresponding clusters where the examples were selected.
then they were asked to rate the representativeness of the selected representative example in each cluster.
possible answers fall in a five point likert scale very accurate accurate neither inaccurate and totally inaccurate .
the results show that developers gave high ratings for the accuracy.
developers graded a high accuracy with a score of or .
the average rating score was .
indicating overall positive feedback.
the code examples selected by codekernel have less redundancy and higher coverage than those selected by the state of the art techniques and are representative.
b. evaluation of the usefulness of the selected api usage examples rq2 we conducted a user study to investigate developers perceived usefulness of api usage examples selected by codekernel.
the study involved the same participants as described in section v a2.
it consists of two tasks on randomly selected apis6 task questionnaire each participant was required to read api usage examples selected by codekernel6.
these apis were selected randomly from those that have examples in jdk or in popular tutorial websites.
then they were required to answer the following question about the usefulness of the examples overall are the selected examples useful for understanding api usages?
it has five answer options very useful useful neither not useful and totally not useful .
figure shows the statistic of developers perceived usefulness in this task.
overall developers gave a high rating of usefulness.
the average rating was .
indicating overall positive feedback from developers.
of the developers thought that codekernel is useful for understanding api usages.
among 5the full list of java apis is in our project website at 6the studied java apis are in our project website at useful useful not useful fig.
the results of user study 0510152025votes codekernel exoadoc similar fig.
feedback on tool comparison them strongly agreed with the usefulness.
the feedback indicates that developers appreciate our codekernel tool.
task tool comparison each participant was required to read api usage examples selected by two tools codekernel and exoadocs .
we hid the names of the two tools and asked participants to evaluate pairs of api usage examples6 each corresponding to a randomly selected api.
they were required to select a tool that produces better examples for the corresponding api and select similar if they consider both producing examples of the same quality.
figure shows the statistic of tool comparison feedback.
for out of pairs the usage examples generated by codekernel are considered more useful by the developers.
codekernel has overwhelming votes for most of the apis.
among all the votes developers considered codekernel s code examples better than those of exoadocs and considered they were similar.
only developers thought that exoadocs s code examples were better.
the results show that developers consider codekernel more useful than the state of the art techniques.
developers feedback indicates that the api usage examples selected by codekernel are useful.
c. graph kernel s performance on graph clustering rq3 as the most distinctive feature of our approach is the graph kernel based clustering method we also evaluate whether the graph kernel technique helps improve the graph cluster597 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv f1 scores of code clustering by different graph similarity methods apibaseline graph kernel p r f1 p r f1 fileutils.writestringtofile .
.
.
.
.
.
ioutils.tostring .
.
.
.
.
.
filenameutils.normalize .
.
.
ioutils.tobytearray .
.
.
.
.
.
fileutils.forcemkdir .
.
.
.
.
.
stringutils.isblank .
.
.
.
.
.
stringutils.isnotblank .
.
.
.
.
.
average .
.
.
.
.
.
ing performance.
to this end we replace the graph kernel component described in section iv b in codekernel with a component which directly measures graph similarities using a conventional similarity measure sim g1 g2 e1 intersectiontexte2 min e1 e2 whereedenotes the set of edges in g. this measure is used in .
basically this equation measures the ratio of common edges of two graphs.
we compare the clustering performance of both schemes that is codekernel with graph kernel and codekernel using the baseline graph similarity measure.
we use the same experimental setup as in rq1.
table iv shows the accuracy results of both schemes.
as the results indicate codekernel with graph kernel leads to better performance than using the baseline graph similarity measure.
the graph kernel technique obtains an relative improvement in terms of f1 score over the baseline method.
graph kernel can significantly improve code clustering performance.
vi.
d iscussion a. an example we now present a concrete api usage example selected by codekernel.
we will also discuss the limitations and present ideas for future improvement.
figure lists an excerpt of code example selected by codekernel for the api fileutils.writestringtofile .
these results come from a cluster consisting of instances.
the example at the top is the selected representative of the cluster.
the code snippets below instances to are instances in that cluster.
these instances are clustered together as they all follow the same pattern file.new fileutils.writestringtofile .
the first instance is selected as an example as it has high similarities to other instances and does not contain many projectspecific nodes.
we can see improvement when comparing our examples against those selected by muse figure .
first all the instances we consider to be the same are clustered together by codekernel which means codekernel can provide less redundant api usage examples to developers.
in addition the representative graph selected by codekernel contains lesscontext specific information which means our examples are more readable.
......repo.add finalstring name finalstring content finalfile dir newfile this.path finalfile file newfile dir name fileutils.writestringtofile file content this.git.exec dir add name instance centrality .
specificity .
gsisshabstractcluster.
submitbatchjob jobdescriptor jobdescriptor intnumber newsecurerandom .nextint number number ?
number number temppbsfile newfile integer.tostring number jobmanagerconfiguration.getscriptextension fileutils.writestringtofile temppbsfile scriptcontent instance centrality .
specificity .
configgenerator.
generateconfig fileinfo template fileinfo filter string outputbasepath strsubstitutor strsub map string set string misspropertiesbyfilename boolean missingpropertyfound string rawtempl fileutils.readfiletostring template.getfile properties properties readfilterintoproperties filter string processedtemplate strsub.replace rawtempl properties fileutils.writestringtofile newfile outputfilename processedtem plate instance centrality .
specificity .6023example centrality .
specificity .
repo.add finalstring name finalstring content finalfile dir newfile this.path finalfile file newfile dir name fileutils.writestringtofile file content this.git.exec dir add name fig.
the code example for the api fileutils.writestringtofile yielded by codekernel still codekernel has limitations and could yield incomplete results.
it may not exhibit the complete data flow.
for example in example shown in figure the definition of the field reference this.path is not included in the sample code developers need to browse the original source code file to understand its definition.
furthermore the selected examples could contain project specific identifiers and statements such asthis.git.exec ... and content .
the project specific statements should be trimed and the name of the identifiers can be normalized.
in the future we will perform more advanced program analysis on the sample code to further improve the completeness and readability of the code.
particularly we will investigate the synthesis of sample code directly from the selected object usage graph.
b. why does codekernel work?
a fundamental challenge to mining source code is that source code is not continuous data.
it is discrete structural and composite.
there is no explicit coordinate and vector that can fully characterize it.
therefore code similarities are difficult to compute.
existing approaches try to make it continuous either by feature extraction which transforms code to fixed length real value feature vectors or by similarity heuristics.
however the feature vectors they extracted just approximate partial information of the code e.g.
tokens ast elements authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
orders and topics .
therefore these approaches often lead to inaccurate code examples.
our approach addresses such challenge by directly embedding the graph representation of source code into a continuous space without explicit feature extraction.
the graph embedding conserves full aspects of the original graphs and is more accurate than methods that extract feature vectors from code.
vii.
t hrea ts to validity as a proof of concept all apis and related projects investigated in our experiments are written in java.
although java is one of the most popular programming languages it might not be representative of apis written in other languages such as python.
however codekernel is not limited to a certain language as it operates on software graphs which can be extracted from most languages.
evaluating our tool for other languages remains our future work.
in the evaluation of cluster accuracy we compared our results with those of related methods muse and exoadocs .
however the tool implementations of the related methods were unavailable to us.
so in our comparison we had to use the published results and datasets as the related methods used which are relatively small in scope.
in the future we will reimplement the related methods and conduct empirical studies on more datasets to further evaluate these tools.
in our work we perform user studies to evaluate the accuracy and usefulness of the selected api usage examples.
although our user studies involved developers the scope of the experiments is still limited.
furthermore the participants examined a small number of apis.
therefore our user studies could introduce bias.
in the future we will perform large scale user studies involving more participants and apis.
viii.
r ela ted work a. code example selection code example selection has shown to be important in many software engineering tasks such as api documentation code search and code completion .
the mainstreaming technical direction to select code example is to cluster relavant code snippets according to similarity heuristics and rank or synthesize an example from each cluster.
for example kim et al.
proposed exoadocs which clusters and ranks code snippets according to their distances between ast element vectors.
buse and weimer proposed to represent code snippets as cfgs and cluster them according to their similarities of statement ordering and data type usages .
however the simplified feature vectors only approximate partial aspects of the code e.g.
tokens ast elements orders and topics .
therefore their approaches tend to produce inaccurate code examples.
different from the aforemensioned approaches codekernel clusters graphs by embedding them to a continuous space.
the graph embedding keeps full aspects of original graphs and is more accurate than methods that extract feature vectors from code.another line of work has investigated marrying state of theart code clone and sample selection techniques.
for example moreno et al.
proposed muse that selects usage examples of a given method by slicing out relevant snippets from code corpus and identifying similar examples through textbased clone detection .
codekernel differs from muse in that it clusters similar code snippets at an abstract usage level.
recently there is also much work that utilizes statistical machine learning and deep learning .
for example nguyen et al.
proposed api code recommendation using statistical learning from fine grained changes .
they also proposed a deep neural network language model with contexts for source code .
codekernel differs from these approaches in that it directly embeds exact graphs without learning and statistically approximating the graph features.
the latter is often computational expensive and cannot represent the exact original graph.
b. mining api usage pattern instead of selecting code example for an api a large number of approaches focus on mining api usage patterns .
usage patterns are often represented as method call sequences or even statistical models .
xie et al.
proposed mapo which is one of the first work on mining api patterns from code corpus.
mapo represents source code as call sequences and clusters them according to similarity heuristics such as method names.
it finally generates patterns by mining and ranking frequent sequences in each cluster.
up miner is an improvement of mapo which removes the redundancy among patterns by two rounds of clustering of the method call sequences.
nguyen et al.
proposed salad a statistical model to learning api usages from bytecode.
similar to codekernel it represents bytecode as a graph based model that captures method call sequences control and data flows.
it learns api usages from graphs using the hidden markov model hmm .
fowkes and sutton proposed a probabilistic algorithm that mines the most informative and parameter free api call patterns.
while such sequential or statistical patterns have shown to be useful for api recommendation and code completion they are insufficient for developers to understand the detailed usage of the apis.
it is difficult to reuse an api usage pattern without code structures.
different from previous techniques codekernel selects code examples that exhibit code structures as it represents source code as graphs instead of call sequences or statistical models.
c. graph based object usage pattern besides codekernel there have been other work that uses graph to represent source code and mines api patterns .
the grouminer introduced the concept of object usage graph and applied it to mine object usage patterns.
as indicated in section ii d grouminer could produce redundant patterns since it is based on frequent pattern mining.
codekernel utilizes the object usage graph proposed by grouminer authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
it addresses the limitation of grouminer by leveraging a graph kernel based clustering technique thus producing less redundant code examples.
gralan is another approach that uses the object usage graph to mine object usage patterns.
it proposes a graph based statistical language model for code suggestion.
different from gralan codekernel mines explicit code examples from a code corpus.
ix.
c onclusion we have proposed codekernel for the selection of api usage examples.
instead of approximating source code as feature vectors or sequences we represent source code as object usage graph and cluster the graphs by embedding them into a continuous space.
our evaluation results suggest that codekernel provides more accurate and understandable examples than the state of the art techniques.
feedback from developers is also very encouraging of our examples were preferred to the state of the art technique developers considered codekernel useful for selecting api usage examples.the code examples selected by codekernel can be found at our website at graph embedding could also be applied to other tasks that require feature extraction on source code such as code retrieval and code clone detection which will be our future work.
in the future we will also investigate deep learning based techniques to further improve the completeness and readability of the code examples.
x. a cknowledgments this work is partially supported by nsfc grant .