libd scalable and precise third party library detection in android markets menghao li wei wang pei wang shuai wang dinghao wu jian liu rui xue wei huo key laboratory of network assessment technology institute of information engineering chinese academy of sciences china college of information sciences and technology the pennsylvania state university university park pa usa state key laboratory of information security institute of information engineering chinese academy of sciences china school of cyberspace security at university of chinese academy of sciences china limenghao wwei liujian6 xuerui huowei iie.ac.cn pxw172 szw175 dwu ist.psu.edu corresponding author abstract with the thriving of the mobile app markets thirdparty libraries are pervasively integrated in the android applications.
third party libraries provide functionality such as advertisements location services and social networking services making multi functional app development much more productive.
however the spread of vulnerable or harmful third party libraries may also hurt the entire mobile ecosystem leading to various security problems.
the android platform suffers severely from such problems due to the way its ecosystem is constructed and maintained.
therefore third party android library identification has emerged as an important problem which is the basis of many security applications such as repackaging detection and malware analysis.
according to our investigation existing work on android library detection still requires improvement in many aspects including accuracy and obfuscation resilience.
in response to these limitations we propose a novel approach to identifying thirdparty android libraries.
our method utilizes the internal code dependencies of an android app to detect and classify library candidates.
different from most previous methods which classify detected library candidates based on similarity comparison our method is based on feature hashing and can better handle code whose package and method names are obfuscated.
based on this approach we have developed a prototypical tool called libd and evaluated it with an update to date and large scale dataset.
our experimental results on apps show that compared to existing tools libd can better handle multi package third party libraries in the presence of name based obfuscation leading to significantly improved precision without the loss of scalability.
keywords android third party library software mining i. i ntroduction mobile app market has been rapidly growing in the past decade.
by july android has become the largest mobile application platform in terms of the number of available apps .
third party libraries make app development much more convenient by offering ready made implementations of specific functionality e.g.
advertisement navigation and social network services.
a previous study shows that in some extreme cases an android app can refer to more than different third party libraries .
on the other hand the widely used third party libraries can also lead to new problems that hurt the security and stability of the android ecosystem.
for example with advanced reverse engineering techniques an adversary is able to modify popular advertising libraries and direct the revenues to a station underhis control while preserving the other functionality of the original apps.
the adversary can then deploy the tampered and repackaged apps into an unofficial android market to lure downloads.
in this way an attacker can contaminate a large number of apps by just tampering a few libraries.
for another example if a specific version of a popular social network library contains a security vulnerability the threat from this vulnerability would be spread to many different apps and influence tons of users.
to countermeasure the emerging threats caused by vulnerable and harmful third party libraries the security community has longed for reliable techniques to accurately identify libraries in mobile apps at a large scale.
there are currently two approaches to recognizing third party libraries in android apps.
the first is based on whitelists of known libraries.
a whitelist is typically generated through manual analysis and has to be constantly maintained to stay updated.
even though it is hard to guarantee that such a list is comprehensive considering there are currently millions of mobile apps available and new library providers keep emerging.
therefore the whitelist based method usually leads to both precision loss and high operation cost.
the other approach is to directly extract libraries from apps without a priori knowledge about the libraries .
in the extraction process a mobile app is first divided into different components which are regarded as library candidates.
then a similarity metric or a feature based hashing algorithm is designed to classify these candidates.
if a group of similar candidates exists in different applications components in that group are considered variants of the same library.
the second approach is currently the state of the art.
although the results reported by previous work have been very promising they are still not as good as they could have been due to several limitations of the employed methods.
our investigation shows that most existing methods are heavily dependent on java package names and package structures when detecting and classifying library candidates.
however package names can be easily mangled by name based obfuscation and package structures may vary in different versions of the same library.
to further improve the accuracy of third party library identification on the android platform we propose a new library ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detection and classification technique that can effectively overcome the limitations discussed above.
different from previous work which recognizes library candidates purely based on the java package names and structures we extract library candidates based on the reference and inheritance relations between the java classes and methods with the assistance of auxiliary information excavated from app metadata.
after collecting these candidates our classification technique will decide if there exist enough apps sharing the same group of candidates.
if so that group of candidates indeed forms a third party library.
our classification method is implemented through a novel feature hashing algorithm such that we can avoid pair wise candidate comparison which is required by approaches based on binary similarity measurement.
this design makes it easier for the classifier to scale to millions of android apps.
compared to previous work which heavily depends on java package names and structures our method only treat them as supplementary information.
as such our research provides a more general solution to the problem of third party library identification for android.
we have implemented our detection technique in a tool called libd and evaluated it with apps collected from third party markets.
compared with similar tools like libradar and wukong libd can not only identify a much larger number of third party libraries from the dataset but also find them with a higher precision.
in summary we make the following contributions in this research.
we develop a new third party library identification technique for the android mobile platform.
our method can overcome various limitations shared by the majority of previously proposed approaches.
in particular our method is resilient to java package name based obfuscation and diversified package structures.
we implement our identification technique in a tool called libd and test its performance with more than a million android apps collected from different markets.
compared to other similar tools libd is able to report better results in terms of both quantity i.e.
the number of identified third party libraries and quality i.e.
the identification precision.
to benefit the research community we share libd at other researchers will be able to build various software engineering and security applications based on our work.
the rest of the paper is organized as follows.
we first discuss the limitations of the previous work which motivate our research in section ii.
we then present our third party library identification method and its implementation in section iii.
the experimental results are presented in section iv.
we discuss a few potential issues in section v review related work in section vi and conclude the paper in section vii.
ii.
m otiv a tion in this section we elaborate on two major limitations of previous research that motivate the development of our newopen tauth connectcom tencent open connect tauth utils acom tencent bapp app different versions of the same library fig.
v ariants of the same library with different package structures third party library identification technique.
according to our investigation the two limitations stem from similar design decisions shared by existing techniques.
the assumptions behind these design choices although valid in many cases do impose constraints that affect the generality of the techniques.
the first assumption which may be problematic is that the instances of an android library included by different apps have the same package name.
this assumption is the basis of the pre clustering algorithms used in similarity based library identification .
since these methods need to compute the pair wise similarity among all library candidates in the dataset they have to first partition the dataset and group candidates that are likely to be in the same cluster otherwise the classification will not scale.
most similarity based identification techniques use package names to tentatively cluster the candidates before undertaking fine grained comparison.
however using package names as a feature for clustering becomes unreliable when obfuscation is considered.
package name obfuscation is one of the most widely used obfuscation methods for java code.
a recent study on android libraries showed that over half of the inspected instances are protected by obfuscation techniques .
as a consequence identification methods utilizing package names as the primary features to detect and classify libraries are likely incapable of handling a considerable portion of android apps on the market.
some researchers have realized that deeply depending on package names can make the identification method less robust.
a recent tool called libradar developed an algorithm that takes obfuscated package names into consideration.
rather than binary diffing libradar classifies library candidates through feature hashing.
therefore libradar does not need pair wise similarity comparison between library candidates and does not need package names for pre clustering.
however libradar recognizes library candidates according to the directory structures of the packages.
in particular libradar requires a library candidate to be a subtree in the package hierarchy.
this is another assumption that may not be valid in reality because we found that a library can be differently packaged in its different versions as illustrated by a real world example in fig.
.
motivated by the reasoning above we aim to develop a new third party library identification method that does not take the two aforementioned assumptions for granted.
although our method does not completely abandon the package level information we utilize it as supplementary features in the identification process.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iii.
m ethod a. overview we now outline the design of the proposed approach.
as shown in fig.
the overall workflow consists of four steps.
we first decompile the input app and recover the intermediate representation ir .
information is then retrieved from the ir regarding multiple levels of the android app organizations i.e.
packages methods and classes and the primary relations among them i.e.
inclusion inheritance and call relations .
we then leverage the retrieved information to build the instances of potential libraries.
note that each instance has standalone functionality and it consists of one or multiple packages.
the next step is to generate features from each instance we propose techniques at this step to select features that are mutationsensitive and resilient to name based obfuscation hereinafter referred to as simply obfuscation .
with a predefined threshold of occurrence third party libraries are identified by clustering instances with equivalent features.
we have implemented our technique in a prototype tool called libd which consists of lines of code in python.
we deployed our experiment environment on openstack a cloud computing platform .
we implemented lines of code to manage machines and schedule experiments on this platform.
ten virtual machines were employed to analyze android apps in parallel.
b. app decompilation the first step of our approach is to decompile the input android apps.
as shown in fig.
a a directory tree is generated by decompiling an android app.
each node on the directory tree can include java class files as well as subdirectories i.e.
the edges to the successor nodes .
note that each tree node with a set of class files is actually an android package in this research we group package nodes on the directory tree to recover third party library instances.
there also exist some other nodes that only contain subdirectories e.g.
com tencent node in fig.
a we ignore such nodes due to their trivial contents.
same as existing work we employ two commonly used app analysis tool apktool and androguard to decompile the input apps.
apktool is used to extract the tree structures of the decompiled apps.
we recover the whole directory structures with all the class files.
in addition we use androguard to find relations between packages classes and methods.
three informative relations are particularly collected to construct the homogeny graphs iii c1 and call graphs iii c2 .
we now introduce each relation in details.
inclusion relation.
the first relation describes the parentchild structures on a directory tree.
considering the path that leads from com tencent to connect in fig.
a such path represents an inclusion relation.
inheritance relation.
we also record the program inheritance relations inheritance relations can be directly read from the decompiled class files.
fig.
b shows theinheritance relations between package common and two other packages.
call relation.
this relation represents the inter package function calls.
fig.
c describes the call relation between packages connect auth tauth and open .
for example by identifying the function call between methods in auth.. ..listener.smali and authactivity.smali tauth i.e.
callee and connect auth i.e.
caller are considered to have the call relation.
c. library instance recovery one of the key contributions in this paper is our systematic approach to recovering the boundaries of third party libraries.
given the decompiled outputs of an input app we traverse its homogeny graphs explained in iii c1 as well as the call graph for multiple iterations each of which relies on different conditions to prioritize nodes and edges.
the outputs of our traversals are weakly connected components each component including one or several packages has an independent functionality and such components are assumed as the instances of potential libraries.
we now detail our technique to recover library instances in a two step approach.
homogeny package union construction the first step is to find highly correlated packages regarding the inclusion and inheritance relations iii b .
before discussing our algorithm we first define three terms as follows.
definition homogeny package.
letpiandpjbe two packages of the input app we say piandpjare homogeny packages if there are inclusion or inheritance relations between them.
definition homogeny graph.
a homogeny graph is a directed graph h v e where vis the set of all the app packages and eis the set of inclusion or inheritance relations.
definition homogeny package union.
a homogeny package union consists of one or several homogeny packages each union is a weakly connected component on the homogeny graph.
a weakly connected component is a maximal connected subgraph of the undirected graph resulted from replacing all the directed edges with undirected edges in the original directed graph.
algorithm describes how we find homogeny package unions.
we construct the homogeny graph with every package in the app and their inclusion and inheritance relations as the graph edges line line .
note that before constructing the graph we first eliminate two kinds of special packages line .
the first elimination line rules out packages at the root of a directory tree.
according to our observation an app usually does not have class files in the root directory developers would put the code base packages starting from the second level of the directory tree.
actually our study on commonly used apps only finds three apps to have class files in the root nodes.
further investigation shows that all of these class files are used to impede reverse engineering.
as a result we rule out packages if they are in the root authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
method info call class info inheritance package info inclusion decompilation library instance recovery candidate databaselibrarieshomogeny package union constructionlibrary instance construction library identification filter with thresholdfeature generation method method... class ...class hashlibrary feature hash... fig.
the architecture of libd connect mm ... share ... inclusion ...userinfo.smali avatar baseapi.smali image.. ..lmp.smali.super .. common b aseapi .super .. common baseapiuserinfo.smali qqshare.smali qzoneshare.smali connect auth tauth open auth.. ..listener.smali l.. connect auth auth .. .. a ... authactivity.smalitencent.smali l.. tauth tencent ask ... socialapi.smali a inclusion relation b inheritance relation c call relation under package of com tencent connectunder package of com tencent call commoncom tencent fig.
packages in a typical app directory tree and three critical relations.
nodes.
besides the android official libraries e.g.
android support v4 are also trimmed off line as our main focus is on the third party libraries.
after the elimination we search for weakly connected components on the homogeny graph line such components could contain single or multiple nodes packages .
as nodes in each component are connected by inclusion and inheritance edges each identified component is one homogeny package union following our definition.
algorithm homogeny package union construction input android app p output homogeny package union set hp 1hp h 2h.v packages in the input app vis the set of vertices.
3filter out packages in the root nodes in h 4filter out android official packages in h 5h.e inclusion relation set eis the set of edges.
6h.e h .e inheritance relation set 7for each weakly connected component g in hdo 8hp.add g 9returnhp library instance construction given the constructed homogeny package unions the next step is to group one or several unions together to recover the instances of potential third party libraries.
our manual investigation of over real world commercial apps reports method calls as a quite informative feature.
thus we first recognize all the inter union function calls and build the call graph.
as a result identifying library instances essentially becomes a task to collect all the reachable nodes on the call graph from the root nodes.
algorithm presents our approach to generating the call graph for homogeny package unions and finding the instances of potential libraries.
we first build the call graph i according the inter union calls line .
we then filter out noisy calls line in terms of two criteria.
finally for each weakly connected component we search for root nodes and collect all the reachable components from one root node as one instance of a potential library line .
naturally the root node is defined as a node on the call graph with no incoming edges.
on the other hand if there is no root node we output the connected component as one library instance line .
in this research we identify and eliminate two noisy calls that could impede our analysis.
the first one describes the call graph edges connecting the application code and the libraries.
such connections could incorrectly bridge two library instances through the application code thus overestimating the library boundaries.
we identify application code according to the manifest files in the input apps the application code and evolved call edges are trimmed off on the call graph line .
we also observe a special call that could lead to false positive in this research we name it ghost call .
a ghost call appears in a method but neither the caller nor the callee exists in the dex code of the decompiled app.
actually such ghost calls are not rare we find apps containing the ghost calls during our analysis of test samples.
most of ghost calls are calling functions from customized android frameworks.
for example there is a call invoking com.samsung.android.
ssdkinterface.getversioncode which exists only on samsung phones.
the decompiler failed to consider these cases leading to dangling function targets.
to filter out such errors we check the appearance of both caller and callee for each call relation and eliminate those ghost calls line .
d. feature generation as previous mentioned a library instance includes one or more homogeny package unions while a union can consist of multiple packages.
the feature of a library instance can be defined as the combination of package features and further authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm library instance construction input homogeny package union set hp output library instance set il 1i 2i.v h p vis the set of vertices.
3for any union u1andu2inido ifthere is a call relation in angbracketleftu1 u2 angbracketrightthen add angbracketleftu1 u2 angbracketrightini.e eis the set of edges.
6filter out application code related calls in i 7filter out ghost calls in i 8for each weakly connected component g in ido ifthere are root nodes in g then for each root do cl reachable components from this root il.add cl else il.add g 15returnil divided into features of classes in each package.
since each class usually consists of several methods in this research we employ method level features as the basic elements to construct the library instance level features.
to this end we first build the control flow graph cfg of each method.
the feature of every basic block on the cfg is calculated by hashing all the opcodes inside the block.
we then concatenate the features of the basic blocks on the cfg in a depth first order.
for a parent node with two or more children we sort the values of the children nodes and prioritize the node with the smallest value.
we then construct the feature of a class with features of all its methods.
to this end we concatenate the feature values of all methods in a non decreasing order.
such feature sequences is then hashed again as the class level features.
finally we build the library instance level feature following the same strategy sorting all of its class level features in a non decreasing order and hashing the feature sequences.
note that one of our central design choice is to generate mutation sensitive and obfuscation resilient features for each library instance such design choice can enable finer grained android app analysis in an efficient way.
we now discuss how we satisfy such requirements.
mutation sensitive to produce features that are sensitive to library mutations we generate hash value from opcodes ofallthe instructions in the basic blocks.
since even subtle modifications would lead to the changes of the underlying instructions our instruction level hashing should be surely updated regarding almost all the mutations.
actually many security related mutations e.g.
the remote control vulnerability exposed in baidu moplus sdk would only update a single line of code in one specific version of the library.
that means previous system api based library detection algorithm is not able to distinguish such mutations.
on the other hand by hashing the underlying instructions within each basic block features utilized in our research can preserve the sensitivity in front of various real world scenarios.naturally mutations with different features are considered as different library instances.
that means instances of one library can be put into different groups if they have different features.
to further cluster mutations we compare the package names of mutations in our current design two mutations are considered from the same library if they have the same name.
obfuscation resilient our in depth study of obfuscated android apps shows that commonly used android obfuscators are typically designed for renaming package class and even method names will be obfuscated into meaningless strings e.g.
t a b .
stating such observation libd is designed to only hash the underlying opcode sequences as the features of each basic block.
note that by extracting features from the underlying implementation libd is naturally resilient towards renaming on package names.
in addition although renaming on class and method names can change the operands of certain control flow instructions the original opcodes are preserved.
for example method call instructions would have different operands when the callee s name is obfuscated.
however since we only calculate the hashing value of the opcode sequences within basic blocks and do not consider the operands libd is suitable to defeat the class and method level renaming obfuscations.
in sum features extracted by libd are obfuscationresilient as shown in our experimental results.
note that given our renaming resilient features obfuscated library instances should be clustered into the same group as their normal versions.
in other words we are able to recover the original identity of the obfuscated libraries by investigating instances clustered into same groups.
e. library identification given an input app the aforementioned techniques can generate instances of potential libraries iii c as well as features of each instance iii d .
we actually repeat such process towards a large amount of apps and collect all the identified instances and their features experimental details are disclosed in iv .
the next step is to cluster instances regarding their features instances with equivalent features are put into one group.
we set a threshold according to our empirical study results.
a group of library instances is considered to truly represent a third party library only if the number of instances in this group is equal or greater than the threshold.
details on how we set the threshold are presented in iv b. we label each cluster with the library name found in the package information.
we also try to merge certain clusters if they have the same library name such merged clusters should indicate library mutations.
iv .
e v alua tion a. dataset we collect in total android apps from thirdparty markets.
although the official app market google play contains over a million apps it employs more rigorous reviews on the uploaded apps including both static and dynamic analysis and presumably many malicious or vulnerable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i markets and the number of apps collected from each market.
market of apps market of apps mumayi appfun apk91 520apk nduo lenovo lmobile baidu sougou jifeng anzhi yingyongbao anzow hiapk zs2345 gezila 7xz xiaomi huawei yy138 16app liqucn apk3310 angeeks appchina others total table ii detected third party libraries with different threshold settings.
threshold of different instances of different librariesthreshold of different instances of different libraries third party libraries could have been rejected during the review process .
on the other hand third party markets usually do not have such review process and we expect to collect more diverse library instances.
as reported in our experiments we successfully collect a considerable number of mutation and obfuscation samples.
we choose broadlyused third party markets e.g.
huawei and apk91 as well as some infamous android forums for evaluation.
table i lists the markets we used and the corresponding apps collected in each market.
b. threshold recall we need to define a threshold to decide whether a cluster of library instances surely represents a third party library iii e .
the threshold is the number of appearances of a potential library candidate in the dataset in our research and previous studies .
in this section we first study how many libraries can be detected regarding different thresholds and try to set a reasonable threshold by comparing with a previous whitelist approach .
previous work sets different thresholds to cluster libraries.
for example wukong sets the threshold as while li et al.
use .
to present an in depth and thorough study we iterate different thresholds from to and record the clustered libraries.
table ii shows the detection results regarding different threshold settings.
recall libd clusters library instances with the same feature into one group and further clusters groups together if they have the identical name iii e .
in table ii we report the number of library instances with different features as well as the number of different library names i.e.
the detected libraries .
naturally with the increase of the threshold less libraries can be found.
we consider the total number of detected libraries is quite promising.
even by setting the threshold as a relatively high value i.e.
we report libd can still detect over two thousand libraries.table iii the number of libraries reported in the whitelist but not found in libd s outputs.
threshold of neglected libraries threshold of neglected libraries when comparing with previous work we report that libd can detect more third party libraries than both whitelist and system api based methods .
we will present further discussions in iv d. setting threshold according to a library whitelist .
chen et al.
present a whitelist including names of commonly used third party libraries in the market.
we validate each threshold used in table ii to find a proper one that could include allthe libraries reported in the whitelist.
as shown in table iii when the threshold decreases to ten all the libraries reported in the whitelist can be found in libd s outputs.
as a result ten is used as the threshold in our following experiments.
c. comparison with libradar to our best knowledge there is no systematic approach to giving us the ground truth i.e.
third party libraries from android apps the boundary of a library is unknown.
manual collection is also not feasible with over a million apps.
to present a convincing and feasible evaluation we randomly collect apps from our dataset as a subset and manually investigate the subset to get the ground truth.
we assume a package name indicates an instance of a third party library if it is a legal domain name.
we employ nslookup to check the package names on the domain name system dns according to the following conditions.
if the library name represents a legal domain name then it is a library instance.
if the package name is a subdomain of a domain name we will then check the entire name on search engines e.g.
google to verify whether the suspicious name has been used by others.
if so we consider to find a new library instance.
following the above strategy we acquire in total libraries as the ground truth from the apps.
we then use libd and a state of the art library detector libradar to detect third party libraries in the apps.
libradar provides an online service to detect libraries this enables convenient comparison with libd.
as libradar only provides the names of the detected libraries we compare libd with libradar regarding the library names.
table iv presents the performance of both libradar and libd.
we also validate the detected libraries according to the ground truth.
in general libd identifies libraries among which libraries are true positive.
libradar finds different libraries in total and libraries are true positive.
considering the false positive and negative rates we report that libd can notably outperform libradar in both criteria and the overall result is quite promising.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv comparison with libradar.
we also validate the results according to the ground truth libraries .
of detected libraries of true positivefalse positive rate false negative rate libradar .
.
libd .
.
besides the validation according to the ground truth we also evaluate the correctness in terms of obfuscated libraries.
both libradar and libd are able to map the obfuscated libraries to their unobfuscated instances.
as the online service of libradar is not stable during our experiment we were only able to test apps at this step.
among these apps libradar reports to find obfuscated libraries while libd reports .
our manual investigation on the outputs of libradar shows five false positive.
for example libradar incorrectly considers library com avos avospush as an obfuscation version of the android official library android support v4.
note that the implementations of these two libraries are quite different.
on the other hand no error is reported when we manually correlate the obfuscated libraries detected by libd with their original instances.
we interpret the main reason for libradar s high false positive is that it captures features from the system apis used by the libraries two libraries are considered identical if they use the same apis.
on the other hand since libd captures the features regarding the underlying implementation commonly used obfuscation methods would not impede libd.
d. comparison with other work table ii reports our library detection results regarding different thresholds.
in the following section we present an in depth study on this library detection results and compare the results with previous work in terms of different aspects.
comparing with li et al.
.
li et al.
detect libraries from apps on google play .
like the whitelist approach li et al.
only provide the detected unobfuscated library names.
we compare their reported names with libd.
in general among libraries detected by their approach we report libraries are new to libd.
further study shows that of the libraries are indeed highly correlated to our results they have similar names and structures.
for example com comscore exceptions andcom comscore stramsense are two libraries reported in their list which have no match in our results.
however we found a library named com comscore in the outputs of libd this library has the same root and second directory names i.e.
com andcomscore .
given the similar names and structures we assume these unmatched libraries are caused by different techniques deployed to recognize library boundaries.
our finding also shows that there are libraries totally new to libd.
since li et al.
analyze apps on the google play we expect libraries that are only used by apps in the google play would be unknown to libd.
for example several apps on google play are linked with library com android psu and this library is absent in our third party market dataset.comparing with wukong .
comparing with wukong our approach finds more libraries with the same threshold.
wukong takes as the threshold to detect libraries and we evaluate libd with the same threshold.
in addition since wukong considers each mutation referred as version in their paper as one library here we use the same measurement for libd i.e.
the of different instances columns in table ii .
in general wukong reports to detect around libraries in while libd finds libraries with the same threshold.
we interpret the comparison results as quite promising.
in particular we consider such improvement mainly comes from the much finer grained features retrieved by libd.
as previously discussed features captured by libd are sensitive to the underlying mutations of the apps.
on the other hand since wukong uses system level apis to detect libraries this approach is not suitable to find many subtle library mutations iii d .
e. processing time our system is deployed on top of openstack including ten virtual machines.
all the virtual machines are configured with a xeon e3 cpu and 2gb ram.
the operation system is ubuntu .
lts x64.
we report that libd takes no more than seconds to analyze an app.
app decompilation iii b including intermediate representation recovery and package relation construction takes around seconds.
library instance recovery iii c takes around seconds.
average clustering time of one library instance is less than milliseconds and we report on average it takes milliseconds to cluster all the library instances in an app.
comparing with libradar we report libd s average processing time for one app is around seconds longer.
naturally as libd undertakes much finer grained analysis it can cost more time.
overall libd is quite efficient and scalable.
f .
further investigation in the following subsections we study three typical challenges in android library detections i.e.
multi package libraries obfuscated libraries and library mutations.
note that as we confirm a library mutation according to the number of instances in a cluster iii e some instances even if they are multi package obfuscated or library mutations would be ignored if the total number of their appearances is less than the threshold.
to present a thorough study we use all the different instances of potential libraries in the whole set of apps for multiple evaluations in the following subsections i.e.
data reported in the of different instances columns in table ii .
multi package libraries a third party library may contain more than one package.
benefited from our novel library boundary identification technique libd discovers many multipackage libraries.
in particular when setting the threshold as ten we report to find multi package libraries .
of all the detected libraries in total .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
distribution of different multi package library instances regarding the number of packages.
fig.
distribution of different multi package library instances regarding the number of structures.
we also use all the different library instances for evaluation as they can reveal potential rare changes on the third party libraries.
fig.
presents the distribution of different multipackage library instances.
the number of library instances decreases quickly with the increase of the packages each instance contains.
most of the multi package instances contain two packages there are in total two package instances .
of all the multi package instances .
we manually analyzed commonly used instances e.g.
com tencent wap and the result shows that the library boundaries are reasonable.
we also find that multi package library instances can have different internal structures.
for example library fly fish adil has three different structures each of which contains two three and four packages respectively.
we consider two library instances have different structures if their internal package names or the number of packages are different.
we also report the distribution of different multi package instances regarding the number of structures.
as shown in fig.
while there are instances with only one structure instances actually contain more than two different structures .
of the multi package instances .
our experiments also report that a library could have different structures at most.
further investigation of multi package libraries also reports that some packages are shared by several multi package libraries.
those shared packages usually provide some common utilities.
table v presents packages that are shared by at least two libraries.
given the observation that the first twotable v five shared packages and evolved libraries.
shared packages evolved libraries cn sharesdk framework cn sharesdk douban cn sharesdk sina cn sharesdk wechat cn sharesdk oneshare cn sharesdk tencent cn sharesdk twitter cn sharesdk google cn sharesdk whatsapp com weibo sdk com weibo net com weibo android cn emagsoftware sdk cn emagsoftware android cn emagsoftware sms com umeng common com umeng update com umeng analystic com umeng newxp com umeng socilize com mobi tool com mobi controller com mobi weather com mobi assembly table vi top ten commonly used first two segments of package names.
directory of libraries org fmod twitter4j util lbsapiprotocol a twitter4j management com unionpay twitter4j json com tencent roboguice content com umeng com facebook segments of these package names are the same we assume that they should come from the same developers.
many library names have three or even more segments e.g.
com facebook util has three segments .
however we observe that many of the first two segments of package names are identical.
we report that there are in total different kinds of first two segments in the outputs of libd we list the top ten in table vi.
note that if the first two segments of two library names are identical they are likely from the same developers.
in other words table vi shows that most library developers prefer to provide a series of libraries instead of one.
obfuscated libraries libd is designed to address name based obfuscation techniques.
obfuscators e.g.
proguard replace the library name with several meaningless strings while preserve the original directory structures.
our experimental results report two kinds of renaming strategies.
the first one obfuscates the library full names all the names in the directory structures are replaced with meaningless strings such as c a b oru y e .
for such obfuscation we are unable to get any useful information by only analyzing the name.
the second obfuscation partially changes the library names e.g.
the last segment of the library name com tencent tis obfuscated .
libraries with such partial obfuscation can usually provide some information of their functionalities or developers.
as shown in table ii by setting the threshold as ten libd can detect different libraries in total.
with our manual authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table vii distributions of the obfuscated library instances.
of obfuscated names of instances percentage .
.
.
.
.
.
total table viii libraries with the top ten number of mutations.
rank library name of mutations in each identified library of mutations in total com sina sso com ut device com nineold androids animation com alipay android m framework utils com google gson com android vending com alipay mobilesecuritysdk com tencent mm cn sharesdk wechat effort we report that there are about obfuscated library instances in our dataset among which are completely renamed while the rest around are partially renamed.
according to our best knowledge there is no well developed automatic approach to distinguishing a partially renamed library from the others.
in other words our manual verification of library obfuscation is already the best effort.
in total we have found that different library instances i.e.
library instances with different features are obfuscated.
table vii presents six groups of obfuscated instances instances in each group have different number of obfuscated names.
in general around .
library instances have equal or greater than different obfuscated names.
we interpret that obfuscations are actually quite common in realworld android applications.
library mutations in this section we study the library mutations.
in general our experimental results report plenty of libraries with more than mutations.
for example com google gson has different mutations while com baidu android has mutations.
table viii lists the identified third party libraries with the top ten number of mutations.
we also report the number of mutations when considering all the different library instances iv f .
our study shows that many mutations indeed only modify a few lines of code.
for example each updating on library com ut device only adds a few move opcodes.
we also find some major updates among mutations of certain libraries i.e.
library structure level changes.
for example some mutations of com google gson contain only a few classes while others can even include multiple packages.
another finding is that the number of the ignored mutations fourth column in table viii is even greater than the confirmed library mutations.
in other words we consider there are actually many libraries having stealthy mutations mutations that are only used by less than apps in the third party markets we studied.
we consider these mutations potentially indicate illegal or even malicious behaviors.v.
d iscussion obfuscation.
obfuscation has been broadly used by many android applications.
in this section we investigate the commonly used android obfuscation tools and discuss the potential advantages and weakness of our techniques in front of them.
proguard the official obfuscation tool provided by the android sdk is considered the most popular obfuscator in the android developer community.
this tool is essentially designed for renaming obfuscation.
typical renaming obfuscation can modify the package class and even method names into meaningless strings.
as previously discussed iii d2 by hashing the underlying opcodes libd is resilient to the renaming obfuscations.
our evaluation also presents promising results in detecting obfuscated third party libraries iv f2 .
we have also noticed that some obfuscation tools can perform code encryption or even program control flow based obfuscations .
given our current design such advanced obfuscations can impede libd to certain degree.
however since most code encryption and control flow based obfuscations follow predefined patterns deobfuscation is mostly feasible.
actually there has been much orthogonal work proposing to deobfuscate those techniques .
setting threshold.
as previously discussed iii e libd identifies libraries according to a predefined threshold and we set the threshold by validating a board set of candidates regarding an existing work iv b .
although our experiments report promising results given the threshold as ten conceptually a module shared by only two android apps can be considered as a library.
in other words determining a foolproof threshold regarding real world android applications may need further investigation and study.
the current implementation of libd can be easily configured with different thresholds.
besides we consider a rigorous training step regarding the ground truth should also be applicable in our research.
on the other hand since there is no systematic approach to acquiring the ground truth our current ground truth set constructed by manual efforts may not be sufficient for training iv c .
in sum we leave it as further work to extend the size of our ground truth set and launch a rigorous training procedure to decide the threshold.
semantics based similarity analysis.
libd detects instances of potential libraries iii c2 instances with identical features are clustered into one group i.e.
a third party library .
conceptually we are indeed searching for the hidden similarity among different code components e.g.
java packages .
note that features extracted by libd e.g.
opcode sequences are essentially from the program syntax.
syntactic features are straightforward representations of the target programs and they have been widely used by many existing work for program similarity comparison and code clone detection .
our experimental result has also demonstrated authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficient and precise detection of android third party libraries iv c using syntactic features.
on the other hand we have also observed some program semantics based similarity analysis work .
ideally similarity analysis work in this category retrieves features by modeling the functionality of the program and it can usually reveal the underlying similarities of code snippets in a more accurate way.
however existing semantics based similarity work may not be very scale .
given the high scalability as a requirement for android third party library related search we consider it may not be feasible to directly adopt previous techniques in our new context.
we leave it as future work to integrate more scalable semanticsbased methods in our research.
vi.
r ela ted work a. third party library identification early work on third party mobile library identification mostly focuses on advertising libraries.
book et al.
and grace et al.
use the whitelist based method for detecting advertising libraries.
after collecting the names of well known advertising libraries they examine the existence of such libraries in a mobile app by package name matching.
later techniques like addetect and pedal start to employ machine learning methods to provide more accurate and comprehensive results but they still target advertising libraries only.
adrob analyzes the network traffic generated by the advertising services in android apps to identify which libraries are bundled with both static and dynamic analysis.
identification techniques specialized for advertising libraries are not suitable for many security analysis on mobile apps.
recent research has proposed more general methods that do not rely on a priori knowledge about what types of libraries are to be identified.
wukong is an android app clone detection technique which needs to filter out third party libraries before the actual detection starts.
wukong adopts the assumption that a library consists of only one package.
for each package wukong assigns the set of invoked android api functions as its signature.
given a large set of apps wukong clusters all packages by this signature and reports clusters that are large enough to be recognized as a third party libraries.
libradar is an online service that implements the identification method of wukong with a better performing package clustering algorithm.
to distinguish app specific classes from third party library classes v asquez et al.
extracted the package name i.e.
main package from androidmanifest.xml for an app.
then they considered all the classes inside the main package and its sub packages as app specific classes classes outside the main package were considered as classes from third party libraries.
an empirical study conducted by li et al.
investigated the usage patterns of third party android libraries.
another study by chen et al.
tried to find potentially harmful libraries in ios as well as android apps.
both studies need to identify android third party libraries first but they adopt an approach different from the one employedby wukong.
instead of matching packages by signature the two studies cluster library candidates by computing a distance metric between each pair of them.
the distance is based on binary similarity and computed through binary diffing algorithms.
with the distances computed candidates close to each other are clustered and considered to belong to the same library.
since binary diffing is usually very costly both studies have to perform pre clustering based on package names to narrow the scope of pair wise library candidate comparison which could be impeded by obfuscation.
b. applications third party library identification has been used to implement many security applications targeting the android ecosystem one of which is android app clone and repackaging detection .
in this application thirdparty libraries are considered noises so they need to be detected and filtered out before app plagiarism is checked.
another important application of library identification is mobile vulnerability analysis.
paturi et al.
and stevens et al.
extracted advertising libraries from popular android apps and studied the privacy leakage problems residing in these libraries.
jin et al.
discovered that some third party libraries providing html5 support for mobile developers can be easily exploited by code injection attacks.
smvhunter analyzed the man in the middle ssl tsl vulnerabilities in android apps and third party libraries.
li et al.
found a vulnerability in a specific version of the google cloud messaging library that leads to private data leakage.
since these vulnerabilities are sometimes closely coupled with specific libraries identifying those libraries can be very helpful to searching for certain kinds of security threats.
libd can in general assist with these applications.
vii.
c onclusion in this paper we present a novel approach to identifying third party libraries in android apps.
our method overcomes some long existing limitations in previous work that affect library identification accuracy.
we have implemented our method in a tool called libd.
from a dataset of android apps recently collected from markets libd identified different third party libraries with a manually validated accuracy rate that clearly surpasses similar tools.
in particular our tool possesses certain degrees of obfuscation resilience.
our experimental results show that libd can find libraries whose package names are obfuscated.