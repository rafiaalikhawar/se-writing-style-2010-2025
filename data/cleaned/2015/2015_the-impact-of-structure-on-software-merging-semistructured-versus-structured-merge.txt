the impact of structure on software merging semistructured versus structured merge guilherme cavalcanti paulo borba georg seibt and sven apel federal university of pernambuco recife brazil university of passau passau germany saarland university saarbr ucken germany abstract merge conflicts often occur when developers concurrently change the same code artifacts.
while state of practice unstructured merge tools e.g.
git merge try to automatically resolve merge conflicts based on textual similarity semistructured and structured merge tools try to go further by exploiting the syntactic structure and semantics of the artifacts involved.
although there is evidence that semistructured merge has significant advantages over unstructured merge and that structured merge reports significantly fewer conflicts than unstructured merge it is unknown how semistructured merge compares with structured merge.
to help developers decide which kind of tool to use we compare semistructured and structured merge in an empirical study by reproducing more than merge scenarios from more than projects.
in particular we assess how often the two merge strategies report different results we identify conflicts incorrectly reported by one but not by the other false positives and conflicts correctly reported by one but missed by the other false negatives .
our results show that semistructured and structured merge differ in of the scenarios with conflicts.
semistructured merge reports more false positives whereas structured merge has more false negatives.
finally we found that adapting a semistructured merge tool to resolve a particular kind of conflict makes semistructured and structured merge even closer .
index t erms software merging collaborative development code integration version control systems i. i ntroduction to better detect and resolve code integration conflicts researchers have proposed tools that use different strategies to decrease effort and improve correctness of the integration.
for merging source code artifacts unstructured line based merge tools are the state of practice relying on purely textual analysis to detect and resolve conflicts.
structured merge tools go beyond simple textual analysis by exploring the underlying syntactic structure and static semantics when integrating programs.
semistructured merge tools attempt to hit a sweet spot between unstructured and structured merge by partially exploring the syntactic structure and static semantics of the artifacts involved.
for program elements whose structure is not exploited e.g.
method bodies semistructured merge tools simply apply unstructured merge textual analysis.
although there is evidence that semistructured merge has significant advantages over unstructured merge semistructured merge reports fewer conflicts fewer false positives and its false positives are easier to analyze and resolve and that structured merge tools report significantly less conflicts than unstructured merge average reduction of on the numberof reported conflicts it is unknown how semistructured merge compares with structured merge.
apel et al.
argue that structured tools are likely more precise than semistructured tools and they conjecture that a structured tool reports fewer conflicts than a semistructured tool.
however the reduction of reported conflicts alone is not enough to justify industrial adoption of a merge tool as the reduction could have been obtained at the expense of missing actual conflicts between developers changes.
in fact although one might expect only accuracy benefits from the extra structure exploited by structured merge we have no guarantees that this is the case.
previous works provide evidence that the extra structure exploited by semistructured merge is not only beneficial while it helps to eliminate certain kinds of spurious conflicts false positives reported by unstructured merge it might introduce others that can only be solved by algorithms that further combine semistructured and unstructured merge.
likewise the extra structure helps semistructured merge to detect conflicts that are missed false negatives by unstructured merge but it unfortunately comes with new kinds of false negatives.
so it is imperative to investigate whether the same applies when comparing semistructured and structured merge as this is essential for deciding which kind of tool to use in practice.
to compare and better understand the differences between semistructured and structured merge we apply both strategies to more than merge scenarios triples of base commit and its two variants parent commits associated with a non octopus1 merge commit from more than github open source java projects.
in particular we assess how often the two strategies report different results and we identify false positives conflicts incorrectly reported by one strategy but not by the other and false negatives conflicts correctly reported by one strategy but missed by the other .
to control for undesired variations arising from implementation details we have implemented a single tool that can be configured to use semistructured or structured merge.
this way we guarantee that structured merge behaves exactly as semistructured merge except for merging the body of method constructor and field declarations.
we found that overall the two strategies rarely differ for the scenarios in our sample.
considering only scenarios with conflicts however the tools differ in about of the cases.
a 1an octopus merge commit represents the merging of more than two variants.
34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
closer analysis reveals that they differ when integrating changes that affect the same textual area in the body of a declaration but the modifications involve different abstract syntax tree ast nodes in the structural representation.
correspondingly they also differ when changes in the same ast node correspond to different text areas in the semistructured merge representation of the same declaration body.
furthermore we found that semistructured merge reports false positives in more merge scenarios than structured merge whereas structured merge has more scenarios with false negatives than semistructured merge .
based on our findings regarding false positives and false negatives and the observed performance overhead associated with structured merge semistructured merge appears to be a better match for developers that are not overly concerned with false positives.
finally we observe that adapting a semistructured merge tool to report textual conflicts only when changes occur in the same lines resolving conflicts caused by changes to consecutive lines would make the two strategies report different results in fewer merge scenarios.
all the scripts and data used in this study are available in our online appendix .
ii.
s emistructured and structured merge the most widely used software merging tools are unstructured every software artifact is represented as text.
although fast unstructured merge tools are imprecise .
alternatively semistructured and structured merge tools incorporate information on the structure of the artifacts being merged.
they represent classes and class level declarations as ast nodes.
this way they avoid typical false positive conflicts of unstructured merge such as when developers add declarations of different and independent methods to the beginning of a class.
they differ only on how they represent the bodies of method constructor and field declarations.
in a structured tool such bodies are also represented as ast nodes in a semistructured tool they are represented as text and are merged in an unstructured way.
we illustrate how this difference affects merging in figure which shows different versions of a method body.2the base version at the top shows a method call that adds a new key value entry to a map.
the structurally merged version at the bottom highlights in red the changes made by developer a who simply refactored the code by extracting key .
it also highlights now in blue the changes made by developer b who added an extra argument to the constructor call.
as the two developers changed different ast nodes from the base version corresponding to different arguments of the method call structured merge successfully integrates their changes.
in contrast semistructured merge reports a conflict because the two developers changed the same line of code in the method body.
to compare semistructured and structured merge we could simply measure how often they are able to merge contributions 2based on method createdefaultparameterstooptimized merged in merge commit from our sample.
figure merging with semistructured and structured merge false positive .
as in the illustrated example.
the preference would be for the strategy that reports fewer conflicts.
given that merging code is the main goal of any merge tool in principle that criterion could be satisfactory.
however in practice merge tools go beyond that and detect other kinds of integration conflicts that do not preclude the generation of a valid program but would lead to build or execution failures.
for instance consider the situation illustrated on figure where developer a besides extracting the key variable also changed its value to j .
the merge tools would behave exactly as in the original example.
in this case however the changes interfere and the behavior expected by a new key with old value and b old key with new value will not be observed when running the integrated code.
in this case the preference would be for a semistructured tool the tool that reports a conflict when integrating these changes.
figure merging with semistructured and structured merge true positive .
whereas the original example in figure illustrates semistructured merge reporting a false positive incorrectly authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
reported conflict the modified example illustrates a structured merge false negative missed conflict .
this shows that our comparison criteria should go beyond comparing the number of reported conflicts.
we should also consider the number of false positives and false negatives that is the possibility of missing or early detecting conflicts that could appear during build or execution.
such comparison should be based on the differences between the merge strategies.
by construction semistructured and structured merge differ only when merging the bodies of method constructor and field declarations.
iii.
r esearch questions to quantify the differences between semistructured and structured merge and to help developers decide which strategy to use we analyze merge scenarios from the development history of a number of software projects while answering the following research questions.
rq1 how many conflicts arise when using semistructured and structured merge?
to answer this question we integrate the changes of each merge scenario with semistructured and structured merge.
for the results of each strategy we count the total number of conflicts that is the number of conflict markers3in the files integrated by each strategy.
based on this we count the number of conflicting merge scenarios that is scenarios with at least one conflict with semistructured or structured merge.
to control for undesired variations on individual tools implementation we have implemented a single configurable tool that via command line options applies a semistructured or structured merge strategy.
rq2 how often do semistructured and structured merge differ with respect to the occurrence of conflicts?
we answer this question by measuring the number of merge scenarios having conflicts reported by only one of the two strategies.
in principle the strategies could still differ when they both report conflicts for the same scenario as the reported conflicts might be different.
however by construction both strategies report the same conflicts occurring outside of method constructor and field declarations.
in dry runs we observed that this already corresponds to a large fraction of the conflicts.
we also observed that conflicts occurring inside such declarations are exactly the same or contain slightly different text in between conflict markers but are essentially the same conflict in the sense that they report the same issue.
similarly we observed equivalent conflicts that are reported with a single marker by semistructured merge but involve a number of markers in structured merge as illustrated later in this paper.
3as illustrated in figure .rq3 why do semistructured and structured merge differ?
we answer this question by inspecting merge scenarios and the code merged with each strategy for a sample of scenarios that have conflicts reported by only one of the strategies.
this way we can understand the difference on strategies behavior that leads to diverging results.
rq4 which of the two strategies reports fewer false positives?
a merge tool might report spurious conflicts in the sense that they do not represent a problem and could be automatically solved by a better tool.
these are false positives which lead to unnecessary integration effort and productivity loss as developers have to manually resolve them.
to capture true positives we rely on the notion of interference by horwitz et al.
who state that two contributions changes to a base program interfere when the specifications they are individually supposed to satisfy are not jointly satisfied by the program that integrates them.
this often happens when there is in the integrated program data or control flow between the contributions.
we then say that two contributions to a base program are conflicting when there is not a valid program that integrates them and is free of unplanned interference.
as interference is not computable in our context we rely on build and test information about the integrated code that we analyze and when necessary we resort to manual analysis.
again we focus on scenarios that have conflicts reported by only one of the strategies so when only one of the strategies produced a clean merge.
we attempt to build the clean merge and run its tests.
if the build is successful and all tests pass we manually analyze the clean merged code to make sure the changes do not interfere passing all tests is a good approximation but no guarantee that the changes do not interfere as a project s test suite might not be strong enough or even do not cover the integrated changes.
if we find no interference in the clean merge we count a scenario with false positive for the strategy that reported the conflict.
rq5 which of the two strategies has fewer false negatives?
a merge tool might also fail to detect a conflict false negative .
when this happens a user would be simply postponing conflict detection to other integration phases such as building and testing or even letting conflicts escape to operation.
so false negatives lead to build or behavioral errors negatively impacting software quality and the correctness of the merging process.
similarly to rq4 we rely on build and test information to identify false negatives.
we attempt to build the clean merge and run its tests.
if the build breaks or at least one test fails due to developers changes when the base version and the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
integrated variants do not present build or test issues but the merge result has issues so the changes cause the problem the strategy responsible for the clean merge has actually missed a conflict false negative .
thus we count a scenario with a false negative for the strategy that yielded the clean merge.
it is important to emphasize that rq4 and rq5 consider only the differences between the semistructured and structured merge strategies.
our interest here is to relatively compare both strategies not to establish how accurate they are in relation to a general notion of conflict we do not have the ground truth .
so we do not measure the occurrence of false positives and negatives when both strategies behave identically.
rq6 does ignoring conflicts caused by changes to consecutive lines make the two merge strategies more similar?
in the example of figure semistructured merge reports a conflict because developers aand bhave changed the same line in a method body.
however even if ahad simply added a single line even a comment like updating the map before the method call semistructured merge would report a conflict too.
this happens because the invoked unstructured merge algorithm reports a conflict whenever it cannot find a line that separates developers changes.
as in the example structured merge would successfully integrate the changes.
assuming that changes to the same line are often less critical than changes to consecutive lines it would be important to know whether a semistructured tool that resolves consecutive lines conflicts would present closer results to a structured tool.
so to answer this question we check whether a semistructured merge conflict is due to changes in consecutive lines of code that is there is no intersection between the sets of lines changed by each developer but one of them changes line nand the other changes linen .
then for each merge scenario we check the number of reported conflicts by semistructured merge and how many of these conflicts are in consecutive lines.
finally answering this research question consists of revisiting previous research questions contrasting results with and without consecutive lines conflicts.
iv .
s tudy setup answering our research questions involves two steps mining and execution.
in the mining step we implemented scripts to mine github repositories of java projects and collect information on merge scenarios each scenario consists of the three revisions involved in a three way merge.
in the execution step we merge the selected scenarios with both semistructured and structured merge.
for each merge without conflicts we use a build manager to build the merged version and execute its tests to find false positives and false negatives see section iii .
in the remaining of the section we describe the two steps in detail.
a. mining step our study relies both on the analysis of source code and build status information so we opt for github projects thatuse travis ci for continuous integration.
as the merge tool used in the execution step is language dependent we consider only java projects.
as parsing travis ci s build log depends on the underlying build automation infrastructure we consider only maven projects because we use its log report information for automatically filtering conflicts.
we start with the projects in the datasets of munaiah et al.
and beller et al.
which include numerous carefully selected open source projects that adopt continuous integration.
from these datasets we select java projects that satisfy two criteria first the presence of travis ci and maven configuration files which indicates that the project is configured to use the travis ci service and that the project uses the maven build manager 4second the presence of at least one build process in the travis ci service and confirmation of its active status which indicates the project has actually used the service.
after selecting the project sample we execute a script that locally clones each project and retrieves its non octopus merge commit list a merge commit represents a merge in the subject project s history and therefore can be used to derive a merge scenario.
as most projects adopted travis ci only later in project history for each project we consider only the merge commits dated after the project s first build on travis ci.
for each scenario derived from these merge commits we check the travis ci status of the scenario s three commits.
if any of them has an errored indicates a broken build or failed status indicates failure on tests we discard the scenario.
the reason is that we would not be able to confirm whether a problem in the merged version was caused by conflicting changes the problem could well have been inherited from the parents.
as a result of the mining step we obtained merge scenarios from selected java projects.
although we have not systematically targeted representativeness or even diversity our sample exhibits a considerable degree of diversity along various dimensions.
our sample contains projects from different domains such as apis platforms and network protocols varying in size and number of developers.
for example the t ruth project has approximately kloc while h ive has more than kkloc.
the w ebmagic project has collaborators while o khttp has .
we provide a complete list of the analyzed projects in our online appendix .
b. execution step after collecting the subject projects and merge scenarios we merge the selected scenarios with both semistructured and structured merge.
to control for undesired variations we have implemented a single configurable tool that via command line options applies semistructured or structured merge.
this way we guarantee that structured merge behaves exactly as semistructured merge except for merging the body of method constructor and field declarations.
the new implementation adapts and improves previous and independent implementations of a semistructured and a structured merge tool .
4we check whether the repository contains both travis ci and maven configuration files travis.yml andpom.xml .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in particular our tool is built on top of the semistructured tool.
while a standard semistructured merge tool invokes unstructured merge for bodies of declarations our configurable tool also allows structured merge to be invoked instead.
when configured to use semistructured merge the tool invokes the standard and widespread diff3 unstructured algorithm at declarations level.
when configured as structured merge the tool invokes the most mature and extensively evaluated structured implementation .
for each merge scenario our infrastructure generates two merged versions a semistructured version and a structured version.
for each file we count the number of reported conflicts.
for the semistructured merge versions we also count thenumber of conflicts that are due to changes in consecutivelines.
to do so we check whether the sets of changed linesin the variants are disjoint and whether the numbers of the contribution lines in the conflict text are consecutive.
based on the number of conflicts we select scenarios having conflicts reported by only one of the strategies.
the strategies could also differ by reporting different conflicts for the same scenario as discussed earlier in section iii.
in our sample however we verified that whenever semistructured and structured merge report conflicts in the same scenario these conflicts are in the same file.
even so they could still report different conflicts in the same file.
we have in fact observed such cases but they actually refer to equivalent conflicts reported by the strategies in different ways using different sets of markers andassociated conflicting code.
so we can consider them to be thesame conflict but with different textual representations derivedfrom the difference in the exploited syntax granularity.
this isillustrated in figure in a merge scenario from project neo 4jframework 6both developers added different declarations for the same constructor.
as this constructor is not declared in the base version both strategies report conflicts.
structured merge reports a conflict for any two syntactic level differences betweenthe versions resulting in several small conflicts.
semistructured merge reports a single conflict for the entire declaration.
having identified scenarios for which the strategies differ we collect information on false positives and false negatives.
we use travis ci as our infrastructure for building and executing tests for each scenario as explained in section iii and illustrated in figure .
as travis ci builds only the latest commit in apush command or pull request not all commits in a projecthave an associated build status on travis ci.
the generated semistructured and structured merged versions certainly do nothave a travis ci build as they are generated by our experiment.
so we use a script that forces build creation in such cases.
basically we create a project fork activate it on travis ci andclone it locally.
then every push to our remote fork creates a new build on travis ci.
so for each scenario for which the two strategies differ by definition one of the merged versions is clean and the other is conflicting we create a merge commit with the clean merged version and push it to our remote fork 5we use gnu s diff command passing the base version and each variant separately.
figure equivalent conflicts with different granularity.
to trigger a travis ci build.
note that we are only able to build and test code without conflicts as the conflicts markers invalidate program syntax.
if the build status on travis ci of the resulting merge commit iserrored when the build is broken or failed when the build is ok but at least one of the tests failed we consider thatthe corresponding merge scenario has a false negative fromthe strategy that did not report a conflict therefore a true positive reported by the other strategy.
however it is possible that a build breaks or a test fails due to external configuration problems such as trying to download a dependency that isno longer available or exceeding the time to execute tests.
we filter these cases as they do not reflect issues caused by conflicting code.
to do so we analyze for each generatedbuild its maven log report seeking for indicative messageerrors.
finally since we have also filtered merge scenarioshaving problematic parents see section iv a if the new merge commit still has build or test issues we can conclude that this is because developers changes interfere.
figure building and testing merge commits.
a green check mark indicates no conflict with one strategy a red cross indicates conflict with the other strategy.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in case the resulting merge commit build status on travis ci is passed we are sure that the merged version has no build error and all tests pass.
so this is a candidate false positive of the strategy that reported the conflict.
however whereas this provides precise guarantees for build issues the guarantees for test issues are as only good as the project s test suite.
even for projects with strong test suites unexpected interference between merged contributions might be missed by the existing tests.
so to complement test information we manually inspect all conflicting files from all merged versions with potential false positives.
in this manual analysis two of the authors analyzed the first conflicting files to consolidate the guidelines.
then two other authors individually analyzed the remaining files.
in the case of divergence between authors classification for the same file a third author reviewed that file.
in the case of uncertainty regarding the contributions a message was sent to the original committers to clarify the changes.
during this manual analysis we check the changes made by each developer analyzing whether they interfere following the definition of interference of section iii.
if one of the developers simply changes spacing and comments or extracts a variable or a method we conclude that there is no interference.
the corresponding merge scenario is then confirmed as having false positives.
the same applies when the developers change unrelated state or when they change assignments to unrelated local variables.
conversely if both developers change program semantics such as modifying related state or changing assignments to the same variable we conclude that there is interference.
we then confirm that the corresponding merge scenario has a false negative.
as discussed in section ii the same applies to the variation of the example illustrated in figure .
for each merge scenario we find interference in the merged version we add explanation and discuss a test case that fails in the base commit passes in one of the parent commits and fails in the merged version.
this is further evidence that the changes made by the considered parent commit were affected by the changes of the other parent commit.
v. r esults we use our study design to analyze merge scenarios from the development histories of java projects.
in what follows we present our results following the structure defined by our research questions.
more details including tables and plots are available in our online appendix .
a. how many conflicts arise when using semistructured and structured merge?
in our sample we found conflicts using semistructured merge and when using structured merge.
this is a reduction of .
in the number of reported conflicts when using semistructured merge.
this results at first might be surprising to those who expect that more structure leads to conflict reduction.
however as pointed out in section iv b and illustrated in figure structured merge might report more conflicts due to 7we provide a sheet with the detailed analysis of all files in our online appendix.its structure driven and fine grained approach.
this leads to conflicts that respect the boundaries of the language syntax which might result in many small conflicts that are reported as a single conflict by semistructured merge.
to control for the bias of conflict granularity we consider also the number of merge scenarios with conflicts .
of the scenarios using semistructured merge and .
using structured merge.
this time we observe a reduction of .
in the number of scenarios with conflicts when using structured merge.
in a per project analysis we found similar results .
.
average standard deviation of conflicting scenarios with semistructured merge and .
.
with structured merge.
summary semistructured and structured merge report similar numbers of conflicts but the number of merge scenarios with conflicts is reduced using structured merge by about .
in general conflicts are not frequent when using both strategies in about of the scenarios .
b. how often do semistructured and structured merge differ with respect to the occurrence of conflicts?
overall we found .
scenarios with conflicts reported only by semistructured merge and .
reported only by structured merge.
so the two strategies differ in .
of the scenarios in our sample a per project analysis gives a similar result on average the strategies differ on .
.
of the scenarios.
the reported percentages are comparatively small because most scenarios are free of conflicts even when using less sophisticated strategies such as unstructured merge.
in fact most scenarios involve only changes to disjoint sets of files so they cannot possibly discriminate between merge strategies because there is no chance of conflict.
so it is more reasonable to consider the relative percentages for conflicting merge scenarios which correspond to .
of our sample scenarios.
overall semistructured and structured merge differ in .
of the conflicting scenarios an average of .
.
in a per project analysis .
the observed error bounds are explained by some projects having low rates of merge scenarios with conflicts.
for instance projects such as clocker wire and la4jhad only one conflicting merge scenario and for this single scenario the strategies differ as a result of the reasons we explain on the next research question.
summary semistructured and structured merge substantially differ in terms of reported number of conflicts when applied only to conflicting scenarios of our sample they differ in about of these scenarios .
c. why do semistructured and structured merge differ?
to better understand the differences between the merge strategies we manually analyzed a random sample of merge scenarios that have conflicts reported by only one of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the strategies guided by power and sample size estimation statistics .
this includes scenarios with conflicts reported only by semistructured merge and scenarios with conflicts reported only by structured merge.
for each scenario we analyzed developers changes the code merged by one of the strategies and the conflict reported by the other strategy.
this way we can relate characteristics of the integrated changes with the strategy that reported the conflicts.
we begin with scenarios having semistructured merge conflicts and a structured clean merge.
consider the example in figure .
developer aadded modifier final to the ioexception catch clause right after the try block.
meanwhile developer badded a new catch clause to resourcenotfoundexception also right after the try block.
as no line separates these changes in two distinct areas of the text semistructured merge which invokes unstructured merge to integrate method bodies reports a conflict.
developers then have to manually act and decide which catch should appear right after the try block.
in contrast structured merge detects that the changes affect different child nodes of the try node and successfully integrates the changes by including the new child node b s contribution and the existing changed node a s contribution .
we observed the same kind of situation in every scenario that leads only to semistructured merge conflicts including the motivating example illustrated in section ii.
figure semistructured merge conflict from project glacieruploader from merge commit summary semistructured and structured merge differ when changes occur in overlapping text areas that correspond to different ast nodes.
next we consider scenarios with structured merge conflicts and a semistructured clean merge.
in the example of figure developer adeletes an argument from the call to method inside a for statement.developer bconverts the same for statement into a for each statement.
since these changes occur in non overlapping text areas semistructured merge successfully integrates the contributions.
structured merge reports a conflict because it is unable to match the new for each with the previous for statement they are represented by nodes of different types.
it correctly detects that the subtree of the body of the for statement was changed by one of the developers but it incorrectly assumes that the whole for statement was deleted by the other developer.
as a consequence structured merge does not proceed merging the child nodes from these iteration statements and reports a single conflict for the entire statements.
note that the changed method call is accidentally included in this deletion as it is not matched with the corresponding version in the for each statement.
figure structured merge conflict from project editorconfig netbeans from merge commit fjnex .
structured merge differs in a second kind of situation as illustrated in figure a .
in this example developer aadded a call to method viewmodel to an existing method call chain.
developer bchanged the argument of method provided in the same chain.
semistructured merge successfully integrates the changes because it detects that they occur in nonoverlapping text areas the line that calls method context act as a separator between the areas.
structured merge reports a conflict because by analyzing and matching the base ast with the developers asts see figure b it incorrectly concludes that the left child of the second methodcall node was changed by both developers.
indeed as marked in red in the figure the three nodes in this position are different.
developer bhas not actually changed the call to provided but changed the level of the call to context in the ast by adding a new method call to viewmodel .
as tree matching is top down and mostly driven by methodcall nodes in this case structured merge is not able to correctly match the calls and assumes that developer bchanged the call to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a code b ast figure structured merge conflict from project mvvm fx from merge commit provided by a call to context .
this is why the reported conflict involves these two method calls the second in the conflict text corresponds to a base node not changed by the developers context call .
the text does not refer to the ast node that actually caused the conflict viewmodel call .
summary semistructured and structured merge differ when changes occur in non overlapping text areas that correspond to a different but incorrectly matched nodes and to b the same node.
d. which of the two strategies reports fewer false positives?
as explained in section iv b we use travis ci to build and test the merged code of the scenarios for which the strategies differ.
we found scenarios with merged code that successfully builds and for which all tests pass their travis ci status is passed .
although this status provides precise guarantees that there are no build and test conflicts there could still be other kinds of semantic conflicts as unexpected interference between merged contributions might be missed by existing tests.
these scenarios are then potential false positives of the strategy that reported a conflict but we have to confirm this with a manual inspection of the merged code and the individual code contributions.
as explained in section iv b these scenarios were analyzed by two authors separately.
in scenarios there was disagreement between the authors so the review of another author was necessary.
besides in only scenario the contributions were not clear so we asked the actual contributors for clarification by commenting the original merge commit.
from the potential scenarios with false positives are related to semistructured merge they were successfully mergedby structured merge and have a passed status in travis ci.
conversely only scenarios are potential false positives of structured merge.
the manual analysis revealed that of the scenarios were actually false positives produced by semistructured merge.
only scenarios were actual true positives and as a consequence false negatives of structured merge.
for instance in a merge scenario from project sw agger ma ven plugin 8both developers added elements to the same list.
as a consequence each developer expected different resulting lists which are themselves different from the list that will be obtained by executing the merged code.
none of this project s tests exercises these contributions but it is not hard to come up with a test that passes in the developers versions but fails in the merged version revealing the conflict.
from the structured merge scenarios having potential false positives of them were classified as actual false positives.
only was an actual true positive produced by structured merge and a false negative of semistructured merge.
the actual true positive is a scenario from project resty gwt .
in this scenario one of the developers edited the condition and block of an existing ifstatement while the other added another ifstatement after the previous ifstatement.
both ifstatements return different values based on the value of the same method parameter.
however the first developer s edited condition now satisfies both developers conditions affecting the method result expected by the other developer and no test of the mentioned project captures this interference.
a test that captures this interference could be one added by the second 9suppose a test that checks whether the size of the list is n if it passes in the developers individuals versions it will fail in the merged version in which the size of the list will be n .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
developer that checks the value of the mentioned parameter and then enters into his added ifblock.
e. which of the two strategies has fewer false negatives?
we found scenarios with merged code that either cannot be successfully built travis ci errored status or can be properly built but at least one of the tests do not pass travis cifailed status .
by performing a travis ci log report analysis we found that most scenarios errored and failed status are due to a number of reasons travis ci timeout unavailable dependencies etc.
unrelated to the contributions being merged and that suggest these are older scenarios that would be hard to compile and build anyway.
so we cannot automatically classify these as false negatives.
we then focus on scenarios with errored and failed status we confirm the status by parsing travis ci log messages and checking that they are compiler or test related.
since our sample does not include scenarios having broken or failing parents see section iv a if the resulting merged code presents build or test issues we conclude this is due to interference between the merged code contributions.
from the analyzed scenarios we found only scenarios that are false negatives produced by semistructured merge with errored and with failed status.12in contrast we found scenarios that are false negatives produced by structured merge with errored status and with failed status for the merge.
although the two merge strategies are somewhat different we identified some common causes for false negatives due to broken builds.
for example we found situations in clean merges from both strategies e.g.
in projects blueprints and s ingu larity where one developer added a reference to a variable while the other developer deleted or renamed this variable.
consequently the compiler could not build the file.
we also observed situations e.g.
in projects neo 4j reco and vraptor where one developer changed the value passed as an argument while the other developer changed the corresponding parameter s type.
after the merge there is a compilation error reported due to the mismatch between expected and passed argument.
regarding test failures causing false negatives the only failed scenario from semistructured merge was in project closure compiler where the developers changes are responsible to update the same list.
conversely on failed scenarios from structured merge we observed for example developers inadvertently changing the same connection creation in project jedis or assigning different objects to the same variable in project ds pace .
table i summarizes our findings for false positives and false negatives after all analyses.
summary semistrutured merge reports more false positives times more scenarios with false positives and 11the test passes on second developer s version and fails on the merged version because now it would enter on first developer s ifblock returning a different value.
12structured merge having reported conflicts for these cases 13semistructured merge having reported conflicts for these cases.table i numbers for merge scenarios with false positives and false negatives.
semistructed merge structured merge false positives false negatives structured merge misses more conflicts has more false negatives times more scenarios with missed conflicts .
f .
does ignoring conflicts caused by changes to consecutive lines make the two strategies more similar?
our results show that our metrics on number of reported conflicts and on when the two strategies differ slightly drop if a semistructured merge tool could resolve conflicts due to changes in consecutive lines.14in particular the number of scenarios with semistructured merge conflicts is reduced by .
and the number of scenarios in which semistructured and structured merge differ is reduced by .
.
in projects such as quickml sejda and sonarqube w e found that this happens because changes to consecutive lines often correspond to changes to different ast nodes.
in such situations structured merge does not report conflicts.
thus when semistructured merge is able to resolve consecutive lines conflicts it might avoid conflicts due to changes to different ast nodes similar to structured merge.
summary a semistructured merge tool that can resolve consecutive lines conflicts would present even closer number of scenarios with conflicts to structured merge and fewer scenarios in which the two strategies differ.
g. threats to v alidity we rely on manual analysis to identify interference between merged contributions so there is a risk of misjudgment.
to mitigate this threat every scenario was analyzed separately by two authors and in case of disagreement another author acted as a mediator.
we also asked the actual contributors for clarification of the changes when they were not clear.
as mentioned in section v d this was only necessary in one occasion.
we opted for a single merge tool that can be configured to apply semistructured and structured merge.
this was necessary to ensure that we have a structured merge tool working as expected.
this single tool is basically an extension of the semistructured merge tool able to invoke a structured merge tool on declarations.
to the best of our knowledge these tools are the most mature and evaluated tools available.
in addition as we discard merge scenarios that we could not properly build on travis ci or that have broken or failed 14we only count consecutive lines conflicts we actually do not resolve them.
thus we dot not have numbers for false positives and false negatives.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
parents we might have missed differences in the strategies behavior.
we might have also missed them because we analyze only code integration scenarios that reach public repositories with merge commits this is not the case for example for integrations with git rebase or that were affected by git commands that rewrite history.
finally we focus on open source java projects hosted on github using travis ci and maven.
thus generalization to other platforms and programming languages is limited.
such requirements were necessary because the merge tools are language specific and to reduce the influence of confounds increasing internal validity.
vi.
d iscussion our results show that overall the two merge strategies rarely differ for the scenarios in our sample as most of them are free of conflicts.
many merge scenarios affect disjoint sets of files having no chance of leading to conflicts no matter which merge strategy is adopted by the tool one uses.
however for scenarios that reflect more complicated merge situations we do observe that the choice of the merge strategy makes a difference considering scenarios with conflicts the two strategies differ in about of the cases.
this is maybe surprisingly low given that most code and changes occur inside method constructor etc.
declarations exploited by the significant extra structure considered by structured merge.
in terms of conflicting scenarios with diverging behavior structure plays a similar role when moving from unstructured merge to semistructured merge and when moving from semistructured to structured merge .
in cases where two strategies differ semistructured merge reports false positives in more merge scenarios than structured merge whereas structured merge has more scenarios with false negatives than semistructured merge.
the extent of the difference in the false positive and false negative rates are quite similar.
semistructured merge s false positives are not hard to resolve the fix essentially involves removing conflict markers.
analyzing the changes before removing the markers might be expensive but certainly not as in unstructured merge with its crosscutting conflicts or as in structured merge with its fine graned conflicts as illustrated in figure .
in contrast structured merge s false negatives might be hard to detect and resolve.
most of the observed false negatives actually correspond to compilation and static analysis issues that escape the merging process but cannot escape the building phase.
these are always detected and are often easy to resolve.
however part of the observed false negatives are related to dynamic semantics issues that can easily go unnoticed by testing and end up affecting users.
these are hard to detect and when detected are often hard to resolve.
a more rigorous analysis based on conflict detection and resolution timing data could differently weight false positives and false negatives in the spirit of berry and better assess the benefits of the two strategies.
based on our findings regarding false positives and false negatives and given the observed modest difference between the two merge strategies we conclude that semistructuredmerge would be a better match for developers that are not overly concerned with false positives.
this is reinforced by considering the observed performance overhead associated with structured merge and the extra effort needed to develop structured merge tools .
together with our findings about consecutive lines conflicts this discussion suggests the development of a tool that adapts semistructured merge to report textual conflicts only when changes occur in the same lines resolving conflicts caused by changes to consecutive lines .
such a tool could hit a sweet spot in the tension between structure and accuracy in merge tools.
our observations especially the ones that explain when the two strategies differ shall help researchers and merge tool developers to further explore improvements to merge accuracy and the underlying tree matching algorithms.
in the same vein our manual analysis of false positives reveal opportunities for making merge tools avoid a number of false positives.
for example by detecting straightforward semantic preserving changes we could avoid of false positives reported by semistructured merge in our sample.
combining the two merge strategies as suggested by apel et al.
seems also promising.
one idea is to invoke structured merge and when it does not detect conflicts invoke semistructured merge and return its result which would reduce the chances of false negatives.
this is a conservative approach which considers the costs associated with false positives to be inferior to those associated with false negatives.
such a tool would eliminate structured merge s false negatives but would still have semistructured merge s false negatives.
conversely in the best case when structured merge does detect conflicts it would present structured merge s false positives and in the worst case the tool would present semistructured merge s false positives.
a less conservative combination in which semistructured is used as long as it does not detect conflicts is also worthwhile to explore.
vii.
r ela ted work several researches propose development tools and strategies to better support collaborative development environments.
these tools try to both decrease integration effort and improve correctness during code integration.
for instance to overcome weaknesses associated with traditional unstructured merge structured and semantic merge strategies have also been proposed .
for example apel et al.
developed jdime the structured tool used in this study also capable of tuning the merging process on line by switching between unstructured and structured merge depending on the presence of conflicts.
they also proposed semistructured merge which takes advantage of the underlying language s syntactic structure and static semantics but without the performance overhead associated with full structured merge .
studies provide evidence that semistructured merge might reduce the number of reported conflicts in relation to traditional unstructured merge but not for all projects and merge scenarios.
cavalcanti et al.
go further and provide evidence that the number of false positives authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is significantly reduced when using semistructured merge.
however they do not find evidence that semistructured merge leads to fewer false negatives.
lessenich et al.
attempt to improve jdime by employing a syntax specific lookahead to detect renamings and shifted code.
they demonstrate that their solution can significantly improve matching precision in while maintaining performance.
zhu et al.
built automerge on top ofjdime that matches nodes based on an adjustable so called quality function .
their goal is to find a set of matching nodes that maximizes the quality function preventing the matching of logically unrelated nodes and as consequence false positives conflicts.
they found that automerge was able to reduce the number of reported conflicts compared to original jdime being slightly slower.
we complement these prior studies by comparing semistructured and structured merge not only in terms of reported conflicts but also in terms of false positives and false negatives.
we conclude that semistructured merge would be a better match for developers that are not overly concerned with false positives especially when a semistructured merge tool resolves conflicts caused by changes to consecutive lines.
we also suggest that a combination of these two strategies seems promising as it is able to reduce weaknesses of both strategies.
souza et al.
propose safemerge a semantic tool that checks whether a merged program does not introduce new unwanted behavior.
they achieve that by combining lightweight dependence analysis for shared program fragments and precise relational reasoning for the modifications.
they found that the proposed approach can identify behavioral issues in problematic merges that are generated by unstructured tools.
this tool needs as input a merged program besides the three versions present in a merge scenario so it could be used in combination with a semistructured or structured merge tool or even our suggested tool that further combines these two strategies to reduce their behavioral false negatives.
however safemerge only analyzes the class file associated with the modified method declarations so it may suffer from both false positives and false negatives too.
in particular their analysis results are only sound under the assumption that the external callees from other classes have not been modified.
other empirical studies provide evidence about the occurrences and effects of conflicts and their associated causes .
for example brun et al.
and kasi et al.
reproduce merge scenarios from different github projects with the purpose of measuring the frequency of merge scenarios that resulted in conflicts.
zimmermann conducted a similar analysis reproducing integrations from cvs projects instead.
they all conclude that conflicts are frequent.
adams and mcintosh and henderson even report that companies have migrated to single branched repositories to avoid merge problems.
our work complements these studies providing evidence of conflict frequency depending on the use of different merge strategies.
finally menezes et al.
analyze merge scenarios from open source java projects to investigate the nature of merge conflicts.
in terms of what conflicts look like what kinds of conflicts occur how developers fix them and more.
based on their results they argue that it is difficult toenvision a single generic merge strategy that can automatically resolve all possible conflicts because the diversity in conflicts is simply too large.
still they believe it is possible to improve over the existing tools to better resolve conflicts for instance in the form of plug ins that can automatically handle specific kinds of conflicts.
accioly et al.
derive a catalog of conflict patterns expressed in terms of the structure of code changes that lead to merge conflicts.
their results show that most conflicts occur because developers independently edit the same or consecutive lines of the same method.
however the probability of creating a merge conflict is approximately the same when editing methods class fields and modifier lists.
similarly investigate how conflicts on method declarations are resolved on open source java projects.
they found that most part of them is resolved by adopting one of the versions then discarding the other.
these findings about conflicts characteristics might be adapted by a merge tool as strategies for resolving conflicts.
viii.
c onclusions when integrating code contributions from software development tasks one often has to deal with conflicting changes.
while state of practice tools still rely on an unstructured linedbased strategy to merging recent developments demonstrate the merits and prospects of advanced merge strategies in particular semistructured and structured merge.
previous studies provide evidence that semistructured merge has significant advantages over unstructured merge and that structured merge reports significantly fewer conflicts than unstructured merge.
however it was unknown how semistructured merge compares with structured merge.
in this paper we compared semistructured and structured merge by reproducing merge scenarios from github java projects.
our results show that users should not expect much difference when using a semistructured or a structured merge tool they differ substantially only when applied to conflicting scenarios in about of them which corresponds to only about of our subject scenarios.
when semistructured merge is able to resolve conflicts due to changes in consecutive lines of code the two strategies differ in about of the conflicting scenarios instead and the number of scenarios in which they differ is reduced by about .
when deciding which kind of tool to use a user should consider that semistructured merge reports more false positives times more scenarios with false positives but structured merge misses more conflicts false negatives times mores scenarios with missed conflicts .
combining the two strategies seems promising as it is able to mitigate the weaknesses of both strategies.
as future work we shall implement and evaluate such a combination of strategies to verify its actual benefits and drawbacks.