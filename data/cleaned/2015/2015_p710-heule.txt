mimic computing models for opaque code stefan heule stanford university stanford ca usa sheule cs.stanford.edumanu sridharan samsung research america mountain view ca usa m.sridharan samsung.comsatish chandra samsung research america mountain view ca usa schandra acm.org abstract opaque code which is executable but whose source is unavailable or hard to process can be problematic in a number of scenarios such as program analysis.
manual construction of models is often used to handle opaque code but this process is tedious and error prone.
in this paper we use model to mean a representation of a piece of code suitable for program analysis.
we present a novel technique for automatic generation of models for opaque code based on program synthesis.
the technique intercepts memory accesses from the opaque code to client objects and uses this information to construct partial execution traces.
then it performs a heuristic search inspired by markov chain monte carlo techniques to discover an executable code model whose behavior matches the opaque code.
native execution parallelization and a carefully designed tness function are leveraged to increase the e ectiveness of the search.
we have implemented our technique in a tool mimic for discovering models of opaque javascript functions and used mimic to synthesize correct models for a variety of array manipulating routines.
categories and subject descriptors i. .
program synthesis keywords opaque code program synthesis mcmc model generation javascript .
introduction we consider the problem of computing models from opaque code.
by opaque we mean code that is executable but whose source is unavailable or otherwise di cult to process.
consider the case of a javascript runtime which provides native implementation of a large number of utility functions such as array functions.
natively implemented methods are opaque to an analysis tool built to analyze javascript sources and are a hindrance to e ective analysis because the tool permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse bergamo italy copyright acm x xxxxx xx x xx xx ... .
.must make either unsound or overly conservative assumptions on what those native methods might do.
this same situation arises for many languages and runtimes.
opacity also is a concern when a third party library is distributed in deliberately obfuscated form that hinders static analysis.
in javascript for example an obfuscator might replace access to elds by computed names e.g.
transforming y x.foo top y x p .
such changes can foil a static analyzer s ability to reason precise about data ow through the heap.
models provide an alternate easy to analyze representation of the opaque code.
sometimes models can be written by hand however this is tedious and error prone and requires understanding of how the opaque code works.
a need for better automated ways of creating models has been argued in the literature .
in this paper we show a new automatic way of creating models for opaque functions based on a novel search based program synthesis strategy.
we observe that the behavior of an opaque function can often be indirectly observed by intercepting accesses to memory shared between the client and the opaque code.
here shared is in the sense of an object that is passed as a parameter to a called function and has nothing to do with concurrency.
in most common dynamic languages e.g.
javascript lua python ruby interception of accesses to shared objects can be achieved using indirection via proxy objects discussed in more detail in section .
in this paper we show that surprisingly it is in fact possible to generate useful models of opaque functions based solely on observation of these shared memory accesses .
given a set of inputs for an opaque function our technique collects traces of shared memory accesses to those inputs by running the function against those inputs and recording the intercepted accesses.
it then carries out a random search inspired by markov chain monte carlo mcmc sampling to synthesize from scratch a function whose execution results in the same sequence of reads and writes.
our strategy is a generate and test strategy leveraging e cient native execution simply running it to test the quality of candidate models.
comparison of quality of models is done using a carefully designed tness function that takes into account the degree to which a model matches the available traces.
native execution lets the technique run tens of thousands of trials per minute and it yields models that are in fact concrete code.
thus our models are agnostic to whatever abstraction a program analysis wishes to employ.
figure shows the model that our approach recovers for the javascript array.prototype.shift method.
notice that the model permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
710includes complex controlow constructs in addition to the elementary statements.
related approaches the problem of generating an implementation from a trace of actions is not new but to the best of our knowledge our technique is new.
closely related work in this area has used the concept of a version space algebra to search through a space of candidate programs.
in version space algebra a domain speci c data structure encodes all programs that are consistent with the traces seen so far.
when a new trace is presented the data structure is adjusted to eliminate those programs that would be inconsistent with this new trace.
the nal space can be ranked using domain speci c insights.
the success of the version space technique depends on careful design both of the space of domain speci c programs and of the data structure that represents them in such a way that the knowledge embedded in a new trace can be factored in e ciently .
while the version space algebra approach has been very successful in speci c domains such as spreadsheet manipulation its success has not been shown on general purpose programs.
the work by lau et al.
handles only the situation in which the complete trace with the state of all variables is given at each step along with the knowledge of the program counter this simpli es the search space considerably.
given our execution traces which contain only shared memory accesses and no program counter information there is not clear way to represent all consistent programs in a compact data structure that can be e ciently updated for new traces.
other recent work uses an oracle guided approach to model generation based on constraint generation and smt solvers .
the generated constraints allow for a model to be constructed from pre de ned building blocks or components and they ensure the model is consistent with inputoutput examples obtained from running the opaque code.
here the limitation is that the set of building blocks must be chosen very carefully to make the constraint problem tractable it is unclear if such an approach could scale to generate models as complex as that of figure without excessive hand tuning.
the alternative then is to adopt a generate and test strategy and the important question is how to organize the generation of candidates so as to not have to evaluate enormous spaces even if bounded of programs exhaustively.
in this regard recent work has shown the promise of genetic algorithms to synthesize patches to x buggy programs.
in that work the operations of mutation and crossover are applied to an existing defective program that has both passing and failing test inputs.
mutation is applied by grafting existing code exercised in failing inputs and this contains the search space to manageable size.
since our problem is to synthesize code from just the execution traces we cannot readily adopt this method there is no place to graft from.
nevertheless this work has strongly inspired our own work in its use of statistical techniques to explore an enormous search space of code fragments.
for our setting an approach inspired by mcmc sampling seems to be an e ective search strategy and this is borne out by our results.
overview of results we have implemented our approach in a tool called mimic for javascript.
it collects traces by wrapping function parameters with javascript proxy objects see section .
we have found mimic to be surpris 1function shift arg0 var n0 arg0 .
length if n0 var n1 arg0 for var i i n0 i var n2 i in arg0 if n2 var n3 arg0 arg0 n3 else delete arg0 delete arg0 arg0 .
length i return n1 else arg0 .
length figure model of array.prototype.shift generated by our tool.
ingly e ective in computing models of several of the arraymanipulating routines in javascript runtime.
in fact the models generated by mimic have occasionally been of higher quality than the hand written models available with wala a production quality program analysis system .
when it succeeded mimic required on average roughly seconds per method evaluating hundreds of thousands of candidates in the process.
the technique is easily parallelized and in our evaluation we leveraged a core machine for improved performance.
mimic was just as capable in extracting models from obfuscated versions of the same library methods written in javascript.
our implementation is available at .
as with any search based technique there are limitations see section .
for a detailed discussion .
our approach is currently limited to discovering models of functions that primarily perform data ow with relatively simple logical computation.
we cannot generate a model for a complex mathematical function e.g.
sine since our trace of shared memory accesses does not expose the complex calculations within the function.
nevertheless we believe our approach can still be usefully applied in a variety of scenarios.
contributions this paper makes the following contributions we introduce the problem of computing models for opaque code and present a novel search based synthesis algorithm to address this problem.
to our knowledge no other technique can nd models for opaque code with the minimal information that our algorithm requires.
we describe a prototype synthesizer mimic for javascript functions based on use of proxy objects and show that it can successfully synthesize accurate models for a variety of array manipulating routines.
.
overview in this section we give an overview of our synthesis technique mimic using an example function from the javascript standard library.
consider javascript s built in array.prototype.shift function.
for a non empty array shift removes its rst element e 711ini al inputs input gen all inputs loop detect loop structure categorizer input cat1 input cat2 search model1 model2 merge unknown condi ons model final model ... input catn modeln search search search cleanup figure overview of mimic phases.
the green phases with solid outlines are deterministic while the red phases with dashed outlines incorporate randomness.
we call the procedure corresponding to the whole gure mimiccore.
at index shifts the remaining values down by one index so the value at index is shifted to to etc.
and nally returns e e.g.
var arr var x arr.
shift x is a and arr is now for an empty array shift returns the value undefined .mimic is able to generate a model for shift shown in figure that captures the above behaviors based solely on collected execution traces with no access to a source representation.
note that the method also works for so called sparse arrays which may have certain elements missing.
in the remainder of this section we outline the steps taken bymimic to generate this model.
these steps are illustrated in figure .
generating inputs and traces.
our approach begins by generating a set of execution traces for the function in question based on some initial inputs provided by the user.
an execution trace includes information about the memory operations performed by the function on any objects reachable from its parameters and also what value was returned.
mimic uses proxy objects to collect such traces for javascript functions details in section .
for the shift function given the input we obtain the following trace read field length of arg0 read field of arg0 a read field of arg0 b write b to field of arg0 read field of arg0 c write c to field of arg0 read field of arg0 d write d to field of arg0 delete field of arg0 write to field length of arg0 return a the trace contains reads from and writes to the array parameter arg0 with writes showing what value was written but not how the value was computed.
given traces based on the initial inputs mimic generates other potentially interesting inputs whose traces may clarify the behavior of the function.
in the above trace we see entry read field of arg0 which reads b from the input array and then write b to field of arg0 which writes b .
based solely on these trace entries one cannot tell if b is being copied from the input array or whether the write obtains b from some other computation.
hence mimic generates an input with a di erent value in arg0 to attempt to distinguish these two cases.
input generation is based on heuristics and is discussed more fully in section .
.loops.
given a completed set of traces our technique next tries to discover possible looping structures in the code.
we rst abstract each trace to a trace skeleton which contains the operations performed by a trace but elides speci c values and eld o sets.
a trace skeleton exposes the structure of the computation in a manner less dependent on the particular input values of a trace.
for the above trace the skeleton of the rst four entries is read read read write .
given a set of trace skeletons mimic then proposes loop structures by searching for repeated patterns in the skeletons rating loop structures by how well they match see section .
for details .
each loop structure is assigned a probability proportional to its rating and then mimic randomly selects a structure to use based on these probabilities.
the full space of loop structures supported by mimic is covered by runs of the tool with di erent random seeds.
for shift the highest rated loop structure is also the correct one and is as follows shown over the skeleton in a regular language like syntax read read has read write delete delete write the trace event hasis a check if a given index is part of the array which may return false for sparse arrays .
categorization.
after a loop structure is chosen mimic groups the traces into distinct categories based on their skeletons.
for shift two categories are created one for traces matching the loop structure above and one for the trace corresponding to the empty array which does not match the structure .
mimic synthesizes models for each category separately as described next and then merges them to discover the nal model which works for all inputs.
search.
to begin a random search for a model we rst generate a program to closely match one of the given input traces.
for the trace above and the given loop structure we generate the following initial program var n0 arg0 .
length var n1 arg0 for var i i i var n2 in arg0 if true var n3 arg0 arg0 b else delete arg0 delete arg0 arg0 .
length return a 712s v e je ejv e e .
.
.
e j if e s else s jv e j for s e s s js s e .
.
.j 1j0j1j.
.
.jtruejfalse j e eje eje eje ej!e j v .
.
.
v e figure syntax of a small object oriented language.
this program is clearly too speci c to the given trace it uses speci c values from its input array and its loop and if conditions are incorrect.
a random mutation is then applied to this program.
for instance the second line might be replaced with the statement var n1 arg0 .
the mutations allow the program gradually be transformed towards a solution.
to this end the mutated program is compared with the current program in terms of how closely is matches the available traces.
if it ranks better as per a tness function the mutated program becomes the current candidate.
if not like in this case where the mutation is worse it still becomes the current candidate with a certain probability.
this is a random search inspired by mcmc see section .
.
our random search is able to gradually evolve this program into the code in lines of figure which works for all nonempty arrays.
key to the e cacy of the search is a tness function for programs that rewards incremental progress toward a correct solution.
for the category corresponding to empty arrays the search discovers the following program var n0 arg0 .
length arg0 .
length program implicitly returns undefined merging.
after generating models for all categories mimic merges the models using conditional statements to create a single model.
at rst the branching conditions are unknown so some trivial condition such as true is used.
another phase of random search discovers the correct conditions to make the model work for all input traces.
finally a last cleanup search makes the program more readable by removing unnecessary statements and simplifying the program.
for shift this nal search yields the model in figure .
.
approach in this section we detail the di erent phases of our approach to synthesizing models of opaque code shown in figure .
as input we require a function and one or more inputs to that function.
furthermore we assume that we have a means of executing the function on an input of our choice and recording a trace of this execution.
we talk more about how these assumptions are ful lled for javascript in the setting ofmimic in section .
we explain our approach for a simple dynamic objectoriented language with object allocation eld reads and writes functions callable objects integers arithmetic operations conditionals and loops.
for simplicity all eld 1in our implementation the initial program is actually slightly more general and contains an auxiliary result variable as well as other ways to break out of the loop see section .names are integers and objects can be viewed as arrays where theith array element is stored in eld i .
the syntax for statements and expressions is given in figure .
a program trace captures the execution of a function on a particular input and is a sequence of trace events and can be eld reads writes and function invocations.
finally the trace contains a return value.
for all the values in the trace such as the eld being read or the receiver the trace directly holds that value if it is a primitive i.e.
an integer .
if the value is an object then the trace holds a unique identi er for that object.
for our simple language this trace format is su cient to capture all object accesses performed by opaque code to objects passed as parameters.
note that the trace does not contain information about where values originate.
.
main loop algorithm main loop for model synthesis require opaque function f initial inputs i timeoutt procedure findmodel f i t m null whilem nulldo initrandomseed m mimiccore f i run with timeout t returnm algorithm gives pseudocode for the main loop of our technique.
in each iteration a global pseudo random number generator is initialized with a fresh random seed and then the synthesis procedure mimiccore shown in figure is invoked with some timeout t nullis returned if tis exceeded .
recall from figure that the loop detection and search phases make use of randomness.
hence by periodically restarting the search with a fresh random seed we ensure that di erent loop structures are explored and the core search explores di erent parts of the state space breaking out of local minima.
note that the loop parallelizes trivially by simply running multiple iterations concurrently and stopping when any iteration succeeds.
in our implementation we used an exponential backo strategy to vary the timeout see section .
.
input generation in order to generate an accurate opaque function model in our approach we require a set of inputs that covers all of the possible behaviors the function can exhibit.
while generating such an input set is impossible in general we have developed heuristics that have worked well for the opaque functions we have tested thus far.
given one or more representative inputs provided by the user we automatically generate additional inputs with three main goals .determine the ow of values through a method.
as illustrated with the example trace in section with only a trace it is impossible to know if a method copies a value from another location or computes it from scratch.
.find dependencies on values of the inputs.
for instance the method array.prototype.indexof in javascript returns the index of a value in an array or 1if it doesn t exist in the array .
by changing the values in the array and what value is searched for we can learn this dependency on the input values.
.expose corner cases.
for many functions it is possible to increase the coverage by trying corner cases such 713as the empty array.
for instance this reveals that array.prototype.pop returns undefined for the empty array.
algorithm input generation require initial inputs init procedure inputgen init r init i init i0 whilei6 do fori2ido t gettrace i l extractreadlocs t i0 i0 gennewvals i l i i0 r r r i i0 returnr algorithm gives pseudocode for input generation.
in each iteration of the while loop new inputs i0are generated from a set of inputs ias follows.
for every input iini the opaque function is rst executed on ito record a trace t. fromt we extract all memory locations lthat were read where a memory location consists of a base object and eld o set.
we generate new inputs by calling gennewvals which heuristically replaces the values of input locations in lwith new values.
to decide what di erent values to generate for a location we use heuristics based on the type of the original value.
for integers we randomly choose values and include a few xed values that are likely corner cases such as or .
for objects we sometimes replace the object with a clone to distinguish cases involving aliased parameters.
furthermore we can remove some elds add additional elds or provide an empty object.
at the outermost level we repeat the steps above until no new inputs can be generated.
in our prototype we terminated input generation after two iterations of the while loop as we found that this generated a su cient set of inputs.
.
loop detection after input generation our technique next discovers possible controlow structure for the function i.e.
loops and conditionals the loop detection and categorizer phases in figure .
by xing the control ow structure for the model rst the core random search can concentrate on nding the correct expressions to complete the program.
here we describe loop detection in more detail categorizing and merging were described in section .
given a set of execution traces like ours discovering arbitrary looping constructs with nesting complex conditionals within loops etc.
is a highly non trivial problem.
the problem can be viewed as learning a regular language form only positive examples where the examples are the program traces and the regular language represents the control ow.
gold showed that the class of regular languages is not learnable from only positive examples.
however we have had success in discovering basic looping structures with a simple probabilistic technique based on detecting repeated patterns that appear in multiple execution traces for a function as described below.
we restrict the methods to have a single loop with potentially one conditional statement in the body.
to discover loop like patterns of this form in traces we rst abstractalgorithm loop detection require set of traces t procedure loopdetect t s getskeletons t c fors2sdo c c loopcandidates s forc2cdo score rank c s l sort c score returnl with probability loop i the traces to trace skeletons which only consist of the event kinds in the trace.
such abstraction is useful since there is often some variation in the events generated by a statement in a loop e.g.
the index being accessed by an array read .
given such a trace skeleton we enumerate candidate control ow structures in the skeleton by simply enumerating all possible loop start points as well as branch lengths inside the loop.2consider the following trace skeleton read read write call read write call read read write call read write call for this example the following control ow candidates are generated among others in a regular expression like syntax read write call read write call read read write call note that the candidates must match the full trace otherwise the candidate could not be the control ow that generated the given trace.
to avoid guessing unlikely loops one can restrict the search to loops that have at least some number of iterations say .
we repeat the procedure above across skeletons of all traces to create a complete set of loop candidates.
depending on the length and the number of traces this set can be quite large.
our next step is to rank the loop candidates based on their likelihood.
first we can check how many traces can be explained by a given loop structure by matching it against all trace skeletons.
intuitively the more traces that can be explained by a possible loop the more likely that loop is correct.
secondly if several loops match the same number of traces then we further rank them by the number of statements in the control ow candidate with fewer statements ranking higher.
once the loops are sorted according to their rank we choose one loop at random with which to continue the search where theith loop is picked with probability loop i for some parameters loop2 .
loopcontrols the probability that no loop candidate is chosen.
in our setting we found and loop to work well.
.
random search we now describe the random search procedure at the heart of our technique the search boxes in figure .
we view the problem of nding a suitable code model for a set of inputs as an optimization problem for a tness function that 2this algorithm runs in polynomial time but could get slow for very long traces in which case optimizations might be necessary.
in the cases we have looked at this has not been a problem.
714algorithm random search for a model require set of inputs i loop structure l procedure search i l to fi7!gettrace i gfori2i m initialmodel to l for somei2i c fitness m t o whilec 0do m0 mutate m c0 fitness m0 to ifc0 cthen m m0 else m m0with probability min exp c0 c returnm procedure fitness m t o s for i t 2todo t0 getmodeltrace m i s s compare t t0 returns evaluates a model by comparing its execution traces to those of the underlying opaque function.
finding a model then corresponds to nding a minimum for the tness function in the highly irregular and high dimensional space of all models.
to nd a model we employ a technique inspired by markov chain monte carlo mcmc sampling and the metropolis hastings algorithm which has been recently used successfully in the domain of superoptimization .
the advantage of this technique is that the sampling frequency is proportional to the value of the density function at that point so the search is carried out more productively.
algorithm gives pseudocode for our random search.
we maintain a current candidate model m and each iteration creates a mutated model m0.m0is then evaluated using the tness function and replaces the current model if it has a lower cost.
otherwise the new model might still be accepted with a probability that is proportional to the di erence between the two costs.
this allows the search to recover from local minima and makes it robust against the irregular nature of the search space.
more precisely if the new model has a higher cost c0compared to the current cost c then the it is accepted with probability min exp c0 c where and are parameters that controls how often models that don t improve the score are accepted.3empirically we found a value of 8for both and to work well in our setting.
.
.
initial program we generate an initial program by exactly matching one execution trace t respecting the given loop structure if any .
so the initial program uses the exact concrete values from t in its statements as needed.
if there is ambiguity because of aliasing e.g.
the same object is passed as two parameters we can pick any of the choices.
for statements inside a loop 3in an approach more closely resembeling mcmc would be zero.
however we found a non zero value for to reduce convergence times.where values might change with every iteration we simply use values from the rst iteration.
it is then the job of the random search to generalize this very speci c initial program to other inputs and generalize statements inside loops to work for all iterations.
more precisely a trace event read field f of o intis translated to the statement n o for a fresh local variable n. the trace event write v to field f of o is translated to o v and a call call f with a0 .. an yields the statement f a0 ... an .
if there is a loop then a loop header for i i i is generated for a fresh local variable i. initially the loop body is never executed and it is up to the random search to nd the correct termination statement.
to allow breaking out of the loop early we add an additional statement to the end of the loop body of the form if false break .
finally we introduce a local variable result for the result of the function which gets returned at the end.
to allow incrementally building the result we additionally add the statement if true result result inside the loop body as well as the ifstatement containing the break .
initially these are nops but allow the search to accumulate the result if necessary.
.
.
fitness function our tness function fitness in algorithm computes the tness of a candidate model by comparing its execution traces on the inputs against to the traces from the opaque function.
to do so it uses a function compare that takes as input a trace tfrom the opaque function called the reference trace andt0from the current model called the candidate trace both generated from the same input.
it then computes ascore that measures how close the t0is tot.
a score of zero indicatest t0 while any larger value indicates a di erence in the traces.
for our approach to work e ectively it is crucial that the random search can make incremental progress toward a good model.
this incremental progress is enabled by the tness function re ecting partial correctness of a model in the score.
to this end compare gives ne grained partial credit even for partially correct individual events.
for instance if the reference trace contains the event read field of and the candidate trace contains read field of then the score is lower better than in the case where no read event was present at all or where the read event also read from the wrong object.
formally compare t t0 is de ned as bbb x event kindkx i jevs t k j i jevs t0 k jdist evs t k evs t0 k ccca b x event kindk jevs t k j evs t0 k ca return value t return value t0 we use evs t k to refer to all events in a trace tof kindk e.g.
all eld reads as a list which can be indexed using 4alternatively we could allow more complicated termination expression in the loop header.
715the notation andj jreturns the length of a list or the absolute value depending on context .
return value refers to the return value of a trace and dist measures the similarity of two trace events of the same kind .
it is de ned as follows dist e1 e2 jvals e1 jx i jvals e1 j1fvals e1 vals e2 g where vals is a list of values for a given trace event.
for a eld read this is the receiver and eld name for a eld write it additionally includes the value written and for a function call it includes the function invoked as well as all arguments.
note that dist is scaled to return a value between and .
in the formula for compare calculates the di erence for all the events that are present in both traces while penalizes the model for any event that is missing or added compared to the reference trace .
because is scaled by the search gets partial credit for just having the right number of events of a given kind in a trace even if the wrong elds are read written.
this is useful to determine the correct loop termination conditions without necessarily having a correct loop body already.
finally ensures that the result is correct.
section will show the advantage of this ne grained tness function over a more straightforward approach.
.
.
random program mutation the control ow structure is xed at this point and the random search can concentrate on nding the correct subexpressions for all the statements.
to this end a statement is selected at random and modi ed randomly.
for eld reads writes and function calls a sub expression is selected at random and replaced with a random new expression we will explain shortly what kinds of expressions are generated .
similarly for local variable assignments the right hand side is randomly replaced.
for a forloop the upper bound is replaced with a new random expression.
for an ifstatement the condition is replaced randomly.
break statements are not modi ed.
generating random expression follows the grammar of the programming language in figure .
to avoid creating very large nested expressions the probability of producing an expression of depth ddecreases exponentially with d. the set of local variables than can be generated is determined by the set of variables that is de ned at the given program point.
the set of constants is taken from all constants that appear in any of the traces as well as a few heuristically useful constants such as .
.
cleanup when the random search succeeds the resulting program typically contains redundant parts.
for instance if it is not necessary to break out of a loop early then the statement if false break can be removed.
similarly there might be unused local variables or expressions that are more complicated then necessary e.g.
.
to clean up the resulting model another random search is performed with a slightly modi ed tness function as well as di erent random mutations in addition to the existing program transformations statements can now also be removed.
furthermore we add the number of ast nodes of the program to the cost.
this allows the search to improve the program by removing un used statements and simplifying expressions like 1to2.
furthermore the cost will never reach zero and thus the search is stopped after a certain number of iterations have been carried out.
cleanup is not strictly necessary as the models perform the same observable behavior whether they are cleaned up or not.
however cleanup can make programs nicer to look at by humans.
.
implementation we have implemented the ideas presented in section in a prototype implementation called mimic for javascript.
the tool is open source and available online.5in this section we highlight challenges and solutions particular to our setting and discuss some implementation choices.
trace recording using proxies.
we leverage the ecmascript proxy feature which allows for objects with programmer de ned behavior on interactions with that object such as eld reads and writes enumeration etc.
.
an object ocan be virtualized with a handler has follows var p new proxy o h any interaction with pwill ask the handler how to handle that interaction and default to accessing odirectly if the handler does not specify any action .
we leverage this feature to record the traces required for our technique by proxying all non primitive arguments to the opaque function.
this way we can intercept any interaction the opaque function has with the arguments and record it as an event in the trace.
our handler responds to all interactions just like the underlying object would by forwarding all calls with the additional book keeping to record the trace.
newly allocated objects.
one challenge with this approach is that newly allocated objects will only be visible to the recording infrastructure when they are returned or otherwise used e.g.
written to a eld .
for instance the function array.prototype.map takes an array and a function and applies the function to all arguments returning a new array with all the results.
when we record the trace we see all the accesses to the array elements and the function invocations but the eld writes to the newly allocated array are not visible.
to handle such functions we generate the relevant object allocation at the beginning of the initial model and assign it to the result variable.
we also add a number of guarded eld writes to the newly allocated object at di erent locations in the model e.g.
before the loop or inside the loop body if false result .
the random search is then able to identify which particular assignments are correct by changing the guard and nd the correct eld name and value to be written.
non terminating models.
it is easy for the random mutations to generate programs that are non terminating or take very long to terminate.
this can cause an in nite loop when recording the traces as part of evaluating the tness function.
luckily given the reference trace we know how long the trace from the model should be and we can abort the execution of a model when the trace gets signi cantly longer than the reference trace.
in that case the tness 716function assigns a very large cost to the trace note that small increases in trace length are not excessively penalized .
javascript specific features.
javascript contains various features not in our language from section .
many of these are straightforward to support e.g.
deletion of elds function receivers and exceptions.
javascript allows variadic functions by providing the special variable arguments that can be used to access any argument using argument as well as the number of arguments passed with arguments.length .
for instance the function array.prototype.push adds zero or more elements to an array.
mimic supports such functions by generating inputs of di erent lengths and generating expressions of the form arguments and arguments.length during the random search.
essentially we can view the function as just having a single argument that is an array and then use the usual input generation strategy described earlier.
the only di erence is that we do not get any information in the trace about accesses to arguments this special object cannot be proxied .
optimizations.
it is important for the random search to be able to evaluate many random proposals which is why we implemented the following optimizations to our approach.
input selection.
input generation can create thousands of inputs or more and executing all of them during search would be prohibitively slow.
for this reason we restrict the inputs used during search to a much smaller number.
we found inputs to work well in our experiments if the inputs are diverse enough.
to get diverse inputs we choose input that generate traces of di erent lengths as well as inputs that have di erent scores on the initial program.
if the search succeeds all inputs are used to validate the result.
if in this nal validation the score for some input is non zero then the search is considered to have failed and a new run with a di erent random seed as described earlier is necessary.
we found this to not be an issue.
program mutations.
if the program mutations are generated na vely it is easy to generate nonsensical programs.
for instance by just following the programming language grammar one might generate an expression that tries to read a eld of an integer or use an array object as a eld o set.
to avoid exploring such malformed programs we lter out expressions when we can statically decide that they are invalid.
given the dynamic nature of javascript this is not always possible but we found that our ltering eliminates many common malformed expressions.
parallelization strategy.
our procedure findmodel is embarrassingly parallel.
however one can further improve performance by exploiting the fact that some of the successful runs nish much more quickly than others.
it is often better to kill a search early and retry again in the hope of nding one of those very quick runs.
to do this we start with a small initial timeout t0 and then exponentially increase it by a factor f. we found that running threads in parallel with a timeout of t0 seconds to work well with a factor off .6all threads run with the same timeout and if any of them succeed all others can be aborted and the model can be returned.
if none succeed then the timeout is increased 6if run with fewer threads mimic will automatically use a smaller factor so that roughly the same number of short runs are made.by a factor of f and the process starts again.
cleanup as noted earlier cleanup is not necessary strictly speaking as models exhibit the same observable behavior with or without cleanup.
for this reason our prototype implements a quick cleanup that only removes unnecessary statements and is always applied.
then a full cleanup as a random search can be applied optionally to make the models more readable.
.
evaluation here we present an experimental evaluation of mimic on a suite of javascript array manipulating routines.
we evaluated mimic according to the following ve research questions rq1 success rate how often was mimic successful in generating an accurate model for the tested routines?
rq2 performance when it succeeded how long did mimic take to generate a model?
rq3 usefulness were the models generated by mimic useful for a program analysis client?
rq4 obfuscation ismimic robust to obfuscation?
rq5 fitness function how important was the negrained partial credit given by our tness function section .
.
?
.
experimental setup our primary subject programs were the built in methods for arrays on array.prototype provided by any standard javascript runtime .
these methods exhibit a variety of behaviors including mutation of arrays loops that iterate forward and backward through the array and methods returning non trivial computed results e.g.
reduce .
furthermore many of these methods can operate on javascript s sparse arrays in which certain array indices may be missing necessitating additional conditional logic.
we ran our experiments on a intel xeon e5 machine with physical cores running at .
ghz and using node v0.
.
to execute mimic written in typescript and python .
our implementation parallelizes the search for a model using di erent random seeds.
.
results success rate mimic was able to generate models for some of the array.prototype functions but not others.
the functions for which it succeeded are listed in table we discuss the other functions below.
the models we synthesized can be found at master models array.js .7we also included three other functions over arrays max min and sum that performed a bit more computation than the built in functions.
performance experimental data addressing rq2 appears in table .
the performance of mimic was quite reasonable with models taking an overall average of .
seconds to generate using our exponential increasing timeout strategy and less than minutes on average for all models.
this experiment was repeated times per example without using the full cleanup see section .
the additional time it would require to perform a full cleanup is .
seconds 7some array methods can handle array like objects we have not used such inputs and focused only on actual arrays.
8though code is available for these functions mimic made no use of it observing their behavior as if they were opaque.
717table summary of all array.prototype functions that mimic can handle as well as some handwritten functions to compute the sum maximum and minimum of an array of numbers.
we report the average time over runs it takes to synthesize the model using the quick cleanup on our hardware as well as how high the correct loop was ranked being the highest rank .
function time to synthesize loop in seconds rank every .
.
lter .
.
foreach .
.
indexof .
.
lastindexof .
.
map .
.
pop .
.
loop free push .
.
reduce .
.
reduceright .
.
shift .
.
some .
.
max .
.
min .
.
sum .
.
on average and less than seconds for all examples for the default of cleanup iterations .
in the same table we also show the loop rank assigned by our ranking heuristic being the highest ranked proposal .
the loop ranking chooses the correct control structure for out of examples with rank and with our choices for and loop mimiccore then picks this loop with probability .
for the ve examples where the correct loop is ranked second the probability is .
and for push with rank it is .
.
finally popdoes not have a loop and the loop inference does not propose any loops .
longer search times were due to several reasons loop ranking complicated expressions e.g.
generating the index n0 i is lower probability than say i and complex dependencies between loop iterations reduce requires the result of the one iteration to be passed in the next iteration .
mimic currently cannot synthesize models for array.prototype methods not listed in table due to the following issues multiple loops concat sort splice and unshift all require multiple loops for which we currently do not have any heuristics.
complex conditionals within loops reverse reverses a list in place.
the loop body takes two indices from the front and back and exchanges them.
to handle sparse arrays four di erent cases need to be handled depending on whether either element is present or not .
lack of relevant mutations join tostring and tolocalstring require computing a possibly localized string representation of an arbitrary array element which our mutations do not propose at the moment.
proxy related bugs we discovered some bugs in the current proxy implementation in node.js .
unfortunately it crashes for slice .
it also reports traces that are not in accordance with the speci cation forconcat shift and reverse .
for shift we used our own implementation that follows the speci cation.
usefulness to answer rq3 we compared the models generated by mimic with those present in the t.j. watson libraries for analysis wala a production quality static analysis framework for java and javascript.
we found that wala did not yet have any model for functions reduce every and some.
since these functions perform callbacks of user provided functions a lack of a model could lead to incorrect call graphs for programs invoking the functions.
we added the mimic generated models for these functions to wala and con rmed via small examples that their presence improved call graph completeness.
additionally we found wala s existing model of the frequently used popfunction was written incorrectly such that it would always return undefined rather than the popped value.
many of wala s models also do not handle sparse arrays which mimic models do handle.
these examples illustrate how writing models by hand can be tedious and error prone and how tool support can ease the process.
mimic generated models for the above functions were accepted for inclusion in wala.
obfuscation to answer rq4 we ran mimic generated models through a well known javascript obfuscator 10and tested that mimic generated the same model for the obfuscated function.
the obfuscator employed rewrites static property accesses into dynamic ones see section which could signi cantly degrade the quality of many static analyses.
we con rmed that for all functions we obtained the same model when using the obfuscated code as the baseline showing the promise of our technique for making such code more analyzeable.
fitness function to answer rq5 we ran mimic with a more na ve tness function that only gave credit to a trace when an individual event matched exactly with the reference trace rather than giving partial credit for partial event matches see section .
.
.
in an experiment we found that our tness function led to decreased running times compared to the na ve function validating our use of ne grained partial credit.
speci cally the running time average increased by .
on average for the na ve tness function and as much as for some examples.
.
limitations and threats to validity mimic currently cannot handle opaque functions with any of the following properties complex local computations e.g.
a sine function as our trace does not expose such computations.
nested loops or complex conditionals inside loops as discussed above.
adding such support without excessively increasing the number of loop candidates is future work.
reliance on non parameter inputs e.g.
a variable in the closure state initialized via some other sequence of method calls.
this could perhaps be handled by the user providing a richer test harness for the function.
global side e ects e.g.
on the network or le system.
this is a limitation of the native execution approach.
long running time which will slow down our search again due to native execution.
javascript obfuscator.aspx 718the primary threat to validity of our evaluation is our choice of benchmarks.
we tested mimic on all array.prototype methods and discussed cases it could and could not handle.
but mimic s handling of di erent array routines or routines on other data structures could vary.
our results thus far are quite encouraging and we plan to further validate mimic for other types of functions in future work.
.
related work summary computation computing summaries of procedure calls has been a very active area of in program analysis and it is impossible to mention all the related work on the topic sharir and pneuli s seminal work is a good overview of the foundational approaches to this problem.
we have used the term models in this paper summaries can be thought of as models that su ce for speci c static analyses which use abstractions.
most of the work on summary computation assumes the availability of library code for analysis.
however recently several authors have tried to deal with unavailable libraries.
the work by zhu et al.
deals with the problem of missing library code by inferring the minimal number of must not ow speci cations that would prevent undesirable ows in the client application.
bastani et al.
have also presented an approach that infers potential summaries for an unavailable library based on a particular static analysis problem being solved.
in both the above approaches ultimately a human auditor must judge the validity of the ndings of the tool.
like these works we also do not require the code to be available in analyzable form but unlike these works we do assume the library code is available to execute.
on the other hand while the summaries computed in the above mostly capture tainted ness and aliasing the models that we compute are considerably richer.
madsen et al.
construct models of library functions through static analysis of uses of values returned from native javascript functions.
however their work does not infer ow of values through the library functions as would be needed for instance for alias analysis rather it only infers the type structure of values returned from the libraries.
summaries can be helpful in dynamic analysis settings as well.
palepu et al.
compute summaries of library functions with the intention of avoiding repeated execution of instrumented library code.
their summary representation is suitable for aliasing and taintow like properties.
by contrast our technique requires only partial observation of the execution of the library code and our models are richer but they are more expensive to compute.
trace based synthesis as mentioned in section there has been considerable work related to the problem of constructing programs to t traces.
one of the earlier papers in this area is that of biermann et al.
.
given a trace of allinstructions as well as conditionals they show how to construct a looping program that would explain the trace.
they present a backtracking procedure that tries to discover the right program structure.
however the technique requires all instructions including conditionals in the trace.
by contrast our technique requires observing only the shared reads and writes.
traces can be detailed traces of low level instructions or they can be traces of high level domain speci c instructions e.g.
deleting a character in an editing bu er.
automatic construction of programs to automate end user tasks has beenan area of much work in the last decade .
repetitive user actions correspond to example traces and a tool synthesizes a program representation that automates such user actions.
however most current approaches to synthesis from examples are limited to generating programs in carefullydesigned domain speci c languages leveraging clever algorithms and data structures for e ciency cf.
version algebra discussion in section .
extending such approaches to generating programs with richer data and control structures as needed in our scenario is non trivial.
when it comes to general purpose programs lau et al.
s work mentions the increased di culty in synthesis when traces do not capture all the steps of a program s execution in fact they report experiments only on complete traces as in biermann s work.
other synthesis approaches jha et al.
presented a technique to synthesize straight line programs from examples.
their technique searches through a space of combinations of program operations which could be either primitive statements or api calls.
like our work they check the correctness of their synthesized programs against a native implementation on a set of inputs.
later qi et al.
extended the technique to handle loops and data structures by extending the set of possible primitive statements.
as discussed in section the main limitation of this approach is in scalability of the constraint solver as the number of primitive statement types increases our generate and test approach leverages native execution and parallelization to improve scalability.
sketching is another synthesis system based on constraint solving.
the idea of sketching is to synthesize missing expressions a.k.a.
holes from an otherwise complete program.
for certain domains boolean satis ability sat techniques can be used to e ciently synthesize completions of programs with holes.
kuncak et al.
have presented automated synthesis procedures that work based on formula solving for a limited setting of linear arithmetic and data structures.
in our setting the entire program needs to be synthesized and hence the above constraint based techniques do not apply directly.
other uses of search our work is inspired by recent successes of search based techniques in the research community.
to pick two examples there is the automatic patch generation work by weimer at al.
which uses genetic algorithms for search and which we discussed in section and compiler optimization work by schkufza et al.
which also uses the markov chain monte carlo technique.
.
conclusions we have presented a novel technique for synthesizing models for opaque code.
we collect partial execution traces by intercepting memory accesses to shared state and then use a random search technique to construct an executable code model that matches the traces.
we implemented our technique in a tool mimic for javascript and showed that it could synthesize non trivial models for a variety of arraymanipulating routines.
along with the paper we have submitted a replication package containing the full source code of our implementation as well as all the experimental setup to reproduce the results in this paper.
it has been successfully evaluated by the replication packages evaluation committee and found to meet expectations.
.