gremlin a tl a scalable model transformation framework gwendal daniel atlanmod team inria imt atlantique ls2n nantes france gwendal.daniel inria.frfr d ric jouault trame team groupe eseo angers france frederic.jouault eseo.frgerson suny atlanmod team inria imt atlantique ls2n nantes france gerson.sunye inria.frjordi cabot icrea uoc barcelona spain jordi.cabot icrea.cat abstract industrial use of model driven engineering techniques has emphasized the need for efficiently store access and transform very large models.
while scalable persistenceframeworks typically based on some kind of nosql database have been proposed to solve the model storage issue the same level of performance improvement has not been achieved for themodel transformation problem.
existing model transformation tools such as the well known atl often require the input models to be loaded in memory prior to the start of the transformationand are not optimized to benefit from lazy loading mechanisms mainly due to their dependency on current low level apis offered by the most popular modeling frameworks nowadays.
in this paper we present gremlin atl a scalable and efficient model to model transformation framework that translates atltransformations into gremlin a query language supported by several nosql databases.
with gremlin atl the transformation is computed within the database itself bypassing the modeling framework limitations and improving its performance both in terms of execution time and memory consumption.
toolsupport is available online.
index t erms atl gremlin ocl scalability persistence framework model transformation nosql i. i ntroduction models are used in various engineering fields as abstract views helping designers and developers understand manipulate and transform complex systems.
they can be manuallyconstructed using high level modeling tools such as civilengineering models or automatically generated in model reverse engineering processes such as software evolution tasks or schema discovery from existing documents .
models are then typically used in model driven engineering mde processes that rely intensively on model transformationengines to implement model manipulation operations like viewextraction formal verification or code generation .
with the growing accessibility of big data such as national open data programs as well as the progressive adoptionof mde techniques in the industry the volume anddiversity of data to model has grown to such an extent thatthe scalability of existing technical solutions to store query and transform these models has become a major issue .
for example reverse engineering tools such as modisco rely on mde technologies to extract a set of high levelmodels representing an existing code base.
these models arethen operated by model transformations to create a set ofartifacts providing a better understanding of the system suchas uml class diagrams code documentation or qualitymetrics.
however these tools typically face scalability issueswhen the input code base increases because the underlyingmodeling frameworks are not designed to store and transformlarge models efficiently.
scalable modeling storage systems have been proposed to tackle this issue focusing on providing a solutionto store and manipulate large models in a constrained memoryenvironment with minimal performance impact.
relational andnosql databases are used to store models and existing solu tions rely on a lazy loading mechanism to optimize memory consumption by loading only the accessed objects from thedatabase.
while these systems have improved the support for managing large models they are just a partial solution to the scalability problem in current modeling frameworks.
in itscore all frameworks are based on the use of low level modelhandling apis.
these apis are then used by most othermde tools in the framework ecosystem to query transform and update models.
these apis are focused on manipulating individual model elements and do not offer support for generic queries and transformations.
this low level design is clearly inefficient when combined with persistence framework because i the api granularity istoo fine to benefit from the advanced query capabilities of thebackend and ii an important time and memory overhead is necessary to construct navigable intermediate objects neededto interact with the api.
as shown in figure this is particularly true in the context of model transformations whichheavily rely on high level model navigation queries such astheallinstances operation returning all instances of a given type to retrieve input elements to transform and createthe corresponding output elements.
this mismatch betweenhigh level modeling languages and low level apis generatesa lot of fragmented queries that cannot be optimized andcomputed efficiently by the database .
to overcome this situation we propose gremlin a tl an alternative transformation approach.
instead of translating high level model transformation specifications into a sequence ofinefficient api calls we translate them into database queriesand execute them directly where the model resides i.e.
in the .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research462 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
doo dooq dwdedvh 0rgho 7udqvirupdwlrq7udqvirupdwlrq qjlqh 0rgholqj udphzrun doo qvwdqfhv qdphjhw d jhw d qdph jhw dq jhw dq qdph fig.
.
model transformation engine and modeling framework integration database store.
this approach is based on a model mapping that allows to access an existing database using modeling primitives and on a transformation helper that lets modelers tune the transformation execution to fit their performance needs.
the rest of this paper is structured as follow section ii introduces the input transformation language and the output database query language of our approach and presents a running example that will be used through the paper.
section iiipresents gremlin a tl and its key components section ivpresent how a transformation is executed from a user point of view.
sections v and vi present our prototype and thebenchmarks used to evaluate our solution.
section vii showsan application example where gremlin a tl is used to specify data extraction rules between two data sources.
finally section viii presents the related work and section ix summarizesthe key points of the paper draws conclusion and presents ourfuture work.
ii.
b ackground in this section we introduce the key features of a tl the model transformation language we use as the input of ourframework and gremlin a multi database graph traversalquery language we use as our output language.
we also presentalong the section a running example that is used through this article to illustrate the different steps of our approach.
a. atl transformation language in mde models are key elements in any software engineering activity.
models are manipulated and refined using modelto model transformations and the final software artifacts are partially generated with a model to text transformation.
each model conforms to a metamodel that describes its structure and the possible relationships between model elements and theirproperties.
as an example figure a shows a simple metamodel representing types methods and blocks.
methods are defined by a name avisibility and contain a set of blocks representing their body.amethod is associated with a return type and can have type parameters.a constructor is defined as a subclass of method.
an instance of this metamodel is shown in figure b .
a tl is a declarative rule based model transformation language that operates at the metamodel level.
transformationswritten in a tl are organized in modules that are used to grouptransformation rules and define libraries.
the language definesthree types of rules i matched rules that are declarativeand automatically executed ii lazy rules that have to beinvoked explicitly from another rule and iii called ruleswhich contain imperative code .
a tl does not assume any order between matched rules and keeps a set of trace links between the source and target models that are used to resolve elements and set target values that have not been transformedyet.
the language also defines helpers expressed in ocl that are used to compute information in a specific context provide global functions and runtime attributes computed on the fly.
ocl helpers can be invoked multiple times in a transformation and are a good solution to modularize similarnavigation chains and condition checking.
finally a tl programs are themselves described as models that conform to the a tl metamodel.
this feature allows todefine high order transformations that take an a tl transfor mation as their input and manipulate it to check invariant properties that should hold in the output model infer type orrefine the transformation.
our approach relies on this reflective feature to translate a tl transformations into efficient databasequeries.
note that in this paper we focus on a tl as our input language but our approach can be adapted to other rule basedtransformation languages notably the qvt standard.
a metamodel b instance model fig.
.
example metamodel and model listing shows a simple a tl transformation based on the metamodel shown in figure a .
the rule methodtomethodunit line matches all the method elements from the input model that do not contain a typeparameter and creates the corresponding methodunit in the target model.
the attributes and