symbolicexecution ofprogrammablelogiccontroller code shengjian guo virginiatech blacksburg va usa meng wu virginia tech blacksburg va usa chao wang universityofsouthern california losangeles ca usa abstract programmablelogiccontrollers plcs arespecializedcomputers forautomatingawiderangeofcyber physicalsystems.sincethese systemsareoftensafety critical softwarerunningonplcsneedto be free of programming errors.
however automated tools for testingplc software are lacking despite the pervasive use ofplcs in industry.
wepropose asymbolicexecutionbasedmethod named s y.sc m.scplc for automatically testing plc software written in programminglanguagesspeci f iedintheiec61131 3standard.
s y.sc m.scplc takestheplcsourcecodeasinputandtranslatesitintocbefore applyingsymbolicexecution tosystematicallygeneratetestinputs that cover both paths in each periodic task and interleavings of these tasks.
toward this end we propose a number of plc speci f ic reduction techniques for identifying and eliminating redundant interleavings.wehaveevaluated s y.sc m.scplconalargesetofbenchmark programs with both single and multiple tasks.
our experiments showthat s y.sc m.scplccanhandletheseprogramsefficiently andfor multi task plc programs our new reduction techniques outperformthestate of the artpartialorderreductiontechniquebymore thantwoorders ofmagnitude.
ccsconcepts softwareanditsengineering softwareveri f icationandvalidation software testing anddebugging software evolution keywords symbolicexecution testgeneration partialorderreduction programmablelogiccontroller plc scada acm referenceformat shengjian guo meng wu and chao wang.
.
symbolic execution of programmable logic controller code.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september4 esec fse 11pages.
introduction programmablelogiccontrollers plcs arespecializedcomputers forautomatingelectro mechanicalprocessesinawidevarietyof industrialapplications includingfactoryassemblylines transportationsystems andsmartpowergrids.plcsareoftenequippedwith domain speci f ic operating systems and virtual machines for executingsoftware code written in programming languages suchas permissionto make digital or hardcopiesof all orpart ofthis work forpersonal or classroom use is granted without fee provided that copies are not made or distributed forpro f itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the f irst page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspeci f icpermissionand ora fee.
requestpermissions frompermissions acm.org.
esec fse september4 paderborn germany 2017association forcomputing machinery.
acm isbn ... .
text st ladder diagram lad and sequential functionchart sfc .sinceplcsoftwarecontrolcriticalinfrastructures e.g.
the scada systems design defects orimplementation bugs may lead to catastrophes.
however despite the already widespread use of plcs automated testing tools are still lacking.
in this work we f ill the gap by developing a symbolic execution based tool for automaticallytesting plcsoftware.
symbolic execution is a popular technique for generating test inputs to systematically explore feasible paths of a program.
althoughsymbolicexecutionhasbeenappliedtomanyprogramming languages priortothiswork ithasneverbeenappliedtoplcs.one reason is that plc software are written in specialized and somewhat archaic languages that differfrommainstream programming languages thuslackingopen sourcedevelopmenttools.another reason is that plc software are periodic programs that often do not terminate and they involve multiple tasks running concurrently with respect to each other.
tasks have different priority levels wherehigh prioritytasksmaypreemptlow prioritytasks but not vice versa.
thus precise modeling of this non conventional execution semanticsisdifficult.
we solve these problems by leveraging an open source plc compiler named matiec and a symbolic execution tool named cloud9 .
first we leverage matiecto translate each plc task fromtheoriginallanguage e.g.
st toc.theccodeisfunctionallyequivalentinthateachofitsprogrampathshasacorresponding pathintheoriginalplctask whichensuresthattestsgenerated from the c code can be mapped back to the plc.
second we automaticallysynthesizeatestharness i.e.
the main functioninc to invokeplctasksasthreads.threadsarefurtherconstrainedtopreciselymodelthepriority basedpreemptiveschedulingasde f ined intheplcprogramsemantics.finally weextend cloud9tosymbolicallyexecutethemulti threadedcmodel.thenewsymbolic execution procedure systematically generate test cases to cover bothpathsof eachperiodictaskandtheirinterleavings.
figure1showsthe f lowof s y.sc m.scplc where pdenotestheplc program and translation from pto c is implemented in the matiec plc compiler.
our symbolic execution procedure based on cloud9 producestestcasesoftheform in sch where in denotestheinput dataandsch denotestheinterleaving schedule.since cloud9only supportscoarse grainedthreadscheduling weextendedittoexecutemultithreadedccode ata f inergranularity.
furthermore we proposeseveralplc speci f icreductiontechniquesthatleveragethe periods and priorities of tasks as well as visited states to efficiently pruning redundant interleavings.
since these redundant interleavings are due to plc speci f ic program semantics they cannot be removedby partial orderreduction techniques .
one advantage of s y.sc m.scplcas a tool is the f lexibility resulted from its separation of the modeling andanalysisphases.
in the modelingphase itfocusesoncapturingthesemanticsofaplcprogramwritteninvariouslanguagesbyconstructingthefunctionallyequivalent c model.
each plc language may be handled by a dedicated front end multiple front ends may be developed independently.intheend plctasks regardlessofwhichlanguagesthey esec fse september4 paderborn germany shengjian guo mengwu andchao wang plc program p and properties modeling in c adding test harness and constraints current input in sch plc symbolic execution based on klee generate new test input redundancy pruning period priority stateful figure1 symplc the overall f lowof ourmethod.
were written in are merged to the same c model that simulates the preemptive scheduling.
in the analysis phase s y.sc m.scplcfocuses on executing the c model efficiently without worrying about plc languagecomplications.theoverallarchitectureallows s y.sc m.scplc toeasily supportnewlanguages andexecution platforms.
anotheradvantageof s y.sc m.scplcistheefficiencyresultedfromthe plc speci f ic interleaving reduction techniques.
since these new techniquesare designedspeci f icallyfortheplctaskscheduling they are more effective than generic partial order reduction por techniques.
in the experiments section we will show por is often ineffective for removing redundant executions in plc programs due to their semantic differences from thread interleavings.
for example in standard multithreaded programs two threads with the same priority level are allowed to preempt each other whereas in plc programs they are not allowed to preempt each other.
furthermore plctasksareexecutedperiodically whichmeansthey never terminate.
our new reduction techniques are designed to takeadvantage ofthese unique characteristics.
s y.sc m.scplcisatestinputgenerationtool.assuch itdiffersfrom existingtoolsforsimulating verifying orsynthesizingplcsoftware.speci f ically simulators can executeplccode in controlledenvironments buttheyrequiretheuserstohandcraft testinputs.incontrast s y.sc m.scplcautomaticallygeneratestheseinputs.veri f icationtools aredesignedtoformallyprove thecorrectness ofproperties in models of plcsoftware butthese formal models are at a much higher level of abstraction than the actual software code.
in contrast s y.sc m.scplcdirectly executes the actualplccode.synthesistools havetheambitiousgoal of generating plc code directly from formal speci f ications thus bypassing the programmers completely.
however these tools only synthesizesmallprogramswithsingletasksduetoscalabilityproblems.incomparison s y.sc m.scplcismorescalableandcanuniformly handlebothsingle andmulti taskplcprograms.
wehaveimplemented s y.sc m.scplcandevaluatediton93plcbenchmarkprograms including49single taskprogramsand44multi task programs.
in total they consist of lines of st code which translateto62 926linesofccode.propertiesareexpressedasassertions embedded in the source code.
during our experiments we evaluatedtheexecutiontimeof s y.sc m.scplcaswellasitseffectiveness indetectingpropertyviolations.wealsocomparedourplc speci f ic reductiontechniqueswithstate of the artportechniques forcomparison weimplementedthedporalgorithm in s y.sc m.scplc.our experimental results show that s y.sc m.scplccan efficiently generate test cases for all benchmark programs and for multi task plc programs in particular our new reduction techniques signi f icantly outperform thestate of the artpor technique.
tosummarize we make the following contributions we develop a symbolic execution tool for plc software by f irst translating the original plc tasks to c code and then applyingsymbolicexecution togenerate the testinputs.
we propose plc speci f ic reduction techniques for more effectively eliminating redundant interleavings than stateof the artpor techniques.
weimplementandevaluateourtechniquesonalargenumberofbenchmarkprogramstodemonstratetheirefficiency andeffectiveness.
the remainder of this paper is organized as follows.
first we illustratethemainproblemsoftestingplcsoftwareinsection2.
then we present our new method for modeling the plc program using a multi threaded c in section .
we present the overall symbolic execution algorithm in section which is followed by the plc speci f icreduction techniques in section .
our experimental evaluation is presented in section .
we review the related work in section .
finally we give ourconclusionsin section .
motivatingexamples inthissection weuseexamplestoillustratebugsinplcprograms andexplain why ournewmethod isnecessarytodetectthem.
.
single taskplc programs figure2showsthreeplcprogramsthatimplementatwo player game named responder where i0.
i0.1andi0.2are inputs from the game host and two players while q0.0andq0.1are outputs for the players.
the program consists of two sections configuration andprogram.the configuration sectiondeclares globalvariablesandallocatesresource cpu toatask.forexample task t1 isstartedevery10millisecondsandeachtimeitexecutes an instance named gameof the program proga.
the actual code of proga providedinthe programsection hastwostatements.the f irst statement at line reads from i0.
i0.
q0.
and q0.1and then computes the new value for q0.
while the second statement computes thenewvalue for q0.
.
initially all inputs outputs and global variables are set to false.
thehoststartsthegamebysetting i0.0to true.then theplayers try to respond as quickly as possible by setting their inputs to true.
if the f irst player is faster its output q0.0becomes true indicating she has won.
but if the f irst player is slower the second player s outputq0.1becomes true.
after a player s output becomes true it should remain true until the hostsets i0.0backto false.
theprograminfigure2 a isbuggybecause whenbothplayers respondatthesametime theprogramisnotabletosetbothoutputs to true indicating a tie .
instead it is biased toward the f irst player sincetheplcprogramisexecutedsequentially i.e.
onelineafter another q0.0will be set to true f irst which prevents q0.1from beingsetto truesubsequently.
to f ixthisbug wecouldintroducetwoauxiliaryglobalvariables m0.0andm0.1as shown in figure b to buffer the temporary outputsbeforeassigningthemto q0.0andq0.
respectively.thus settingm0.0to truedoes not prevent m0.1from becoming true.
indeed whenthetwoplayersrespondatthesametime bothoutputs will be set to true.
unfortunately the revised program is still faulty.
assume that both outputs have been set to trueat the end of the f irsttaskexecution because twoplayersresponded concurrently.
since task t1 executes periodically during the next task execution q0.1being truewillforce q0.0tobecome false and q0.0being true will force q0.1to become false.
thus both outputs become falseat symbolic executionofprogrammable logic controllercode esec fse september4 paderborn germany 1configuration plc cell1 var global i0.
bool i0.
bool i0.
bool q0.
bool q0.
bool end var resource cpu responder on cpu001 taskt1 interval t 10ms priority program gamewitht1 proga end resource end configuration program proga q0.
i0.
or q0.
and notq0.
andi0.
q0.
i0.
or q0.
and notq0.
andi0.
end program a the initial buggy implementation 1var global ... m0.
bool m0.
bool 3end var ... 5program proga m0.
i0.
or q0.
and notq0.
andi0.
m0.
i0.
or q0.
and notq0.
andi0.
q0.
m0.
q0.
m0.
end program b revisedbutstill buggy implementation 1program proga m0.
i0.
and notq0.
or q0.
andi0.
m0.
i0.
and notq0.
or q0.
andi0.
q0.
m0.
q0.
m0.
6end program c the correctimplementation figure2 three implementations of plc responder inst.
the end of the second execution which is not expected.
recall that the expected behavior is that both outputs remain true until the hostends the game.
to f ix the second bug we need to revise the code as shown in figure c .
compared with the program in figure b the modi f icationisactuallyminor wesimplyenlargethescopeofthe two logical or operators to include q0.0andq0.
.
because of this modi f ication after q0.0andq0.1become true they will remain trueduringallsubsequentexecutionsof t1 regardlessofthenew inputdata until the host endsthe game bysetting i0.0to false.
thesethreeexamplesshowthatevenasimpleplcprogramwith a single task may have subtle bugs in its implementation due to the non conventional program semantics.
thus automated testing tools suchas s y.sc m.scplcwouldbe invaluable.
.
multi taskplc programs figure shows a plc program with two tasks that implement a simpli f iedversionoftheroboticcontrollerfrom .the resource sectioncontainsthetwotasks bothofwhichareassignedtothe device cpu001.task t1 hasashorterperiod 100ms andahigher priority while task t2 has a longer period 200ms and a lower priority.
in plcs high priority tasks may preempt low priority tasks but not viceversa.
assume tasks nevermiss theirdeadlines thenimplicitly thetimingconstraintisthat t1 f inishesitsexecution within100msand t2 f inisheswithin200ms.furthermore thetasks are associatedwith progaandprogbde f inedbelow.
theprogramsectionsprovidethesourcecodeofthetasks which share two global variables.
in addition progareads from the input variablesensor input whereas progbdoes not read from any primary input.1configuration plc cell2 var global obstacle bool forward int end var resource cpu main on cpu001 taskt1 interval t 100ms priority high taskt2 interval t 200ms priority low program fastwitht1 proga program slowwitht2 progb end resource end configuration program proga var input sensor input int end var obstacle if sensor input then obstacle forward end if end program program progb if obstacle then forward end if end program figure a multi task plcprogram instructuredtext.
g1004 g373 g400 g1005 g1004 g1004 g373 g400 g1006 g1004 g1004 g373 g400 g94 g286 g374 g400 g381 g396 g890 g349 g374 g393 g437 g410 g3 g1093 g3 g1005 g1004 g94 g286 g374 g400 g381 g396 g890 g349 g374 g393 g437 g410 g3 g1092 g1089 g3 g1005 g1004 g75 g271 g400 g410 g258 g272 g367 g286 g3 g855 g1089 g3 g1005 g38 g381 g396 g449 g258 g396 g282 g3 g855 g1089 g3 g882 g1005 g1004 g1004 g38 g381 g396 g449 g258 g396 g282 g3 g855 g1089 g3 g1005 g1004 g1004 g75 g271 g400 g410 g258 g272 g367 g286 g3 g1089 g3 g1004 g75 g271 g400 g410 g258 g272 g367 g286 g3 g855 g1089 g3 g1004 g38 g381 g396 g449 g258 g396 g282 g3 g855 g1089 g3 g1009 g1004 g3 figure thetask interleavingthat fails theassertion.
progaisresponsibleforobstacledetection e.g.
bysetting forward tothereversespeed 100whenthevalueoftheinput sensor input indicates an obstacle ahead.
progbcomputes the forward speed of therobotifnoobstacleisdetected.thus bothtasksmaywriteto thevariable forward lines20and26 .theraceconditionwould cause a problemin the followingscenario t1 runs f irstand sensor input isgreaterthan t1 f inishesits f irstexecution of proga t2 starts andproceeds tothe statementatline then it ispreemptedby t1 before writingto forward t1 detects an obstacle and sets forwardto and f inishesitssecondexecution of proga t2 continuesthe execution of progb.
at this moment the value of forward is and should have remained but progboverwrites it to as illustrated by figure .
the erroneous value is not expected and may result in the robothittingthe obstacle.
notethatdetectingthekindofbugshowninfigure4isnoteasy sinceitrequiresacombinationoftherightinputdata sensor input being inthe f irstexecutionof progaand inthesecond execution of proga andtaskinterleaving progbis preemptedby thesecondexecutionof progarightbeforethewriteto forward .
although in practice simulators may be used to reproduce this bug after it is detected the users are required to handcraft the esec fse september4 paderborn germany shengjian guo mengwu andchao wang error triggering input data in the f irst place which is difficult.
furthermore simulatorsdonothavethecapabilityofsystematically exploring the space of task interleavings.
our s y.sc m.scplctool in contrast solves the problemby automaticallyexploring the combined inputandinterleavingspace.thus giventhe source code ofthis plcprogram s y.sc m.scplcwillgeneratenotonlythefailure triggering testdata but alsothe corresponding task schedule.
modelingplcprogram semantics we f irstpresentourmethodfortranslatingplctaskstoequivalent ccode andthen model theirexecution semantics usingthreads.
.
translatingplctasks toc variables .
plcprograms have differentvariable types.
forexample the keyword var input de f ines read only input variables var outputde f inesoutput onlyvariables andvar external de f inestheglobalvariables.thereareeightsuchusagetypesiniec standard all of which are mapped by s y.sc m.scplcto proper variablesinthecprogram.thetranslationismostlystraightforwardexceptforinputs whichrequire special handling.
inputs.
variables such as sensor i1 andsensor i2 at line in figure are primary inputs.
they need to be fed a symbolic valueeverytimethecorrespondingtaskisactivated.thisisaccomplishedby calling the apifunction symplc mk symbolic which returnsasymbolicvalueforthevariable.wealsoapplyvalue range constraintsoverthesesymbolicvaluestoensurethattheyalways concretize to values allowed by their types.
the use of symbolic values simulates the factthat input data maybe arbitrary.
timers.thebehaviorofplctimersisabstractedbytreatingthe output ofeach timerinvocation as a symbolic variable it iseither trueor falsesincebothvaluesarepossibleatruntime.itensures thatactionsdependingondifferenttimeroutputsarealwayscovered.
although this modeling approach may introduce potentially redundant test cases it has the advantage of not missing any valid testinput.furthermore weshallshowthattheredundanttestcases maybeeliminatedbyournewplc speci f icreductiontechniques implementedinside the symbolicexecution procedure.
statements .
the translation of plc program statements from the st language to c is straightforward because as a programming language c is strictly more expressive than st. thus any st statement in the original program can be expressed by a corresponding cstatement.furthermore sincethenumberofbuilt infunctions inst libraryfunctions isfairlysmall eachofthesefunctionsmay be replaced by a corresponding c function.
in our implementation the translation from st code to c code is carried out by the matiec plc compiler which has been designed to conform to the popular iec 3standard.
in figure forexample the program statementsoftheplcroboticcontrollerare translatedintotheccode atlines .
.
constructingthetest harness the test harness is the main function that treats plc tasks as threadsandincorporatesthemtoacompletecprogram.infigure5 for example the test harness consists of lines .
there are two separate issues in simulating plc tasks using threads.
the f irst one is constructing a thread for potentially multiple invocations of each task lines .
the second one is using these threads to simulatethe periodicexecution ofplctasks lines .1bool obstacle intforward 2voidproga intsensor input obstacle if sensor input obstacle forward 9voidprogb if !obstacle forward voidthread1 intsensor i1 sensor i2 symplc mk symbolic sensor i1 ... symplc mk symbolic sensor i2 ... proga sensor i1 symplc task boundary proga sensor i2 voidthread2 progb intmain void pthread t t1 t2 for i i max iter i symplc hyperperiod begin pthread create t1 thread1 pthread create t2 thread2 symplc set priority n period t1 symplc set priority n period t2 pthread join t1 pthread join t2 symplc hyperperiod end assert obstacle forward property figure the multithreaded cmodelof thestprogram.
it is always feasible to simulate plc task interleaving semantics using threads because threads have strictly more permissive interleavingsemantics.thatis allpossibleinterleavingsallowed by plc tasks are included in the set of interleavings allowed by threads.
however threads may allow certain interleavings that are notpossibleinplcs.thus weneedtoconstrainthethreadsinour cmodeltomakethemodelingofplctasksprecise.towardthis end the f irststep isto constructall threadsforahyper period.
hyper period .plctasksinthesameprogrammayhavedifferent periods.
for instance in our running example t1 has a period of 100ms and t2 has a period of 200ms.
in this context a hyperperiodisde f inedastheleastcommonmultiplieroftheperiodsof all tasks.
thus the hyper period of our running example is 200ms.
clearly within a hyper period t1 will be executed twice and t2 will be executed once.
the reason why we are interested in the hyper periodisbecausetiming relatedprogrambehaviorsrepeat themselvesaftereachhyper period.thus focusingonanalyzing the tasks within each hyper period is important.
furthermore the hyper periodwillbeusedtoreducethesymbolicexecutioncost.in thecmodel weconstructonethreadforalltheexecutioninstances of each task in a hyper period.
that is why in figure thread1 invokesprogatwice but thread2 invokesprogbonlyonce.
periodic execution .
next we construct a for loop in the main functiontoexecuteallthreadsconcurrently.eachiterationofthe for loopcorrespondstoahyper period.thetotalnumberofiterationsisboundedbyauser de f inedparametermax iter since plc programs in general are non terminating programs.
within each hyper period we f irst create the threads and then set their parameters periodand priority .
these parameters will be passed tothesymbolicexecutionenginetoavoidexploringinterleavings symbolic executionofprogrammable logic controllercode esec fse september4 paderborn germany thatarenotallowedbytheplcprogramsemantics.asshownin figure we use special api functions to signal the boundary of thehyper periodandboundaries oftasks within eachthread.
assertions .theassertionattheendofthehyper periodrepresents the property to be checked.
in plc programs developers may use theassertion ... keywordtospecifyaproperty.suchassertions aretranslatedintoassertionsinthecprogramstraightforwardly.
s y.sc m.scplcalso allows its user to specify additional assertions which areinsertedattheendofthehyper period e.g.
atline36infigure .
assertions are reachability properties because each assert c may be modeled as if !c error where erroris an error location.
during symbolic execution if any error location is reached the symbolic execution tool produces an error triggering testcase.
symbolicexecution in this section we formally de f ine plc programs and then present theoverall symbolicexecution algorithm.
.
multithreaded cmodel themultithreadedcmodelofaplcprogramconsistsofasetof periodic tasks t t1 ... tn .
each task ti t where i n denotes an instance of a plc program within a hyper period.
consider the program named progain figure which has two instancesinahyper period lines18and20 .inourcmodel these twoinstances are consideredas differenttasks in t. tasksshareaset gv ofglobalvariables.each tialsohasaset lv ioflocalvariables.inaddition each timayreadfromaset pi of primaryinputs.thus ticanbeviewedasasequentialprogramthat reads fromprimary inputs aswell as globalvariables updates the globalvariables andcomputestheoutputs.sincetasksareexecuted periodically in addition to being a sequential program each tihas thefollowingattributes ti.tiddenotes the unique identi f ierofthe task ti.prioritydenotes the prioritylevel ofthe task ti.period denotes the execution periodof the task within a hyper period ti.starttdenotes the starttimeofthe task s period ti.endtdenotes the endtimeofthe task speriod.
duetoplc snon conventionalinterleavingsemantics foranytwo taskstiandtj where i nequalj if ti.priority tj.priority then tjmaypreempttheexecutionof tiatanytimebetween ti.starttandti.endt but ticannot preempt tj if ti.priority tj.priority neither task may preempt the othertask.
thisisdifferentfromthestandardinterleavingsemanticsofamultithreadedprogram wherethreadswiththesamepriorityareallowed topreempteachother.
the execution of task tileads to a sequence of events t1 ... tk.
foreaseofpresentation weassumeeachevent t tiinheritsall attributes of the task tiincluding tid priority period startt and endt.
in other words t.startt andt.endt are the expected start time and end time of the period of the task ti.
in addition we introduce t.task todenote the task tithat generates the event t. some events in a plc program are reads and writes of global variables whileothersarecomputationsoverlocalvariables.localoperationsarefurtherdividedintobranchingstatementse.g.
algorithm1 symbolicexecution of a multi taskplcprogram.
initially statestack s runs y.sc m.scplc s0 where s0is the initial state.
s y.sc m.scplc state s s.push s if sis an interleaving schedule node foreach event tthat is enabledand r e.sc d.sc u.sc n.sc d.sc a.sc n.sc t.sc s t s prime n e.sc x.sc t.scs t.sc a.sc t.sc e.sc s t s y.sc m.scplc s prime elseif sis a sequential computation node foreach event twhosepath conditionissatis f iable s prime n e.sc x.sc t.scs t.sc a.sc t.sc e.sc s t s y.sc m.scplc s prime else outputtestcaseif sis the endofan execution s.pop n e.sc x.sc t.scs t.sc a.sc t.sc e.sc state s event t s.sel t computenewsymbolicstate s primebasedon sandt return s prime r e.sc d.sc u.sc n.sc d.sc a.sc n.sc t.sc state s event t if tis redundantaccording tothe theory ofpor return true return false if c andassignments l v.alt exp where exp maybearithmeticcomputations bit stringoperations booleanoperations etc.without loss of generality we assume if c involves only local variables because if exp gv where afii10069.ital v.alt gv can always be replaced by l v.alt afii10069.ital v.alt if exp lv where l v.alt lv iisanewlyaddedlocalvariable andif exp lv involvesonlylocalvariables.thus duringsymbolic execution we only needtoconsidertwo types of events interleavingschedule events whichperformcontextswitches rightbefore global reads andwrites sequential computation events which are either if c or assignmentsoverlocal variables.
onlyinterleaving schedule events may affect the execution order.
thus we will focus on analyzing them to identify redundant interleavings.
in contrast sequential computation events are handled in the sameway asin standardsymbolicexecution tools.
.
overallalgorithm algorithm shows the overall procedure which closely follows priortechniquesforsymbolicexecutionofmultithreadedprograms .here sisastackofsymbolicstates.eachsymbolicstate s sis a tuple angbracketleftpcon m enabled sel angbracketright where pcon is the path condition mis the symbolic memory enabledis the set of enabled events and selisthe eventexecutedat s. initially s y.sc m.scplcstarts with the symbolic state s0.
then depending on the type of the current state s it either schedules a contextswitchorexecutesasequentialcomputation.speci f ically if sis an interleaving schedule node right before a global read orwrite s y.sc m.scplcisinvokedrecursivelytoexploreeachpossible scheduletogetherwiththesubsequentevents lines4 .if sisa sequential computation node local statement within a task s y.sc m.sc hyphen.sc plcis invoked recursively to explore each branch and assignment lines8 .uponreachingtheendofanexecution lines11 s y.sc m.scplcgeneratesthecorrespondingtestcaseandbacktracksfrom the current state.
subroutine n e.sc x.sc t.scs t.sc a.sc t.sc e.sc takesthecurrentstate sandtheevent tas input and returns the newly computed symbolic state s primeas output.
for brevity we omit the details of this symbolic execution esec fse september4 paderborn germany shengjian guo mengwu andchao wang algorithm deciding if event tchosen at sis redundant.
r e.sc d.sc u.sc n.sc d.sc a.sc n.sc t.sc state s event t if tis redundantaccording tothe dpor algorithm return true priority basedreduction lett primebe the lasteventin sbefore reaching t if t primeis null if t.priorityis notthe highestin s.enabled return true else if tis abouttopreempt t prime if t prime.priority t.priority return true if t prime.startt t.startt return true period basedreduction if t prime.tid nequalt.tid if t prime.endt t.startt return true if t prime.startt t.endt return true if tis the lasteventin t.task if th tl sthatth.tid t.tidandthpreempted tl if t prime prime sthatt prime prime.taskinterleaved with t.task if t prime prime.startt tl.endt return true return false processsinceitremainsthesameasinstandardsymbolicexecution procedures in the literature.
thechallengeismitigatingthecombinatorialblowupassociated with the event interleavings lines because in the worst case the number of interleavings is exponential in the number of global operations.traditionaltechniquesformitigatingtheinterleaving explosion are based on partial order reduction por which is to group interleavings into equivalence classes and thenpickarepresentativeinterleavingfromeachequivalenceclass while skipping the other redundant interleavings.
in algorithm this is implemented inside subroutine r e.sc d.sc u.sc n.sc d.sc a.sc n.sc t.sc .
however por doesnotconsidertheadditionalinterleavingconstraintsimposedby plc tasks.
as such it is not effective in mitigating the interleaving explosion problemin plcprograms.
our plc specificreductions inthissection wepresentthreenewreductiontechniquesdesigned totakeadvantageoftheuniquecharacteristicsofplcprograms.
speci f ically they are related to leveraging information from the priorities of tasks periods of tasks and previously visited programstates during symbolicexecution.
algorithm 2showsourimplementation ofthe f irsttworeductions.thethirdreductionwillbepresentedinsection5.
.here the subroutine r e.sc d.sc u.sc n.sc d.sc a.sc n.sc t.sc returns trueif executing tfrom the state s isredundant whetheritisduetodpororinfeasibilityaccording totheplcinterleavingsemantics.withinthecurrenthyper period wede f ine t primetobethelasteventchosenbeforereaching s line5 .
in thesubsequenttwosections we illustratehowthese twotypes ofreductions make use of t primein more details.
.
priority based reduction in this new reduction we impose three rules which directly follow theway plcsschedule theirtasks theactivetaskwiththehighestprioritymustbescheduled tobeforeotheractivetaskswheneverahyper periodstarts.
arunningtaskcanonlybepreemptedbyanotherrunning taskwith a strictly higherpriority ifahigh prioritytaskstartsbeforetheperiodbeginningof alow prioritytask theremustbenointerleavingsbetween these twotasks.1resource cpu main on cpu001 taskt1 interval t 200ms priority high taskt2 interval t 200ms priority low program fastwitht1 proga program slowwitht2 progb 6end resource figure thecontrol f lowgraph of themodi f ied program.
weencodetheserulesintolines5 11ofalgorithm2.first when bothhigh prioritytaskandlow prioritytaskareenabledandready to run the plc should always run the high priority task f irst.
this corresponds to the conditions at lines if t primedoes not exist it means tis the f irst event in the current hyper period.
at this moment the plc must choose the highest priority task to execute.
thus if tis not the highest priority task r e.sc d.sc u.sc n.sc d.sc a.sc n.sc t.sc returns true.
ontheotherhand if t primeexistsand tisabouttopreempt t prime we f irstleveragethetaskprioritiestoperformareduction andthen leverage both the priorities and the periods to perform another reduction.
speci f ically we checktwo the following conditions.
the f irst condition at line ensures that thas a strictly higher priority than t prime because plcs only allow high priority tasks to preemptlow prioritytasksbutnotviceversa.andtaskswiththe samepriorityarenotallowedtopreempteachother.thesecond condition at line makes use of periods of the tasks.
note that at this point we know t s priority is higher than that of t prime.
the condition checks if the expected start time of the period of tis before the expected start time of the period of t prime.
if this is the case theinterleavingisinfeasiblebecausethelow priorityevent t prime should not have occurred before t it should only be executed after the end of t s period .
consider the plc program in figure again as an example but with an important modi f ication setting the interval of t1 to t 200msinstead of t 100ms.
sincebothtasksnowneed t 200ms the hyper period becomes 200ms meaning progaandprogbare invoked once each in the new threads thread1andthread2 respectively.thecontrol f lowof thesetwonewthreadsareshownin figure where nodes are the global reads or writes and solid lines are the control f lows.
recall that the primary input sensor input is modeled as a symbolic variable thus allowing both branches immediately after the node 1to be taken.
in contrast the branches immediatelyafterthenode 4dependonlyonthevalueoftheglobal variableobstacle .symbolic executionofprogrammable logic controllercode esec fse september4 paderborn germany table1 interleavingsexploredbypriority basedreduction.
id all interleavings dpor symplc id all interleavings dpor symplc yes yes yes yes yes yes yes yes yes yes yes if it were a standard multithreaded program each thread would beallowedtopreempttheotheroneatthecontrol f lownodes thus leadingtoatotalof12interleavings asshowninthesecondand f ifth columnsoftable1 labeled all interleavings .amongthem thetwo interleavingsmarkedwith wouldviolatetheassertion.afterapplyingthe dpor algorithm for example eightinterleavings would remainwhiletheotherfourwouldberemoved.speci f ically isremovedbecauseitisequivalentto isequivalent to 5is equivalent to and is equivalentto .
however applyingournewpriority basedreductionwouldlead to signi f icantly fewer interleavings.
in fact only two interleavings would remain which are shown by the red and blue dotted lines in figure .
this is because according to our second rule all six interleavingsincolumn2except 5and1 4areinfeasible becausethelow prioritytask t2 preemptsthehigh priority task.
similarly according to our f irst rule all six interleavings in column6areinfeasible becausewhenboth t1 andt2 areactive andready to run atthe beginning the plcs wouldalways choose toexecute the high prioritytask t1 .
since the erroneous interleavings and are not explored by s y.sc m.scplc and s y.sc m.scplcterminatesaftertwohyper periods dueto the termination condition to be presented in section .
we have provedthe validityofthis assertion condition.
our implementation uses an on the f ly computation to decide whetherthecurrentinterleavingisfeasible.takethesecondruleas an example.
whenever an instruction accessing global variables is interpretedinthesymbolicexecutionengine wecheckthepriority ofitstaskagainsttheoperationhistoryofcurrentexecution.ifa preceding operation is from an active task whose priority is higher thanthecurrentone thentheinterleavingresultedfromexecuting tat sshould be skipped.
the f irstand the third rule are developed in a similarfashion.
in figure for instance 1is determined to be infeasible immediately after the f irst node 4is reached by s y.sc m.scplc since the f irst rule is violated.
therefore s y.sc m.scplcbacktracks from node while skippingthe interleavings numbered8 12entirely.
.
period based reduction in this new reduction we develop two rules over task interleaving two tasks are allowed to interleave only when their expectedexecution periods overlapin time ifahigh prioritytask thpreemptsalow prioritytask tl thmustnotinterleavewithanytaskwhoseperiodbegin timeis notearlierthan the periodendtime of tl.
we implement these rules at lines of algorithm .
recall thatt.starttandt.endtare the expected logical time when the periodof tbeginsandends wearenotconcernedwiththeactual starttimeandendtimeof t exceptthattheymustfallwithinthe period .
without these rules any two operations from different 1configuration plc cell1 2resource cpu main on cpu001 taskt1 interval t 100ms priority h priority taskt2 interval t 200ms priority m priority taskt2 interval t 300ms priority l priority program fastwitht1 proga program constwitht2 progb program slowwitht2 progc 9end resource end configuration b2 b1 c1 c2b3 ms g100 g258 g400 g364 g3 g100 g1006 g100 g258 g400 g364 g3 g100 g1007 g44 g455 g393 g286 g396 g3 g87 g286 g396 g349 g381 g282 a3 a1 a6 g100 g258 g400 g364 g3 g100 g1005 a2 a4 a5 figure7 threeperiodictaskswithahyper periodof600ms.
threads would have been allowed to execute concurrently in the same hyper period.
however since each task must meet its own deadline some of themcan neverrun concurrently.
consider the program in figure as our example which has threetasks t1 t2 andt3 withperiods100ms 200msand300ms respectively.thus thehyper periodis600ms allowing t1 toexecute six times t2 to execute three times and t3 to execute twice.
for easeofpresentation letthesixinstancesof t1 bedenotedfrom a1 to a6 the three instancesof t2 be denotedfrom b1to b3 andthe twoinstances of t3 be denoted c1andc2.
without the timing related information symbolic execution would have to explore all possible interleavings of these tasks including the obviously infeasible ones between a1andb2 for example whichdonotoverlapintime.theseinfeasibleinterleavings will be removedby applyingourreduction rules.
we f irstcomparethetaskidsof t primeandtinalgorithm2 different idsmeanstheybelongtodifferenttasks.thenextruleatline14 is straightforward since interleaving cannot occur if the two tasks do not overlap in time.
in our running example the period of a1is while the period of b2is .
obviously eventsin a1donotoccurconcurrentlywitheventsin b2.similarly the periods of b3andc1do not overlap.
both of these two cases are handledby the conditions atlines 15ofalgorithm2.
the second rule lines is more subtle because the infeasibleinterleavingsarededucedviaaprecedinginterleaving basedon both periods and priorities of involved tasks.
as shown in figure theperiod b2isexpectedtostartbefore a4.thus itappearsthat a4 may interleave with b2.
however if b2preempts c1in a particular execution then b2must endbefore the endofthe periodof c1 to allowc1tomeetitsdeadline.since b2wouldhaveendedbeforethe start of the period of a4 it cannot run concurrently with a4.
thus in this particularexample a4andb2can no longerinterleave.
this example also illustrates the third reduction rule in section .
a3starts from the 200ms while the earliest time b2can startis200ms.since t1 hasahigherpriority and a3startsearlier thanb2 theexecutionof a3cannotbeinterruptedby b2.thus any interleavingbetween themisguaranteedto be infeasible.esec fse september4 paderborn germany shengjian guo mengwu andchao wang algorithm nextstate computation withstateful reduction.
n e.sc x.sc t.scs t.sc a.sc t.sc e.sc state s event t s.sel t compute thenewsymbolicstate s primebasedon sandt if tis plc hyperperiod end if s prime visited return null elsevisited visited s prime return s prime .
statefulexploration now we present the state based reduction.
recall plc tasks are periodicandthusneverterminate.furthermore symbolicexecution bydefaultisgearedtowarddetectingbugsasopposedtoproving the correctness of properties.
thus applying s y.sc m.scplcwith a userspeci f ieddepthboundingeneralwillneverprovetheabsenceof bugs in a plc program.
however information of already visited statesmaybeleveragedtodetectearly terminationconditions.this allows s y.sc m.scplcto drastically reduce the number of test cases as well as prove the correctness ofproperties.
algorithm3showsthemodi f ied n e.sc x.sc t.scs t.sc a.sc t.sc e.sc subroutineinalgorithm that implements this method.
at the end of each hyperperiod itchecksifthenewsymbolicstate s primehasbeenvisitedpreviously.
if the answer is yes it returns null instead of s primewhich forcess y.sc m.scplctobacktrackimmediately.
ingeneral thestateofaplcprogramisavaluationofallvariables as well as program counters pc of all tasks.
however since weareconcernedwiththeprogramstateonlyattheendofahyperperiod wherealltaskshaveendedandlocalvariablesareoutofthe scope onlythevaluationofglobalvariablesneedstobeconsidered.
letrbethesetofallreachablestatesofaplcprogramattheend of the hyper period.
ideally s y.sc m.scplcshould generate enough test cases to cover all states in r. we will show through experiments that due to the nature of these plc programs the termination conditioncanoftenbemetafterafewhyper periods.italsomeans s y.sc m.scplcshouldbedesignedtoterminateassoonasthesymbolic executionprocedurestopsgeneratingpreviouslyunexploredstates.
consider a program named industrialauto 4from which containsa state machine whose state variable cstate6 may take a number of values.
a brute force application of s y.sc m.scplcwould resultinexponentiallymanyprogrampathsasthenumberofhyperperiodsincreases.forexample after f ivehyper periods thenumber of executions becomes .
in contrast applying our new stateful reduction decreases the total number of executions down to .
furthermore sincethesymbolicexecutionproceduredetectsthe early termination condition after hyper periods all unfalsi f ied properties are consideredto be formally proved.
experiments we have implemented s y.sc m.scplc based on the matiecplc compiler andthe cloud9symbolicvirtualmachine .weused matiectotranslatestcodeofeachplctasktoansic andthencreated a test harness to incorporate these tasks.
we implemented the testharness generatorusing python.the resultingmultithreaded c model was then executed by the extended cloud9 which uses klee internally for symbolic execution.
we extended cloud9 tohandle the plc speci f icprogramfeatures.
our experiments answer the following research questions cans y.sc m.scplcefficientlyhandlebothsingle taskandmulti taskplc programs?is s y.sc m.scplceffectivein detectingpropertyviolationsas wellasprovingtheircorrectness?
aretheplc speci f icreduction techniques stateful period andpriority effectiveinreducingthe searchspace?dotheyoutperformstate of the artportechniques?
for comparison purposes we implemented the state of the art dynamicpartial orderreduction dpor algorithm in s y.sc m.scplctoidentify andremove redundantinterleavings.
we evaluated s y.sc m.scplcon two sets of benchmark programs.
the f irst set consists of single task plc programs collected from various online sources .
the second set consists of multi task plc programs that implement several embedded controllers .eachplcprogramhas30to3 418linesofstcode which translate to to lines of c code.
in total they consist of lines of st code which translate to lines of c code.
the c code is f irst compiled to llvm bitcode and then symbolically executed by the modi f ied cloud9.
correctness properties are expressedasassertionsembedded intheprograms.weconducted all our experiments on a computer with a .
ghz cpu and gb ramrunning ubuntu .04linux.
.
results onsingle task plcapplications table2showstheexperimentalresultsonsingle taskplcprograms.
sinceeachhyper periodhasonetask thenumberofiterationsis thesameasthenumberoftasksexecuted.inthistable columns1 show the statistics of each benchmark program including the name thenumberoflinesoforiginalst code andthenumberof linesofgeneratedccode.columns4 8showthedetailedresults of s y.sc m.scplc includingthemaximumnumberofiterationsreached .iter whether stateful reduction detected convergence conv thenumberoftests generated execution timein seconds andthe instruction coverage .icov .
the last three columns show the assertion checking results including the number of undecided falsi f ied andprovedassertions.
if s y.sc m.scplc f indsanexecutionthatfailsanassertion theassertion is falsi f ied.
if s y.sc m.scplcdoes not f ind such an execution before reaching early termination the assertion is proved.
otherwise the assertion remainsundecided.
althoughsymbolicexecution isgearedtowardfalsifyingassertions table2showsthatourstatefulreductionisalsoeffectivein detectingterminationconditions.asaresult s y.sc m.scplccanprove154 assertions inadditiontofalsifying34assertions andthereareonly undecided assertions.
in contrast without stateful reduction there wouldbe 172undecidedassertions.
furthermore the number of iterations ranges from to indicating that repeatedly executing the same plc tasks after that many hyper periods does not lead to new program states.
instead the main difficulty resides in covering the input space which is whatsymbolic execution is designedfor.
the average instruction coverage for all benchmarks is .
which did not reach even for benchmarks that converged apparently because some of these instructionsare unreachable.
.
results onmulti task plcapplications in this section we show the performance differences between nonstateful and stateful exploration inside s y.sc m.scplc and then compare the various interleavingreduction techniques.
table3showstheresultsonmulti taskplcprograms.columns13 show the benchmark name and statistics of the hyper period including the total number of tasks and global operations executed symbolic executionofprogrammable logic controllercode esec fse september4 paderborn germany table2 results of s y.sc m.scplc onsingle task plcprograms.
program loc .iter conv .tests time s .icov assertions st c undet.
falsi f ied proved g4ltl st1 y .
.
g4ltl st2 y .
.
g4ltl st3 y .
.
g4ltl st4 y .
.
g4ltl st5 y .
.
g4ltl st6 y .
.
g4ltl st7 y .
.
g4ltl st8 y .
.
g4ltl st9 y .
.
g4ltl st10 y .
.
industrialauto1 y .
.
industrialauto2 y .
.
industrialauto3 y .
.
industrialauto4 y .
.
industrialauto5 y .
.
industrialauto6 y .
.
industrialauto7 y .
.
industrialauto8 y .
.
industrialauto9 y .
.
industrialauto10 no .
industrialauto11 y .
.
industrialauto12 y .
.
industrialauto13 y .
.
industrialauto15 y .
.
iec y .
.
iec y .
.
iec no .
iec y .
.
iec y .
.
iec y .
.
iec y .
.
ld program1 y .
.
ld program2 no .
ld program3 y .
.
ld program4 y .
.
mixer no .
evaporator y .
.
hydraulic y .
.
safe y .
.
logic y .
.
lift y .
.
plastic y .
.
bargraph y .
.
jedyka y .
.
glowny y .
.
il tool y .
.
shutter y .
.
alarm y .
.
fountain y .
.
total in eachhyper period becausethey areclosely relatedtothe complexityoftheinterleavingexploration.columns4 9showresults of s y.sc m.scplcwithout stateful reduction including the maximum numberofiterationsreached thenumberoftestcasesgenerated the run time and the assertion checking results.
columns show resultsof s y.sc m.scplcwithstateful reduction.
we set the time boundto10minutes andhyper perioditeration boundto10.
sincenon stateful s y.sc m.scplccannotdetectconvergence itdoes not prove properties.
in contrast stateful s y.sc m.scplccan prove properties.
our results show that stateful s y.sc m.scplconly needed a few hyper periods to detect convergence.
in contrast non stateful s y.sc m.sc hyphen.sc plcfrequently timed out or generated more test cases .
million versus 11k .
both detected violations but stateful s y.sc m.scplcalso proved27assertions whereas non stateful s y.sc m.scplcdidnot.
table shows the result of comparing different interleaving reduction techniques.
here klee denotes the default symbolic execution algorithm in cloud9augmented with the capability of handling threads.
dpor denotes the enhanced version of klee table results of s y.sc m.scplc on multi task plcprograms.
program hyper period non stateful stateful .task .ops .iter .test .time assertions .iter .test .time assertions und fal pro und fal pro nxt2.prog1 .
.
nxt2.prog2 .
.
nxt2.prog3 .
.
nxt2.prog4 .
nxt2.prog5 .
nxt2.prog6 .
nxt2.prog7 .
nxt3.prog1 .
nxt3.prog2 .
nxt3.prog3 .
nxtway01 .
nxtway02 .
nxtway03 .
nxtway04 .
nxtway05 .
nxtway06 .
nxt.pi00 .
nxt.pi01 .
nxt.pi02 .
nxt.pi03 .
trans01 .
trans02 .
trans03 .
trans04 .
trans05 .
attend01 .
attend02 .
attend03 .
attend04 .
att4 01 .
att4 02 .
race01 .
race02 .
race03 .
nobadmode01 .
nobadmode02 .
nobadmode03 .
nobadmode04 .
ctm01 .
ctm02 .
ctm03 .
aso 01 .
aso 02 .
aso 03 .
total whereweaddedtheimplementationofdynamicpartialorderreduction.
among the three plc speci f ic reductions perioddenotes ourperiod basedreductiontechnique prioritydenotesourprioritybased reduction technique and period priority denotes the fullblown implementation ofour reduction in s y.sc m.scplc.
all methods shown in table were used in conjunction with the stateful reduction.foreachindividualmethod weshowthenumberoftest cases generated and the total execution time in seconds.
since the timelimitwassetto10minutes 600smeansthecorresponding methodwas forced toterminate afterrunning outoftime.
as shown in the total numbers in the last row the full blown reductionimplementedin s y.sc m.scplc denoted period priority signi f icantlyoutperformedkleeanddpor twostate of the artsymbolicexecutiontechniques.speci f ically thereductioninthenumber oftestcasesismorethantwoordersofmagnitude.furthermore the full blown reduction is signi f icantly more efficient than period based reduction versus or priority based reduction versus267 alone.
thismeans applying both periodandprioritybasedreductionshas ledtosynergisticimpact.esec fse september4 paderborn germany shengjian guo mengwu andchao wang table4 results of comparingthereductiontechniques.
program klee dpor plc speci f icreductions period priority period priority .
test time s .
test time s .test time s .test time s .
test time s nxt2.prog1 .
.
.
.
nxt2.prog2 .
.
.
.
nxt2.prog3 .
.
.
.
nxt2.prog4 .
.
.
nxt2.prog5 .
.
nxt2.prog6 .
.
nxt2.prog7 .
.
nxt3.prog1 .
.
nxt3.prog2 .
.
nxt3.prog3 .
.
nxtway01 .
.
nxtway02 .
.
nxtway03 .
nxtway04 .
nxtway05 .
.
nxtway06 .
.
nxt.pi00 .
.
nxt.pi01 .
.
nxt.pi02 .
.
nxt.pi03 .
.
trans01 .
.
trans02 .
.
trans03 .
.
trans04 .
.
trans05 .
.
attend01 .
.
attend02 .
.
attend03 .
.
attend04 .
.
att4 01 .
.
att4 02 .
.
race01 .
.
race02 .
.
.
.
race03 .
nobadmode01 .
.
nobadmode02 .
.
.
nobadmode03 .
.
nobadmode04 .
.
ctm01 .
.
.
ctm02 .
.
ctm03 .
.
aso 01 .
aso 02 .
aso 03 .
total relatedwork since plcs are widely used in industry control applications there existsomeintegrateddevelopmentenvironments ides andsimulators for plcs.
however they are designed primarily for mimicking the behaviorofplcdevices on hostcomputers.
althoughsimulatorsmaybeusedtotestaplcprogram theusermusthandcraftthe testinputs.aswementionedearlier manuallycreatinghigh quality test inputs is difficult.
furthermore even with the test inputs itis stillnecessarytoexplorethepossibletaskschedulesunderthese inputs.
unfortunately simulators are not equipped to perform this task.s y.sc m.scplc f illsthegapbyleveragingsymbolicexecutiontoautomaticallygeneratehigh qualitytestinputs aswellassystematically coverthe possible interleavings.
there is also a large body of work on formal veri f ication of plc applications .inthiscontext aformalmodel of the target plc has to be constructed before it is analyzed by veri f icationtoolssuchasuppal andnusmv .various optimizationsare alsoproposedtoincreasethe efficiencyofthese veri f ication tools .
however there are several fundamentaldifferences between these model checkers and s y.sc m.scplc.
first constructing and tuning formal models are not easy.
they requireexpertiseinformalmethodsandtheapplicationdomains thus limiting the practical use.
second formal models are at higher abstractionlevelsthantheactualcode thus theyaremoresuitable for checking designdefects than implementation bugs.
finally noneoftheexistingtoolshandlesmulti taskplcprograms indeed they focus exclusively on single task programs perhaps to avoid the difficulty in modeling the concurrencysemantics.
in contrast s y.sc m.scplcrequires no formal model instead it relies on symbolic execution to directly checking the plc software code.
s y.sc m.scplcalso uniformly models both single task and multi task plc programs.
while symbolic execution has been routinely used fortestingsequentialandconcurrentprogramswritteninawide varietyofprogramminglanguages tothebestofourknowledge ithasneverbeenappliedtomulti taskplcsbefore.bohlenderet al.
applied concolic testing to single task plc programs but didnot considerthe interleaving of multiple tasks.
our modelingofpreemptiveschedulingsemanticsis relatedto testing and verifying periodic programs.
in this particular context regehretal.
usedthreadstosimulatethebehaviorofinterruptdrivencprograms.kroeningetal.
veri f iedccodewithnested interruptsusingaboundedmodelchecker.chakietal.
also developedseveraltoolsforverifyingperiodiccprograms.although therearesimilarities theseworksaresigni f icantlydifferentbecause thesemanticsofplctasksdiffersfrombothinterruptsandthreads.
furthermore none of these prior works was related to symbolic execution whichisthe focus ofourwork.
our method for restricting task interactions based on prioritieswasinspiredbytechniquesformodel checking real timesoftware whichencodenecessaryconditionsofthe schedulersemantics toincrease f idelityand reduce state space explosion.
similar approaches were also used in combination with symbolicexecution .ourstatefulreductioncanbeviewedasan instance of the state merging and matching technique in symbolic execution .
however none of the existing techniques has been appliedtoplcsoftware.
there are techniques for synthesizing plc software from speci f ications.forexample chengetal.
synthesizedplccode fromlineartemporallogicspeci f ications.
gelenetal.
synthesizedplccodeforreal timesupervisorycontrolofamanufacturing system.
however due to inherent limitations so far they can only producesmallprograms.
s y.sc m.scplccanbeconsideredasacomplementary testingmethodtothese programsynthesis tools.
conclusions wehavepresentedasymbolicexecutiontoolforautomaticallytestingsingle andmulti taskplcprograms.ittakestheplcsource code as input translates itinto ccode andthen appliessymbolic execution.assuch itcansystematicallyexplorefeasiblepathsof individual plc tasks as well as their interleavings.
toward this end our main contribution is developing a number of plc speci f ic reduction techniques foreliminating redundant interleavings.
our experimentsshowthatthetoolisefficientinhandlingalargenumberofplcbenchmarkprograms.
onmulti taskplcprograms in particular our newreduction techniques signi f icantly outperform the state of the artpartial orderreductionstechnique.