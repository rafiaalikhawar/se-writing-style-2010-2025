the care and feeding of wild caught mutants david bingham brown univ.
of wisconsin madison usa bingham cs.wisc.edumichael vaughn univ.
of wisconsin madison usa mvaughn cs.wisc.edu ben liblit univ.
of wisconsin madison usa liblit cs.wisc.eduthomas reps univ.
of wisconsin madison and grammatech inc. usa reps cs.wisc.edu abstract mutation testing of a test suite and a program provides a way to measure the quality of the test suite.
in essence mutation testing is a form of sensitivity testing by running mutated versions of the program against the test suite mutation testing measures the suite s sensitivity for detecting bugs that a programmer might introduce into the program.
this paper introduces a technique to improve mutation testing that we call wild caught mutants it provides a method for creating potential faults that are more closely coupled with changes made by actual programmers.
this technique allows the mutation tester to have more certainty that the test suite is sensitive to the kind of changes that have been observed to have been made by programmers in real world cases.
ccs concepts software and its engineering software configuration management and version control systems software testing and debugging parsers keywords mutation testing repository mining test suites acm reference format david bingham brown michael vaughn ben liblit and thomas reps. .
the care and feeding of wild caught mutants.
in proceedings of esec fse paderborn germany september pages.
introduction good test suites are among the most important tools available to ensure the quality of software.
however bad test suites help nobody and evaluating test suites themselves is challenging.
mutation testing of a test suite with respect to a program provides one way to measure the test suite s quality.
in essence mutation testing measures the sensitivity of the test suite which is intended to provide an estimate of the ability of the test suite to detect faults inserted into the program in the future .
conventional mutation testing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
make random or effectively random modifications to the target program s code according to some fixed set of substitution directives such as replacing with .
just et al .
have shown that this strategy is a useful proxy for real faults.
however the conventional approach to mutation testing has a basic limitation the ad hoc patterns used do not necessarily reflect the types of changes made to source code by human programmers.
consequently the measured sensitivity does not necessarily reflect how effective the test suite is at identifying the kinds of defects that real programmers might introduce.
the objective of our research has been to reexamine mutation testing by using mutation operators that more closely resemble defects introduced by real programmers.
thus the high level goal of our work is as follows find a method for creating potential faults that are closely coupled with defects created by actual programmers.
we have developed a method for identifying such mutation operators by using the revision histories of software projects.
we call such mutants wild caught mutants .
when interpreting a revision history it may be difficult to determine precisely when a defect was introduced.
for this reason we use instead the reversal of what is likely to be a correction in the revision history.
that is the orientation of a mutation operator that we recover is backward with respect to the direction of the patch from which it was recovered in the revision history.
from a patch of the form before code after code we create a mutation operator patterna replacementb where patternais a pattern created from code fragment after code and replacementb is a rewrite created from code fragment before code.
after we present the details of our method for extracting such mutation operators there are a number of natural research questions that we consider.
for starters we wish to know whether wild caught mutation operators subsume the manually curated mutation operators widely used until now research question does the the operator harvesting method of the wild caught mutants technique find existing mutation operators?
conversely perhaps wild caught mutants exhibit useful qualities that go beyond past work 1while a patch before code after code could introduce a defect and hence our recovered mutation operator would represent a correction our system confines itself to small and typically single line patches which one might expect to be corrections more often than defect introductions.
esec fse september paderborn germany david bingham brown michael vaughn ben liblit and thomas reps language definitionidiomization mutgen idiomized language definitionharvesting mutgen mutationoperator setinsertion mutins mutated code basepatch corpus target code base optional figure overview of mutation operator extraction and insertion through the mutgen mutins toolchain research question does the operator harvesting method of the wild caught mutants technique find operators that are notexisting mutation operators?
we also want to know whether our approach leads to improved mutation testing research question do wild caught mutants exhibit behavior that is quantifiably different than existing mutation operators and if so in what ways?
while backward patches seem more likely to re introduce bugs which is good from the standpoint of mutation testing forward patches may also describe interesting human generated changes.
research question does harvesting from forward patches yield many additional mutation operators and do the behaviors of these new operators differ significantly from those harvested from backward patches?
the contributions of our work can be summarized as follows we describe a technique to automatically create mutation operators that others have identified as being missing from previous mutation approaches just et al.
.
we created a toolchain for mutation operator extraction that implements the wild caught mutants technique.
this toolchain allows the user to harvest mutation operators from most common programming languages using mutgen and then apply them to a system using mutins to perform mutation testing of a test suite.
we report on experiments in which we extracted mutation operators from a corpus consisting of the most forked c based projects on github.
we find that wild caught mutants can capture faults that traditional mutation operators are unable to reproduce.
compared to existing mutation operators the mutation operators obtained by the wild caught mutants technique lead to mutants that roughly as hard to kill as mutants from traditional mutation operators.
however they offer a richer variety of changes and thereby provide a more extensive way to evaluate the quality of a test suite.
harvesting from forward patches provides a significant numberof operators not obtained from backward patches.
there is some support for the conjecture that compared to forward harvested operators backward harvested operators can introduce defects that more closely resemble defects introduced by real programmers.
organization.
the remainder of the paper is organized as follows section offers an overview of our approach then describes mutation operator extraction and mutant insertion in detail.
section presents our experimental setup followed by experimental results in section .
section considers threats to the validity of our approach.
section discusses related work.
section describes supporting materials that are intended to help others build on our work.
section concludes.
harvesting and insertion as shown in figure our system consists of two tools mutgen for extracting reusable mutation operators and mutins for applying these operators to the code of a system under test.
the extraction process referred to as harvesting generates a mutation operator setfrom a corpus of diff formatted code patches.
our insertion tool mutins can then apply these mutation operators to a new code base distinct from that used during harvesting.
the main input tomutgen is a corpus of patches for harvesting the main input to mutins is a target code base to mutate.
both tools are parameterized by a second input a language definition which specifies the syntactic elements of the language on which they operate see section .
.
in other words our implementation of the wild caught mutants approach is really a framework that can be retargeted easily to work on other languages.
our toolchain operates in three phases idiomization harvesting and insertion.
idiomization augments the language definition to conform more closely with the patch corpus or system under test.
this preprocessing step is performed by mutgen and is described in section .
.
harvesting extracts novel mutation operators from the patch corpus.
this process is also performed by mutgen and is described in sections .
.
and .
.
the final insertion step applies harvested mutation operators to the system under test.
it is implemented by mutins and described in section .
.
512the care and feeding of wild caught mutants esec fse september paderborn germany k auto break case char const continue default k do double else enum extern float for goto k if inline int long register restrict return k short signed sizeof static struct switch k typedef union unsigned void volatile while o o !
o !
.
?
q c c figure language definition file for c. the first character on each line specifies keywords k operators o quoted string literals q block comments c or single line comments c .
.
language definition we define a language as a set of operators keywords quote delimiters and comments both block comments and single line comments .
our language parser is essentially a lexical analyzer.
however our language definition files are simpler than those required by a full lexical analyzer generator e.g.
flex in part because we do not need to feed tokens into a full compiler.
additional simplification is possible by leveraging commonalities seen in the basic syntax of c and other c influenced languages such as c java and c .
these commonalities allow us to recognize tokens with high accuracy using the following strategy operators are consumed greedily from the input stream.
text from one quote delimiter to a matching quote delimiter is parsed as a single string literal.
text identified to be not part of an operator is read until whitespace or an operator is encountered once isolated in this fashion the text is classified as follows if the text exists in the keyword list it is classified as a keyword.
if the text begins with a digit it is classified as a numeric literal.
otherwise it is classified as an identifier.
while simple these rules are such that mutgen can effectively parse most languages that lack semantic whitespace.
using such a simple language definition and not e.g.
a contextfree grammar for the language used in the corpus supports our goal of using patch histories as a source of mutation operator sets.
the patches processed by mutgen to harvest mutation operator sets have varying and unpredictable contexts one may easily encounter a patch that begins or ends mid expression or mid comment.
therefore we do not parse the input with respect to a context free grammar for the language of the corpus.
instead we perform purely lexical analysis generating a stream of tokens as determined by 2escaped quote delimiters are not handled but would not be hard to add.
3python s semantically meaningful whitespace could be handled as well by materializing and later dissolving explicit indent outdent tokens a standard python lexing parsing technique.table most frequent inferred idioms in our experimental corpus idiom incidence 0x00 dev set 888idiom incidence u32 y u8 file 500idiom incidence s line data inode o rules in the language definition.
this approach also allows our system to be more flexible with regard to its inputs.
the harvester need not be able to compile any part of its input corpus it can injest incomplete or invalid code fragments as well as complete code.
comments create a challenge during harvesting.
the patches we process can begin and or end mid comment.
thus we cannot guarantee that the tokens generated when analyzing a particular patch correspond to actual code as opposed to a natural language comment.
we address this problem in both the extraction and insertion phases.
during extraction we use heuristics to identify and discard patches that are likely to be comments section .
discusses these heuristics in more detail.
during insertion we have the full system under test and therefore the complete context for any potential insertion so we can identify comments precisely and exclude them from mutant insertion.
.
idiomization the language definition file covers all of a language s keywords and operators.
however some identifiers are used so often and in such standardized ways as to effectively be additional keywords.
we call these identifiers idioms and the process of identifying them idiomization .
we collect identifiers that occur within the corpus above a user selected threshold.
this threshold can be specified by minimum incidence in the corpus minimum frequency or a top k limit of accepted idioms.
subsequent extraction passes treat these identifiers as additional keywords.
for example null is missing from the c language definition given in figure .
this omission is correct null is a standard c macro but is not a c keyword per se .
adding null to this definition by hand would be easy and would expand the pool of admissible candidate mutation operators.
unfortunately the arbitrary choices required by this method do not necessarily scale.
automated idiomization provides a pragmatic method to augment a base language definition with identifiers that are used idiomatically in practice.
depending on differences in the subject of the patch corpus and the system under test idiomization has the potential to identify idiomatic keywords that appear rarely or never in the system under test.
therefore we make idiomization optional and also allow the system under test to be used as its own source of idiomization.
table lists some of the most commonly identified idioms derived from our experimental corpus.
the influence of the linux kernel is apparent in several entries.
513esec fse september paderborn germany david bingham brown michael vaughn ben liblit and thomas reps if x if x y a admissible candidate if .
.
if .
.
.
b mutation operator extracted from figure 3a if x y if x c inadmissible candidate requires synthesizing y if x if x d candidate made admissible by idiomization of figure example candidate mutation operators.
.
syntactic mutation mutgen identifies candidate mutation operators by isolating small changes defined as having fewer than a configurable number of lexical tokens from the revision history it reads as input.
for a patch to be considered for extraction it must contain a contiguous section of removed and replaced code that we divide into a before and after block.
a single patch that is a single diff formatted file can contain multiple blocks of modified code and each individual contiguous block is treated as a separate candidate mutation operator.
corresponding blocks of each identified section are broken into a stream of tokens as described by the language definition see section .
.
mutgen makes no attempt to understand the underlying semantics or grammar of a processed language.
mutins does not attempt synthesis of identifiers or literals so mutgen requires that candidate mutation operators not require the synthesis of new information.
in particular it must be possible to assemble the before state solely from identifiers and literals matched in the after state along with any keywords drawn from the idiomization enhanced language definition.
once the before andafter blocks are tokenized mutgen then analyzes both to determine whether this requirement is satisfied.
a candidate mutant that meets the requirement is called an admissible candidate .
figure 3a shows an admissible candidate mutation operator building thebefore text requires no new identifiers or literals beyond those that appeared in the corresponding after text.
conversely an inadmissible candidate is one that would require synthesis of new information to turn its after state back into its before state.
the candidate mutation operator in figure 3c would be discarded as inadmissible its before state includes the identifier y which is not found anywhere in the after state.
the idiomization process discussed above allows for limited synthesis of terms not present in the after state.
thus idiomization turns some otherwise inadmissible candidates into admissible ones.
the candidate mutation operator in figure 3d would be inadmissible if we had to synthesize the in the before state.
however is so common that it is always recognized as an idiomatic keyword in practice.
thus the before state of figure 3d can be constructed from the after state by replacing with the idiomatic keyword .
figure 3b shows the tokenized mutation operator extracted and generalized from figure 3a.
in the mutation operator language of mutgen andmutins indicates a keyword where the text that else a while i n while i n b tmpfile tmpfile c figure examples of real candidate mutation operators found within the experimental corpus.
follows identifies the keyword itself.
likewise .
indicates an operator where the text that follows specifies the operator text.
for identifiers and literals that appear in both the before andafter states we number after identifiers and literals starting from .
i represents the ithidentifier or literal.
this notation lets us represent mutation operators that are polymorphic with respect to identifier names and literal values.
thus the generalized mutation operator in figure 3b can match a wide variety of if statements not merely those that test the value of x y as in figure 3a.
marks identifiers and literals that do not appear in the before text.
as seen in figure 3b mutation operators are stored in a plain text format that humans can easily read and edit.
this feature allows a user to create hand written mutation operators for use in our mutation testing system.
figure shows some candidate mutation operators identified by mutgen .
figure 4a shows a patch that fixes a missing else keyword.
from this patch we harvest a mutation operator that can remove anyelse keyword immediately after a right curly bracket.
the patch in figure 4b generalizes into a mutation operator that can add a semi colon to certain while statements.
figure 4c yields a mutation operator that when applied to c code can strip a modulo operation applied to a single identifier.
.
filtering heuristics our initial expectation that admissible candidate mutation operators would be rare proved to be untrue.
on the contrary our initial run of mutgen over the patch corpus used in our experiments yielded over twenty million mutation operators more than it was reasonably possible to evaluate.
manual inspection revealed that many of these were not worth keeping.
for example some would only mutate comments or were so complex as to be unlikely to match token sequences from other code bases.
we therefore extended mutgen with heuristic filters to detect and discard operators with less promising potential.
mutgen s complete filtering sequence applied in the order given below is as follows too many tokens candidates that consist of large amounts of code are so specific that they will probably not match in any other code base.
therefore we discard candidates that affect eleven or more tokens.
too few tokens conversely single token candidates would match too frequently to be practical.
therefore we require that either the before or the after text contain at least two tokens.
note that identifier shifts section .
can still apply to single token before andafter texts.
ascii art candidates that contain three or more repeated operators are assumed to be comments and excluded.
this situation commonly arises in line spanning ascii art such as or .
514the care and feeding of wild caught mutants esec fse september paderborn germany comment detected using the language definition section .
we can recognize candidates that include the start or end of a comment.
mutating comments is not useful in mutation testing so we exclude such changes.
needs synthesis per section .
we discard candidates for which the pattern contains identifiers or literals not present in the replacement .
our current version of the toolchain does not support the synthesis of identifiers outside of the limited identifier conversion in identifier shifts or through the use of identifiers treated as keywords through idiomization that would be required to apply these mutation operators to a target program.
too many identifiers as for too many tokens a candidate involving too many identifiers is unlikely to be applicable to new code.
we discard candidates that affect more than four identifiers.
too many adjacent identifiers a candidate containing three identifiers in a row is more likely to be naturallanguage text than programming language source code we assume that these candidates involve comments and exclude them from harvesting.
identical tokenized strings generalizing a candidate into a reusable mutation operator can make the before and after token streams identical yielding a mutation operator that changes nothing.
this situation can arise for example when the candidate merely affects whitespace.
we discard these candidates.
unbalanced brackets all mainstream languages include bracketing tokens that must appear in matched pairs such as round parentheses square brackets and curly braces.
mutation operators can introduce mismatches when our harvester splits one commit into multiple separate changes each of which affects only one side of a matched bracket pair.
we discard candidates that introduce mismatched counts of opening and closing round parentheses square brackets or curly braces.
introducing this filter increased the compilation rate of mutants produced by the toolchain from about .
to about .
duplicated mutation operator similar candidates can yield identical generalized mutation operators.
we discard redundant copies.
several of the above filters rely on configurable thresholds.
adjusting thresholds for total tokens or potential identifiers can dramatically change the total harvested mutation operators while also changing the probability that each mutation operator can be matched with and therefore inserted into another code base.
some tuning may be needed for specific languages or coding styles.
for example function application can lead to multiple adjacent identifiers in many functional languages sum x y z in ml or sum x y z in lisp instead of sum x y z in c. in such languages the too many adjacent identifiers filter should only be used with a high threshold.
the result of applying these culling heuristics was to reduce the generated set from over twenty million mutation operators most of them unusable to roughly forty four thousand of which a largerpotential mutation operators too many tokens too few tokens ascii art .
comment detected .
needs synthesis too many identifiers too many adjacent identifiers identical tokenized strings unbalanced brackets duplicated mutation operator harvested mutation operators figure potential mutation operators discarded and retained at each filtering stage proportion can be applied to other code bases.
section .
discusses the empirical behavior of these filters in greater detail.
.
effect of filtering heuristics figure depicts the filtering process as applied to space.
flow begins at the top with 907candidates and proceeds downward.
each filter removes some candidates and allows others to proceed to later stages.
the width of each curved arrow represents the absolute number of potential mutation operators discarded at each stage the actual count is reported immediately after the colon in each stage s description.
for example duplicated mutation operator discards 569candidates.
the diminishing width of the straight flow descending along the right edge of the diagram is proportional to the number of candidates retained after all preceding steps.
numbers in parentheses are the fraction of surviving candidates discarded expressed as percentage of candidates considered at each stage not as a percentage of the 907potential mutation operators gathered at the start.
for example the duplicated mutation operator filter discards of the mutation operators that had not already been eliminated in any preceding stage.
in absolute terms too few tokens is the major gatekeeper accounting for nearly half of the initial candidates that do not make it through to the end.
too many tokens and needs synthesis also discard large portions of the initial pool.
the latter could potentially be relaxed by deeper semantic analysis to allow more ambitious synthesis beyond our idiomization technique.
the other filters seem minor relative to the large starting candidate pool but notice that each of these still discards tens or hundreds of thousands of candidates.
ascii art detection is highly selective and therefore 515esec fse september paderborn germany david bingham brown michael vaughn ben liblit and thomas reps table most frequent identifier shifts in our experimental corpus before after incidence init devinit module exit module platform driver device prt dbg prt of device platform device m y config pm config pm sleep config embedded config expert mach plat a uint8 u8 device platform device has the least impact discarding just .
of the potential mutation operators it considers but even this filter eliminates candidates that would have been pointless to turn into mutation operators.
when operating at these large scales even relatively small contributors can be important.
.
identifier shifts we call the second type of wild caught mutant extracted by mutgen anidentifier shift .
during the extraction process it is common formutgen to identify a patch that consists solely of a change of one identifier to another.
while the syntactic mutation technique explicitly avoids synthesis during the insertion process with the exception of a limited form permitted through idiomization we capture these single identifier changes calling them identifier shifts to allow an additional limited form of synthesis.
any patch that is observed to replace solely one identifier with another is marked as a candidate identifier shift.
at the end of extraction all candidate shifts with incidence above a configurable threshold are encoded as identifier shifts within the mutation operator set.
all identifier shifts extracted during the harvesting process are used both forwards and backwards.
that is a single identifier shift mutation operator can replace either the before identifier with the after or vice versa.
table shows example identifier shifts harvested from the corpus used in our experiments.
.
insertion once the harvesting process produces a mutation operator set our mutant insertion tool mutins can then apply mutation operators to a code base.
mutins works by tokenizing all source code input files using the same language definition specification and rules discussed in section .
.
it then selects a mutation operator from the mutationoperator set.
by default the selection is done randomly but the user may specify either a particular mutation operator in the mutationoperator set by index or specify a seed for the random number generator.
4mutins uses the mersenne twister random number generator both for the generation of high quality random numbers as well as to allow seeds to be used across systems and allow faithful reproduction of random sequences.once the mutation operator is selected mutins then attempts to match the mutation operator s pattern to any subset of the token stream generated from parsing the source code.
all possible matches are identified and if any exist one is chosen randomly if the insertion index is not specified by the user.
mutins then replaces the tokens in the source file preserving whitespace with the tokens from the replacement in the mutation operator.
to avoid inserting mutants into non executable portions of the source code mutins uses the comment rules defined in the languagedefinition file see figure to identify comments during the insertion process and does not apply mutation operators to token sequences that lie within comments.
in contrast to the harvesting process the mutation insertion process has the entire source file available for analysis and so can more reliably identify comments because the full context is visible.
experiments .
repository mining we obtained mutation operators by mining public github repositories that contain c code.
we wanted to target the repositories with the largest number of commits however the github api does not provide a way to search based on the number of commits.
as a proxy for number of commits we opted instead to select those repositories with the most forks which is accessible via github s api.
the number of forks would seem to be a reasonable heuristic for projects with significant activity and thus a higher rate of development and commits from more developers.
qualitatively the assumption appears to be warranted the top 20project repositories under this metric include the linux kernel memcached and redis .
for our experiments we used the full revision histories of the top 50project repositories which consisted of approximately 600thousand commits containing roughly 20million individual diff blocks spanning 850million lines of text.
.
target program we used the 50project histories to rerun part of an experiment reported by andrews et al .
substituting the wild caught mutation operators obtained from the 50github project histories for the set of mutation operators used by andrews et al.
andrews et al .experimented on programs from the sir repository .
for each program andrews et al .generated a number of test suites by randomly choosing a subset of the tests in the program s full test suite.
they then measured the mutation adequacy of each randomly chosen test suite by running each test suite over the set of all mutants of the program created by applying a single mutation operator at a single site in the program.
by collecting these measurements andrews et al .constructed a model of the statistical distribution of the mutant detection rate over arbitrary test suites which they compared to a similarly constructed approximation of the distribution of hand seeded faults.
to test the effectiveness of mutation testing andrews et al .
worked with a wide variety of programs from sir including the siemens suite.
among these space was the only program that they tested for which realfaults were available instead of handintroduced ones.
because we were interested in understanding how wild caught mutants fare against a test suite s detection rates for 516the care and feeding of wild caught mutants esec fse september paderborn germany real faults we worked only with space.
as distributed by sir space has38buggy variants and one gold version with no known faults.
andrews et al .used the bug free gold version we did the same to allow direct comparison with andrews et al.
s findings.
.
procedure following the method of andrews et al .
we generated case test suite subsets from space s set of 496total test cases.
next we ran mutins on space to identify each possible point at which a wild caught mutation operator can be applied.
we recorded each possible insertion in a list that could be fed to our test suiteexecution framework at a later time.
we then divided the space of mutation insertion points into batches to be run in parallel on a large scale computing platform capable of serving over 300million hours of compute time annually.
we inserted each mutation and compiled the result if compilation succeeded we ran each of the case test suite subsets.
the data was gathered in parallel because there are no interdependences among any of the runs of a test suite subset.
once all test batches completed we recorded the number of mutants that successfully compiled.
we also computed the mutationdetection ratio am s for each compiled mutant and each test suite defined as follows definition .
.
letsbe a test suite.
then the mutation detection ratio am s is defined as follows am s of mutants detected by s of mutants not equivalent to the original program.
the denominator of am s requires determining whether each mutant is equivalent to the original program which is undecidable in general .
therefore andrews et al .
adopt and we reuse here a decidable approximation am s of mutants detected by s of mutants detected by program s complete test suite.
in other words any mutant that triggers no failure in space s extensive case complete test suite is assumed to be equivalent.
results .
research question do wild caught mutation operators cover existing mutation operators?
just et al .
describe a set of mutation operators provided by the major mutation framework replace constants.
mutgen can extract mutation operators that replace constants in the system under test both through the idiomization technique effectively turning literal constants into language keywords which can then be extracted in the form of a syntactic mutation operator or identifier shifts.
if specific conversions are not found within the corpus from which mutation operators are harvested a mutins user can manually add mutation operators that replace specific constants.
replace operators.
all operators seen in the languagedefinition file used as an input to mutgen are capable of beingextracted as syntactic mutation operator.
operator replacements can also be added manually to the mutation operator set.
modify branch conditions.
operators to modify branch conditions can be extracted as syntactic mutation operators.
section .
.
delete statements.
mutgen does not yet support the harvesting of statement deletions but there is no impediment to so.
in the terminology of section from a patch of the form after code we can create a statement deletion operator of the form patterna .
our framework allows for the replication of all four classes of mutation operators although mutgen does not currently harvest statement deletion operators.
future work will support the harvesting of these mutation operators mutins already supports such mutation operators if mutgen were capable of producing them.
the pit mutation testing suite supports a set of eleven nonexperimental mutation operators many of which duplicate mutation operators provided by the major mutation framework conditionals boundary mutator conditionals mutator invert negatives mutator math mutator negate increments mutator.
mutins can replicate these mutation operators in the same manner as major s replace operators mutation operators as all of these mutation operators consist of replacing individual operators or omit a unary minus from a larger expression in the case of invert negatives .
return values mutator.
mutins can duplicate this mutation operator via idiomization to harvest common literal numeric values and or via syntactic mutation operators for the language specific keywords true false and null5.
void method calls mutator mutins does not currently support statement deletion of which this mutation operator is an instance.
inline constant mutator.
mutins can replicate this mutation operator through idiomization as in major s replace constants mutation operator.
remove conditionals mutator constructor calls mutator non void method calls mutator.
mutins can utilize harvested mutation operators of these types so long as an example of a change of the type exists within the input corpus.
our framework allows for the replication of ten out of the eleven non experimental mutation operators supplied by pit again failing to directly reproduce statement deletion.
5the pit framework operates on java while these keywords do not exist in the c language definition used in the experimentation in this paper a java language definition for mutgen properly identifies them as keywords and treats them as such during the harvesting process without idiomization.
517esec fse september paderborn germany david bingham brown michael vaughn ben liblit and thomas reps .
research question do wild caught mutation operators extend existing mutation operators?
in their study of whether real faults are coupled to mutants just et al.
found that for of the real faults in their study none of the triggering tests detected any additional mutants.
they manually reviewed those faults and classified them as follows i cases where a mutation operator should be strengthened ii cases where a new mutation operator should be introduced and iii cases where no obvious mutation operator can generate mutants that are coupled to the real fault in our experiments we found that several of the mutation operators identified by just et al .appeared among the mutation operators harvested by mutgen .
specifically we are able to harvest mutation operators that are consistent with the classifications of just et al.
stronger mutation operators argument swapping.
mutgen is capable of harvesting patches that rearrange function arguments which become mutation operators that perform the inverse rearrangement.
argument omission.
mutgen is capable of harvesting patches that contain a function call modified to have additional arguments which become mutation operators that match a function call and replace it with one that has fewer arguments.
similar library method called.
the identifier shift technique section .
allows mutgen to harvest mutation operators of this category by identifying patches in which a single identifier is replaced by another.
just et al .specifically mention a java fault caused by a call toindexof where a call to lastindexof should have been performed.
our experiments which used a c corpus found multiple occurrences of the analogous c transformation a strchr strrchr identifier shift.
new mutation operators omit chaining method call.
mutgen was able to identify mutation operators of this type where the fault is a missing call to a one argument function whose return type is equal to or a subtype of its argument s type.
specifically it found patches in which a missing call to an sql string sanitization function was inserted.
direct access of field.
while we were unable to find this mutation operator among the harvested operators most likely because we were using only c patches this mutation category could be generated by a combination of an identifier shift and a syntactic mutation operator.
other mutation operators specific literal replacements.
the idiomization technique section .
allows mutgen to identify specific literals to be used in mutation operators.
to identify literals that are more relevant to the system under test the implementation allows the system under test to be used as its own source of idioms.
figure illustrates that these operators are all within the harvesting capabilities of mutgen .
just et al .provide diff formatted patches to illustrate faults not coupled to existing mutation operators mutgentable experimental results when harvesting from backward or forward patches aspect backward forward extracted syntactic mutation operators extracted identifier shifts total number of syntactic mutants total number of applied identifier shifts successfully compiled syntactic mutants successfully compiled identifier shifts compilation rate average am s .
.
median am s .
.
is able to harvest mutation operators automatically from the provided patches.6the patches provided by just et al .were in java while our experiments exclusively used c our toolchain is language agnostic and we were able to create a java language definition file and extract mutation operators from the provided java patches.
in addition to being able to harvest such mutation operators from diff formatted patches a user of our system can also manually specify additional mutation operators in all of the above categories.
.
research question do wild caught mutation operators differ from existing mutation operators?
research question asks whether wild caught mutants exhibit behavior that is quantifiably different than existing mutation operators.
table summarizes some basic metrics from the mutationtesting experiment with space.
mutation detection ratio.
andrews et al .
defined the samplebased mutation detection ratio am s see definition .
in section .
and measured it as .
when existing mutation testing techniques were applied to space and space s test suite.
using the same sample based technique we measured an am s value of0.81for the mutation operator set created via the wild caughtmutants technique.
this indicates that the mutation operators obtained by the wild caught mutants technique lead to mutants that roughly as hard to kill as mutants from traditional mutation operators.
compilability.
using the wild caught mutation operators the compilation success rate of the mutants created for space was around see table .
although this rate is substantially larger than our original guess that the compilation success rate would be less than the rate is comparatively low andrews et al .
reported a compilation success rate of for space.
however because of the large number of mutation operators harvested mutation testing via wild caught mutants still appears feasible our set of 439compilable mutants is more than three times larger than andrews et al .
s11 mutant set 802forward mutants 617backward mutants 980duplicate mutants .
6for some of these patches it is necessary to supply command line arguments to change the values of mutgen s options from their defaults specifically those relating to total identifier count and the commonality threshold for harvesting identifier shifts.
518the care and feeding of wild caught mutants esec fse september paderborn germany return solve min max return solve f min max a math fix as found in just et al.
return .
.
.
.
return .
.
.
.
.
b math fix as generalized by mutgen int indexofdot namespace .
indexof .
int indexofdot namespace .
lastindexof .
c closure fix as found in just et al.
indexof lastindexof d closure fix as generalized to an identifier shift by mutgen return ... tooltiptext ... return ... imagemaputilities .
htmlescape tooltiptext ... e chart fix as found in just et al.
return ... .
.
... .
return ... .
.. .
.
.
... .
f chart fix as generalized by mutgen fastmath .
pow fastmath .pi dim fastmath .
pow fastmath .pi .
dim g math fix as found in just et al.
.. pow .
.
.. .
.
.
.
.. pow .
.
.. .
.
.
.
.
h math fix as generalized by mutgen with pow and .
keywords added by idomization return getpct comparable ?
v return getcumpct comparable ?
v i math fix as found in just et al.
getpct getcumpct j math fix as generalized to an identifier shift by mutgen lookupmap new hashmap charsequence charsequence lookupmap new hashmap string charsequence k lang fix as found in just et al.
.
new .
.
.
.
.
.
.
new .
.
.
.
.
.
l lang fix as generalized by mutgen if u v if u v m math fix as found in just et al.
if .
.
.
.
if .
.
.
.
.
.
.
.
n math fix as generalized by mutgen with keyword added by idiomization figure examples of mutation operators proposed by just et al.
and identified by mutgen the majority of failed compilations arise from simple parsing errors.
another fail because mutation has turned the left operand of an assignment into a non assignable expression i.e.
not a clvalue .
other frequent compilation errors include due to invalid operands to binary operators e.g.
applied to a pointer and a double and due to using an undeclared identifier.
compilation errors of these kinds are to be expected given the lexical level at which we operate.
traditional mutation operators limit changes to ones that are unlikely to ever introduce parsing errors.
for example negating an ifcondition or replacing a with a will not break compilation except under truly exceptional circumstances.
thus the high compilation rates of traditional mutants arise essentially by construction.
the wild caught mutants approach offers no such guarantees.
that means we waste more time on failed compilations but it also means that we have the potential to change code in much more interesting ways.
.
research question are forward and backward patches different?
while considering patches in the backward direction backward patches intuitively seems more likely to re introduce bugs which is good from the standpoint of mutation testing we also tried harvesting mutation operators by considering the same set of patches in the forward direction forward patches .
overlap.
we found that the overlap is considerable between the sets of mutation operators harvested by considering patches in the forward and backward directions but there is significant non overlap of the 929unique mutation operators found using both techniques 860were found only from backward patches 359were found only from forward patches and 710were found by both techniques.
519esec fse september paderborn germany david bingham brown michael vaughn ben liblit and thomas reps mutation detection ratio.
the mutants caused by mutation operators harvested by forward and backward patches are ultimately equally difficult to kill average and median am s scores are .81in each direction per table .
this may seem surprising if backward patches truly represent bug reintroduction.
however one must keep in mind that the gold version of space used in our experiments passes its entire extensive test suite.
the test suite then effectively traps space into a rather narrow set of allowed behaviors.
any deviation from that whether to fix a fault or not is likely to trigger at least one test case failure.
given the constraints of an extensive test suite any change will look like a new fault whether derived from backward or forward patches.
ultimately forward patches may still describe interesting human generated changes and therefore harvesting them can be a worthy enhancement to backward patch harvesting.
ability to reproduce faults in space.
to evaluate the differences between mutation operators harvested from forward and backward patches we examined the faults in the faulty versions of space.
we classified each fault as to whether the two kinds of harvested mutation operators could reintroduce them if mutation testing were carried out on the gold version.
seven faulty versions and had faults that would be reintroduced by some mutation operator harvested from backward patches.
one faulty version had a fault that would be reintroduced by a mutation operator that was harvested from both the forward and backward patches.
five faulty versions and had faults that could potentially be reintroduced by mutins but with mutation operators that were not harvested in either direction from the50github projects that we analyzed.
of the five faulty version had a fault that could potentially be reintroduced via an identifier shift albeit one that we did not harvest the faults in the remaining four are expressible as syntactic mutation operators.
the remaining 25faulty versions required mutations outside of the scope of our current techniques.
the majority of these are expressible as syntactic mutation operators but involve too many lexical tokens to survive our filtering heuristics.
while these results are limited in scope they provide weak support for the conjecture that compared to forward harvested mutation operators backward harvested operators can introduce defects that more closely resemble defects introduced by real programmers.
ultimately while the ideal is to insert bug like changes into the target program a robust test suite must also be able to identify behavior changes introduced by human programmers which our wildcaught mutants whether derived from bug fixes or not simulate.
threats to validity there are several threats to the validity of our work.
we employ small changes lexical tokens or fewer and typically single line to generate our mutation operators.
these sizelimited patches represent a distinct subset of all possible changes to code and as a result we do not derive mutation operators from all valid patches observed.
we enact this limitation because the more complex each individual harvested mutation operator is theless likely it is to be matched in any particular piece of code to which it is applied.
smaller and simpler mutation operators yield a substantially higher proportion of matchable mutation operators syntactic mutation operators larger than those we harvest clutter the system but are rarely able to be applied to a system under test.
the idealized goal of mutation testing is to measure a test suite s quality by measuring its ability to detect faults of the kind that might be inserted into the program in the future.
one may question whether reversals of past changes are good candidates as predictors of the kinds of future faults that one wants the test suite to detect.
our experiment with the faulty versions of space provides a small amount of evidence that backward patch harvesting is a better source of such candidates than forward patch harvesting.
even if our specific harvesting approach proves to be sub optimal the general idea of supporting mutation testing using information harvested from a revision control system would still have much potential.
a possible improvement which we plan to investigate in follow on work is to extend the harvesting operation to include information from a bug tracking system such as bugzilla .
liwerski et al .
investigated how the combination of a revision control system and a bug tracking system provides a way to identify fix inducing patches in the revision history.7such an approach would provide three sources of input for harvesting mutation operators i the fix inducing patch ii the corrective patch and iii the commonalities between the fix inducing patch and the corrective patch.
rather than experiment shallowly across a large benchmark suite we chose to focus on evaluating in depth a single application space from the sir repository .
this decision allowed us to make direct comparisons with the empirical findings of andrews et al .
.
however if space is unlike other real world code then this difference would harm the external validity of our findings i.e.
the extent to which our conclusions can be generalized to other situations.
in spite of that risk space is an appealing subject for an experiment on the effectiveness of mutation testing.
it is not a synthetic benchmark but rather is a mature piece of software that has been subject to years of production use.
among the programs studied by andrews et al .
only space had variants with real faults instead of hand introduced ones.
moreover at 124lines of code space is larger than the programs in the siemens suite.
for space mutins generated 517single mutation mutants of which 439were compilable.
the set of 517mutants is a nontrivial set but was still small enough that for each mutant we could run case test suite subsets.
related work to the best of our knowledge the wild caught mutants technique is novel however several other projects have used related ideas.
some of the latter techniques could be used to enhance our methods for extracting mutation operators.
liwerski et al .
describe a technique to identify fix inducing patches within a revision history and propose applying similar tactics to identify failure inducing patches.
many others have used similar strategies all based on recognizing specific keywords such 7as defined by liwerski et al.
a fix inducing patch is one that causes a later bug fix.
520the care and feeding of wild caught mutants esec fse september paderborn germany as fixed or bug or bug ids such as in commit messages .mutgen could be extended to use these techniques to attempt to identify higher quality mutation operators by inferring properties of the changes induced by specific patches in the source corpus.
le et al .
mine revision histories to extract bug repairing patches and use these as a basis for program repair.
we provide a technique that effectively does the opposite we use mined patches to break code instead of fixing it.
coccinelle s semantic patches are generalized patches that can be applied to code much like our syntactic mutation technique .
however coccinelle works with manually authored patches whereas we harvest new mutation operators automatically.
coccinelle applies semantic changes to multiple blocks of code and has been applied to bug detection whereas we focus on breaking code for the purpose of mutation testing.
the mutationtesting context lets our toolchain utilize simpler patches as well as harvest them automatically.
as a follow on to coccinelle palix et al .
developed herodotos a system to track the evolution of patterns in code through analysis of a revision history.
we share palix et al .
s interest in the evolution of code although we focus on pairwise diffs between adjacent revisions rather than entire revision histories.
herodotos requires more manual intervention than our toolchain most notably to create and generalize the initial patterns to be tracked across revisions.
this approach is sensible for herodotos which ultimately drives interactive code understanding tools.
however our batch testing usage scenario calls for a fully automated approach.
nam et al .
describe a technique for identifying bug fixing commits in a source control repository and calibrating mutation testing to utilize mutation operators that more closely resemble the reverse of changes observed in bug fixing commits.
nam et al .look for keywords in commit messages as many others have done and also manually inspect commits to confirm that they are indeed fixes.
our approach is more automated as we harvest all patches that fit our purely syntactic filtering heuristics.
likewise nam et al .craft several new mutation operators by hand whereas our approach automates the entire process of harvesting and generalizing new mutation operators.
our automation focused approach may be less selective but it allows us to work with a corpus two orders of magnitude larger than that used by nam et al.
experimental artifacts our core mutation tools consisting of mutgen and mutins are available at .
we also provide tools to demonstrate our experiments at https github.com d bingham fse2017artifact .
however reproducing our complete set of experiments would require months of processor time and as such was executed on a high throughput computing platform .
therefore this experimental artifact recreates scaleddown versions of the experiments described in section .
the artifact allows the user to harvest a set of mutation operators from scraped github repositories omitting the full linux kernel source due to space and time concerns .
once a set of mutation operators are harvested from this corpus the artifact then generates thirty randomly chosen mutants chosen as mutation operatorsand insertion indices into the space program attempts to compile them and evaluates the mutated programs against space s test suite.
with the pass fail results from each test case the artifact then generates random virtual test suites to calculate am s scores for the generated mutants.
the artifact can be executed via a provided shell script or through the use of a docker container allowing demonstration of a small portion of our experiment in a highly portable manner.
conclusion for mutation testing to provide a useful measure of the sensitivity of a test suite it must produce not only faults within the system under test but faults that mimic those caused by the actual developers working on a project.
just et al .demonstrated that faults introduced through mutation testing can serve as proxies for real faults introduced by developers and be effectively used to evaluate the sensitivity of a testing suite although they also described limitations of existing sets of mutation operators.
we expand upon that work by automatically harvesting mutation operators wild caught mutants and comparing the capabilities of the harvested mutation operators to those of existing mutation operators.
andrews et al .
discussing threats to validity caution that it is also expected that the results of our study would vary depending on the mutation operators selected.
.
.
.
our findings provide strong empirical support for this expectation.
as opposed to existing synthetic mutation testing techniques every mutation we create is based on a reversed change that some real programmer made to some real piece of code.
our wild caught approach produces novel mutation operators in turn creating defects that are about as difficult to kill as those arising from existing synthetic mutation operators or space s naturally arising faults.
whether existing synthetic mutation operators or our wild caught mutation operators can objectively be characterized as more realistic remains an open question.
realism arguments aside it is clear that developers benefit if their test suites can be challenged by bugs that resemble those they might expect programmers to introduce.
our wild caught mutants technique can be a source of such bugs.
instead of crafting mutation operators by hand we believe that our results demonstrate that wild caught mutants provide a stronger method for evaluating the sensitivity of test suites.