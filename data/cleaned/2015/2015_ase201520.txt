string analysis of android applications justin del v ecchio feng shen kenny m. yee boyu wang steven y .
ko lukasz ziarek university at buffalo the state university of new y ork jmdv fengshen kennyyee bwang24 stevko lziarek buffalo.edu abstract the desire to understand mobile applications has resulted in researchers adapting classical static analysis techniques to the mobile domain.
examination of data and controlflows in android apps is now a common practice to classifythem.
important to these analyses is a fine grained examinationand understanding of strings since in android they are heavilyused in intents urls reflection and content providers.
rigorousanalysis of string creation usage and value characteristics offersadditional information to increase precision of app classification.
this paper shows that inter procedural static analysis that specifically targets string construction and usage can be used toreveal valuable insights for classifying android apps.
to this end we first present case studies to illustrate typical uses of stringsin android apps.
we then present the results of our analysis onreal world malicious and benign apps.
our analysis examines howstrings are created and used for url objects java reflection andandroid intents and infers the actual string values used as muchas possible.
our results demonstrate that string disambiguationbased on creation usage and value indeed provides additionalinformation that may be used to improve precision of classifyingapplication behaviors.
i. i ntroduction android is one of the most popular platforms for mobile computing.
countless numbers of devices have been released internationally and android s official app store google play contains more than a million apps.
however along with thispopularity comes an increase in malicious apps.
it was reportedin that of all mobile malware targeted android and this number has been sharply growing.
this increase in malware has led to the creation of many static analysis tools for identifying malicious android apps.
byidentifying malware prior to its release these tools can offerenhanced security and privacy for end users who downloadand use android apps.
many different types of analyses haveproven to be useful such as data and control flow analysis call graph analysis and sensitive api analysis .these static analysis approaches provide awareness of potentialharms to users.
in this paper we show that analysis of strings and how they are created in android apps can be useful in identifyingmalicious apps.
the usefulness of string analysis is derivedfrom two aspects.
first android apps heavily rely on strings inorder to perform potentially sensitive or malicious tasks suchas reading contact information and device ids accessing stor age calling hidden apis and using remote servers.
second string analysis is complementary to other types of analysis andcontributes to improving their precision.
for example data andinformation flow analysis can benefit from additional stringanalysis if there is a flow from the code that reads the device idto the code that sends it out to a remote server.
by employingadditional string analysis data and information flow analysiswill have a chance to differentiate which remote server theflow is intended for and if it should be considered malicious.
in order to show the usefulness of string analysis we report our preliminary results in this paper.
our string analysisfocuses on analyzing android specific uses of strings these in clude strings for intents android s messaging data structure java reflection and network urls.
our goal for analyzingthese strings is three fold.
first we aim to verify if the valueof a string object indicates its intended use.
for example aurl a class name used in reflection or an obfuscated stringcan indicate the purpose of the code that uses them.
second we aim to verify if the provenance of a string indicates itsintended use.
for example use of strings that come fromexternal sources such as configuration files may be an attemptat subterfuge.
third we aim to verify if construction of stringsprovides information on the complexity required in creation ofstrings for example a multi part string for a url.
analysisof strings in the context of these types of characteristicscan provide a wealth of information useful in improvingthe precision of flow analysis especially with respect to theclassification of malicious versus benign activities.
this paper has the following three contributions we identify string analysis as an under explored but stillquite useful type of analysis for android apps.
we present case studies that illustrate typical uses ofstrings in android apps.
these case studies also demon strate the potential usefulness of string analysis.
we report our preliminary results for url java reflec tion and intent string analysis.
we have analyzed 517benign apps from google play and malicious appsfrom the malgenome project .
we believe that ourresults provide enough evidence that string analysis canprovide additional deciding features that can improveflow disambiguation.
the remainder of the paper is organized as follows.
in section ii we present motivating examples for urls androidintents and java reflections.
it identifies how strings are usedin such operations and the value added of string analysis aswell as the inherent difficulties of the approach.
we presentthe implementation and related algorithms in section iii.preliminary results validation and threats against validityare presented in section iv.
testing of the algorithm wasperformed on a corpus of both malicious and benign apps.analysis of aggregate results identifies drastic differencesbetween the employment of strings in operations for thesetwo types of apps.
a deep dive for a selected set of resultsis provided.
the studies reveal pertinent details about howmalicious apps are engineered and how they can be identified.related work and future directions are presented in section vand section vi respectively.
30th ieee acm international conference on automated software engineering .
ieee ii.
m otiv a tion in android apps strings are used pervasively to uniquely identify android specific constructs to specify files and network addresses that an app uses as well as to enumerateclasses and methods invoked dynamically through the javareflection apis.
understanding how strings are constructedin the code base as well as the concrete values the stringscontain is vital to the understanding of the apps themselves.consider the following examples taken from real world apps both malicious and benign.
a. urls many developers make their data publicly available on internet servers and provide an interface for extracting slices or sections of that data.
urls are heavily used in android apps to communicate between clients and servers.
some appsgather users phone data and send it to remote servers torequest service content.
malware also takes advantage of thispattern to perform harmful actions.
in order to protect users privacy many analyses are currently tracking what data is sentoff the phone via the internet.
this however is not sufficientbecause it is not trivial to distinguish malicious behaviorfrom benign behavior.
to differentiate malicious and benignbehaviors we must not only track what data is but also where data is sent and how.
to do this an analysis engine must be able to track network urls.
the following example gives us a brief idea on how a url object is constructed and used in an android app.
private void exectask ... str2 base64.encodebook 2maodb3ialke8mdeme3gkos9g1icaofm mm.do?imei this.imei ... httpstring str2 mobile this.mobile ... http baseauthenicationhttpclient .getstringbyurl httpstring ... code .
android url construction example in the example the app first creates a base url string and appends additional data e.g.
imei phone number t o construct the complete url object.
finally the app sends the string out via a httpclient.
even though it is common to append data to a url string in benign apps there are notable differences in the above example.
one key difference is theobfuscation how of the ip address of the url where via the encodebook method.
malicious apps show a far greater tendency than benign apps to obfuscate the ip component.in the example the url object is also used to exfiltrate the mobile number and imei what operations benign apps do not perform.
b. android intents intent is one of the most heavily used inter component communication icc mechanisms in android.
android intent provides a nice way for benign apps to communicate but android malware can also take advantage of this toperform malicious behaviors.
researchers have spent agreat effort on analyzing intent for android icc .
to understand how an android app works we mustdiscover the relation of components connected by intents.
thefollowing code example shows how intents are used in an app.
public void onreceive context context intent intent if intent.getaction .equals android.intent.action.boot completed intent new intent android.intent.action.run intent.setclass context zjservice.class context.startservice intent ... while true if !intent.getaction .equals android.provider.telephony.sms received break intent intent.getextras ... msg smsmessage.createfrompdu byte intent this.sms code msg .getoriginatingaddress this.sms body msg .getdisplaymessagebody writerec context zjsms.txt this.sms code this.sms body ... ... private void uploadallfiles ... upload.uploadfile getkeynode dom dom v zj upload uploadfiles.aspx?askid uid getkeynode uid uid v com.creativemobi.dragracing files zjsms.txt ... code .
android system intent example this example contains three types of intents.
firstly the app catches the system boot completed intent and starts its service zjservice.
additionally it monitors two other system intents sms and outgoing call.
we only show the sms intent in the example.
as observed from the example eachintent has its own unique string which the program uses todifferentiate intents.
there might be a large number of intentscontained in a single app.
thus it is important to not onlyidentify all intents but to infer connections between differentprogram components in order to understand the behavior of theapp.
this is especially important for android because manyandroid malware apps take advantage of system intents tostart malicious code.
the above example is from one of theknown android malware.
by monitoring the system intents the app catches the incoming sms andphone call and writes to local files.
later it uploads these files to a remote serverin the zjservice.
to understand the complete execution flow above we must discover all the strings that define an intentfirst and then build up the correct flow of the program whichis needed for future analysis e.g.
data flow analysis .
681c.
java reflection reflection is commonly used by programs to provide runtime support and is used pervasively in android.
since reflection is a dynamic feature it is usually not handledby static analyses.
however precision of static analysis iscritically hurt if reflection is ignored completely.
in this case itis important to find the reflection statically defined by strings.the following jimple intermediate representation used bysoot and our tool code example shows how reflection is usedin double twist a popular music player available in googleplay.
due to space constraints we refer to v all ee rai et al.
for more details on soot and jimple.
r4 com.doubletwist.util.l string a string c2vuzejpbgxpbmdszxf1zxn0 n com.doubletwist.androidplayer.lr string i r4 r4 com.doubletwist.util.l string a string c2vuzejpbgxpbmdszxf1zxn0 n r5 java.lang.class class forname string r4 r2 com.doubletwist.androidplayer.lr string i r6 newarray class r6 class android os bundle r7 r5.
class reflect.method getdeclaredmethod string class r2 r6 r8 com.doubletwist.audio.audiovolumeservice object e r9 newarray object r9 r3 r8 r7.
java.lang.reflect.method object invoke object object r8 r9 code .
android reflection example as observed above the app loads a reflection object using an encrypted string.
then it fetches the wanted method fromreflection by using another encrypted string and executes it bycalling invoke.
clearly it performs some abnormal actions as it obfuscates the class and method names loaded via reflection.this is one of the common patterns in malware we haveobserved during our string analysis.
iii.
i mplementa tion our string analysis prototype is being built into blueseal a data flow analysis framework we have developed .
it is pub licly available along with data sets experimental results andplotting scripts for download at itself is built on the soot bytecode optimizationframework.
our string analysis runs three phases as follows.
a. interprocedural analysis the first phase of our tool gathers relevant information on strings used in intents files urls and java reflection.
this is done through a backward inter procedural flow analysisoriginating at relevant invoke statements of api calls whichthe tool takes as input.
the analysis itself is mostly standard but leverages functionality from blueseal to recreate theandroid app s call graph.
the most important feature of ourimplementation is the capability to reconstruct complex strings.that is it can reconstruct strings built by multiple string related operations across different methods.
this capabilitywould dovetail nicely with other tools such as iccta thatperforms single method string analysis.
due to the structure ofandroid apps not all method calls are in the default generatedcall graph.
for more details on call graph reconstruction forandroid please refer to our previous work on blueseal .
b. abstract interpretation the output of our first phase is a set of backward flows where each flow is represented as a graph starting with a single root.
this root for a backward flow graph is a stringargument used in intents files urls or java reflection.
thus each graph is effectively a backward slice of a program that consists of the code used to construct a string of interest.
thisgives us an opportunity to analyze the structural properties of how strings are created and used we perform an abstractinterpretation over each graph in order to do this.
as theresults presented in section iv show in many cases thisallows us to generate concrete string literals.
our abstractinterpretation engine understands basic java string constructionapis including the stringbuilder class.
c. string classification once a graph is generated we classify strings into multiple categories.
the goal of classification is to provide multipletypes for strings which eventual clustering or disambiguationalgorithms could use to classify a string as benign or malicious.currently we classify strings into three categories as follows.
plain strings this category includes strings constructed using string andstringbuffer classes.
these are perhaps the most frequently used classes to build a string andinclude convenient methods such as replace append andsubstring.
derived strings this category includes strings originated from sources other than string literals found in thecode.
for example strings originated from tostring class.forname or a string read from a configurationxml file all belong to this category.
intraprocedural or interprocedural strings this category identifies if a string is created within a single methodor across multiple methods.
in the future we plan to test a number of different categories based on the inferred properties and code characteristicsthat our tool is currently able to extract.
we currently countthe number of class and static fields used in the creationof the string the number of methods called in the creationof the string especially where aggregated strings show deepnesting of method invocations to retrieve string parts andgraph patterns for constructed strings.
the latter characteristicoffers the possibility to match obfuscated code against knowngraph patterns to determine likely intent and semantics ofoperations performed.
iv .
r esults development and initial validation of the algorithm was performed using unit test and gold standard android appsobtained from github.
unit test apks were designed to testthe validity of the inter procedural algorithm especially withrespect to chaining string creation graphs for parameter andreturn values.
precision and recall metrics were developed for 682the gold standard github apps with respect to total number of url objects created and for each created object the number of method calls that contributed to the string s creation.
the algorithm was next tested on a small subset of the malgenome apps.
v alidation of results for malgenomerequired a different test methodology as source code wasnot available.
all url objects were identified by inspection of soot unit objects.
manual tracing of string creation wasperformed to identify and resolve issues with the string anal ysis algorithm.
the initial version of output formats used inthe following aggregate analysis section were developed andperfected to capture necessary information.
manual inspectionof malgenome apps solidified the string analysis algorithm im plementation and this inspection process continued as analysisresults identified the need to capture additional information forcustomized output formats.
a. benchmarks two sets of android apps were used for benchmarking the malgenome corpus of malicious apps consisting of apps and the google play corpus consisting of apps.
both setscomplement one another as they contain a broad spectrum ofapps from those relatively small in size hundreds of kbs tolarger apps that are in the tens of mbs.
the string analysisalgorithm was fitted with a threaded driver class that allowedfor multiple concurrent analysis executions.
the malgenomecorpus was processed in six hours and google play in tenhours using a thread pool of size five.
interesting to note isthat across all equally sized apps google play apps take longerto process than malicious apps.
multiple output formats were generated to enable the aggregate analysis of results.
these included a tabular view ofall strings detected by the analysis algorithm a graphical viewof the soot units used in string creation values and countsof all reflection and url string values across all apps and counts of all method calls across all apps.
these four outputtypes provided a great deal of information about string creationand contributed to identification of the high level observationsdiscussed in the following subsections.
creation of urls url creation presents a wealth of information that may be used to categorize the behavior ofmalgenome and google play apps.
consider table iv a1 which shows our tool s results for url parameters for both malgenome and google play apps.
provided are the topten parameters identified for urls constructed in these apps along with counts note that for brevity we only presentjava.net.url objects .
immediately it is evident that while google play apps provide information about timestamp plat form and app id malicious apps are interested in passinginformation with respect to imsi iccid and telephonenumber.
some overlap does exist between arguments where timestamp and p1 trace to java date objects used to collectthe timestamp when the url is sent.
the tool captures urls that are discrete strings as well as strings that are a series of appends.
analysis on thediscrete strings yields a simple observation summarized intable iv a1.
for the distinct discrete strings identifiedfor google play apps used https.
for the identifiedfor malgenome only used https.
all three cases were callstable i. t opurl parameters malgenome google play parameter total parameter total p1 c imsi uid ca game ac udid shid app id err s tel timestamp iccid sid pid locale sim platform table ii.
u sage of secure and insecure http c onnections http https google play malgenome to mainstream urls facebook and myspace.
this simple observation demonstrates that the authors of malicious apps areunconcerned with encryption of the actual transfer of content.
while unconcerned with encryption of the transfer of content malicious app developers are extremely concernedwith encryption of the ip addresses they connect to.
anexamination of google play apps revealed that there wereno instances of obfuscated or encrypted url usage.
the same examination of malgenome apps identified hundreds ofinstances of obfuscated or encrypted url usage.
table iv a1 demonstrates this where the left column are methods thataccept obfuscated text typically the ip portion of the address and are used in url string creation.
zhou et al.
discuss some of these methods in greater detail.
there are numerous observations related to this table.
the example column indicates that obfuscation results tend to fallinto two categories those starting with the sequence hoip and those that do not.
this categorization corresponds to themethod signatures in the method column where all methodsexcept encode andencodebook use hoip strings.
reflection we have run our string analysis on both known malgenome malware and google play apps to gatherstatistics on how malware and legitimate apps leverage reflection.
in table iv a2 we show the gathered statistics.here we only show the most common reflection strings basedon the occurrence count.
we observed that the most commonlyused reflection strings are related to the ads classes.
as wemanually examine the apps it turns out some of the appsleverage reflection to request ads from different libraries.another family of interesting reflection strings is found inwhat appears to be an official apache httpclient library usedby some apps.
in this library reflection is heavily used inmany different places.
however after comparing the codeto the official apache library code we have discovered thatthese two are completely different as the official library neveruses reflection.
the last interesting class of apps that usereflection involves a known malicious family called geinimi.
by examining the source code manually we have discoveredthat the geinimi code uses reflection to start a malicious service which steals sensitive data including sms device idandphone number and sends it to a remote server.
683table iii.
e ncrypted url usage method total calls spread example angbracketleftcom.keji.danti.util.ap string a string angbracketright hoiprjbh9c519if5hxil9i0h8cmnuezdrebh7 angbracketleftcom.sec.android.providers.drm.xmlns string d string angbracketright hoiprjbh9cvn9wnq0w7o84fepwnypjshh angbracketleftcom.android.main.base64 string encodebook string int int angbracketright kl4ofgsmgeje5gko99s1fc2ofm angbracketleftcom.sec.android.providers.drm.onion string a string angbracketright hoiprjbh9cvp9i0h8cg1zkvo7cao7cfapjsq angbracketleftcom.keji.util.pd string a string angbracketright hoiprjbh9nds9i0h8cg1zkvo7cao7cfapjsq angbracketleftcom.keji.util.pf string d string angbracketright hoiprjbh9c519if5hxil9i0h8cmnuezdrebh7 angbracketleftcom.android.battery.a.pf string d string angbracketright hoiprjbh9c519if5hxil9i0h8cmnuezdrebh7 angbracketleftcom.android.main.base64 string encode string int angbracketright alfo3gsa3nfdsrfo3isd21d8a8fccosm angbracketleftcom.android.base64 string encode string int angbracketright alfo3gsa3nfdsrfo3isd21d8a8fccosm angbracketleftac string d string angbracketright hoiprjbh9c519if5hxil9i0h8cmnuezdrebh7 angbracketleftcom.android.sf.adomb.transitional string d string angbracketright hoiprjbh9cvp9i0h8cg1zkvo7cao7cfapjsq table iv .
r eflection usage in android reflection class string count com.admogo.
ad com.waps.
ad org.apache.commons.httpclient.
com.geinimi.custom.googlekeyboard com.google.ads.adview intent analysis was performed on intents for both malgenome and google play with intent calls in the former and calls in the latter.
results were analyzedby grouping the string argument values provided to intentsand sorting by frequency.
table iv a3 shows the result of thisanalysis.
several interesting conclusions can be drawn from the table.
the google play apps display an expected pattern of intentusage.
the view intent is indicated by google documentationto be the most used intent with the documentation alsoindicating that send and main are popular.
additionally there are numerous intents related to billing again expectedfor commercial apps.
the malgenome apps show a very different usage pattern.
they also make use of the view intent as expected.
secondmost popular is web search used to make url connections.
this intent ranks 39th in google play with usages.next most popular is app development settings a non mainstream intent with few