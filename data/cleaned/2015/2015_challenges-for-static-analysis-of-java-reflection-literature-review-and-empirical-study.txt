challenges for static analysis of java reflection literature review and empirical study davy landman alexander serebrenik jurgen j. vinju centrum wiskunde informatica amsterdam the netherlands davy.landman jurgen.vinju cwi.nl eindhoven university of technology eindhoven the netherlands a.serebrenik j.j.vinju tue.nl abstract the behavior of software that uses the java reflection api is fundamentally hard to predict by analyzing code.
only recent static analysis approaches can resolve reflection under unsound yet pragmatic assumptions.
we survey what approaches exist and what their limitations are.
we then analyze how realworld java code uses the reflection api and how many java projects contain code challenging state of the art static analysis.
using a systematic literature review we collected and categorized all known methods of statically approximating reflective java code.
next to this we constructed a representative corpus of java systems and collected descriptive statistics of the usage of the reflection api.
we then applied an analysis on the abstract syntax trees of all source code to count code idioms which go beyond the limitation boundaries of static analysis approaches.
the resulting data answers the research questions.
the corpus the tool and the results are openly available.
we conclude that the need for unsound assumptions to resolve reflection is widely supported.
in our corpus reflection can not be ignored for of the projects.
common challenges for analysis tools such as non exceptional exceptions programmatic filtering meta objects semantics of collections and dynamic proxies widely occur in the corpus.
for java software engineers prioritizing on robustness we list tactics to obtain more easy to analyze reflection code and for static analysis tool builders we provide a list of opportunities to have significant impact on real java code.
keywords java reflection static analysis systematic literature review empirical study i. introduction static analysis techniques are applied to support the efficiency and quality of software engineering tasks.
be it for understanding validating or refactoring source code pragmatic static analysis tools exist to reduce error prone manual labor and to increase the comprehension of complex software artefacts.
static analysis of object oriented code is an exciting ongoing and challenging research area made especially challenging by dynamic language features a.k.a.
reflection .
the java reflection apiallows programmers to dynamically inspect and interact with otherwise static language concepts such as classes fields and methods e.g.
to dynamically instantiate objects set fields and invoke methods.
these dynamic language features are useful but their usage also wreaks havoc on the accuracy of static analysis results.
this is due to the undecidability of resolving dynamic names and dynamic types.
until the analysis of code which uses the reflection apiwas considered to be out of bounds for static analysis andhandled via user annotations or dynamic analysis handling reflection would inherently be either unsound due to unverified assumptions or highly inaccurate due to over approximation and render the contemporary static analysis tools impractical.
then in livshits et al.
published an analysis of how reflection was used in six large java projects proposing three unsound yet well motivated assumptions and using these to partially statically resolve the targets of dynamic method calls.
since then more tools were based on similar assumptions.
very recently in livshits and several other authors of static analysis tools published the soundiness manifesto .
it argues for soundy static analysis approaches that are mostly sound but pragmatically unsound around specific problematic language features.
java s reflection apiis one of the examples that can be handled more effectively after certain unsound assumptions are made.
for future work they identified the need for empirical evidence on how these language features are used such that tool builders can motivate the required unsound assumptions.
we provide more unbiased empirical evidence on the use of reflection by focussing on the following main research question what are limits of state of the art static analysis tools when confronted with the reflection api and how do these limits relate to real java code?
hence we investigate the following sub questions sq1.
how do static analysis approaches handle reflection which limitations exist and which assumptions are made?
section iii sq2.
how often are different parts see section ii of the reflection apiused in real java code?
section iv sq3.
how often does real java code challenge the limitations and assumptions identified by sq1?
section v together with answers to these questions this paper contributes a representative corpus of open source java projects and a comprehensive literature overview on the relation between static analysis and java reflection.
the main question is answered with a list of challenges and suggested tactics for static analysis researchers ordered by expected impact.
ii.
the java reflection api we first describe the java reflection api how its features can be categorized.
the resulting frame of reference is used for the interpretation of the findings in sections iii v because the different apifeatures interact differently with static analysis.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
metaobject class method constructor field member method constructor field classloader tm class .getclassloader lm classloader.getsystemclassloader lm new classloader classloader lm classloader .getparent class lc class.forname string lc class.forname string boolean classloader lc classloader .loadclass string lm type .class lm object .getclass tm class .get interfaces tm class .assubclass class tm metaobject .get class es ?
tm metaobject .get type p proxy.getproxyclass class method tm class .get declared ?methods tm class .get declared ?method string class tm class .getenclosingmethod constructor tm class .get declared ?constructors tm class .get declared ?constructor class tm class .getenclosingconstructor field tm class .get declared ?fields tm class .get declared ?field string void m field .set object object ar array.set object int object mm member .setaccessible boolean as classloader .
set ?
clear ?
assertionstatus boolean as classloader .set assertionstatus string boolean object c constructor .newinstance object c class .newinstance ar array.newinstance class int p proxy.newproxyinstance classloader class object i method .invoke object object a field .get object ar array.get object int dc class .cast object an method .getdefaultvalue tm class .getenumconstants p proxy.getinvocationhandler object an metaobject .getannotation class an metaobject .get annotations s class .getsigners protectiondomain s class .getprotectiondomain boolean sg class .isassignablefrom class sg class .isinstance class sg proxy.isproxyclass class sg metaobject .is class other signature checks sg metaobject .equals object sg metaobject metaobject sg metaobject !
metaobject sg member .isaccessible class as class .desiredassertionstatus an metaobject .isannotationpresent class string st metaobject .get name st metaobject .to string st class .getpackage returns a wrapper for strings int sg metaobject .getmodifiers resource url inputstream rs class .getresource string rs classloader .get resource string figure .
grammar of the java reflection api.a inside a terminal indicates zero or more other characters and inside a nonterminal it indicates zero or more of this nonterminal.
x ?
indicates an optional part of a terminal.
methodutil.getmethod was elided into the non deprecated replacement method.
the java reflection apiconsists of objects modeling the java type system.
these meta objects are split over classes java.lang.
class classloader and java.lang.reflection.
array constructor field member method proxy totaling public methods.
the meta objects mostly provide an immutable view of the running system s types.
figure summarizes the apias a context free grammar that defines construction of