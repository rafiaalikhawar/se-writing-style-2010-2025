the interactive verification debugger effective understanding of interactive proof attempts martin hentschel tu darmstadt darmstadt germany hentschel cs.tudarmstadt.dereiner h hnle tu darmstadt darmstadt germany universit degli studi di torino torino italy haehnle cs.tudarmstadt.derichard bubel tu darmstadt darmstadt germany bubel cs.tudarmstadt.de abstract the symbolic execution debugger sed is an extension of the eclipse debug platform for interactive symbolic execution.
like a traditional debugger the sed can be used to locate the origin of a defect and to increase program understanding.
however as it is based on symbolic execution all execution paths are explored simultaneously.
we demonstrateanextensionofthesedcalledinteractiveverification debugger ivd for inspection and understanding of formal verification attempts.
by a number of novel views the ivd allows to quickly comprehend interactive proof situations and to debug the reasons for a proof attempt that got stuck.
it is possible to perform interactive proofs completely from within the ivd.
it can be experimentally demonstrated that the ivd is more effective in understanding proof attempts than a conventional prover user interface.
a screencast explaining proof attempt inspection with the ivd is available at youtu.be 8e q9jf1h w. ccs concepts software and its engineering software verification formal software verification software testing and debugging keywords symbolic execution debugging program execution visualization verification proof understanding .
introduction one of the most time consuming and challenging steps in deductive semi automatic software verification is to understand why a proof attempt fails.
reasons for failure include of course buggy programs or specifications.
it is also possiblethattheautomateddeductioncomponentisnotpowerfulenough to find a proof.
in either case the user needs to develop sufficient understanding of the current proof situation to be able to fix the program specification or to perform adequate interactive proof steps.
to reason about programs requires to explore their full behavior.
one way to do so is to use symbolic execution .
deductive verification based on symbolic execution is for instance implemented in the verification systems key kiv and verifast .
our work is based on key which permits to verify correctness of java programs specified with the java modeling language jml .
symbolic execution is a general static analysis technique that can be also used to realize an interactive debugger with the usual functionality such as stepwise execution and the inspection of states.
in fact this had been suggested already in .
the big advantages of a debugger based on symbolic execution are i it can start a session at any program point without setting up an initial state and ii all feasible execution paths are explored simultaneously.
such a tool was realized in the form of the symbolic execution debugger1 sed .
it is an extension of the eclipse debug platform for symbolic execution into which any symbolic execution engine can be integrated.
by default the sed integrates key as its symbolic execution engine.
in this tool demo we present an extension and a new use case of the sed for the inspection understanding and completion of interactive proof attempts.
we call our sed extension interactive verification debugger ivd to distinguishitfromthepreviousversionsofthesed.thedebuggerlike inspection of proof attempts is particularly advantageous for novice users who lack background in formal verification.
it is realized by several new views that present the information contained in a proof attempt in a way that is familiar to software developers.
for instance the program behavior explored in a partial proof is visualized as a symbolic execution tree and hides all the logical reasoning steps.
in addition the truth status of the formulas that were evaluated in the underlying proof can be traced and visualized.
if desired the full key proof with all details can be inspected and continued interactively.
statistical evidence that the ivd indeed increases the effectiveness of proof attempt inspections is presented in .
we proceed with a demonstration of how to create and manage proofs in eclipse section followed by their in1 permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
spection2 section and interactive completion3 section with the ivd.
finally we discuss related work section and conclude section .
.
creating and managing proofs we use the ivd with key as the underlying theorem prover to inspect verification proofs of java code.
the recommended way to create and manage proofs is to allow eclipse to automatically maintain them for you.
this functionality is offered by the eclipse extension key resources4 .
each time when the source code under verification is modified key resources determines which proofs might be affected by the change and re verifies them.
this ensures that source code specifications and proofs are always in sync.
source code markers placed as closely as possible to the verified code element are used to present proof results to the user.
infigure1theactiveeditorinthecentershowsthesource code of method add.
its formal specification appears as structured comments expressed in jml and inlined into the code.
jml semantics stipulates that by default a method is called in a state where its parameters of reference type here a are not null.
the method contract ensures that i an array is returned ii whose length is greater by one compared to the given array iii the last element of the returned array is the new value and iv all other array values of the returned value are identical to the values of the original array at the same position.
in addition addwill not throw an exception normal behavior and not change any existing location assignable nothing .
however it is not forbidden to create objects and change locations on them.
a loop invariant required for verification is specified as well.
the warning marker at the method declaration indicates that the current proof attempt was not successful.
an eclipse quick fix called debug proof can be used to inspect the proof attempt with the ivd.
eclipse s java editor does not support jml out of the box.
jml specific syntax highlighting and editing facilities are provided by our eclipse extension jml editing.
the project icon in view package explorer indicates that the source code is part of a key project an extended java project provided by key resources where proofs are automatically maintained.
alternatively to key resources key itself can be used to create and perform proof attempts.
this is only manageable for small projects with very few proofs.
for large projects it is not recommended because it requires a lot of automizable user interaction and proofs affected by a change must be identified manually.
all this shows that the ivd fits nicely into the existing tool chain for verification with key.
.
inspecting proofs the ivd displays the full behavior of the program under verification explored by using symbolic execution during the 2a screencast explaining proof attempt inspection with the ivd is available at youtu.be 8e q9jf1h w. 3a screencast explaining interactive verification with the ivd is available at youtu.be iv denpclki.
proof attempt in the views debug as a tree structure and symbolic execution tree visualized see figure .
different icons highlight the function of each symbolic execution tree node.
details of the currently selected node are shown in view properties .
the views debug symbolic execution tree and the active editor are automatically synchronized.
in addition source codestatementsreachedduringsymbolicexecutionarehighlighted in the active editor.
this provides a compact summary of the source code that was symbolically executed in the current proof attempt.
a proof is successful if and only if each symbolic path ends with a termination node and no node in the symbolic execution tree is marked by an icon crossed out in red for not being verified .
in figure the proof attempt of addis inspected with the ivd.
an icon crossed out in red at the selected node indicates that the loop invariant does not hold initially.
the jml loop specification consists of three parts i the loop invariant must hold initially and has to be preserved in each loop iteration ii the decreasing clause also called variant a strictly positive numerical expression that must be decreased in each loop iteration and iii the assignable clause describing the locations that may be changed by the loop.
to identify which part of the loop specification is violated the truth status assigned to each expression in the current proof can be traced .
this is visualized in view properties tab loop invariant .
each open proof goal here only one is displayed as an implication with i the proof obligation to verify right side of the arrow and ii additional constraints under which the proof obligation is evaluated left side of the arrow .
formulas are colored according to their truth status in the proof.
here the prover evaluated the formula i a.length to false.
indeed the loop invariant does not hold in case the array is empty a typical oversight.
after correcting the loop invariant the proof figure is still not successful as indicated in the termination node at the end of add s execution.
tracing the truth status in view properties tab postcondition shows that two formulas are neither evaluated to true nor to false.
these are the universally quantified postcondition and the formula describing the assignable clause.6we can immediately exclude the latter because the implementation of addonly changes the result array which is allowed.
hence the postcondition must be the reason why the proof remains open.
view variables shows the symbolic state at the selected termination node.
view properties callout in figure shows additional constraints on symbolic values.
but the constraints say nothing about the array index i 0 which represents a generic loop iteration.
we conclude that the loop invariant is too weak to prove the postcondition.
as a solution the loop invariant could be strengthened with forall int j j j i result a .
.
completing proofs so far we used the ivd in auto active style by adjusting code or specifications to interact with the prover.
key s program logic java dl extends first order logic and is undecidable.
hence it is sometimes necessary to assist the 6at the moment the implication is displayed in java dl the program logic used by key.
the rendering of jml in java dl is easy to read with a little practice.
847figure a quick fix allows to debug a proof attempt maintained by key resources with the sed figure loop invariant is marked as not verified because it could be proven not to hold prover.
in key this is done by applying rules interactively before restarting the automated proof search strategy.
consider figure where the proof attempt of method searchis inspected with ivd.
the method implements a search of argument content in the given array a. the search starts at the index given as argument start.
if the contentis not found in a then is returned instead of the found index.
the precondition requires that startis a valid array index.
the postcondition expresses the functionality of search.
in addition the loop invariant i bounds the loop counter variable ito valid array indices and ii expresses that at previously visited indices the content was not found.
848figure termination node marked as not verified the loop invariant is too weak to prove postcondition body preserves invariant branch condition currently selected loop body termination node figure prover was not able to verify universally quantified loop invariant automatically the symbolic execution tree indicates that the loop invariant is not preserved on the body preserves invariant branch which represents an arbitrary loop iteration icon crossed out in red in loop body termination node .
truthstatus tracing in the properties view tells us that the universally quantified loop invariant was not completely evaluated it is uncolored .
the reason here is that the prover needs guidance to find the proof.
view proofin figure shows 849similar as in the legacy user interface of key the full proof tree bottom left including the implication corresponding to the currently selected proof node to its right .
rules are applied from that window in the same way as in key via the context popup menu of a selected subexpression.
the automated proof strategy had tried out already many rules which results in a complex proof goal.
instead of inspecting that complex implication we choose to prune the proof tree.
the context menu item prune proof cuts off right after the node where symbolic execution ends and the failed proof attempt of the loop invariant begins.
next we apply the proof macro full auto pilot which splits each part of the proof obligation to verify into a separate branch.
in addition branches that cannot be closed automatically are cut back to their initial state.
these are best practices in key to understand a failed proof attempt.
the implication to prove after a few simplification steps is shown in figure .
with some practice an opportunity to create a contradiction on the left side of the arrow can be spotted.
the two formulas involved in it are highlighted in figure on top and inside the callout.
the contradiction is easilyprovableonceweinstantiatetheuniversallyquantified formula in the callout with j 2by applying rule alllefthide .
it instantiates a universally quantified formula and hides it thus making work for the prover easier.
we restart the automated proof search by executing macro close provable goals below .
it has the advantage that in case the proof could not be found automatically the proof tree is cut back to its original state.
but here the prover was successful.
now we take again advantage of ivd s views.
one branch isstillmarkedasnotverified.
themarkeratthetermination node tells that the postcondition could not be automatically proven notshown .
thesamecontradictionasbeforeisalso present in this branch and it can be made explicit by guiding the prover in the same manner as before.
however before running the close provable goals below macro we have to set the arithmetic treatment in the view symbolic execution settingstomodel search .
this tells the proof search strategy to systematically search for a model.
finally the proof is closed and we can save it via the toolbar of view proof.
key resources will then detect the change and update the result marker accordingly.
.
related work the ivd is based on the sed which is intended to inspect visualize and debug programs however the sed completely lacks the capability to inspect and understand interactive verification proofs as described in this tool demo.
the boogie verification debugger and the symbolic debugger part of the verifast ide can inspect the states on a symbolic path that could not be verified.
like the ivd these tools present the memory and assumptions of each selected state to the user.
ivd permits to inspect all symbolic execution paths explored by a proof at once.
in addition truth status tracing is available to narrow down the unverified parts of a proof goal.
in contrast to boogie and verifast which run in batch mode key interleaves automated theorem proving with user interaction which is supported as part of ivd.
other verification tools based on symbolic execution e.g.
kiv verifast could profit from an sed integration similar to the ivd.
.
conclusion we demonstrated a new use case for debuggers based on symbolic execution the inspection and understanding of general interactive proof attempts.
the ivd tool is implemented on top of the sed and tightly integrates with eclipse and the infrastructure needed for verification.
the ivd presents a proof attempt using different views which makes it a powerful assistant for proof understanding tasks.
its usage and best practices are presented in tutorial style by way of two non trivial fully executable java examples.
whenverificationtargetsaresimpleenoughfortheprover to run in auto active style the ivd hides the logical reasoning completely .
this is particularly suited for novice users with little experience with logic and automated proof search.
it makes the learning curve for using interactive verification systems considerably less steep.
this increased effectivity of the ivd compared with a conventional user interface can be experimentally proven .
completely auto active proofs are however not always possible.
sometimes an interactive prover needs guidance to finish a proof.
this is supported as well in the ivd by a view that offers nearly the same functionality as the original user interface of the underlying key prover.
we stress that the sed is a platform for debuggers based on symbolic execution into which in principle any symbolic execution engine can be integrated.
a consistent tool chain andtheabilitytopresentresultsofastaticanalysisbasedon symbolic execution in a user friendly way that is familiar to developers is of fundamental importance for usability.
we encourage system builders to profit from the sed and to integrate their tools similar to the ivd.
.