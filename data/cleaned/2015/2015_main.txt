hal id hal submitted on mar hal is a multi disciplinary open access archive for the deposit and dissemination of scientific research documents whether they are published or not.
the documents may come from teaching and research institutions in f rance or abroad or from public or private research centers.l archive ouverte pluridisciplinaire hal est destin e au d p t et la diffusion de documents scientifiques de niveau recherche publi s ou non manant des tablissements d enseignement et de recherche fran ais ou trangers des laboratoires publics ou priv s. crash reproduction via t est case mutation let existing t est cases help jifeng xuan xiaoyuan xie martin monperrus t o cite this version jifeng xuan xiaoyuan xie martin monperrus.
crash reproduction via t est case mutation let existing t est cases help.
esec fse 10th joint meeting on f oundations of software engineering nier t rack aug bergamo italy .
pp.
.
.
.
hal crash reproduction via test case mutation let existing test cases help jifeng xuany xiaoyuan xiey martin monperrus ystate key lab of software engineering school of computer wuhan university china university of lille inria france jxuan xxie whu.edu.cn martin.monperrus univ lille1.fr abstract developers reproduce crashes to understand root causes during software debugging.
to reduce the manual e ort by developers automatic methods of crash reproduction generate new test cases for triggering crashes.
however due to the complex program structures it is challenging to generate a test case to cover a speci c program path.
in this paper we propose an approach to automatic crash reproduction via test case mutation which updates existing test cases to trigger crashes rather than creating new test cases from scratch.
this approach leverages major structures and objects in existing test cases and increases the chance of executing the speci c path.
our preliminary result on crashes in apache commons collections shows that crashes are reproduced by our approach of test case mutation.
categories and subject descriptors d. .
testing and debugging debugging aids keywords crash reproduction test case mutation stack trace .
introduction reproducing a crash is inevitable to software debugging.
once software goes wrong crash information usually stack traces is recorded to assist future reproducing the crash scenario.
for instance in java programs a crash mainly contains a stack trace of runtime exceptions and crashed positions in source les.
in practice crash reproduction is manually conducted via designing a test case to trigger the crash by developers.
based on such reproduction developers can further understand the root cause of crashes and x the bug behind crashes.
automatic methods of crash reproduction are proposed to reduce the manual e ort by developers such as recore by r o ler et al.
bugredux by jin orso and star bychen kim .
these methods generate new test cases to execute the program paths which can trigger the target crash.
the criterion of a successfully reproduced crash is that a test case can produce the same stack trace as in the target crash.
in this paper we propose an approach to automatic crash reproduction via test case mutation called mucrash which updates existing test cases to trigger crashes rather than creating new test cases from scratch.
our approach leverages major structures and objects in existing test cases and increases the chance of executing a speci c path that reproduces the crash.
the idea of test case mutation is motivated by program mutation which is used to identify the strength of test cases in mutation testing .
note that test case mutation in our work aims to update an existing test case and to generate its mutants while mutation testing aims to update the program under test to examine whether test cases can catch the updates.
to reproduce a crash our approach mucrash takes the stack trace in the crash the source code and existing test cases as input the output is a set of test cases after mutation that can reproduce the crash.
an existing test case denotes a unit test case which is released together with the program under test and is not able to trigger the crash.
the process ofmucrash consists of three major steps.
first given a stack trace mucrash executes all the existing test cases on the program and selects test cases that cover the classes in the stack trace.
second mucrash eliminates program assertions in these selected test cases and maintains the program behavior inside assertions.
third given a set of pre de ned mutation operators e.g.
an operator of setting one variable in a method call to null or adding a target method call each selected test case produces a set of test case mutants.
these resulting test cases are executed on the program and the ones that can reproduce crashes are extracted and sent to developers for manually verifying.
our preliminary result on crashes in apache commons collections shows that crashes are reproduced by our approach of test case mutation.
one reproduced crash of acc331 by mucrash is the rst time of successful reproduction by automatic methods.
this crash was not reproduced by the state of the art method star .
this paper makes the following contributions.
.test case mutation .
this method generates new test cases by updating existing test cases and keeps objectoriented features in test cases.
.mucrash an approach to crash reproduction with existing test cases .
this approach employs test casemutations as a lightweight technique to reproduce crashes by exploring potential execution paths compared with symbolic execution techniques in bugredux and star.
.
motivation and new idea we use a real world bug in apache commons collections to illustrate the motivation and the new idea of our work.
apache commons collections is a widely used java library of enhanced usage of collections such as lists maps or sets.
bug report of collections acc for short describes a null pointer exception in a class collatingiteratorin version .
or before.
according to the document a feature of collatingiterator is to accept a null comparator as input and to load a default comparator to perform the comparison between two ordered list note that this feature is discarded in its subsequent version since .
due to complexity .
figure shows code snippets and related test cases which are written by developers and generated by our technique of test case mutation.
as shown in figure 1a the buggy source code did not call a default comparator when a user inputs a null comparator.
the bug will trigger a crash shown in figure 1b.
this crash records the stack trace of calling methods in class collatingiterator .
however it is hard to reproduce the scenario where the program crashes.
during the process of debugging a developer wrote a test case testnullcomparator to trigger the crash in figure 1c triggered at line .
this test case will help developers to understand the root cause behind the crash.
writing a test case in figure 1c is not easy.
on one hand a human developer needs to fully understand the functionality of the constructor of collatingiterator line and to initialize two lists lines for calling the method next line .
on the other hand an automatic method of test case generation must handle a constructor with three variables line especially with two variables of complex iterators meanwhile automatically creating a method call sequence like hasnext and next lines is also challenging.
in the state of the art method star the authors claim that they fail to reproduce the crash of acc .
our new idea of crash reproduction is to leverage existing test cases instead of creating new test cases from scratch.
as shown in figure 1d in the test suite which is released together with the buggy source code a unit test case testiterateevenodd is provided to test the general functionality of collatingiterator .
in this test case two lists evens and odds are already provided.
once we change thecomparator at line into null a resulting test case will trigger the target crash.
this resulting test case is shown in figure 1e.
without changing the lists of evens and odds code at line in figure 1e will lead to the target stack trace in figure 1b.
note that due to the change at lines original assertions may be incorrect and are replaced by lines and .
the change from line in figure 1d to line in figure 1e is to set one variable in the method call to null.
in this paper such a change in a test case is called test case mutation which is motivated by the concept of mutation operators for programs in mutation testing.
section .
.
will present more useful mutation operators for test cases.
1bug report of acc collections its manually written test case by developers for reproducing the crash attachment collatingiteratortest.java .private int least f object curobject values.get i if comparator.compare curobject leastobject f comparator comp comparator null ?
comparablecomparator.getinstance comparator if comp.compare curobject leastobject f leastobject curobject ... a buggy code snippet with its patch in the program java.lang.nullpointerexception .iterators.collatingiterator.least collatingiterator.java .iterators.collatingiterator.next collatingiterator.java ... b stack trace during software crashing 1public void testnullcomparator f list integer l1 arrays.aslist list integer l2 arrays.aslist collatingiterator collatingiterator new collatingiterator null l1.iterator l2.iterator 6for inti collatingiterator.hasnext i integer n integer collatingiterator.next ... 9g c manually written test case by developers for reproduction 1private arraylist evens null 2private arraylist odds null 3public void setup throws exceptionf initialize evens and odds with elements before each test case 5g 6public void testiterateevenodd f existing unit test case collatingiterator iter new collatingiterator comparator evens.iterator odds.iterator 9for inti i i f asserttrue iter.hasnext assertequals new integer i iter.next 12g asserttrue !
iter.hasnext 14g d existing unit test case that is released with the buggy program 1public void testiterateevenodd mutation f collatingiterator iter new collatingiterator null evens.iterator odds.iterator 4for inti i i f object obj1 iter.hasnext object obj2 iter.next 7g object obj3 !
iter.hasnext 9g e test case that is generated via test case mutation by setting one variable to null figure real world example of bug acc in class collatingiterator .
to reproduce the crash in figure 1b developers write a test case in figure 1c our method of test case mutation generates a test case in figure 1e based on an existing test case in figure 1d.
di erences between the existing test case in green and the mutated test case in red are marked with boxes.
.
approach test case mutation we present our approach to automatic crash reproduction via test case mutation mucrash .
the goal of our approach is to trigger a speci c execution path by updating existing test cases.
the technique of test case mutation bridges existing test cases and target test cases which are expected to reproduce crashes.bug report program code existing test cases crash stack trace test case mutation test case mutation operatorsexisting test case selection assertion elimination test case updatingtest case that reproduces a crashtogether released in the software version that has the crashfigure overview of crash reproduction via test case mutation mucrash .
.
overview figure illustrates the overview of our proposed approach to crash reproduction via test case mutation.
as an input crash information in a bug report is usually expressed as stack traces which record runtime exceptions and crashed positions in source code les the other inputs are program source code as well as its related unit test cases that are not able to trigger the target crash.
in modern software development unit test cases are released together with source code to validate the software con guration.
our proposed approach consists of three major steps existing test case selection assertion elimination and test case updating.
after applying a set of pre de ned mutation operators an existing test case will be updated to a set of new test cases each of which may provide di erent stack traces from the trace by the existing test case.
these new test cases are executed on the buggy program test cases that are successful in crash reproduction are extracted as output.
.
test case mutation .
.
existing test case selection our approach updates existing test cases to reproduce crashes.
to reduce the number of considered existing test cases we select a subset of existing test cases for subsequent steps.
given a stack trace we extract classes in the trace e.g.
class collatingiterator in figure 1b.
then all existing test cases are executed test cases that cover the classes in the trace are selected.
such selection discards irrelevant test cases and narrows down the range of potential existing test cases.
we conduct this selection under an assumption that the selected test cases may relate to methods in the crash since these test cases have contributed to the testing ofclasses in the stack trace.
.
.
assertion elimination in a test case developers write assertions to ensure that software meets the expected behavior.
for instance code at line in figure 1d ensures iter.next equals to i. in our approach the goal of test case mutation is to modify existing test cases to trigger new traces.
once a statement in a test case is changed assertions are no longer applicable.
to remove the judgment of assertions we conduct assertion elimination for all assertions in the selected test cases.
assertion elimination keeps the behavior of variables inside an assertion and removes the statement of assertions.
for in table test case mutation operators in our approach index mutation operator operator description 1variable null set a variable in a method call to null 2variable renewing set a variable in a method call to a newly created object 3numeric variable replacementreplace a numeric variable with default values e.g.
or and with existing values in the same test case 4method call addition add a call of a method that appears in the stack trace 5overloading method call additionadd a call of an overloading method that appears in the stack trace stance assertequals new integer i iter.next at line in figure 1d is changed into object obj2 iter.next as shown at line in figure 1e.
such changes in assertion elimination will not add or reduce the program behavior to test cases except the judgment by assertions.
the kept program behavior can facilitate the crash reproduction.
for instance the crash in figure 1e is triggered at line .
.
.
test case updating intest case updating we modify selected test cases after assertion elimination to produce new traces.
we leverage the concept of mutation operators for programs from mutation testing.
a mutation operator is a pre de ned transformation rule that generates new program from an original program .
in this paper we use test case mutation operators to update test cases.
to facilitate crash reproduction we focus on mutation operators with object oriented features.
table lists ve types of test case mutation operators in our work.
the rst three mutation operators are related to update a variable in a method call while the other two are related to adding a method call that exists in the stack trace.
in contrast to general operators in mutation testing test case mutation operators in our work could be guided by the stack trace.
for instance adding one method call in the trace to an existing test case i.e.
operator in table may increase the opportunity of successful reproduction.
in this work we exhaustively apply all the mutation operators without any selection.
note that applying one mutation operator to one test case will lead to more than one new test cases.
for example applying the rst operator variable null to code at line in figure 1d will lead to three test cases with a null variable in a method call.
.
novelty of proposed approach in test case generation to our knowledge this is the rst work of mutating test cases in a style of program mutation .
previous work has explored generating new test cases from existing ones.
the most related work is test case regeneration by yoo harman and test suite augmentation by xu et al.
.
however their work treats existing test cases as seeds of new test case generation while our work of test case mutation directly updates existing test cases with mutation operators.
another related work is data mutation in modeling languages by shan zhu .
their work updates model diagrams to test a modeling tool while our work directly manipulates test cases for crash reproduction.
in summary test case mutation reuses object oriented features inside existing test cases to avoid the complexity of creating new ones from scratch.table bug ids of reproduced crashes among bugs method bug ids of reproduced crashesuseless reproduction reproduced crash useful reproduction star mucrash the most related work by authors is test case puri cation for fault localization .
both the technique and the goal are di erent from those in test case mutation previous work splits failing test cases into small parts to improve the e ectiveness of fault localization.
.
preliminary result .
dataset and implementation in the state of the art method of crash reproduction star bug reports from three open source java projects are used for evaluation.2in our preliminary experiment we use all the bugs from one of their projects apache commons collections.
collections contains kloc of source code and kloc of test code the latest version under evaluation .
our prototype of mucrash is implemented on the top of spoon.
spoon is a static library for java program analysis and transformation.
.
result of reproducing crashes table shows a preliminary result of crashes of bug reports in collections.
we compare the proposed mucrash with the state of the art method star .
as de ned in areproduced crash denotes that the generated test case triggers the same stack trace while a useful reproduction means that the crash reproduction is helpful to x the bug.
we manually check whether a reproduced crash is useful or not.
as shown in table mucrash reproduces out of crashes while star reproduces out of crashes.
mucrash is able to reproduce acc while mucrash fails to reproduce acc and acc .
the major reason for this failure is that test cases for both crashes require frequent method calls which cannot be directly performed by mutation operators.
based on our manual check all reproduced crashes by mucrash are useful to x the bug while as reported by chen kim the reproduction of acc by star is useless.
hence both mucrash and star can reproduce useful ones among crashes.
the reproduced crash acc see figure for details by mucrash shows the strength of test case mutation in crash reproduction.
comparing with techniques of symbolic execution and precondition analysis in star test case mutation in mucrash is lightweight it will add no runtime overhead of computing resources except executing test cases meanwhile test case mutation maintains objectoriented features in existing test cases which are updated to trigger new crashes.
to further understand the role of test case mutation in crash reproduction table shows which mutation operator works for the reproduced crashes.
among seven reproduced crashes by mucrash test cases in four crashes are mutated by updating variables while test cases in the other three crashes are mutated by adding method calls from stack traces.
acc the newly reproduced crash by mucrash 2star project .table mutation operators that reproduce crashes bug id buggy version mutation operator see table acc collections .
variable null acc collections .
variable null or2 variable renewing acc collections .
method call addition acc collections .
method call addition acc collections .
overloading method call addition acc collections .
variable null acc commit r numeric variable replacement is based on a simple mutation operator i.e.
to set a variable tonull.
.
discussion crash reproduction via test case mutation relies on the quality of existing test cases.
the ability of reproducing crashes will be limited if the existing test cases are not welldesigned for the software under test.
we intend to mainly apply our method to projects with high quality test suites such as apache commons in this paper.
in our method we exhaustively update test cases with all mutation operators no selection of mutation operators is employed.
this may lead to a large number of unnecessary test cases which are helpless to crash reproduction.
a potential solution to reduce the helpless ones is to prioritize mutation operators for successful reproduction.
.
conclusions this paper proposes a new approach to crash reproduction via test case mutation.
this approach updates existing test cases to form new test cases for triggering crashes.
in our preliminary study out of crashes are reproduced and useful to bug xing this result achieves the same number of useful crashes by the state of the art method star.
moreover one crash acc is newly reproduced which was reported non reproduced previously.
remained research questions .
we plan to further understand the ability of test case mutation via an empirical study of more crashes.
this study will explore the di erent power of test case mutation and symbolic execution based test case generation.
we plan to investigate the prioritization of applying mutation operators for crash reproduction.
.