rclassify classifying race conditions in web applications via deterministic replay lu zhang virginia tech blacksburg v a usachao wang university of southern california los angeles ca usa abstract race conditions are common in web applications but are difficult to diagnose and repair.
although there exist tools for detecting races in web applications they all report a large number of false positives.
that is the races they report are either bogus meaning they can never occur in practice or benign meaning they do not lead to erroneous behaviors.
since manually diagnosing them is tedious and error prone reporting these race warnings to developers would be counter productive.
we propose a platform agnostic deterministic replay based method for identifying not only the real but also the truly harmful race conditions.
it relies on executing each pair of racing events in two different orders and assessing their impact on the program state we say a race is harmful only if both of the two executions are feasible and they lead to different program states.
we have evaluated our evidence based classification method on a large set of real websites from fortune companies and demonstrated that it significantly outperforms all state of the art techniques.
i. i ntroduction modern web applications are complex due to their need to implement many features on the client side through asynchronous programming and the use of javascript code while maintaining quick response to users.
although web browsers typically guarantee that each java script code block is executed atomically meaning there is no data race in the traditional sense high level race conditions can still occur due to deferred html parsing interleaved execution of event handlers timers ajax requests and their callbacks.
existing race detection tools for web applications often report many false positives.
that is warnings reported by these tools may be bogus o r real but harmless .
for example e vent racer reported hundreds of warnings from the official websites of fortune500 companies although some of these race conditions are indeed harmful the vast maj ority are not which means directly reporting them to developers would have been counterproductive.
none of the existing tools including r4 can accurately assess the impact of racing events and robustly identify the real and truly harmful race conditions.
we propose rc lassify t h efi r s t evidence based method for classifying race condition w arnings in web applications.
toward this end we develop a platform agnostic deterministic replay framework for client side javascript programs and leverage it to assess the actual impact of race conditions.
given a race condition warning denoted eva ev b w h e r eeva andevbare the racing events we first execute the application while forcing evato occur before evb and then execute the application while forcing evbto occur before eva.w es a y that eva ev b is a harmful race only if both executions are feasible and the resulting program states ps1and instrumented web application compare the program states execution url of web application race condition warnings static analysis of html files replay the racing event pair execution 2harmful or harmless fig.
.
rc lassify o u r evidence based race condition classification method.
ps2 differ in some important fields of the html dom javascript variables and environment variables of the browser.
the intuition is that when the order of evaandevbis not fully controlled by the program logic and yet affects the program behavior it deserves a closer look by developers.
the overall flow of rc lassify i ss h o w ni nf i g .
w h o s e input is the url of the web application and a set of racecondition warnings and whose output is the set of harmful races.
first it statically an alyzes the html files and then uses source code transformation to add self monitoring and control capabilities.
then it analyzes the race condition warnings reported by the race detection tool and generates the configuration files needed for deterministic replay.
next for each pair eva ev b of racing events it executes the application twice once with evapreceding evband the other time with evbpreceding eva.
finally it compares the two resulting program states ps1andps2.
there are two technical challenges.
the first challenge is developing a robust method to deterministically replay a javascript based client side web application.
this is difficult due to the myriad possible sources of nondeterminism.
for example the race condition may occur during the deferred parsing of html elements the interleaved execution of javascript the dispatch of multiple event handlers the firing of timer events the execution of asynchronous http requests as well as their callback routines.
in this context our main contribution is developing a unified framework for controlling the execution order of the various types of racing events.
our replay framework differs from the mechanisms used by existing race detection tools such as e vent racer wav e and r4 because it is implemente d within the target web application itself and therefore is platform agnostic.
that is we do not modify the web browsers or their underlying javascript execution engines e.g.
w ebkit .
instead we leverage sourcecode transformation to add self monitoring and control capa2017 ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
bilities to the application itself see section v .
this is better than existing approaches because technologies are changing rapidly and tools implemented using a particular version of the browser will quickly become obsolete.
in contrast our platform agnostic approach will be more robust against these changes and updates.
since we concretely execute the application using deterministic replay as opposed to heuristically filtering the warnings or applying conservative static analysis we can robustly decide if a race condition is real i.e.
if both execution orders are feasib le .
the reason why existing tools report many bogus race conditions in the first place is because some hidden happens bef ore relations between events are not accounted for and precisely capturing all happensbefore relations would have been prohibitively expensive.
the second challenge is to decide during state recording and comparison which fields of the program state are important and thus should be compared.
for a typical client side web application the number of fields can be extremely large which means including all of them would result in large overhead at run time.
furthermore many fields are actually designed to be sensitive to other sources of nondeterminism that are irrelevant to the race condition.
for example there are fields that need to have different values depending on the date or time of the day.
in such cases we should exclude them in order to avoid the false positives.
therefore our main contribution in this context is developing a flexible configuration interface to allow users to specify which fields should be excluded.
we also propose a testingbased method see section vi to automatically identify and exclude these irrelevant fields.
we implemented and evaluated rc lassify on standard benchmarks and real websites from fortune companies.
our experiments show that rc lassify outperforms all other existing tools capable of handling the same benchmarks including e vent racer mutlu et al.
and r4 .
for example rc lassify identified all known to beharmful races out of the warnings in standard benchmarks whereas r4 identified only of them and mutlu et al.
did not identify any.
furthermore on the seventy randomly chosen websites from the portals of fortunate companies event racer returned warnings among which rclassify identified as bogus as harmful as harmless and as undecided.
we manually reviewed the harmful races and confirmed the correctness of our classification in contrast r4 identified only of the harmful races indicating that it is significantly less effective.
to sum up this paper makes the following contributions we propose an evidence based method for classifying race condition warnings in web applications by concretely executing the appli cation to assess the actual impact of racing events.
we develop a platform agnostic deterministic replay framework for javascript based web applications which does not rely on modifying browsers or javascript engines and thus is more widely applicable.
we evaluate the new method on standard benchmarks as well as a large number of real websites to demonstrate its effectiveness in identifying the harmful race conditions.
html head ... head body img src image1.jpg onload image1loaded id image1 !
omitted elements... script id script1 function image1loaded document.getelementbyid button1 .addeventlistener click func function func document.getelementbyid outputfield .innerhtml well done!
script !
omitted elements... button id button1 button1 button !
omitted elements... div id outputfield div body html fig.
.
example a client side web application with race conditions.
ii.
m otiv ation in this section we use examples to illustrate the ideas behind our new method while highlighting the technical challenges.
a. race conditions consider the web page in fig.
which contains an image a button and a javascript code block.
the image.onload event fired after the browser downloads image1 i n v o k e st h e image1loaded function which in turn attaches a listener function to the onclick event of button1 .
the button may be clicked by the user immediately after it is parsed and its listener function func changes text in outputfield to well done!
thus the expected event sequence is ev0 parsing image1 ev1 parsing script1 ev2 parsing button1 ev3 firing image1 .onload ev4 parsing outputfield ev5 firing button1 .onclick .
however depending on the network speed load of the computer and timing of the user click there may be other execution sequences some of which do not lead to the expected display of well done!
.
as shown in the partial order of events in fig.
there are four race conditions rc1 is ev1 ev over image1loaded a event ev1 parsing script1 b event ev3 firing image1 .onload rc2 is ev2 ev over button1 a event ev2 parsing button1 b event ev3 firing image1 .onload rc3 is ev3 ev over button1 a event ev3 firing image1 .onload b event ev5 firing button1 .onclick rc4 is ev4 ev over outputfield a event ev4 parsing outputfield b event ev5 firing button1 .onclick the first race condition rc1 is between the parsing of html element script1 a n dt h efi r i n go f image1 .onload .
typically the parsing finishes first but if image1 is downloaded before the parsing finishes e.g.
due to caching of the image or slow parsing of other html elements preceding script1 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g104 g400 g286 g396 g17 g396 g381 g449 g400 g286 g396 g87 g258 g396 g400 g286 g282 g855 g3 g349 g373 g258 g336 g286 g1005 g3 g87 g258 g396 g400 g286 g282 g855 g3 g400 g272 g396 g349 g393 g410 g1005 g3 g87 g258 g396 g400 g286 g282 g855 g3 g271 g437 g410 g410 g381 g374 g1005 g3 g87 g258 g396 g400 g286 g282 g855 g3 g381 g437 g410 g393 g437 g410 g38 g349 g286 g367 g282 g69 g286 g410 g449 g381 g396 g364 g24 g381 g449 g374 g367 g381 g258 g282 g855 g3 g349 g373 g258 g336 g286 g1005 g856 g361 g393 g336 g3 g38 g349 g374 g349 g400 g346 g286 g282 g855 g3 g349 g373 g258 g336 g286 g1005 g856 g361 g393 g336 g3 g349 g373 g258 g336 g286 g1005 g856 g381 g374 g367 g381 g258 g282 g17 g437 g410 g410 g381 g374 g1005 g3 g396 g286 g258 g282 g455 g3 g410 g381 g3 g272 g367 g349 g272 g364 g3 g104 g400 g286 g396 g3 g272 g367 g349 g272 g364 g286 g282 g3 g271 g437 g410 g410 g381 g374 g1005 g271 g437 g410 g410 g381 g374 g1005 g856 g381 g374 g272 g367 g349 g272 g364 g286 g1004 g286 g1005 g286 g1006 g286 g1007 g286 g1008 g286 g1009 fig.
.
partial order graph of the racing events of the example in fig.
.
image1loaded will be undefined when the browser invokes it through image1 .onload .
the second race condition rc2 is between the parsing of button1 and the firing of image1 .onload .
here we assume the unwanted situation regarding rc1 did not occur ev1 precedes ev3and image1loaded is properly defined .
in this case it is still possible for image1 .onload to happen before the parsing of button1 thereby causing document.getelementbyid button1 at line to fail.
the third race condition rc3 is between image1 .onload and button1 .onclick .
here we again assume the unwanted situations regarding rc1 and rc2 did not occur ev1andev2 precedeev3 .
however it is possible for button1 to be clicked before the firing of image1 .onload .s i n c e func has not yet been attached to button1 .onclick clicking the button will not lead to the desired behavior.
the fourth race condition rc4 is between the parsing of html element outputfield a n dt h efi r i n go f button1 .onclick .
here we again assume that none of the unwanted situations regarding rc1 rc2 and rc3 occurred.
however it is possible for button1 to be clicked and yet the well done!
message is not displayed.
this occurs when the button is clicked before the parsing of outputfield causing document.getelementbyid outputfield at line to fail.
the example in fig.
and fig.
shows that race conditions in web applications are tricky developers may have to spend long hours weeding out the bogus warnings if the race detection tools report too many false positives to them.
our work aims to lift this burden from developers thus allowing them to focus on diagnosing the truly harmful race conditions.
b. harmful race conditions we leverage deterministic replay and state comparison to identify harmful races.
let eva ev b be a potential race condition e.g.
reported by e vent racer .
we perform controlled executions of the application twice first with evabeforeevb and then with evaafterevb.
if any of these executions is infeasible the replay fails indicating that it is a bogus warning.
otherwise we record the program states at the end of the two executions and compare them.
consider rc1 in fig.
.
first we execute the application while forcing ev1beforeev3 which leads to the expected event sequence.
then we execute the application while forcing ev3 input id input 1 type text value name onfocus cleartext this input id input 2 type text value email onfocus cleartext this script id script2 src nyl min.js ... script script id script1 !
adding async script utag.js to dom script ... !
nyl min.js 9function cleartext a if a.defaultvalue a.value a.value ... !
utag.js 13function c if !done done true ... 15document.addeventlistener domcontentloaded c false 16window.addeventlistener load c false fig.
.
race conditions that we detected from .
beforeev1.
both executions are feasible and the second execution invokes image1loaded before it is defined causing the browser to print an error message in the console window.
the event handler for button1 .onclick also remains uninitialized subsequently causing a difference in outputfield .
therefore we say that rc1 is a harmful race meaning that it deserves the attention of the developers.
however not all real race conditions are harmful.
among the three race conditions in fig.
which were detected by rc lassify from t h e one between parsing of utag.js and firing of document.ondomcontentloaded is harmless while the two races over input 1 and input 2 are harmful.
the first race is harmless because although the event handler of document.ondomcontentloaded may be registered by utag.js after the browser fires the document.ondomcontentloaded event the same callback function c is also registered to window.onload as a precaution.
since window.onload always execute after the load of utag.js it ensures that c is executed thereby resulting in the same program state.
however the two races over input 1 and input 2 are harmful because they initially show the hint values name and email to the user but their onfocus event handlers which call cleartext will empty these hint values as soon as the user tries to type into the text areas.
unfortunately the script that defines cleartext m a yb ep a r s e da f t e rt h eu s e r typed something into the two fields assume usertyped is what the user typed.
this can lead to unwanted text contents such as namusertypede or nameusertyped instead of just usertyped .o u r evidence based method can correctly identify these two races as harmful since they led to significant differences in the program states.
in contrast e vent racer reported all three races to the user whereas mutlu et al.
could not detect any of them.
iii.
p reliminaries a. web applications a modern html page consists of a set of elements each with opening closing tags and the content in between e.g.
p ... p for a paragraph.
in addition elements may be added dynamically by executing javascript code.
the document object model dom is a tree representation of the web page to be rendered by the browser.
each dom node has authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
attributes for holding meta data e.g.
the img element has thesrcattribute indicating the url of the image.
javascript may be embedded in the html file or declared externally e.g.
script src code.js script by default they are synchronous and therefore must be parsed before the browser can move to the next html element.
however external scripts with the defer attribute will run after all static html elements are parse d whereas async scripts may run at any time after they are downloaded.
web applications follow an event driven execution model where various handlers are registered to events of dom nodes to react to the user and the environment.
an event may be propagated through the dom tree through capturing and bubbling .
for example if a button is clicked the onclick event will be fired not only for this button but also for dom nodes that recursively contain this button.
the propagation is performed level by level all the way up to the window object.
any onclick event handler registered to dom nodes along this chain of propagation will also be fired.
the execution trace of a web application is a sequence of events denoted ev1 ... ev n. each event is of the form ev angbracketleftid type info mem angbracketright w h e r eidis the element id type is the event type info stores additional information of the dom node and mem stores information of shared memory access.
we consider five event types parse element which represents the parsing of an element.
static elem ents are parsed sequentially following the order in which they are declared in the html.
execute js which represents the e xecution of an embedded deferred or asynchronous javascript code block.
fire ev cb which represents the execution of a callback function ev cbin response of an event such as the onclick event of a button.
fire tm cb which represents the execution of a callback function tm cbin response of a timer registered using either setinterval orsettimeout .
fire ajax cb which represents the execution of a callback function ajax cbin response to an ajax request.
letps be the set of program states.
each state ps angbracketleftdom js env console angbracketrightis a memory snapshot where dom is the dom content jsis a valuation of javascript variables env is a valuation of the browser s environment variables and console denotes console messages.
an execution is a sequence ps0ev1 ps1ev2 ps2...evn psn whereps1 ... ps n ps are program states ev1 ... ev n are events and for each i n w eh a v e psi 1evi psi.
b. race conditions since the web browser ensures that each javascript based event handler function is execute d atomically it is impossible for individual javascript statements to interleave.
thus web applications do not have data races in the traditional sense unlike multithreaded java or c programs .
however there are still race conditions at higher levels.
for example a web application may consider fast rendering of visual elements as a priority while asynchronously loading images and javascript libraries.
in such cases event handlers of the visual elements may be made available to users long before the corresponding javascript functions are defined.before formally defining race conditions we define the must happens before relation mhb which is a binary relation over events.
we say eva ev b mhb if and only if eva precedes evbin all possible executions of the web application.
ifevaprecedes evbonly in a particular execution we say eva evbin this execution.
let wr ev be the set of memory locations written by ev a n d rd ev be the set of memory locations read by ev.
a race condition is defined as a pair eva ev b of events such that eva ev b negationslash mhb evb ev a negationslash mhb a n d var such that var wr eva wr evb orvar wr eva rd evb orvar rd eva wr evb .
however eva ev b may not be considered harmful if it does not affect the program behavior .
thus we say a race condition is harmful only if there exist two executions 1and 2such that eva evbin 1 evb evain 2 a n d the two resulting program states ps1andps2are different.
iv .
t healgorithm of rclassify rclassify takes the url of the web application and a set of race condition warnings as input and returns the classification results as output .
it first removes the bogus races where at least one of the two executions is shown to be infeasible.
next it removes the real but harmless races where the two executions do not result in differences in the program states.
in both steps we need to deterministically replay the web application.
toward this end we first download the application following the url and then instrument the html files to add selflogging capabilitie s. we want to record information of the racing events during race detection so we can identify and control these events during deterministic replay.
in this work we used e vent racer to generate race condition warnings input of rc lassify although other race detection tools m a yb eu s e da sw e l l .
next we classify these warnings using replay and state comparison.
for each pair eva ev b of racing events we first executeevabeforeevb denote 1 and then execute evbbefore eva denoted 2 .
in both executions we fix the order of other events as much as possible.
if both executions are feasible we call eva ev b a real race condition and record the global states at the end.
let ps1and ps2be the two states resulting from 1and 2 respectively.
we say eva ev b is a harmful race if there are significant differences in ps1andps2.
in the remainder of this section we explain how to instrument the web application a nd analyze the race condition warnings to prepare for the subsequent deterministic replay.
in sections v and vi we will explain how to control the event order and record compare program states.
a. instrumenting the html files one input of rc lassify is the url of the target web application consisting of the html files and other resource files such as cascading style sh eets css javascript code images audio and video.
after fe tching these files we instrument them before using them as input of the race detection tool e vent racer it allows us to generate information of the racing events for deterministic replay.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
html head script src pre rclassify.js script !
start of head elements ... head body ... !
end of body elements script window.addeventlistener load rc fire handlers false script body html fig.
.
example instrumented web page prior to race detection.
we use an open source html parser called j soup we generate a unique idattribute for each html element to help pinpoint the html element involved in the racing event at run time and therefore control its execution order during replay.
we also insert our own library code pre rclassify.js t ot h eh t m l head element.
this library code block will be executed before the browser loads the body of the web page thereby allowing us to track the execution of all racing events.
our instrumentation is designed to collect information about the race condition warnings.
fig.
shows an example where lines and are added during our instrumentation.
they execute pre rclassify.js at the start of the head element to redefine api functions such as addeventlistener and settimeout so we can intercept these function calls at run time.
specifically we replace them with wrapper functions which invoke the original apis but also gather information of the racing events for later phases of our algorithm.
we also insert a window.onload event handler at the end of the html body element to be fired after the page is fully loaded.
our function rc fire handlers goes through all registered event handlers that require user actions and fires them one by one to simulate user interactions.
by automatically dispatching these event handlers as opposed to relying on clicks from the user we have improved the coverage compared to existing race detectors.
b. analyzing race condition warnings another input of rc lassify is the set of race condition warnings.
in our work the race detector is e vent racer which uses a modified version of w ebkitto generate a trace log while loading the web page.
then it analyzes the trace log to build a happens before model to capture global resources that have conflicting accesses.
two accesses are conflicting if they refer to the same memory location and at least one of them is a write operation.
however the happens before model in e vent racer is not precise enough to separate harmful races from bogus harmless ones .
our work focuses on precisely classifying these race condition warnings.
toward this end we statically analyze the warnings to compute the information required by deterministic replay.
we use js oup to create two instrumented versions of the web application.
in one version the self control capability ensures eva evb in the other version it ensures evb eva.t o prevent interference from other pairs of racing events we force all other racing events to maintain their original execution order instead of allowing them to interleave freely.
html head !
load replay info of all races here ... script src rclassify.js script ... head body ... !
end of the element m script rc detect handler changes script ... !
end of all body elements script window.addeventlistener load rc dump state false script body html fig.
.
example instrumented web page prior to deterministic replay.
for example given two warnings rc eva ev b andrc evc ev a the first execution may be 1 ps0...ps ievc ...ps jeva ...ps kevb ...ps nwhere eva evb.
to classify rc we obtain the second execution 2 ps0...ps ievc ...ps jevb ...ps prime keva ...ps prime n w h e r e evb eva.
in both executions we try to maintain the order evc evaforrc .
fig.
shows an example of the instrumented html file.
similar to fig.
it loads another of our libraries rclassify.js a tt h es t a r to ft h e head element as well as information of the racing events.
this library contains functions to control the execution order of racing events and record the program state.
we also insert a javascript code snippet to invoke the function rc detect handler changes after the parsing of every html element line .
it checks if the list of event handlers attached to any element of the dom has changed.
if new handlers have been added we retrieve and instrument them so as to track their executions at run time.
when loading the racing events line if evaneeds to be executed before evb we putevainto the towaitlist .
during replay we monitor all racing events dynamically and forceevbto wait for all events in towaitlist before executing evb.
for multiple warnings however it is not always possible to maintain the execu tion order of all other racing events while flipping the race c ondition under investigation.
this is because reversing the order of a race condition may invalidate the order of other race conditions.
for example considerrc eva ev c rc eva ev b andrc evb ev c in an execution where eva evb evc.
when reversing rc maintaining the original order of rc 2andrc 3becomes impossible.
in such cases we try to maintain the order of as many of the other races as possible.
that is after loading the ordering information of the reversed rc 1and the original rc w e discover that they conflict with the original order of rc .
therefore we ignore rc 3and obtain an execution where evc eva evb.
when the must happens before relation among race conditions are available we use it to further refine the execution order information needed for replay.
for example if there is a must happens before relation eva mhbevb we know the order of evaandevbcannot be flipped.
although analyzing rc 1orrc 2alone would not detect any conflict when authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
reversing rc we know that it is no longer possible to maintain both rc 2andrc .
therefore we ignore rc 2and obtain an execution where evc eva evb.
we also insert a window.onload handler at the end line .
the function rc dump state saves all relevant fields of the global state into a disk file.
after recording the two program states we compare them to decide if the race is harmful.
we say eva ev b is harmful if the two states are significantly different.
toward this end an important problem is to identify fields that may be affected by sources of nondeterminism other than race conditions failure to do so will lead to harmless races to be incorrectly classified as harmful races.
in the next sections we explain in detail how to accurately control the order of racing events during replay and how to compare relevant fields of the program states.
v. c ontrolled executions to replay the racing events we need to intercept them and control their execution order at run time.
a. intercepting the callback functions we want to intercept the registration invocation and removal of callback functions for all global events timers and ajax requests.
we replace each callback function with a wrapper that prior to invoking the original function checks if the invocation should be postponed.
broadly speaking there are two types of callback functions for handling events.
type handlers are installed by setting a dom element s attribute such as el.onload and el.onclick .
type handlers in contrast are added and removed by calling addeventlistener and removeeventlistener respectively.
each element may have multiple type handlers stored in the browser as opposed to the dom itself as such these handlers cannot be accessed by traversing the dom tree.
third party libraries such as jquery may define their own apis such as jquery.bind and jquery.detach for managing event handlers.
but internally they still rely on the two aforementioned mechanisms.
the addition and removal of type event handlers via attributes such as el.onclick are difficult to intercept at run time since it is possible for the parsing of any html element e.g.
script elements to add or remove event handlers.
in rclassify we do not modify the underlying web browser or intercept the execution of each individual javascript instruction.
instead our instru mentation is performed at the html file level.
to solve this problem we developed a unified framework for detecting changes to event handlers which periodically scans the dom and compares it with a copy of the dom recorded during the previous scan.
if there is any change in the dom element s type event handler e.g.
the addition or modification of el.onclick we will detect it.
in fig.
for example the scan is implemented using javascript in rc detect handler changes .
by statically instrumenting the html file at run time we can invoke this function right after the parsing of each html element or the execution of each callback f unction that may modify the dom.
to reduce the runtime overhead we statically analyze the html elements to invoke this function only if needed e.g.
after the parsing of javascript code embedded html and other elements whose event handlers contain racing events.
algorithm scanning and instrumenting event handlers.
rc detect handler changes for each el document.all elements for each eh type all event handler types if el eh type has changed event str compose es el.id eh type orig func el eh type if is racing event event str el eh type replace callback event str orig func algorithm controlling execution of callback functions.
replace callback event str orig func function rc func if orig func is defined if racing event finished waiting event str postponedevent .push rc func else orig func .call arguments return rc func the pseudocode is shown in algorithm which first scans the dom to identify any change of el eh type corresponding to the event el.eh type and then instruments the handler var orig func el.onclick el.onclick replace callback event str orig func generate and return rc func ... where rc func is a dynamically generated instance of orig func.
in addition to controlling the execution order rc func also invokes the original function orig func.i n t e r nally replace callback creates the wrapper rc func using event strand orig func and uses it to replace the original function.
type event handlers are intercept by replacing addeventlistener and removeeventlistener with wrapper functions while loading rclassify.js in the html head element.
internally the procedure executes var orig addel addeventlistener addeventlistener function new addel orig addel ... therefore at runtime instead of invoking the original function it would invoke new addel .
instead of adding orig func as an event handler new addel dynamically creates a wrapper function rc func as the event handler.
b. controlling the execution order after a callback function is replaced with its wrapper function the execution order can be controlled with respect to other racing events.
specifically the callback is instrumented according to algorithm where orig func is replaced by a dynamically generated instance of rc func .
we control the event execution order by conditionally postponing the corresponding callback functions.
when a racing event is about to be dispatched instead of executing the original function directly we call the function rc func which in turn checks if the corresponding orig func is ready to execute.
each eventevhas a precomputed set of events towaitlist that need to be executed before ev.
if an event needs to be postponed the function rc func will be put into the waiting list.
the list is checked periodically to ensure that callbacks are executed immediately after they are ready.
to ensure that replay does not deadlock we use a counter inside each rc func to record the number of times it has been authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
postponed not shown in algorithm for brevity .
when the counter reaches a certain threshold say we assume that it has waited too long and thus declare that replay failed.
after that it will stop waiting and enter a free run.
the reason why replay may fail is because some racing events simply cannot be flipped e.g.
bogus race .
in this sense our method can robustly handle bogus races.
however it is not the most efficient way to detect bogus races since waiting for replay to fail consumes a significant amount of time.
therefore we also deve loped a cheaper mechanism for identifying certain bogus races common in web applications.
recall that bogus races are largely due to limitations of race detectors in modeling happen before relationships.
certain event handlers such as document.ondomcontentloaded and window.onload have somewhat fixed execution time they are fired either after the entire html is parsed or after all resources are loaded.
therefore if a reported race is between the parsing of an html element and document.ondomcontentloaded orwindow.onload we know for sure that it is a bogus race.
in such case we can skip replay because replay is guaranteed to fail.
vi.
p rogram state comparison we record the program states after both controlled executions and then compare their fields.
a. state recording after the web page is fully loaded we serialize the program state and store the result in a disk file.
we initiate state recording when the following two conditions are met the web page is fully loaded and a ll racing events have finished executing.
we consider the following fields as parts of the program state the dom we record the value of all html elements their attributes and type event handlers.
we also intercept all type event handlers and store them in a special dom attribute.
javascript variables we record the value of all javascript global variables since they affect the behavior of the application.
environment variables we record the value of environment variables associated with the browser such as the height and width of the window.
console messages we record runtime information displayed in console.log console.warn and console.error .
they are invisible to end users but useful to developers.
all javascript functions and v ariables used to implement rclassify are defined in a specific name space and thus can be excluded from the program state easily.
to serialize the data fields into a string thus allowing them to be compared easily we use the json.stringify api.
however json does not directly handle data with cyclic dependency which are common in web applications.
to solve this problem we imp lemented a javascript method that traverses the dom object in the bfs order and marks each visited node with a unique identifier.
if it encounters a visited object again it replaces the reference to that object with its unique identifier.
since the resulting representation is guaranteed to be acyclic it can be serialized to a string using json.stringify .b.
state comparison to compare two program states we first use json.parse to restore the data fields from disk files and construct two key value tables.
for the dom we use the element s id attribute as the key the unique idgenerated by our html instrumentation and the html content as the value.
for javascript variables and environment variables we use the variable name as the key.
for console messages we use their order in the console as the key.
we say the race condition isharmless if the two states are identical.
we say the race condition is harmful if they differ in the dom or javascript global variables.
if they differ only in console logs or the value of some environment variables we assume the race condition is likely harmless but we still report it as a warning.
sometimes certain fields of the dom or javascript variables may have nondeterministic values due to reasons other than race conditions.
for example an application may record the last time it is executed or create a session id that is different every time it is executed.
to exclude such fields in state comparison since they may lead to false positives we developed a mechanism for users to specify which fields should be excluded.
we also developed a heuristic method for filtering out such irrelevant fields automatically.
our solution is to execute the web application three times with the following event orders eva evb eva evb a n d evb eva.
after that we use a three way comparison to check the state differences.
if there exists a field that has different values in all three states then we consider it as an irrelevant field.
if a field has the same value in the first two states but a different value in the third state then we consider it as a relevant field.
vii.
e xperiments we have implemented our evidence based classification method in a software tool rc lassify which builds upon a number of open source software.
our libraries for monitoring and controlling racing events is written in .1k lines of javascript code.
our front end for html instrumentation is implemented using jsoup .
.
in .4k lines of java code.
we leverage e vent racer to generate the race condition warnings our input .
during the experiments we store benchmarks under test in a local web server.
we use teleport ultra .
to download the source files of real websites before instrumenting them.
we use mozila firefox as the web browser we experimented with versions ranging from .
to .
and did not encounter any incompatibility issue.
our benchmarks fall into two groups.
the first group consists of standard web appli cation benchmarks from recent publications such as e vent racer and w av e .
since they are written specifically for illustrating various types of race conditions most of them have known to beharmful races and our goal is to confirm that rc lassify can correctly identify them.
the second group consists of seventy real websites randomly chosen from the portals of the fortune companies.
previously e vent racer was applied to the same type of websites and reported many bogus warnings.
therefore our goal is to see if rc lassify can do better than state of the art techniques which include not only event racer but also mutlu et al.
and r4 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that is can rc lassify accurately classify these warnings while maintaining a low runtime cost?
our experiments were conducted on a machine with intel core i7 .
ghz cpu and gb ram running bit ubuntu.
a. results on standard benchmarks table i shows our results on the standard benchmarks.
columns show the benchmark name and number of race condition warnings input of rc lassify .
column shows the number of bogus races that rc lassify identified.
columns show the number of harmful races harmless races and undetermined cases undet respectively.
column shows the total time taken by rc lassify .
note that some warnings cannot be generated by the race detector e ventracer due to its own limitations for these warnings we manually created them and gave them to rc lassify .w e checked all input warnings manually and confirmed that rclassify produced the correct classification.
specifically the harmless races fall into three groups none means there are no differences in the program states con.
means there are differences in console logs only and b c t means the differences are due to event bubbling and capturing or a timer try pattern.
event bubbling and capturing b c lead to duplicated events on the upper level elements.
for example if a windows has buttons each of the button.onclick events can be bubbled up to trigger document.onclick .
in such case there will be races reported on document.onclick .
timer try t is when a function repeatedly postpones its execution via settimeout until some condition is satisfied.
the nature of these races means they are likely harmless.
we also downloaded and applied the tools from mutlu et al.
and jessen et al.
r4 .
mutlu et al.
was designed to report only harmful races but it reported races despite that of the races were known to be harmful.
r4 focuses on applying stateless model checking to web applications to systematically explore the event interleavings but also can filter race condition warnings.
our experiments showed that r4 detected only race conditions among which it classified as harmful h as normal risk n and as low risk l .
our manual inspection showed that whereas the races marked as harmful h by r4 are indeed harmful of the other races which were not marked as harmful by r4 are also harmful.
altogether r4 reported only out of the harmful races while missing the other .
b. results on real websites table ii shows the results of our experiments on real websites.
since going through all web portals of the fortune500 companies takes too much time we randomly selected seventy companies and applied e vent racer to generate the initial set of race condition warnings.
among them twenty websites do not have any e vent racer reported warnings for the remaining fifty websites the results are shown in the table.
columns show the website name and the number of e vent racer reported warnings input of rc lassify .table i experimental results on the standard benchmarks .
name warning bogus harmful harmless undet.
time from from input con.
b c t none harmful h n l webr ex1 .8s webr ex2 .8s webr ex3 .8s webr ex4 .8s webr ex5 .1s eventr ex1 .8s eventr ex2 .8s eventr tut 1m10s kaist ex1 .8s kaist ex2 .0s kaist ex3 1m10s kaist case1 2m20s kaist case2 .2s kaist case3 1m35s kaist case4 1m51s kaist case5 1m11s kaist case6 .3s kaist case7 2m50s kaist case8 .6s total script id script 1 function show document.getelementbyid dw .style.display block script ai d href1 href javascript show link a div id dw style display none d w div fig.
.
a harmful race condition rc lassify identified but r4 missed.
columns show the number of bogus races harmful races harmless races and undecided cases respectively.
column shows the total time taken by rc lassify .
finally columns show the results reported by r4.
while using e vent racer to generate the input warnings we found that some of the reported races do not make sense since the racing events have empty read write accesses likely due to defects in e vent racer therefore we filtered them out before applying rc lassify they are labeled undet.
in the table.
the results in table ii show that rc lassify identified harmful races out of e vent racer reported warnings.
we manually inspected the state comparison results of these races and confirmed the correctne ss of all classifications.
an example of the harmful races identified by rc lassify is already shown in fig.
which turns out to be a real bug from in contrast r4 identified only harmful races.
there are also six websites on which r4 crashed they are marked as crash in the table.
a closer investigation shows that r4 relies on the severity of error logs and exception logs to determine the risk level of each race.
although r4 saves a picture screenshot after each execution for the user s reference it does not record the program state.
even if the developers manually compare screenshots it is not as accurate or informative as comparing the program states.
for example in fig.
r4 failed to identify the harmful race occurred when href1 is clicked before the dwelement is parsed thus causing show to access a nonexisting element but there is no visual difference.
in contrast rclassify can detect the difference in program states and thus identify it as a harmful race.
while reviewing the classification results we also noticed that harmful race conditions from the same website were often authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii experimental results on real websites randomly chosen from webportals of fortune c ompanies .
name warning bogus harmful harmless undet.
time result of r4 input of rc lassify console b c t none harmful normal low 5m30s .8s 67m48s 4m5s crash crash 3m17s crash .6s 1m14s 11m16s 7m40s crash 1m39s 12m53s 1m16s 75m18s 73m37s 1m8s 235m31s 3m32s 1m22s 0m36s 21m18s 161m18s .6s .3s 5m58s 1m49s 1m1s 126m30s 3m33s 1m42s 4m59s 1m38s .2s 2m48s .7s 3m22s crash 4m10s 3m46s .5s crash 6m41s 2m3s 14m45s 7m33s 15m36s total correlated fixing one race e.g.
by adding a must happenbefore constraint also fixes many of the other races.
the execution time of rc lassify is largely determined by how fast the browser loads the target web page since we need to wait for the page to be completely loaded before recording the program state.
in practice it is common for a website to have large resource files that take a significant amount of time to download.
an example is which may take tens of seconds to load completely and thus increase the total execution time of rc lassify .
in addition we inserted several sleep commands in our framework to ensure a smooth connection between operations e.g.
between the script for saving the state recording file and the script for loading the next web page.
during state comparison we also run the same web application three times among which two are in the original execution order while the third one is with the racing events flipped.
for each individual replay we observed only a slowdown of .
2x when compared to a free run.
also note that we have not optimized the runtime performance of our tool.
nevertheless rc lassify is fully automated and therefore is significantly more efficient than manually classifying race condition warnings.c.
compared to heuristic filtering we also compared rc lassify with e vent racer s heuristic filtering which does not check the effect of racing events but instead relies on event types and a limited number of bug patterns.
as such they may report false positives as well as miss harmful races.
more specifically e vent racer has two levels of filtering.
the first level filtering aims at removing benign races.
the second level filtering aims at identifying high risk harmful races.
we use the rest to denote left over races after these two levels of filtering.
table iii shows our experimental results.
of the race condition warnings e vent racer s heuristic filtering identified as high risk harmful as benign and as the rest.
in contrast our method showed that only of the high risk harmful r aces are truly harmful whereas of the benign races are harmful.
in addition of the left over races are also harmful.
the results show that heuristic filtering techniques are not effective in practice.
fig.
shows a harmful race condition detected by rc lassify from the official website of honeywell international but considered by eventracer s heuristic filtering as benign they call it filtered .
the race condition is between the parsing of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii rclassify versus event racer sheuristic filtering .
total event racer shigh risk event racer sbenign event racer sthe rest harmful .
.
asynchronous script jsapi eva and the parsing of synchronous script gssautocomplete.js evb .
by executing these racing events in different orders rc lassify detected differences in many fields of the program states.
among them one difference is in the title field of the web page when evb eva t h e title is honeywell global technology leader in energy efficiency clean energy generation safety security and globalization b u tw h e n eva evb the title is home .
!
other elements script id script 4 ... 4var gjsapi document.createelement script 5gjsapi.type text javascript 6gjsapi.src https document.location.protocol ?
7var s document.getelementsbytagname script 8s.parentnode.insertbefore gjsapi s ... script !
other elements script type text javascript id script 26 src 13internetframework scripts gssautocomplete.js script !
other elements fig.
.
a harmful race condition filtered out by e vent racer .
viii.
r elated work there are several existing tools for detecting race conditions in web applications some of which are based on conservative static analysis e.g.
zheng et al.
and a rrow while others are based on dynamic analysis .
static analysis has the advantage of covering all possible execution paths of the javascript code but due to the rich set of dynamic features in javascript and client side web applications in general they cannot robustly handle real websites.
dynamic analysis tools such as event racer and w av e do not have such limitations.
however they have limited code coverage and often report many bogus warnings as well as miss real bugs.
furthermore none of these existing methods uses evidencebased techniques to classify race conditions.
mutlu et al.
proposed a method for detecting race conditions using a combination of dynamic and static analysis techniques.
they obtain an execution trace and then use predictive static analysis to detect races that may occur in all possible interleavings of events of the given trace.
however their method does not use deterministic replay to check the actual impact of racing events and therefore may still report bogus and harmless races.
furthermore their tool is limited to detecting certain types of races over persistent storage and may miss many other races as shown in our experiments.
jensen et al.
proposed a stateless model checking tool r4 for systematically exploring event interleavings in a web application.
unlike tools such as e vent racer which detect races only in one trace r4 can generate many new traces from the given trace and detect races in these traces.
however as shown in our experimental evaluation r4 does not perform well in classifying the races it missed many harmful races and reported many false positives.
there are also software tool s for recording the state of a running web application but the goal is to allow developers to revisit the recorded program state to diagnose bugs or dynamically migrate the web application to other platforms .
therefore although they also address the state recording problem the applications are significantly different from ours none of these prior works focuses on diagnosing concurrency bugs.
for diagnosing data races in multithreaded programs there is a large body of work .
specifically narayanasamy et al.
proposed perhaps the first deterministic replay based method for classifying data races in multithreaded applications.
they used a checkpointing tool to take snapshots of the main memory while executing the program and compared the snapshots to decide if a data race is harmful.
similar works also include sen s race directed testing tool and the portend tool by kasikci et al.
.
there are also many testing tools such as ctrigger penelope fusion and rvpredict for multithreaded programs.
however data races in multithreaded c c or java programs are significantly different from race conditions in clientside web applications.
specifically the computing platforms are significantly different in that one relies on multi threading whereas the other relies on event driven execution.
the supporting tools are also different.
for multithreaded programs there already exist a large number of checkpointing tools but for web applications we are not aware of any such checkpointing tool.
due to these reasons both deterministic replay and program state comparison require drastically different solutions.
therefore except for the high level similarity rc lassify is completely different from these existing methods and tools.
ix.
c onclusions we have presented rc lassify t h efi r s t evidence based method for automatically cla ssifying race condition warnings in web applications.
it identifies the real and harmful races based on executing the racing events in different orders and then comparing the program states.
we also developed a purely javascript based platform agnostic framework for monitoring and controlling the execution order of racing events.
we have implemented rc lassify and evaluated it on both standard benchmarks and a large set of real websites.
our experimental results show that the new method is both effective in identifying harmful races and scalable for practical use.
for future work we plan to leverage rc lassify not only to diagnose race conditions but to automatically repair them.
x. a cknowledgments this work was primarily supported by the national science foundation nsf under the grants ccf ccf1405697 and ccf .
partial support was provided by the office of naval research onr under the grant n0001413 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.