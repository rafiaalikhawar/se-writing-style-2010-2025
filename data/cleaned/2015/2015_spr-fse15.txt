staged program repair with condition synthesis fan long and martin rinard mit eecs csail usa fanl rinard csail.mit.edu abstract we present spr a new program repair system that combines staged program repair and condition synthesis .
these techniques enable spr to work productively with a set of parameterized transformation schemas to generate and efciently search a rich space of program repairs.
together these techniques enable spr to generate correct repairs for over ve times as many defects as previous systems evaluated on the same benchmark set.
categories and subject descriptors d. .
testing and debugging keywords program repair staged repair condition synthesis .
introduction despite decades of e ort defect triage and correction remains a central concern in software engineering.
indeed modern software projects contain so many defects and the cost of correcting defects remains so large that projects typically ship with a long list of known but uncorrected defects.
consequences of this unfortunate situation include pervasive security vulnerabilities and the diversion of resources that would be better devoted to other more productive activities.
automatic program repair holds out the promise of signi cantly reducing the time and e ort required to deal with software defects.
in the last decade researchers have developed automatic techniques that have been demonstrated to successfully correct targeted but important classes of defects such as out of bounds accesses integer overow errors null pointer dereferences in nite loops memory leaks and data structure corruption errors .
but impoverished search spaces and ine cient search algorithms have crippled the ability of previous systems to generate correct patches for more general classes of defects .
.
staged program repair spr we present spr a new program repair system that uses a novel staged program repair strategy to e ciently search a rich search space of candidate repairs.
three key techniques work synergistically together to enable spr to generate successful repairs for a range of software defects.
together these techniques enable spr to generate correct repairs for over ve times as many defects as previous systems evaluated on the same benchmark set parameterized transformation schemas spr deploys a set of general transformation schemas each of which implements a strategy designed to generate repairs that correct an identi ed class of defects.
because each schema is parameterized it represents a large class of program transformations.
together these schemas enable spr to work with a rich search space that contains many successful repairs for common defects.
target value search given a parameterized transformation schema spr uses target value search to quickly determine if there is anyparameter value that will enable the schema to produce a successful repair.
if not spr rejects the schema and bypasses all of the many repairs that the schema can generate.
condition synthesis many of the spr transformation schemas take a logical condition as a parameter.
the spr condition synthesis algorithm rst uses target value search to obtain constraints that any such logical condition should satisfy.
it then works with these constraints to synthesize logical expressions that enable the transformation schema to generate a successful repair.
a key insight is that staging the repair process as transformation selection target value search and condition synthesis enables spr to immediately bypass the overwhelming majority of candidate repairs and focus the search on the most promising regions of the space.
our results highlight the e ectiveness of this strategy staged repair can deliver two orders of magnitude reduction in the size of the space that spr explores.
staged program repair is therefore critical in enabling spr to work productively with large repair search spaces that contain many useful repairs.
.
experimental results we evaluate spr on real world defects and functionality changes from the repositories of eight real world applications.
this is the same benchmark set used to evaluate several previous automatic patch generation systems this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication esec fse august september bergamo italy c acm.
... .1the spr search space contains transformations that correctly repair of the defects and of the functionality changes .
for of these defects spr generates the correct repair as the rst repair to validate i.e produce correct outputs for all test cases in the test suite .
these correct repairs semantically match corresponding repairs provided by human developers.
for comparison previous systems generate correct patches for only one or two of the defects in this benchmark set.
a repair is plausible if it produces correct outputs for all of the test cases in the test suite a plausible repair may be incorrect it may produce incorrect outputs for test cases not in the test suite .
spr generates plausible repairs for of the defects and of the functionality changes .
for comparison previous systems generate plausible patches for only or of the defects in this benchmark set.
these results highlight the success of spr s staged approach and the synergistic relationship between its three novel techniques.
parameterized transformation schemas produce a rich repair space that contains many useful repairs.
target value search enables the e cient search algorithm required to make this rich search space viably searchable in practice.
and condition synthesis delivers the logical expressions required to successfully instantiate the transformation schemas to obtain successful repairs.
.
repair prioritization and prophet spr uses a set of heuristics to prioritize the order in which it validates repairs see section .
.
the goal is to obtain a sequence of plausible repairs in which the correct repair appears as early as possible and ideally the rst repair in the sequence to validate .
the spr heuristics are reasonably e ective at satisfying this goal for of the relevant defects the correct repair is the rst to validate.
but there is room for improvement.
prophet searches the same repair space as spr but works with a large corpus of correct repairs from human developers.
it processes this corpus to learn a probabilistic model that assigns a probability to each candidate repair in the search space.
this probability indicates the likelihood that the repair is correct.
it then uses this model to prioritize its search of the repair space.
the results show that prophet s learned repair correctness model outperforms spr s heuristics for of the defects prophet nds the correct repair as the rst repair to validate.
this result highlights how leveraging information available in existing large software development projects can signi cantly improve our ability to automatically manipulate large software systems.
1papers for these previous systems report that this benchmark set contains defects .
our analysis of the commit logs and applications indicates that of these defects correspond to deliberate functionality changes.
that is for of these defects there is no actual defect to repair.
we evaluate spr on all defects changes but report results separately for the actual defects and functionality changes.
2because of errors in the patch evaluation scripts previous papers report incorrect results .
speci cally previous papers report patches for and of the defects changes.
but for of these defects changes and of these defects changes none of the reported patches produces correct outputs for the test cases in the test suite used to validate the patches .
.
contributions this paper makes the following contributions staged program repair it introduces staged program repair a new technique for automatically generating and e ciently searching rich repair spaces that contain many useful repairs.
search space it presents a set of transformation schemas that generate a search space with many useful repairs and synergistically enable the development of a staged repair system that uses condition synthesis to e ciently search the generated space.
condition synthesis it presents a novel condition synthesis algorithm.
this algorithm rst uses target value search to obtain constraints that would enable the repaired program to produce correct outputs for all test cases in the test suite.
it then generates logical conditions that successfully approximate the set of branch directions.
this condition synthesis algorithm enables spr to e ciently search the space of conditions in the spr search space.
experimental results it presents experimental results that characterize the e ectiveness of spr in automatically nding correct repairs for out of benchmark defects and plausible repairs for of these defects.
the results also show that the spr search space contains correct repairs for of the defects.
we discuss several extensions to the spr search space and identify the correct repairs that each extension would bring into the search space.
.
example we next present an example that illustrates how spr repairs a defect in the php interpreter.
the php interpreter before .
.
or svn version before contains a defect php bug in its implementation of the dateperiod object constructor .
if a php program calls the dateperiod constructor with a single null value as the parameter e.g.
dateperiod null the php interpreter dereferences an uninitialized pointer and crashes.
figure presents simpli ed source code from the source leext date php date.c that contains this defect.
the code in figure presents the c function inside the php interpreter that implements the dateperiod constructor.
the php interpreter calls this function to handle dateperiod constructor calls in php programs.
a php program can invoke the dateperiod constructor with either three parameters or a single string parameter.
if the constructor is invoked with three parameters one of the two calls to zend parse parameter ex on lines will succeed and set interval to point to a dateinterval php object.
these two calls leave isostr len and isostr unchanged.
if the constructor is invoked with a single string parameter the third call to zend parse parameter ex on lines parses the parameters and sets isostr to point to a php string object.
isostr len is the string length.
the then clause in lines is designed to process calls with one parameter.
the defect is that the programmer assumed incorrectly that all one parameter calls will set isostr len to a non zero value.
but if the constructor is called with a null string isostr len will be zero.
the if condition at line misclassi es the call as a three parameter call and executes the else clause in lines .
in this creates new dateperiod object.
php method dateperiod construct php period obj dpobj char isostr null int isostr len zval interval ... parse datetime dateinterval int if zend parse parameters ex ... start date ce date interval date ce interval recurrences options failure parse datetime dateinterval datetime if zend parse parameters ex ... start date ce date interval date ce interval end date ce date options failure parse string if zend parse parameters ex ... isostr isostr len options failure php error docref ... this constructor accepts either datetime dateinterval int or datetime datetimeinterval datetime or string as arguments.
... return dpobj ... dpobj current null repair transformation schema if isostr len abstract cond instantiated repair.
abstract cond isostr !
if isostr len isostr !
developer patch if isostr if isostr len handle string case date period initialize dpobj start dpobj end dpobj interval recurrences isostr isostr len ... else handle datetime ... cases pass uninitialized interval intobj php interval obj zend object store get object interval ... ... figure simpli ed code for php bug case interval is uninitialized and the program will crash when the invoked zend object store get object function dereferences interval .
we apply spr to automatically generate a repair for this defect.
speci cally we give spr program to repair version of the php source code this version contains the defect .
negative test cases test cases that expose the defect i.e.
test cases that php version does not pass but the repaired version should pass.
in this example there is a single negative test case.
positive test cases test cases that prevent regression i.e test cases that the version already passes and that the patched code should still pass.
in this example there are positive test cases.
defect localization spr compiles the php interpreter with additional pro ling instrumentation to produce execution traces.
it then executes this pro ling version of php on both the negative and positive test cases.
spr observes that the negative test case always executes the statement at lines in figure while the positive test cases rarely execute this statement.
spr therefore identi es the enclosing if statement line as a high priority repair target.first stage select transformation schema spr selects transformation schemas to apply to the repair target.
one of these schemas is a condition re nement schema that loosens the if condition by disjoining an abstract condition abstract cond to the if condition.
second stage condition synthesis spr uses condition synthesis to instantiate the abstract condition abstract cond in the selected transformation schema.
target condition value search spr replaces the target if statement on line with the transformation schema on line .
the schema takes an abstraction condition abstract cond as a parameter.
spr links php against a spr library that implements abstract cond .
note that if abstract cond always returns the semantics of php does not change.
spr searches for a sequence of return values from abstract cond that causes php to produce the correct result for the negative test case.
spr repeatedly executes php on the test case generating a di erent sequence of return values from abstract cond on each execution.
in the example ipping the return value of the last invocation of abstract cond from to produces the correct output.
instrumented reexecutions spr instruments the code to record for each invocation of abstract cond a mapping from the values of local variables accessed global variables and values accessed via pointers in the surrounding context to theabstract cond return value.
spr reexecutes the negative test case with the sequence of abstract cond return values that produces the correct output.
it also reexecutes the positive test cases with an all sequence of abstract cond return values so that these reexecutions preserve the correct outputs for the positive test cases .
condition generation spr uses the recorded mappings to generate a symbolic condition that approximates the mappings.
in the example isostr is never in the negative test case execution.
in the positive test case executions isostr is always zero when abstract cond is invoked note that jjis a short circuit operator .
spr therefore generates the symbolic condition isostr !
as the parameter.
condition validation spr reexecutes the php interpreter with abstract cond replaced with isostr !
.
php passes all test cases and spr has found a successful repair lines in figure .
the o cial patch from the php developer in version replaces isostr len with isostr line in figure .
at this program point isostr len is zero whenever isostr is zero.
the spr repair is therefore functionally equivalent to the o cial patch from the php developer.
.
design spr starts with a program with a defect and a test suite.
the suite contains positive test cases for which the program already produces correct outputs and negative test cases which expose the defect that causes the program to produce incorrect outputs.
the goal is to generate a repair that enables the program to pass the supplied test suite i.e produce correct outputs for all test cases in the test suite .
168c 1j0jc1 c2jc1 c2j!c1j c1 jv const prts print vjprint const simps v v1opv2jv const jv read jprts ifs if c absts if c !abstc 2jif c abstc jprint abstval s skip jstopjsimps jifsjabsts v v v22variable const 2int 22label c c c22condexpr s2stmt ifs2ifstmt prts2printstmt simps 2simplestmt absts 2abststmt figure the language statement syntax spr rst uses fault localization to identify target statements to transform .
it then stages the search for a successful repair as follows.
it rst selects a transformation schema to apply to a target statement.
the result is a candidate repair template which may contain an abstract expression as the template parameter.
spr then uses target value search to determine if there is any parameter value that would instantiate the candidate repair template to deliver a successful repair.
if so spr synthesizes candidate parameter values and attempts to validate each resulting repair in turn.
.
core language language syntax figure presents the syntax of the core language that we use to present our algorithm.
the current implementation of spr works with applications written in the c programming language.
see section .
for the extension of our algorithm to handle c. a program is a pair hp ni wherep label!statement maps each label to the corresponding statement and n label!label maps each label to the label of the next statement to execute.
0is the label of the rst statement in the program.
the language in figure contains arithmetic statements and if statements.
an if statement of the form if c transfers the execution to 1ifcis and 2ifcis .
the language uses if statements to encode loops.
a statement of the form v read reads an integer value from the input and stores the value to the variable v. a statement of the form printv prints the value of the variable vto the output.
statements that contain an abstract expression i.e.
abststmt are temporary statements that the algorithm may introduce into a program during the repair algorithm.
such statements do not appear in the original or repaired programs.
program state a program state h i o d r sicontains the current program point a label the current environment that maps each variable to its value variable!int the remaining input i and the generated output o .iis a sequence of integer values i.e.
sequence int .
ois a sequence of integer and abstract values i.e.
sequence int fabstvalg .
to support the extension to programs with abstract expressions the program state also contains a sequence of future abstract condition values d a sequence of recorded abstract condition values r and a sequence of recorded environments for each abstract expression execution s .dandrare sequences of zero or one values i.e.
sequence 0j1 .sis a sequence of environments i.e.
sequence variable !int .the rst three rules in figure present the operational semantics of input read if and print statements.
in figure is the sequence concatenation operator.
the notation c x indicates that the condition cevaluates to xunder the environment .
note that for programs that do not contain abstract expressions d r andsare unchanged.
see our technical report for the rules for other kinds of statements.
.
transformation schemas figure presents our program transformation function m. it takes a program hp niand produces a set of candidate modi ed programs after transformation schema application.
tl hp ni is the set of target statement labels to transform.
our error localizer section .
identi es this set of statements.
simples p denotes all simple statements i.e.
simplestmt inp.vars p and vars s denote all variables in the program pand in the statement s respectively.
consts p denotes all constants in p. reps p s is an utility function that returns the set of statements generated by replacing a variable or a constant in swith other variables or constants in p. speci cally spr works with the following transformation schemas condition re nement given a target if statement spr transforms the condition of the if statement by conjoining or disjoining an abstract condition to the original if condition m tighten and m loosen .
condition introduction given a target statement spr transforms the program so that the statement executes only if an abstract condition is true m guard .
conditional control flow introduction spr inserts a new control ow statement return break or goto an existing label that executes only if an abstract condition is true m control .
insert initialization for each identi ed statement spr generates repairs that insert a memory initialization statement before the identi ed statement m init .
value replacement for each identi ed statement spr generates repairs that replace either one variable with another an invoked function with another or a constant with another constant m rep .
copy and replace for each identi ed statement spr generates repairs that copy an existing statement to the program point before the identi ed statement and then apply a value replacement transformation mcprep .
note that the transformation schemas m tighten mloosen mguard and m control introduce an abstract condition into the generated candidate programs.
the transformation schemas m repand m cprep may introduce a print statement with an abstract expression.
these abstract conditions and expressions will be handled by the repair algorithm later.
.
staged repair with condition synthesis figure presents our main staged repair algorithm with condition synthesis.
given a program hp ni a set of positive test cases post and a set of negative test cases negt the algorithm produces a repaired program hp0 n0ithat passes all test cases.
exec hp ni i d at lines and produces the results of running the program hp nion the inputigiven the future abstract condition value sequence d. test hp ni negt post at lines and produces 169p v readi x i0 h i o d r si jhp nik hn i0 o d r sip if c c h i o d r si jhp nik h i o d r si p printv o0 o v h i o d r si jhp nik hn i o0 d r sip print abstval o0 o abstval h i o d r si jhp nik hn i o0 d r s i p if c !abstc c h i o d r si jhp nik h i o d r sip if c !abstc c h i o r si jhp nik h i o r s i p if c !abstc c 1d d0 h i o d r si jhp nik h i o d0 r s ip if c !abstc c 1d d0 h i o d r si jhp nik h i o d0 r s i figure small step operational semantics m hp ni m ifstmt hp ni mstmt hp ni mifstmt hp ni 2tl hp ni p 2ifstmt mtighten hp ni mloosen hp ni mstmt hp ni 2tl hp ni mcontrol hp ni minit hp ni mguard hp ni mrep hp ni mcprep hp ni mtighten hp ni fhp nig where p if c mloosen hp ni fhp nig where p if c mcontrol hp ni fhp n ig mguard hp ni fhp n ig minit hp ni fhp n i j 8v2vars p g mrep hp ni fhp ni js2reps p p g mcprep hp ni fhp n i hp n i j 8s2simples hp ni 8s0 2reps p s g reps p v v1opv2 fv0 v1opv2 v v0opv2 v v1opv0 j 8v0 2vars p g reps p v const fv0 const v const0 j 8v0 2vars p 8const0 2consts p g reps p v read fv0 read j 8v0 2vars p g reps p prts fprint abstval g where prts2printstmt reps p s where s 2simplestmt figure the program transformation function m. note that 0and 00are fresh labels.
a boolean to indicate whether the program hp nipasses all test cases.
see figure for the de nitions of exec and test.
the algorithm enumerates all transformed candidate programs in the search space derived from our transformation function m hp ni line .
if the candidate program does not contain an abstract expression the algorithm simply uses test to validate the program lines .
if the candidate program contains an abstract condition the algorithm applies condition synthesis lines in two stages target condition value search and condition generation.
target condition value search we augment the operational semantics of the core language to handle statements with an abstract condition.
the last four rules in figure present the semantics of if c abstc .
the rules for if c abstc are similar .
the fth rule in figure speci es the case where the result of the condition does not depend on the abstract condition the semantics implements short circuit conditionals .
in this case the execution is transfered to the corresponding labels with d r andsunchanged.
the sixth rule species the case where there are no more future abstract condition values in dfor the abstract condition abstc .
this rule uses the semantics preserving value for the abstract condition abstc withrandsappropriately updated.
the last two rules specify the case where dis not empty.
in this case the execution continues as if the abstract condition returns the next value in the sequence d withrandsupdated accordingly.
for each negative test case the algorithm in figure searches a sequence of abstract condition values with the goal of nding a sequence of values that generates the correct output for the test case lines .
flip is an utility function that ips the last non zero value in a given valuesequence see figure for the formal de nition .
the algorithm line executes the program with di erent future abstract condition value sequences dto search for a sequence that passes each negative test case.
if the algorithm cannot nd such a sequence it moves on to the next candidate program line .
note that the program may execute an abstract condition multiple times.
spr tries a con gurable number in our current implementation of di erent abstract condition value sequences for each negative test case in the loop lines .
at each iteration except the last of the loop the algorithm ips the last non zero value in the previous sequence.
in the last iteration spr ips all abstract condition values to one line in figure .
the rationale is that in practice if a negative test case exposes an error at an if statement either the last few executions of the if statement or all of the executions take the wrong branch direction.
this empirical property holds for all defects in our benchmark set.
if a future abstract condition value sequence can be found for every negative test case the algorithm concatenates the found sequences r0and the corresponding recorded environments to s0 lines .
it then executes the candidate program with the positive test cases and concatenates the sequences and the recorded environments as well lines .
note that for positive cases the algorithm simply returns zero for all abstract conditions so that the candidate program has the same execution as the original program.
condition generation the algorithm enumerates all conditions in the search space and evaluates each condition against the recorded condition values r and environments s0 .
it counts the number of recorded condition values that the condition matches.
our current condition space is the 170exec hp ni i d ho r si 9i0 o r s such thath i d i jhp nik hnil i0 o d0 r si ?
otherwisetest hp ni negt post false9hi oi2 negt post such that exec hp ni i ho0 r si o6 o0 trueotherwisef c c x f x r s c f r s c c x f x r s c f r s c flip r r0 flip r r0 1r r0 flip r flip r0 v s c co06 o o0 oro v o0 o s c s s0o0 x o00o y o0x y v o0 o s c v o00 o0 s0 c o0 x o00o y o0x6 y x6 abstval v o0 o s c s s0o0 abstval o00o y o0c0 v o00 o0 s0 c v o0 o s c fvj v y v2c0g fyjy2c0g figure de nitions of exec test flip f and v input original program hp ni input positive and negative test cases negt andpost each is a set of pairshi oiwhereiis the test input and o is the expected output.
output the repaired program hp0 n0i or if failed 1forhp0 n0iinm hp ni do ifp0contains abstc then 3r0 4s0 forhi oiinnegt do 6ho0 r si exec hp0 n0i i cnt whileo06 oand cnt 10do ifcnt then d else d flip r ho0 r si exec hp0 n0i i d cnt cnt ifo6 o0then skip to the next candidate hp0 n0i else r0 r0 r s0 s0 s forhi oiinpost do 21ho0 r si exec hp0 n0i i r0 r0 r s0 s0 s c fg for ins0do c c f v const !
v const j 8v8const such that v constg cnt whilec6 and cnt 20do letc2cmaximizesf r0 s0 c c c fcg iftest hp0 n0i negt post then returnhp0 n0i cnt cnt else ifp0contains abstval then c variable int forhi oiinnegt do 37ho0 si exec hp0 n0i i c v o0 o s c forvalincdo iftest hp0 n0i negt post then returnhp0 n0i else if test hp0 n0i negt post then returnhp0 n0i 44return figure repair generation algorithm with condition synthesisset of all conditions of the form v const or!
v const such that9 2s0 v const .
it is straightforward to extend this space to include comparison operators and a larger set of logical expressions.
for our benchmark set of defects the current spr condition space contains a remarkable number of correct repairs with extensions to this space delivering relatively few additional correct repairs see section .
.
f r0 s0 c in figure is an utility function that counts the number of branch directions for the condition cthat match the recorded abstract condition values r0given the recorded environments s0.
see figure for the formal de nition.
the algorithm enumerates a con gurable number in our current implementation of the top conditions that maximizef r0 s0 c lines .
the algorithm then validates the transformed candidate program with the abstract condition replaced by the generated condition c lines .
p denotes the result of replacing every occurrence ofabstc inpwith the condition c. enumerating all conditions in the space is feasible because the overwhelming majority of the candidate transformed programs do not pass the target condition value search stage.
spr will therefore perform the condition generation stage very infrequently and only when there is some evidence that transforming the target condition may deliver a correct repair.
in our experiments spr performs the condition generation stage for less than of the candidate programs that contain an abstract condition see section .
.
staged repair for print statements we augment the semantics to support print statements with abstract expressions as shown as the fourth rule in figure .
when such a print statement is executed a special token abstvalis appended to the output sequence oto represent an undetermined value.
at the rst stage the algorithm executes the program with such abstract print statements on each of the negative test cases lines .
the algorithm compares the result output sequence o0with the expected output sequence o. this comparison uses the utility function v o0 o s c to compute a set of concrete values that after replacing the abstract expression enable the repaired program to pass the test case.
see figure for the formal de nition of v. if the rst stage succeeds the second stage replaces the abstract expression with the computed concrete values and validates the resulting repair lines .
.
extensions for c c program support we have implemented spr in c using the clang compiler front end .
spr applies the transformation function separately to each function in a c program.
when spr performs variable replacement or condition synthesis it considers all variables including local global and heap variables that appear in the transformed function.
during condition generation spr also searches existing conditions cthat occur in the same enclosing compound statement in addition to conditions of the form v const or!
v const described in section .
.
when spr inserts control statements spr generates repairs that include break return and goto statements.
when inserting return statements spr generates a repair to return each constant value in the returned type that appeared in the enclosing function.
when inserting goto statements spr generates a repair to jump to each already dened label in the enclosing function.
when spr inserts initialization statements spr generates repairs that call memset to initialize memory blocks.
when spr copies statements spr generates repairs that copy compound statements in addition to simple statements as long as the copied code can t into the new context.
spr also extends its staged repair algorithm to constant string literals in c print statements e.g.
printf .
see our technical report for implementation details.
error localizer the spr error localizer recompiles the given application with additional instrumentation.
it inserts a call back before each statement in the source code to record a positive counter value as the timestamp of the statement execution.
spr then invokes the recompiled application on all test cases and produces a prioritized list that contains target statements to modify based on the recorded timestamp values.
spr prioritizes statements that are executed with more negative test cases are executed with fewer positive test cases and are executed later during executions with negative test cases.
our technical report presents the error localization algorithm.
repair test order spr validates the generated candidate repairs one by one line in figure .
spr prioritizes the generated patches as follows .
spr rst tests repairs that change only a branch condition e.g.
tighten and loosen a condition .
.
spr tests repairs that insert an if statement before a statements wheresis the rst statement of a compound statement i.e.
c code block .
.
spr tests repairs that insert an if guard around a statements.
.
spr tests repairs with abstract print statements.
.
spr tests repairs that insert a memory initialization.
.
spr tests repairs that insert an if statement before a statements wheresis not the rst statement of a compound statement.
.
spr tests repairs a that replace a statement or b that insert a non if statement i.e.
generated by m cprep before a statement swheresis the rst statement of a compound statement.
.
spr nally tests the remaining repairs.
if two repairs have the same tier in the previous list their validation order is determined by the rank of the two corresponding original statements which the two repairs modify in the list returned by the error localizer.
.
experimental results we evaluate spr on a benchmark set containing defects and functionality changes drawn from eight large open source applications libti lighttpd the php interpreter gmp gzip python wireshark and fbc .
we address the following questions repair generation how many correct plausible repairs can spr generate for this benchmark set?
design decisions how do the various spr design decisions a ect the ability of spr to generate repairs?
previous systems how does spr compare with previous systems on this benchmark set?
.
methodology reproduce the defects changes for each of the eight applications we collected the defects changes test harnesses test scripts and test cases used in a previous study .
we modi ed the test scripts and test harnesses to eliminate various errors .
for libti we implemented only partially automated patch validation manually ltering the nal generated repairs to report only plausible repairs .
we then reproduced each defect change except the fbc defects changes in our experimental environment amazon ec2 intel xeon .6ghz machines running ubuntu64bit server .
.
fbc runs only in bit environments so we use a virtual machine with intel core .7ghz running ubuntu 32bit .
for the fbc experiments.
apply spr for each defect change we ran spr with a time limit of hours.
we terminate spr when either spr successfully nds a repair that passes all of the test cases or the time limit of hours expires.
to facilitate the comparison of spr with previous systems we run spr twice for each defect once without specifying a source code le to repair then again specifying the same source code le to repair as previous systems .
inspect repair correctness for each defect change we manually inspect all of the repairs that spr generates.
we consider a generated repair correct if the repair completely eliminates the defect exposed by the negative test cases so that no test case will be able to trigger the defect and the repair does not introduce any new defects.
we also analyze the developer patch when available for each of the defects changes for which spr generated plausible repairs.
our analysis indicates that the developer patches are consistent with our correctness analysis if our analysis indicates that the spr repair is correct then the repair has the same semantics as the developer patch and if our analysis indicates that the spr repair is not correct then the repair has di erent semantics from the patch.
we acknowledge that in general determining whether a speci c repair corrects a speci c defect can be di cult or in some cases not even well de ned .
we emphasize that this is not the case for the repairs and defects that we consider in this paper.
the correct behavior for all of the defects is clear as is repair correctness and incorrectness.
3previous systems require the user of the system to identify a source code le to patch .
this requirement reduces the size of the search space but eliminates the ability of these systems to operate automatically without user input.
spr imposes no such restriction it can operate fully automatically across the entire source code base.
if desired it can also work with a speci ed source code le to repair.
172table overview of spr repair generation results app loc testsdefects changesplausible correctinit timespr timespr wsf timesprspr genae sprspr genaewsf prog wsf prog libti 77k .4m .8m .0m lighttpd 62k .2m .0m .0m php 1046k .7m .5m .3m gmp 145k .5m .0m .5m gzip 491k .2m .5m .5m python 407k .1m .0m .8m wireshark 2814k .8m .5m .3m fbc 97k .0m 49m 32m total .
summary of experimental results table summarizes our benchmark set and our experimental results.
column app presents the name of the benchmark application.
column loc presents the size of the benchmark application measured in the number of source code lines.
column tests presents the number of test cases.
column defects changes presents the number of defects changes we considered in our experiments.
each entry is of the form x y where x is the number of defects and y is the number of changes.
each entry in column plausible spr is of the form x y where x is the number of defects and y is the number of changes for which spr generates a plausible repair.
column plausible spr wsf presents the corresponding numbers for spr running with a speci ed source code le to repair.
for comparison columns present the corresponding results for genprog and ae .4columns present the corresponding results for correct repairs.
even with no speci ed source code le spr generates plausible repairs for at least more defects than genprog and ae for spr vs. for genprog and for ae genprog and ae require the user to provide this information .
the genprog result tar le reports results from different genprog executions with di erent random seeds.
we count the defect as patched correctly by genprog if any of the patches for that defect is correct.
our results show that spr generates correct repairs for at least nine more defects than genprog and ae for spr vs. one for genprog and two for ae even when the target source le is not speci ed.
column init time in table presents the average time spr spent to initialize the repair process which includes compiling the application and running the error localizer.
column spr time presents the average execution time of spr on all defects changes for which spr generates repairs.
column spr wsf time presents the average execution time for the runs where we specify a source code le to repair.
when spr generates a repair it does so in less than two hours on average.
.
correct repair analysis when the target source le is not speci ed the spr repair search space contains correct repairs for defects changes.
table classi es these correct repairs.
the rst of these are the rst plausible repair that spr encounters 4due to errors in the repair evaluation scripts at least half of the originally reported patches from the genprog and ae papers do not produce correct results for the test cases in the test suite used to validate the patches .
see previous work on the analysis of genprog and ae patches for details .table spr repair type and condition synthesis results defect changerepair typecondition value search on o php replacey .3x php add inity .2x php replace printyz .5x php guarded controlyz .5x php add inity .8x php change condition yz .0x php delete .5x php change condition y4 .9x php redirect branchy .4x libti ee2ce5 b5691a add controlyz .1x gmp replaceyz .7x php add guardyz n a .9x php copyz n a .9x php change condition yz n a .0x php copy and replace yz n a .5x libti d13be ccadf change condition y n a .4x libti 5b021 3dfb3 replacey n a .5x gzip a1d3d4 f17cbd copy and replace yz n a .0x python delete n a .6x fbc change condition yz n a .8x during the search.
the classi cation highlights the challenges that spr must overcome to generate these correct repairs.
column defect change contains entries of the form x y z where x is the name of the application that contains the defect change y is the defective version and z is the reference repaired version.
modi cation operators column repair type presents the repair type of the correct repair for each defect.
add control indicates that the repair inserts a control statement with no condition.
guarded control indicates that the repair inserts a guarded control statement with a meaningful condition.
replace indicates that the repair modi es an existing non print statement using value replacement to replace an atom inside it.
replace print indicates that the repair replaces an existing print statement via staged repair.
copy and replace indicates that the repair copies a statement from somewhere else in the application using value replacement to replace an atom in the statement.
add init indicates that the repair inserts an initialization statement.
delete indicates that the repair removes statements this is a special case of the condition introduction in which the guard condition is set to false .
redirect branch indicates that the repair removes one branch of an if statement and redirects all executions to the other branch by setting the condition of the if statement to true or false .
change condition indicates that the repair changes a branch condition in a non trivial way unlike delete and redirect branch .
add guard indicates that the repair conditionally executes an existing statement by adding an if statement to enclose the statement.
a y in column indicates that the spr repair for this defect is outside the search space of genprog and ae out of the defects changes .
a z in the column indicates that the spr repair for this defect is outside the search space of par with the eight templates from the par paper out of the defects changes .
see our technical report for the analysis details.
condition synthesis each entry in column condition value search on is of the form x y. here y is the total number of repair schema applications that contain an abstract target condition.
x is the number of these schema applications for which spr discovers a sequence of abstract condition values that generate correct outputs for all test cases.
spr performs the condition generation search for only these x schema applications.
these results highlight the e ectiveness of spr s staged condition synthesis algorithm over .
of the schema applications are discarded before spr even attempts to nd a condition that will repair the program.
for all defects except php spr s condition generation algorithm is able to nd an exact match for the recorded abstract condition values.
for php310991 the correct generated condition matches all except one of the recorded values.
we attribute the discrepancy to the ability of the program to generate a correct result for both branch directions .
column condition value search o presents how many times more candidate repairs spr would need to consider if spr turned o condition value search and performed condition synthesis by simply enumerating and testing all conditions in the search space.
these results show that spr s staged condition synthesis algorithm signi cantly reduces the number of candidate repairs that spr needs to validate in some cases by a factor of over two orders of magnitude.
.
search space extensions the current spr repair space contains repairs for of the defects.
increasing the threshold of the error localization ranked list from to would bring a repair for an additional defect into the search space.
extending the spr condition space to include comparison operations would bring repairs for an additional two defects into the repair space.
extending the repair space to include repairs that apply two transformation schemas instead of only one as in the current spr implementation would bring repairs for another three defects into the space.
extending the copy and replace schema instantiation space to include more sophisticated replacement expressions would bring repairs for four more defects into the search space.
combining all three of these extensions would bring an additional six more defects into the search space.
repairs for the remaining defects require changes to or insertions of at least three statements.
all of these extensions come with potential costs.
the most obvious cost is the di culty of searching a larger space.
a more subtle cost is that increasing the search space may increase the number of plausible but incorrect repairs and make it harder to nd the correct repair.
it is straightforward to extend spr to include comparison operators.
the feasibility of supporting the other extensions is less clear.
.
limitations the data set considered in this paper was selected not by us but by the genprog developers in an attempt to obtain a large unbiased and realistic benchmark set .
nevertheless one potential threat to validity is that our results may not generalize to other defects and test suites.
spr applies one transformation at each time it generates a candidate repair.
it is unclear how to combine multiple transformations and still e ciently explore the enlarged space.
note that previous tools that apply multiple transformations produce only semantically simple patches.
the overwhelming majority of the patches are incorrect and equivalent to simply deleting functionality .
.
related work codephage horizontal code transfer automatically locates correct code in one application then transfers that code into another application .
this technique has been applied to eliminate otherwise fatal integer over ow bu er over ow and divide by zero errors and shows enormous potential for leveraging the combined talents and labor of software development e orts worldwide.
clearview clearview is a generate and validate system that observes normal executions to learn invariants that characterize safe behavior .
it deploys monitors that detect crashes illegal control transfers and out of bounds write defects.
in response it selects a nearby invariant that the input that triggered the defect violates and generates patches that take a repair action to enforce the invariant.
spr di ers from clearview in both its goal and its technique.
spr targets software defects that can be exposed by supplied negative test cases which are not limited to just vulnerabilities.
spr operates on a search space derived from its transformation schemas to generate repairs while clearview generates patches to enforce violated invariants.
genprog rsrepair ae and kali genprog uses a genetic programming algorithm to search a space of patches with the goal of enabling the application to pass all considered test cases.
rsrepair changes the genprog algorithm to use random search instead.
ae uses a deterministic search algorithm and uses program equivalence relations to prune equivalent patches during testing.
previous work shows that contrary to the design principle of genprog rsrepair and ae the majority of the reported patches of these three systems are implausible due to errors in the patch validation .
further semantic analysis on the remaining plausible patches reveals that despite the surface complexity of these patches an overwhelming majority of these patches are equivalent to functionality elimination .
the kali patch generation system which only eliminates functionality can do as well .
unlike genprog rsrepair and ae which only copy statements from elsewhere in the program spr de nes a set of novel modi cation operators that enables spr to operate on a search space which contains meaningful and useful repairs.
spr then uses its condition synthesis technique to e ciently explore the search space.
our results show that spr signi cantly outperforms genprog and ae in the same benchmark set.
the majority of the correct repairs spr generates in our experiments are outside the search space of genprog rsrepair and ae.
174par par is another prominent automatic patch generation system.
par is based on a set of prede ned humanprovided patch templates.
we are unable to directly compare par with spr because despite repeated requests to the authors of the par paper over the course of months the authors never provided us with the patches that par was reported to have generated .
monperrus found that par xes the majority of its benchmark defects with only two templates null pointer checker and condition expression adder remover replacer .
in general par avoids the search space explosion problem because its human supplied templates restrict its search space.
however the par search space with the eight templates in the par paper is in fact a subset of the spr search space.
moreover the di erence is meaningful the spr correct repairs for at least of our benchmark defects are outside the par search space see section .
.
this result illustrates the fragility and unpredictability of using xed patch templates.
semfix and minthint semfix and minthint replace the faulty expression with a symbolic value and use symbolic execution techniques to nd a replacement expression that enables the program to pass all test cases.
semfix and minthint are evaluated only on applications with less than lines of code.
in addition these techniques cannot generate xes for statements with side e ects.
repair model and repair shape martinez and monperrus propose to stage the program repair in three steps error localization selecting a repair shape and repair synthesis.
they also mine the past human repairs to obtain a probabilistic distribution of di erent repair shapes.
the spr transformation schemas in contrast enable spr to preliminarily validate the result candidate patch templates and signi cantly reduce the number of candidate patches spr needs to consider.
debroy and wong debroy and wong present a transformation based patch generation technique.
this technique either replaces an arithmetic operator with another operator or negates a condition.
in contrast spr uses more sophisticated and e ective transformations and search algorithms.
none of the correct repairs in spr s search space for the defects are within the debroy and wong search space.
nopol nopol is an automatic repair tool focusing on branch conditions.
it identi es branch statement directions that can pass negative test cases and then uses smt solvers to generate repairs for the branch condition.
a key di erence between spr and nopol is that spr introduces abstract condition semantics and uses target condition value search to determine the value sequence of an abstract condition while nopol simply assumes that the modi ed branch statement will always take the same direction during an execution.
in fact this assumption is often not true when the branch condition is executed multiple times for a test case e.g.
php and php .
in this case nopol will fail to generate a correct patch.
autofixe autofix e operates with a set of x schemas to repair ei el programs with human supplied speci cations called contracts.
spr di ers from autofixe in that it requires no speci cation and uses the staged program repair strategy to e ciently explore the search space.
deductive program repair deductive program repair formalizes the program repair problem as a programsynthesis problem using the original defective program as a hint .
it replaces the expression to repair with a synthesis hole and uses a counterexample driven synthesis algorithm to nd a patch that satis es a formal speci cation.
spr in contrast works with large real world applications where formal speci cations are typically not available.
domain speci c repair generation other program repair systems include vejovis and gopinath et al.
which applies domain speci c techniques to repair dom related faults in javascript and selection statements in database programs respectively.
spr di ers from all of this previous research in that it focuses on generating xes for general purpose applications without humansupplied speci cations.
failure oblivious computing failure oblivious computing checks for out of bounds reads and writes.
it discards out of bounds writes and manufactures values for out of bounds reads.
this eliminates data corruption from out of bounds writes eliminates crashes from out of bounds accesses and enables the program to continue execution along its normal execution path.
rcv rcv enables applications to survive null dereference and divide by zero errors.
it discards writes via null