see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation understanding the impact of refactoring on smells a longitudinal study of software projects conf erence paper august .
.
citations 84reads author s including diego cedrim amaz on publica tions citations see profile alessandr o gar cia pontific al catholic univ ersity of rio de janeir o publica tions citations see profile melina mongio vi feder al univ ersity of campina gr ande publica tions citations see profile rohit ghe yi feder al univ ersity of campina gr ande publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y diego cedrim on a ugust .
the user has r equest ed enhanc ement of the do wnlo aded file.understanding the impact of refactoring on smells a longitudinal study of software projects diego cedrim puc rio brazil dcgrego inf.puc rio.bralessandro garcia puc rio brazil afgarcia inf.puc rio.brmelina mongiovi ufcg brazil melina copin.ufcg.edu.br rohit gheyi ufcg brazil rohit dsc.ufcg.edu.brleonardo sousa puc rio brazil lsousa inf.puc rio.brrafael de mello puc rio brazil rmaiani inf.puc rio.br bal fonseca ufal brazil bal ribeiro ufal brazil marcio ic.ufal.bralexander ch vez puc rio brazil alopez inf.puc rio.br abstract code smells in a program represent indications of structural quality problems which can be addressed by software refactoring.
however refactoring intends to achieve different goals in practice and its application may not reduce smelly structures.
developers may neglect or end up creating new code smells through refactoring.
unfortunately little has been reported about the beneficial and harmful effects of refactoring on code smells.
this paper reports a longitudinal study intended to address this gap.
we analyze how often commonly used refactoring types affect the density of types of code smells along the version histories of projects.
our findings are based on the analysis of refactorings distributed in different types.
even though .
of the refactorings touched smelly elements did not reduce their occurrences.
surprisingly only .
of refactorings removed smells while .
induced the introduction of new ones.
more than of such refactoringinduced smells were not removed in successive commits which suggest refactorings tend to more frequently introduce long living smells instead of eliminating existing ones.
we also characterized and quantified typical refactoring smell patterns and observed that harmful patterns are frequent including i approximately of the move method andpull up method refactorings induced the emergence of god class and ii the extract superclass refactoring creates the smell speculative generality in of the cases.
ccs concepts software and its engineering software evolution keywords refactoring code smells structural quality permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
reference format diego cedrim alessandro garcia melina mongiovi rohit gheyi leonardo sousa rafael de mello bal fonseca m rcio ribeiro and alexander ch vez.
.
understanding the impact of refactoring on smells a longitudinal study of software projects.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction code smells represent indications of software structural problems in a program .
several types of code smells are recognized as critical by software developers .
examples of such smell types include god class long method andspeculative generality .
thus code smells may suggest structures in the source code that require refactoring .
refactoring is a common practice employed by practitioners along software maintenance .
refactoring is a program transformation used for improving the structure of a program while preserving its observable behavior .
examples of commonly applied types of refactoring involve i restructuring or moving class members such as extract methods move method andpull up method and ii extracting new elements such as extract superclass andextract interface .
the goals of refactoring widely vary in practice .
refactoring goals include combating design degradation reducing maintenance effort and facilitating feature additions or bug fixes .
in order to achieve these goals developers apply two tactics during refactoring namely root canal refactoring andfloss refactoring .
root canal refactoring is used for strictly improving the source code structure and consists of pure refactoring.
floss refactoring consists of refactoring the code together with non structural changes as a means to reach other goals such as adding features or removing bugs.
independently of refactoring tactic employed the increase of code smells in a program is harmful.
the increased density of code smells often relates to design degradation fault proneness and higher maintenance effort .
however as floss refactoring is often applied developers may often end up introducing rather than reducing code smells.
even in situations 465esec fse september paderborn germanyd.
cedrim a. garcia m. mongiovi r. gheyi l. sousa r. de mello b. fonseca m. ribeiro and a. ch vez where root canal refactorings are performed developers may either fail to remove a smell or introduce new ones.
unfortunately the impact of refactoring on smells is rarely investigated in depth.
to the best of our knowledge there is no study that thoroughly characterizes both positive and negative effects of refactoring on code smells.
only recently bavota et al.
performed a study aiming to investigate if refactoring tends to remove code smells in the context of some major versions of only three software projects.
however they could not reveal to what extent and which types of refactorings often increase rather than decrease code smells in a program.
moreover they did not make a distinction between root canal and floss refactoring in their analyses.
finally given the nature and size of their sample they could not characterize recurring relationships between refactoring and smell types.
thus we conduct a longitudinal study that analyzes both the beneficial and negative impact of refactoring changes on the density of smells.
we analyze not only if refactoring reduces smells but also if and to what extent specific types of refactoring are often related to the introduction of new smells.
instead of being limited to the analysis of a few major versions in a few projects we consider versions distributed among open source projects.
we classify each refactoring instance according to its interference on the existing and new smells located in the refactored elements.
in our study we classify a given refactoring instance in one of the three cases i positive if the absolute number of smells in the elements decreases after the program transformation ii negative if it increases or iii neutral if it remains the same.
this classification is used to analyze whether certain refactoring types tend to improve or decrease the smelly structure of a program.
this analysis was also performed in samples of root canal and floss refactorings.
we identified and analyzed refactorings classified in commonly used refactoring types.
thirteen code smell types are used to classify the collected refactorings.
these code smell types were selected because they are conceptually associated with the definition of the refactoring types i.e.
the definition of each refactoring type is explicitly associated with one or more code smells addressed in our study.
surprisingly our study revealed that either neutral or negative effects of software refactoring are much more frequent than positive effects.
in particular we derived the following new findings as compared to previous studies.
refactorings often touch smelly elements but they are neutral.
the aforementioned study found of the refactorings touched smelly elements in their smaller sample.
we observed a higher frequency in our sample approximately of the refactorings touched smelly elements.
this frequency was consistent across the majority of the refactoring types.
moreover of the refactorings are neutral.
surprisingly even root canal refactorings often did not reduce the density of code smells in the refactored elements.
these findings suggest developers need more guidance to remove a code smell once they start restructuring a smelly element.
stinky refactorings.
we found .
of refactorings are stinky i.e.
they were negative refactorings which were related to the introduction of new smells.
such refactorings occurred three times more frequently than positive ones.
only .
of refactorings removed smells.
we also concluded that more than of refactoringinduced smells were not removed afterwards in successive commits.
stinky refactorings were also surprisingly frequent in root canalrefactorings i.e.
when developers perform pure refactoring.
these findings shed light on how refactorings if intended to improve program structure or not may degrade the smelly structure of a program.
in particular it seems developers should be at least warned of smells being introduced along root canal refactorings.
harmful refactoring smell patterns.
we characterized and quantified recurring patterns related to the beneficial neutral and harmful effects of specific refactoring types on code smells.
harmful patterns were more frequent than beneficial ones.
for instance refactorings intended at moving methods such as move method andpull up method tended to induce the emergence of god class in the target class without removing smells in the source class.
the move method refactoring induced the emergence of god classes in of the cases while the pull up method tended to be related to this smell type in of the cases.
several other types of refactoring were surprisingly often related to smells emerging after the transformation.
for instance the extract superclass refactoring creates thespeculative generality smell in of the cases.
this work is organized as follows section provides basic concepts.
section presents the study planning.
sections and present our results.
section describes the threats to validity.
section relates our study with previous work.
section concludes the study.
concepts and motivation a smell is a surface indication that usually corresponds to a deeper structural problem .
for instance a class with several responsibilities is known as god class .
this smell makes the class hard to read modify and evolve.
let us suppose a person class that has amongst many other members at least three attributes representing two loosely coupled concepts person and telephone number.
this structure of person can be considered a god class .
in order to remove this smell the developer can extract part of the class structure into another class telephonenumber .
after this transformation called extract class refactoring the program no longer has the god class and still realizes the same functionality.
after this refactoring the number of code smells would be reduced.
however it might be not always the case that refactorings are successful in removing smells.
even worse a new code smell can be introduced by refactoring.
for instance suppose that a developer tried to generalize the person class.
so he applied an extract superclass refactoring in the person class creating its superclass called livingbeing .
however this generalization was never explored so the developer created a smell called speculative generality via refactoring.
there has been little effort to characterize these occasions which happen on a non ignorable frequency as we can observe in section .
.
.
refactoring classification this section presents a scheme to classify each refactoring instance by computing the number of smells introduced or removed along the refactoring changes.
let s s1 sn be a set of software projects.
each software shas a set of versions v s v1 vm .
each version vihas a set of elements e vi e1 representing all methods classes and fields belonging to it.
in the previous section the set s phonebook represents a software system called phonebook .
this software has two versions 466understanding the impact of refactoring on smells a longitudinal study of software projects esec fse september paderborn germany v phonebook v1 v2 wherev1is the version before the refactoring and v2 after.
finally each version vihas a set of elements e vi .
for instance e v2 is composed of person andtelephonenumberclasses section including their methods and fields.
in order to be able to detect refactorings we must analyze transformations between each subsequent pair of versions.
in this way we assume ris a refactoring detection function where r vi vi r1 rt1 e1 rk rtk ek gives us a set of tuples composed of two elements the refactoring type rti and the set of refactored elements represented by ei.
so the function rreturns the set of all refactorings detected in a pair of versions.
thus r v1 v2 r1 extract class e1 where e1 person telephonenumber .
refactored elements.
in this work we consider as refactored elements all those directly affected by the refactoring.
for instance let us consider the move method refactoring.
in this refactoring type a method mis moved from class atob.
hence the considered refactored elements in this case are m a b .
all callers of m are indirectly affected by this refactoring but we do not consider them as refactored elements.
similar reasoning applies to the other refactoring types thus for each refactoring type a different set of refactored elements is used.
the complete list of what is considered refactored elements for all refactoring types is available at .
csis a code smell detection function where cs ei cs1 returns a set of code smells present in a set eiof software elements.
we only analyze code smells related to the refactored elements.
in this way we can say that csb ei is the set of code smells of eibefore the application of the refactoring r. on the other hand csa ei is the set of code smells found after the application of r. considering the aforementioned r1refactoring we have csb person god class csa person telephonenumber .
positive neutral and negative refactorings.
using data collected by the functions defined before it is possible to classify a refactoring by looking how it interferes in existing code smells.
suppose eiis a set of software elements ris a refactoring and csb ei x. after rrefactoring csa ei y. depending on xandy it is possible to classify r. ifx y rreduced the number of smells on eiand because of that ris considered a positive refactoring .
otherwise if x y rincreased the number of smells onei thus ris anegative refactoring .
when x y ris aneutral refactoring .
for instance csb e1 1and csa e1 .
thus ther1refactoring performed in phonebook system is a positive one.
.
refactoring smell patterns we determine the relationship between each refactoring instance on the removal or addition of a code smell.
moreover the refactoring classification process can also reveal to what extent and which types of refactorings often increase rather than decrease the number of code smells in software projects.
this classification enables us to characterize recurring relationships between code smells and refactorings.
for instance if the move method refactoring introduces god class frequently is possible to infer that there is a pattern governing these two types.
we use a threshold based rule to state a relation between refactoring and smell types as patterns .
letk r1 r2 rn be the set of all detected refactorings after analyzing the set s. thus kr tis the subset of kof refactorings of the type rt.
the set k r t csis the ksubset composed of refactoringsof the type rtthat added code smells of type csin any refactored element while k r t csis the ksubset that removed code smells of type cs.
finally k r t csis the ksubset composed of refactorings of the type rtthat satisfies the following conditions i the refactoring was applied in classes or methods containing at least one code smell instance of the type cs and ii the refactoring did not remove the instance of the code smell of cstype.
applied in smelly code.
eis a smelly element if and only if cs e .
consider r rt e .
we say rwas applied in program elements hosting at least one code smell if any element belonging toeis a smelly element i.e.
risapplied in smelly code if and only if there is a code smell of any type in the refactored elements .
creational patterns.
the definition of creational pattern between types of code smell and refactoring can be established using the above notation.
a creational pattern occurs when a specific refactoring type involves code transformations that often introduces a specific code smell.
we define this concept as a thresholdbased rule.
if k r t cs kr t is possible to affirm that there is a creational pattern between rtandcs.
this kind of pattern captures scenarios where developers apply a refactoring and somehow end up creating at least one new code smell.
thus creational patterns represent cases of stinky refactorings.
removal and non removal patterns.
the definition of removal pattern also lies in a threshold based rule.
if k r t cs kr t we can affirm that there is a removal pattern between rtandcs.
it means that developers consistently removes instances of cswhen performing rtrefactorings.
we are also interested in studying what types of code smells are commonly present in classes and methods and somehow end up remaining in the source code after refactoring.
this third type of pattern is called non removal pattern and it is defined by another threshold based rule k r t cs kr t .
study planning this section presents the study planning.
.
research questions software refactoring might interfere in the presence of code smells.
as illustrated in section the number of code smells located in refactored elements should be ideally reduced.
therefore our study aims at addressing the following research question rq1.
does refactoring reduce the density of code smells?
we address this question by relying on the classification of each refactoring detected in real projects.
this procedure enables us to compute how frequent each refactoring classification occurs across the projects.
first all instances of refactorings and code smells present in a set sof software were detected.
then all refactoring instances were classified according to section .
.
also we divided the refactorings into root canal and floss refactoring section .
.
.
letpthe number of refactorings classified as positive nthe number of negative refactorings and krepresenting the number of neutral refactorings.
if n pandn k we can state that the application of refactorings are likely increasing the number of code smells of projects.
otherwise if p nandp k the answer to our research question is yes refactorings tend to remove code smells.
another 467esec fse september paderborn germanyd.
cedrim a. garcia m. mongiovi r. gheyi l. sousa r. de mello b. fonseca m. ribeiro and a. ch vez possible case is when k pandk n. in this scenario refactorings would tend to neither introduce nor remove code smells.
it is also important to understand and distinguish the impact of specific refactoring types on code smells.
some types of refactoring might consistently remove or fail to do so or even frequently introduce specific smell types across software projects.
section .
defined three categories of possible patterns between types of refactoring and smells.
discovering these patterns is the focus of our second research question rq2 what are the patterns governing types of refactoring and code smells?
by answering rq2 we are able to reveal harmful actions made by developers on refactored elements.
we detect removal non removal and creational patterns by analyzing the impact of refactoring types on smells located in the refactored elements.
the knowledge about non removal and creational patterns make developers informed about the possibilities and risks of missing and introducing certain smells along either root canal or floss refactorings.
.
study phases this section presents all phases of the study design.
.
.
phase selection of software projects.
the first step of this study is to choose a set sof software projects to compose the study sample.
first we established github the world s largest open source community as the source of software projects.
we focused our analysis on open source projects so that our study could be easily replicated and extended.
this study uses github projects that met the following quality criteria i high popularity i.e.
among the projects with most stars ii active issue tracking system i.e.
users actively use the github issue management system for bug reporting and improvement suggestions iii has at least of the code repository effectively written in java.
the full list of selected projects is in table .
this table presents the i name ii lines of code and iii number of commits for each project.
.
.
phase smell and refactoring detection.
this phase is in charge of detecting refactorings in all subsequent pairs of versions viandvi .
it also encompasses the detection of all smells in each versionvi v s .
these activities are described in the following.
refactoring detection.
we choose refactoring miner to support the detection of refactoring instances.
this tool implements a lightweight version of umldiff algorithm for differencing object oriented models.
the precision of .
reported by tsantalis et al.
led to a very low rate of false positives as confirmed in our validation phase section .
.
.
this tool supports the detection of refactoring types which are amongst the ones reported by murphy hill et al.
as the most common refactoring types.
all refactoring types detected by refactoring miner were considered in this study except the rename method refactoring.
we discarded this refactoring type as it was not directly related to one of the code smells addressed in our study.
refactoring miner gives us as output a list of refactorings r vi vi r1 rk as defined before where kis the total number of refactorings identified.
code smell detection.
code smells are often detected with rule based strategies .
each strategy is defined based on a setof metrics and thresholds.
therefore the application of rule based strategies requires the collection of metrics for all source files in a project.
after the collection of metrics we apply a set of previously defined rules to detect code smells.
this procedure is the implementation of csfunction defined in section .
.
the specific metrics and thresholds for code smell detection were defined in .
these rules were used because i they represent refinements of well known rules proposed by lanza et al.
which are well documented and used in previous studies e.g.
and ii they have on average precision of .72and recall of .
.
these rules detect five code smells god class long method feature envy shotgun surgery anddivergent change .
table shows examples of rules used to identify code smells.
the rules use the following metrics i lines of code loc ii coupling between objects cbo iii number of methods nom iv cyclomatic complexity cc v lack of cohesion of methods lcom vi fan out fo and vii fan in fi.
we also considered eight additional smell types complex class lazy class long parameter list message chain refused bequest spaghetti code speculative generality and class data should be private .
the selection of these smell types was due these code smells are very common and tend to be related to design degradation symptoms .
another reason to select these smell types was their direct relation with the most frequent refactoring types .
murphy hill et al.
reported the refactorings often performed table projects used name loc commits alibaba dubbo androidbootstrap android bootstrap apache ant argouml elastic elasticsearch facebook facebook android sdk facebook fresco google iosched google j2objc junit team junit4 netflix hystrix netflix simianarmy orhanobut logger philjay mpandroidchart prestodb presto realm realm java spring projects spring boot spring projects spring framework square dagger square leakcanary square okhttp square retrofit xerces total 468understanding the impact of refactoring on smells a longitudinal study of software projects esec fse september paderborn germany by developers and we analyzed which code smell types these refactorings may intend to remove .
refactoring miner is capable of detecting the refactoring types that remove these smells.
we implemented a tool to detect all the types of code smells .
in addition to the rules presented in table we also implemented all rules proposed in a recent study .
these rules detect the eight additional types of code smells.
the complete list of the rules and the tool we implemented are available in our study s website .
table rules for code smell detection code smell detection rule god class or long method loc and cc shotgun surgery cc and fo divergent change fi and lcom and cc feature envy fo and lcom and cc rules for detecting smells play a central role in our study.
thus we must guarantee that our results are not biased by a single set of detection rules.
different thresholds can lead to different results .
therefore choices of thresholds can pose a threat to this study.
thus two sets of thresholds were used to mitigate this menace.
the first set known as tight set represents the thresholds previously validated in the study by macia et al.
.
we named this strategy astight because it relies on the use of high threshold values aiming to detect only critical code smells across the projects.
the second strategy named as relaxed uses relaxed thresholds designed to detect as many smells as possible.
in addition to the two previously mentioned tight and relaxed set of thresholds we also used the detection rules proposed by bavota et al.
.
.
.
phase refactoring classification.
the objective of the third phase is to classify all refactorings detected in the prior phase.
we classified each detected refactoring by observing its interference in the number of code smells.
after this classification it is possible to quantify how frequent refactorings are labeled according to each possible category in our software set s. as mentioned in section .
.
all projects are git repositories stored on github servers.
the data collection process starts by cloning a git repository.
this study considers as a version every commit in the repository.
we skipped merge commits during the analysis since this kind of commit could lead us to compute twice the same refactoring .
the algorithm always compares subsequent versions of the projects.
let us suppose a project that has only three commits and .
in this project the r function would be computed for the following pairs r and r .
the set v s of a git repository sis the list of all non merge commits in the master branch ordered chronologically.
root canal vs. floss refactoring.
there are two tactics of refactoring i root canal refactoring and ii floss refactoring.
during floss refactoring the programmer uses refactoring as a means to reach a specific end such as adding a feature or fixing a bug.
root canal refactoring in contrast is used for solely improving code structure and involves a process consisting of exclusive refactoring.
in this way this study comprises a manual inspection of arandomly selected sample of refactorings.
in this manual inspection we evaluate if a refactoring is root canal or floss.
we analyzed manually whether the changes performed during the refactoring do not modify the behavior.
we classify a transformation as floss when we identify behavioral changes such as an addition of methods or changes in a method body not related to refactoring transformations.
when no behavioral changes are detected we classify the refactoring as root canal.
this manual inspection will enable us in revealing the percentage of positive negative and neutral effects in the context of both root canal and floss refactorings section .
this inspection was performed by three researchers.
two of them are very experienced refactoring researchers.
the most experienced one solved the conflicts.
we found that developers apply root canal refactoring in .
of the cases.
the confidence level for this number is with a confidence interval of .
.
.
phase manual validation.
the last phase is responsible for all data validation.
as the first three phases rely on tools to detect refactorings and code smells there is a threat to validity related to false positives and negatives yielded by these tools.
to mitigate this threat the fourth phase is required.
in this phase a manual procedure was executed in a smaller dataset.
a manual validation of each output was made in this phase to ensure the reliability of our data.
in this vein we conduct different data validation activities.
we randomly sampled refactorings from each type to support the analysis.
we decided to sample by the refactoring types since the precision of the refactoring miner could vary due to the rules implemented in the tool to detect each refactoring type.
to ensure an acceptable confidence level in the results we calculated the sample size of each refactoring type based on a confidence level of and a confidence interval of points.
we used such confidence to all sampling activities performed in this study.
we recruited ten undergraduate students from another research group to also analyze the samples.
the samples were divided into ten disjointed sets and each student validated a different one.
in general it was observed a high accuracy for each refactoring type with a mean of .
.
details can be found in the study s website .
refactoring and smells this section presents and discusses the data used to answer the first research question.
the refactoring detection procedure identified refactorings.
table presents the refactoring types ordered by the number of their occurrences across the projects analyzed.
the first column shows each refactoring type followed by the corresponding number of its occurrences second column in all projects analyzed.
the most common refactoring type is extract method similarly to a previous study that analyzed refactoring frequencies in other systems .
table confirms most of the other refactoring types also occur frequently in our sample.
most refactorings touch smelly elements.
before addressing rq1 we first analyze the frequency of refactoring types that touch smelly elements.
thus we also compute how many times each type of refactoring was applied in smelly code section .
.
the results are shown in the third column in terms of both absolute number of occurrences and percentages in brackets .
we can observe that developers tend to often apply refactorings in smelly elements of a 469esec fse september paderborn germanyd.
cedrim a. garcia m. mongiovi r. gheyi l. sousa r. de mello b. fonseca m. ribeiro and a. ch vez table the impact of common refactorings types refactoring type occurences applied in smelly code neutral negative positive extract method .
.
.
.
move field .
.
.
.
inline method .
.
.
.
move method .
.
.
.
pull up method .
.
.
.
pull up field .
.
.
.
extract superclass .
.
.
extract interface .
.
.
push down method .
.
.
.
push down field .
.
.
.
totals .
.
.
program.
seven refactoring types have been applied in smelly code elements in more than of the occurrences .
one could wonder if many elements are tagged as smelly in the analyzed programs thereby increasing the probability of refactorings often touching smelly elements.
then we computed the probability of randomly choosing a smelly element in our dataset smelly elements all elements which is .
.
this low probability shows that in our dataset refactorings did not target smelly elements by coincidence.
refactorings indeed tend to concentrate on smelly elements which were confined to a vast minority of the program elements.
this behavior was consistently observed for both root canal and floss refactorings.
.
smell neutral refactorings are common the three last columns of table present respectively the incidence rate of neutral negative and positive refactorings.
surprisingly the neutral classification was the most frequent one for refactoring types namely move field inline method move method pull up method pull up field push down method and push down field .
even though refactorings are frequently applied in smelly elements they often do not reduce the smells.
the data presented in table was produced with smell detection strategies based on a set of tight thresholds.
to make sure our findings were not biased by this particular set of thresholds we have also classified the refactorings using relaxed thresholds.
finally we have also used another set of detection strategies the same used by bavota et al.
.
figure shows the general proportion of neutral positive and negative refactorings using all these three classification methods labeled as tight relaxed andbavota .
an analysis of figure confirms there is indeed a general trend independently of the smell detection strategy neutral refactorings are much more frequent than positive and negative refactorings.
when we analyze each individual project the same classification distribution is observed i.e.
neutral refactorings represent the vast majority in all the projects.
in our manual validation section .
.
we found that .
of the refactorings are root canal.
even when this tactic is applied refactorings often do not reduce the density of code smells in the refactored elements.
these findings suggest developers need more guidance to remove a code smell once theystart restructuring a smelly element i.e.
when they perform rootcanal refactorings.
.
stinky refactorings surprisingly .
of the refactorings were found to be stinky they are related to an increase of smells in the refactored elements.
moreover when we analyzed the commits performed after the negative refactorings we also concluded that more than of refactoring induced smells were not removed afterwards.
only .
of refactorings removed smells according to table .
negative refactorings were more frequent than positive refactorings according to our three classification methods presented in figure .
stinky effects are more frequent than positive ones in the context of both root canal and floss refactorings as well.
negative refactorings were more frequent than neutral ones in the context of three refactoring types extract method extract superclass and extract interface .
interestingly extract method is the most frequent type of refactoring .
section discusses different patterns involving this refactoring type.
moreover the refactorings that involve multiple changes in a class hierarchy such asextract superclass andextract interface tend to be negative.
this fact might indicate developers need more guidance on refactoring class hierarchies even in the context of root canal refactoring.
these results enable us to answer rq1 refactorings made by developers in real projects often do not remove code smells.
on the contrary most of the refactorings are neutral or stinky.
this observation also prevails if we only consider refactoring types that according to their description in fowler s catalog are explicitly associated with specific code smell types addressed in our study.
for instance the mechanics for applying move method pull up method andmove field refactorings are associated with smells that represented methods or fields that are misplaced.
the misplacement of these members are captured by occurrences of either feature envy divergent change shotgun surgery orgod class .
our data suggest that most refactorings do not remove smells even in the context of root canal refactorings.
there are possible interpretations of this finding.
first critical design problems in a program may not be related to code smells.
if so this fact may explain why developers either neglect or introduce code smells 470understanding the impact of refactoring on smells a longitudinal study of software projects esec fse september paderborn germany figure results of the data collection phase through refactoring.
however previous studies indicate that design problems are often located in modules containing two or more code smells.
second similarly to previous studies we use metrics and thresholds to detect all smells.
the proper choice of metrics and thresholds may be sensitive to particular developers and other project specific factors .
as a consequence our detection of code smells may not reflect what developers truly consider as smells.
however our previous studies involving developers suggest that heuristics used by developers are often not essentially different from smell detection strategies adopted in our study.
our understanding is that refactoring indeed ignores or introduces technical debt in the source code.
finally it may be the case that our set of studied refactoring types are not among those used by developers to actually remove design problems.
still it is troublesome that developers introduce smells through refactoring regardless its type and tactic.
refactoring smell patterns in order to address our second research question we analyzed what are the patterns emerging from the relationship between refactorings and smells.
section .
defines three categories of such patterns i.e.
removal non removal and creational patterns.
section .
focuses on discussing the removal and non removal patterns while section .
discusses the creational i.e.
stinky patterns.
we will focus on discussing patterns in which more than of the instances of a refactoring type was related to instances of a specific smell type.
for these patterns we inspected all the pattern instances in order to understand what happened in each case.
in particular we also confirmed whether the refactoring was directly related to the removal or introduction of the smell.
this was an important step as we had pattern instances occurring in the context of either root canal refactoring or floss refactoring.
for the non removal and creational patterns we also analyzed the lifetime of the prevailing and introduced smells related to the non removal and creational patterns.
we checked if such smells prevailing or emerging in commits involving one or more refactorings were either removed or not in subsequent commits.
we considered subsequent commits all those ones performed until the last commit of each project.
therefore we were able to identify precisely when a particular code smell was removed.
our goal was to understand whether the refactoring related smell was or not temporarily prevailing in the code because the developer was planning to remove the smell in the next commits.
.
removal vs. non removal patterns table presents the cases of removal and non removal patterns observed.
they are alphabetically ordered by the refactoring type.
each row represents a removal and or non removal pattern involving a pair of refactoring type and smell type.
the first column shows the refactoring type followed by the smell type in the second column.
the next two columns present for each refactoring type the percentage of its instances related to the removal fourth column or prevalence third column of the corresponding code smell.
patterns with an incidence strength higher than are shown in bold.
the last column presents the percentage of root canal refactoring for each pattern.
for instance the first row informs that .
of theextract interface refactorings related to god class either by non removal or removal pattern are root canal refactoring.
at a first glance it is already possible to observe there was a much higher incidence of non removal patterns than removal ones.
the percentages of non removal patterns third column are often higher than their removal counterparts.
thus we can also conclude there are specific types of refactorings tending to consistently affect a particular type of smell.
however those refactorings more frequently are unsuccessful non removal rather than successful removal with respect to that particular smell type.
for instance extract method refactoring was often targeted at methods hosting afeature envy smell.
however as expected most of those extract method refactorings could not remove this smell.
table shows .
against of such refactorings touched this smell but they were not able to eliminate it.
after analyzing these pattern instances we confirmed that proper action of developers should also include moving not only extracting those feature envy smells as methods to other classes.
however the vast majority of those extracted methods higher than of its instances were neither moved to neighbor classes in subsequent commits.
in fact those of successful extract method refactorings were performed in conjunction with other method moving refactorings in the same commit such as move method pull up method orpush down method refactorings.
another interesting observation is that the god class smell was the most frequent target of removal or non removal refactorings.
in fact this smell dominates the rows of table .
several refactoring types were often related to changes moving out members from god class smells.
two of the refactoring types namely move method and move field refactorings were significantly successful in contributing to the removal of a god class smell within a commit.
however even for these refactoring types there was higher incidence of non removal patterns.
table shows .
and .
of move method and move field refactorings touched god class smell but were not sufficient to eliminate it independently if 471esec fse september paderborn germanyd.
cedrim a. garcia m. mongiovi r. gheyi l. sousa r. de mello b. fonseca m. ribeiro and a. ch vez they were part of root canal or floss refactorings.
those refactorings were often performed in conjunction with other member moving refactorings in the same commit but were not sufficient to remove god classes .
in of the cases the prevailing god class smell were not removed in the successive commits either.
there were only two refactoring smell patterns that more predominantly removed rather than not the code smell.
they were patterns involving thepush down method refactoring and lazy class smell and refused bequest smell .
we can observe a non ignorable frequency of root canal refactorings spread across the patterns in table .
even when the root canal frequency is as high as the developers are not able to remove the code smell.
since the refactorings belonging to the patterns could be just the first step towards the code smell removal we computed the code smells lifetime after the refactoring.
in of the cases the code smells were not removed.
this shows that even when developers refactor purely to improve the code structure root canal they do not succeed on removing the code smells.
table removal and non removal patterns refactoring code smell non removal removal root canal extract interface god class .
.
extract method divergent change .
extract method feature envy .
.
extract method god class .
.
move field god class .
move method god class .
.
pull up field god class .
.
pull up method god class .
.
push down field god class .
.
push down method god class .
.
push down method lazy class .
.
push down method refused bequest .
.
creational patterns interesting data also emerged from creational patterns detected in our dataset.
we divided these patterns into three groups considering the purpose of the refactoring type i refactorings targeted at improving generalization ii refactorings responsible for moving features between objects and iii refactorings targeted at restructuring members of a class.
the following subsections respectively present and discuss creational patterns involving refactorings in these groups.
table presents all creational patterns found with the same structure presented in table .
.
.
generalization patterns.
refactorings dealing with generalization were often related to the creation of god class and speculative generality smells.
we can observe in table that pull up method and pull up field refactorings are related to the creation ofgod class smells in and of the cases respectively.
extract superclass refactoring creates the speculative generality smell in of the cases while of the pull up field refactoring instances introduce this same smell in the target superclass.
what is more troublesome was the fact that more than of such introduced smells were not removed in successive refactorings.
a typical example of generalization related creational pattern can be illustrated by the case involving the defaultprojectlistener class from the xerces project commit 002901b .
the defaultprojectlistener class is the default implementation of a listener thattable creational patterns refactoring code smell creational root canal extract method divergent change .
.
extract method feature envy .
.
extract superclass lazy class .
.
extract superclass refused bequest .
extract superclass spec.
generality .
move method complex class move method god class .
move method lazy class pull up field god class .
pull up field spec.
generality .
.
pull up method god class .
.
pull up method spaghetti code .
emulates the old ant listener notifications.
extract superclass refactoring was applied on defaultprojectlistener class thereby creating the abstractprojectlistener class from it.
however the new abstract class did not seem to justify the refactoring.
there was only one class that extended abstractprojectlistener class i.e.
the defaultprojectlistener class itself.
thus the refactoring created the abstractprojectlistener class with a speculative generality smell.
moreover this refactoring had another negative consequence on the affected classes as it introduced another code smell.
the defaultprojectlistener class overrides all the methods defined on the abstractprojectlistener class.
consequently the defaultprojectlistener class became affected by a refused bequest smell.
one of the reasons for this problem is that all the bodies of the methods defined on the abstractprojectlistener class are empty they do not have any implementation.
ideally the abstractprojectlistener abstract class should have been instead defined as an interface.
moreover all these smells were not removed in successive commits thereby affecting other listener subclasses created latter.
therefore in this example the extract superclass refactoring is responsible for creating an instance of a generalization related creational pattern and propagating a smelly structure to other classes.
.
.
feature moving patterns.
refactorings aiming at moving features between objects were also part of our catalog of detected creational patterns.
move method refactorings were related to the creation of three types of smells.
this refactoring created god class complex class and lazy class smells in and of the cases respectively.
interestingly this type of refactoring was amongst the most common ones in a previous study .
when analyzing all these pattern instances we confirmed that developers were consistently creating smells through move method refactorings in the target classes i.e.
those receiving the moved methods without removing those smells in the source classes.
again the vast majority of these introduced smells more than prevailed in the successive commits.
this observation shows that tooling support should warn developers about the risks related to such recurring creational patterns.
a typical case of creational feature moving pattern can be illustrated by refactoring changes affecting two classes from the argouml project.
the generatemessagenumber method was moved 472understanding the impact of refactoring on smells a longitudinal study of software projects esec fse september paderborn germany from the generatordisplay class to the messagenotationuml class.
before the refactoring the generatordisplay class had three types of code smells namely god class complex class andrefused bequest smells.
on the other hand the messagenotationuml class had only one code smell refused bequest .
after the refactoring the messagenotationuml class received the other three types of code smells that were affecting the generatordisplay class.
however the generatordisplay class continued having the three types of code smells.
that is in addition to introducing code smells in the target class move method refactoring did not remove the code smells from the source class.
to make matters worse move method refactoring also introduced a fifth type of code smell that was not affecting any one of the both classes before.
it introduced a spaghetti code smell since the moved method interacts through a method call with an existing method of the messagenotationuml class that was long in terms of loc .
this move method refactoring instance is a critical one since it is responsible for creating two out of three relevant code smells god class and complex class smells and it is also responsible to introduce the spaghetti code smell.
.
.
method extraction patterns.
in the last category we only found creational patterns involving the extract method refactoring.
this refactoring type was often related to the creation of two types of smells divergent change smell in of the cases and feature envy smell in of the cases.
however when we analyzed these pattern instances we observed that most of them occurred in the context of i floss refactorings or ii composite root canal refactorings.
therefore extract method refactoring was often not the only factor potentially contributing to the emergence of those code smells.
still the high incidence of such creational patterns may warn developers that extract method refactorings should be often followed by move method refactorings in order to eliminate possibly prevailing feature envy ordivergent change smells.
thefixcrlf class from the apache ant project had the complex class smell.
also the execute method from this class had two code smells namely feature envy andlong method smells.
this method had two functionalities executing a scanning task on a source code folder and processing files found in the folder.
through the extracted method refactoring the execute method was split into a second method called processfile .
after the refactoring the execute method had only the feature envy smell while the processfile method kept both smells feature envy and long method smells.
however it was also introduced a divergent change smell in the processfile method.
furthermore it was introduced another code smell in thefixcrlf class.
after the refactoring it also had a spaghetti code smell.
in this example the extracted method refactoring was responsible for creating an instance of a method extraction pattern.
also this refactoring contributed to introduce a code smell at class level spaghetti code which did not exist in the class before the refactoring and together with the complex class smell they can decrease the reusability of the system.
table presents the percentage of root canal refactorings for each creational pattern.
considering all instances involved in those patterns .
are root canal refactorings.
this is an alarming rate.
developers introduce smells when refactoring even when they are performing solely structural improvement activities.
to make the matter worse this behavior occurs consistently between specificrefactoring smell pairs.
this non tolerable rate presented indicates developers might need proper support during refactoring to avoid structural degradation even when they clearly want to improve the structure via root canal refactoring.
threats to validity internal validity.
the data collection using the refactoring miner represents a threat to internal validity because it may find false positives.
to minimize this threat and check the tool s precision we randomly select a sample of refactorings and manually validate them.
section .
.
presents the procedure used to estimate the precision of this tool in our dataset.
we observed a high precision for each refactoring type with a median of .
.
the precision found in all refactoring types are close to the standard deviation .
.
by applying the grubb outlier test alpha .
we could not find any outlier indicating that no refactoring type is strongly influencing the median precision found.
thus the results found in the sample analyzed represent a key factor to provide confidence in the results reported in this work.
we could not reach the developers to ask their intentions rootcanal or floss in all refactorings detected.
therefore we performed a manual validation analysis to check whether each refactoring instance was part of a root canal or floss refactoring.
this manual validation also represents a threat to internal validity.
to mitigate this threat part of the sample was validated by two researches.
the third researcher solved cases of conflict.
external validtiy.
the selection of subjects in empirical studies is a recurrent external threat to validity.
we mitigate this threat by establishing a process to sample a set of valid projects randomly from github.
as a result we yield relevant java projects with an interesting diversity of structure and size.
moreover we also included in the sample the three projects used by bavota et al.
so that we could contrast our findings with theirs section .
related work elements touched by refactoring.
bavota et al.
mined the evolution history of java open source projects to investigate if refactorings occur on code elements that certain indicators suggest a need for refactoring.
their considered indicators include structural quality metrics and the presence of smells.
they also measure the effectiveness of refactorings regarding their ability to remove smells.
according to their results quality metrics do not show a clear relationship with refactoring and of the refactorings are applied on smelly elements in which only of them remove smells.
different from bavota et al.
our results indicate that most of the refactorings are performed in elements with code smells in which .
of them remove smells and .
induce new smells.
the procedure that we followed may explain why our results are different from the one presented by bavota et al.
.
we collected refactorings between commits while they collected refactorings using only the projects major versions.
usually between two major versions developers perform significant changes in the source code structure.
therefore they probably missed refactorings when they followed this procedure since refactorings might be hidden or unidentifiable.
in our study we mitigate this threat by collecting the refactorings between consecutive commits.
in summary our study 473esec fse september paderborn germanyd.
cedrim a. garcia m. mongiovi r. gheyi l. sousa r. de mello b. fonseca m. ribeiro and a. ch vez improves several aspects of the study reported by bavota et al.. first we analyzed projects while they analyzed only .
second we collected refactorings in consecutive commits.
third we used a refactoring detection tool refactoring miner with a good precision rather than the well known ref finder s low precision .
in addition we evaluated if and when refactorings are stinky by introducing new smells in the context of both root canal and floss refactoring.
we have also characterized refactoring smell patterns.
motivations to refactor.
our data showed that most of refactorings touch smelly elements.
even though the specific motivation of the developers is unknown we actually observed a similar behavior when developers apply both root canal and floss refactoring.
mainly in the former case one would expect developers explicitly intend to improve code structure.
regarding developers motivation silva et al.
investigated the reasons that drive developers to refactor their code.
they identified refactorings on java projects in the github repository.
then they asked developers why they performed the identified refactorings.
their results indicate that fixing a bug or changing the requirements such as feature additions mainly drives refactorings.
their results show that the refactored code may contain code smells although developers did not mention it explicitly as the intention to refactor.
on the other hand the study of yamashita moonen reports that developers often consider smells as critical.
benefits to refactor.
kim et al.
conducted a three folded investigation at microsoft about refactoring through a survey interviews and data analysis of the windows version history.
their results indicate that the refactoring in practice seems to differ from the rigorous definition of behavior preservation transformation found in the literature .
this result provides us an additional support to investigate floss refactorings since developers also perform non behavior preservation transformations while refactoring.
the survey participants also reported the benefits they have observed from refactoring.
the two most cited benefits were improved readability and maintainability.
although the participants did not mention code smells the presence of code smells affects negatively the two benefits they claim they want to achieve .
introduction of code smells.
tufano et al.
investigated the circumstances that led to the introduction of smells not specifically in the context of software refactoring.
the authors analyzed issues and tags associated with commits that introduced smells on open source projects.
their results indicate that most of code smells are introduced during enhancement activities between and .
they also found that between and of the smellintroducing commits were tagged as refactoring.
however our study goes beyond our findings indicate that stinky refactorings are frequent refactorings are related to the introduction of code smells in .
of the cases.
we also characterized and quantified typical refactoring smell patterns and observed that certain stinky patterns are very frequent.
negative refactorings.
we conducted a preliminary study that analyzes how often the commonly used refactoring types affect the density of types of smells along the version histories of projects.
our findings are based on the analysis of refactorings distributed in different types.
surprisingly .
of refactorings are neutrals.
only .
of refactoring were positive and .
negatives.
our new results show that negative refactorings aremuch more frequent.
this discrepancy between the studies can be explained by the nature of the projects.
in the preliminary study we considered only small projects with fewer developers.
conclusions we conducted a study aiming to understand the relationship between refactorings and code smells in projects.
first we have observed that although refactorings touch smelly elements they are often smell neutral.
second stinky refactorings occur more often than positive refactorings.
stinky refactorings were also surprisingly frequent in root canal refactorings i.e.
when developers are solely focused on improving the program structure.
these findings suggest developers need more guidance to fully remove a code smell once they restructure a smelly element.
in order to better guide developers we have investigated which recurring refactoring smell pairs tend to produce stinky neutral or positive effects.
we achieved this goal by revealing and characterizing removal non removal and creational patterns.
we found a wide range of creational and non removal patterns which were much more frequent than positive patterns.
extract method is a refactoring type frequently involved in both stinky and non removal patterns.
moreover we decomposed creational patterns in three groups.
the first group included refactorings dealing with generalization they were often related to the creation of god class and speculative generality smells.
the second group represents feature moving refactorings which induced the creation of god class complex class and lazy class smells.
finally the last group comprises the extract method refactorings which were related to the creation of divergent change andfeature envy smells.
the aforementioned findings can help practitioners and tool engineers.
practitioners using refactoring are now better informed of when they may typically introduce neutral or stinky refactorings in their programs.
moreover a refactoring assistance tool can be built in order to i detect when developers performed refactoring in a commit and ii depending on the refactoring characteristics e.g.
occurrence of a root canal refactoring immediately produce warnings or recommendations for the developer.
for example a refactoring assistant could warn developers of an emerging god class related to a stinky refactoring and suggest her to move the class member to a more appropriate class.