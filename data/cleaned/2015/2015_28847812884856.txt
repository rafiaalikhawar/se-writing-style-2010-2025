synthesizing framework models for symbolic execution jinseong jeon xiaokang qiuyjonathan fetter degges jeffrey s. foster armando solar lezamay university of maryland college park usaymassachusetts institute of technology usa jsjeon jonfd jfoster cs.umd.edu xkqiu asolar csail.mit.edu abstract symbolic execution is a powerful program analysis technique but it is di cult to apply to programs built using frameworks such as swing and android because the framework code itself is hard to symbolically execute.
the standard solution is to manually create a framework model that can be symbolically executed but developing and maintaining a model is di cult and error prone.
in this paper we present pasket a new system that takes a rst step toward automatically generating java framework models to support symbolic execution.
pasket s focus is on creating models by instantiating design patterns .pasket takes as input class method and type information from the framework api together with tutorial programs that exercise the framework.
from these artifacts and pasket s internal knowledge of design patterns pasket synthesizes a framework model whose behavior on the tutorial programs matches that of the original framework.
we evaluated pasket by synthesizing models for subsets of swing and android.
our results show that the models derived by pasket are su cient to allow us to use o the shelf symbolic execution tools to analyze java programs that rely on frameworks.
categories and subject descriptors i. .
program synthesis keywords program synthesis framework model symbolic execution sketch.
.
introduction many modern applications are built on frameworks such as java swing a gui framework or the android platform among many others.
applying symbolic execution to such applications is challenging because important control and data ows occur via the framework .
for example consider a swing application that creates a button registers permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
callback for it and later receives the callback when the button is clicked.
a symbolic executor that simulates only application code would miss the last step since the control transfer to the callback happens in the framework.
one possible solution is to symbolically execute the framework code along with the application but in our experience this is unlikely to succeed.
frameworks are large complicated and designed for extensibility and maintainability.
as a result behavior that appears simple externally is often implemented in complex ways.
frameworks also contain details that may be unimportant for a given analysis.
for instance for swing the details of how a button is displayed may not be relevant to an analysis that is only concerned with control ow.
finally frameworks may contain native code that is not understood by the symbolic executor.
the standard solution to this issue is to manually create a framework model that mimics the framework but is much simpler more abstract and can be symbolically executed.
for example java pathfinder jpf includes a model of java swing that is written in java and can be symbolically executed along with an application.
however while such models work they su er from several potential problems.
since the models are created by hand they likely contain bugs which can be hard to diagnose.
moreover models need to be updated as frameworks change over time.
finally applying symbolic execution to programs written with new frameworks carries a signi cant upfront cost putting applications that use new or unpopular frameworks out of reach.
in this paper we take a rst step toward automatically synthesizing framework models by introducing pasket pattern sketcher a tool that synthesizes java framework models by instantiating design patterns .
the key idea behind pasket is that many frameworks use design patterns heavily and that use accounts for signi cant control and data ow through the framework.
for example the swing button click callback mentioned above is an instance of the observer pattern .
thus by creating a model that includes an equivalent instantiation of the observer pattern pasket helps symbolic execution tools discover control ow that would otherwise be missed.
overview.
figure gives an overview of pasket.
its two main inputs are a set of tutorial programs that exercise relevant parts of the framework and a summary of the framework api to be modeled.
for scalability of the synthesis problem pasket is designed to be used with tutorial programs that each exercises a small part of the framework andpasket then combines the information from each tu2016 ieee acm 38th ieee international conference on software engineering pasket frameworktutorialapi loggerencoder synthesizerframework modeldesign patterns logssynthesis problemfigure pasket architecture.
torial into a full model.
in the case of swing for example oracle provides tutorials for buttons checkboxes and similar components which are ideal for this purpose .
the framework api information can be extracted from the jar or aar les of the framework although some user input is needed to select the parts of the framework api that should be modeled.
this api provides the skeleton of the expected model.
pasket s goal is to generate code for that skeleton insert the bodies of constructors and methods to yield a model that can be used to analyze the tutorial programs and that ideally will also generalize to larger programs that use the same parts of the framework.
as a rst step in the model creation process the logger component inside pasket executes the tutorial programs perhaps requiring user interaction with the tutorial and logs the method names arguments and return values that cross the boundary between the tutorial code and the framework.
calls internal to the framework are omitted from the log.
for instance in the swing button callback example the user would run the application and press the button while the logger records the execution.
the log would therefore capture the button creation registration and callback including the precise identities of the objects so it captures the fact that the registered object is the one being called back when the button is clicked.
these captured logs serve as a partial speci cation for the synthesis process.
speci cally the synthesizer aims to produce a model that achieves log conformity with the original program meaning if the application were to run using the model code in place of the framework code under the same user inputs we would observe the exact same sequence of calls as in the original log.
section explains this in detail.
to produce a model the log conformity requirement must be combined with a structural hypothesis to limit the space of possible models.
in pasket this structural hypothesis comes from pasket s internal knowledge of design patterns.
the idea is that by limiting the search to models that implement design patterns we know to be used by the actual framework we increase the likelihood the synthesized model will generalize and behave correctly with other applications.
pasket currently supports four main design patterns observer accessor adapter and singleton.
section explains how these patterns are instantiated to match the given api and produce models satisfying log conformity.
pasket uses the open source sketch synthesis system to search for log conforming instantiations of the design patterns hence the sketcher part of the name pasket .
sketch s input is a sketch that describes a space of programs and a set of semantic constraints usually given as assertions the synthesized program must satisfy.
sketch uses a symbolic search procedure to nd a program in that space that satis es the constraints.
section discusses pas ket s encoder component which translates the client app logs framework api and design pattern information into a sketch whose solution solves the pasket synthesis problem.
the encoded synthesis problems are quite challenging due the large number of possible design pattern instantiations as well as the di culty of reasoning about dynamic dispatch.
despite this the problems are made tractable using recent research on combining constraint based synthesis with explicit search together with a careful encoding that allows the synthesizer to e ciently rule out large numbers of incorrect solutions.
results.
we used pasket to produce a model of the java swing gui framework and the android framework.
for swing we used tutorial programs distributed by oracle.
synthesis took just a few minutes and in the end produced a model consisting of di erent classes and lines of code making it one of the largest pieces of code ever synthesized using constraint based synthesis.
for android we used tutorial programs gathered from the web.
synthesis took a few seconds and produced a model consisting of di erent classes and lines of code.
we validated the models in three ways.
first we ran the swing tutorials against the synthesized swing model and checked that they match the original logs.
second we ran the swing tutorials under java pathfinder jpf .
we found we could successfully execute eight of the ten tutorials two tutorials are not supported by jpf s event generating system while jpf s own model failed due to some missing methods.
finally we selected eight code examples from o reilly s java swing 2nd edition that use the same part of the framework and veri ed that they run under jpf using our merged model.
we also selected two android code examples and veri ed they run under symdroid a davlik bytecode symbolic executor using our merged model.
section describes our experiments.
contributions.
in summary this paper makes the following contributions we introduce pasket a new tool that takes a rst step toward automatically synthesizing framework models su cient for symbolic execution.
we formulate the synthesis problem as design pattern instantiation and show how to use the framework api and log of framework client calls to constrain the design pattern instantiation process.
sections and we show how to encode the synthesis problem as a sketch synthesis problem.
sections and we present experimental results showing pasket can synthesize a model of a subset of swing and a subset of android and that model is su cient to symbolically execute a range of programs.
section .
running example as a running example we show how pasket synthesizes a java swing framework model from the tutorial program in figure which is a simpli ed extract from one of the tutorials for java swing.
here the main method not shown calls createandshowgui line which instantiates a new window and adds a new instance of buttondemo to it.
the buttondemo constructor 1571class buttondemo implements actionlistener public buttondemo b1 new jbutton disable middle button ... b1.setactioncommand disable b2 new jbutton middle button ... ... b3 new jbutton enable middle button ... ... b1.addactionlistener this b3.addactionlistener this add b1 add b2 add b3 public void actionperformed actionevent e if disable .equals e.getactioncommand ... private static void createandshowgui jframe frame new jframe buttondemo buttondemo newcontentpane new buttondemo ... frame.setcontentpane newcontentpane ... figure buttondemo source code simpli ed .
line creates and initializes button objects b1through b3 each of which are labeled line .
the code then registers thisas an observer for clicks to b1and b3 line and then adds the buttons to the window.
when either button is clicked swing calls the actionperformed method of the registered observer line whose behavior depends on the label of the button that was clicked line .
in addition to the tutorial the second input to pasket is the framework api consisting of classes methods and types.
the api is then completed by pasket to produce a complete model like the swing model that is partially shown in figure .
the black text in the gure corresponds to the original api given as input package names are omitted for space reasons.
the rest of the code highlighted in blue is generated by pasket given a log from a sample run of buttondemo.
for example pasket discovers that abstractbutton is a subject in the observer pattern thus it has a list olist of observers initialized in the constructor and its attach method is addactionlistener.
the handle and handle 1 methods are introduced entirely by the synthesizer to model the way in which the abstractbutton invokes the actionperformed methods in its registered listeners.
in this model the runtime posts events into the eventqueue and dispatches them by calling run.
the model then propagates those events to any listeners that have been registered with a button.
pasket also discovers that eventobject awtevent and actionevent participate in the accessor pattern with a eld set via their constructor and retrieved via getsource in the case of eventobject.
notice that pasket abstracts several constructors and methods to have empty bodies because this particular tutorial program does not rely on their functionality.
for example the argument to the jbutton constructor is never retrieved.
thus the tutorials control pasket s level of abstraction.
unneeded framework features can be omitted so they will not be synthesized and framework features can be added by introducing tutorials that exercise them.
.
logging and log conformity as explained earlier pasket executes the tutorial program to produce a log of the calls between an application and the framework.
figure shows a partial log from buttondemo.
each log entry records a call or return.
in the20class eventdispatchthread private eventqueue q void run eventobject e while e q.getnextevent !
null q.dispatchevent e ... 26class eventqueue private queue eventobject q void postevent eventobject e q.add e void dispatchevent eventobject event if event instanceof actionevent abstractbutton btn abstractbutton event.getsource btn.handle actionevent event ... ... 35class abstractbutton extends jcomponent private list actionlistener olist abstractbutton olist new linkedlist actionlistener void addactionlistener actionlistener l olist.add l void setactioncommand string actioncommand empty void handle actionevent event handle 1 event void handle 1 actionevent event int i while i i olist.size o olist.get i !
null l.actionperformed event i i ... 45class jbutton extends abstractbutton jbutton string text icon icon empty 47class jframe extends frame ... 48class eventobject private object source eventobject object source this.source source object getsource return source 53class awtevent extends eventobject ... 54class actionevent extends awtevent priavte string command actionevent object source intid string command super source id this.command command string getactioncommand return command figure framework api to be modeled partial .
highlighted code produced by synthesis.
gure thisis the rst parameter to each call and we use indentation to indicate nested calls.
constructor calls and object parameters are annotated with a java object id.
for example jbutton is a jbutton with object id .
using object ids provides us with a simple way to match the same object across di erent calls.
thus the log contains detailed information about both the values that ow across the api and the sequencing of calls and returns.
that detailed information is exactly what is needed to su ciently constrain the synthesis problem.
for example line has a call to addactionlistener with arguments jbutton and buttondemo .
subsequently on line an actionevent associated with this button is created and immediately posted into the eventqueue after this the runmethod in the eventdispatchthread is called.
the details of what happens inside the framework after the call to runare ignored by the logger because it does not involve methods in the given api.
the next log entry in line corresponds to the framework s call to the actionperformed method in the application.
it will be up to pasket to infer that this sequence of log entries is 15861buttondemo.main buttondemo.createandshowgui buttondemo.buttondemo jbutton.setactioncommand jbutton disable jbutton.setenabled jbutton false jbutton.addactionlistener jbutton buttondemo jbutton.addactionlistener jbutton buttondemo jframe.setcontentpane jframe buttondemo ... 70actionevent.actionevent jbutton disable 71eventqueue.postevent eventqueue actionevent 72eventdispatchthread.run eventdispatchthread buttondemo.actionperformed buttondemo actionevent actionevent.getactioncommand actionevent return disable ... 77actionevent.actionevent jbutton enable 78eventqueue.postevent eventqueue actionevent 79eventdispatchthread.run eventdispatchthread buttondemo.actionperformed buttondemo actionevent actionevent.getactioncommand actionevent return enable ... figure sample output log from buttondemo.
part of the observer design pattern.
pasket will then use its knowledge of the pattern to infer the contents of postevent run and all the other functions that were invoked inside the framework to eventually call actionperformed.
as another example line shows getactioncommand returning the string disable which was set in the setter on line .
thus again given pasket s library of design patterns these log elements must be part of an accessor pattern.
the log conformity constraint is that a correct framework model run against the same tutorial program under the same inputs should produce the same log as the actual framework.
in reactive frameworks such as swing or android however events such as button clicks are relayed by the runtime system to the framework and the framework interacts with the application in response to these events.
for such a reactive framework these events are what constitute the inputs to the framework application pair so to check log conformity the system needs to check that the combined framework model and application react to these events in the same way as the original framework and application did.
one subtle aspect of the log conformity constraint is that the objects created when running against the real framework will have di erent ids from those created when running against the model so the log conformity check must allow for the renaming of objects of the same type when comparing the logs for the two executions.
in the next section we discuss pasket s design patterns and then in section we show how to combine the api logs and design pattern knowledge to synthesize a framework model using sketch .
.
design pattern instantiation pasket synthesizes the code in figure by instantiatingdesign patterns.
to understand the synthesis process consider figures and which show two of the four design patterns supported by pasket.
the uml diagrams in these gures have boxes for classes and interfaces with elds at the top and methods at the bottom arrows for subclass orimplements relationships and diamond edges for containment.
unless marked private elds and methods are public.
the key novelty in these diagrams are design pattern variables indicated in colored italics.
these are unknowns that pasket solves to determine which classes and methods play which roles in the patterns.
for example the observer pattern in figure includes several di erent design pattern variables including the names of the subject and observer classes the name of the iobserver interface and the names of the attachand detach methods.
the main technical challenge for pasket is to match these pattern variables with class interface and method names from the api description.
in our running example pasket determines there must be an observer pattern instance with abstractbutton as the subject and addactionlistener as the attach method.
thus to create the framework model pasket instantiates the eld olistfrom the pattern as a new eld of abstractbutton and it instantiates the body of the attach method into addactionlistener.
the other roles are instantiated to other classes in the api.
in addition to design pattern variables the design pattern descriptions also leave certain implementation details to be discovered by the synthesizer.
for example inside the handle method the synthesizer can decide what event types should invoke which individual handlers and in the handler handle i the synthesizer is left to choose in what direction to iterate over the observer list.
pasket uses the same basic idea of design pattern instantiation to create the entire framework model.
we next discuss the patterns currently supported by pasket and then discuss the problem of synthesizing multiple patterns simultaneously.
we selected this set of patterns to support the experiments in section but we have designed pasket to support extensibility with more patterns if necessary it is even possible to create specialized patterns when we need very platform speci c behavior.
observers and events.
we have already discussed several aspects of the observer pattern in figure .
the subject maintains a list of iobserver s initialized in the constructor.
observers can be attached or detatched to the list and both methods are optional i.e.
they may or may not be present.
notice update i has no code in the pattern since the observer is part of the client rather than the framework.
for example in figure the update i method is actionperformed.
we mark the methods handle and handle i asauxiliary to indicate they are not part of the original framework.
the real framework has some possibly complicated logic to determine how to call the update i methods when the runmethod of the eventdispatchthread is called and the methods handle and handle i are our way of modeling this logic.
because we do not need to match them with methods in the api their names are not pattern variables.
this is why they were added with these same names to abstractbutton in figure where the synthesizer instantiated handle to just call handle 1 and handle 1 to iterate forward through olistwhile calling the update method actionperformed.
accessors.
figure shows the accessor pattern used for classes with getters and setters.
the class has k elds f1 through fk.
as in java each eld has a default value before any initialization or update 0for int falsefor boolean and nullfor all object elds .
there are also rgetter methods get f1 through get fr andsgetter methods set f1 through 159void update i evt e i .. k class observersubject olist new linkedlist optional void attach iobserver obs olist.add obs optional void detach iobserver obs olist.remove obs auxiliary void handle evt e if e.gettype ?
?
handle 1 e ... if e.gettype ?
?
handle k e else handle k e auxiliary void handle i evt e i .. k int i iobserver o while i i olist.size o olist.get i !
null o. update i e i private list iobserver olist class subject void update i evt e i .. k interface iobserver auxiliary void dispatchevent ievt e if e instanceof evt subject e.getsource .handle e void postevent ievt e return q.add e auxiliary ievt nextevent return q.remove private queue ievt q class eventqueue object getsource int gettype interface ievt subject getsource int gettype class evtvoid run ievt e while e q.nextevent !
null q.dispatchevent e private eventqueue q class eventdispatchthreadfigure observer pattern in pasket.
accessor t1 o1 ... tj o j j k if super f1 o1 ... fj oj if fj ... if fk ti get f i void return i .. r r k void set fi ti v v i .. s s k private ti fi i .. k class accessor figure accessor pattern in pasket.
set fs.
each getter method get fi retrieves the value of a eld chosen from f1 through fk similarly each setter method updates a eld chosen from f1 through fkwith the input v. the accessor class also has a single constructor that accepts jarguments for some j k. the i th argument is used to initialize the i th eld fi respectively.
this incurs no loss of generality since pasket can choose to enumerate the elds in any order.
for those elds beyond fj i.e.
elds fj through fk pasket may opt to initialize some of them implicitly with either a new instance of some class clsor some constant value indicated by a hole ?
?
depending on eld s type.
for the former case we assume that the new instance is constructed by a public no argument constructor cls .
before these elds are initialized the constructor may or may not call the superclass constructor with a subset of thejarguments written .
for example in figure we see that actionevent s constructor passes only two parameters to its superclass awtevent which in turn passes only one parameter to its superclass eventobject.
finally the constructor initializes the elds appropriately.
other patterns.
pasket also supports the singleton pattern and the adapter pattern which are not shown due to lack of space.
the singleton pattern supports classes that have a single instance such as system level services.
the adapter pattern is used to delegate calls to another object e.g.
in swing invocationevent is an adapter that dispatches runcalls to a runnable object stored in a eld.
more details about other patterns along with uml diagrams can be found in .multi pattern synthesis.
in practice frameworks may have zero one or multiple instances of each pattern and they may use multiple patterns.
currently the number of instances of each pattern is a parameter to pasket.
in our experiments for each framework we x these numbers across all tutorial programs and then discard any unused pattern instances as discussed further in section .
since the same class might be involved in multiple patterns the design patterns in figures and should be taken as minimal speci cations of classes pasket always allows classes to contain additional elds and methods than are listed in a diagram.
those additional class members either get their code from a di erent pattern or di erent instance of the same pattern or are left with empty method bodies or return the default value of the return type .
in our running example the abstractbutton class is involved in both the observer pattern and the accessor pattern its methods addactionlistener removeactionlistener and fireactionperformed instantiate an observer pattern and its methods getactioncommand and setactioncommand instantiate an accessor pattern.
currently pasket requires that each method body be instantiated from at most one pattern.
.
framework sketching pasket usessketch to discover how to instantiate the design patterns from section into the method bodies in figure to satisfy log conformity.
background.
the input to sketch is a space of programs in a c like language.
the space is represented as a program with choices and assertions.
the choices can include unknown constants written ?
?
as well as explicit choices between alternative expressions written .
the goal of sketch is to nd a program in the space that satises the assertions .
for example given a program void double int x intt ?
?
assert t x x sketch will choose 2for the constant ?
?and xfor the choice.
full details about sketch can be found elsewhere .
the encoder component in pasket consumes the framework api the tutorial and the log and produces a frame16087assert subject6 observer 89assert subcls 90assert subcls 91assert argnum 92assert argnum 93assert argtype iobserver 94assert argtype iobserver 95assert rettype void 96assert rettype void 97assert subcls 99assert attach6 detach figure constraints on design pattern variables partial .
work sketch which is a sketch input le.
the framework sketch is comprised of four main pieces the tutorial code driver code to invoke the framework tutorial with the sequence of events captured in the log the framework api lled in with all possible design pattern implementations guarded by unknowns that allow the synthesizer to choose which roles of which patterns to use in each method and additional code to assert log conformity and other constraints e.g.
from subtyping relationships.
when sketch nds a solution it will thereby discover the implementations of framework methods such that when the framework is run in combination with the app log conformity will be satis ed.
from java to sketch.
the rst issue we face in building the framework sketch is that it must include java code e.g.
for the client app and framework method implementations.
however sketch s language is not object oriented.
to solve this problem pasket follows the approach of jsketch a tool that adds a java front end to sketch .
we currently do not use jsketch directly for two reasons.
first for log conformity we need to retrieve runtime instances which requires modifying an object allocation function.
second to check log conformity only for calls that cross the boundary between the framework and the client app we need to slightly modify method signatures and call sites to include a framework client ag.
likejsketch we introduce a new type v object de ned as a struct containing all possible elds plus an integer identier for the class.
more precisely if c1 c mare all classes in the program then we de ne 84struct v object intclass id elds from c1... elds from cm where each cigets its own unique id.
pasket also assigns every method a unique id and it creates various constant arrays that record type information.
for a method id m we set belongsto to be its class id argnum to be its number of arguments and argtype to be the type of its i th argument.
we model the inheritance hierarchy using a two dimensional array subcls such that subcls is true if class iis a subclass of class j. using this encoding we can translate the client app directly into the framework sketch.
driving execution.
the next piece of the framework sketch is a driver that launches the client app and injects events according to the log.
more speci cally looking at figure 102void addactionlistener v object self v object l addactionlistener has id int params self .obj id l .obj id check log params check that params is the next log entry and advance the log counter by one if attach code for attach else if detach code for detach else if ... int ret check log ret figure framework sketch partial .
we see three items that come from outside both the client app and the framework the initial call to main line and the user inputs on lines and .
the driver is responsible for triggering these events which it does by calling the appropriate hard coded method names in figure for the event queue or the appropriate names for android if applyingpasket to that domain .
design pattern implementations.
the next component of the framework sketch is the framework api itself with code for the design patterns checks of log conformity and constraints on design pattern instantiation.
for each possible pattern instantiation and each possible design pattern variable we introduce a corresponding variable in the framework sketch initialized with a generator.
for example to encode the observer pattern every role name in italics in figure will be a variable in the framework sketch 100intsubject intobserver 101intattach intdetach ... here each design pattern variable s generator lists the possible class or method ids that could instantiate those roles.
if there were multiple occurrences of the observer pattern there would be multiple variables attach1 attach2 etc.
next pasket generates a series of assertions that constrain the design pattern variables according to the structure of the pattern.
figure shows some of the constraints for the observer pattern.
the rst line requires that two di erent classes are chosen as subject and observer.
the next lines check that the attach and detach methods are members of or inherited by the subject and that those methods have the same signature taking a single argument of an appropriate type a superclass of observer and returning void.
finally it checks that distinct roles e.g.
attach and detach in the design pattern are instantiated with di erent methods.
finally for each api method we add a corresponding function to the framework sketch that checks log conformity at entrance and exit of the method and in between conditionally dispatches to every possible method of every possible design pattern.
for example figure depicts the framework sketch code corresponding to addactionlistener figure .
the rst statement line creates a call descriptor that includes the method s id and the object ids of the parameters.
this call descriptor is passed to check log on line which asserts it matches the next entry in the global log array created in the driver and advances the global log counter.
next the code dispatches to various design pattern method implemen161tations based on the role chosen for this method.
finally the code checks that the return indicated by negating the method id matches the log here the method returns void.
note that void returns are included in the actual log though we omitted them from figure .
putting this all together the check log assertions will only allow this method to be called at appropriate points in the trace speci cally lines and of figure .
sketch will determine that attach is19 hence the attach method code will be called in the function body.
model generation.
after sketch has found a solution the last step is to generate the framework model.
pasket usessketch s solution for each variable attach detach etc.
to emit the appropriate implementation of each method in the model.
for example since we discover that addactionlistener is the attach method of the observer pattern we will emit its body as shown in figure along with the other methods and elds involved in the same pattern.
in some cases methods in the framework api will be left unconstrained by the tutorial program.
in these cases pasketeither leaves the method body empty if it returns void or adds a return statement with default values such as false or null according to the method s return type.
.
implementation we implemented pasket1as a series of python scripts that invoke sketch as a subroutine.
pasket comprises roughly 14k lines of code excluding the java parser.
we specify name and type information for the framework via a set of java les containing declarations of the public classes and methods of the framework with no method bodies.
pasket parses these les using the python frontend of antlr v3.
.
and its standard java grammar.
after solving the synthesis problem pasket then unparses these same java les but with method bodies and private elds instantiated according to the synthesis results.
we use partial parsing to make this output process simpler.
there are several additional implementation details.
logging.
for swing tutorials pasket gathers logs via a logger agent which is implemented with the java instrumentation api using javassist .
this allows pasket to add logging statements to the entry and exit of every method at class loading time.
pasket also inserts logging statements before and after framework method invocations.
in this way it captures call return sequences from the framework to clients and vice versa.
altogether the logger agent is approximately lines of java code.
for android tutorials pasket uses redexer a general purpose binary rewriting tool for android to instrument the tutorial bytecode.
similarly to our approach for swing we use redexer to add logging at the entry and exit of every method in the app and also insert logging statements before and after framework method invocations.
the logging statements emit specially tagged messages and we read the log over the android debugging bridge adb .
java libraries.
recall that several of our design patterns use classes and interfaces from the java standard library typically for collections such as list.
client applications also the standard library.
thus as part of our translation from java to sketch we provide sketch implementations of standard library methods used in our experiments.
android layouts.
android apps typically include xml layout les that specify what controls called views in android are on the screen.
in addition to the class of each control and its id the layout may specify the initial state of a control such as whether a checkbox is checked or in some cases an event handler for the control.
since layout information is needed to analyze an app s behavior we manually translate the layout les for each tutorial and subject app into equivalent java code.
the translated layout les instantiate each view in the layout le set properties as speci ed in the xml and add it to the activity s view hierarchy.
multi pattern synthesis.
recall from section that we need to synthesize models with multiple design patterns at once thus pasket needs to know how many possible instances of each pattern are needed.
for swing we choose observer patterns accessor patterns adapter pattern and singleton pattern per tutorial program and for android we choose observer pattern accessor patterns and singleton patterns per tutorial program.
these counts are su cient for the tutorial programs in our experiments.
most of the time not all pattern instances will actually be needed.
if this is the case the input we pass to sketch will underconstrain the synthesis problem allowing sketch to choose arbitrary values for holes in unused pattern instances.
in turn this would produce a framework model that is correct for that particular tutorial program but may not work for other programs.
thus pasket includes an extra pass to identify and discard unused pattern instances.
merging multiple models.
as described so far pasket processes a single tutorial program to produce a model of the framework.
in practice however we expect to have many di erent tutorials that illustrate di erent parts of the framework.
thus to make our approach scalable we need tomerge the models produced from di erent tutorials.
our merging procedure iterates through the solutions for each tutorial program accumulating a model as it goes along by merging the current accumulated model with the next tutorial s results.
at each step for each design pattern we need to consider only three cases either the pattern covers classes and methods only in the accumulated model only in the new results for the tutorial program or in both.
in the rst case there is nothing to do.
in the second case we add the new pattern information to the accumulated model since it covers a new part of the framework.
in the last case we check that both models assign the same classes or methods to design pattern variables i.e.
that the results for those classes and methods are consistent across tutorial programs.
note for this check to work we must ensure class and method ids are consistent across runs of pasket.
.
experiments we evaluated pasket by using it to separately synthesize a swing framework model and an android framework model from tutorial programs.
table summarizes the results which we discuss in detail next.
162tutorial sketch w ac patterns java name loc log loc std s jjtm s tot s o ac ad s loc c m s wingbuttondemo checkboxdemo colorchooserdemo comboboxdemo customicondemo filechooserdemo menudemo splitpanedividerdemo textfielddemo oom toolbardemo model merging 30an droiduibutton uicheckbox telephony model merging table pasket results.
loc stands for lines of code log indicates number of log entries std s is the median running time under the standard version of sketch jjshows the median number of parallel processes forked to nd a solution tm s is the median running time of a single process that found a solution tot s is the median total running time o bserver ac cessor ad apter and s ingleton are the number of instantiations of each design pattern c and m are the number of synthesized classes and methods and is the number of empty methods.
synthesis inputs.
to synthesize the swing model we used ten tutorial programs distributed by oracle.
the names of the tutorials are listed on the left of swing group in table along with their sizes.
in total the tutorials comprise just over lines of code.
the tutorial names are self explanatory e.g.
checkboxdemo illustrates jcheckbox s behavior.
the last row of the swing section reports statistics for the merged model.
we ran each tutorial manually to generate the logs.
for instance for the buttondemo code from figure we clicked the left most button and then the right most button only one is enabled at a time.
it was very easy to exercise all features of these small simple programs.
the third column in the table lists the sizes of the resulting logs.
we also created java les containing the subset of the api syntactically used by these programs.
it contains classes methods and finalconstant elds.
to synthesize an android model we used three tutorial apps listed in the android group of table .
two of them uibutton and uicheckbox were examples in a coursera class on android programming.
the third tutorial app telephony is from an online tutorial site.2table gives the size of each tutorial after translating the layout les into java as described above.
we treated the tutorial apps similarly to the swing programs we ran the android apps manually to generate logs and we created a subset api containing the classes methods and finalconstant elds referred to by these programs.
synthesis time.
given the logs and api information we then ran pasket to synthesize a model from each tutorial program individually.
the middle set of columns in the table summarizes the results.
performance reports are based on seven runs of the synthesis process on a server equipped with forty .
ghz intel xeon processors and gb ram running ubuntu .
.
lts.
the column sketch loc lists the lines of code of the framework sketch les.
we should emphasize that this is a very challenging synthesis problem and these sketches are much larger than sketch has typically been used for both terms of lines of code and search space.
for example based on the combinatorics of the classes and methods available to ll the roles the search space for the swing framework is at least size .
in fact one of the sketches is so hard to solve that sketch runs out of memory.
to address this problem we adopted adaptive concretization ac an extension to sketch that adaptively combines brute force and symbolic search to yield a parallelizable and much more scalable synthesis algorithm.
the remaining columns under sketch in the table report the results of running both with and without ac.
the std column lists the median running time under sketch without ac.
thejjcolumn lists the median number of parallel processes forked and executed before a solution is found under ac.
the next column reports the median running time of a single trial that found a solution.
the last column lists the median total running time under ac.
we can see that overall synthesis just takes a few minutes and ac tends to reduce the running time sometimes quite signi cantly for larger programs.
the bottom row of each section of the table lists the time to merge the individual models together which is trivial compared to the synthesis time.
synthesis results.
the next group of columns summarizes how many instantiations of each design pattern o for observer ac for accessor ad for adapter and s for singleton were found during synthesis.
the last four columns report the lines of code and the number of classes methods and empty methods i.e.
those that are essentially abstracted away in the synthesized model.
in swing most tutorials handle only one kind of event and one event type and hence have a single instance of the observer pattern.
looking at the bottom row of the table we can see there is a lot of overlap between the di erent tutorial programs in the end the merged model has ve observer pattern instances.
in terms of the accessor pattern again there is a lot of overlap between di erent tutorials resulting in nine total pattern instances in the merged model.
finally all tutorials have exactly one instance of the adapter pattern for invocationevent and one instance of the singleton pattern for toolkit 163name loc tutorials toolbarframe2 toolbardemo toolbarframe3 toolbardemo customicondemo jbuttonevents buttondemo checkboxdemo jtogglebuttonevents buttondemo checkboxdemo simplesplitpane splitpanedividerdemo filechooserdemo colorpicker colorchooserdemo buttondemo colorpicker3 colorchooserdemo buttondemo simplefilechooser filechooserdemo table examples from o reilly s java swing 2nd edition.
which are part of the swing event handling framework.
we manually inspected the set of empty methods in the merged model and found that most of these methods in uence how things are displayed on screen.
e.g.
window.pack resizes a window to t its contents and component.setvisible shows or hides a window.
thus while these methods are important in an actual running swing program they can be left abstract in terms of control ow.
we also found some of the empty methods cases of setter like methods that were called in a tutorial but the set value was never retrieved hence it did not a ect log conformity.
thus for this set of tutorial programs these are safe to abstract while another set of tutorial programs might cause these to be matched against the accessor pattern.
in general synthesis results in android are similar to those in swing.
most tutorials in android also handle only one kind of event and one event type resulting in a single instance of the observer pattern.
similarly for the observer pattern and the accessor pattern there is a lot of overlap between di erent tutorials.
one noticeable di erence between swing and android is the number of instances of the singleton pattern.
in android many system level services are running in background and providing useful features to applications.
for easier maintainance those system level services are usually implemented as singletons.
correctness.
to check the correctness of the merged swing model we developed a sanity checker that veri es that a tutorial program produces the same logs when run against the merged model as when run against swing.
recall that the logs include the events i.e.
the user interactions that produced the original logs used for synthesis.
thus we developed a script to translate the logged events into a main method containing a sequence of java method calls simulating reception of those events.
then we replay the tutorial under the model by running this main method with the tutorial and model code recording the calls and returns in the execution.
we then compare against the original log.
using this approach we successfully veri ed log conformity for all ten tutorial programs.
to check the correctness of the merged android model we ran the tutorial apps under the symdroid symbolic executor.
since the android model is much smaller than that of swing we manually examined symdroid s outputs to verify the correctness of the model we ran symdroid and recorded its detailed execution steps checked branching points of interest while walking through those symbolic ex name loc tutorials visibility uibutton uicheckbox bump uibutton uicheckbox telephony table example apps for android.
ecution traces and double checked that expected branches were taken and that expected assertions passed accordingly.
java pathfinder s model.
next we compared our synthesized swing model to an existing manually created model the swing model that ships as part of java pathfinder jpf .
we ran jpf under both models on eight of the ten tutorials.
we omitted two tutorials colorchooserdemo and filechooserdemo since those cannot easily be run under jpf due to limitations in jpf s swing event generator.
note that there are no symbolic variables in this use of jpf i.e.
we explore only the path taken to create the original log.
surprisingly we found that run with jpf s own model jpf failed on all tutorial programs for a fairly trivial reason some method with uninteresting behavior i.e.
that our synthesis process left empty was missing.
in contrast all eight tutorials run successfully under jpf using pasket s merged model.
this shows one bene t of pasket s approach by using automation pasket avoids simple but nonetheless frustrating problems like forgetting to implement a method.
applicability to other programs.
finally we ran symbolic execution on several other programs under each model to demonstrate that a model derived from one set of programs can apply to other programs.
we chose eight java swing code examples from o reilly s java swing 2nd edition that use the same part of the framework as the oracle tutorials we used.
table lists the eight examples along with their sizes.
all ran successfully using jpf under our merged model.
the rightmost column lists which oracle tutorials are needed to cover the framework functionality used by the o reilly example programs.
interestingly we found that in addition to the obvious oracle tutorial based on just the name often the o reilly example programs also needed another tutorial.
for example toolbarframe3 needed functionality from both toolbardemo the obvious correspondence and customicondemo.
we also ran two apps under the synthesized model of android they are listed in table .
visibility is an activity extracted from the api demos app in the android sdk examples.
bump is an app created for an earlier project that looks up a phone number and or device id from the telephonymanager depending on the state of two check boxes.
we manually translated the layout les to java for these two apps as we did for the tutorial apps.
as with the o reilly examples these apps needed framework functionality from multiple tutorials.
in our earlier project we introduced interaction based declassi cation policies along with a policy checker based on symbolic executions.
using the model generated by pasket we conducted similar experiments.
we ran the policy checker against the original secure version of the bump app and found the checker yielded the correct results with the synthesized framework model.
for the visibility app we conducted the same correctness check as the other tutorial apps we ran the app under symdroid and double checked 164that the simulated events of user clicks were properly propagated to the app s event handlers via our synthesized framework model.
.
related work modeling.
as mentioned earlier symbolic execution tools for framework based applications usually rely on manually crafted framework models.
for example as discussed earlier jpf awt models the java awt swing framework.
the model is tightly tied to the jpf awt tool and cannot easily be used by other analysis tools.
moreover as we saw in section the model is missing several methods.
there are some studies that attempted to automatically create models of swing and android for jpf.
the techniques from these papers are quite di erent as they rely primarily on slicing.
one advantage of pasket is that it could generate more concise models for complex frameworks because it is unconstrained by the original implementation s structure.
nonetheless the techniques used in those papers could help identify which parts of the framework to model.
several researchers have developed tools that generate android models.
edgeminer ran backward dataow analysis over the android source code to nd implicit ows.
modelgen infers a model in terms of information ows to support taint analysis.
to learn behaviors of the target framework it inputs concrete executions generated by droidrecord similarly to our logging using redexer .
both of these systems target information ow which is insu cient to support symbolic execution.
given an app droidel generates a per app driver that simulates the android lifecycle.
this enables some program analysis of the app without requiring analysis of the android framework which uses re ection to implement the lifecycle.
a key limitation of droidel is that it is customized to the lifecycle and to a particular android version.
mimic aims to synthesize models that perform the same computations as opaque or obfuscated javascript code.
mimic uses random search inspired by machine learning techniques.
mimic focuses on relatively small but potentially complex code snippets whereas pasket synthesizes large amounts of code based on design patterns.
samimi et al.
propose automatically generating mock objects for unit tests using manually written pre and postconditions.
this is also quite di erent from pasket which synthesizes a model using knowledge of design patterns.
synthesis.
there is a rich literature on algorithmic program synthesis since the pioneering work by pnueli and rosner which synthesizes reactive nite state programs.
most of these synthesizers aim to produce low level programs e.g.
synthesis techniques that are also sketch based .
the idea of encoding a richer type system as a single struct type with a type id was also used in the autograder work .
component based synthesis techniques aim at higher level synthesis and generate desired programs from composing library components.
our approach is novel in both its target abstract models for programming frameworks and its speci cation logs of the interaction between the client and the framework and an annotated api .
the idea of synthesizing programs based on i o samples has been studied for di erent applications.
godefroidand taly propose a synthesis algorithm that can e ciently produce bit vector circuits for processor instructions based on smart sampling.
storyboard is a programming platform that can synthesize low level data structuremanipulating programs from user provided abstract i o examples.
transit a tool to specify distributed protocols inputs user given scenarios as concolic snippets which correspond to call return sequences pasket logs.
in our approach the synthesis goal is also speci ed in terms of input event sequences and output log traces and our case studies show that the i o samples can also help synthesize complex frameworks that use design patterns.
design patterns.
in their original form design patterns are general solutions to common problems in software design rather than complete code.
that is there is exibility in how developers go from the design pattern to the details.
several studies formalize design patterns detect uses of design patterns and generate code using design patterns.
mikkonen formalizes the temporal behavior of design patterns.
the formalism models how participants in each pattern e.g.
observer and subject are associated e.g.
attach how they communicate to preserve data consistency e.g.
update etc.
mikkonen s formalism omits structural concerns such as what classes or methods appear in.
albin amiot et al.
propose a declarative meta model of design patterns and use it to detect design patterns in user code.
they also use their meta model to mechanically produce code.
jeon et al.
propose design pattern inference rules to identify proper spots to conduct refactoring.
these approaches capture structural properties but omit temporal behaviors such as which observers should be invoked for a given an event.
in contrast pasket accounts for both structural properties and temporal behaviors.
we leverage design patterns as structural constraints and logs from tutorial programs as behavioral constraints for synthesis.
antkiewicz et al.
aim to check whether client code conforms to high level framework concepts.
they extract framework speci c models which indicate which expected code patterns are actually implemented in client code.
this is quite di erent from the symbolically executable framework model synthesized by pasket.
.
conclusion we presented pasket the rst tool to automatically derive symbolically executable java framework models.
pasket consumes the framework api and logs from tutorial program executions.
using these it instantiates the observer accessor singleton and adapter patterns to construct a framework model that satis es log conformity.
internally pasket usessketch to perform synthesis and it merges together models from multiple tutorial programs to produce a uni ed model.
we used pasket to synthesize a model of a subset of swing used by ten tutorial programs and a subset of android used by three tutorial programs.
we found that synthesis completed in a reasonable amount of time the resulting models passed log conformity checks for all tutorials and the models were su cient to execute the tutorial programs and other code examples that use the same portion of the frameworks.
we believe pasket makes an important step forward in automatically constructing symbolically executable java framework models.
165acknowledgments supported in part by nsf ccf ccf ccf1161775 and the partnership between umiacs and the laboratory for telecommunication sciences.