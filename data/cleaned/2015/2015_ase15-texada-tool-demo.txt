investigating program behavior using the texada ltl specifications miner caroline lemieux ivan beschastnikh computer science university of british columbia vancouver bc canada caro.lemieux gmail.com bestchai cs.ubc.ca abstract temporal specifications relating program events through time are useful for tasks ranging from bug detection to program comprehension.
unfortunately such specifications are often lacking from system descriptions leading researchers to investigate methods for inferring these specifications from code execution traces code comments and other artifacts.
this paper describes texada a tool to dynamically mine temporal specifications in ltl from traces of program activity.
we review texada s key features and demonstrate how it can be used to investigate program behavior through two scenarios validating an implementation that solves the dining philosophers problem and supporting comprehension of a stack implementation.
we also detail texada s other more advanced usage options.
texada is an open source tool i. i ntroduction program specifications or formal descriptions of expected program behavior are helpful in various software engineering tasks.
specifications can help in bug detection model creation and test case generation they can help with manageability by capturing what is important and being more concise than code they can help to document intended program behaviour .
however specifying behavior can be tedious or difficult and the resulting specifications can fall out of date as the system changes.
developers therefore rarely write down specifications of their programs.
one way to overcome the lack of specifications is to infer or mine specifications from existing program artifacts.
for example a constraint like a lock must be claimed before entering function ata dev select can be extracted statically source code or comments .
an alternative source of information and the focus of this paper is dynamic program behavior which reflects actual program execution.
this paper overviews texada a tool for mining linear temporal logic ltl property instances matching a userdefined temporal property type from traces of program behavior or logs.
figure illustrates the inputs to texada and the corresponding outputs through an example.
at the top of the figure is a log consisting of four traces of methods manipulating a queue instance.
the second input below is the property type xalways precedes y which we express in ltl as ywx1.
this property type is included in the texada distribution so that a user can input this pre defined property template without needing to compose the ltl expression directly.
the output for this log has four property instances bottom of figure .
the first three instances indicate that ywx fy!
yux g y yux newqueue isempty enqueue isempty newqueue enqueue isempty dequeue newqueue enqueue enqueue dequeue dequeue newqueue isempty isempty isempty log property type texadatrace 1trace 2trace 3trace propertyinstances or always precedes xy dequeue wenqueue ywx isempty wnewqueue enqueue wnewqueue dequeue wnewqueue fig.
.
top example inputs to texada including a sample log of traces containing method invocations for a queue object instance and a property type.
bottom texada s four mined property instances output.
an instance is an ltl formula based on the input property type that evaluates to true on each execution in the input log.
the newqueue method invocation precedes all other method calls i.e.
it is the first event in every trace .
the last property instance dequeue wenqueue implies that the dequeue method is never invoked before enqueue .
so in these traces thequeue instance is used without violating its api contract.
texada uses ltl to relate dynamic program behaviors or events that appear in a textual log file.
the events are userdefined with regular expressions not shown in figure and may represent a variety of program features.
for example texada can be used to analyze console logs generated with printf statements events are logged messages stack traces produced by stack tracing tools events are function names syscall traces produced by tools like strace events are system calls and output from other tools that track program information at runtime and emit a text file.
a key feature of texada is its use of an ltl property type e.g.
ywxin figure .
this property type has no structural constraints the user can specify any ltl property type without writing new code.
this feature distinguishes texada from prior tools that mine a specific set of pre defined ltl types .
the texada repository contains pre defined property types based on prior work including all of the ones mentioned in this paper.
these types are usable without needing to compose any ltl and can be run inp0p2p1p3p4fig.
.
a dining philosophers illustration with five philosophers p0 p4 .
aggregate against an input log.
the texada algorithms are described in another publication .
this paper illustrates how texada can be used to investigate complex program behavior.
we use texada to validate a solution to the dining philosophers problem and show how texada can help understand the usage of the stack data structure.
ii.
t exada usage scenarios texada can be used as a command line tool or from a web interface2.
below as we proceed through the two scenarios we explain each command line option to texada and also give the texada running time3.
the traces and arguments used in each example are available in the texada repository so that the given results can be replicated.
validating a solution to the dining philosophers problem.
if a developer knows the specification of a system texada can be used to verify whether the specification holds on a set of observed runtime traces from the system.
to illustrate this we use an implementation of the dining philosophers problem figure .
in this classic concurrency problem the goal is to feed a set of philosophers who are sitting at a table representing threads of execution and have to share chopsticks representing shared resources to access food on their plates.
between any two adjacent philosophers is one chopstick which can be held by only one philosopher at a time exclusive access .
a philosopher can be in one of three states thinking not accessing chopsticks hungry intending to access chopsticks or eating actively accessing chopsticks .
we use a multi threaded java implementation of a solution to the dining philosophers problem created by stephen j. hartley.
we modified the logging statements in this implementation to output the state of each of the five philosophers whenever one of them changes state.
to study the resulting log we use texada s multi propositional trace parsing feature which allows us to reason about traces where more than one atomic proposition occurs at a time point.
in this scenario we consider each philosopher s state to be an atomic proposition.
we used a log consisting of one minute traces of the implementation and found that the implementation in those minutes satisfied several correctness properties of the dining philosophers problem.
.any two adjacent philosophers iandj should never eat at the same time.
in ltl g iis eating !
jis eating .
we use texada to derive this set of properties 3texada revision on a machine running bit ubuntu .
tls with 8gb ram and an intel i5 haswell quad core .2ghz processorwith .
texada m f g x !y parse mult prop log.txt4.
the output involving philosopher i included g is eating !
is eating g is eating !
is eating g is eating !
is hungry g is eating !
is thinking texada generated similar output for the other four philosophers.
the first two properties in this output confirm our expected invariant philosopher cannot eat at the same time as philosopher or philosopher .
the bottom two properties confirm the more obvious invariant that philosopher can only be in one state at a time.
.if we let the solution run long enough we may be able to detect another desirable property eventually non adjacent philosophers get to eat at the same time.
that is for nonadjacent philosophers iandk we would like to make sure that eventually iis eating andkis eating co occur.
any interesting solution to the problem should satisfy this property.
this information is in fact implicit in the texada output from the previous query with property type g x!
y .
since for the binding of is eating tox the only bindings toywere is eating is eating is hungry and is thinking clearly at some point all other events cooccurred with is eating and similarly for philosophers and .
this equivalence comes from the fact that g x!
y g x y f x y .
however the absence of the instantiations of g x!
y with x andybound to non adjacent philosophers eating in texada s output simply indicates these instantiations were invalidated on at least one trace not necessarily on all traces.
if we explicitly check for f x y we will observe amongst other instantiations the following output f is eating is eating f is eating is eating f is eating is eating f is eating is eating f is eating is eating this confirms that pairs of non adjacent philosophers eventually get to eat at the same time in alltraces.
the queries in this scenario illustrate how a developer can use texada to study a non trivial concurrent program.
in this case we used texada to validate that the runtime traces generated by a solution to the dining philosophers problem satisfy basic correctness and concurrency properties.
the commands took .
to .044s to run on the log which consisted of traces time points total events and unique event types.
comprehension of stack usage.
texada s flexibility in temporal property inference makes it well suited for supporting program comprehension tasks.
in the second scenario we analyze a log with method call traces for a stack data structure.
our goal is to understand how this stack is exercised.
in this case the stack implementation is a java program provided with the daikon tool that implements a stack using an array.
note that in this implementation pop is called topandpop .
4throughout this paper we use log.txt to represent the file containing the log we are mining.
.
texada m f f x y parse mult prop log.txtfirst we want to know if all elements in the stack are always removed.
here we use texada s support and support potential statistics detailed further in section iv .
for the g x property the support is the number of xoccurrences and the support potential is the total number of events.
setting conf threshold to outputs all instantiations use global thresholds sets this threshold over the entire log and print stats prints out global statistics for each instantiation.
running .
texada l f g x conf threshold use global thresholds print stats log.txt gives g push java.lang.object support support potential confidence .
g topandpop support support potential confidence .
there are clearly more objects pushed onto the stack than popped off i.e.
.
notwithstanding possible exceptional situations it is likely that several objects are never removed from the stack in this scenario.
to learn more about the order in which push and pop are called we mine the x is always followed by y rule.
we summarize texada s results by grouping all outputted yinstantiations in brackets g isfull xf isempty top g push java.lang.object xf isempty isfull top topandpop g topandpop xf isempty isfull top g top xf isempty above we see that despite the fact that not all of the objects are popped off the stack at least some object must be since g push java.lang.object xf topandpop holds.
we also see that pop is always followed by top which gives us some information about the workflow.
finally we might want to check whether pop is ever called before push this is a pattern we do not necessarily expect to witness when a human exercises a queue and which could be unsafe.
for this we try to mine xalways precedes y ywx .
since all we are interested in is what needs to happen before pop we use texada s constant event option e to bind ytotopandpop .
the full command is .
texada m f !
topandpop w x e topandpop log.txt and the output is !
topandpop w isempty isfull stackar int top interestingly we see that push does not appear bound to x meaning that push does not always precede pop.
so in some runs pop is called before push.
as our focus has been on the relationship between push and pop it might be informative to check the method calls that always precede push binding yto push java.lang.object returns !
push java.lang.object w isempty isfull stackar int top topandpop the above tells us that in all executions any call to push was preceded by a call to pop.
this is unusual we might want to check if this stack has a guard mechanism to protect against calls to pop on an empty stack.
for this we mine instances of xis always immediately followed by y or g x!xy .
texada outputs the following instances g topandpop x isempty g top x isempty g push java.lang.object x isfull g makeempty x isfull the output supports the idea that the system has guards in place to prevent over and under flow isempty is always called immediately after the call to pop suggesting that it is called within the method.
similarly isfull appears to be called within push.
with these few calls to texada we have learned that the system calls more pushes than pops likely contains guards to prevent over and under flow and has no strict rules on push and pop method call order in fact pop appears to always be called before push.
the runtimes of these commands ranged between .034s and .065s.
the log consisted of traces totaling events and unique event types.
in both scenarios texada was useful because we had a precise idea of which correct invariants we were looking for.
in general it may be difficult to tell the difference between correct and incorrect invariants .
invariant filtering mechanisms either built into or on top of texada may be necessary to make texada accessible to more users.
iii.
t exada design this section overviews texada s design.
a more detailed treatment of texada s algorithms and design appears in our previous paper .
figure illustrates texada s high level operation.
texada works by taking an input log and a property type and then steps through the process illustrated in figure to output the instantiations of that property type which are valid over the log.
we describe the steps below.
parsing the log.
the input execution traces are parsed into an interpretable format step in figure using user supplied regular expressions see section iv .
the parsed unique event types are passed to the property instance generator.
texada supports two trace representations linear and map.
the linear representation is the natural one consisting of an ordered sequence of trace events which must be traversed sequentially.
the map representation is a set of maps each of which represents a trace the keys are trace events and the values are sets of positions at which the event occurs.
parsing property types.
we use the spot ltl parser to parse the input ltl property type into a tree structure step in figure .
an example of such an ltl formula tree is shown in figure .
our checking of property instances is based on traversal of the property tree.
we use this tree representation to eliminate redundant computation by performing checking state memoization since two instantiations of the same property type may have nearly identical tree representations.
our version of ltl is an extension of propositional logic with the following temporal operators6 x p poccurs at the next time point 6we also support the w r and m operators which are variations of u.property typelog parser spot ltl parserproperty instance generatorevent types ltl formula treeproperty instance checker property instancesparsed log valid property instancest exada execution tracesqueuear int makeempty isempty isfull getfront isempty isempty ... always followed by1 g x fx y fig.
.
overview of the texada process on a log generated by the execution of a queue.
puq pholds up to the first occurrence of q which must exist f p eventually poccurs g p pholds at every time point in the future in our version of ltl we use a specialized finite trace semantics to evaluate property instances on finite traces.
creating the space of property instances.
the event types taken from the parsed input traces along with the ltl formula tree are passed into a property instance generator which creates the space of property instances step in figure .
the space of property instances is by default generated on the fly cycling through all possible bindings of events to property type variables.
pre generating the instantiations is also an option.
by default bindings where two unique variables are bound to the same event are eliminated.
checking property instances over traces.
finally property types are checked against the input execution traces step in figure .
checking property instances over the linear and map representations of a log requires different algorithms.
the checking procedure over the linear trace benefits from the natural linear definition of ltl operators making it both extensible and reliable.
the algorithm proceeds by traversing the ltl formula tree like the one in figure at each node it applies the formal definition of the nodes to the trace often traversing the trace multiple times which limits its scalability.
in contrast the map trace algorithm uses the fact that most ltl operators apart from the next operator rely on the relative positions of events in the trace instead of their absolute positions.
this algorithm also traverses the ltl formula tree but employs the subroutines find first occurrence and find last occurrence to determine whether a high level node in the formula tree holds instead of just getting the result of checking at the nodes .
because this algorithm can skip over large sections of the trace for many property types it is more efficient than the linear checker.
however the map optimizations preclude the careful checking necessary to calculate support support potential and confidence statistics.
the map checker also involves some memoization and is generally the option to choose if efficiency is desired.
this concludes the outline of texada s overall design.
we now make some notes regarding its performance.
memoizing checking state.
texada checks nearly all property instances on each trace it stops checking a property instance when an invalidating trace is found .
because these instantiations may share the assignment of events tovariables in the property template texada will needlessly repeat the checking computation.
memoizing of checking state avoids this by storing the checking results from prior runs for a specific trace position and a formula tree node .
the memoization is currently implemented in the map checker s find first occurrence and find last occurrence subroutines.
runtime performance.
our extensive evaluation demonstrates that texada performs favorably against a specialized property type miner synoptic .
texada s map miner mines the synoptic property types faster than synoptic over all parameters increasing trace length trace number and number of unique events .
for example mining the synoptic property types on a log of twenty event long traces with unique events texada s map miner took 59s compared to synoptic s 69s.
we believe that texada is sufficiently fast to accommodate a variety of log input sizes and use cases.
iv.
o ther usage options besides the basic options reviewed in section ii texada includes a number of advanced options that we explain here.
parsing the input log.
in the scenarios we elided the log format assuming that the logs are in a format that is compatible with texada.
however texada supports custom regular expressions regexes to extract relevant events from log lines.
using the roption a user can input a list of regular expressions each specifying the structure of a matching log line.
the regex arguments require a capturing group with the name etype .
the texada parser step in figure attempts to match each log line with one of these regular expressions in order.
if a match is found the string captured by the named group etype becomes the event type of the line7.
mining temporal properties from a single execution is brittle so texada works best when there are multiple traces in the log file.
the user can specify a custom trace separator regular expression using trace separator which partitions the sequence of lines in a log into traces8.
if the ior ignore nm lines option is not specified texada will stop and show an error when a line fails to match the provided regular expressions.
with the ioption texada will instead ignore non matching lines.
texada includes several distinct algorithms which have different trade offs.
the user must specify either the linear lor linear trace or the map mor map trace checker 7the default regex is ?
etype .
8the default trace separator is algorithm both of which were detailed in section iii.
property instance generation.
as discussed in section iii texada is configured to generate property instances on the fly.
it can be configured to pre generate property instances with the pregen instants option.
by default texada will not allow distinct variables in the input formula to be bound to the same event.
for example if the input formula is g x!xfy texada will not check if g a!xfa holds on a log.
this double binding can be enabled with the allow same bindings flag.
property support and confidence thresholds.
while we used a confidence threshold in the comprehension of stack usage scenario the topic of support support potential and confidence warrants some further detail.
briefly support potential is the number of time points where the property type could be falsified support is the number of such time points where the property type is not falsified and confidence is the ratio of support to support potential.
for example we expect the support potential of ais always followed by b to be the number of aevents and its support to be the number of aevents which are eventually followed by a bevent.
we expect both support and confidence to rise if more aevents which are followed by bare added to a trace if aevents not followed by bare added to a trace we would like support potential to increase while support stays constant lowering confidence.
note that in this formulation the addition of bevents or unrelated events has no effect on the confidence of this property instance.
the ais always followed by b case is the ideal one for support and support potential and these statistics are currently approximated for other property types but may not quite reflect our intuition about what they should be.
see our previous publication for more details.
these statistics can help a user to reason about property instances that hold over a fraction of the traces but perhaps not all traces or not completely on all traces .
while these thresholds may help the user analyze imperfect traces texada has no mechanism reason about traces or logs beyond determining the satisfiability of property instances.
a log that requires data cleaning should be pre processed prior to being used as input to texada.
a series of options allow the user to specify thresholds for these statistics for output property instantiations with the linear checker.
these thresholds can be set with sup threshold sup pot threshold and conf threshold the default values for these thresholds are and respectively.
the no vacuous findings option stops texada from outputting vacuously true invalidated but not concretely supported expressions by setting the support threshold to .
note that enabling these options will cause a slowdown in the linear checker.
the option use global thresholds sets all the input thresholds as global over the entire log instead of over each individual trace .
this option causes even more slowdown since some inter trace optimizations can no longer be used.
full statistics for each outputted instantiation can be printed with the print stats option though this will disable most optimizations .
v. r elated work texada is not the only temporal specification mining tool but is to our knowledge the only one supporting fully gen eral user specified templates.
van der aalst et al.
developed an almost fully general ltl checker tool whose logic resembles the texada linear algorithm s logic but can only check one property instance as opposed to discovering valid property instances from a specified pattern.
unlike prior work which focuses on mining a few specific temporal patterns texada allows users to infer properties matching any pattern expressible in ltl.
since ltl may not be widely known the texada tool provides ltl version of the patterns in dwyer et al.
s work on temporal specifications the perracotta patterns and the property types used by the synoptic miner giving a total of included property types.
several specification miners are based around the response pattern yresponds to x or xis always followed by y as we have called it previously.
perracotta mines variations of the response patterns out of execution traces forming larger patterns by chaining the strictest response pattern i.e.
xy which the authors call alternating .
javert mines both the alternating and resource allocation i.e.
xy z patterns from dynamic traces and combines these into even more complex patterns the authors have also developed an algorithm to mine these based on binary decision diagrams .
researchers have also developed methods to handle imperfect traces by computing as just one example property instance interestingness scores.
the perracotta tool has thresholds for property interestingness gabel et al.
develop thresholds as part of their bdd based inference tool and lo et al.
allow users to specify support and confidence thresholds to determine which mined properties are statistically significant .
texada can mine all the properties these tools mine and most of their templates are distributed with texada.
another contrasting feature is that texada includes algorithms to compute support and confidence measures which can be used on imperfect traces or to allow the user to input thresholds for statistical significance.
in addition we have found that texada s performance compares favorably to the performance of a specialized invariant miner found in synoptic .
vi.
c onclusion this paper overviewed the texada tool which mines arbitrary ltl properties over textual logs regardless of the properties form.
we presented two usage scenarios to demonstrate how texada can be used to validate key properties of a concurrent program and support comprehension of program behavior.
we believe that texada is generally applicable and is especially useful for constructing more advanced analyses tools that require ltl specification mining.
for example we have used texada to mine temporal properties between data invariants an unanticipated use case of the tool.
texada is distributed with pre defined property types from prior work .
texada is an open source tool and is available at