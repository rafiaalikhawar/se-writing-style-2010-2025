directed test generation to detect loop inefficiencies monika dhok indian institute of science bangalore india monika.dhok csa.iisc.ernet.inmurali krishna ramanathan indian institute of science bangalore india muralikrishna csa.iisc.ernet.in abstract redundant traversal of loops in the context of other loops has been recently identified as a source of performance bugs in many java libraries.
this has resulted in the design of static and dynamic analysis techniques to detect these performance bugs automatically.
however while the effectiveness of dynamic analyses is dependenton the analyzed input tests static analyses are less effective in automatically validating the presence of these problems validating the fixes and avoiding regressions in future versions.
this necessitates the design of an approach to automatically generate tests for exposing redundant traversal of loops.
in this paper we design a novel scalable and automatic approach that addresses this goal.
our approach takes a library and an initial set of coverage driven randomly gene rated tests as input and generates tests which enable detectionofredundanttraversalofloops.
ourapproachisbroadl y composed of three phases analysis of the execution of random tests to generate method summaries identification of methods with potential nested loops along with the appropriate context to expose the problem and test generation to invoke the identified methods with the appropriate parameters.
the generated tests can be analyzed by existing dynamic tools to detect possible performance issues.
we have implemented our approach on top of the soot bytecode analysis framework and validated it on many open source java libraries.
our experiments reveal the effectiveness of our approach in generating tests that reveal bugs across seven libraries including previously unknown bugs.
the tests generated using our approach significantly outperform the randomly generated tests in their ability to expose the inefficiencies demonstrating the usefulness of our design.
the implementation of our tool named glider is available at .
ccs concepts software and its engineering software performance software testing and debugging keywords redundant traversal bugs performance testing .
introduction performance is of significant importance for any software application.
unfortunately underlying performance issu es are hard to detect in house during testing and usually manifest in the field .
not surprisingly these issues are found even in well tested commercial products .
since these bugsdegradetheapplication responsiveness techniquest hat improve the possibility of detecting these problems before deployment are helpful.
many effective techniques are developed to detect performancebugsautomatically.
these techniquesaddress variou s kinds of performance related issues including repetitive c omputations redundant loops object bloat latentperformance bugs andperformance issues inclouds and smart phones .
the performance problems due to repetitive and similar computations across iterations h ave been found in many mature codebases .
this has resulted in the design of efficient static and dynamic analysis techniques to detect these problems.
.
public class a .
public boolean containsany collection c1 collection c .
iterator itr c1.iterator .
while itr.hasnext .
if c2.contains itr.next .
return true .
return false .
.
figure example figure1illustrates the problem of redundant traversal.
here class ahascontainsany method which accepts collections c1andc2 as input.
the method iterates over c1to check whether one of its elements is present in c2.
this innocuous looking code can result in poor performance.
ifcontainsany is invoked with a non empty hashset and arraylist as parameters respectively repeated invocatio n of contains method line can result in a slowdown.
this is because the implementation of contains inarraylist has linearcomplexity as it traverses the list to check the presence of the element.
for each iteration of the outer loop line the elements in c2areunnecessarily traversed.
this redundant traversal can be addressed using memoization for example by ensuring that c2is hashset in this permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
artifact evaluated by fse case.
however the core problem is to identify their existence.
toddler employs dynamic analysis to detect loops which perform repetitive memory accesses.
it takes a set of tests as input and monitors their execution to detect repetitive accesses across loop iterations.
while unit tes ts provided by developers can be used for this purpose these tests can be less effective in revealing the entire gamut of de fects due to redundant traversals.
this is because the unit tests are usually directed towards ensuring functional cor rectness and not necessarily to expose redundant traversals.
therefore if the test does not cover the loops performing repetitive memory accesses analyzing its executi on becomes less useful.
manually writing the tests to help toddlerexpose the inefficiencies can be an arduous task.
in order to overcome the dependence on tests clarity employs static analysis to detect inefficient loops.
unfortunately the defects reported by static analyses nee d to be triaged by a programmer to ensure the validity of the reported defects .
in comparison if tests that expose the defects are available they can serve multiple purposes a help confirm the validity of the bug based on the execution time b the bug fix can be automatically validated by comparing execution times of the two program versions and c can be integrated into the testsuite to prevent any regressions in future revisions.
therefore to realize the se benefits without investing manual effort techniques for directed generation of tests to expose loop inefficiencies are desirable.
there are various challenges involved in generating tests to detect these defects.
firstly due to virtual call resolution a method invocation can be resolved to various methods depending upon the type of the receiver.
generating tests for all the possible resolutions of all the invocations is no t scalable.
secondly the realization of the defects can be dependent on conditions that can affect the reachability of the problematic loop.
therefore it is essential that the gener ated test has the appropriate context to ensure reachabilit y. finally the problem can manifest only when the data structure being traversed has large number of elements arranged in aspecificorder.
for example if the elements are ordered in a manner that the loop is not traversed completely then the redundant traversal cannot be detected.
we elaborate these challenges using the example in figure1.
to expose the underlying problem the generated test must have the following characteristics invokethemethod containsany withnon emptyinputcollections so that both the loops execute sufficient number of times pass an object of typearraylist as second parameter and usedistinctelements in the input collections so that the loop does not break at line .
tests that satisfy these conditions will perform redundant traversal of the list exposing the underlying problem.
our goal is to automatically generate these tests.
in this paper we address the goal of automatically generating useful tests to detect inefficient loops in libraries.
o ur approach takes a library and a randomly generated testsuite as inputand generates atestsuite that helps expo se the inefficient loops in the library.
our approach is composed of three phases summary generation phase which generates method summaries method detection phase whichidentifies methods whose invocation causes the inefficiencie s andtest generation phase which generates tests that invoke the identified methods with appropriate parameters under a suitable context.
these tests can be analyzed by toddler to expose the underlying defects.
more elaborately in the summary generation phase we generate a random test suite for the library using existing test generation tools evosuite randoop .
our analysis instrumentsthesetests andanalyzes theirexecut ion to derive method summaries.
a method summary is composed of information pertaining to the presence of loops th e object traversed in each loop and methods and the parameters invoked.
for example the summary of containsany method in the figure 1will represent the loop iterating on c1and the invocation of the contains method on c2.
we leverage the method summaries to directthe test generation process so that tests exposing loop inefficiencies alone are generated.
in other words this phase prunes the large state space of method sequences that can be invoked.
in themethod detection phase our analysis traverses the callgraph andidentifiesmethods thatmay executeinefficient loops when invoked.
for example while traversing the callgraph for the class corresponding to the example in figure1 this phase detects that there exist a nested loop if the method is invoked with c2of type arraylist.
it also keeps track of the addition of objects to collection array fields by different methods and identifies these methods as populator methods.
in the test generation phase we generate the test to invoke the identified methods in the previous phase.
we create the required objects receiver and parameters andensurethatthemethodis invokedwithappropriate types.
moreover we set the context based on the concrete execution from the initial set of tests so that the inefficient loops are reachable.
test generator also populates the coll ection array fields on which the loop traverses with distinct patterns and sizes using the populator methods detected in the previous phase.
the generated test will highly likely expose the redundant traversal problem in the method.
we have implemented our approach on the sootbytecode analysis framework .
we perform elaborate experimentation and analyze seven popular java libraries including apache collection andguava.
our implementation generates tests that enables detection of bugs including previously unknown bugs.
a few bugs reported by us are confirmed as real bugs by the developers of these libraries.
we fixed the bugs in house and executed the generated tests on the original and fixed versions.
we observed performance gains of to even with just elements in the collection objects on which the redundant traversal occurs.
our experimental results also demonstrate that more than of the generated tests help reveal a defect.
the implementation of our tool named glider is available at .
the paper makes the following technical contributions wepresentanovelandeffectiveapproachtogeneratetests for detecting inefficient loops in java libraries.
our analysis proposes a novel dynamic analysis to generate method summaries which are subsequently used to identify methods with redundant traversals.
these identified methods are invoked with appropriate parameters as part of the tests generated by our approach.
we implement the proposed approach on the sootbytecode analysis framework and present the implementation details necessary for our approach to be practical.
we validate our approach on seven open source java libraries and generate tests that enable the detection of bugs including previously unknown bugs.
.
motiv ation in this section we motivate the need for our approach by using a real example from the latest version .
.
of jfreechart library a free java chart library that helps developers generate professional quality charts.
categoryplot.java .
public class categoryplot .
private map integer categorydataset datasets .
public categoryplot ... .
public void setdataset int index categorydataset set ... .
this.datasets.put index set ... .
.
public int indexof categorydataset dataset .
for entry entry this.datasets.entryset .
if entry.getvalue dataset .
return entry.getkey .
return .
.
private list categorydataset datasetsmapped int id x .
for categorydataset set this.datasets.values ... .
int i indexof set ... .
.
.
public list getcategoriesforaxis categoryaxis axis .
int axisindex getdomainaxisindex axis .
datasetsmapped axisindex ... .
.
figure motivating example.
figure2presents a simplified implementation of categoryplotclass.
this implementation can cause an execution slowdown when used in other applications because of the redundantcomputationsinthemethod datasetsmapped lines .
this method traverses over datasets line .
during traversal this method invokes another method indexof which also traverses over the same data structure line .
this results in o n2 complexity where nis the number of elements present in datasets .
ifdatasets is populated with large number of objects we can observe a significant slowdown.
to detect this problem a test should invoke datasetsmapped method while ensuring that datasets contains large number of elements.
apart from these requirements there are intricate challenges in designing the test the programmer needs to find appropriate callsite to invokedatasetsmapped which is a private method.
the programmer should have detailed knowledge of the class hierarchy.
for instance in the generated test objects of type categoryplot categoryaxis andcategorydataset need to be instantiated.
to add large number of elements to datasets the programmer needs to identify the appropriate method.
the programmer needs to update datasets with appropriate parameters.
updating a map by adding many elements at the same index will not be useful.testcategoryplot.java .public class testcategoryplot .
public static void main string args .
categoryplot categoryplot new categoryplot .
for int i i args i .
defaultcategorydataset defaultdata .
defaultdata new defaultcategorydataset .
slidingcategorydataset slidingdata .
.
slidingdata new slidingcategorydataset defaultdata i i .
categoryplot.setdataset i slidingdata .
.
categoryaxis axis new categoryaxis abc .
categoryplot.getcategoriesforaxis axis .
.
figure sample test for defect in figure .
our implementation overcomes these challenges and automatically generates the relevant test.
to start with the ap proach generates random set of tests for categoryplot class.
in thesummary generation phase we monitor the execution of these tests and derive method summaries.
further in the method detection phase we identify methods that executes nested loops which includes the datasetsmapped method and the populator method that updates the collections for e.g.
datasets of the class.
subsequently using static analysis we identify methods to create objects that can be used to invoke the inefficient method.
finally we use this information to synthesize the test.
figure 3shows a sample test that exposes the aforementioned problem.
this test invokes getcategoriesforaxis method line which calls datasetsmapped .
we create the receiver of typecategoryplot for this method invocation at line .
the method setdataset accepts objects of type categorydataset as input.
since categorydataset is an interface required objects are created using appropriate constructo rs of subclasses.
we invoke setdataset method multiple times to populate the datasets field line .
manually designing this test is a non trivial task.
during execution the test i terates over datasets with numerous invocations of indexof thereby exposing the inefficient loop in datasetsmapped method.
we fixed the bug by merging the loops and verified the fix by executing the generated test which resulted in a speedup between the new and old versions when the number of elements in datasets is 100k .
.
design figure4presents the overall architecture of our approach.
our approach takes a java library as input and outputs the set of the tests that enable the detection of redundant traversals.
the generated tests execute the potentially in efficient loops with appropriate parameters.
our approach is broadly composed of three phases summary generation method detection andtest generation .
initially we generate a set of random tests using coverage driven test generation tools .
these tests and the input library are input to thesummary generation phase.
this phase generates method summaries that are input to the method detection phase.
this phase outputs set of methods that will execute potentially redundant traversals.
we also identify th e 1our bug report available at has been acknowledged by developers and our suggested fix is incorporated in the version .
.
.
phase random testsevosuiterandoop libraryjava summary generation method detection phase method summaries inefficient methods populator methods test generation phase generated tests figure architecture diagram.
populator methods that can be used to populate the collection array fields on which the traversal occurs.
finally test generation phase generates tests that invoke the methods identified in the previous phase using relevant parameters.
.
summary generation in this phase we generate method summaries which are used in later phases to identify the methods with potential inefficiencies related to redundant traversal.
a method summary contains details about the loop traversals in the method objects on which the loops are traversed and the set of other methods invoked.
we execute the randomly generated tests and analyze the execution trace to derive this information.
we employ dynamic analysis here to generate precise summaries and depend on the test generation tools to provide an initial set of tests with good coverage.
for this purpose we will need to track the various method invocations and the different loops that are traversed.
we identifyeach loop inthemethodusingasequenceofsymbols.
the sequence length represents the nesting depthof the loop in the method.
the symbols provide theconnection between the object on which the loop is traversed and the parameters that are input to the method containing the loop.
we also track the method invocations along with parameters and use symbols to connect the parameters in the invoking current method and the parameters in the invoked method.
more specifically we use the following data structures to encode this information.
loop s1 s2 ... s k methodsinvoked method params summary loop methodsinvoked methodsummaries method summary eachloopis distinctly identified by a sequence of symbols.
the length of the sequence represents the nesting depth.
the symbols are based on the parameters input to the method containing the loop.
if the object on which loop iteration happens at some nesting level is local and not reachable via the parameter passed to the method we use to represent the symbol at that nesting level in loop.
methodsinvoked is a map from method toparams which is the list of symbols corresponding to the objects passed tomethod.
the receiver of the method is encoded as the first parameter to the method invocation.
if the parameter passed to the invoked method is created locally then werepresent it by .
this is because the client of the invoking method cannot influence the behavior relevant to that parameter in the invoked method.
summary is a map from looptomethodsinvoked .
this binding enables us to maintain the association between the loops and the methods invoked within the loop context.
we represent the methods invoked outside a loop by mapping representing absence of loops to methodsinvoked .methodsummaries integrates summary of all the methods invoked from the tests.
1public void foo a a b b c c 2hashset set new hashset 3for e e a a is a collection of elements of type e set.add e for e f b c.remove f b collection of type e a.baz c 8a.update figure example for method summary generation more elaborately the methodsinvoked structure for the simple example given in figure 5is add4 sa remove sc sb baz6 sa sc update sa here the element add4 sa means that method addis invoked at line the first parameter receiver is local and is therefore represented by a and the second parameter is given by symbol sa where sais associated with the symbol passed as the parameter to foo.
the other elements in the map can be constructed accordingly.
the distinct loops in fooare sa sa sb representing the loops from lines and respectively.
the summary of methodfoois shown in table .
table summary for method foo loop methodsinvoked sa sa sb algorithm 1presents the procedure for generating the method summaries for the input library.
it takes a random set of tests as input and outputs the methodsummaries object containing the summary of each method.
in this procedure we execute each test from the set of random tests line .
during the execution of these tests we monitor three types of instructions a loop start b method invocations and c loop finish.
algorithm genmethodsummary input a random set of tests t output methodsummaries foreach test tintdo execute t while i nextinstruction t exception halt do switch ido case loop start o getlooptarget if islocal o thenappend toloop elseappend symbol o toloop case loop finish remove last symbol from loop case invocation of method x m getcurrentmethod mi getmethodsinvoked loop mi getsymbols x mi return 898if the current instruction is a loop start we use the auxiliary function getlooptarget toobtain the object oon which the loop traversal happens line .
if this object is create d locally modifying the object directly is not feasible from the client invoking the method.
therefore we append toloop line .
on the other hand if ois not local then we add the associated symbol line .
on a loop finish we simply remove the last element from loopto reflect the nesting level appropriately.
when a method xis invoked we get the methodsinvoked inmi in the corresponding loopfrom the method summary of m wheremcontains the invocation of x line .
we update the method summaries to appropriately represent the invocation of x lines .
information in the loopis intraprocedural.
for ease of presentation we do not show the stack related operations needed to maintain the intraprocedural data.
for example ifxis invoked from mat a nesting depth of two the invocations of other methods in x assuming the absence of loops inx is considered to happen outside the context of a loop.
wemergetheintra proceduralinformationinthemethoddetection phase see section .
.
at the end of the procedure in algorithm we return the updated methodsummaries object containing the summary of each method.
.
method detection in this section we elaborately discuss the details of two components in method detection .
the first component identifies inefficiently implemented methods that execute nested loops.
the identified methods are invoked with appropriate parameters during test generation.
the second component derives populator methods which adds elements to the collections or arrays and can be used to setup the context.
for instance these methods are used to populate collection s with large numberof elements in specific patterns toensur e that repetitive memory accesses are performed across itera tions.
executing the populator methods is essential before invoking the inefficient methods to expose the problem.
.
.
inefficient methods withthehelpofsummariesderivedforeachmethodinthe previous phase we determine if the method can potentially execute nested loops.
for this purpose we traverse the call graph in a topologically reverse order and mergesummaries at each node.
finally we have a mapping from methods to the list of possible nested loops.
for any method min this map whenitisinvokedwithappropriateobjects correspond ing to the symbols present in the nested loops the execution will entail nested loop iterations.
exposing the magnitude of the inefficiency will be handled by the populator methods which is discussed in the next subsection.
the procedure to identify the inefficient methods is presentedin algorithm .
algorithm 2accepts themethodsummaries and a class as input and outputs the candidates map which contains the map from methods to list of potential nested loops.
initially algorithm 2builds the callgraph for the input class line where each public method in the class is considered an entry point.
vis the list of methods obtained after performing a reverse topological sorting on g line .
webreakcyclesinthecallgraphrandomly.
foreachmethod inv if a method is the leaf node in the callgraph then other method invocations are not feasible.
hence the only possible loops are the loops that exist in m. therefore wealgorithm identifying inefficient methods input method summaries class output candidates method loop graphg getcallgraph v reversetopologicalsort g for method minv do if mis leafnode in g then candidates getloops goto label for calleenofm do loop getloop n candidates loop candidates remove all the private methods from candidates remove any loop from candidates with length returncandidates extract all loops using getloops from and add it to candidates line .
for the non leaf methods we consider each callee nof method m. this is to explore all possible nesting behavior.
therefore we recursively mergethe summary of methods m andnusing the operator.
this operator accepts a loop corresponding to callee nin line and all possible loops present in candidates and generates a list of merged loops line .
we define the operator using patterns angbracketlefts1 ... si angbracketright angbracketleft angbracketright angbracketlefts1 ... si angbracketright angbracketleft angbracketright angbracketlefts1 ... si angbracketright angbracketlefts ... s i angbracketright angbracketlefts1 ... si angbracketright angbracketleftsl sm angbracketright angbracketlefts1 ... si s l s m angbracketright angbracketlefts1 ... si angbracketright angbracketleft angbracketleftsk angbracketright angbracketleftsl sm angbracketright angbracketright angbracketleft angbracketlefts1 ... si angbracketright angbracketleftsk angbracketright angbracketlefts1 ... si angbracketright angbracketleftsl sm angbracketright angbracketright equation 1and2imply that the merge operation on is identity albeitwithmodificationstothesymbolsinequati on representedbya tolocalize thesymbols in thecontextof the caller.
equation 3represents the merging of two nested loop sequences angbracketlefts1 ... s i angbracketrightand angbracketleftsl sm angbracketrightrespectively to output a single nested loop sequence.
equation 4presents a scenario where merging is done with two loops in the callee angbracketleftsk angbracketrightand angbracketleftsl sm angbracketright .
it corresponds to independently merging the two loops as shown in the equation.
after updating candidates for each method in algorithm2 lines we remove all the private methods from candidates .
this is because we can not invoke private methods directly.
we also remove any loopwith length less than two because these cannot expose any non linear inefficiencies.
finally the candidates map contains a list of methods and the possible nested loops within these methods.
these methods can be invoked with the appropriate parameters to expose potential inefficiencies.
m1 m2 m6m7m5m3 m4 figure example for deriving inefficient methods we now illustrate the working of algorithm 2using the callgraph given in figure .
the graph has seven methods named m1 ... m7.
the shaded node m4 represents a 899private method.
we assume an implementation where the method summaries including loops methods invoked their parameters are as shown in table .
for ease of presentation we use the notation sij which represents the symbol corresponding to parameter jof method mi.
table summaries for example in figure method mloop method params candidates m4 an bracketle ts41 s42 an bracketri ht an bracketle ts41 s42 an bracketri ht m2 m4 an bracketle ts23 s22 an bracketri ht an bracketle ts23 s22 an bracketri ht m6 m7 an bracketle ts71 an bracketri ht an bracketle ts71 an bracketri ht m5 m6 m7 an bracketle ts51 an bracketri ht an bracketle ts51 an bracketri ht m3 an bracketle ts32 an bracketri htm5 an bracketle ts31 an bracketri ht an bracketle ts32 s31 an bracketri ht m1 m2 an bracketle t s11 an bracketri ht an bracketle ts11 an bracketri ht m3 an bracketle t s11 an bracketri ht an bracketle ts11 an bracketri ht algorithm 2traverses this graph in a reverse topological order and starts from method m4.
according to the summary in table m4does not invoke anymethod.
hence we add the existing loopto thecandidates map.
subsequently we consider m2which invokes m4withparams angbracketlefts23 s22 angbracketright outside a loop based on a forloop .
we merge angbracketleft angbracketrightand candidate given by angbracketlefts41 s42 angbracketrightto obtain angbracketlefts23 s22 angbracketright.
this is because the loop in m4corresponds tothe first two parameters ofm4andoursummaryconnectsthemtothethirdand second parameters of m2respectively.
similarly while calculating the candidate we observe that m2is invoked outside a loop.
the candidate specifies the presence of a nested loop associated with traversing angbracketlefts23 s22 angbracketright.
since this corresponds to angbracketlefts11 angbracketrightbased on the parameter summary for m2when invoked in m1 we obtain the relevant candidate .
the remaining candidates shown in the table are obtained in a similar manner.
finally we can remove m4which is a private method and anyloopwith depth e.g.
in m7 m1andm5 .
the final candidate mappings are given below m2 angbracketlefts23 s22 angbracketright m3 angbracketlefts32 s31 angbracketright if we invoke m2andm3with the appropriate parameters we can potentially expose the inefficiencies due to the implementation of m4 a private method and the nesting that transcends method boundaries m3andm7 .
.
.
populator methods in this section we discuss the procedure to derive populator methods.
given an inefficient method that needs to be invoked along with symbolic information on parameters we need a mechanism to populate the collections corresponding to those symbols to enable traversal of the loops.
in order to derive the methods that can help populate the collection objects we monitor the execution of methods tha t operate on the objects of that type.
if there is an increase in the total count of the elements in the collection object after an invocation of a method the method is identified as a possible populator method.
since there can be multiple methods which can affect the overall count we rank the identified methods based on the behavior of the method in different contexts and select the highest ranking method.
more elaborately we consider each test from the suite of random tests.
for any method minvoked from a test we statically extract the set of class fields of collection typ es sayw updated in the method.
we execute the test and count the number of elements present in each field w w just before invoking the method m. after method exit we recount the number of elements in the field wfor presence of additional elements.
if additional elements are present w econsiderthemethodasapossiblepopulator.
afterrepeatin g this procedure for each test from the set of random tests we rank the overall populator methods for any given type and select the highest ranking method.
also we do not consider constructorsas possible populatormethodsbecau se they cannot be repeatedly invoked to increase the size and will deliver independent objects.
class b .public class b .
hashset set .
public b set new hashset .
public void add a a .
set.add a .
public void initialize .
set new hashset new a .
test .b b new b .b.initialize .b.add new a .b.add new a figure example class band corresponding test we use the example in figure 7to illustrate our approach.
for the class bunder consideration the constructor initializes the field set.
method addadds input object atoset line and method initialize assigns a new hashset with one element line .
while monitoring the methods invoked from the test shown on the rhs of the figure we ignore the invocation of the constructor at line .
before invoking initialize at line we count the number of elements in setand obtain .
after executing initialize we observe an increase in the number of elements by one and is considered a possible populator.
similarly we observe addition o f elements by addand include it as a populator.
since add increases the overall count under different contexts we ran k it higher and select it as a populator method for setinb.
.
test generation in this section we discuss our approach to generate tests that execute nested loops in the library with the appropriate objects.
algorithm 3takes the methods identified as inefficient and populator from the previous phase as input.
we represent the set of methods using iandprespectively.
the goal then is to generate tests that invoke methods in i and ensure that the objects corresponding to the parameters of the method have large number of elements and cover the code region that contain the inefficiencies.
algorithm genperftests input class inefficient methods i populator methods p for eachmini do for eachloopini do receiver createobject for each parameter iinm do if iis inloop then type gettype i i createobject type mp p for j j count j do for each parameter ptomp do cj createobject gettype p invokempon iwith params c1 c2 ... cn else i reuse parameter from test invoking m invokemwithreceiver on params 1 2 ... n algorithm 3traverses all methods in imap line .
for each method m we iterate over each problematic nesting behavior line .
we instantiate the method musingcreateobject an auxiliary function which takes the type of the object as input.
900we perform a simple static analysis to enable instantiation of the object.
if the class is public we extract the set of public constructors.
if the class has only private constr uctors we derive the appropriate callsites within the class a nd use them for instantiation.
if the class is private abstrac t or an interface we traverse the class hierarchy graph and check all the public subclasses and identify public constructors.
if the constructor requires further objects we recursively perform a similar procedure.
after collecting all the required constructors we instantiate the objects appr opriately to obtain the receiver for invoking the method m. after creating the receiver object we need to create parameters to invoke the method m. moreover we need to ensure that parameter objects on which loop traversals happen in the implementation of mare suitably populated.
therefore if the parameter corresponds to an object on which a loop traversal can happen it will be present in the sequence of symbols represented by the loop line .
otherwise we simply reuse the parameter from the original random test invoking m line .
this is because if the inefficient region under consideration is dependent on the value of the parameter there will be minimal changes and the possibility of th e generated test reaching the inefficient regions is higher.
if the parameter is part of the loop sequence then we create the object of the appropriate type after obtaining it s type lines .
further wepopulatetheconstructedobje ct lines .
we obtain the populator method mpbased on the type of the object line .
subsequently we invoke the method mpbased on a parameterized number of times count .
to obtain parameter objects for the invocation we employcreateobject line to instantiate the objects.
we now illustrate the working of algorithm 3using an example.
consider the input iandpas follows i p based on the data in i we need to generate a test that invokesfoowith appropriate objects for first and second parameters to foo.
the populator method for object of type b isupdatewhich takesobjects oftype c. figure8presentsthe test generated.
it invokes method foothat will help expose the redundant traversal defect.
for the first two parameter objects on which the loop traversal happens the objects are created at line and populated subsequently using the information present in p. because the third parameter to foo need not be modified we simply obtain the value used in the concrete run using getruntime method.
.
public class test .
public static void main string args .
a a new a .
b b1 new b b b2 new b .
for int i i args i .
c c new c random int .
b1.update c .
.
for int i i args i .
c c new c random int .
b2.update c .
.
a.foo b1 b2 getruntime flag .
.
figure generated test4.
implementation we have implemented the algorithms discussed earlier as part of the sootbytecode analysis framework .
our implementation generates tests for java libraries.
we now discuss the tradeoffs considered to make our implementation practical.
.
populating the collections with patterns in algorithm we discussed the procedure to instantiate the objects that can be used as parameters for the various method invocations.
we now discuss how the parameter objects can be populated.
while a straight forward approach to populate collection objects is to provide randomobjects it may not always be useful in exposing potential problems.
for instance if there is a search of an element in a traversal and the element being searched and the first element in the traversal coincidentally match then the underlying probl em may not beexposed.
this is also necessitated as our analysis is light weight and does not track path constraints.
therefore to broaden the possibility of identifying the inefficie ncies we use the patterns based on size similarity among the elements across collections and the type of elements.
.size to handle multiple scenarios where the implementation makes choices dependent on the size of the collection objects on which the traversal happens we use two variants for all pairs of nested loops a collection sizes are equal and b size of first collection is less than the second and vice versa.
.similarity afewiterationsare dependentonthesimilarity of elements across the collection objects under consideration.
therefore we use three variants to populate the collections with elements a all elements are distinct b all elements are the same and c first collection is a subset of the second collection and vice versa.
.type of elements if the collection has a specific type and is extended by multiple other types we ensure that the original collection can take all possible types.
this is to ensure that any path condition that is dependent on the type of the collection is satisfied thereby exploring the code covered by the condition.
because of the three different patterns the number of possible combinations among them e.g.
same size different elements same type same size same elements same type etc.
can be significant.
our current prototype handles a limited combination of these patterns.
.
handling multiple method summaries the input random tests can invoke the same method multiple times under different contexts.
therefore we need to choose a summary among the possible summaries in the process of generating candidate methods.
we prioritize the summaries based on the nesting depth of the loop methods invoked from the loop and number of methods invoked.
more specifically for two summaries 1and 2 we prioritize them as follows.
if 1has nesting loop depth greater than that of 2 we use the former.
if both have the same nestingloop depth thenwe prioritize thesummary that contains more method invocations within a loop context.
if this value is also the same we choose the summary that contains more method invocations outside loops .
901table benchmarks benchmark idversionkloc classes analysed methods static nested loops randomly generated testsanalysis time s apache collection b14.
.
pdfbox b21.
.
groovy b32.
.
guava b4182517 jfreechart b51.
.
ant b61.
.
lucene b75.
.
.
parameterizing random test generation our approach accepts a randomly generated set of tests as input.
we use evosuite andrandoop for this purpose.
a key goal is to invoke more number of methods so that inter procedural summary information can be updated suitably.
therefore we guide the random test generation tools to invoke more methods by setting the relevant parameters in these tools.
.
optimizing virtual call resolution we statically analyze types of all the fields in the class and track the type bindings performed in each constructor.
this is to optimize the virtual call resolution and reduce th e overall possible set of methods that can be invoked.
.
public class a .
public b order .
public a order new c .
public void foo .
... .
order.baz .
... .
we illustrate this using a simple example as shown above.
acontains a field orderof typeb line .
the constructor at line restricts the type to field c under the assumption thatbis a superclass of c .
in the invocation of bazfrom foo we use this information to restrict the possible types on which bazis invoked.
.
experimental ev aluation in this section we report the evaluation of our implementation and demonstrate the effectiveness of our approach.
we have applied our approach to many popular java libraries.
our selection of benchmarks was guided by earlier bug reports on these benchmarks .
we performed our experiments on an ubuntu .
desktop machine with a .5ghz intel core i7 processor with 16gb of ram.
table3providesthedetailsofthebenchmarksusedforour experiments.
apache collection provides many powerful datastructuresthatare usedtobuildjavaapplications pdfboxis a java tool for working with pdf documents groovyis aoptionallytypeddynamiclanguage thathasstatic compila tion capabilities guavais the google core libraries for java jfreechart is a java chart library to display professional quality charts antis a java library and command line tool to help build software and luceneis a high performance full featured text search engine library.
for brevity as i ndicated in the table we refer to our benchmarks as b1through b7.
the table presents the version of the different benchmarks used for our experiments.
the lines of code varies from 117kl for apache collection to .5mc for guavalibraries.
we select the classes in these benchmarks on which bugs are reported in other papers .
the cumulative numberof methods in all these classes varies from for groovyto forguava.
we also count the static nested loops present in the analyzed code which ranges from to .
the total method and loop count indicate without even considering the parameters to method invocations and the complexities duetovirtual calls that analyzingevenfew classes manual ly is a nontrivial task.
we use evosuite andrandoop to generate the initial tests of random tests that is used as input to our implementation.
we restrict the number of tests generated by these tools to for each class under consideration .
the overall time to generate the random tests ranges from a minute to minutes.
essentially these tests invoke the va rious methods in the class with random objects.
we designed our experiments to answer the following research questions .rq1 is our implementation effective in generating bugrevealing tests?
.rq2 is our approach useful for practical adoption?
.rq3 are randomly generated tests sufficient to expose the redundant traversal problem?
.rq4 how many elements in the collection object will be necessary to expose the underlying performance issue?
.
rq1 effectiveness of test generation table information on generated tests detected bugs and analysis time.
id generated tests bugs new bugs false positivesanalysis time min b1 b2 b3 b4 b5 b6 b7 total table4presents the information on the tests generated using our approach when the initial test suite consists of test s from various test generators .
the number of generated tests varies from for b7to for b1.
this is significant reductionfrom thetotal numberofrandomlygeneratedtests that is input to our implementation.
ideally these tests wi ll be input to toddler to detect bugs.
however since the implementation of toddler is unavailable2 we manually analyzed the generated tests.
this helped us reveal bugs in these benchmarks including previously unknown performance issues .
the number of bugs detected also depends upon the generated tests.
we observe that bugs are detected when the set of patterns proposed in the section .1are disabled.
other bugs are missed because the test with default pattern either generates objects of inappropriate types or do not meet the conditions to execute the loop.
2personal communication adrian nistor 902our approach is able to generate useful tests by analyzing random tests.
the generated tests detect performance problems even in well tested open source java libraries.
.
rq2 practicality of our approach table4also gives information on the practicality of our approach.
there are two key issues involved w.r.t practical ity of program analysis tools false positives and analysis time .
a few tests generated by our approach do not reveal any defects.
our approach generates eight tests that do not reveal any defect.3based on industry standards the false positive rate of less than is negligible.
on closer examination the false positive tests are mainly due to two reasons generated tests take a different path compared to the original test and absence of redundancy during nested loop traversal.
for example the implementation of the library in apache collection compares the size of objects present in the two input collections and follow a path based on the result.
since our generated test did not use this constraint recall that our current prototype e xplores a limited combination of patterns for parameters w e generate atestwhere adifferentpathis taken.
inafewother cases e.g.
jfreechart ant there is no redundancy in the traversal e.g.
dimensional table checking for duplic ate elements in list .
this set of false positive can be elimina ted when their executions are analyzed using toddler .
the overall time taken to generate the tests for all the benchmarks is around .
hours.
on average this corresponds to minutes per analyzed class.
this time depends on the number of tests considered in the beginning and also the length of method sequences in those tests.
more than of the tests generated by our approach help in bug detection and the time taken is less than five minutes per class.
these numbers indicate the potential for seamless integration of our implementation in the software development process.
.
rq3 comparison with randomly generated tests b1 b2 b3 b4 b5 b6 b7percentage performance improvement benchmarksrandom tests generated tests21.11s .49s .94s .51s .92s 18s .09s2.59s .27s .24s .96s .25s .68s .06s figure comparison with randomly generated tests.
we now discuss the usefulness of the tests generated by our approach as compared to the random tests.
the first author created new versions of the libraries by fixing the 3many defects are detected by multiple generated tests.bugs appropriately by removing redundant traversals.
the generated testsuite with 10k elements populated in the col lection objects and the input random testsuite were executed on the original and fixed versions of the libraries.
figure9presents the percentage performance improvement of the fixed version over the original version for the two test suites across all the benchmarks.
the time taken to execute the original version is shown on top of the bar e.g.
.
seconds to execute randomly generated tests on b1 .
the figure clearly demonstrates the huge performance gains observed on the generated tests as compared to the random tests.
this is because the generated tests are directed towards exposing the problems that are addressed by our fixes.
moreover the time taken to execute the generated tests on the original version is significantly less than that of the random tests across all benchmarks.
this suggests that the generated tests can be used as part of a regression testsuite.
moreover themagnitudeofperformancegains implie s that the use of existing dynamic tools like toddler will be more successful with the generated tests.
the generated tests take less time toexecute and are more suitable to expose the magnitude of the underlying performance problem.
.
rq4 size of the collection objects in order to use our implementation for practical purposes we wanted to find the number of elements in the collections to help expose the inefficiencies with the loop.
therefore we consider the original and fixed versions of the benchmark.
further we modified the number of elements that are populated in the collection based on the countparameter from to 100k.
then we execute the generated tests on the original and fixed versions and compare the percentage performance improvement in time between the two versions.
figure10presents the corresponding results.
100000percentage performance improvement input sizesb1 b2 b3 b4 b5 b6 b7 figure percentage performance improvement.
accordingtothefigure theperformance improvementsaturates after 10k elements.
in other words populating the collection objects with 10k elements will yield sufficient re petition of memory accesses leading to the detection of the underlying problem.
populating the collection with fewer e lements e.g.
less than 1k elements may not always demonstrate a substantial difference.
populating the collection objects with 10k elements will enable detection of performance issues.
.
threats to validity our approach is sensitive to the initial set of random tests used.
if these tests do not cover problematic code regions our approach will not be able to generate the necessary tests a drawback that is shared with other dynamic analyses.
our ability to identify populator methods can also be hampered due to this reason.
also as we do not explicitly track the path conditions it is possible that the generated tests may cover a different path which can reduce the effectiveness of our approach.
although benchmarks used in our experimental results are representative of most codebases it is possible to have custom codebases where our analysis may be less effective.
.
related work detection of redundant traversal bugs.
elegant techniques to detect redundant traversal bugs have been designed recently .toddler is a dynamic analysis technique that analyzes execution of input tests to detect repetitive memory accesses.
the effectiveness of the technique is dependent on the ability of the input tests to expose the problem.
manually writing these tests is nontrivial andrandom test generation is not effecti ve.
our approach is complementary to toddler as we generate the tests that can be used by it.
clarity analyzes the source code of the library to detect redundant nested loop traversals.
however as we discuss earlier it is difficu lt to automatically confirm the bug validate any fix and use the information to avoid future regressions.
in contrast o ur approach generates tests to serve these purposes.
detection of performance bugs.
many useful techniques to detect a variety of performance bugs have been designed .
dynamic analyses have been proposed to detect problems pertaining to object bloat in java programs .
mudduluruet al propose an approach to efficiently instrument object flow profiles and use them to detect object bloats.
yanet al propose a framework for building runtime graphs that can be used to detect this problem.
resurrector uses dynamic analysis to detect problematic code regions which can be fixed to reduce gc pressure.
bhattacharya et al propose a hybrid approach to detect object bloat due to unnecessary creation of temporary container and string objects.
techniques that propose static identification of locations where dead objects can be reclaimed are also proposed .
other proposed techniques include identifying wasteful use of temporary objects incorrect use of data structures latent performance bugs and performance issues in clouds and smartphones .
eventbreak uses a random testsuite and identifies event handlers whose execution time may gradually increase while using applications.
this approach generates more tests based on its execution.
our approach differs by white box analysis and by focusing on unit level tests.
all these tech niques are geared towards detecting other kinds of performance problems.
our approach generates tests to expose redundant traversal bugs.
automated test generation.
automatic test generation tools for java utilize feedback from generated tests.
we use the tests generatedby these random test generators as input to bootstrap the process of generating tests necessary for exposing loop ine fficiencies.
seeker combines static and dynamic analyses to synthesize method sequences that are necessary for high coverage testing.
concolic testing that integrates symbol ic execution with concrete trace information enhancing path coverage has been effective in detecting bugs .
our approach is inspired by these techniques and combines concrete traces with symbols to generate the necessary test s. our approach will benefit from the tests generated by this approach as it increases coverage thereby the possibilit y of exploring the problematic code regions containing the loop s. test generation for detecting concurrency bugs.
automatically generating multithreaded tests to detect data races deadlocks and atomicity violations have been found to be effective in detecting rare bugs in well tested and thread safe java libraries.
these techniq ues analyze the execution of a random set of sequential tests to generate the required tests.
our current approach is inspired by the successes of the test generators in the context of detecting concurrency bugs.
our approach also operates by analyzing a random set of tests and uses this concrete information to generate relevant tests.
profiling.
profiling is a common technique to detect performance problems in programs.
ball and larus propose a numbering scheme to get statistics on the control flow paths traversed in an execution with minimum overhead.
many extensions to this technique have been proposed .
in the imprecision of path profiling due to loop iterations is addressed.
improving garbage collection by profiling data due to dynamically created objects is also proposed .
our work is orthogonal to these approaches as we enable detection of unnecessary traversal s of loops to improve the performance of libraries.
.
conclusions redundant traversal of loops under nested conditions can affect the overall performance of java libraries.
the useful ness of existing techniques to detect these problems can be significantly enhanced in the presence of a directed test gen erator that generates tests to help expose these inefficienci es.
in this paper we designed a novel scalable and automatic dynamic analysis technique that analyzes the execution of randomly generated tests to construct targeted tests whic h can serve as input to existing dynamic analyses.
the evaluation of our implementation on many java libraries demonstratetheefficacyofourdesign.
ourtoolgenerated224tests that enabled detection of bugs including previously unknown bugs.
.