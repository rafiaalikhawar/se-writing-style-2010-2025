perses syntax guided program reduction chengnian sun university of california davis ca usa cnsun ucdavis.eduyuanbo li university of california davis ca usa yboli ucdavis.eduqirun zhang university of california davis ca usa qrzhang ucdavis.edu tianxiao gu university of california davis ca usa txgu ucdavis.eduzhendong su university of california davis ca usa su ucdavis.edu abstract given a program pthat exhibits a certain property e.g.
ac program that crashes gcc when it is being compiled the goal ofprogramreduction istominimize ptoasmallervariant p primethat still exhibits the same property i.e.
p prime .
program reduction is important and widely demanded for testing and debugging.
for example all compiler interpreter development projects need effective program reduction to minimize failure inducing test programs to ease debugging.
however state of the art program reduction techniques notably delta debugging dd hierarchical delta debugging hdd andc reduce donotperformwellintermsofspeed reduction time andquality sizeofreducedprograms orare highly customized for certain languages and thus lack generality.
this paper presents perses a novel framework for effective efficient and generalprogramreduction.the keyinsight istoexploit inageneralmanner theformalsyntaxoftheprogramsunderreductionandensurethateachreductionstepconsidersonly smaller syntacticallyvalid variantstoavoidfutileeffortsonsyntactically invalid variants.
our framework supports not only deletion as for dd and hdd but also general effective program transformations.
wehavedesignedandimplemented perses andevaluateditfor twolanguagesettings candjava.ourevaluationresultson20c programstriggeringbugsingccandclangdemonstrate perses s strong practicality compared to the state of the art smaller size perses s results are respectively and45 in size of those fromdd andhdd and shorterreduction time persestakes and47 time taken by dd and hdd respectively.
even when compared to the highly customized and optimized c reduce for c c persestakes only reduction time.
ccs concepts software and its engineering software testing and debugging permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
program reduction delta debugging debugging acm reference format chengnian sun yuanbo li qirun zhang tianxiao gu and zhendong su.
.perses syntax guidedprogramreduction.in icse icse 40th international conference on software engineering may june gothenburg sweden.
acm newyork ny usa 11pages.
.
.
introduction program reduction is important and widely used.
given a program pthat exhibits a property the objective of program reduction is to generateasmallerprogram p primefrompthatstillexhibitsthesame property.
the reduction process continuously generates smaller programvariants andchecksthemagainsttheproperty.aminimal variant that perserves the property is returned at the end.
a common usage scenario for program reduction is reducing test programs that trigger compiler bugs.
it is well known that debuggingtypicalapplicationsoftwareispainstakinganddaunting.
debuggingcompilerscanbeevenmoredifficultascompilersare amongthemostcomplexsoftwaresystems e.g.
gcc scodebase is close to million lines .
it is worse when the bug triggering programcontainsalargeamountofirrelevantcodetothebugas compiler developers need to manually distill useful information fromthetestprogram.mostofthetime thesizedifferencebetween the original and the distilled version can be considerable.
for example a recent study on the characteristics of bugs in gcc and llvm hasshownthat onaverage minimizedtestprograms contain only lines of code to trigger compiler bugs.
in contrast the original bug triggering test programs may have hundreds or thousands of lines of code .
therefore it is important to automatically compute the distilled version.
indeed compiler developers strongly encourage submitting small reproducible test programs both gcc and llvm advocate test reduction in their bug reporting processes .
existing reduction techniques.
the state of the art program reduction techniques are delta debugging hierarchical delta debugging and c reduce .
delta debugging dd zellerandhildebrandt pr oposeddd to minimize failure inducing test inputs.
it is general and works on not only programs but also arbitrary inputs as dd can operate attheindividualbytelevel.initially thetestinputissplitintoalist of elements at acertain granularity e.g.
byte lexeme or line .
new acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden chengnian sun y uanbo li qirun zhang tianxiao gu and zhendong su inputsarethensystematicallygeneratedbydeletingelementsfrom thelist andcheckedwhethertheystilltriggerthesamefailure.the algorithm terminates with a minimal failure inducing input.
dd is general but not suited for reducing programs because bydesign itdoesnot leveragenorrespect syntaticstructuralconstraints available in programs and enforced by a programminglanguage s formal syntax.
thus dd inevitably considers a large numberofcandidateinputsthataresyntacticallyinvalid leading to poor reduction performance.
hierarchical delta debugging hdd misherghi and su p r o posed hdd to improve the effectiveness of dd for tree structured inputs.differentfromdd hddconvertstheinputintoatree w.r.t.
the input s format.
in the particular case of program reduction hdd converts a program into its parse tree or abstract syntax tree ast performsbreadth firstsearchonthetree andinvokesthe dd algorithm on each level to prune tree nodes from that level.
although hdd s tree based reduction considers fewer syntacticallyinvalidprogramsthanddandthusoutperformsit itprovides no guarantee and still generates many syntactically invalid inputs e.g.
removingthevariablenamein adeclaration .the reasonis that hdd only uses the formal syntax of a language i.e.
its grammar to convert a test input into its tree representation but does notexploitthegrammarfurthertoguidereduction.ashdd score reductionisbasedondd itgeneratessmallerprogramsonlyvia deletion thus may be incapable of generating smaller programs that require other transformations see section for illustration .c reduce regehret al.proposedc reduce ahighlycustomized reducer for c c that embodies a set of c c program transformations implemented via the clang libtooling library.
although c reduce is powerful at minimizing c c programs the reduction process may take significant time.
to mitigate its performance issue le et al.combined dd and c reduce to reduce c test programs in the emi compiler testing work .
more importantly c reduce is not general to support another programming language one needs to re design and re implement program transformations targetting the language which is obviously nontrivial.
in short dd is fast but often cannot produce good quality i.e.
small reductions c reduce offers high quality reductions forc c programs butlacksgeneralityandtakesmuchreduction time and hdd is in between it produces better reductions than dd and runs faster than c reduce.
syntax guided program reduction.
thispaperaddressesthe aforementioned shortcomings of existing techniques by proposing anovelframework perses toenablegeneral effective andefficient program reduction.
our conceptual insight is to utilize the formal syntax i.e.
grammar of a programming language to guide reduction.our technicalinsight istoleveragethegrammarto generate only syntactically valid inputs and support generic effective program transformations.
inmoredetail programreductionisaboutsearchingforsuitable programsinasearchspace p 1whichcanbepartitionedintotwo disjoint sets the set of syntactically valid programs pvalid and the set ofsyntactically invalid onespinvalid i.e.
p pinvalid unionmultipvalid 1pistheuniverseofcandidateprogramsthataprogramreducercanderivefrom p wherepis the initial program to reduce.where unionmultidenotesthedisjointunionoperator.ddandhdd2have non empty pinvalid becauseasaforementioneddddoesnotconsiderprogramsyntaxatthepreprocessingstep i.e.
convertinga test program into a list or during reduction and hdd does not eitherduringreduction.bothalgorithmsgenerateaconsiderable number of syntactically invalid programs only being a waste of reduction time.
on the other hand both reduction algorithms only delete elements from test programs which limits the search space of syntactically valid programs i.e.
pvalid.
our use of grammars is fundamentally different from that of hdd.
hdd only uses grammars to parse programs into tree structures whereas persesfurtheranalyzesandleveragesgrammars during reduction.
this brings us two advantages pinvalid from the definition of the grammar during reduction persescandeterminewhetheratreenodeisdeletable.ifno we can avoid generating variants by deleting that node.
this makes it veryeasyfor persestoensure pinvalid whichconsequently reduces the number of unnecessary property tests.
enlarging pvalid persesleveragesthegrammartosupportmore advanced program transformations which thus increases pvalid.
for example according to the c grammar a conditional statement if ... print can be simplified to if ... print asthetruebranchofanifstatementisastatement and the compound statement print and the function call print are both statements.
though increased pvalidmay increase the number of property tests it enables persesto generate more valid diverse possibly smaller variants than dd and hdd.
itiseasyfor persestosupportanewlanguagebyjustproviding its grammar in backus naur form bnf .
however it is very likely thattheoriginalgrammarinarbitraryformmayhindertheeffectiveness of perses.
thus we define a normal form of grammars to facilitatereduction referredtoaspersesnormalform pnf .we also design an algorithm to automatically convert any grammar into itsequivalent pnf.
ourevaluationresultsof perseson20largecprogramsthat trigger bugs in gcc and clang demonstrates that perses s strong practicality compared to the state of the art smaller size perses s results are respectively and45 in size of those from ddandhdd and shorterreductiontime persestakes23 and47 time taken by dd and hdd respectively.
even when comparedtothehighlycustomizedandoptimizedc reduceforc c persestakesonly reductiontime.todemonstratethegeneralityof perses wealsoevaluate perseson6smalljavaprograms triggering bugs in javac and eclipse compiler for java and the results areconsistent with those onc programs.
persesconstantly outperforms hdd in terms of both time and reduction quality.
contributions.
this paper makes the following contributions.
we propose perses a framework for effective and efficient programreduction.itisthefirst generalprogramreducerthatleverages formal syntax to guide program reduction.
it guarantees no generation of syntactically invalid programs and supports more program transformations to produce smaller reduction results.
2we exclude c reduce from comparison and discussion in the remainder of the paper except section as c reduce is language specific and this paper focuses on languageindependent program reducers.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
perses syntax guided program reduction icse may june gothenburg sweden we define perses normal form of grammars to facilitate program reduction and also propose an algorithm to automatically convert any context free grammar into an equivalent pnf.
ourevaluationresultsonreal worldbenchmarksdemonstrate significant improvement of persesover the state of the art.
persesprovidesanewperspectiveforprogramreduction.with theknowledgeofformalsyntax wecandesignmoreprogram transformations to produce better reduction results.
a motivating example we illustrate perseswith a contrived c program.
the full algorithmisdetailedinsection4.figure1ashowsaprogramthatprints threelines hello world!
and end .assumethatweareinterestedinthebehaviorofprinting hello world!
.then perses outputs a minimized program that only prints hello world!
.
different from hdd which performs reduction level by level persesdoesnodebynode.itmaintainsapriorityqueue qtostore the treenodes forreduction.
eachtime itretrieves thenode with themosttokensfrom q andreducesthatnodewithvarious syntaxpreserving program transformations.
after the node is reduced the remaining children of the node are added to qfor future reduction.
initially persesparses this program into the parse tree shown in figure 1e.
then it performs the following reduction steps step .func def persesreducestherootoftheparsetree i.e.
.func def .however removingitdoesnotpossesstheproperty.
so all its children are added to q. step .compound stmt thefunctionbody .compound stmt is dequeued for reduction because it has the most tokens in q. for thiscompoundstatement wecannotdeleteit asthefunctionbody is compulsory for a function definition.
however we can replace it with one of its descendants which is also a compound statement.
in this case we can replace it with .compount stmt the true branch of if a on line .
after replacement the new variant is listedbelow.althoughitissyntacticallycorrect itdoesnotcompile astheidentifier a isnotdefined.sothisreductionstepfails and we add the three immediate children to q. int main printf d n a printf hello printf world!
n printf end n step .stmt star the suffix star indicates that this node is akleene star node and represents that it can have zero or more statements as immediate children.
in other words any child of this nodecanbedeletedwithoutviolatingthecprogramsyntax.forthis node persesuses dd to delete irrelevant children.
unfortunately all three children cannot be deleted and then are added to q. step .if stmt thelargestnodein qis .if stmt .itsparent is .stmt star that expects zero or more statements.
so we can find a statement to replace if stmt and the program syntax willstillbevalid.wesearchallitschildren andfinditstruebranch to be a statement i.e.
n od e .compoudt stmt .
so we obtain the first successful reduced variant shown in figure 1b.
step .compound stmt to reduce this node we attempt to use one of its children to replace it.
as it replaces .if stmt its parent becomes the node .stmt star which expects zero or more statements.
then we can use .stmt star which is also a kleene star node that expects zero or more statements to replacethiscompoundstatement.indetail .stmt star becomesachild of .stmt star and this transformation does not invalidate the grammar becausethetokensownedby .stmt star stillconstitutealistofstatements.thistransformationpreservestheproperty and the result is shown in figure 1c.
step .stmt star asitisakleenestarnode weuseddtoreduceit.andnodes .printf and .printf areremoved.
following steps after .printf i.e.
the print statement on line4 isremoved thedependencyonvariable aisalsoremoved.
when persespicks .inta f r o mq this statement can be safely removed without introducing any compilation error.
figure 1d shows the final result and figure 1f shows the final pruned parse tree.
only the two print statements and the return statement are kept in the result.
the if statement is removed by replacing it with its child.
this transformation is not possible in eitherhddorddexceptwithcase by casespecializedsolutions.in contrast ourapproachissystematic andinvolvenoad hocdesigns.
alltransformationsin persesaredesignedbasedonthesemantics oflanguagegrammars e.g.
deletingsomechildrenofkleenestar nodes replacing a statement node with another statement node.
preliminaries this section formalizes program reduction introduces dd and defines persesnormal form.
.
program reduction letb true false pbe a program that exhibits a property pbe the search space of programs defined by concrete program reductionalgorithmsover p.3wedefineapropertytestfunction p b such that p trueand for any program p p p trueifpexhibitsthe property otherwise p false.the size ofpis denoted as p which is the number of tokens in p. given a program pand its property test s.t.
p true the goal of program reduction is to search for a minimized program p p such that p p p .ideally the goal of reducing p denoted as reduce p is defined as argmin p p p p p p p p x p. p x minimality and tree minimality.
however obtainingthe globalminimalityisnp complete .therefore inpractice thereductionproblemisrelaxedtocomputetheminimumresult within a program reducer s capacity.
for example dd defines 1minimality .thatis p pis1 minimalifanyvariant p primederived frompbyremovingasingleelementfrom pdoesnotpasstheproperty test i.e.
p prime false.
hdd also defines a similar notion a program is tree minimality if any nodeof the tree representation of the program cannot be further simplified by the reducer.
.
delta debugging algorithm dd is integral to perses and we briefly introduce its reduction algorithm ddmin.givenaninputandaproperty ddfirstconverts theinputintoalist lofelements.then ddmindeterminesasubset 3note that the search space pis not the universe of all programs.
as aforementioned in section it is defined by the concrete reduction algorithm over p andp p. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden chengnian sun y uanbo li qirun zhang tianxiao gu and zhendong su 1int main int a if a printf d n a printf hello printf world!
n printf end n return a original.1int main int a if a printf d n a printf hello printf world!
n printf end n return b perses first success.1int main int a if a printf d n a printf hello printf world!
n printf end n return c perses second success.1int main int a if a printf d n a printf hello printf world!
n printf end n return d perses final result.
.func def int main .compound stmt .stmt star .inta .if stmt if expr a .compound stmt .stmt star .printf .printf .printf .printf .return e the parse tree of figure 1a simplified for illustration purpose.
.func def int main .compound stmt .stmt star .inta .if stmt if expr a .compound stmt .stmt star .printf .printf .printf .printf .return f the pruned parse tree after reduction.
figure an example program.
oflsuchthatnooneelementcanbedeletedfrom lwhilepreserving i.e.
the reduced lis minimal.
it involves three steps.
step splitlintonpartitions.foreachpartition u testifuonly without the other partitions can preserve the property.
if yes remove the complement of ufroml and resume at step .
step test if the complement of each partition upreserves the property.
if yes remove ufroml and resume at step .
step try to split each remaining partition into halves.
that is increasethenumberofpartitionsfrom nto2n.thenresumeatstep with the newlysplit smaller partitions.
if each partitionscannot be further split the remaining elements in lare the reduced result andddminterminates.
.
input grammar forms persestakesasinputlanguagegrammarsspecifiedinbackus naur form bnf notation.
unlessotherwisestated wealways assume thegrammarsareexpressedinbnfnotation.
persesalsosupports the context free grammar rules with three additional quantifier over terminals and nonterminals.
kleene star .the quantified terminal or nonterminal should occurzeroormultipletimes.forexample a cangenerateempty strings a aa and so on.
kleene plus .thequantifiedterminalornonterminalshould occuroneormultipletimes.forexample a issimilartoa except that a does not accept empty strings.
optional ?
.the quantified terminal or nonterminal should occur either zero times or once.
for example a?
accepts either empty strings or a .in particular a grammar rule is defined as a quantified rule iff at least oneof itsright hand sidesymbols is equippedwith aquantifier.thethreequantifierssimplifythegrammarrepresentationand have been widely used in many popular parser generators such as antlr and javacc .persesleverages the three quantifiers toperformsyntaxguidedprogramreduction.wesaythatanonterminalaisquantifiable ifacouldbetransitivelydescribedbya quantified rule.
for instance b colonequald is a quantified rule and the nonterminal bisquantifiable.supposethatwehaveanotherrule a colonequalbc .
the nonterminal ais also quantifiable since acould be transitivelydescribedbyaquantifiedrule a colonequald c byreplacing thebsymbol with d .
next we formally introduce the grammar normal form used in perses.
definition3.
persesnormalform .
acontext freegrammar cfgisinpersesnormalform pnf ifallitsproductionrulesareof the following form i a colonequalb1b2...bn o r ii a colonequalb1 o r iii a colonequalb1 o r iv a colonequalb1?
o r v s colonequal wheresdenotesthestartsymbol adenotesanonterminal bidenotes either a terminal or a nonterminal for all i andn .
moreover all quantifiable nonterminals are transitively described by at leastone quantified rule.
the pnf could be viewed as a restricted form of the extended backus naurform.
every context freegrammarcould be normalized to pnf.
the normalization algorithm is detailed in section .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
perses syntax guided program reduction icse may june gothenburg sweden intuitively rule i indefinition3.1referstoanynon epsilonrulein a context free grammar.
the epsilon rules could be safely removed duringnormalization .rules ii iii correspondtoanyrecursive ruleswitheitherleft orright recursion.thenormalizationalgorithmfindsatleastonesuchrecursiverulesforeachquantifiable nonterminal.rule iv couldbedistilledfromtheruleswithoptional terminal or nonterminals.
figure shows the grammar in pnf for theprograminfigure1a.forillustrationpurposeitissimplified by covering a small subset of the c programming language.
angbracketleftfunc def angbracketright angbracketlefttype angbracketright angbracketleftidentifier angbracketright angbracketleftcompound stmt angbracketright angbracketleftstmt angbracketright angbracketleftif stmt angbracketright angbracketleftdecl stmt angbracketright angbracketleftexpr stmt angbracketright angbracketleftcompound stmt angbracketright angbracketleftif stmt angbracketright angbracketleftcond plus angbracketright angbracketleftdecl stmt angbracketright angbracketleftcond plus angbracketright angbracketleftexpr stmt angbracketright angbracketleftcond plus angbracketright angbracketleftcompound stmt angbracketright angbracketleftcond plus angbracketright angbracketleftif cond angbracketright angbracketleftif cond angbracketright if angbracketleftexpr angbracketright angbracketleftdecl stmt angbracketright angbracketlefttype angbracketright angbracketleftidentifier angbracketright angbracketleftexpr angbracketright angbracketleftexpr stmt angbracketright angbracketleftexpr angbracketright angbracketleftcompound stmt angbracketright angbracketleftstmt star angbracketright angbracketleftstmt star angbracketright angbracketleftstmt angbracketright figure a normalized grammar in pnf for the program in figure 1a.
we omit the rules of nonterminals angbracketlefttype angbracketright angbracketleftidentifier angbracketrightand angbracketleftexpr angbracketrightfor brevity.
approach grammar normalizerjava grammarjavascript grammarc grammarother grammar pnf parse t ree reducerprogram propertyminimized program figure overall workflow of perses.
figure shows the overview workflow of perses.
conceptually persessupportsanyunambiguouscontext freegrammars.to support a specific language persesconverts its grammar to the normal form i.e.
definition .
.
when persesis used to reduce a program pw.r.t.a property.
persesfirst uses the normalized grammar to parse pinto a parse tree t. thentis fed to the core reductionalgorithmconsistingofasetofprogramtransformations.guidedbythepropertytest thereducergraduallydeletesirrelevant elementsfromthetree andoutputtheminimizedprogramupon termination.
angbracketlefta angbracketright angbracketleftb angbracketright angbracketleftc angbracketright angbracketleftd angbracketright angbracketleftb angbracketright angbracketlefta angbracketright angbracketleftd angbracketright angbracketleftc angbracketright angbracketleftd angbracketright angbracketleftc angbracketright c angbracketleftd angbracketright d a original grammar.
angbracketlefts angbracketright angbracketlefta angbracketright angbracketlefta angbracketright angbracketleftb angbracketright angbracketleftc angbracketright angbracketleftd angbracketright angbracketleftb angbracketright angbracketlefta angbracketright angbracketleftd angbracketright angbracketleftc angbracketright angbracketleftd angbracketright angbracketleftd angbracketright angbracketleftc angbracketright c angbracketleftd angbracketright d b preprocessing.
angbracketlefts angbracketright angbracketlefta angbracketright angbracketlefta angbracketright angbracketleftb angbracketright angbracketleftc angbracketright angbracketleftd angbracketright angbracketleftb angbracketright angbracketleftb angbracketright angbracketleftc angbracketright angbracketleftd angbracketright angbracketleftd angbracketright angbracketleftd angbracketright angbracketleftc angbracketright angbracketleftd angbracketright angbracketleftd angbracketright angbracketleftc angbracketright c angbracketleftd angbracketright d c transformation.
angbracketlefts angbracketright angbracketlefta angbracketright angbracketlefta angbracketright angbracketleftb angbracketright angbracketleftc angbracketright angbracketleftd angbracketright angbracketleftb angbracketright angbracketleftg angbracketright angbracketleftd angbracketright angbracketlefte angbracketright angbracketleftf angbracketright angbracketleftc angbracketright c angbracketleftd angbracketright d angbracketlefte angbracketright angbracketleftd angbracketright?
angbracketleftf angbracketright angbracketleftg angbracketright angbracketleftg angbracketright angbracketleftc angbracketright angbracketleftd angbracketright d normalization.
figure an illustrative example for pnf normalization.
.
pnf normalization this section describes our normalization algorithm for computing thepersesnormalform pnf .ournormalizationalgorithmtakes asinputanycontext freegrammarinbnfnotationandoutputsan equivalent grammar in pnf.
the basic idea of our normalization algorithmistocomputequantifiedrulesbasedongrammartransformations.
we notice that the and quantifiers correspond tothesequencerepetitionsinregularexpressions.therepetitionistypicallyspecifiedusingleft orright linearcontext freegrammars.
asaresult wecouldcomputethe and quantifiedrulesfrom thoseleft orright recursionrules.the ?
quantifiedrulescould be computed by comparing the differences of each pair of rules.
our normalization algorithm involves three essential steps.
we briefly describe these steps with an example in figure .
figure 4a shows the original grammar where angbracketlefta angbracketrightis the start symbol.
the original grammar is not in the pnf.
in particular the nonterminal angbracketleftb angbracketrightis quantifiable since it could potentially be described by a quantified rule obtainable from the left recursion rule angbracketleftb angbracketright colonequal angbracketleftb angbracketright angbracketleftc angbracketright angbracketleftd angbracketright .
however thegrammarin figure4adoesnotcontain any quantified rule.
we then discuss pnf normalization as follows.
preprocessing.
our preprocessing procedure eliminates the productions and unreachable rules.
we also assign a random or dering to all nonterminals in the grammar.
the preprocessedgrammar is given in figure 4b.
in particular angbracketlefts angbracketrightbecomes the new start symbol.
transformation.
to facilitate our next normalization step we preferleft orright recursiveproductions.during thetransformationprocedure foreachnonterminalwetrytodescribeitbya left or right recursive production rule according to the original grammar.
figure 4c shows the example after the transformation nonterminal angbracketleftb angbracketrightis transformed into a left recursion form.
normalization.
in the normalization step the corresponding leftorright recursiveproductionrulesaretransformedintoquantifiedrules.onceallquantifiablenonterminalshavebeentransitivelydescribedusingquantifiedrules weconverttheresult authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden chengnian sun y uanbo li qirun zhang tianxiao gu and zhendong su algorithm pnf normalization normalization g input g a context free grammar in bnf notation.
output g prime an equivalent grammar in pnf.
1preprocess g 2g1 grammarnormalizationleft g 3g prime grammarnormalizationright g1 4returng prime 5function grammarnormalizationleft g input g a context free grammar in bnf notation.
output g an equivalent grammar without quantifiable nonterminals in form of left recursion.
6letgcfgbe an empty digraph 7foreachni nj dogcfg gcfg ni nj 8scc compute scc gcfg 9foreachscci sccdo gi foreacha scci all rules of the form a togi g prime i grammartransformationleft gi g prime i quantifierintroductionleft g prime i g g gi g prime i 15returng 16function grammartransformationleft g input g a context free grammar in bnf notation.
output g an equivalent grammar with direct left recursion 17foreachnonterminal ni gdo repeat foreachruleni nj i gdo ifj ithen removeni nj ifromg foreachrulenj j gdo addni j itog untilgrammargremains unchanged.
25returng 26function quantifierintroductionleft g input g a context free grammar in bnf notation.
output g an equivalent grammar with quantifiers.
27foreachnonterminal ni gdo starintroductionleft g ni foreachni 1 prime prime 2do removeni 1 prime prime 2fromg letu1 u2be new auxiliary nonterminals g g ni 1u1 2 u1 u u2 prime foreachpair of ni i ni j where i j do if j 1 prime 2and i 1 2then removeni iandni jfromg letu3 u4be new auxiliary nonterminals g g ni 1u3 2 u3 u4?
u4 prime 38returng 39function starintroductionleft g n input g a set of grammar productions input n a nonterminal output g a set of grammar productions with quantified rules 40a andb 41foreachrulen gdo if n 1thena a 1 elseb b removen fromg 45foreachbi bdo denote set aas a1 a2 ... aj letu1 u2be new auxiliary nonterminals g g n biu1 u1 u u2 a1 a2 ... aj 49returng grammartopnfbyintroducingnecessaryauxiliarynonterminals.
figure 4d gives the example grammar in pnf.
algorithm overview.
algorithm1describesourpnfnormalizationalgorithm whereeach nirepresentsanonterminalandeach irepresents a sequence of terminals and nonterminals.algorithm the main algorithm reduce p input p the program to be reduced.
input p b the property to be preserved.
output a minimum program p ps.t.
p 1best parsetree p 2worklist rootnode best 3while worklist 0do largest getandremovelargestfrom worklist 5iflargestis kleene star node then best pending reducestar best largest 7else if largestis kleene plus node then best pending reduceplus best largest 9else if largestis optional node then best pending reducestar best largest 11else if largestis regular rule node then best pending reduceregular best largest 13else continue skip token nodes worklist worklist pending 15return best inparticular lines1 4describethemainnormalizationalgorithm.
after preprocessing many quantifiable nonterminals may still not betransitivelydescribedusingquantifiedrules.ouralgorithmthen processesthegrammarintwopasses.thefirstpasshandlestheleft recursion rules and the second pass handles the right recursion rules.inprinciple thetwopassesarealmostidentical.therefore we only discuss the first pass.
online5 thefunction grammarnormalizationleft processes all left recursion rules.
we first build a directed graph gcfgby constructingedges ni nj fromanonterminal nitotheleftmostnonterminalnjaccording to its productions lines .
then we find the strongly connected components scc in gcfgusing tarjan s algorithm line .
each scc corresponds to at least one recursive rule.therefore thealgorithmperformsgrammartransformation and grammar normalization for each scc lines .
grammar transformation.
the function on line performs grammartransformation.inparticular ittransformsanyindirect recursionruletoanequivalentrulewithleftrecursion.itutilizes theassignedordering line20 anditerativelyreplacesthelower order nonterminals with its production rules line .
the procedure terminates when there is no indirect recursion rules w.r.t.
the ordering line .grammar normalization.
the grammar normalization procedureonline26introducesthequantifiersandoutputsanequivalent grammar in the pnf form.
specifically it converts the recursive rulesinto quantifiedrules line39 quantifiedrules line2932 or ?
quantifiedrules line33 .lines32 37and48introduce the quantified rules to the output grammar.
finally all rules are in the pnf according to definition .
.
the transformation procedure fully exploits all dependencies among the nonterminals and the normalizationprocedureintroducesthequantifiedrules w.r.t.the definition.itisstraightforwardtoseethatalgorithm1preserves the grammar equivalence.
.
main reduction algorithm algorithm2liststhemainproceduretoreduceaprogram pw.r.t.
.
the output is a minimum variant derived from pthat still passes .
initially pisconvertedintoaparsetree bestwiththepnfgrammar.
then all the following reduction is performed on this parse tree.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
perses syntax guided program reduction icse may june gothenburg sweden the overall reduction process is a prioritized traversal of best.
algorithm 2maintainsa worklistoftree nodespending reduction andeachtimepopsoutthenodewiththemosttokenstoreduceon line .
we treat quantified nodes and regular rule nodes differently.
forexample ifthenode largestisakleene starnode wereduce it with the function reducestar on line that returns a pair of which the first is the reduced result and the second is the pending nodesforfuturereduction.theothernodesaretreatedsimilarly onlywithdifferentfunctions.whenreducing largestfinishes we update the worklistby adding the pending nodes on line and proceed to the next largest node in worklist.
.
reducing quantified nodes for a kleene star kleene plus or optional node we use ddminto delete its children as each child is independent of the others in terms of syntax validity which fits in the assumption of dd well.
reducing kleene star and optional nodes.
wetreatkleenestarandoptionalnodesinthesameway asoptionalnodesarea specialcaseofkleene star.algorithm3showsthegeneralreduction procedure.
we use ddminto perform delta debugging on all the childrenof treetoremovethechildren thatareirrelevantto .at last we return the minimized tree by removing irrelevant nodes fromtreeand the remaining children of nodeas the result.
algorithm reducestar tree node input tree the parse tree to be reduced.
input p b the property to be preserved.
input node the parse tree node to be reduced.
output best pending bestis the minimum tree by reducing tree and pendingis a set of remaining descendants of node.
1all children node 2remaining ddmin all 3best tree.copyandremove all remaining 4return best remaining reducing kleene plus node.
reducing kleene plus nodes is similartoreducingkleene starnodes i.e.
algorithm3.italsouses ddminas the underlying reduction algorithm.
the main difference is that when reducing the children of node we need to maintain oneconstraintinducedbythesemanticsofkleene plus atleast onechildof nodeisnotdeleted.forexample whenweareaboutto test avariant bydeleting allthe childrenof node weneed tokeep one child e.g.
the first child in order to avoid syntax errors.
.
reducing regular rule nodes algorithm4showshowaregularrulenodeisreduced.thegeneral idea is to replace the tree node nodethat is being reduced with one of its compatible descendants.
the compatibility is determined based on the subsume relation defined as follows.
definition .
subsume relation .
given two symbols aand b terminals or non terminals in a grammar bis subsumed by a denoted as b a if one of the following conditions holds a b bcan be derived from a for example angbracketleftstmt angbracketright angbracketleftstmt angbracketright and angbracketleftif stmt angbracketright angbracketleftstmt angbracketright.
intuitively angbracketleftif stmt angbracketright angbracketleftstmt angbracketrightmeansthatanyparsetreeof angbracketleftif stmt angbracketrightcanbesyntacticallysafetobeusedinthecontextwhereaparsetree of angbracketleftstmt angbracketrightisexpected.wedefinethreeauxiliaryfunctionsrelated to rule types for a node n. rule n returnstheproductionrulethatcreatesthenode n.forexample theruleofthenode .if stmt infigure1eis angbracketleftif stmt angbracketright.
expectedrule n returns the expected production rule at the position ofnin the context of its parent parent n .
for example the expected production rule for node .if stmt in figure 1e is angbracketleftstmt angbracketright because its parent .stmt star expects each of its children to be angbracketleftstmt angbracketright.
quantifiedrule n onlyappliestokleenenodes niseitherkleenestar or kleene plus .
it returns the quantified production rule of n. for example quantifiedrule returns angbracketleftstmt angbracketrightfor the node .stmt star because it expects a list of angbracketleftstmt angbracketrightchildren.
with the subsume relation and auxiliary functions we can identify two types of compatible descendants to replace node.
regular nodes lines aregulardescendantnode nofnode is a replacement candidate if its production rule rule n is subsumed by that of node i.e.
rule n expectedrule node .
take figure 1e as an example.
assume that we are reducing .if stmt .itsexpectedruletypeis angbracketleftstmt angbracketrightasaforementioned.
thenitsdescendant .compound stmt isacompatiblenode astheruletypeofthisdescendantis angbracketleftcompound stmt angbracketrightwhich is a kind of statements.
kleene node lines if the parent of nodeis either kleenestar or kleene plus then a descendant nis compatible if nis also a kleene node and its quantified rule type is subsumed by the expected rule of node namely quantifiedrule n expectedrule node .
forexample infigure1e thenode .stmt star canreplace .if stmt becausetheparent .stmt star of .if stmt quantifies a list of angbracketleftstmt angbracketrightnodes and using .stmt star t o replace .if stmt still maintains the syntactical invariant that is .stmt star still quantifies a list of angbracketleftstmt angbracketrightnodes thoughthenewlyaddednode .stmt star introducesalayer of indirection.
note that the number of compatible nodes for nodecan be enormous.
in order to limit the search space we require the path l betweennode exclusive and its compatible node n inclusive satisfy the following two constraints the number of nodes in l is bounded there is no other compatible node on lbeforen.
in other words nis the first compatible node on l. the function boundedbfs online18implementsthesetwoconstraints.inthis work we use as the maximum length of l i.e.
line and line .
.
fixpoint reduction mode a single run of the reduction function reducedoes not guarantee thatthereducedprogramis1 tree minimal cf.section3.
because the deletion of one node may enable the deletion of another node.
forexample assumetwofunctions fooandmain foohasmore tokensthan main maincalls foo mainhasthepropertyofinterest andfoois irrelevant to this property.
when reduceis reducing this program it first reduces foo.
however foois referenced by main soitcannotbecompletelydeleted.later when mainisbeing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden chengnian sun y uanbo li qirun zhang tianxiao gu and zhendong su algorithm reduceregular tree node input tree the parse tree to be reduced.
input p b the property to be preserved.
input node the parse tree node to be reduced.
output best pending bestis the minimum tree by reducing tree and pendingis a set of remaining descendants of node.
1candidates 2beginsearching for replacement candidates subsume pred n.rule n expectedrule node 4replacement candidates boundedbfs node subsume pred candidates candidates replacement candidates 6ifiskleene parent node then kleene pred n.iskleene n quantifiedrule n expectedrule node 9quantified candidates boundedbfs node kleene pred candidates candidates quantified candidates 11best node 12foreachc candidates do 13t tree.copyandreplace node c 14if t t tree.copyandreplace node best then best c 16ifbest nodethen return tree children node 17else return tree.copyandreplace node best best 18function boundedbfs node pred max depth input node the starting node of breadth first search input pred treenodes b predicate to match tree nodes.
input max depth depth bound.
output result the matched tree nodes.
queue queue children node result 21while queue max depth 0do max depth max depth queue size queue fori 0toqueue size do n dequeue queue ifpred n then result result n continue ifmax depth 0then foreachc children n doenqueue queue c 31return result reduced thecallto fooisdeleted.then foocanberemoved.but it has been visited so reducewill not delete it in the current run.
therefore similartohdd weproposeafixpointreduction mode in which reduceis repeatedly applied to the reduced result until no more tree nodes can be removed from the result.
and the final result will be tree minimal.
evaluation we evaluate perseswith large c programs that trigger bugs in gcc and clang and compare it with dd hdd and c reduce.
on average persesoutperforms the other reducers nearly in every aspect e.g.
reducedfilesize smallerexceptc reduce numberofpropertytests fewer reductiontime shorter exception multidelta and reduction speed .
.6xspeedup .
todemonstratethegeneralityof perses weinstantiate perses with an antlr java grammar.
the evaluation on six benchmarks confirmsagainthat persesoutperformshddinvariousmetrics.
all experiments are conducted on a ubuntu machine with an intel core i7 cpu and gb memory.
.
evaluation on c programs benchmark collection.
the benchmark c programs are collected from the official bug repositories of two mainstream c compilers gcc and clang .
we have randomly selected recent bug reports and requested the unreduced testcase from the original reporter.
the selected bug reports include both crash and miscompilationbugs.moreover allselectedbugreportsarereproducible w.r.t.at least one stable release of the two compilers.
tools for comparison.
we run persesandpersesf perses infixpointmode incomparisonwiththefollowingtools delta a line based delta debugging tool deltaf delta in fixpoint mode multidelta a variant of delta that is aware of blocks inprograms c reduce hdd andhddf hddinfixpoint mode .
.
.
reduction quality .
table shows the reduction quality results.
it also gives the original token count of a test program and that of the minimized program by a reducer.
in general perses produces much smaller results than the other reducers except creduce smaller .
the row sizein table shows the averageimprovementof persesandpersesfoverotherreducers.
forexample thesizeoftheresultby persesfisonly2 ofthatof delta and45 ofhddf.comparedtoc reduce persesproduces tokens more than c reduce on average.
however this is expected because c reduce is a c c language specialized reducer which performs aggressive semantic program transformations.
.
.
reduction efficiency .
efficiency is another key criterion toevaluateareducer.table2andapartoftable1showsthedetails ofefficiency wisedata.4thissectionfurtherquantifiesefficiency in the following three different metrics.
number of property tests.
thisisthemetricusedin .ifthe property test runs in constant time then this metric can reliably reflect the runtime complexity of reducers.
table lists this metric.
persesfrunspropertytests5095timesonaverage whichis .26x fewer than multidelta .4xfewer than deltaf .37xfewer than c reduceand .31xfewerthanhddf.therow testsintable3 lists the detailed improvement.reduction time.
this measures how long a reducer takes to terminate.
it depends on the number of property tests and the time of each property test.
the row timein table shows the time ratio between persesandtheotherreducers.exceptmultidelta perses constantly takes shorter time to terminate shorter .
as far as multidelta though taking similar time as multidelta.
perses produces much smaller results than multidelta.reduction speed.
reductionspeed isthenumberoftokensthat a reducer can delete per second.
the row speedin table lists the speed ratio between persesand the other tools.
both perses andpersesfrunfasterthantheothers.especially persesisthe fastest .
.6x faster than the rest .
4in table delta and deltafperforms only two property tests and in table they spendzerosecondsonthisbenchmark.thisisbecauseallthetokensoftheoriginal test program are placed in a single line and the line oriented strategy of delta just treats the program as a single line which demonstrates the limitation of dd.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
perses syntax guided program reduction icse may june gothenburg sweden table size information of original and reduced programs and number of property tests.
bugo delta multidelta deltafc reduce hdd hddfperses persesf r q r q r q r q r q r q r q r q clang clang clang clang clang clang clang clang clang gcc gcc gcc gcc gcc gcc gcc gcc gcc gcc gcc mean median columnso r qlist the number of original tokens the number of tokens after reduction and the number of queries respectively.
table reduction time and reduction speed.
bugdelta multidelta deltafc reduce hdd hddfperses persesf t s e s t s e s t s e s t s e s t s e s t s e s t s e s t s e s clang clang clang clang clang clang clang clang clang gcc gcc gcc gcc gcc gcc gcc gcc gcc gcc gcc mean median columnst elist the time of reduction and the efficiency in tokens per second respectively.
table3 ratioofvariousmetricsbetween persesandothers.
delta multidelta deltafc reduce hdd hddf sizeperses persesf2 testsperses persesf26 timeperses persesf40 speedperses .6x .5x .3x .6x .9x .3x persesf2.6x .1x .2x .9x .4x .7x5.
evaluation on java programs wedemonstratethegeneralityof persesbyinstantiatingitwith anantlrjavagrammartoreducejavaprograms.tothebestof ourknowledge persesisbyfarthemosteffectiveprogramreducer for java as there is no c reduce like tool for java.
wemanuallycheckedtheofficialbugrepositoriesofopenjdk andeclipsecompilerforjava ecj andcollected5bugsthatcanbe reproducedandhave unreduced inputprogramsattachedinthebug reports.table4showsthereductionresults.
persesoutperforms hdd.
in general persesis2.07xfaster produces .13xsmaller results and reduces .99xfewer queries than hdd.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden chengnian sun y uanbo li qirun zhang tianxiao gu and zhendong su table results of java benchmarks.
bug o hddfpersesf r q t s r q t s ecj ecj 9ecj jdk 60jdk total columnso r qandtlist the number of original tokens the number of tokens after reduction the number of queries and the reduction time respectively.
discussion generality to programming languages.
persesisageneral reductionframework anditmakes noassumptionaboutspecific programming languages.
it takes as input language grammars and thus is able to exploit any language specific syntactical properties e.g.
which nodes can be replaced with other nodes or deleted of the programs under reduction.
all transformations presented in section4arebasedonthepnf.anycontext freegrammarcould be converted to pnf.
therefore persesis applicable to any programming language.
this is why we can easily effectively support reducingjavaprogramsinadditiontocaspresentedinsection5.
which requires little effort on integrating the java grammar.
generality to other test inputs.
although we only focus on program reduction in this paper persesis capable of reducing other structured test inputs e.g.
xml and html documents .
persesisexpectedtoperformatleastaswellashdd.wefocus on program reduction since programs have much more complex constraints intermsofbothquantityandcomplexity overtheir syntacticalstructuresthaneitherxmlorhtml.thesecomplex constraints significantly increase the difficulty of reduction and increase the search space of invalid variants pinvalidas well.
extensibility.
the transformations described in section are the first attempt to instantiate the persesreduction framework.
more transformations can be designed.
persescurrently supports reducing production rules either by deletion cf.
section .
or replacement cf.
section4.
.wecandefinenewtransformations to increase pvalid.
for example replacing long string literals with an empty string converting an expression by appending t o an expression statement to replace an existing large statement.
before perses duetotheomissionoftheinformationingrammar definitions it is impossible to design such an extensible reduction tool in a general way .
persesmakes this feasible.
related work the most related work to persesis hierarchical delta debugging thatexploitsthetreestructureofthetestinputs.hodov n et al.proposed an approach to speed up hdd in .
delta debugging istheseminalworkontestcasereduction.however neither of them address the syntactical validity for program reduction.asaresult theywasteaconsiderableamountoftimein exploring the invalid search space pinvalid.
many delta debuggingbased frameworks leverage the underlying language feature to achieve almost optimal program reduction for a specific language.for instance js delta relies on the wala static analysis infrastructure to reduce javascript programs.
c reduce employs a set of heuristics for efficient program reduction based on the c c semantics obtained from clang.
our evaluation shows that in terms of the reduction throughput i.e.
the number of tokens deleted per second persesis .
faster than c reduce.
for reducing c programs it is possible to combine both perses andc reduce.specifically wecouldrun persestoquicklyremove irrelevant program elements and then use c reduce to obtain the almost optimal reduction result.
le et al.introduce a meta reducer by combining berkeley delta and c reduce in their emi testingproject .persescan improve theperformanceofthe meta reducerbyreplacingberkeleydelta.recently herfert et al.
proposeageneralizedtreereduction gtr algorithmwhichcombines a generic set of transformations for a particular language by learningfromacorpusofexampledata .persesisageneral framework and does not require any prior knowledge on the input data.
persescould also be used for reducing other structured testcasessuchasminimizingstructuredtextformatsforsecurity testing .binkley et al.proposeanobservationalprogram slicing ops techniquetoreduceaprogrambasedontheresults ofpropertychecks .toreduceaprogram theopstechnique uses line deletion whereas perses manipulates trees.
perses is more general and supports arbitrary program properties.
conclusion in this paper we propose a novel effective program reduction framework perses.sameashdd itisgeneraltoanyprogramming languagesandperformsreductionontheparsetreesofprograms.
butdifferently itisawareofthesyntacticalconstraintsbetween nodes andthusguaranteesnogenerationofsyntacticallyinvalid programs during reduction and enables more effective program transformations.itsignificantlyoutperformsdd hddandeven c reduce a specialized reducer for c c programs in terms of size of reduced programs and efficiency of reduction.
in order to further demonstrate the generality of perses w e instantiate with anantlr grammar for java.
the evaluationon six bugsinjavacompilersshowsthat persesrunsmuchfasterthan hdd and produced much smaller results which is consistent with the evaluation on c programs.
webelievethat perses sintegrationofsyntacticalknowledge opens a new way towards general effective and efficient program reduction.consequently inthefuturemoreprogramtransformationscanbeeasilydesignedandimplementedwithin perses either general or specific to a certain programming language.