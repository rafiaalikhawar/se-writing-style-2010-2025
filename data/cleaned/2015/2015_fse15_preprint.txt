zurich open repository and archive university of zurich university library strickhofstrasse ch zurich year tracing software developers eyes and interactions for change tasks kevic katja walters braden m shaffer timothy r sharif bonita shepherd david c fritz thomas posted at the zurich open repository and archive university of zurich zora url conference or workshop item published version originally published at kevic katja walters braden m shaffer timothy r sharif bonita shepherd david c fritz thomas .
tracing software developers eyes and interactions for change tasks.
in 10th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering bergamo italy august september s.n.. software developers eyes and interactions for change tasks katja kevic braden m. walters timothy r. shaffer bonita sharif david c. shepherd thomas fritz university of zurich switzerland y oungstown state university usa abb corporate research usa department of informatics department of cs and is industrial software systems kevic fritz ifi.uzh.ch bmwalters01 trshaffer student.ysu.edu david.shepherd us.abb.com bsharif ysu.edu abstract what are software developers during a change task?
while an answer to this question opens countless opportunities to support developers in their work only little is known about developers detailed navigation behavior for realistic change tasks.
most empirical studies on developers performing change tasks are limited to very small code snippets or are limited by the granularity or the detail of the data collected for the study.
in our research we try to overcome these limitations by combining user interaction monitoring with very fine granular eye tracking data that is automatically linked to the underlying source code entities in the ide.
in a study with professional and student developers working on three change tasks from an open source system we used our approach to investigate the detailed navigation of developers for realistic change tasks.
the results of our study show amongst others that the eye tracking data does indeed capture different aspects than user interaction data and that developers focus on only small parts of methods that are often related by data flow.
we discuss our findings and their implications for better developer tool support.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms human factors experimentation keywords eye tracking gaze change task user study .
introduction software developers spend a majority of their time working on change tasks such as bug fixes or feature additions .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse copyright 20xx acm x xxxxx xx x xx xx ... .
.in order to successfully complete these tasks they have to read navigate and edit the relevant pieces of code .
since the inception of software development researchers have been studying how developers read and navigate code and what kind of knowledge they acquire e.g.
.
the more we know about a developer s work the better we are able to support her for instance by reducing information overload improving defect prediction or providing automatic navigation recommendations .
yet relatively few studies have been undertaken to investigate detailed navigation behavior of developers for realistic change tasks.
the lack of realistic studies is due to the significant challenges and effort of acquiring the time of professional software developers to participate as well as of capturing transcribing and coding longer sessions of developers work on change tasks.
more recently approaches have been developed to automatically capture more data from a developer s interactions with source code elements in an integrated development environment ide .
these approaches capture source code elements mostly on the class and method level and are based on explicit user interactions with the mouse or keyboard.
recent advances in technology afford new opportunities to collect a wide variety of more detailed information on a software developer and her work.
studies with sensors for tracking biometric features such as eye gaze have generated new insights on developers work on small code tasks such as perceptions of difficulty brain activation patterns the scanning patterns of code or the ease of comprehending different representations of code .
most of these studies focus on very small code comprehension tasks with a single method or class in particular since they require manual linking between the gaze data collected with an eye tracker and the source code elements a developer looked at.
while these studies provide valuable first insights the advances in technology open up the opportunity to address further important research questions such as what is a developer s fine grained navigation behavior for realistic chang e tasks what is the difference in the data captured through eye tracking and interaction logging and how can we use eye tracking data to support developers.
answering these questions will allow us to better understand developers comprehension of large code bases and to develop better and more fine granular tool support for developers.this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication esec fse august september bergamo italy acm.
... 202in our research we take advantage of the opportunities that eye tracking provides and extend previous research by addressing some of these questions by focusing on more realistic change tasks to investigate how developers read and navigate through code while working.
in particular we are examining how eye tracking data differs from the data captured by monitoring user interactions in an ide how developers eyes move within and between methods and how these newly gained insights can be used to better support developers in their work on change tasks.
we developed an approach to automatically link eye tracking data to the source code elements in the ide which combines the ease of automatically collecting data in an ide with the finer granularity of eye tracking data.
our approach also supports the scrolling and switching of code editor windows by developers and thus allows for change task investigations on a realistic sized code base and is not limited to very small tasks as most previous studies are.
this new approach for conducting user studies in software development provides the potential to reduce the cost of generating detailed rich user data and valuable insights in developers navigation behavior.
we conducted a study with participants professional developers and students working on three realistic change tasks for a total of minutes while automatically tracing their eye gazes and their explicit user interactions in the co de editor of the eclipse ide.
our analysis of the gathered data shows amongst other results that eye tracking captures substantially different data than a developer s navigation within the ide that developers only look at a few lines of a method when working on a change task and that these lines are often related to the data flow of variables within these methods.
these results also provide evidence for the value of combining eye tracking with interaction monitoring in an ide in the future.
this paper makes the following contributions study findings based on eye tracking and user interaction monitoring that provide insights into the detailed navigation behavior of developers working on realistic change tasks.
an approach to automatically and on the fly capture the fine grained source code elements a developer looks at in an ide while working with large files thereby significantly improving current state of the art that limits eye tracking studies to only single methods.
a discussion on the value of the data gathered and the opportunities the data and the findings offer for better developer support.
.
related work our work can be seen as an evolution of techniques to empirically study software developers working on change tasks.
therefore we classify related work roughly along its evolution into three categories manual capturing user interaction monitoring and biometric sensing of developers work.
manual capturing.
researchers have been conducting empirical studies of software developers for a very long time.
many of the earlier studies focused on capturing answers of participants after performing small tasks to investigate code comprehension and knowledge acquisition e.g.
.
later on researchers started to manually capture more detailed data ondevelopers actions.
altmann for instance analyzed a ten minute interval of an expert programmer performing a task and used computational simulation to study the near term memory .
perhaps one of the most well known user studies from this category is the study by ko et al.
.
in this study the authors screen captured ten developers desktops while they worked on five tasks on a toy sized program and then hand coded and analyzed each minute session.
in a study on developers performing more realistic change tasks fritz et al.
used a similar technique and manually transcribed and coded the screen captured videos of all participants.
while all of these studies are a valuable source of learning and led to interesting findings the cost of hand coding a developers actions is very high which led to only a limited number of studies providing detailed insights on a developers behavior.
user interaction monitoring.
more recently approaches have been developed to automatically capture user interaction data within an ide such as mylyn .
based on such automatically captured interaction histories logs of the code elements a developer interacted with along with a timestamp researchers have for instance investigated how developers work in an ide how they navigate through code or how developers micro interaction patterns might be used for defect prediction .
even the eclipse team themselves undertook a major data collection project called the usage data collector that at its peak collected data from thousands of developers using eclipse.
overall the automatic monitoring of user interactions was able to significantly reduce the cost for certain empirical studies.
however these studies are limited to the granularity and detail of the monitoring approach.
in case of user interaction monitoring the granularity is predominately the method or class file level and detailed information such as the time a developer spends reading a code element or when the developer is not looking at the screen is missing and makes it more difficult to fully understand the developers traces.
biometric sensing.
in parallel to the ide instrumentation efforts researchers in the software development domain have also started to take advantage of the maturing of biometric sensors.
most of this research focuses on eye tracking while only few studies have been conducted so far that also use other signals such as an fmri to identify brain activation patterns for small comprehension tasks or a combination of eye tracking eda and eeg sensors to measure aspects such as task difficulty developers emotions and progress or interruptibility .
by using eye tracking and automatically capturing where a developer is looking eye gaze researchers were able to gain deeper insights into developers code comprehension.
one of the first eye tracking studies in program comprehension was conducted by crosby et al.
who found that experts and novices differ in the way they looked at english and pascal versions of an algorithm .
since then several researchers have used eye tracking to evaluate the impact of developers eye gaze on comprehension for different kinds of representations and visualizations such as 3d visualizations um l diagrams design pattern layout programming languages and identifier styles .
researchers have 203also used eye tracking to investigate developers scan patterns for very small code snippets finding that participants first read the entire code snippet to get an idea of the program .
other researchers examined different strategies novice and expert developers employ in program comprehension and debugging as well as where developers spend most time when reading a method to devise a better method summarization technique .
finally researchers have also used eye tracking to evaluate its potential for detecting software traceability links .
all of these studies are limited to very small toy applications or single page code tasks.
furthermore in many of these studies the link between the eye gaze e.g.
a developer looking at pixel on the screen to the elements in an ide e.g.
a variable declaration in line of method openfile had to be done manually.
to the best of our knowledge this paper presents the first study on realistic change task investigation that collects a nd analyzes both developers user interaction and eye gaze data .
due to the approach we developed that automatically links eye gaze data to the underlying source code elements in the ide we reduce the need of manual mapping and are able to overcome the single page code task limitation of previous studies allowing for change tasks on a realistic sized code base with developers being able to naturally scroll and switch editor windows.
.
exploratory study we conducted an exploratory study with participants to investigate the detailed navigation behavior of developers for realistic change tasks.
each participant was asked to work for a total of minutes on three change tasks of the open source system jabrefin the eclipse ide while we tracked their eyes and monitored their interaction in the ide.
for the eye tracking part we developed a new version of our eclipse plugin called itrace by adding automatic linki ng between the eye gazes captured by the eye tracking system to the underlying fine grained source code elements in the ide in real time.
all study materials are available on our website .
.
procedure the study was conducted in two steps at two physical locations.
in the first step we conducted the study with twelve professional developers on site at abb.
we used a silent and interruption free room that was provided to us for this purpose.
in the second step we conducted the study with ten students in a university lab at youngstown state university.
we used the same procedure as outlined below at both locations.
when a participant arrived at the study location we asked her to read and sign the consent form and fill out the background questionnaire on their previous experience with programming java bug fixing and eclipse.
then we provided each participant a document with the study instructions and a short description of jabref.
participants were encouraged to ask questions at this stage to make sure they understood what they were required to do during the study.
the entire procedure of the study was also explained to them by a moderator.
in particular participants were told that they will be given three bug reports from the jabref repository and the goal was to fix the bug if possible.
however we didmention that the ultimate goal was the process they used to eventually fix the bug and not the final bug fix.
for the study participants were seated in front of a 24inch lcd monitor.
when they were ready to start we first performed a calibration for the eye tracker within itrace.
before every eye tracking study it is necessary to calibrate the system to each participants eyes in order to properly record gaze data.
once the system was successfully calibrated the moderator turned on itrace and mylyn to start collecting both types of data while the participants worked on the change tasks.
participants were given time to work on a sample task before we started the one hour study on the three main tasks.
at the end of each change task we had a time stamped eye gaze session of line level data and the mylyn task interactions saved in a file for later processing.
we also asked each participant to type their answer the class es method s attribute s where they might fix the bug in a text file in eclipse at the end of each change task.
for the study each participant had eclipse with itrace and mylyn plugins installed the jabref source code a command prompt with instructions on how to build and run jabref and sample bib files to test and run jabref.
there were no additional plugins installed in eclipse.
the study was conducted on a windows machine.
each participant was able to make any necessary edits to the jabref code and run it.
they were also able to switch back and forth between the eclipse ide and the jabref application.
itrace detects when the eclipse perspective is in focus and only then collects eye gaze data.
we asked subjects not to resize the eclipse window to maintain the same full screen setup for all subjects and not to browse the web for answers since we wanted to control for any other factors that might affect our results.
.
participants for our study we gathered two sets of participants twelve professional developers working at abb inc. that spend most of their time developing and debugging production software and ten undergraduate and graduate computer science students from youngstown state university.
participants were recruited through personal contacts and a recruiting email.
all participants were compensated with a gift card for their participation.
all professional developers reported having more than five years of programming experience.
seven of the twelve reported having more than five years of experience programming in java while the other five reported having about one year of java programming experience.
nine of the twelve professional participants also rated their bug fixing skills as above average or excellent.
with respect to ide usage four of the twelve stated that they mainly use visual studio for work purposes and that they were not familiar with the eclipse ide and one participant commented on mainly being a vim and command line user.
of the twelve professional developers two were female and ten were male.
among the ten student participants one participant had more than five years of programming experience five students had between three and five years programming experience and four of them had less than two years programming experience.
three of the students reported having between three and five years of java programming experience while seven students had less than two years.
three of the ten students rated their bug fixing skills as above average and seven rated them as average.
all but one student stated that 204they were familiar with the eclipse ide.
of the ten students one was female and nine male.
.
subject system and change tasks we chose jabrefas the subject system in this study.
jabref is a graphical application for managing bibliographic databases that uses the standard latex bibliographic format bibtex and can also import and export many other formats.
jabref is an open source java based system available on sourceforge and consists of approximately kloc spread across files.
the version of jabref used in our study was .
.
release date .
to have realistic change tasks in our study we took the tasks directly from the bug descriptions submitted to jabref on sourceforge.
information about each task is provided in table .
all of these change tasks represent actual jabref tasks that were reported by someone on sourceforge and that were eventually fixed in a later jabref release.
the tasks were randomly selected from a list of closed bug reports with varied difficulty as determined by the scope of the solution implemented in the repository.
we selected a set of three change tasks to be performed by all participants.
we consider this to be a reasonable number of tasks without causing fatigue in the one hour of the study.
a time limit of minutes was placed for each task so that participants would work on all three tasks during the one hour study.
to familiarize participants with the process and the code base each participant was also given a sample task before starting with the three main tasks for which we did not analyze the tracked data.
the task order of the three tasks was randomly chosen for each participant.
.
itrace for capturing eye tracking data and linking it to source code elements in the ide we developed and use a new version of our eclipse plugin itrace .
for this new version we added the ability to automatically and on the fly link eye gazes to fine grained ast source code elements including method calls variable declarations and other statements in the eclipse ide.
in particular itrace gives us the exact source code element that was looked at with line level granularity.
furthermore to support a more realistic work setting we added features to properly capture eye gazes when the developer scrolls or switches code editor windows in the ide or when code is edited.
eye tracking on large files that do not completely fit on one screen is particularly challenging as none of the state of the art eye tracking software supports scrolling while maintaining context of what the person is looking at.
our new version of itrace overcomes this limitation and supports the collection of correct eye gaze data when the developer scrolls both horizontally and vertically as well as when she switches between different files in the same or different set of artifacts.
itrace interfaces with an eye tracker a biometric sensor usually in the form of a set of cameras that sit in front of the monitor.
for our study we used the tobii x60 eyetracker that does not require the developer to wear any gear.
tobii x60 has an on screen accuracy of .
degrees.
to accommodate for this and still have line level accuracy of the eye gaze data we chose set the font size to points for source code files within eclipse.
we ran several tests to validate the accuracy of the collected data.after calibrating the eye tracker through itrace s calibration feature the developer can start working on a task and the eye gazes are captured with the eye tracker.
itrace processes each eye gaze captured with the eye tracker checks if it falls on a relevant ui widget in eclipse and generates an eye gaze event with information on the ui in case it does.
itrace then uses xml and json export solvers whose primary job is to export each gaze event and any information attached to it to xml and json files for later processing.
currently itrace generates gaze events from gazes that fall on text and code editors in eclipse.
these events contain the pixels x and y coordinates relative to the top left corner of the current screen the validation of the left and right eye as reported by the eye tracker i.e.
if the eye was properly captured the left and right pupil diameter the time of the gaze as reported by the system and the eye tracker the line and column of the text code viewed the screen pixel coordinates of the top left corner of the current line the file viewed and if applicable the fully qualified names of source code entities at the gaze location.
the fully qualified names are derived from the abstract syntax tree ast model of the underlying source code.
for this study we implemented itrace to capture the following ast elements classes methods variables enum declarations type declarations method declarations method invocations variable declarations an y field access and comments.
these elements are captured regardless of scope which includes anonymous classes.
.
data collection for this study we collected data on participants eye traces and their interactions with the ide simultaneously.
since we conducted our study with the eclipse ide we used the eclipse plugin mylyn to monitor user interactions.
for the eye tracking data we used our new version of the eclipse plugin itrace .
we gathered a total of change task investigations from the professional developers and computer science students who each worked on three different change tasks.
for each of these investigations we gathered the eye tracking data and the user interaction logs.
due to some technical difficulties such as a participant wearing thick glasses or too many eye gazes not being valid for a task we excluded change task investigations and ended up with overall subjects investigating task subjects investigating tas k and subjects investigating task .
with respect to individual method investigations over all participants and task s we gathered a total of method investigation instances.
.
study results based on the collected logs of eye gazes gaze context and user interactions interaction context of the participant s we were able to make detailed observations on how developers navigate within source code.
table summarizes the gaze and interaction contexts we collected and used to infer our observations from.
in the following we structure our observations along three research foci the difference between gaze and user interaction data developers navigation withi n methods and developers navigation between methods.
.
interaction context and gaze context o1 gaze contexts capture substantially more and more fine grained data.
to compare the different amounts of elements within the gaze and the interaction contexts we 205table tasks used in the study.
id bug id date submitted title scope of solution in repository t2 no comma added to separate keywords mult iple classes entryeditor groupdialog fieldcontentselector jabrefframe t3 failure to import big numbers single meth od bibtexparser.parsefieldcontent t4 acrobat launch fails on win98 single meth od util.openexternalviewer used a paired samples t test1with pairs consisting of the gaze and the interaction context for a task and subject.
this paired samples t test showed that the number of different classes contained in the gaze context m .
sd .
and the number of different classes contained in the interaction context m .
sd .
do not differ significantly t .
p .
.
nevertheless there were more classes captured in the gaze contexts which turned out to be internal classes or classes defined in the same file.
while there is no significant difference on a class level there is a significant difference in the amounts of methods captured.
the number of different methods within the gaze contexts m .
sd .
is significantly higher than the number of different methods within the interaction contexts m .
sd .
t .
p .
.
this observation on the substantial difference in the number of elements within the gaze and interaction context provides evidence that developers often look at methods that they do not select.
approaches that only analyze interaction logs thus miss a substantial amount of information.
when analyzing the method sequences captured in the logs the data also shows that gaze context not only captures more elements but also more details on the actual sequences of navigation between methods.
a paired samples t test revealed a significant difference in the number of method switches captured in gaze contexts m .
sd .
and the number of method switches captured in interaction contexts m .
sd .
t .
p .
.
table summarizes the number of unique methods and the number of method switches for each context type and participant.
o2 gaze and interaction contexts capture different aspects of a developer s navigation.
to evaluate whether gaze and interaction contexts capture different aspects of a developer s navigation for change task investigations we defined ranking models based on the data available in the different contexts and compared the top ranked methods.
there are a variety of models that can be used to select the most important elements within a navigation sequence .
for our analysis we used single factor models to select the most important elements in each kind of context that were also suggested in previous studies .
to rank the methods of a gaze context we used a time based model.
this model ranks methods higher for which a developer spends more time looking at.
to rank the methods of an interaction context we used a frequency model which ranks methods higher that were visited more often.
1according to the central limit theorem with large samples number the distribution of the sample mean converges toanormaldistributionandparametrictestscanbeused .the comparison of the top methods for each change task investigation resulted in an average agreement of .
sd .
.
comparing solely the highest ranked method for each context pair results in an agreement of .
.
the agreement on the top most important methods however is considerably lower for change task m .
sd .
than for change task m .
sd .
and for change task m .
sd .
.
while the description for change task and change task include concrete hints to source code elements which are possibly important for performing the change task change task required to explore the source code more exhaustively in order to find the relevant code and a possible fix.
these results illustrates that gaze context especially in form of the time of gazes captures aspects that are not captured in the interaction context and that might be used to develop new measures of relevance.
especially since gaze contexts also capture elements that are not in the interaction context o1 the more fine grained gaze data might provide better and more accurate measures of relevance.
.
navigation within methods we base the analysis of navigation within methods solely on the gaze data since interaction contexts do not capture enough detail to analyze within method navigation.
o3 developers only look at few lines within methods and switch often between these lines.
figure depicts the lines a professional developer middle and a student developer right looked at within a certain method and over time during a change task investigation.
across all subjects and tasks developers only look at few lines within a method on average .
sd .
of the lines.
the lengths of methods included in this analysis thereby differed quite a lot with an average length of .
lines sd .
and had a moderate influence on the number of lines looked at by a developer pearson s r .
p .
.
participants performed on average .
sd .
line switches within methods.
the method length again influences the amount of line switches moderately pearson s r .
p .
.
further examination of the kind of lines developers actually looked at shows that developers spend most of their time within a method looking at method invocations m .98ms and variable declaration statements m .
ms but spent surprisingly little time looking at method signatures m .
.
in fact in cases out of method investigations analyzed the method signature was ignored and not looked at.
our findings demonstrate that developers who are performing an entire change task involving several methods and classes read methods differently than 206table summary of professional pro and student stu deve lopers average avg of methods and method switches captured in the gaze and interaction context as we ll as the percentage of lines read within methods.
idavg of method switches average of unique methods avg of line s read in method gaze context interaction context gaze context interaction context p1 .
.
.
.
p2 .
.
p3 .
.
p4 .
.
.
.
p5 .
.
.
p6 .
.
.
.
.
p7 .
.
.
.
p8 .
.
.
p9 .
.
.
p10 .
p11 .
.
.
p12 .
avg pro .
.
.
.
.
s1 .
.
.
s2 .
.
.
.
s3 .
.
.
.
.
s4 .
.
.
.
s5 .
.
.
s6 .
.
.
.
s7 .
.
.
.
s8 .
.
.
.
s9 .
.
.
.
s10 .
.
avg stu .
.
.
.
.
total avg .
.
.
.
.
developers who are reading methods disconnected from any task or context in which case the method signature might play a stronger role.
o4 developers chase data flows within a method.
to better understand how developers navigate within a method we randomly picked six change task investigation instances from the collected gaze contexts and manually retraced the paths participants followed through a method by drawing their line switches on printouts of the methods.
closely examining these printed methods with the eye traces drawn on top allowed us to form the hypothesis that developers often trace variables when reading a method.
to further investigate this hypothesis.
we selected four methods which were investigated by most participants resulting in unique method investigation instances see table .
the method investigation instances stem from different participants and two different task.
of these investigations stem from professional software developers while the other stem from students.
for each method we assigned a color for each variable used within the method and colored the lines in which the variablewas either defined or used in the method.
we did not color lines or statements that did not include a variable.
over all four methods we identified an average of .
variable slices per method with an average of .
different lines of code per slice.
then we applied this line to color mapping to the sequence logs of participants who investigated these method s see figure for an example .
within each sequence log we ignored the lines which did not map to a slice such as brackets or empty lines.
as we are investigating if developers trace variables when reading a method we further ignored control flow statements which did not use any variable.
in the event of more than one variable used in a single line we manually checked if a color was predominantly used before or after the line was visited and decided on a color according using the predominant color .
in cases where there was no evidence of a predominant color we picked the color of the variable that was used first in the source code line.
our analysis revealed that developers switched between the lines of these four methods on average .
sd .
times.
we then used our color coding to examine how many of these line switches are within variable slices lines with the same color .
overall method investigation instances we 207figure the sequence logs mapped to line numbers and colors w ith the colored source code on the left.
figure colored sequence logs of participants investigat ing method browserlauncher.locatebrowser .
each row represents a method investigation of a participant with t he time axis going from left to right and an eye gaze on a line represented by a colored line within the row.
found an average of .
.
line switches of the to be within a variable slice supporting our hypothesis that developers are in fact following data flows when investigating a method.
the long green and yellow blocks within figure further illustrate the frequency of switching within a variable slice rather than switching between different variable slices.
.
navigation between methods overall subjects switched on average .
sd .
times between methods when working on a change task.
thereby they revisited a method on average .
times.
o5 developers frequently switch to methods in close proximity and rarely follow call relationships.
to investigate the characteristics of method switches we examined whether they were motivated by call relationships or due to the close proximity of methods.
we assessed for each method switch within a class and for each method switch to a different class whether the switch was motivated by following thecall graph of the method.
in addition we assessed for each method switch within the same class whether the sequentially next method looked at is directly above or directly below the current method.
we conducted this analysis for both contexts the gaze context and the interaction context.
to understand if a method switch was motivated by following the call graph we memorized the method invocations within a given method and assessed if the next method in the method sequence was one of the memorized invoked methods.
while we had to consider all method invocations within a given method when analyzing the interaction context we could precisely assess at which method invocation the developer actually looked at when analyzing the gaze context.
if a next method in the sequence was equal to one of the memorized invoked methods we concluded that it is likely that the developer followed the call relationship switch potentially motivated by call graph although the next metho d 208table methods used in the analysis to determine the amount o f within variable slice line switches.
method name investigation instances pro stu length in lines identified slicesavg lines per sliceavg line switchesavg line switches within slice bibtexparser.parsefieldcontent .
.
util.openexternalviewer .
.
.
bibtexparser.parsetexttoken .
.
browserlauncher.locatebrowser .
.
.
could have also been within spatial proximity and the call relationship not of importance for the navigation.
if the next method was not contained within the memorized method invocations we concluded that the developer s navigation wa s motivated by other means than the call relationships.
to understand if a method which was looked at next is directly above or directly below a current method we compared the line numbers in the source file.
gaze context we found that merely .
sd .
of all method switches were potentially motivated by following the call graph.
onaverage thesubjectsswitchedmethodspotentially motivated by the call graph more when they were investigating change task m .
sd .
than when they were investigating change task m .
sd .
and change task m .
sd .
.
a pairedsamples t test showed that developers switched methods potentially motivated by the call graph significantly more often within a class m .
sd .
than between different classes m .
sd .
t .
p .
.
at the same time a larger amount of all method switches ended in methods which were right above or below a method m .
sd .
.
these results suggest that the call graph of a project is not the main drive for navigation between methods but the location of a method captures an important aspect for navigation between methods.
interaction context we found that .
sd .
of all method switches were potentially motivated by following the call graph.
different to the results of the gaze context analysis participants switched between methods potentially motivated by the call graphsubstantiallymorewhentheywereinvestigatingchange task m .
sd .
than when they were investigating change task m .
sd .
and change task m .
sd .
.
on average subjects followed considerably more call relations when they were navigating within the class m .
sd .
than when they were navigating to a method implemented in another class m .
sd .
.
we further found that on average .
sd .
of the method switches within a class were aimed towards methods which are directly above or below a method.
overall these results also show that the more coarse grained interaction context indicates that developers follow structural call graphs fairly frequently .
while the more fine grained gaze context depicts a different image with only .
of switches being motivated by structural call relations.
our results on switches to methods in close proximity further support the findings of a recent head to head study thatcompared different models of a programmer s navigation and that suggested to use models to approximate a developer s navigation based on the spatial proximity of methods within the source code.
o6 developers switch significantly more to methods within the same class.
a paired samples t test shows that developers switched significantly more between methods within the same class m .
sd .
than they switched from a method to a method implemented in another class m .
sd .
t .
p .
.
while over all three tasks participants rarely switched to methods of different classes the participants method switching within the same class differs between tasks.
a wilcoxon matched pairs signed rank test indicates that participants switched significantly more between methods withi n classes for task m .
sd .
than for task m .
sd .
z .
p .
.
while it is not surprising that different tasks result in different navigation behavior of participants this also suggests that it is important to take into account the task for support tools such as code navigation recommendations.
.
differences based on experience previous empirical studies on software developers found differences in the patterns that experienced and novice developers exhibit e.g.
.
to investigate such difference s we analyzed our data for differences in navigation between our professional developers and our students.
in particular we tested each statistic that contributed to the above observations and examined whether there were any statistically significant differences in gaze respectively interactio n contexts.
to compare the professional developers and the students we used a mann whitney test as there are different participants in each group and the data does not meet parametric assumptions.
overall we did not find any statistically significant difference between the two groups of participants in the amounts of unique elements on different granularity levels within the gaze context u .
p .
on class level u .
p .
on method level nor the interaction context u .
p .
on class level u .
p .
on method level .
furthermore there was no significant difference in the amounts of switches conducted between different elements within a class u .
p .
for the gaze contexts and u .
p .
for the interaction contexts nor outside of a class u .
p .
for the gaze contexts and u .
p .
for the interaction contexts .
finally we also could not find any significant difference in the amount of call relationships followed u .
p .
for the gaze contexts and u .
p .
for the interaction contexts nor if any of these two groups switched more often to methods with a high spatial proximity u .
p .
209for the gaze contexts and u .
p .
for the interaction contexts .
so even though our exemplary figure figure that depicts a sequence log for a professional and a student developer might suggest a difference in navigation behavior our analysis did not produce any such evidence.
further analysis is needed to examine this aspect in more detail.
.
threats to validity one threat to validity is the short time period each participant had for working on a change task.
unfortunately we were limited by the time availability of the professional developers and therefore had to restrict the main part of the study to one hour.
while the data might thus not capture full task investigations it provides insights on investigat ions for multiple change tasks and thus the potential of being more generalisable.
another threat to validity is the choice of jabref as the subject system.
jabref is written in a single programming language and its code complexity and quality might influence the study.
for instance code with low quality and or high complexity might result in developers spending more time to read and understand it and thus longer eye gaze times for certain parts of the code.
we tried to mitigate this risk by choosing a generally available system that is an actively used and maintained open source application and that was also used in other studies.
further studies however are needed to examine the effect of factors such as code quality to generalize the results.
in our study jabref had to be run through the command prompt using ant and not directly in eclipse.
this meant that participants were not able to use breakpoints and the debuggerwithineclipseandmighthaveinfluencedtheresults .
we intend to conduct further study to investigate if our findings generalize to other settings e.g.
ones in which the project can be run from within eclipse.
itrace collects eye gazes only within eclipse editors.
this means that we do not record eye gaze when the developer is using the command prompt or running jabref.
however since we were interested in the navigation between the code elements within the ide this does not cause any problems for our analysis.
if the user opens the find in file or search window within eclipse or a tooltip pops up when hovering over an element in the code the eye gaze is not recorded as this overlaps a new window on top of the underlying code editor window and itrace did not support gazes on search windows at the time of the study.
to minimize the time in which eye gazes could not be recorded we made sure to let participants know that once they were done with the find feature within eclipse to close these windows so gaze recording can continue.
finally most professional developers were mainly visual studiousersfortheirwork weconductedourstudyineclipse.
however all professional developers stated that they did not have problems using eclipse during the study.
.
discussion tracing developers eyes during their work on change tasks offers a variety of new insights and opportunities to support developers in their work.
especially the study s focus on change tasks the richness of the data and the finer granularity of the data provide potential for new and improved tool support such as code summarization approaches or code andartifact recommendations.
in the following we will discuss some of these opportunities.
richness of eye tracking data and gaze relevance.
our findings show that the eye tracking data captures substantially more o1 and different aspects o2 of a developer s interaction with the source code.
therefore eyetracking data can be used complimentary to user interaction task context to further enhance existing approaches such as task focused uis or models for defect prediction .
in particular since eye tracking data also captures gaze times how long a developer spends looking at a code element more accurate models of a code element s relevance could be developed as well as models of how difficult a code element is to comprehend which might inform the necessity of refactoring it.
to examine the potential of the gaze time we performed a small preliminary experiment to compare a gaze based relevance model with a model based on user interaction.
we focused on professional developers and were able to collect and analyze user ratings from professional developers within the group of participants also since not everyone was willing to spend additional time to participate in this part.
each developer was asked to rate the relevance of the top elements ranked by gaze time as well as the top ranked by degree of interest from mylyn s user interaction context on a five point likert scale.
overall participan ts rated of the top gaze elements relevant or very relevant and only of the top as relevant or very relevant.
while these results are preliminary and further studies are needed the improvement illustrates the potential of the data richness in form of the gaze time.
finer granularity of data and task focus.
most current tools and research approaches to support development work focus on method or class level granularity.
most prominently editors of common ides such as visual studio or eclipse display whole classes but even the recently suggested new bubble metaphor for ides displays full methods .
similarly approaches to recommend relevant code elements for a task such as mylyn or wear based filtering operate on the class and method level.
while the method and class level are important our results show that developers only focus on small fractions on average of methods that are important for the change task at hand o3 .
these findings suggest that by identifying highlighting and possibly filtering the parts within methods that are relevant for the task we might be able to save developers time and effort to switch between relevant parts of code and avoid getting distracted by other irrelevant code.
since developers focus a lot on data flow within a method o4 that is related to the task we hypothesize that a task focused program slicing approach might provide a lot of benefit to developers working on change tasks.
such an approach could take advantage of existing slicing techniques such as stat ic or dynamic slicing and identify the relevance of a slice based on its relation to the task by for instance using textual similarity between the slice and the task description or previously looked at code elements.
by using eye tracking to capture a more fine grained task context while a developer is working we are also able to better determine what a developer is currently interested in and 210complement existing approaches to recommend relevant artifacts to the developer such as hipikat or prompter .
finally the insights from our study can also be used to inform summarization techniques to help developers comprehendtherelevantpartsofthecodefaster.
existingtechniques to summarize code have mainly focused on summarizing whole methods rather than only summarizing the parts relevant for a given task.
similarly the approach by rodeghero et al.
focused on using eye tracking to summarize whole methods.
our findings show that developers usually do not read or try to comprehend whole methods and rather focus on small method fractions and data flow slices for a change task.
this suggests that a more task focused summarization that first identifies relevant code within a method according to previous eye tracking data or other slicing techniques and then summarizes these parts of the method might help to provide more relevant summaries and aid in speeding up code comprehension.
accuracy of method switches.
the eye tracking data captured in our study shows that a lot of the switches between methods are between methods in close proximity as well as within a class o5 o6 .
these findings suggest that there is a common assumption among developers that nearby code is closely related.
while this is not a new finding the additional data captured through eyetracking that is not captured by user interaction monitoring provides further evidence for this switch behavior.
this finding also suggests that a fisheye view that zooms in on the current method and provides much detail on methods in close proximity but less on methods further out might support faster code comprehension for developers.
a common assumption of navigation recommendation approaches is that structural relations between elements are important in a developers navigation .
while empirical studies that examined developers navigation behavior base d on user interactions have shown that developers actually follow such structural relations frequently in particular call relations e.g.
the eye tracking data of our study sho ws that developers perform many more switches that do not follow these relations and that are not captured by explicit user interaction.
these findings point to the potential of eye tracking data for improving method recommendations as well as for identifying the best times for suggesting structural navigation recommendations.
however further studies are needed to examine this possibility.
an eye tracker per developer.
as discussed using eye trackers in practice and installing them for each developer not just for study purposes bares a lot of potential to improve tool support such as better task focus recommendations or summarization.
with the advances and the price decrease in eye tracking technology installing eye trackers for each developer might soon be reasonable and feasible.
at the same time there are still several challenges and questions to address to be smooth and of value to developers in particular with respect to eye calibration granularity level and privacy.
several eye trackers especially cheaper ones currently still need a recalibration every time a developer changes position with respect to the monitor which is too expensive for practical use.
for tool integration one has to decide on the level of granularity that is bestfor tracking eye gazes.
while more fine grained data might provide more potential eye tracking on a finer granularity level is also more susceptible to noise in the data.
finally as with any additional data that is being tracked about an individual s behavior finer granular data also raises more privacy concerns that should be considered before such an approach is being deployed.
for instance the pupil diameter or the pattern of eye traces might also be used to monitor the cognitive load of the developer which could also be used in harmful ways.
.
conclusion to investigate developers detailed behavior while performing a change task we conducted a study with developers working on three change tasks of the jabref open source system.
this is the first study that collects simultaneously both eye tracking and interaction data while developers worked on realistic change tasks.
our analysis of the collected data showsthatgazedatacontainssubstantiallymoredata aswel l as more fine grained data providing evidence that gaze data is in fact different and captures different aspects compared to interaction data.
the analysis also shows that developers working on a realistic change task only look at very few lines within a method rather than reading the whole method as was often found in studies on single method tasks.
a further investigation of the eye traces of developers within methods showed that developers chase variables flows within methods.
when it comes to switches between methods the eye traces reveal that developers only rarely follow call graph links and mostly only switch to the elements in close proximity of the method within the class.
these detailed findings provide insights and opportunities for future developer support.
for instance the findings demonstrate that method summarization techniques could be improved by applying some program slicing first and focusing on the lines in the method that are relevant to the current task rather than summarizing all lines in the whole method.
in addition the findings suggest that a fisheye view of code zooming in on methods in close proximity and blurring out others might have potential to focus developers attention on the relevant parts and possibly speed up code comprehension.
the approach that we developed for this study automatically links eye gazes to source code entities in the ide and overcomes limitations of previous studies by supporting developers in their usual scrolling and switching behavior within the ide.
this approach opens up new opportunities for conducting more realistic studies and gathering rich data while reducing the cost for these studies.
at the same time the approach opens up opportunities for directly supporting developers in their work for instance through a new measure of relevance using gaze data.
however possible performance and especially privacy concerns have to be examined beforehand.
.