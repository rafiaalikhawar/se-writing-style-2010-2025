testing regex generalizability and its implications a large scale many language measurement study james c. davis daniel moyer and ayaan m. kazerouni department of computer science virginia tech davisjam dmoyer ayaan vt.edudongyoon lee department of computer science stony brook university and virginia tech dongyoon cs.stonybrook.edu abstract the regular expression regex practices of software engineers affect the maintainability correctness and security of their software applications.
empirical research has described characteristics like the distribution of regex feature usage the structural complexity of regexes and worst case regex match behaviors.
but researchers have not critically examined the methodology they follow to extract regexes and findings to date are typically generalized from regexes written in only programming languages.
this is an incomplete foundation.
generalizing existing research depends on validating two hypotheses various regex extraction methodologies yield similar results and regex characteristics are similar across programming languages.
to test these hypotheses we defined eight regex metrics to capture the dimensions of regex representation string language diversity and worst case match complexity.
we report that the two competing regex extraction methodologies yield comparable corpuses suggesting that simpler regex extraction techniques will still yield sound corpuses.
but in comparing regexes across programming languages we found significant differences in some characteristics by programming language.
our findings have bearing on future empirical methodology as the programming language should be considered and generalizability will not be assured.
our measurements on a corpus of regexes can guide data driven designs of a new generation of regex tools and regex engines.
there are more things in heaven and earth horatio than are dreamt of in your philosophy.
hamlet i. i ntroduction for such a widely used programming tool regexes have been surprisingly understudied.
although they have been around for decades and appear in an estimated of software projects only recently have they been investigated from a software engineering perspective.
empirical studies have examined topics like regex readability feature usage structural complexity evolution and worst case performance and concomitant security vulnerabilities .
these studies have often been based on smallscale regex corpuses extracted from a few thousand software projects.
can their findings be generalized?
in this paper we formulate and test two generalizability hypotheses underlying prior research.
first we test whether prior results may have been biased by following different regex extraction methodologies v .
researchers have extracted regexes using static analysis or runtime instrumentation and to generalize from one methodology to theother we must show that the extracted regexes are similar.
second we test whether prior results generalize to other programming languages.
for this test we rely on a large scale corpus of regexes extracted from projects across eight programming languages vi .
our generalization efforts depend on a comprehensive set of regex metrics iv .
our findings support a nuanced notion of universal regex practices.
in our first experiment we show that the regex extraction methodology does not produce significantly different regex corpuses.
in our second experiment we found that the regexes from different programming languages are not significantly different on four of our eight metrics and on the other metrics only a few languages are outliers.
because regexes appear to be similar across programming languages we were able to replicate many findings from prior research in new programming languages on a larger regex corpus vii .
in viii we discuss the implications of our measurements for regex tool designers and regex engine developers.
for example visualization designers should ensure their approaches render well on realistically sized regexes and regex engine designers might prioritize regex feature support and optimizations based on their relative frequency of use in real regexes.
this work makes the following contributions we identify two generalizability hypotheses underpinning existing empirical regex research iii .
we define a comprehensive set of regex metrics permitting regex characterization across three dimensions iv .
we test these hypotheses using two regex corpuses collected from k and k software projects respectively written in three and eight popular programming languages.
the generalizability hypotheses generally hold sections v and vi .
we test the replicability of prior regex research and show that this research generalizes vii .
we describe the potential effect of outliers on the findings of prior work.
we discuss the implications of our measurements for regex tool designers and regex engine developers viii .
ii.
b ackground a. regular expressions automata and redos a regex is a way to describe strings that match a certain pattern.
regexes are supported in most popular programming languages.
software engineers use them to concisely conduct 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sophisticated string operations like text processing input sanitization and code search .
programming languages implement regex matching using automaton simulation.
a programming language s regex engine converts a regex pattern to a non deterministic finite automaton nfa or deterministic finite automaton dfa representation.
the regex engine tests for a pattern match by simulating the behavior of the automaton on a candidate string using static dfa simulation spencer s backtracking nfa simulation or thompson s dynamic dfa simulation .
most regex features like kleene stars a and custom character classes are truly regular in the automata theoretic sense and can be modeled through the appropriate construction of the automaton graph and transition function.
some regex engines also support extended regex features like backreferences and lookaround assertions which are non regular and entail a more complex automaton representation and simulation .
the worst case time complexity of a regex match varies widely by regex engine exposing many applications to a denial of service vector.
most programming languages use spencer s algorithm which supports extended regex features but suffers from exponential worst case time complexity due to the catastrophic backtracking that can occur while simulating nfas with high ambiguity .
super linear worst case regex match time can lead to an algorithmic complexity attack known as regular expression denial of service redos .
in a redos attack an attacker triggers polynomial or exponential regex match behavior in server side software to divert resources away from legitimate clients.
for example the company cloudflare had an outage in july due to a super linear regex match .
b. recent regex research tools and characteristics though regex research has historically focused on the mathematical properties of regexes recent work has examined regexes from a software engineering perspective.
researchers have proposed a variety of tools to support engineers working with regexes.
for example regex visualizations have been proposed for comprehension regex input generators for regexes have been developed to support comprehension and testing and researchers have combated the redos security threat through mechanisms for worst case regex detection and prevention .
the better we understand how and why software engineers use regexes the better tools we can build to support them.
to guide this endeavor empirical regex researchers have sought to understand the characteristics of real world regexes.
the efforts of these researchers have provided many hints about how engineers use regexes in practice.
regexes are widely used reportedly appearing in of software projects with applications like input sanitization error checking document rendering linting and unit testing .
software engineers may rely more heavily on some regex features than others possibly tied to the relative comprehensibility oftable i existing regex corpuses .no comparison has been made between extraction methods .regex characteristics ha ve been studied carefully in three programming languages .
t his corpus has only been used to compare regex engines see x .
corpus extraction method languages projects static analysis python k static analysis javascript k python k program instrumentation java .
k static analysis eight prog.
languages k different features .
features like quantifiers capture groups and character classes are commonly used in python while backreferences and lookaround assertions rarely appear in practical regexes .
engineers may under test their regexes perhaps relying on line coverage instead of automaton graph coverage .
most regexes may go unmodified after entering version control .
and many prominent software modules and web services rely on super linear regexes and are vulnerable to redos .
if these preliminary empirical regex findings generalize they can guide research into more fruitful directions and nip others in the bud .
for example if regexes are as widely used as is thought then visualization and input generation tools can be valuable aids for many developers.
and if super linear worst case time complexity is as common as has been estimated then addressing this behavior by overhauling regex engines seems natural.
conversely if regexes do not change after entering version control then regex specific differencing tools e.g.
for code review may not have great utility.
and if non regular regex extensions like backreferences and lookaround assertions are as rare universally as initial results suggest then they should be a low priority for tool support and regex engine optimizations.
iii.
m otiv ation assumptions and applications empirical regex research depends on two generalizability hypotheses.
generalizing this research will permit us to guide future researchers and programming language designers.
a. existing regex corpuses as summarized in table i the corpuses used in prior empirical regex research were created using one of two regex extraction methodologies.
the first three corpuses have been analyzed in terms of regex characteristics covering only three programming languages.
the fourth corpus has been used to compare regex engine behavior but the characteristics of the regexes themselves have not been studied.
comparing regex extraction methodologies.
when a developer matches a string against a regex they must specify the regex pattern and construct a regex object.
the regex pattern can be provided as a static string to the regex constructor.
or the developer might wish to supply a variable string e.g.
to build a complex regex by concatenating its constituent parts.
rasool and asif suggest that this practice of regex templating authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
which they call abstract regexes may make regexes easier to debug .
for a real world example the widely used marked markdown parser relies heavily on regex templating.
we illustrate these concepts in listing .
listing regex corpuses based on static analysis or program instrumentation may yield different results.
for example the regex used to match the emailstr is of varying complexity depending on the regextype flag.
static analysis might only be able to retrieve the simplest regex pattern while an instrumented application or runtime might identify all three patterns if the software can be exercised thoroughly.
def isemail emailstr regextype externalregex ifregextype simple regex reg regex .
.
elif regextype complex regex name regex domain regex .
regex name regex domain regex reg regex regex else reg regex externalregex return reg.match emailstr regex corpuses have been constructed using either static analysis or program instrumentation table i .
these approaches have familiar tradeoffs.
using static analysis researchers can analyze an entire software project but may not be able to extract dynamically defined regex patterns like those in listing without intra and inter function dataflow analysis.
in contrast runtime analysis can extract both statically and dynamically defined regex patterns so long as the relevant call sites are evaluated during execution.
it is not clear whether a regex corpus based on one extraction methodology would be comparable to a regex corpus based on the other.
regex variation by language?
regex research has provided hints about how engineers use regexes in practice but these works have been isolated to practices in three programming languages.
engineers may choose a programming language based in part on their task the right tool for the job and some tasks may have greater call for pattern matching.
it is not unreasonable to suppose that the characteristics of the regexes used to solve these problems may likewise vary by programming language.
b. two regex generalizability hypotheses we wonder whether variations in regex extraction methodology as well as the present restriction of regex analyses to only three programming languages may mask variations in regex characteristics.
we formulate these questions as two regex generalizability hypotheses the extraction methodology em and cross language cl hypotheses.
h em it does not matter whether a regex corpus is constructed using static analysis or program instrumentation.
at scale using either extraction methodology will yield a corpus with similar distributions of regex metrics.
1see regex characteristics are similar across programming language.
the distributions of regex metrics will be similar for software from different programming languages.
c. application data driven regex engine design programming language designers and regex engine developers have several regex matching algorithms to choose from including thompson s and spencer s .
while the pros and cons of these algorithms can be debated some are noticeably more suitable than others on certain regexes e.g.
the well known advantage of thompson over spencer engines on ambiguous regexes .
to the best of our knowledge the regex engines in many programming languages were designed without considering the characteristics of real regexes.
we lack both a comprehensive set of metrics that engine designers should consider and the measurements of real regexes to guide their designs.
to fill this gap in the next section we describe metrics that can indicate the relative costs of different approaches iv and we proceed to measure real regexes and discuss the implications viii .
iv .
a c omprehensive set of regex metrics in this section we introduce our comprehensive collection of regex metrics table ii .
we selected metrics to characterize a regex in three dimensions its representation the diversity of the language it describes and the complexity of various algorithms to solve its membership problem.
these metrics fulfill two purposes.
first they include most regex metrics considered in prior research allowing us to evaluate generalizability.
second our metrics include those of particular interest to the developers of regex tools and regex engines.
in testing these hypotheses we characterize the largest extant regex corpus in support of data driven tool and engine designs.
a. metrics for regex representation we measure the representation of a regex in terms of the pattern and its corresponding automata.
the features and structural complexity of a regex may impact regex comprehension affecting areas like code re use and code review.
these metrics may also influence the design of visualization tools which features does my visualization need to support?
how will typical regexes look in my visualization?
.
a regex s pattern representation is the face it shows to engineers.
measures on the pattern representation give some sense of the impression an engineer has when examining the regex.
we first measure the length of this representation in terms of the number of characters in the string encoding of the pattern.
then we measure its chapman feature vector counting the number of times each regex feature is used.
for example for the regex a we would compute a regex length of and report two uses of the feature and one use of the capture group and backreference features.
the pattern representation of an automata theoretic regex corresponds to an nfa and dfa representation used by a regex engine to answer regex language membership queries.
as we discuss during our analysis measures of the automata authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii regex metrics organized by representation language diversity and worst case match complexity .the final column