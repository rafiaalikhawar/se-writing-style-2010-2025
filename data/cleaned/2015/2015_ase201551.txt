codeexchange supporting reformulation of internet scale code queries in context lee martie thomas d. latoza and andr van der hoek university of california irvine department of informatics irvine ca u.s.a. lmartie tlatoza andre ics.uci.edu abstract programming today regularly involves searching for source code online whether th rough a general se arch engine such as google or a specialized code search engine such as searchcode ohloh or github.
searching typically is an iterative process with developers adjusting the keywords they use based on the results of the previous query.
however searching in this manner is not ideal b ecause just using keywords places limits on what developers can express as well as the overall interac tion that is required.
based on the observation that the results from one query create a context in which a next is formulated we present codeexchange a new code search engine that we developed to explicitly leverage this co ntext to support fluid expressive reformulation of queries.
we motivate the need for codeexchange highlight its key design decisions and overall architecture and evaluate its use in both a field deployment and a laboratory study.
keywords code search query reformulation context interface internet scale i. introduction today with the proliferation of code on the web searching for code has become an integral part of the job .
indeed it can be argued that the modern programmer has to be as versed in finding and interp reting relevant code on the web as they are in writing it.
programmers search for a variety of reasons.
some look for sample implementations of algorithms or data structures others are curious about a particular api and how they can best use it and yet others may search for specialized domain specific code that performs certain desired functionality while question and answer sites such as stackoverflow can be helpful in many cases oft en developers want more than just a brief answer with some illustrat ive code they want to examine and perhaps copy and paste real working code .
typically developers use a general purpose search engine like google or a specialized code search engine such as ohloh github or searchcode .
the advantage of using a specialized code search engine is that all of the results are code as opposed to manuals tutori als code and other kinds of results intermixed.
regardless th e way in which to search is the same the developer in puts keywords into the search engine receives and examines results and issues an adjusted set of keywords if they do not find what they are looking for repeating these steps until they find what they are looking for start over or just give up.
previous work has characterized this process as one of query reformulation an initi al query is issued after which subsequent queries adjust the set of keywords of the previous query in order to attempt to steer the search engine into delivering the desired results .
it is important to realize that such reformula tion is not random rather it is based on examining the search results deciding what is desired and what is not desired in those results and mapping this back to a modified set of keywords that is then issued to the search engine.
it is here that two problem s arise.
first developers can only express a limited amount of information in keywords.
it is for instance not possible to express that they want some code that is shorter and presumably simp ler than the results shown.
as another example if they see a result that provides them with the desired functionality but no t in the righ t way e.g.
they want a method with java generics instead of a fully specified method just adding generics or java generics to the current query does not necessarily improve the search results and may well lead to very different results.
the second problem lies in the overall user interaction that is required each time a set of keywords is reissued the previous query is lost except for using the back button and it is difficult to combine keyw ords from different queries since the previous queries are no longer visible.
the result is that developers rarely go back or recombi ne parts of old queries instead continuing a linear se quence of modifying keywords.
this is less than ideal.
the underlying issue is that current code search engines are designed to support query fo rmulation and fail to recognize that query reformulation is perhaps much more important to achieve successful search experiences.
we are not alone in making this observation e.g.
and some preliminary work exists that seeks to support reformulation e.g.
.
the work to date however h as limited itself to making enhancements that remain clos ely tied to the traditional search paradigm.
a variety of extensions are proposed but the focus remains on issuing sets of keywords as queries.
to better support reformulation in code search we pose that it is necessary to rethink the search engine from the information 30th ieee acm international conference on automated software engineering .
ieee that is indexed to the kinds of queries that can be issued to the way those queries are issued.
the key insight underlying our work is that the results being returned by a code search engi ne provide a rich context that can be leveraged in many different ways to enable reformulation of the current query.
in this paper we experiment with three such ways making keyword recommendations that are based on the words that appear most frequently across the variable names in the results that the search returns providing criti ques that allow developers to dial up or dial down propertie s e.g.
length complexity of the returned results and enabling developers to select language concepts in a search result and add them to the query to for instance specify that the search results should contain a particular method call or import a particular interface which is different from adding that method call or interface as a keyword .
simply providing all these features however is insufficient as it still leaves unsol ved the interaction problem.
we therefore designed a code search user interface that breaks down queries into query parts .
each reformulation of the current query is then performed either by adding a new query part through one of the three mechanisms above by typing an additional keyword or set of keywo rds to add as a new query part or by deactivating an existing query part it will still remain visible so it can easily be reactivated .
in this way the current query is a composition that can be fluidly manipulated in many different ways.
we implemented these ideas in a prototype codeexchange and evaluated its use in a field deployment as well as a laboratory experiment.
combined this gave us a broad look at how people search with codeexchange in the wild as well as a detailed look at how searching with codeexchange compares to searching with github.
in the field deployment of the successful searches those involving copying or downloading of c ode involved use of the advanced features of codeexchange.
in the laboratory experiment we drew on successful searches from our fi eld deployment as input and compared task performance of six participants in issuing queries on codeexchange or github.
we found that participants with codeexchange on average were about minutes faster in finding results.
while this overall is strongly indicative of the benefits of our approach the evaluation also identified several opportunities fo r improving codeexchange.
the remainder of this paper is organized as follows.
section presents relevant backgro und material in code search.
section motivates our work with three problems developers commonly encounter when they search.
section introduces our high level approach and section details codeexchange.
in section we present the system architecture of codeexchange.
in section we present the results of our evaluation.
section discusses threats to validity.
finally we conclude in section with an outlook at future work.
ii.
b ackground this section introduces relevant background material in how developers search query form ulation manual query reformulation and automat ic query reformulation.
a. how developers search that programmers search for code is not a new phenomenon.
even decades ago they wo uld search for code locally with tools such as grep .
sometimes they just want to find some code to look at but other times they search for code to actually copy paste and perhaps adapt somewhere else.
with the proliferation of source code available on the internet pro grammers today can oft be found searching online as part of their daily routine .
among other things it is known that they look for source code that illustrates how to use some api helps them write their own often domain specific code enables them to recall how to use and integrate with a particular piece of code helps them gain a deeper understanding of some programming language feature and allows them to compare their approach to others .
while early on general search engines such as google were the only available tool to search for code online today a variety of specialized code search engines such as ohloh github sourcegraph and searchcode are available.
the research community too has produced a number of code search engines see section ii.b .
of importance to the design of these code search engines is the question of how developers search.
surprisingly not much is known yet with few studies having taken place.
the existing studies though do shed light on some important behaviors that we build on in this paper.
first and foremost search is an iterative process .
this is not a surprise and well know n in information retrieval .
it is simply too difficult to on a first try formulate a que ry that is sufficiently precise to yield the desired result.
devel opers thus need to reissue modi fied queries.
typically this means that they refine the query with additional keywords to attempt to further constrain th e results that are returned .
at the same time it has been found that developers sometimes also need to move in the opposite direction having used a que ry that was too precise and thus needing to adjust the query to be more general .
the second behavior pertains to the keywords developers use to construct their queries.
when they do not exactly know what they are looking for or are more broadly looking to learn about a technology or language they tend to use relatively generic keywords in th eir queries.
when they refine the queries though the keywor ds tend to become less generic and contain more language specific terms .
work has begun to try to theoretically cast these search behaviors.
information foraging theory is perhaps the most explored theory in this regard dis tinguishing prey a goal to be reached predator developer and approximations of the prey queries .
its authors observe that accuracy of goal approxi mation suffers when developers have dif g191culty coming up with effective query terms a common problem.
b. support for query formulation a traditional search engine takes as its input keywords that it attempts to match.
using keywords as such is still the pre25vailing mechanism in the code search engines that are used in practice today.
it has been recognized however that alternative mechanisms exist and may be desired.
it is for instance possible to perform a search in s6 c ode conjurer or code genie by specifying test cases with the results that are re turned code that passes the test cases.
recognizing that perfect matches between the test cases and the code in the search database do not always exist some approaches first attempt to transform e.g.
rename methods reor der parameters the interfaces to expand the results that may be returned .
similar to test cases others use input output specifications to form the query .
yet other appr oaches use the code that the programmer is currently writing to create the query.
strathcona and codebroker for instance take keywords from the code being written to automatically issue queries and grapacc and the approach of bruch et al.
use pattern matching to search for code that auto completes what the developer is working on.
similarly in local code search an approach for utilizing the workspace of the developer was shown to help developers find artifacts.
other approaches like sniff and assieme use the api documentation of the code in their datab ase to enrich their search indexes so there is a better chance for more generic non programmatic queries to pro vide useful results.
explainer and codetrail ev en augment how the results are presented with relevant document ation to support code comprehension.
a final class of code sear ch engines supports queries through more programming language oriented input mecha nisms.
as an example sourcerer allows developers to search for method signatures or specific interface relationships.
a number of other code search t ools e.g jsearch prospector parseweb offer various other such search capabilities.
common to all of these approaches is a heavy focus on initial specification of the right query.
while this is certainly helpful from the perspective of reformulation they perhaps worsen the problem since now the presence of undesirable results must be translated to up dates to complex input structures.
c. manual query reformulation reformulation as a separate step from formulation of the initial query has received much less attention.
in most code search engines it is only supported through inputting new keywords.
a few search engines e.g.
support the use of filters to narrow down results for in stance by project or author but do not go beyond.
a few projects do explicitly seek to support reformulation.
codefinder uses spreading activation networks to match words appearing in th e results to words th at it draws from example source code files a match leads to the matching word being recommended to the devel oper.
mica also generates keyword recommendations although it does so somewhat differently.
it matches keywords in th e results to method and interface names of the java sdk libraries.
a match again results in the matching word to be suggested.
both of the approaches are useful though limited in general applicability.
an interesting approach is presented in .
though aimed at local code search only the authors report success in match ing prefixes and suffixes of id entifiers drawn from its repository of code to keywords in failed searches with the longest matching prefix or suffix rec ommended for reformulating the query.
d. automatic query reformulation in contrast to the suggestive approaches above which still require the human to actually choose to a dapt the suggestion or parts of it automatic que ry reformulation modifies a query automatically in an attempt to provide better results.
blueprint b.a.r.t.
and the work by lemos et al.
are examples of automatic query reformulation.
all preprocess a query before it is issued to the code search engine.
blueprint augments the query with words from the code currently being written in an attempt to find code that fits better with the ongoing effort.
th e other two approaches actually issue not just a single query but multiple each query replacing some keywords with semantically related keywords e.g.
box with rectangle in order to broaden the candidate set of search results.
areas outside internet scale code search also use automatic query reformulation.
sonia hai duc et al.
apply it for finding methods to change in a project.
the authors experimented with many techniques and even built a ma chine learning technique to choose the best depending on the kind of query used.
roccio an information retri eval technique that has not yet been applied to software engineering lets users mark docu ments as relevant or not and then itself constr ucts a new query.
while these approaches have show n promise they at the same time might make things worse.
that is if the automati cally reformulated query does not deliver the right result then how is the user to adjust the query?
iii.
m otivating examples this section illustrates the kinds of problems one encounters when query reformulation is limited to reissuing keywords only.
we show t wo examples both executed on github s code search engine with the filters code and java enabled.
a. finding traveling salesman code our first example is taken from one of the searches that was performed during our field de ployment.
someone was looking for code implementing the trave ling salesman problem.
in effect they needed an algorithm implementation something that is very common in code search .
while the person succeeded in the search by using codeexchange s features re creating the search with github reveals problems.
a reasonable starting query is of course traveling salesman .
the top results from this query however all have zero logic in them as they are abstract classes test cases and empty classes.
a second query could be traveling 26salesman implementation to indicate we prefer actual code.
this does not lead to the d esired result either as the first result is a java file containing a package statement and nothing else and the other nine results are copies of the same junit test file in different github repositories.
it is unclear what to do next though the github advanced search is a possibility it has the option to specify a file size.
this leads to the query traveling salesman implementation size .
this query also does not lead to any code that actually implements the algorithm.
rather the top results are test cases and other code containing library calls.
while a brief non exhaustive example it is representative of many of the searches we saw in our evaluation when developers were restricted to usi ng github s search engine and had trouble formulating the right queries to obtain the results they needed.
without kn owledge of even just one of the traveling salesman implementations on github it is difficult to guess the keywords that might lead to them.
b. finding the observer pattern our second example mimics what happens when one has to look for how to use a particular api.
in this case we search for how to use the java observer interface.
a reasonable starting point is to issue the query implements observer as we are looking for an example of how the interface is used.
the top results do not contain classes that implement the java observer class but instead contain implementations of other obse rver classes.
clearly the query is too generic to avoid this proble m a refined query might tag on java to the previous query implements observer java .
some of the results returned do implement the java observer interface but they are abstract classes and do not show any method invocation of the observer interface.
refining the query further for instance as implements observer java import java.util.observer still leads to the t op results being abstract classes with no implementations an d other results that do not implement the java observer interface at all or if they do that do not show actual method invocations but simply comments that say write your code here .
using quotes to group the import statement implements observer java import java.util.observer finally leads to results that implement the java observer interface.
still the results are not helpful as they are abstract classes empty implementations of observable methods or statements such as system.out.println changed .
none of the top results show real examples of how to use the interface.
again the example is brief and non exhaustive.
certainly it is possible to issue queries that lead to the desired result quickly.
on the other hand it is representative of the kind of mean dering we witnessed in our la boratory experiment and shows how it is all too easy to be walking down a non productive path.
iv.
a pproach our work distinguishes itself by focusing on reformulation from the start.
we sought to design a code search environment in which reformulation is the m ain driver for the features that it provides.
to do so we stud ied the literature per section ii.a talked with local developers abou t their code search habits and prototyped a number of different approaches.
the key insight that emerged is that a significant opportunity exists when one considers the search results from one query as a context in which developers specify the next query.
that is it is typical for developers to think of the next query in re sponse to the results that the previous query gives them.
this response can be of two forms .
it is a response that borrows fr om the results to augment the query.
a developer might see a new keyword or they may find a programmatic construct th at they think could lead them to the desired result if it is incorporated in the new query.
.
it is a response that is relativ e to some of the results.
a developer might want method im plementations that are not empty but have actual code in them or might want results that use more methods than just a few of the api that they are seeking to understand.
one can imagine a rich variety of ways in which the context of code search results can be leveraged in these ways.
it may be interesting for instance to explore whether it helps developers to know the number of test cases that each result has how many open bugs each result had fixed over the past months and how many open bugs are left or how many other developers already looked at a result and copied or downloaded it.
indeed one can easily imagine a rich context consisting of many different kinds of social and technical information that is shown to a developer who is searching.
before we create such a fully featured environment though it is necessary to first estab lish the feasibility of the overall idea and examine whether providing developers access to context is actually beneficial in aiding the search process.
to do so then we experiment with three novel ways of leveraging context g120 recommendations .
because a developer may not know the exact keywords to use in narrowing down a query it is useful to suggest possibilities to them.
we particularly make keyword recommendations that are based on those words that appear most frequently across variable names in the results that are return ed.
variable names regularly encode domain information a fact that we leverage here to make borrowing from the results easier.
g120 critiques .
to enable developers to create responses that are relative to the current search results we use critiques through which developers can dial up or down certain properties desired of the results.
we particularly explore three such properties length of th e code complexity of the code and number of imports.
g120 language concepts.
to enable developers to leverage the code results directly in n arrowing down their search we allow them to select instances of language concepts shown in the results to add to the query.
in this manner develop ers can specify that search results should contain a particu lar method call or that they should be restricted to code that imports a given interface.
27simply providing these features however is insufficient.
it enables reformulation but the overall interaction mechanism of the search engine has to be designed to support it also.
that is while the above features make it easier for the developer to add important considerations to their queries it has to be as simple to remove parts from a current query that may not have had the intended effect or to recombine parts of previous queries.
to do so our queries consist of query parts .
a reformulation of a current query is perform ed either by adding a new query part through one of th e three mechanisms above or by typing additional keywords to add as a query part or by deac tivating an existing query part.
the key is that deactivated que ry parts do not disappear but remain visible and can be reactivated.
the current query then is a composition of query parts that can be manipulated fluidly.
v. c odeexchange in this section we present how we implemented these ideas in codeexchange our pro totype code search engine.
before we detail its support for reformulation we briefly discuss first how a developer can use codeex change to form an initial query.
we also note that codeexchange currently is implemented to deal with java code only.
a. query formulation codeexchange starts with its splash screen figure where the programmer inputs an initial query as a set of keywords that are submitted via the submit button or simply by hitting enter .
the input box provi des autocomplete functionality that uses the word s occurring in identifier names in the indexed code similar to .
codeexchange also offers an adv anced form for inputting initial searches that are more language specific.
pressing the advanced search button in figure brings up the window shown in figure .
the adva nced search form allows users to specify queries that involve imports of certain classes interface properties extends implements location package or project method calls class method parameters and method declarations.
additionally it all ows developers to specify where appropriate whether a class or method should be generic or have a variable arguments.
once a developer has submitt ed their initial search they are presented with the main search interface of codeexchange see figure in which they can reformulate their search.
note that the search interface immediately shows results no clicking on figure .
codeexchange splash screen.
figure .
advanced search.
figure .
codeexchange main interface.
28links is required as is typical in most code search engines and that it is possible to paginate to further results bottom right a .
all results are ranked using lucene s tf idf .
b. query parts after issuing the first query the keyword input box remains at the top of codeexchange interface b .
it though is emptied out with the keywords that were typed now added to the current query on the left of the interface c .
the current query is listed as a set of query parts with all parts that are selected composing the current query.
by default any query part added is stacked at the top and each query part displays both its kind e.g.
keyword complexity import count language construct and its value.
in the figu re three query parts have been provided keywords traveling salesman complexity more than and import count less than .
each query part can be deactivated or reactivated simply by clicking it.
activated query part s are highlighted in yellow with deactivated query parts show n in white.
the current query is the logical and of all activated query parts.
note that compared to the traditi onal back and forth button of a browser composing queries through query parts is flexible any query part can be deactivated or reactivated at any moment in time as there are no restrictions on their order.
programmers can generalize the query by deactivating any part specialize by reactivating an y inactive part or try entirely new combinations by both deactivating and reactivating.
c. recommendations below the current query are the keyword recommendations that codeexchange makes once it has obtained search results in response to the current query note that codeexchange provides additional recomme ndations based on language concepts see section v.e for a discussion .
in this case it lists city distance citycount index name and nextindex d .
if a recommendation is clicked it is added to the current query and the current query is re issued.
once the results return the recommendations also are updated to offer further assistance in scoping the next query.
the keywords that codeexchange recommends are the ones that are most frequent across variable names in the results.
this relies on the following three observations regarding code search and the structure of code.
first search results have co occurring words that can be relevant to a programmer s keyword query this is an essential assumption in the entire field of informati on retrieval and applies here as well.
second variable names usually have domain words in them and consist often of concatenati ons of such words .
finally we observe that variable names are the most abundant source of names in the code as they can make up even of its content .
based on these observations we implemented codeexchange to extract all variable names split them it does this at index time and use the resulting co occurring relationships of name parts within files to make its recommendations.
words thus do not need to be co occurring in the variable names themselv es but be part of co occurring variable names in the same file or files.
a particular striking example of this approach is represented by the keyword query lda lda is a popular means to generate topics describing a la rge corpus .
after lda is submitted to codeexchange the first result is empty and it is unclear if the second and thir d result generate topic models and how they set the model s para meters.
using the automated recommendations made by codeexchange however it is possible to select model alpha beta and topic to obtain search results that generate topic models using the mallet library .
similar recommendation sequences would achieve the same results.
d. critiques at the top of each of the results are the critiques e enlarged version shown in figure .
each critique allows the developer to specify relative to the given result whether they prefer to get code that is l onger shorter has more less branch complexity or has more fewer imports.
in figure the initial query was traveling salesman which led to results that had no logic in it.
this was indicated by the red zero in the complexity critique for these results as is shown in figure for one of the results .
programmers know that most algorithms typically exhibit some branch complexity caused by for loops and if statements.
by clicking the arrow up above the complexity critique a ne w query part is added that specifies that the complexity of the returned results must be greater than .
in the example of figure this led to results that involved a large number of ex ternal libraries as evidenced by a large number of import statements so the imports criticism was invoked to ask for fewer than import statements.
the result is the code shown in figure which actually represent complete implementations of the algorithm.
e. language concepts the third and final use of context is via language concepts in the results that are shown.
each result is presented in an editor with the various language concepts highlighted e.g.
package imports method names types method invocations .
rather than ha ving to encode these as keywords a developer can click on a highlighted language construct to refine the current query to look for code that has instances of this construct.
for example in figure the programmer hovers the mouse over the method compareto which presents them with a popup with additional information about this method.
if they determine they want to add this method invocation as a query part a click on compareto does so and re issues the query all results that are now retu rned by codeexchange will include figure .
critiques.
29compareto method calls that take type e arguments e is a generic type .
for convenience codeexchange automatically recommends the top three most occurring instances across all of the returned results of im plements extends and imports.
this not only saves the user time but because they are based on co occurrences with the other keywords in the current query these recommendations fi gure f help the developer drill down their search quickly.
returning to our second motivating example as discussed in section iii.b submitting the query implements observer suffers the same problem in codeexchange as in github in that none of the top results implement the java observer interface.
contrary to a github search however codeexchange offers a developer ad vice.
in this case it suggests the query to be refi ned by classes that implement interface java.util.observer .
simply clicking this recommendation adds it as a query part to the current query and the next set of results all now implement the interface.
f. additional functionality codeexchange has several additional features that are worth mentioning briefly.
first th e current query can also be restricted to a given result s project.
each code result lists its project in its respective upper right corner g .
when clicked a query part is added to the current query that specifies that all code results must be within this project.
the motivation for providing this support is to allow the programmer to scope the results down to a project when th ey think it will have other relevant code.
second codeexchange offers devel opers the opportunity to download the search result or its encompassing project by using the download icons listed below the code results h .
finally programmers often reuse historical queries to form their future queries .
codeexchange provides a query history not shown that contains all final queries that were issued.
each of the listed queries can be reissued as a starting point for a new search simply by clicking it.
once clicked all query parts that were activated at that time are restored assuming past queries were successful we do not store the deactivated query parts as part of th e history .
the history is presented as a grid where each cell contains a past query.
the cells are chronologically ordered.
a similar approach is taken by searchbar a tool for resum ing search for web pages.
vi.
s ystem architecture codeexchange consists of four pri mary components a list server a code miner a search engine and a web search interface.
figure presents its architecture as a data flow diagram of the primary informati on that flows among the four components.
the list server contains a list of repository urls i.e.
different projects on github.
we obtained this list by using github s api to identify the urls of repositories that included only java code a list we obtained between february and february .
the list server simply passes a single not yet mined repository url to the code miner each time the code miner has completed mining a previous repository.
once the code miner has received a repository url it clones the repository from github and analyzes it to create a summary of each of the source code files in that repository.
to do so it extracts a variety of in formation including method and variable names import statem ents method invocations code length code complexity and other items necessary to support the codeexchange user interface.
this summary is stored in a database that the search engine maintains.
the search engine uses the apache solr framework to index the source code summaries.
when it receives a query from the web search interface it uses solr to identify the source files that match the search criteria.
it ranks the results using lucene s tf idf and returns them to the web search interface together with the original source files that it obtains from github we do not store any source files locally since cloning github is prohibitively expensive in disk space .
the web search interface was built in ajax using the jquery library .
it implements the user interface discussed in the previous section and is responsible for sending queries to the search engine and rendering the results.
from the repositories we thus far have mined over projects with the resu lting database consisting of 10m classes 150m methods and 253m method calls that are searchable through codeexchange at codeexchange.ics.uci.edu.
vii.
e valuation we evaluated codeexchange in two complementary ways.
first we wanted to deploy it to real programmers to understand if they would actually use it and if so how they would use it to reformulate queries.
we posted brief announcements on several java and programming forums and collected figure .
language concepts.
figure .
system architecture.
30logs of the resulting usage.
second we wanted to directly compare how searching with codeexchange differs from searching with github keywords.
to do this we performed a lab experiment for which we recruited six participants.
each of them performed a number of searches inspired from successful field deployment searches.
we chose github as our comparison for two reasons.
first because codeexchange indexed java source code from github it puts the two on equ al footing with respect to the collection of projects against which queries are evaluated.
this enabled us to perform the second experiment.
second we pre ferred to use github over a ge neral purpose search engine such as for instance google to filter out non code related search results.
in the below we present the details of each of the evaluations and discuss our findings.
a. field deployment on july th we posted a pre announcement to a small group of developers that our research group interacts with on a regular basis.
we made this pre announcement to vet possible problems before we made the more public announcements.
as we did not experience any serious issues we moved on quickly and posted several brief announcements of codeexchange s availability on p ublic forums such as reddit javaranch and hacker news .
our post on reddit for instance read as follows codeexchange a new java code search engine codeexchange.ics.uci.edu we received the most activity in the week we posted on hacker news august th and reddit august 6th .
other forums were less effective in drawing attention.
codeexchange logged all visito r behavior by assigning each first time visitor a unique anonymous id that is stored as a cookie in their browser.
this is especially important to track their return behavior.
every time a codeexchange feature was used an entry was made in the logs detailing which feature was invoked any input the user provided and the date and time of feature use.
from july 31st to august 19th we observed more than users of codeexchange.
approximately of the users were robots which we di scarded immediately.
about users just typed in keywords on the splash screen and subsequently never did anythi ng else.
we discarded these from our analysis as well leaving roughly users who collec tively performed searches.
figure plots all of these users with all of their searches on a graph where the y axis is the visitor identifier and the x axis represents the date and time of the search.
as the visitors came from many different time zones we treated all their local search times as pst time.
this is why there is a search on august th even though we stopped co llecting data on august 19th .
black dots denote users who searched once.
blue squares are searches by a visitor who after at least one hour has elapsed returned for another search blue lines connect back to the first search by the visitor .
red circles around a blue square or a black dot indicate that a copy or a download occurred as part of that search.
visitor for example searched on august th 11th and 12th with the latter two searches involving copies or downloads of actual code.
overall visitors re turned for additional searches over th e fourteen days and searches used the advanced features of codeexchange.
for purposes of studying how ref ormulation helps with the search process we focus on just those searches that involved a copy or download since we can reasonably assume that a search involving copy or download meant that the user actually found what they are looking fo r this is conservative and optimistic at the same time see section viii .
out of the searches this left covering a broad range of searches e.g.
travel agency code twitter api usage convex hull algo rithms .
figure presents an encoding of some of these searches with each sequence of columns representing a set of queries that constitute a search k for keywords r for recommendations q for critiques c for language concepts p for project filter empty for times when all query parts are deactivated .
we can see how users reformulated their queries in a variety of ways using all of the co deexchange features in the process.
use of keywords still dominated as did the use of project re figure .
searches from our field deployment.
figure .
sample query sequences.
31finements which is not a s urprise since it is how developers are used to search.
of the codeexchange features language concepts were used in searches invocations in total recommendations in and critiques in .
while in the absolute these numbers are small especiall y for critiques of the successful searches involved use of the new fea tures.
we further note that among the successful searches involved users turning off one or more query parts as part of their explorations.
on the whole the field deploy ment did not lead to as much usage as we had hoped.
while users showed a lot of interest and explored the features only searches qualified as suc cessful in that we could re asonably assume the developers found what they needed.
in some ways this is not surprising given that we posted merely bri ef announcements performed no training and many users likel y just visited to satisfy their curiosity.
on the other hand we had hoped for more.
nonetheless we are encouraged by the results.
some users returned days or weeks later to search again with a number of those searches leading to copies or do wnloads.
additionally the fact that in the successful searches the advanced features were used extensively provides in itial evidence that there is value in the overall approach.
b. laboratory experiment comparative use to delve into th e differences between github search and codeexchange search we performed a laboratory study.
it involved six java programmers.
two were working as devel oper interns one was working a full time development job and three were graduate students with or more years working as a developer.
we constructed six independent search tasks each patterned after a successful search taken from the field deployment.
we read the code that was copied or downloaded looked up documentation to further dete rmine what the code does and developed a general task descripti on.
figure presents one of the resulting tasks with others concerning code related to oracle thin jdbc drivers minecraft yaml files android wake locks calculating convex hulls and raspberry pi gpio.
before the experiment began codeexchange and github s search engine were explained.
for codeexchange we walked through all of the featur es that are discussed in section .
for github we showed them how to use keyword search ad vanced search sorting functions how to navigate to a project page of a code result as well as how to filter results by code and the java language.
each participant worked on the six tasks in the same order switching search engines after each task.
half starting with codeexchange and half with git hub.
participants were given a description of the task and up to minutes to complete each task.
each task asked participants to find th e code that they felt best matched the instructions.
after completing the task participants answered several survey questions.
at the end the ex perimenter conducted a semi struct ured interview focusing on their relative perceptions and their use of features during the study.
we recorded the screen and logged participants actions.
from this we calculated task time from the moment they be gan interacting with the search engi ne by typing search terms until they pasted the found code into the task completion sur vey.
table presents our main results listing times for each task.
grey cells indicate github times and white cells codeexchange times.
on averag e participants completed tasks minutes faster with codeexhan ge than with github .
versus .
minutes .
however there were several outliers in the data.
for example in two cases using github participants were still looking for code at the end of minutes.
to remove these and other outliers we perfo rmed symmetrical truncation an accepted technique for trimming outliers and removed the two slowest and two fastest times from each search engine double underlined in table .
after removing outliers we found participants were about minutes faster with codeexchange.
performing a one tailed t test codeexchange and github times are separate groups and have equal variance on the truncated results we found that this difference is significant p .
.
further with a power level of .
we found the effect size to be large d .
.
this means that codeexchange had a large effect on the user s task times co hen s d greater than .
is considered large .
in the tasks with codeexchange its advanced features often helped participan ts in identifying the code they copied.
in of the tasks they did not need them in the other they used recommendations language constructs critiques as well as deactivations and reactivations for 3rds of all tasks being helped with codeexchange.
one participant reported that complexity cri tiques helped when he found code that was too dumb and did not kn ow how else to continue enabling him to increase the desi red complexity and find his desired search result.
another participant said she never used codeexchange s advanced search because searching through language concepts and automated keyword recommendations let her do similar searches.
several reported that the layout of the results made them easier to read.
when searching participants of ten wished to reformulate their queries by backing up a level removing a portion of their query.
to back up in github participants were forced to start from scratch needing to remem ber the keywords they had used before.
participants reported that codeexchange made it easier to back up as they could simply activate and deactivate query parts.
others reported that query parts helped them try different combinations of queries.
all of the participants had positive reactions to codeexchange such as codeexchange is better than github no doubt.
but participants al so had several suggestions for background jboss is an open source java application server maintained by red hat.
there is a jboss api for creating different kinds of