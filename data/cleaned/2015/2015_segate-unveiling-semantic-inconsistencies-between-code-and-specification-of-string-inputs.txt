segate unveiling semantic inconsistencies between code and specification of string inputs devika sondhi iiit delhi new delhi india devikas iiitd.ac.inrahul purandare iiit delhi new delhi india purandare iiitd.ac.in abstract automated testing techniques are often assessed on coverage based metrics.
however despite giving good coverage the test cases may miss the gap between functional specificationand the code implementation.
this gap may be subtle in nature arising due to the absence of logical checks either in theimplementation or in the specification resulting in inconsistenciesin the input definition.
the inconsistencies may be prevalentespecially for structured inputs commonly specified using stringbased data types.
our study on defects reported over popular libraries reveals that such gaps may not be limited to inputvalidation checks.
we propose a test generation technique forstructured string inputs where we infer inconsistencies in inputdefinition to expose semantic gaps in the method under test andthe method specification.
we assess this technique using our tool s egate semantic gap tester.
s egate uses static analysis and automaton modeling to infer the gap and generate test cases.
on our benchmark dataset comprising of defects reported in 15popular open source libraries written in java s egate was able to generate tests to expose of the defects.
index t erms testing static analysis string input generation regular expression automaton modeling data flow analysis i. i ntroduction oftentimes a programmer may implement a functionality that differs from specifications either in the documentationor in standard conventions followed for inputs especially structured inputs such as a file path or url.
these structured inputs despite being valid as per the specification may endup being handled incorrectly in the implementation if logicalchecks on the expected input are missing or weakly definedor if there are additional checks in the code that constrain the input as compared to its specification in the documentation.
qualitative evaluation of test cases based on code or path coverage may overlook such issues.
consider the defect 1in google guava library s getfileextension method in files class.
according to the specification as obtained from the javadoc the method acceptsa string denoting a file name and returns the file extension or an empty string if the file has no extension.
the faulty implementation shown in listing misses cases where a dot .
the extension separator may be present in the internalpath components of the file name.
for instance the methodwith input c abc.def testfile would incorrectly return the extension as def testfile when it should return defective implementation of getfileextension.
returns the file extension for the given file name or the empty string if the file has no e xtension .
t h e result does not include the .
.
public static string getfileextension string filename checknotnull filename int dotindex filename .
lastindexof .
return dotindex ?
filename .
s ubstring dotindex an empty string.
the implementation returns the substring following the last .
.
however the implementation misses thatthe file separator in this case may occur after the dot which is valid for a file path.
appropriate constraints to extract a valid file extension are not explicitly provided either in the main code or as assertions by the developer.
as a result passing the program path constraints to a constraint solver or using a fuzz tester isunlikely to generate tests to reveal the described defect.
we know from the documentation that there is only a single .
as extension separator while rest of the occurrences of .
act as non separators.
the implementation presumes all occurrences of .
to act as separators.
our proposed techniqueleverages this gap by formulating two regular expressions fromthe documentation and the implementation respectively todenote the input structure treating separator .
as a differentcharacter altogether from the non separator .
.
using this approach we generate the potentially defect exposing test strings that denote the differences in the two regular expressions.
our work focuses on test generation of structured and semi structured inputs commonly specified using string baseddata types.
the approach particularly targets cases of missinglogical checks in the implementation or missing details in the specifications that are otherwise part of the implementation.
a solution to deal with such inconsistencies may be specificto the nature of input data type.
the situation becomescomplicated with string inputs where the size of character set charset may be large and the manipulation operationson strings may be diverse.
these challenges make testing a non trivial task.
while researchers have done substantial workon detecting input validation defects in a method these techniques may not necessarily expose subtledefects in the method once the input passes all validationconstraint checks.
ui .
oufsobujpobm pogfsfodf po vupnbufe 4pguxb sf ohjoffsjoh authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in this paper we make the following key contributions a test generation technique to expose defects arising from string based input inconsistencies between methodimplementation and specification.
these inconsistenciesmay be semantic or syntactic in nature.
design and implementation of a prototype tool s egate to assess the proposed technique on java programs.
exposing unreported defects in widely used libraries using the proposed technique.
segate s novelty is in its differential approach that is combined with in depth string analysis and prioritization heuristicsto improve the quality of test strings.
the technique allows tar geting tests beyond the coverage criteria and input validation.
section ii gives an overview of our technique.
ii.
o verview a. motivating example consider the defective implementation of getprincipalsandcredentials method from apache shiro library in listing .
the method documentation describes the encoded input as a base64 encoded username password value found in the request s authorization header.
the method is expected to return the username and password pair split over .
rfc2617 referred to in the documentation states that the user name excludes character but it is valid for a password tocontain a even though there is only a single that acts as a separator.
the implementation misses the support for this scenario thus depriving a user having in the password from connecting to a shiro protected application.
for instance for a base64 encoded input foo this bar the method returns password as this at the second index of the returned string array instead of the expected this bar .
the implementation has a single program path possible with the split function indicating the possible presence of in the input.
there isno additional check on single and multiple occurrences of as both require a different way of handling.
however givena single constraint it is not guaranteed for a constraint solveror a fuzzer to be able to generate concrete value containing more than one .
thus the defect due to a missing constraint check may be left unexposed.
our technique models the structures of the specified input and the implementation derived input as regular expressions regexes r sandri respectively.
these regexes may accept different languages.
for the encoded input rsis obtained by annotation derived from the grammar in rfc as below segate statically analyses the method to derive rias as the colon can act as a username password separator or a non separator s egate assigns a different character representation in the regex as nonspl for the occurrence of colon as a non separator in rs.
we generalize this idea to all characters that could play multiple roles in a string structure.
defective getprincipalsandcredentials method.
returns the username and password pair based on the specified encoded string obtained from the re quest s authorization header .
per r f c the de fault implementation first base64 decodes the st ring and then splits the resulting decoded string into two based on the character8 param s cheme the authcscheme found in the request authzheader .
it is ignored by this implementation but available to over riding im plementations should they find it useful .
param encoded the base64 encoded username password value found after the sc heme in the header return the username index password index pair obtained from the encoded header data .
public string ge tprincipalsandcredentials string scheme string encoded string decoded base64.
decodetostring encoded return decoded.
s plit the approach models rsandrias two separate deterministic finite automata dfa to compute the differential dfa d .d represents the symmetric difference between sets of strings accepted by rsandri.segate applies prioritization heuristics to generate a subset of test strings accepted by d .
for the discussed example s egate successfully generates test strings with occurring in the password of the encoded input as described in the reported defect hence exposing the defect.
b.s egate overview we implement the proposed technique in a prototype tool segate semantic gap tester.
figure shows the two main components of s egate in grey boxes.
here is a flow of steps.
the static analyzer performs an inter procedural dataflow analysis to compute the regex ri denoting the input string to the method as inferred by analyzing theprogram.
the analyzer also extracts special charactersfrom the program which are later used for test generation.
r iis passed to the test generator which also takes a human annotated or system recommended regex rs.
here rsdenotes the set of input strings that are expected to be accepted by the method as inferred from the documentation attached with the method being tested.
rsandriare modeled as dfa from which s egate computes the symmetric difference between the two regexesto obtain a differential automaton d .
d is transformed into a graph.
by performing a prioritybased traversal on the graph a set of test strings aregenerated that would be accepted by d .
these test strings represent the inconsistencies over input constraints in documentation and implementation.
we describe the components of s egate in the next section.
iii.
s egate architecture a. static analyzer we apply static dataflow analysis to derive the regex representing the structure of string input from the source code.the static analyzer built using soot performs forwardflow inter procedural and context sensitive string analysis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
test generatorstatic analyzer source code and documentationtest stringsregex extractor derived regex annotated recommended regexspecial character extractor string methods regex mappingdifferential automatonautomaton tranformationprioritized automaton traversal fig.
the architecture of s egate tool.
table i flow functions used in string analysis sa .
v ector r regex containing characters c ascii charset kill sa stmt braceleftbigg stmt taintedstmt all otherwise gen sa stmt stmt taintedstmt stmt t hrowstmt concatenate e r e inset stmt stmt ifstmt loopstmt invokestmt assgnstmt with string where r is regex obtained from regmap operation and stmt taintedstmt uniontext using e inset stmt returnstmt inset stmt braceleftbigg .
at method entry uniontext outset s prime s prime pred stmt otherwise outset stmt uniontext using e inset stmt at method exit inset stmt kill sa stmt otherwise gen sa stmt regmap contains mapping from method to the regex denoting the input structure derived from the implementation.
algorithm derive regular expression.
data m method to test in address jimple code result regmap regex mapping for all method inputs 1function regex flow m initialize load regex mappings for string api regmap loadregexmapping cg m.getinterproceduralcallgraph removebackedges cg remove cycles from cg methods getmethods cg java lib.
methods are ignored reversetopologicalsort methods forall m in methods do cfg getunitgraph m control flow graph forall stmt in cfg do compute inset outset func.
regex outset from func.
regmap.add m regex return regmap algorithm describes the derivation of regex from the method.
the analysis takes the method under test in the formof a address code in jimple format and returns thestring representing the regex for each string input accepted by the target method.
the regex flow function obtains the call graph to arrange methods in the reverse weak topologicalorder algo.
line to perform an inter proceduralanalysis and compute the analysis summary.
using the flow functions in table i the analyzer further performs string analysis over statements of each method algo.
line .
in the rest of the paper we refer to a string based parameter as input.
the inset vector at a method statementcontains the regex status of the input as derived from the control flow paths reaching from all predecessors to thatstatement denoted by pred stmt in function condition func.
cond.
.
on processing the statement the inset elements are updated based on gen saand killsafor the statement type to obtain the outset func.
.
note that the presented string analysis is not a bit vector analysis and gen sa and killsadepend on the inset .
the analysis uses taint propagation to extract statements affected by the input and hence contribute in generatingregex.
at the method entry we assume the input parameter astainted and add it to the inset.
further using a may variant of constant propagation the local variables referring to aconstant string at an instance are replaced by their corresponding possible constant values.
our implementation of constant propagation also handles obtaining new string constants dueto statements involving string concatenation functions andexpressions.
these constants are useful in building the regex.
summary computation regmap maintains mapping summary from method to regex denoting the structure of theinput derived from the method implementation.
regmap is updated with summaries as more methods are analyzed algo.
line .
initially we maintain a manually obtained regexmapping for methods in java s string api.
for instance aregex for startswith str method over alphanumeric charset is str w .
the analyzer replaces str with all its possible values obtained through constant propagation analysis described previously.
we assume that the third party library authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
methods written in java dealing with string inputs may at some point invoke the methods from java library s string class.hence having these basic mappings would aid in buildingregex for string inputs of other methods.
while obtaining thisinitial mapping we ignored update methods like concat andits variants.
these methods make additions to the tainted stringwithout revealing any information about its original structure.
we stop exploring the depth of the call graph at a method invocation from the java library.
the analyzer fetches thecorresponding regex from regmap for the invoked method.
statement analysis for a method the regex flow function generates regex by processing each taint affected statement taintedstmt according to its type such as conditionals loop conditions assignments invocations and return.
for our analysis we are only interested in a statement if it contains at least one tainted use value.
for instance in anassignment statement having a tainted use value indicates that the variable being defined on the l value is directly or indirectly affected by the input string and hence would be usefulto infer the structure of the input.
in statements containingmethod invocations if the implicit parameter of the invokedmethod is tainted we pass the tainted values and constant arguments of the invoked method to obtain the corresponding regex from the existing mapping in regmap of the invoked method.
this regex is then appropriately concatenated withthe existing regex in the inset according to the flow func.
cond.
to obtain the outset func.
cond.
.
consider int dotindex filename.lastindexof .
from this statement one can infer that filename may contain the character .
hence deriving regex .
?
for this statement.
a typical conditional statement has a boolean expression which may be an in equality check or a method invocation.
we treat switch case statement conditions and loops conditions similar to if else statement.
conditionals involvingtainted values are relevant for our analysis to infer details aboutthe input.
similar to the assignment statements we maintaina condition to regex mapping in regmap to build on the regex from the conditional statements.
to reach a converging fixed point while analyzing statements inside a loop body the derived regex from the loop body is not concatenated in theoutset elements if already done in the previous iteration.
condition leading to a throw statement that raises exception may not be useful in learning about the input as it indicates a case already handled for an invalid input.
hence for everythrow statement the analyzer kills all elements func.
cond.
in the inset and generates nothing func.
cond.
.
however the analyzer still captures the negated conditionthat takes the else path.
the intuition is that the negatedcondition would define constraint on a valid input.
for a return statement the regex derived along all paths reaching it are concatenated using a indicating logicalor func.
cond.
.
as all return statements lead to a method exit the regex coming from all return statements areconcatenated using a indicating logical or func.
cond.
.
the final single regex thus obtained represents the set ofstrings that the input would match.
this regex is added to regmap corresponding to the method analyzed.
statements of other types do not influence the regex and are hence ignored.
handling multiple string inputs if a method consists of multiple string parameters inputs then for every input at a time we mark it as tainted and others as untainted to proceedcomputing its regex.
this idea is similar to symbolic executiontreating one input as symbolic and others as concrete.
collecting special characters any hard coded character or string occurring in a statement is recorded in a set ofspecial characters.
this set is passed to the test generator.
section iii b discusses the use of this set in detail.
b. test generator the test generator aims to generate concrete test inputs that are supported by exactly one of the two the methodimplementation or the method specification obtained from thedocumentation.
the regex r i derived by the static analyzer is modeled into a deterministic finite automaton dfa using the dk.brics.automaton library .
from the specifications we infer and annotate the regex r s for the string input which is further modeled into another dfa.
obtaining annotations from specification similar to past techniques that take assertions or contracts as inputs such as with randoop s egate takes rsannotations from an expert or as recommendation from our system.
to obtain rs we follow a semi automated approach using an annotation rec ommender system.
we build a repository of regex annotationsfor standard string structures to recommend annotations tofurther test other methods taking similar inputs.
the repositorycontains a tag associated with every annotation describingwhat the annotation denotes such as json string ip address etc.
to obtain recommendation for r s the system takes a query description as input and computes a phrase similarity score between the query and every tag in the repository picking thetag with the highest score ranging between and providedthe score exceeds the empirically determined threshold of .
.to compute the similarity score we use a semantic similaritycomputation api .
the regex corresponding to the picked tag is recommended.
if no appropriate tag exists the user provides an annotation which is fed into the system alongwith a provided tag for future recommendations.
such anapproach thus reduces manual efforts and allows incorporatingdomain knowledge about the input structures which could be leveraged to test other methods.
obtaining a differential df a the two dfas modeled fromr iandrs are minimized using hopcroft s algorithm .
segate computes a differential dfa d accepting the set of strings which is the symmetric difference represented by rs ri rs ri using a dfa for string generation provides flexibility as well as control to generate diverse strings by traversing differentpaths of the automaton.
automaton model could also be usedto generate strings by traversing selective paths.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm derive d anddt.
data regex strings ri rs result transformed automaton dt 1function transform automaton ri rs automaton ai ri.toautomaton automaton as rs.toautomaton automaton d difference union ai as intersection ai as transformation forall transition statepair s1 s2 in d do charset symbolset partition s1 s2 .symbols splchars forall sym in symbolset do node n node s1 s2 sym ifs2 is acceptstate then n.setacceptnode ifs1 is initstate then n.setinitnode ifs s then n.setselfloopnode true forall adjacent nodes n1 n2 do edge e edge n1 n2 where n1.secondstate n2.firststate return automaton set node asciicharset set edge set initnode set acceptnode need for differential automaton the differential nature of d makes the strings accepted by it as relevant test inputs.
we expect most ricomplying strings to comply with rs and vice versa.
hence we use a differential approach to narrowdown to potentially defect revealing strings.
df a transformation for string generation the ascii charset and the special characters obtained from the static analyzer make up the alphabet for the dfa.
however d may accept a large number of strings.
to prepare test inputs the requirement is to obtain a smaller subset of strings acceptedbyd .
thus the generator generates a subset of strings such that every sequence of transitions from each start to acceptstate in d is traversed not more than once.
to ensure that every transition is visited once we transform d todt treating each transition as a node and each pair of adjacent transitions as an edge .
figure shows an example of a snippet of d being transformed to produce dt.
algorithm describes the derivation of d line and its transformation to dfa dt q q0 f line defined as below q set of finite nodes formed where a pair of adjacent states of d form a node also called a state pair node alphabet containing the ascii charset and the special characters set obtained from the static analyzer set of transitions between all adjacent state pair nodes with the transition function q q. for adjacent state pairs nodes n1 and n2 n1.secondstate n2.firststate q0 start nodes which are the set of nodes with the first state as a start state of d f subset of q containing accept nodes denoting strings accepted by the regular language of expression .
a node n is in accept state if n.secondstate is an accept state.
t est string generation from dt to obtain the test strings we apply a variant of depth first search traversal dfs visit function of algorithm over d tto visit every node that represents a transition edge from d .
the number of nodes in the automaton despite minimization ranged tolarge numbers with maximum nodes for a method in ourdataset.
hence while traversing d t we do not visit a node more than once hence ignoring the respective path algo.a cdb e a b c db d a cb c s... d e c s... s... fig.
transformation from d todt.
algorithm generate test strings.
data dt result string teststrings 1function generate teststring dt forall initstate src in dtdo teststrings.add dfs visit src visited dt str teststrings return teststrings data srcnode visitednodes dt result string teststr list of test strings 5function dfs visit src visited dt str teststr visited.add src ifsrc.isacceptnode str not in teststr then teststr.add str prioritize src.neighbors forall neighbor of src do ifneighbor not in visited then concatenate random char from the symbols of the node str str.concat neighbor.randomsymbol ifneighbor .isacceptnode then teststr.add src dfs visit neighbor visited dt str teststr return teststr line .
this optimization allows the technique to scale by avoiding path explosion and allows generating a smallerset of strings suitable for a test set.
while traversing fromevery node a symbol is randomly picked from the range of symbols supported for the node and concatenated to thestring being derived algo.
line .
on reaching an accept state node the resultant string is logged and the traversalcontinues deriving other test strings algo.
line .for the getprincipalsandcredentials method section ii a the corresponding d t due to its differential nature would contain at least one path that accepts strings containing boththe colons and nonspl in the username password encoding.
advantage of dtover d note how the traversal over dt instead of d guarantees visiting every vertex of the original differential automaton d .
referring to figure to explain through an example a traversal along the path a b d e on d would mark all the states vertices along the path as visited.
this eliminates the paths a b c d e anda c d e due to banddalready marked visited leaving vertex c unexplored.
transformation to dt as shown in the figure defines distinct nodes for every transition and running a depthfirst traversal on this automaton would allow exploring more paths allowing every state from d to be visited.
note how the path a c d e ora b c d e could now be included in the traversal in addition to a b d e .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii list of some of the known defects from popular libraries used for evaluation.
bugid methodname library defect description io filenameutils.
directorycontains apache commons io gives false positive when two directories have equal prefixes io filenameutils.getextension apache commons io implementation misses accounting for existence of alternate data stream in file path http urlencodedparser.parse google http java client a parameter with in the value is misinterpreted separate representation for special characters recall that the static analyzer derives special characters that arepassed to the test generator.
these characters appear directlyin the implementation.
hence they should be given moreimportance over other characters in the charset while generating the test strings.
in d the transition symbols contain a range of symbols merged into a single transition.
thesesymbols may include special characters s egate represents each of which on a separate transition edge.
to introducethese separate transitions the partition function algo.
line performs splitting of the symbol range.
for instance a transition with symbol range a g having das a special character would be split into three transitions with respectivesymbol ranges as a c dand e g .
analogous to splitting the transition d twould introduce additional state pair node with corresponding symbols set according to the separated transition edge.
on traversing dt these special character edges are given higher priority over other edges algo.
line .
so provides the advantage of generating stringscontaining special characters.
design decisions and trade offs the static analyzer assumes that if a variable is tainted then the constraints onit are relevant to infer r iof the input that tainted it.
for instance in listing from section ii decoded is tainted by the input encoded as the inter procedural analysis results in decodetostring invocation returning a tainted output.
hence the taint is propagated on to decoded .
as a result the subsequent call on decoded.split induces the constraint of being present in decoded as well as encoded .
the constraint on encoded is valid for the given example as inferred by studying the nature of manipulation on encoded bydecodetostring .
however in general this propagation of constraint on the actual input may not always result in an accurate inference.
the analyzer could possibly relax theconstraint on the input into a possible occurrence instead of strict occurrence.
however this relaxation would increase theexploration space of strings.
due to scalability consideration the analyzer imposes strictness on such constraints.
due to the size of the differential automaton being large capturing every transition edge would not scale.
as a result we applied the transformation to d tto allow covering equal or relatively more number of paths of string sequences thanthe number we could have covered on d .
to generate a reasonable number of test strings we ignore paths on whichthe nodes have been visited before.
while this allows theapproach to scale and results in a set of test strings representingthe gap it comes with a trade off on missing certain interestingtable iii evaluation data description.
data description value faulty methods analyzed code size loc mean stdev.
.
range of code size loc 2955call graph depth mean stdev.
.6range of call graph size table iv performance of s egate in exposing defects.
metric value known defects in dataset new defects exposed using s egate known defects exposed by s egate total defects exposed by s egate of test strings generated per run mean stdev.
range of of test strings generated 12266execution time s per run mean .
stdev .
.05memory consumption mb per run mean .
stdev.
.
paths from the perspective of producing defect revealing strings.
improving on the traversal heuristics would be of our interest.
iv .
e xperimental ev aluation we evaluated s egate on its ability to expose defects in a method or its specification.
we ran s egate i on methods with known defects to verify if it generated test inputs to expose the defects ii on methods in popular libraries withthe objective to expose potential defects iii to assess itsperformance relative to state of the art techniques.
all evaluations were performed on a windows bit system with intel core i7 5500u .40ghz processor with 8gb ram and maximum jvm heap size of 4gb.
s egate has been built over eclipse mars .
.
ide running with java .
.the dataset and results are available at the project website.
a. v erifying against known defects methodology we picked commonly used string structures often used in research to evaluate program methodstaking such structured input.
these structures include filepath url json format ip address phone number email and credentials.
to prepare a benchmark dataset with known defects we extracted top starred java projects on github.filtering on keyword search over these repositories on thestructure names mentioned we obtained projects that had at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
least one method taking at least one such structure as input.
we inspected the issue trackers of these projects and extractedissues labeled as defect.
we considered defects no older thanreported in the year to avoid the scenario where themethod of concern is obsolete.
we further picked moreproject which has been frequently referred to in some of these14 projects and followed the same filtering approach on it.this resulted in analyzing issues in open source projects.from the filtered issues we shortlisted defects discussingmethods that take at least one parameter as a string basedstructured input and discuss one or more of the followingcases i there is a difference in what the documentation orthe referenced specifications state and the code behavior ii there is a practical use case that is not handled well by theimplementation.
some such defects are listed in table ii.
we obtained a dataset of such defects in distinct methods across libraries.
corresponding to every method were java documentation or external documentation describing the input structure.
if our recommender system lacked a relevant regexannotation r s we assigned an annotator a computer science graduate having a development experience of years injava with the task of deriving r sfrom the documentation.
the annotator was provided with the documentation of thefaulty method and the method parameter for which we requireobtaining r s. to avoid bias the annotator was not informed about the purpose of the study.
one of the authors performedthe same task to validate the annotations derived.
for methods in our dataset the documentation referred to external sources such as rfcs that contained grammar defining the syntax of the string input.
the annotators were required toderive r sfrom the grammar.
a manual annotation on an average required minutes.
this exercise was required for of the methods.
for the remaining methods basedon our domain knowledge we felt that the recommendationforr s returned by our system is fit for usage.
to assess the inter rater agreement the free marginal kappa score was computed as .
which is rated as fair to good .
in 3of the annotations there was a minor disagreement amongannotators which was resolved over discussion.
the final annotation r s was then fed to s egate to generate test strings complying with expression .
these annotations were added in the recommendation repository for future query.
as the repository expanded we observed improvedrecommendations.
this indicates the usefulness of manualintervention in annotating as the domain knowledge gainedfrom experienced developers contribute to strengthening therecommendations.
we ran s egate on the faulty methods in our dataset to check if it generated test inputs to expose the defects.
we assess s egate on the number of defects exposed by its tests and its execution time and memory usage.
table iii gives astatistical description of the nature of programs in our dataset.the description includes the range and the average size of the code loc over faulty methods.
the code size is a count on the number of distinct statements including inter procedural method body in jimple representation visited bylisting snippet indirectly manipulating occurrence of .
while index json .
length char current json .
charat index if current inobject if current inobject if current inlist if current in list if current inob ject inlist list .add build .
tostring build .
setlength else build .
append current index the static analyzer.
the call graph depth refers to the depth of method invocations involved in the method under analysis.
results segate generated test strings exposing of the known defects.
table iv gives the details of theexecution time and memory consumption of s egate with values averaged over executions over every method.
overeach program s egate executed in a matter of a few seconds not exceeding seconds with the mean value of .
seconds.discounting the memory consumed by the garbage collector s egate s memory consumption on execution ranged between to mb as evaluated on every method in the dataset.
for the defects missed by s egate following are the key observations to infer the reason for failure.
i.indirect manipulation on position of characters in the string consider the faulty method reported in the defect spring boot which constrains the occurrence ofcomma relative to and statement oflisting .
this constraint is enforced by integral coun ters.
the static analyzer does not currently support mak ing such precise inferences from numeric manipulation onstrings.
the analyzer infers the occurrence of comma anywhere in the string.
hence s egate misses exposing the defect.
however the analyzer has basic support forinference of regex from character position.
for instance str .charat results in a regex indicating at third position in str.
index based manipulation on substrings is handled based on certain templates to infer the positionas either at front last or in between the string.
ii.missing explicit checks from the specification as well as the implementation the case reported in v alidator420 is about a validation method incorrectly accepting urlcontaining a space character.
as both the specificationand the implementation do not have an explicit con straint barring occurrence of a space in a url s egate misses exposing the defect.
as the charset of invalidcharacters may be huge we do not currently consideroccurrence of a character while modeling r iandrs i f it does not explicitly appear in the implementation or the specification.
we would be interested in obtaining implicit characters that are common sources of errors in the future.
nonetheless adding the space in thecharset of r sallowed s egate to reveal the defect.
b. exposing unreported defects methodology with an objective to explore new defects we picked the first test strings generated or all if test authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v list of unknown defects from popular libraries exposed by s egate .
no.
methodname library defect description .
files.getfileextension google guava the method does not handle ads file paths supported in ntfs .
inetaddresses.isinetaddress google guava gives false positive for ipv6 address in certain cases of occurrence of 0s such as in the last bit group for 804c 404c cc c0 00c0c .
jsonparser.parse spring boot several validation checks missing in jsonparser no check on closing .
phonenumberutil.parse libphonenumber specifications from the rfc reference in the documentation are loose as compared to the stricter checks in the actual implementation .
uriutils.extractfileextension spring validation check missing on the url path6.
inetaddressvalidator.
isvalidinet6addressapache validator does not account for presence of scope id in the ip address strings for each of the faulty methods obtained in section iv a and passed them as inputs to the respective method.the obtained output for every input was logged.
the potentialdefects may not necessarily lead to an exception throw theprogram could silently give an unexpected output.
hence we manually studied the logged output to look out for unexpected output indicative of an exposed defect based on the intendedbehavior specified in the documentation.
note that our workcontributes in generation of quality test inputs to help a testerprioritize the tests.
we leave it to the tester to validate theprogram s behavior on the test inputs and decide whether the implementation or the documentation should be altered.
results by manual inspection we could spot new defects in the methods in our dataset.
on increasing the limit to inspecting first test strings for each method we explored more new defects.
table v lists these new defects exposed by s egate .
these defects varied in nature discussed as follows i.missing validation checks leading to false positive output third defect table v is about missing validation checks in code accepting invalid json inputs without throwingan exception.
second and fifth defects have similar nature.
ii.missing support for certain inputs in the implementation when the documentations implicitly support them first and sixth defects in table v fall in this category.
in the former the file path containing alternate data stream is a feature of ntfs file system however the implementationdoes not account for it while extracting the file extension.
iii.
requiring changes in the documentation when the implementation has a stricter check while the documentation is lenient on the structural or functional constraints this follows from the fourth defect table v where the doc umentation mentions supporting phone number formatas per rfc .
however the grammar describing theformat in the rfc is relaxed as compared to the methodimplementation which has stricter checks on the number of digits appearing in the number.
we have reported these defects to the developers.
one defect had already been fixed before we reported thus validating thedefect.
we have so far received validation of four defects.
c. comparative evaluation of s egate undirected fuzz t ester to compare our technique with black box undirected fuzzing we implemented such a fuzzer using a semi randomized string generation approach.to generate meaningful strings the fuzzer derives automaton from the annotated rsfor every method in our dataset and generates test strings accepted by the automaton using depth first approach traversing random paths.
usage of r sin this approach makes the fuzzer as purely specification based.
foreach method the fuzzer generated same number of test stringsas generated by s egate .
due to the randomized nature of the undirected fuzzer we computed each result over programexecutions.
we considered defect detection as successful ifthe fault revealing string was generated in at least of executions.
results table vi gives the comparative summary of s egate and the undirected fuzzer.
column gen. denotes the status of generation of defect revealing string by the respective technique.
on a set of defects while s egate exposed defects the undirected fuzzer exposed defects.
of these16 cases for cases the undirected fuzzer generated thefault revealing string for only and of the executions respectively indicating unreliability of the technique.
on the other hand s egate uses a deterministic approach.
the undirected fuzzing technique missed the defect when the defect revealing input had one of the following properties.
i. the input does not comply with the specifications but it is still accepted by the implementation due to missing orweak validation checks in the code.
for the above case the defects could not be exposed by the generated strings that already comply with the specifications.thus considering the implementation becomes necessary.
ii.
we also observed defects in which the defect revealing string complied with the specification but it was missedby black box undirected fuzzing.
this happens due to thelarge space of compliant strings reducing the probabilityof generation of tests having the defect revealing nature.
s egate improves the probability of generation of tests revealing unhandled boundary cases by eliminating trivialtests by using the differential approach section iii b .
inour dataset we did not find any defect exposed by the undirected fuzzer which s egate was unable to expose.
for a tester it may be infeasible to evaluate a method on a large test set.
hence we picked the first test stringsgenerated by both the techniques to observe if the defectrevealing strings appear in the set.
column atin table vi denotes the position of occurrence of the defect revealing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table vi performance comparison of s egate with undirected fuzzer and evosuite in generating fault exposing inputs.
no.
bugid segate undirected fuzzer evosuite test inputs gen. at test inputs gen. at test inputs gen. .
async http client check .
async http client check check check .
async http client .
greenmail check .
guava check check .
guava check check .
guava files check check .
guava inetaddresses check .
http check check .
io check check .
io check .
io check check check .
io check check .
io check .
io check check .
lang check check .
lang check check .
libphonenumber .
libphonenumber phonenumberutil check .
net check check .
okhttp check .
okhttp check .
okhttp check check .
okhttp check check .
shiro check check .
spring uriutils check .
spring .
spring boot check check .
spring boot check check .
spring boot check check .
spring boot check .
spring boot .
spring boot jsonparser check check .
text check check check .
urlbuilder check check .
urlbuilder check .
v alidator .
v alidator .
v alidator .
v alidator inetaddressvalidator check check faults exposed indicates new defect exposed by s egate indicates defective method was not covered by evosuite string in the test set returned by the respective technique for a method.
the computed value has been averaged over positions obtained from executions for the undirected fuzzing.
using s egate for of the successfully exposed defects the defect revealing string appeared in first tests.further for of the defects the relevant test stringappeared in first tests.
this observation is attributed tothe priority given to edges denoting special characters whiletraversing the differential automaton to generate test strings.
for cases where the relevant string did not appear in top it was observed that leading strings contained other specialcharacters other than those specific to the defect in question with equal priority thus pushing the defect revealing stringto lower position.
assigning priority among special characterscould be subjective to the nature of the defect hence we leavedeveloping heuristics for so for the future.
using the undirected fuzzer of the successfully revealed defects for cases the relevant test string appeared in the first tests on an average.
further for of those cases thedefect revealing test string appeared in first tests.
for these7 cases we observed the nature of the relevant test stringwhich in all the cases required occurrence of one or morespecial characters.
the construct of the associated r sallowed occurrence of the special character s in high probability resulting in a higher chance of defect revealing string beinggenerated by undirected fuzzing.
for instance for a regex there is a high chance of the percentage appearing in a string generated by undirected fuzzing.
f eedback directed fuzz t ester randoop generates test suites using a feedback directed approach to iteratively authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table vii configuration settings used in tools.
tool parameter value evosuite dminimize false jpfsymbolic.dp choco symbolic.string dp automata satlistener gov.nasa.jpf.symbc.sequences.
symbolicsequencelistener default values have been used for parameters other than those mentioned.
build an input.
randoop uses feedback from the execution of legal method sequences to guide the search towards anew sequence resulting in new object states.
we executedrandoop .
.
ten times using the default configuration on every faulty method in our dataset.
we have set the default time limit of seconds on the execution of randoop whichis significantly higher than s egate s average execution time of .
seconds observed on the dataset.
however randoop didnot reveal any defect in our dataset.
on closely studying the generated test suites in errortest and regressiontest files we observed that most of the generated test inputs were invalidstring structures.
to obtain meaningful tests we passed a specification file to randoop describing the pre condition that the input matches the corresponding r s. however randoop appears to check the pre condition as a filter after generatingthe tests hence not resulting in any useful test input.
coverage based testing to assess coverage based techniques to test for semantic gaps we executed symbolic pathfinder spf and evosuite on our dataset.
a spf spf uses the analysis engine of java path finder jpf which is a model checking tool for java programs.
spfcombines path coverage based symbolic execution technique with model checking and it is known to have symbolic string support.
we used spf to verify the generation of teststrings exposing defects in the methods from our dataset.
tablevii gives the details of jpf configuration used in evaluation.
result for only one method spf generated a defectexposing test string bugid io .
major reasons for missingthe rest of the defects are listed as follows.
i. use of native method calls is not supported by jpf .
ii.
the path constraints are loosely defined in the method capturing a wide variety of strings.
while the solverproduces a finite set of strings for every path constraint it misses generating a string of defect exposing nature.
iii.
explicit constraints are missing from the implementation and hence are not captured by the path traversal approachused by symbolic execution.
to handle the last two cases s egate leverages the information rich specification in addition to the implementa tion.
this allows elimination of redundant tests satisfied byboth the implementation and the specification to focus on generating defect revealing strings.
b evosuite evosuite generates test suites using a search based approach which optimizes on coverage criterion.we executed evosuite .
.
on every class containing thelisting snippet with defect in a path.
documentation takes input st ring str denoting key value pairs separated by with key and value containing alphanumeric characters expected to return the substring prec eding if str .
charat i return str .
substring i returns substring succeeding defective methods from our dataset.
while configuring evosuite we disabled the test set minimizer to prevent exclusion of any code statement from analysis and used the defaultcoverage criterion that includes combination of criteria suchas line coverage branch coverage and method coverage.
dueto the randomized nature of evosuite the readings have been reported on executions of evosuite for each defective method.
we considered a defect as revealed by evosuite ifat least one of the ten executions generated a defect revealingtest string.
result of the defects in our dataset evosuite revealed defects table vi with mean coverage of .
overthe cases.
of these defects one defect bugid async http client was not revealed by s egate due to overapproximation resulting from confluence operation involvedin the dataflow analysis.
hence the coverage based technique was found to be more relevant to test for such a defect.
v. s cope and limitations we scope our technique to explore defects arising from gap in the input specification and the input accepted by the implementation.
there may be defects caused by input that complies with the specification and accepted by the implementation butmay be handled inappropriately in the implementation such asperforming an incorrect operation at a path.
consider listing4 that returns an incorrect sub string.
s egate would derive the same riandrsforstr a s w w .
hence targeting the gap between the two would not generate the relevant input.
for such issues path coverage based techniques may generatedefect exposing input.
our technique can adapt to generatingpath covering tests to expose such defects by configuring r s to empty.
for testers interested in the occurrence of particular characters in the test strings s egate also allows prioritization of user specified or source code derived special characters from listing while generating strings.
as our technique complements path coverage techniques we do not intend to take into account path coverage oriented defects where thereare no input inconsistencies with the documentation.
vi.
r elated work there has been recent focus on defects arising from difference in the code and the associated documentation.
zhouet al.
propose a technique to detect semantic defects in documentation using program comprehension and natural language processing .
the technique scopes the nature of defects tochecks on range limitation and type restriction.
it is based on the assumption that the code is correct which may not be thecase as seen in the listed defects table ii .
s egate attempts authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to detect relatively broader variety of defects that could occur either in the documentation or the code.
tan et al.
perform comment analysis to derive program rules scoped in the domain of locking protocols .these rules are used to detect inconsistencies between com ments and source code.
tcomment is another ap proach for testing code comment inconsistencies where theypropose simple heuristics to analyze free form text in javadoccomments related to method properties for null values andrelated exceptions in java libraries.
alkhalaf et al.
present an input validation technique to check input structure inferred from validation function against somegiven policies .
similar to our technique the technique usesdataflow analysis to infer the possible values of the stringin the form of a dfa.
however the approach uses intra procedural analysis unlike s egate s inter procedural analysis that additionally exploits implicit assumptions in non updatestring manipulation functions.
alkhalaf et al.
run the string analysis over validation functions hence limiting to exposing input validation defects.
semrep is a repair tool based on the proposed technique .
by analyzing statements in the entirefunction our technique goes a step ahead to expose deeperfunctionality flaws in addition to input validation.
while theapproach by alkhalaf et al.
checks compliance with certain policies we derive our own deviation policies through d .
further instead of assuming the specification to be correct we target inconsistencies between the specification and theimplementation which may result in fixing the specification.
shahbaz et al.
propose to explore defects in routines due to missing logical paths .
they use web search based approach to gather valid tests and perform mutation overregexes obtained from web searches to generate invalid tests.their approach relies on identifier names to perform websearch upon to infer structured values.
this may however not work for identifiers that heavily depend on the context of occurrence.
for instance identifier name pair may refer to credential pairs json key value pairs or any other pair.
kim et al.
present a grammar based fuzz testing called api level concolic testing act .
to improve codecoverage of black box testing act derives a fuzzing grammar from the implementation of the programs taking complex structured input strings.
their approach however overlooksthe specifications.
we follow a similar path coverage basedapproach to derive the input structure from the implementa tion in the form of a regular expression.
however our focusis on generating test strings targeting missing logical paths for which considering the specifications becomes essential.
as string manipulation could be a source of vulnerabilities in security critical programs string anal ysis has been actively researched upon in the last two decades .
christensen et al.
present a precise string analysis which statically extracts flow graph from string operations in a program to infer the structure of the derived string in the form of a context free grammar .
the technique was shownto be effective in validating syntax of standard inputs likesql queries.
however to test a client program the approachis dependent on the existence of an input validator program which may not be present in all cases.
a documentation ismore likely to be available instead.
by generating the shortestpossible counter example violating the specified grammar thistechnique limits the revelation of several potential defects forwhich a well defined string generation model may be required.
several string constraint solvers have been proposed in the past decade indicative of thewide usage and importance of string based structures in pro grams and the need to verify such programs.
however stringanalysis based testing using constraint solvers focus purelyon the paths covered in a program and ignore the absence of constraint checks in it.
our approach gives due consideration to the documentation and other sources of input specificationsto verify the consistency with the implementation.
vii.
c onclusion and future work we presented a test generation technique to expose defects in a method occurring due to input inconsistencies in themethod documentation and the implementation.
focusing onstructured string inputs we used static analysis to model input as regex and comparing with the regex model derivedfrom documentation we computed strings to expose the gap between the two models.
we evaluated our technique s imple mentation in our tool s egate which exposed defects in popular libraries.
to assess the effectiveness in exposing defects we compared s egate with some of the state of the art test generation tools.
we showed that s egate outperformed the other techniques on a dataset of defects in library methods.
we plan to optimize the regex ri generated by static analysis in addition to improving the precision of the staticanalyzer to support complex numeric manipulation on strings.
other area of optimization is in reducing the test set bydiscarding highly similar strings.
determining the criteria ofsimilarity would be of our interest .
incorporation of userdefined specification constraints when defining the criteria of similarity among inputs could be one direction.
further a search based approach to find behaviorally similar regex may be useful to fully automate regex repair or recommendation.
we would also be interested in integratingpast techniques proposed on comment analysis with s egate to assess their effectiveness in inferring the input string s properties in deriving rs.