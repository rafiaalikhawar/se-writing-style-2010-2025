general rights copyright and moral rights for the publications made accessible in the public portal are retained by the authors and or other copyright owners and it is a condition of accessing publications that users recogniz e and abide by the legal requirements associat ed with these rights.
users may download and print one copy of any publication from the public portal for the purpose of private study or researc h. you may not further distribute the material or use it for any profit making activity or commercial gai n you may freely distribute the url identifying the publication in the public portal if you believe that this document breaches copyright please contact us providing details and we will remove access to the wo rk immediately and investigate your claim.
if the document is published under a creative commons license this applies instead of the general right s. this coversheet template is made available by au library version .
december coversheet this is the accepted manuscript post print version of the article.
contentwise the accepted manuscript version is identical to the final published version but there may be differ ences in typography and layout .
how to cite this publication please cite the final published version christoffer quist adamsen anders m ller saba ali madadi and frank tip.
.
practical ajax race detection for javascript web applications.
in proceedings of the 6th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
publication metadata title practical ajax race detection for javascript web applications author s christoffer quist adamsen anders m ller saba ali madadi and frank tip journal proceedings of the 26th acm join t european software engineering conference and sympo sium on the foundations of software engineering esec fse document version accepted manuscript post print the authors .
this is the author s version of the work.
it is posted here by permission of acm for your personal use.
not for redistribution.
the definitive version was published in proceedings of the 26th acm join t european software engineering conference and sympo sium on the foundations of software engineering esec fse november .
practical ajax race detection for javascript web applications christoffer quist adamsen aarhus university quist cs.au.dkanders m ller aarhus university amoeller cs.au.dk saba alimadadi northeastern university saba northeastern.edufrank tip northeastern university f.tip northeastern.edu abstract asynchronous client server communication is a common source of errors in javascript web applications.
such errors are difficult to detect using ordinary testing because of the nondeterministic scheduling of ajax events.
existing automated event race detectors are generally too imprecise or too inefficient to be practically useful.
to address this problem we present a new approach based on a lightweight combination of dynamic analysis and controlled execution that directly targets identification of harmful ajax event races.
we experimentally demonstrate using our implementation ajaxracer that this approach is capable of automatically detecting harmful ajax event races in many websites and producing informative error messages that support diagnosis and debugging.
among widely used web pages that use ajax ajaxracer discovers harmful ajax races in of them with a total of error reports and with very few false positives.
ccs concepts software and its engineering software testing and debugging keywords event race detection javascript dynamic analysis acm reference format christoffer quist adamsen anders m ller saba alimadadi and frank tip.
.
practical ajax race detection for javascript web applications.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction millions of javascript web applications use ajax for client server communication.
ajax is today a commonly used term that describes uses of the xmlhttprequest abbreviated xhr api that all modern browsers support.
this api enables javascript programs running in browsers to send http requests to a server based on permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
user s input and receive responses that are then used to update the ui.
a prominent example is the autocomplete feature at google.com where suggestions are provided as soon as the user starts entering a search term.
to ensure a smooth user experience ajax communication is usually asynchronous meaning that a user can continue interacting with the page and that more javascript code can be executed between the time that the http request is sent and when the response is received.
additionally it is possible to perform multiple ajax interactions simultaneously.
this may cause nondeterminism when the same sequence of user events leads to different behaviors depending on the order in which the ajax responses and other events are processed.
often this leads to errors that are missed by ordinary testing when programmers are insufficiently aware of the many possible interleavings of events.
for the end user the consequences of such errors typically range from minor functionality glitches to misleading inconsistencies in the ui.
the fact that the javascript execution model is susceptible to so called event races is well known .
many techniques have been developed to detect and prevent event race errors and their harmful consequences .
however none of those existing techniques are capable of detecting harmful event race errors that involve ajax with sufficient precision and performance to be practically useful.
in particular eventracer reports too many benign races and may miss harmful ones r4 relies on stateless model checking which does not scale well and requires complex browser instrumentation and initracer only detects event races that appear during the initialization of a web application not those that involve ajax later in the execution.
the goal of our work is to provide an automated event race detector that is practical for event races that involve ajax.
specifically such a tool should be able to detect ajax event races that have observable effects without reporting a large number of spurious or harmless races.
also it should not require browser instrumentation which is platform specific and difficult to maintain as browsers evolve and it should be fast and produce informative error messages that facilitate debugging.
we present an approach that meets these requirements inspired by the ideas of adverse execution used by initracer and controlled execution used by eventracecommander .
our approach is based on the key observation that javascript developers typically test their code using networks and servers that are fast and reliable so in their tests ajax is effectively synchronous meaning that the ajax request response pairs are essentially atomic without other events occurring in between.
this observation allows us to establish a notion of expected event schedules as those where an ajaxesec fse november lake buena vista fl usa c. q. adamsen a. m ller s. alimadadi and f. tip response event handler erespexecutes immediately after the event handler ereqthat sent the request.
in contrast any schedule where another event handler eis scheduled between ereqanderespcan be regarded as less likely to be exercised during ordinary testing.
an ajax event race occurs if the effects of econflict with the effects oferesp.
the idea of adverse execution is to systematically expose a program to adverse conditions and compare the result with the normal behavior.
in our case schedules where ajax is processed synchronously define the normal expected behavior and adverse conditions are situations where the network or server is slow or unreliable allowing other events to interfere.
our approach consists of two phases.
the first phase dynamically monitors an execution of a web application with the purpose of identifying user event handlers that have conflicting ajax response event handlers and information about which event handlers may be reordered.
this initial execution may be driven by a human user an automated testing tool or a pre existing test script similarly to other dynamic race detectors.
for each user event handler uthat has been observed an event graphguis generated that captures relevant information about the events that have been triggered either directly or indirectly by u. for example clicking on a button may create a timer event that leads to an ajax request that in turn triggers an ajax response event which finally updates the ui.
the second phase uses these event graphs to plan a series of tests.
each test simulates two event schedules one where ajax is synchronous and one that simulates adverse conditions as discussed above and automatically compares screenshots of the resulting web pages.
observable differences are reported along with detailed information about the event schedules that gave rise to them.
to control the scheduling of event handlers when executing the tests we use an event controller mechanism inspired by eventracecommander in which nondeterminism is restricted by selectively postponing the execution of event handlers.
we evaluate ajaxracer using web pages from large and widely used web applications.
the results show that the approach is effective in detecting ajax races in real settings.
ajaxracer generates tests of which reveal harmful races among of the web pages and only seven reports are false positives.
we additionally demonstrate the usefulness of ajaxracer s comprehensive web based reports for understanding the detected ajax races and diagnosing their root causes.
in summary this paper makes the following contributions we define a notion of event graphs that captures relevant information about effects and orderings of event handlers relative to a given initial execution.
we present a two phased approach for automatically detecting harmful ajax event races in javascript web applications.
the first phase performs a dynamic analysis for computing event graphs the second phase executes the generated tests under different event schedules and determines if observably different results appear.
we describe the open source tool ajaxracer which implements the approach.
we present experimental results showing ajaxracer to be effective at detecting ajax races in real world web applications that it reports few false positives and that it provides insightful explanations that are helpful to developers.1function fetchjsonfromurl url callback var xhr new xmlhttprequest xhr.open get url true xhr.onreadystatechange function if xhr.readystate xmlhttprequest.done xhr.status var obj json.stringify xhr.responsetext return callback obj xhr.send null figure ajax example that demonstrates how a web application can fetch a json object from a server.
background on ajax ajax asynchronous javascript and xml is a technology that enables web applications to exchange data asynchronously with a server without imposing page reloads which enables rich and responsive client side web applications.
figure illustrates how a web application can retrieve a json object asynchronously from a server using the xmlhttprequest xhr api.1to send an xhr request a web application first needs to construct an xhr object line and initialize the object by calling theopen method with the relevant http method and url line .
the open method takes as optional arguments a boolean that specifies if the request should be asynchronous defaults to true and credentials for authentication purposes.
when the xhr object has been initialized the ajax request can be sent by calling the send method optionally with data for the body of the request line .
each xhr object goes through several phases during the lifecycle of the corresponding request.
the current state of an xhr object can be accessed at any time by reading its readystate property.
this state indicates among others if the request has been sent if the headers and status code have been received from the server or if the entire response has been received.
each time the state of an xhr object changes a so called readystatechange event is triggered.
web applications can react to these events by registering an event handler for this event type as in line .
the event handler in lines explicitly checks that the response has been fully received before it accesses the body of the ajax response in line .
xhr involves several other kinds of events in addition toreadystatechange events.
these include a load event when the resource has been loaded a timeout event if the response takes too long and an error event if for example the request is blocked by the browser s same origin policy.
to circumvent the same origin policy of xhr many websites instead implement ajax using jsonp.
to get data from a server with that approach the client code dynamically creates a script element with the url of a script which is executed when it has been retrieved from the server.
for this reason we also need to take dynamically loaded scripts into account.
we distinguish between user events mouse click events keyboard events etc.
and system events most importantly ajax 1see .
the new fetch api fetch api and websockets api websockets api provide related functionality.
in this paper we focus on xhr which is currently the most widely used ajax api but the alternatives may be interesting for future work.esec fse november lake buena vista fl usa script src js gmap helper main compiled.js script input id search value enter location zip code div id searchbar p filter your search p a onclick addremovefilter search7 ... car wash locations a a onclick addremovefilter search11 ... diesel locations a div div id stationresult div 20var curgeoobj filters 21function addremovefilter filterid togglefilter filterid stationresult .html searchlocationsnearbyjson 26function searchlocationsnearbyjson var url createurl webservices getstationsnearme.aspx curgeoobj filters .ajax url url type get success parsestationdata 31function parsestationdata data if data.status ok var htmls for var i i data.stations.length i var html ... htmls.push html stationresult .html htmls.join hr else ... figure motivating example.
response events and timer events .
after the web page has been loaded and initialized every system event is triggered either directly or indirectly by a user event.
each such system event can thus be associated uniquely with a user event we say that the system event is derived from that user event.
ajax is one of the key ingredients of modern web applications.
however it also introduces complexities in the execution of web applications.
in particular there are no guarantees regarding the exact timing and order of arrival of ajax requests at the server nor of the corresponding ajax response events at the client.
the user controls the ordering of user events but the execution of system events is to some extent nondeterministic.
borrowing terminology from concurrency in multi threaded settings a schedule fixes the nondeterministic choices relative to a given sequence of user events.
as a consequence of this nondeterminism event race errors may occur in production web applications when the order of events in the execution differs from the ones observed during testing.
motivating example figure shows a snippet of html and javascript code from www.
chevronwithtechron.com findastation.aspx .
this web page allows the user to search for gas stations in a given area and to filter these gas stations based on various criteria.
for example the user can search for gas stations that have a car wash by clicking on the car wash locations button defined in line which causes the javascript function addremovefilter in line to execute.
this function updates the set of filters that have been selected by the user line clears the contents of the html element that presentsclick car wash loc s click car wash loc s click diesel loc s xhr load filter xhr load filter xhr load filter click diesel loc s xhr load filter a correct schedules.
click car wash loc s click diesel loc s xhr load filter xhr load filter b erroneous schedules.
u u v event vis derived from event uv event uarrives before event v figure possible interleavings in the motivating example.
the list of gas stations to the user line and finally invokes the function searchlocationsnearbyjson line to retrieve the list of gas stations from the server according to the search query provided by the user lines .
by the time the server response arrives an ajax response event fires causing the event handler parsestationdata line to execute.
this function constructs a snippet of html for each gas station in the server response lines and then updates the ui using these snippets line .
the example web page exhibits an ajax event race when the user selects more than one criterion.
consider what happens when the user clicks on the car wash locations button and subsequently on the diesel locations button.
each of these click events causes an ajax request to be sent in line .
the corresponding ajax response events arrive asynchronously and without a predetermined order so either may be processed first.
if the ajax response corresponding to the click on the car wash locations button is processed first then the web page works correctly since the subsequent ajax response event corresponding to the click on the diesel locations button simply updates the ui with the gas stations that have a car wash anddiesel.
however if the ajax responses arrive in the opposite order then the ajax response event corresponding to the click on car wash locations results in an inconsistent state the filters car wash locations and diesel locations are both selected and highlighted in the ui but the list of gas stations in the ui only shows those stations that have a car wash but not necessarily diesel.
figure 3a illustrates two schedules that lead to correct behavior for the example user event sequence with the two button clicks.
for simplicity it only shows a subset of the actual events that occur.
in one schedule the ajax response event derived from the first button click occurs before the second button click and vice versa in the other schedule.
in both cases the ajax response event derived from the second button click comes last.
figure 3b shows a third schedule for the same user event sequence.
in this case the ajax response events arrive out of order which results in the error.
the event handler for the car wash locations button not only conflicts with the event handler for the diesel locations button but also conflicts with itself.
in particular it is possible to expose an error that is similar to the one described above by triggering twoesec fse november lake buena vista fl usa c. q. adamsen a. m ller s. alimadadi and f. tip simultaneous click events on the car wash locations button.
if the ajax responses arrive out of order the markers on the map are inconsistent with the selected filters.
the technique we describe in the following sections finds both these errors.
for an event race error detection technique to be practical it is not sufficient for it to detect errors and produce useful error messages it is also important that it does not report too many false positives.
predictive event race error detectors like eventracer generally report many races that are infeasible or harmless .
this is particularly problematic when web application programmers carefully use ad hoc synchronization to avoid race errors.
for this reason our technique is designed so that it only reports event race errors that can be witnessed by concrete schedules that exhibit visible differences in the browser.
the ajaxracer technique our technique comprises two phases.
phase generates event graphs that can be used to identify pairs of user events that are likely to be involved in an observable ajax event race.
phase examines for each such pair of events whether or not an observable ajax event race actually exists.
.
phase generating event graphs phase is seeded by a sequence of user events similar to other dynamic race detectors .
this sequence can be obtained by a single manual execution of the web application or using an automated crawler .ajaxracer loads the instrumented web page in the browser and waits until it has been fully initialized meaning that the html has been parsed its scripts have been executed and there are no pending system events see section for details .
it then triggers the user events in the sequence one by one in each step awaiting a quiescent state where no system events are pending until the next user event is triggered.
with such a controlled execution it is easy to determine from which user event each system event is derived and we reduce the risk of interference.
for each user event u ajaxracer generates a trace uby monitoring the execution of uand its derived system events.
a trace is a sequence of operations of the following kinds fork models the fact that an event vcreates a new system event wof kind kto be dispatched later.
for example fork means that vperforms an xhr request and wis the associated xhr load event and fork means that vsets a timer using settimeout andwis the associated timeout event.
join specifies that event wcannot occur before event v. every xhr request creates several xhr readystatechange events and an xhr load event and we use join to model the ordering constraints on those events.
mutate dom models that event vhas modified the html dom where the parameters x y w hspecify the position and size of the affected bounding box on the screen.
2as an example if we did not wait between the user events but triggered them without any delay an unfinished xhr interaction initiated by one user event might be aborted by an xhr interaction initiated by another user event.
3other effects for example involving web storage or cookies can be modeled as variants of this operation.
x y w h v1 v2 v3 v4 x y w h v5xhr readystatechange xhr readystatechange xhr readystatechange xhr load figure the event graph for a click event on the car wash locations button from section .
the click event leads to three xhr readystatechange events and an xhr load event.
compared to the notion of event actions in eventracer the key differences are that we generate one trace per user event rather than one global trace and we use a different model of memory accesses where we consider the effects of html dom write operations on the pixels on the screen instead of low level read write operations.
from each trace u ajaxracer now generates an event graph gu.
an event graph is a directed graph gu n e l where each nodev nis an event which is either uitself or an event derived from u and where the edges erepresent constraints on the event order 4each operation fork in ugives rise to a labeled edgevk w e and each operation join in ugives rise to an unlabeled edge v w e. the component lannotates each node with a set of bounding boxes according to the html dom modifications for each operation mutate dom the bounding box x y w h is included in l v .
the event graph thus describes the html dom modifications made by the user event u and all its derived system events.
we will refer to the user event u as the unique rootofgu.
example.
figure shows a simplified version of the event graph for a click event on the car wash locations button from section .
the root is the click event itself.
since the addremovefilter function clears the contents of the html element with id stationresult line the node annotation contains its bounding box x y w h .
the bottom most node represents thexhr load event whose event handler updates the same html element as indicated by the node annotation.
our approach targets a scenario in which web application programmers have tested their code using fast servers and networks and with plenty of time between each user event.
in such situations if a user event u1is followed by a user event u2 it is to be expected that all events derived from u1appear before u2and all of its derived events.
it is less likely that the programmers have encountered executions in which some of the events derived from u2appear before some of the events derived from u1.
such executions are exactly what ajaxracer aims to explore.
for that purpose we now define a suitable notion of event conflicts.
let u1andu2be user events with event graphs gu1 n1 e1 l1 andgu2 n2 e2 l2 respectively.
the two user events 4notice that the event graph captures a happens before relation in the style of petrov et al.
v wif there is a path from vtow.esec fse november lake buena vista fl usa algorithm planning ajax race tests.
foreach ui uj where i j .
.
.
ndo ifuiandujare potentially ajax conflicting then test ui uj end end u1andu2arepotentially ajax conflicting if there exists an event v1 n1and an event v2 n2such that u1andv1are separated by an ajax event meaning that gu1 has a path from u1tov1containing an edgek where the label kisxhr load orscript load and a bounding box in l v1 overlaps with one in l v2 .
the intuition of the first condition is that u1triggers an xhr request or loads an external script which subsequently leads to an event v1 and the second condition checks whether v1may interfere with events derived from u2.
we say potentially conflicting because the criterion does not guarantee that u1andu2are simultaneously enabled.
for example u1andu2may be click events on two different buttons where the button for u2is created by u1or one of its derived events.
also the event handlers may behave differently depending on the schedule due to e.g.
ad hoc synchronization.
phase described in section .
examines whether potential conflicts are realizable.
in principle some ajax race errors require more than two user events to manifest.
however in all real world cases we are aware of two user events suffice so we focus on this more common situation.
example.
as mentioned in section a car wash locations button click event not only conflicts with a diesel locations button click event but also with itself.
the event graph for a click on car wash locations as shown in figure indeed satisfies the conditions for this event to potentially ajax conflict with itself there is a path from v1tov5containing an xhr load event and the bounding box of v1overlaps with that of v5 in fact they are identical in this case .
this tells us that it may be worthwhile in phase to test a user event sequence containing two clicks on car wash locations with a schedule where the events derived from the second click appear before those derived from the first click.
.
phase testing potential conflicts from phase we have a sequence of user events u1 .
.
.
un each described by an event graph and we know for each pair of user events whether or not they are potentially ajax conflicting.
in principle ajaxracer could simply output the resulting pairs of events as warnings to the user which would be reminiscent of how predictive race detectors work .
however to avoid many false positives and produce more informative error messages phase attempts to provoke actual observable race errors similar to other techniques but using a mechanism specifically designed for ajax event races.
we perform a set of tests according to algorithm .
for each pair of user events ui uj one test is created if the two events are potentially ajax conflicting.
note that we consider all ordered pairs of user events from u1 .
.
.
un including those where i j which is relevant for the previously mentioned example involvingalgorithm executing an ajax race test.
execute uiand ujin synchronous mode 1reload the web page 2trigger ui 3wait until the events in guihave been executed 4trigger uj 5wait until the events in gujhave been executed 6s1 screenshot execute uiand ujin adverse mode 7reload the web page 8trigger ui and postpone all its derived ajax events 9trigger uj 10wait until the events in gujhave been executed 11allow the events derived from uito execute 12wait until the events in guihave been executed 13s2 screenshot decide outcome 14ifs1 s2then emit error message multiple clicks on car wash locations .
in practice relatively few of the event pairs are potentially ajax conflicting so the total number of tests performed is usually low see section .
algorithm shows how each test is performed.
lines simulate a user event sequence where uiandujare performed after the web page has been loaded using a schedule where all system events derived from uiappear before those derived from uj as if ajax communication were synchronous.
next lines simulate the same two user events but this time using an adverse schedule where the ajax events derived from uiare postponed until after all the events derived from ujhave appeared.
after each run we take a screenshot of the browser contents and an error is reported if the two screenshots are not identical line .
when attempting to trigger an event lines and the test aborts without emitting any error message if the event is not enabled because the associated dom element does not exist or is not visible.
this can happen because other events that appear in the phase execution but not in the phase executions may have changed the system state however this is rarely a problem in practice see section .
one pattern is quite common though in many web pages an html element e.g.
a menu item only becomes visible after clicking or hovering over another html element.
for this reason we allow the user of ajaxracer to group such low level events in the initial event sequence into macro events so that ajaxracer can trigger them together which increases the chance of the events being enabled.
each time the web page is reloaded lines and we wait until it is fully initialized as in phase .
waiting for derived events to be executed lines and is also implemented by waiting until the web page becomes idle.
in this way we do not risk waiting for derived events that were observed in phase but do not occur in this execution which is reminiscent of the concept of approximate replay in r4 .
postponing events line and allowing them to execute line is implemented using an approach inspired by eventracecommander .esec fse november lake buena vista fl usa c. q. adamsen a. m ller s. alimadadi and f. tip example.
continuing the example an initial user event sequence that contains a single click event uon car wash locations and a single click event von diesel locations suffices to find both errors described earlier.
one test being performed is for the event pair u v .
this test first executes ufollowed by vin synchronous mode and then in adverse mode.
the resulting screenshots are different so an error is reported.
another test is performed for the event pair u u and again an error is reported because the screenshots differ between the synchronous and the adverse schedules.
an important difference between ajaxracer and other event race detectors like eventracer r4 and wave is that ajaxracer not only explores different schedules for the system events but also user event sequences that are different from the seed execution.
this allows ajaxracer to detect errors that are missed by the other techniques.
consider for example a web page with two buttons aandb.
clicking the abutton triggers an xhr request where the xhr load event adds contents to an html element and clicking the bbutton clears the contents of the html element.
in this case a race error appears if the bbutton is clicked after the abutton is clicked but before the xhr load event occurs.
if the initial sequence of user events consists of a click on afollowed by a click on b then eventracer r4 wave and ajaxracer will all find the error.
however if the initial event sequence consists of a click on bfollowed by a click on a then eventracer r4 and wave do notfind the error because they treat user events as being happensbefore ordered but ajaxracer does find it.
as another example consider a web page with a single button cwhere clicking on ctriggers an xhr request and the xhr load event handler writes the server response data into the html dom.
a user event sequence that contains a single cclick event may cover all the javascript code but it is not enough for eventracer r4 orwave to expose the race error that occurs if cis clicked twice and the responses arrive out of order.
in contrast ajaxracer can find the error even with a single occurrence of the cclick event in the initial event sequence.
implementation ajaxracer is implemented as a command line javascript application that takes as input a url and a user event sequence to analyze and is available at .
the implementation uses a proxy server mitmproxy 5to dynamically instrument html and javascript source files as they are fetched by the browser.
the instrumentation wraps all property assignments and dom api functions that involve event handlers and modifications of the html dom so that we can intercept the relevant operations at runtime.
dynamically generated code is instrumented by wrapping the built in functions eval and function .
when the proxy is running ajaxracer uses the end to end testing framework protractor6to load the given url in google chrome via the proxy server trigger a given sequence of user events or macro events as discussed in section .
store results from the execution and optionally take a screenshot of the resulting these steps are carried out once for phase and twice for each test that has been planned in phase recall algorithm .
the screenshots that are captured for each test are compared using the lookssame library.7ajaxracer ignores a difference at a pixel x y if the adverse mode and synchronous mode executions already differed at x y when the web page finished loading.
this mechanism helps to prevent false positives in situations where a server returns slightly different html each time.
in addition to classifying the two screenshots as identical or not ajaxracer also uses thelookssame library to generate an image where the differences if any are highlighted which is useful for further debugging.
the instrumentation of the web application code allows ajaxracer to generate a trace for each user event.
it also makes it possible to determine when the web application has finished loading by waiting for the set of pending events to become empty as explained in section .
and when the web application becomes idle after a user event has been triggered and processed.
some web applications never finish loading in the sense that they continuously react to timer events e.g.
to implement a slideshow that automatically changes every few seconds .
ajaxracer deals with such situations during page loading by deleting timer events with a delay above a given threshold and by stopping a chain of timer events if the length of the chain reaches some threshold.
we have not found cases where this breaks the main functionality of the web application.
because we wait until the web application is entirely idle the user event handlers triggered by ajaxracer cannot interleave with code that has been spawned during the loading of the web application.
this helps prevent false positives from the screenshot comparison.
for example in the presence of a slideshow the screenshots taken by ajaxracer would otherwise depend on the exact timing and be unsuitable for use as an oracle.
gif animations are another source of nondeterministic results.
to combat this issue ajaxracer uses its proxy to intercept the loading of gif images and remove animations.
evaluation to assess the effectiveness of our approach we conducted three experiments to answer the following research questions rq1 effectiveness does ajaxracer report ajax event race errors in real world web applications?
how often do ajaxracer s warnings identify real errors?
rq2 race characteristics do the detected ajax races exhibit interesting patterns?
rq3 usefulness do the generated reports provide informative explanations of the causes and effects of each ajax event race?
rq4 performance isajaxracer s performance acceptable?
rq5 comparison with state of the art how effective is ajaxracer compared to other tools most importantly eventracer ?
.
experimental methodology to answer the research questions we consider randomly selected web pages from a subset of the companies from the fortune list.8we manually identified web pages that use ajax by browsing the company web sites using the chrome browser while enabling november lake buena vista fl usa table summary of results.
company tests avg.
runtime s name web page total failuresfalse positives phase phase .
amerisource bergen job openings .
apple accessibility .
buy macbook .
customize .
search jobs .
search support .
bank of america search locations .
berkshire hathaway search listings .
chevron find a station .
citigroup news .
exxon mobil job locations .
fannie mae search .
grainger home .
mckesson home .
blog archive .
event calendar .
press releases .
verizon search locations .
wells fargo home .
search total average .
.
.
.
.
the log xmlhttprequests feature and the network panel from the chrome devtools 9which makes it easy to recognize when an xhr message is being exchanged or an external script is being loaded dynamically.
we ignored requests that send analytics data.
with this approach we obtained web pages from different companies as shown in the company columns of table .
for each of the web pages we manually create a short user event sequence that exercises some of the dynamic behavior on the web page.
each user event sequence consists of two to nine user events and has been made without any knowledge of the javascript code on the web page or the client server communication.
we then carry out the following experiments on an ubuntu .
desktop machine with an intel core i7 cpu and gb ram.
experiment .
we run ajaxracer on each subject application using the given manual event sequence.
to answer rq1 we inspect the ajax event race errors that it reports and manually check whether each of them can be reproduced.
to answer rq2 we present patterns that we observe in the reported ajax races.
we answer rq3 by reporting on our experiences during this study with the asynchronous code and the generated reports.
experiment .
to answer rq4 we measure the time needed by ajaxracer s two phases.
for phase we separately report the time spent on loading the web page and on generating traces for the user events.
for phase we separately measure the time spent on test planning algorithm and test execution algorithm .
we repeat the experiments three times and report the average and worst case running times.
experiment .
we run eventracer on the subject applications using the manually created user event sequences and answer rq5 by investigating the results.
eventracer also detects races during the loading of a web page.
to estimate how many races arise from the execution of the user event sequence we analyze the results of when no user events are triggered.
we report average numbers across three runs.
regrettably we could not compare to rclassify as it was not available to us.
.
results and discussion in this section we present the results of our experiments summarized in table and elaborate on more interesting findings while addressing rq1 rq5.
.
.
effectiveness rq1 .
after phase ajaxracer created a total of tests for the web pages in table which follows from column tests .
of the tests four proved to be infeasible i.e.
one of the user events in these tests was not enabled by the time it was scheduled to be executed .
the number of test failures is reported in column failures .
each failure reveals a situation where adverse mode execution of a pair of user events leads to a state that is observably different from the corresponding synchronous mode execution.
in total tests failed.
the page from amerisource bergen produced the highest number of failing tests with failures row .
after manually inspecting the results we found that only seven of the test failures were false positives column false positives .
this is a significantly smaller false positive rate than that of existing predictive race detectors such as eventracer .
in particular each of the succeeding test cases indicates a situation where eventracer would report a race warning but where the race is not observable because ad hoc synchronization prevents the harmful effects or the two events from the race commute i.e.
the events have the same effects irrespective of their arrival order .
overall our results show that ajaxracer is capable of detecting observable ajax races in real world web applications with only few spurious warnings.
the fact that the web applications of some of the largest companies in the united states suffer from observable ajax races demonstrates that this is a widespread problem.
left undetected they may render the application in an inconsistent state as we give examples of later in this section .
as such they can frustrate end users and negatively impact their experience.
ajaxracer unveils such situations semi automatically with relatively few tests per web page.
in summary ajaxracer generated an average of eight test cases per web page of which half exposed an observable ajax race.
false positives.
as mentioned above we observed only seven spurious warnings among the failing tests.
five false positive arose for a web page from chevron row because live traffic which was changing during the execution of the tests row was being shown on a map.
ajaxracer also reported two false positives for a web page from berkshire hathaway row where the user can search for real estate listings.
one test was failing because the screenshot from synchronous mode showed results whereas the one from adverse mode showed results.
presumably a listing was removed from the website during the execution of the test.
the other false positive from berkshire hathaway was similar.
we confirmed this behavior by rerunning the tests which lead to successful executions.
if ajaxracer did not ignore pixels that were already different by the time the web page had been loaded section then additional false positives would have been reported for rows and .
generally there may be other sourcesesec fse november lake buena vista fl usa c. q. adamsen a. m ller s. alimadadi and f. tip of nondeterminism in the application s ui such as multimedia resources and third party entities e.g.
videos and advertisements .
using ajaxracer we were able to detect these inconsistencies at a glance without any need for manual analysis of the code with the help of the generated reports.
observable ajax races are neither the only type of races that exist in web applications nor did we attempt to reveal all such races within each application.
however the prevalence of observably harmful ajax races in our subject applications indicates the need for systematic analysis of race prone code.
we used ajaxracer s reports to gain further insight into the behavior of such code by manually examining successful tests.
as expected a group of tests succeeded because they lead to the same dom state regardless of the ordering of the ajax events.
more interestingly we encountered another group of successful tests that did not show symptoms of ajax races contrary to our initial assumptions e.g.
rows and .
after a thorough examination of the source code of these applications we found that the developers had deployed means of remedying the ajax races.
their strategies not only strengthened our motivation regarding the problematic nature of such races in practice but also provided insights on common practices for preventing ajax races discussed more thoroughly in section .
.
.
we also observed ajax race errors that lead to a series of uncaught exceptions row .
ajaxracer conservatively classified these errors as benign since they had no observable effects on the screen.
overall we encountered no cases where the user event sequence lead to an observable ajax race that was missed by ajaxracer .
only four tests among all were deemed infeasible during phase of ajaxracer .
these tests all belonged to the press releases web page of mckesson row .
a next button on the page was removed from the ui when the number of results did not exceed one page.
therefore a click event could not be issued on this button if an event that filters the press releases had already been triggered e.g.
an event that clicks on the november button .
.
.
race characteristics rq2 .
we observed that most of the detected ajax races fit in one of the following categories.
dataset queries.
many applications present some data from a database to the user through a list or a table e.g.
web shops .
with the overwhelming amount of information available to users many modern web applications provide means of filtering the displayed dataset based on users needs.
this is the case for the web pages in rows and of table .
however when users send multiple queries and the corresponding responses arrive asynchronously race conditions arise.
such races may cause the displayed data to be inconsistent with the user queries.
interactive maps.
many web applications display interactive maps that are used for various purposes e.g.
specifying the locations of retail stores row or available job postings row .
triggered by user queries the information overlaid on the maps is updated using ajax.
conflicts between the user events discovered by ajaxracer lead to incorrect data on the maps of these applications.
autocompletion.
autocompletion is a feature for generating textual suggestions as soon as a user starts typing in a text field.
such suggestions are often updated asynchronously which can cause ajax races that lead to incorrect recommendations.
rows and correspond to autocompletion features.
a adverse mode.
b autogenerated diff.
figure inconsistent state when customizing a macbook.
.
.
usefulness rq3 .
manual analysis of the dynamic asynchronous and event driven behavior of javascript applications is a challenging endeavor.
to assist developers with understanding ajax races and locating their root causes ajaxracer creates a comprehensive web based report as the final step.
from the report developers can view the event graphs corresponding to the user events that have been triggered during phase and see which user events are potentially ajax conflicting.
the report also allows developers to navigate the test results examine the screenshots that have been taken at different steps during the adverse and synchronous mode executions and compare the final screenshots.
example apple .on a web page from apple row users can customize a macbook before purchasing it.
when the user selects one of the available processors the ui is updated asynchronously in response to an ajax request that fetches the model s information from a web service.
ajaxracer automatically found an ajax race error on this web page.
one of the generated tests is for a user event sequence that clicks on the button for the .3ghz processor and then on the .4ghz processor button.
figure 5a shows the undesirable outcome that results from executing this scenario in adverse mode.
as it follows from the screenshot the ui showed that the price would increase by if the user selected the .4ghz processor although it was already chosen indicated by the blue border .
in the screenshot from synchronous mode a price difference was only shown for the processors that were not selected.
the total price of the model was also incorrect in adverse mode.
it reflected the price of the previously selected configuration .
rather than that of the .4ghz model.
figure 5b shows the diff image that was automatically generated by ajaxracer .
from this image it was effortless to recognize the consequences of the race which could otherwise be labor intensive.
further analysis of all the generated reports revealed that ajax event races were common in most subject applications.
we examined each report to locate and understand the underlying mechanisms that enabled the races.
example chevron .recall the motivating example from chevron discussed in section .
figure shows the two screenshots that were captured from a test that clicks twice on the car wash locations button.
the map that results from adverse mode figure 6b did not show any gas stations without a car wash although it should the car wash locations button is a toggle switch initially turned off .
when the same user event sequence was executed in synchronous mode the web application correctly showed all the gas stations in the given area regardless of whether they had a car wash. overall we found that ajaxracer s reports provided informative explanations of the causes and effects of each ajax race.esec fse november lake buena vista fl usa a synchronous mode.
b adverse mode.
figure nondeterministic search results on chevron.
.
.
performance rq4 .
the worst case execution time of ajaxracer is shown in the rightmost columns of table .
in phase on average ajaxracer spent seconds waiting for the web application to load and eight seconds executing the input user event sequence while monitoring the execution to build a trace.
in the worst case phase took seconds row .
the test planning algorithm took .
seconds in the worst case including the time required for constructing the event graphs from the traces.
in phase ajaxracer executed algorithm for each planned test.
on average this took seconds per test with seconds spent waiting for the web application to load and five seconds spent on generating the report.
the average running time of phase was approximately nine minutes when run sequentially with a worst case of minutes.
however all tests could easily be executed in parallel.
column phase depicts the worst case running time for algorithm which reflects the time phase would take if all tests were executed in parallel.
the time required for executing a test in the worst case was below three minutes row .
these results demonstrate that the overall performance of ajaxracer is acceptable for practical use.
.
.
comparison with state of the art rq5 .
when running eventracer on the subject applications we found that it reports an overwhelming number of races.
as an example we applied eventracer to the web application of berkshire hathaway row with a user event sequence that searches for real estate listings by clicking on the buttons beds and beds a subsequence of the one given to ajaxracer .
on average across three runs eventracer reported races on memory locations.
of the races were uncovered.10the reports contain no information about the effects of the races.
when no user events were triggered eventracer reported races on memory locations.
this time of the races were uncovered.
thus somewhat surprisingly the two user events caused the number of reported races to approximately double.
this shows that eventracer would still report an overwhelming number of races even if it had a mechanism for ignoring races that manifest during the loading of web pages.
inevitably the majority of these races are harmless.
even after manual investigation of the web page we were unable to detect any observable races.
we did find examples of ad hoc synchronization in the web page as described below.
10intuitively a race is uncovered if it is guaranteed that no ad hoc synchronization prevents the two events of the race from being reordered assuming the happens before relation is complete .
.
.
common development practices.
we encountered several practices in the subject applications which prevented ajax race errors from manifesting.
a simple solution is to avoid the use of ajax altogether by reloading the entire web page upon a user event.
although offering a less smooth user experience this approach was still widespread in practice.
among the applications that utilized ajax it was common practice to circumvent ajax races by disabling ui elements while waiting for a pending response.
for example many applications render a dialog showing a spinner when an ajax request is sent until the corresponding response arrives in a manner that prevents the user from interacting with the web page.
while generally offering a better user experience this approach reduces the responsiveness of the application.
another group of applications used ad hoc synchronization in a way that did not prevent the user from interacting with the page.
for example on mckesson an autocompletion feature was implemented in a way that ignored all ajax response events except the one corresponding to the last request as documented in the code 41success function data make sure it s the latest request if global counter requestcounter ... o.render container data query ... the following code from berkshire hathaway illustrates one of the more sophisticated remedies we found in terms of the logic and the quality of the user experience.
45var jqxhrs checkbox .change submit 47function submit if jqxhrs.search jqxhrs.search.abort jqxhrs.search .ajax ... 53jquery.noop function 54jquery.ajax function var xhr new xmlhttprequest var jqxhr ... abort function xhr.onreadystatechange jquery.noop xhr.abort ... when the user clicks on a button labeled beds the function submit executes lines .
this function contacts a web service and updates the search results line .
if an ajax request is already active the function cancels it by calling the function in lines from jquery .
.
.
this is done by replacing the readystatechange event handler with the empty function in line and calling the native method abort of the xhr object.
these countermeasures are helpful in their scope and prevent many ajax race errors in practice.
the mere existence of such treatments indicate that ajax races are real problems and that professional developers make an effort to prevent them.
.
threats to validity we addressed the external threats of representativeness of our subjects and generality of the investigated scenarios by testing executable sequences of events within widely used pages of large companies.
an internal threat arises from selection of pages particularly triggering ajax races as targeted in the scope of this work a subset of all potential races.
to mitigate this bias we devised 12the code has been simplified for presentation.
it originates from the scripts f345a312 25b7 6dfc8ce834fa and 91ff98c9 a847 4d7b 8bf0ef5c9697c8ba from .esec fse november lake buena vista fl usa c. q. adamsen a. m ller s. alimadadi and f. tip scenarios for analysis prior to experiment similar to exploratory testing.
inspection of races and their severity was performed manually and was thus labor intensive and prone to examiners bias and errors.
we alleviated this bias by having two of the authors carefully examining the code and the reports independently.
related work it has long been known that javascript applications may experience nondeterministic failures depending on the order in which event handlers execute.
steen observed situations where web applications that rely on settimeout to modify a page s dom representation fail in mysterious ways when browsers parse web pages too quickly or too slowly.
ide et al .
point out that these problems can be viewed as a type of race condition similar to data races in programming languages with concurrency see e.g.
.
one scenario discussed by ide et al.
involves erroneous ui updates that occur when ajax requests are processed out of order similar to scenarios we consider.
the throttling feature in google s chrome developer tools can be viewed as a poor man s race detector by simulating various network conditions situations can be identified where event race errors cause nondeterministic failures.
zheng et al .
present an approach based on static analysis for automatically detecting bugs in web applications where an asynchronous event handler writes to a global variable v and a user event handler reads v. in such cases serious errors e.g.
deleting the wrong file on a server may occur if other event handlers are interleaved that also write to v. some of the asynchronous scenarios studied in our work have similar characteristics.
petrov et al .
define a happens before relation for commonly used html and javascript features and a model of logical memory locations on which web applications operate.
these concepts form the basis of webracer a dynamic race detector.
raychev et al .
propose a notion of race coverage to eliminate false positives that are due to synchronization deliberately introduced by programmers ad hoc synchronization .
intuitively a race acovers a race b iff treating aas synchronization eliminates bas a race.
nevertheless predictive race detectors such as webracer andeventracer have been found to report an overwhelming number of races the majority of which are harmless or benign.
several projects focus on classifying event races as harmful or harmless.
mutlu et al .
apply a dataflow analysis to a trace in order to detect situations where executing racing event handlers under different schedules results in different values being written to persistent storage cookies and local and session storage .
wave and r4 explore executions that can be obtained by reordering events in a sequence of events observed in some initial execution.
these tools classify a race as harmful if reordering a pair of conflicting events results in a different dom heap state or uncaught exception.
rclassify classifies a race reported by eventracer as harmful or harmless by generating two executions in which the racing events are executed in both orders and determining if the resulting program states differ in important fields of the dom heap or environment variables.
our work differs from these existing approaches by focusing specifically on ajax races by providing detailed explanations for reported issues and by not relying on the modification of a javascript engine.initracer detects race errors that commonly arise during page initialization form input overwritten late event handler registration and access before definition errors using adverse and approximate execution.
ajaxracer follows a similar instrumentationbased implementation technique as initracer and provides similar detailed explanations.
however unlike initracer we focus on detecting ajax related races that occur after page initialization.
initracer s adverse execution works by injecting new events whereas ajaxracer instead delays ajax response events.
several projects focus on repairing event race errors.
arrow performs a static analysis to determine happens before relationships between page elements and record these in a causal graph.
races are detected by identifying inconsistencies between the causal graph and def use relationships inferred from source code order and prevented by adding causal edges that preclude undesired execution orders.
eventracecommander is an instrumentation based tool for repairing event race errors that match patterns that reflect undesirable interleavings e.g.
ajax requests that are processed out of order .
eventracecommander avoids these errors by dropping or postponing events so that no undesirable patterns can occur.
we use the same mechanism to implement adverse execution.
several projects focus on detecting event races for other programming languages including android and c c .
while these works are directly inspired by the work on detecting event races in javascript applications applications written in these languages do not rely on ajax so the techniques explored in our work do not apply there.
brutschy et al .
show how a generalization of the notion of conflict serializability can be used to detect race errors in applications that use eventually consistent data stores.
conclusion we have presented a technique for detecting ajax event race errors in javascript web applications and described its implementation ajaxracer .
our technique uses a combination of light weight dynamic analysis and controlled execution and identifies pairs of user events that are potentially ajax conflicting.
for each pair it generates a test that is expected to fail only if the corresponding ajax race has observable effects on the screen.
unlike previous techniques ajaxracer has been designed specifically to detect ajax races.
as a result ajaxracer can detect observable ajax races in real world web applications with very few false positives.
in an evaluation on widely used web pages ajaxracer detects errors in of them.
in total ajaxracer generates tests of which reveal ajax race errors and only seven are false positives.
we additionally report on the usefulness of ajaxracer s comprehensive web based reports from which it was easy to locate the root cause and effects of ajax races although we had no prior experience with the web pages.
in summary our results show that ajax race errors are commonplace in web applications and that ajaxracer is an effective tool for detecting them.