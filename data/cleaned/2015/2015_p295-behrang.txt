users beware preference inconsistencies ahead farnaz behrang college of computing georgia tech atlanta ga usa behrang gatech.edumyra b. cohen dept.
of comp.
sci.
and eng.
univ.
of nebraska lincoln lincoln ne usa myra cse.unl.edualessandro orso college of computing georgia tech atlanta ga usa orso cc.gatech.edu abstract the structure of preferences for modern highly configurable software systems has become extremely complex usually consisting of multiple layers of access that go from the user interface down to the lowest levels of the source code.
this complexity can lead to inconsistencies between layers especially during software evolution.
for example there may be preferences that users can change through the gui but that have no effect on the actual behavior of the system because the related source code is not present or has been removed going from one version to the next.
these inconsistencies may result in unexpected program behaviors which range in severity from mild annoyances to more critical security or performance problems.
to address this problem we present scic software configuration inconsistency checker a static analysis technique that can automatically detect these kinds of inconsistencies.
unlike other configuration analysis tools scic can handle software that is written in multiple programming languages and has a complex preference structure.
in an empirical evaluation that we performed on years worth of versions of both the widely used mozilla core and firefox scic was able to find real inconsistencies some determined as severe whose lifetime spanned multiple versions and whose detection required the analysis of code written in multiple languages.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms verification keywords configurable systems software evolution .
introduction many modern software systems are highly customizable providing a flexible environment for adding removing and modifying functionality.
in these systems users typically have access to hundreds or even thousands of preferences that they can modify to forman individual configuration or instance of the application.1the mechanisms for the manipulation of preferences consist of multiple layers of access.
these mechanisms can include the userinterface menu which normally gives access to only a subset of the available preferences the actual application s code which usually has complete control over the existing configurations and direct access to a persistent database often based on plain files that contains the configurations and can be directly modified.
at the user interface level some systems also provide access to a fuller set of preferences reflecting all of those within the underlying database e.g.
firefox through the about config mechanism .
in addition at the source code level preferences are often set and manipulated using more than one programming language .
this multi layered approach for specifying preferences has the potential to introduce inconsistencies between layers.
this is especially true during software evolution where modifications made in one layer might not be suitably reflected in the other layers involved.
for example a preference may be modifiable in the external user view but the corresponding source code may not be present either because it was never implemented or because it has been removed going from one version to the next.
in this scenario which was first described by rabkin users might believe that they are modifying the application s behavior yet no changes will occur.
to make things worse this could all happen silently without clearly observable failures occurring.
although some of these inconsistencies may result in nothing more than mild annoyances for the users some of them may also cause more serious security or performance problems.
consider for instance a security preference in firefox that we discovered in our empirical evaluation.
in earlier versions of firefox a user had the ability to set for how long the website passwords repository remained unlocked after the users entered their master password that is if a user had visited a website for which a password was stored in firefox s repository within nminutes from entering the master password firefox would have automatically populated the password entry without asking the user to re enter it.
this preference was removed from the code of version .
of firefox yet the option was modifiable with no effect using the about config mechanism until version .
.
users accustomed to using this setting in firefox were therefore led to falsely believe that they were adding a level of security to their browser whereas they were not.
despite a large body of recent research on testing and specifically regression testing of configurable systems most of the previous work focuses on the problem of better functional fault detection and assumes that the preference model is known e.g.
1in this paper we use the term preference to indicate a specific configuration option.
a set of preferences and the value assigned to them therefore identifies and corresponds to a configuration.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
.
some researchers have begun to extract or dynamically track configuration options from the source code e.g.
.
however most of these analyses are limited to single language programs with a flat i.e.
name value preference structure and have been evaluated on programs with a limited number of options.
therefore they cannot be straightforwardly applied to the highly configurable complex programs that we target which typically have an extremely large configuration space e.g.
firefox has about options without considering plug ins with a hierarchical i.e.
tree based preference structure system and which tend to be written in multiple languages.
to address some of the limitations of these existing approaches we propose scic software configuration inconsistency checker a technique and tool for finding configuration inconsistencies in modern complex highly configurable multi language software systems.
more precisely scic s goal is to detect inconsistencies between the way configurations are handled in different layers e.g.
user interface and code with a focus on program evolution but the technique can also be used for a single version of a program.
scic uses a custom analysis for each individual programming language and merges the results before identifying mismatches.
to assess whether a mismatch is related to changes performed during evolution scic also checks its current results against its results for prior versions of the system.
this approach allows us to plug in different analyses e.g.
for additional languages and identify the lifespan of inconsistency occurrences.
scic s analyses work both on flat and on tree based preference structures.
we have identified this latter type of structure in several modern systems including both the mozilla and the openoffice application suites.
to assess the effectiveness of scic we applied it to a year version history of the open source mozilla core modules which form the basis for the entire family of mozilla applications that is any inconsistencies within this core will propagate to all applications.
we also applied scic to the firefox versions that were released during the same time period.
in this empirical evaluation scic was able to find real inconsistencies whose lifetime spanned multiple versions and whose detection actually required the analysis of code written in multiple languages.
we found unique inconsistencies in both mozilla core and firefox and reported them to the mozilla team which acknowledged some of the issues and is currently investigating them.
in our evaluation we also classified the preferences involved in these inconsistencies and found that they are of different types ranging from performance to security and can cause non negligible issues.
the contributions of this work are a technique for extracting configuration options and finding configuration inconsistencies in evolving highly configurable multilanguage modern software systems.
the technique is able to handle systems with a hierarchical preferences structure.
an implementation of the technique that can handle complex preference structures and systems written using multiple languages i.e.
c c javascript and various markup languages .
an empirical study performed on numerous versions of a large widely used code base that shows that our technique can find real configuration inconsistencies that can have problematic consequences for users.
our experimental data is available at http .
the rest of this paper is structured as follows.
we next present some background on preference systems.
section motivates inconsistency checking.
we present our technique in section and discuss its implementation in section .
we then present our empirical evaluation in section and related work in section .
finally we conclude and discuss future work in section .
.
background most modern highly configurable applications have different levels of user interfaces uis through which users can modify application preferences.
in these applications the top level ui is typically the menu system.
however as previous studies show e.g.
for many of these applications the menu options only account for a subset of the whole preference set.
for instance these studies reported that the firefox menu provides only out of more than available preferences the versions of firefox that we analyzed have more than preferences.
other preferences that are not readily available to the users through menu options are typically accessible through an intermediate level ui.
the google chrome browser firefox and the opera browser for instance all provide a settings page that is accessible by typing about flags about config andopera config into the address bar respectively.
users can search for a particular option on the resulting page and once they find it they can modify the current value which will update the current application configuration as well as write the value to the persistent preference files.
at the lowest level the preferences are mapped to source code variables that turn on or off particular pieces of code and control the specific preference behavior.
the lowest level holds the truth for the application when it comes to system behavior but most systems do not provide a direct mapping between the ui levels and the code level.
initialization modules in the application set the preference values at application startup and store these in memory e.g.
in a hash table or some other database during runtime .
many applications also provide a dynamic api the previously mentioned about config uses this api to manipulate preferences at runtime.
these apis interact with the source code preference variables.
in order to identify mismatches between the preferences in different levels of uis and source code we first need to obtain a complete set of preferences from both the source code and the uis and then map the different levels to one another.
rabkin and katz studied seven open source java programs and concluded that using key value configuration apis is a common and widespread approach for programmers to interact with configuration options.
each configuration api takes the name of a configuration and an optional default value as its parameter.
in however jin and colleagues noted that this convention does not hold for some classes of highlyconfigurable applications such as those we target in this work.
an alternative way to handle preferences is to create a map from option names to values but these options may be grouped in a hierarchy as a tree structure.
applications that use the windows registry open source office suites such as openoffice and libreoffice and mozilla based applications are examples of systems that use this type of preference structure .
figure shows an example of a hierarchical tree structure in which related configurations share the same prefix.
at the highest level there is the browser prefix to which we can append either chrome orchromeurl .
the browser.chrome preference name can then be the prefix for either favicons orsite icons .
in a tree structured preference system the argument that is passed as a preference name to a configuration api is not necessarily the exact configuration name.
when the api interacts with the preference tree there is a possibility that such interaction occurs on branches other than at the root.
in this case the configuration name is divided into two parts the branch where the interaction occurs and the argument that is passed to the api.
to illustrate consider the code snippet in figure which we extracted from firefox version .
.
other tree structured preference systems behave in a similar way but may be implemented browser chrome favicons browser.chrome.favicons site icons browser.chrome.site icons chromeurl browser.chromeurl figure example of tree structured configuration.
define ns branch download browser.download.
... define ns pref dir dir ... nscomptr nsiprefbranch prefbranch rv prefservice getbranch ns branch download getter addrefs prefbranch ... prefbranch getcomplexvalue ns pref dir ns get iid nsifile getter addrefs customdirectory figure example of tree structure configuration in the code.
differently.
in this code the configuration api is getcomplexvalue line .
if we use the existing analyses to extract the preference from this code the first parameter would be the configuration name which is dir line .
however the correct configuration name consists of two parts browser.download line as the branch name and dir as the configuration api argument.
we need to identify and concatenate these two parts to return the correct configuration name.
this is a common way of implementing configurations because when developers want to interact read write with a group of preferences that share the same branches in the tree they can retrieve the shared branch once and use that to traverse the rest of the tree.
in the context of the code shown above preference browser.download.folderlist shares prefix browser.download with preference browser.download.dir .
in our analysis we support both flat and tree structured preference systems.
.
motiv ating example our motivating example is derived from a real bug report in the bugzilla database.
the report is for the core modules of mozilla which means that the issue with the preference code is shared across the entire family of mozilla applications and impacts more than just firefox the application mentioned by the user in this report .
in the report a user complains about preference browser.history expire sites which was intentionally removed from the source code during software evolution but still existed in the ui.
this preference can be used to limit the number of urls kept in a browser history.
the user indicated in the bug report that although he set the value of this preference to in firefox he still had more than sites in his history.
this bug was later marked by the developers as invalid since the preference having been removed did not exist anymore which triggered the following followup comment by the reporting user it s hard to guess if something is a bug or an intended change.
if this preference is no longer used it should be removed automatically just like browser.history expire days all relevant information should be updated you should make sure that users are aware of this change.
e.g.
by mentioning it in the release notes.
note that this particular issue might have impacted the privacy of users who were unaware that browser.history expire sites was no longer a valid preference and used it to limit the amount of history maintained.
we investigated the cause of this issue and found the following code segment extracted from firefox version .
file nsnavhistory.cpp where preference browser.history expire sites was introduced.
define pref browser history expire sites history expire sites ... pbi addobserver pref browser history expire sites this false ... if ns failed mprefbranch getintpref pref browser history expire sites mexpiresites mexpiresites expiration cap sites this code was removed in version .
.
before removing the code the history component itself was responsible for expiration management.
however due to drawbacks such as a lag in navigation and other performance issues a new javascript js component with an adaptive algorithm was introduced instead.
this change resulted in the replacement of three history related preferences browser.history expire days browser.history expire days min and browser.history expire sites with the single preference places.history.enabled .
when these three preferences were replaced with the new preference one would expect them to also be removed from the uis.
however whereas browser.history expire days and browser.history expire days min were correctly removed from the ui in the next release history expire sites was not.
this preference was actually removed from the ui later on in version .
of the mozilla core and no longer exists in the mozilla preference interface which shows that it was indeed an inconsistency and was recognized as such by the developers.
with thousands of preferences and multiple layers that have to be kept synchronized providing and maintaining consistency between the different levels at which preferences are accessed is not a trivial task.
during software evolution in particular new preferences might be added to a version and some old preferences might be removed.
if any inconsistency is introduced between the actual and available functional preferences this is likely to affect the users of the system or at least the ones that rely on those preferences.
to make things worse these inconsistencies are often hard to detect especially when their effect is not immediately observable which is often the case for performance or security related preferences.
the browser history inconsistency we just described is a typical example as it may not be easy to catch without specifically checking the number of entries kept in the history.
.
our technique scic figure shows an overview of scic.
for each new application version scic first performs a static analysis to extract the preferences from the source code.
this is done independently for each of the different programming languages contained in the application leftmost part of the figure .
using language dependent analyses allows us to handle different combinations of programming languages in different systems and add new language specific analyses or modify and improve individual ones based on the target application.
297external user preferences source language ... source language source language m programming language analyses merge results comparator output n pi does not exist in code but exists in user view ...
!
!!!!!!!!!!
!
version n version ... n regressions ?
outputs ..n pi does not exist in code but exists in user view ... figure overview of scic.
algorithm strategy to match preferences at different levels during software evolution.
matchingprefs highlevelprefs extracthighlevelprefs sourcecodeprefs extractsourcecodeprefs inconsistentprefs newlist pair pref version foreachversion inavailablesoftwarev ersions do foreachpref inhighlevelprefs do ifsourcecodeprefs contains pref then continue else inconsistentprefs add pair pref version end if end for end for after performing these analyses scic merges their results to form a single set of unique preferences and compares these merged results against the preferences that are available to users through higher level apis.
the ui preferences can be obtained either through static analysis our approach or using dynamic api methods that some applications provide.
scic then reports inconsistent preferences that is preferences that are not in the source code but are in the api.
finally scic compares this report with those it produced for the prior ... n versions of the system.
this last step provides the inconsistencies lifespan and allows for distinguishing new inconsistencies from inconsistencies that have already been identified.
algorithm shows scic s approach to matching preferences.
as the algorithm shows scic starts by extracting the high level preferences from the ui layer line and then extracts the preferences from the source code modules line .
on line it finds inconsistencies by checking whether each preference in the higher level ui matches a preference in the source code using regular expression matching.
if not scic reports an inconsistency.
as we just discussed scic also identifies inconsistencies from all of the available prior versions of the software lines .
the two main methods used in this algorithm are extracthighlevelprefs and extractsourcecodeprefs .
method extracthighlevelprefs extracts the ui preferences statically from the preference and configuration files.algorithm algorithm to extract configuration options.
auxiliary functions constructcallgraph returns call graph getpref c returns the preference argument from method c getbranch pref returns the branch of configuration api concatenate prefvalues branchvalues returns list of strings from joining two arguments extractsourcecodeprefs c constructcallgraph confapis newmap method argumentindex confapis identifyconfapis foreachcinconfapis do pref getpref c prefv alues findprefv alues pref branch getbranch pref branchv alues newlist branchv alue trackbranch branch branchv alues prefnames concatenate prefv alues branchv alues end for .
analysis framework algorithm describes the general analysis performed by method extractsourcecodeprefs which is called from algorithm .
this analysis builds on the work of rabkin and katz by adding to it the ability to handle tree structured preferences.
the first step of the analysis is to identify the methods that read or write preferences we call these methods configuration apis .
to achieve this the analysis first constructs the static call graph line and then identifies the configuration apis lines .
for many highly configurable systems configuration apis are used to interact with preferences.
these are either stand alone documented apis or are provided via specific classes that expose a set of methods to the rest of the program to enable interaction with configurations.
there may also be other apis that act as wrappers around explicit apis.
in order to extract all possible configurations method identifyconfapis line accounts for both types of apis.
it examines each method in the call graph and checks if any of its arguments are 298algorithm algorithm to track branches.
auxiliary functions getbranchdecl branch returns declaration of branch getbranchargument c returns branch argument in call site c add branchvalues branchvalue adds an element to list trackbranch branch branchvalues branchdecl getbranchdecl branch ifbranchdecl is an argument of method m then foreach call site cof method mdo branchargument getbranchargument c trackbranch branchargument branchv alues end for else branchv alue findbranchv alue branch branchv alues add branchv alue end if passed to a configuration api.
if so it considers that method to be a configuration api as well.
once it has collected all of the configuration apis scic proceeds as follows.
for each api it first retrieves the configuration argument which is of type string line .
on line method findprefvalues is responsible for finding the possible values of the configuration argument.
most of the configuration arguments are built as constants at compile time.
if the argument is passed explicitly as a string literal to the api the method returns the string as the value of the configuration.
otherwise it uses a points to analysis to find possible values of the configuration.
sometimes parts of the configurations are built dynamically.
for instance if the branch name is browser .contenthandlers .types .
nums .
where the value of nums is decided at runtime scic uses regular expression .
instead of nums to match any string at that point.
so far scic has found the value of the api s configuration argument.
however as shown earlier this does not necessarily mean that it has found the exact name of the configuration.
therefore scic needs to check whether the retrieved configuration name starts from the root of the tree.
if not the algorithm has to find the corresponding branch with which the configuration api interacts line .
for instance at line in the example of figure the branch for getcomplexvalue configuration api is prefbranch .
branches do not always get generated or modified at the call site of their corresponding configuration api as it happens in the example in figure .
it is possible for them to be passed as an argument as well.
method trackbrach on line which is shown in algorithm see below tracks the branch at different call sites until it finds the earliest point in the program where the branch gets generated or modified.
then the value of the branch is found on those particular call sites.
this approach allows the analysis to use context sensitivity on demand only for the relevant call sites rather than for the whole program.
after finding the possible values of the branch since scic already has the possible values of configuration arguments the algorithm calls method concatenate to find the configuration names line .
algorithm illustrates the general technique used by scic to find branches and their values.
for every branch it first finds the declaration of the branch line .
then it checks whether the declaration is an argument of its method.
if so for every call site of the method it recursively calls itself until it finds the call site where the value of the branch is generated lines .
this is the point where method findbranchvalue is called to find the value of thealgorithm strategy to find branches.
auxiliary functions getbranchdecl branch returns declaration of branch findarg m n finds nth argument of method m findbranchvalue branch defuse constructdefusechains branchdecl getbranchdecl branch ifcpp then branchisroot true uses defuse branchdecl foreachuseinuses do ifuseis an argument of getbranch then brancharg findarg getbranch values findv aluesusingpointsto brancharg branchisroot false end if end for ifbranchisroot then values null end if else if jsandbranchdecl points to getbranch then brancharg findarg getbranch values findv aluesusingpointsto brancharg else values null end if branch in the call site line .
this value is then stored in the list of possible branch values line .
the list is passed by reference to this method initially.
depending on how branches are stored and used in a preference system method findbranchvalue could be implemented differently.
in the next section we discuss how we can instantiate this method for the preference system of one family of modern highly configurable software system the mozilla family of applications.
.
example instances in this subsection we show how we can implement method findbranchvalue for mozilla based applications.
we then discuss an instantiation of the approach for analyzing markup languages.
.
.
calculating branch values for calculating branch values we first determine if the branch is at the root.
if so the branch value is null .
otherwise we have to find where branch was initiated and what are its possible values.
algorithm shows an instance of method findbranchvalue line of algorithm .
note that we want to find the possible values of a branch that is an argument of a method possibly a configuration api at a particular call site.
as we mentioned earlier mozilla based applications are written in multiple programming languages the two most used of which are c and javascript.
the preference system uses xpcom cross platform component object model interfaces in which each language provides its own apis to access these interfaces we discuss this in more detail in section .
in c branch values are passed around by method getbranch const char aprefroot nsiprefbranch retval where the first argument is the branch value and the second argument is the branch itself.
however in javascript branch access is provided by method getbranch in string aprefroot in which the argument is the branch value.
based on these two different apis we separated some parts of the strategy for c and javascript.
preferences preference id xulschoolhello message count pref name extensions.xulschoolhello.message.count type int !
more preference elements.
preferences textbox preference xulschoolhello message count pref type number figure example of how preferences are handled in xul.
first the algorithm constructs def use chains line which consist of all the uses for each definition.
on line it finds the declaration of the branch.
in the case of c we need to find the uses of the declaration and check whether the branch ever gets passed to the branch api.
if so the algorithm gets the corresponding argument and finds its value by using points to information line .
otherwise it means that the branch has not been changed and is at the root.
in case of javascript we need to know whether the result of the getbranch method ever gets assigned to the branch.
in other words we need to know if the branch declaration points to the getbranch method.
if this happens the algorithm uses point to information to find the possible values of the branch.
if not also in this case it means that the branch is at the root.
.
.
extracting configurations from markup languages in order to enable users to modify some of the preferences at the menu level developers use markup languages such as xml and xul to build the uis.
preference handling in xul is facilitated by using prefwindow which acts as a container.
it lists the preferences that are going to be used later in the code.
after being defined in the prefwindow the preferences can be associated with form elements in the window such as a text box.
figure shows an example of preference handling in xul.
lines define the preferences and lines associate a preference to a text box.
to extract the preferences from xul files our technique parses them and gathers the elements from the preference tags.
in xml documents there is a section called cdata which is marked for the parser to interpret those elements as only character data rather than markup.
preferences are handled as part of the cdata section in which the content is written in javascript.
figure shows an example of preference handling in xml where in the cdata tag a configuration api getintpref is called.
our approach for extracting preferences from xml documents is to parse the corresponding file and retrieve the content from the cdata tags.
then we use the same strategy that we used to extract preferences from javascript.
.
implementation our implementation of scic supports the family of mozillabased applications.
we chose this set of software systems because they are implemented in multiple programming languages and use a preference system based on a hierarchical tree structure neither of which has been studied before in the context of finding preference inconsistencies.
the family of mozilla based applications is built using a set of core modules which are used by all of the programs in the family.
therefore any problems within the core will affect all programs in the family.
each individual application builds on this core and has its own modules to implement its specific unique field name mmenuaccesskey !
cdata components.classes .getservice components.interfaces.nsiprefbranch .getintpref ui.key.menuaccesskey field figure example of preference handling in xml.
functionality.
these applications include the firefox web browser are actively developed and maintained and are widely used.
in alone for instance firefox had eight major releases.
given the wide user base of these applications it is clearly important to make sure that preferences are suitably maintained and consistent.
as we mentioned above mozilla applications are written in multiple programming languages that include c c javascript java python and some markup languages such as xml xul and xhtml .
to expose its preference system mozilla uses xpcom interfaces where xpcom is a cross platform component object model that has multiple language bindings.
these language bindings act as a bridge between xpcom and different languages by providing access to xpcom objects in each language.
in addition languages for which there are xpcom bindings can use modules that are written in other languages as xpcom objects.
therefore xpcom components can be used and implemented in javascript java and python in addition to c .
interfaces in xpcom are defined in xpidl which is an interface description language .
two commonly used interfaces in the mozilla preference system arensiprefservice andnsiprefbranch .nsiprefservice is the preference system that is the main entry point to the management of preference files.
it provides access to the preference branch object through methods such as getbranch prefroot which allows the direct manipulation of preferences .
nsiprefbranch can be obtained either directly or from the nsiprefservice .nsiprefbranch is created with a root value which describes the base point in the preference tree from which this branch stems.
preferences can be accessed starting from this root by simply using the final portion of the preference.
if nsiprefbranch is created with the root browser.startup.
for instance preferences browser.startup.page browser.startup.homepage and browser.startup.homepage override can be accessed by simply passing page homepage orhomepage override to configuration apis.
to enable manipulation of preference data nsiprefbranch provides two set of methods one set for reading the preference value such as gettypepref orgetcomplexvalue and another set for writing its value such as settypepref or setcomplexvalue .
in both cases type should be replaced by one of the three types int char orbool .
each language implements its own interfaces to interact with these configuration apis.
to implement the analysis for the c side of applications we used the llvm compiler infrastructure and clang .
we used them to generate the call graph and points to information as well as the data flow information in algorithm .
as mentioned earlier c implements its own interface to interact with xpcom objects in the preference system.
instead of gettypepref orgetcomplexvalue configuration apis it uses gettypepref orgetcomplexvalue with different arguments.
to implement the analysis for the javascript side of the applications we used the wala framework to generate the call graph and points to information.
however the recent versions of mozilla follows the ecmascript standard which is not supported by most javascript analysis frameworks.
therefore we used traceur a compiler that takes ecmascript and compiles it frequency versions removed inconsistency inconsistency figure number of source ui inconsistencies appearing for the first time in each version.
down to regular ecmascript javascript to generate source code that the current analysis framework is able to parse.
using this approach we were able to analyze most of the files in the codebase we considered in our experiments.
for about of the code however we had to perform part of the analysis manually.
to analyze the xul files we used an xul parser written in python and provided by the mozilla developers .
it parses xul and builds a list of all the xul elements and their attributes from which we extracted preference elements.
for xml we used sax simple api for xml a java based parser.
after parsing we analyzed the content from the cdata section written in javascript .
.
empirical ev aluation to evaluate how effective and useful is scic in detecting preference inconsistencies we performed an empirical evaluation and investigated three research questions.
the first question assesses whether scic can correctly identify inconsistencies that exist in an application.
the second question focuses on the second part of our analysis which is to understand how prevalent inconsistencies are and how long they persist in the history of a system.
the last question focuses on the categories of inconsistencies found by scic to understand if they are actually problematic and relevant for the users of the applications being analyzed.
more specifically we investigated the following three questions .rq1 how accurate is scic in identifying inconsistencies?
.rq2 what is the lifespan of inconsistent configuration options?
.rq3 to what classes do the inconsistent preferences belong?
are these inconsistencies potentially harmful?
.
evaluation method we selected a year period from february to december of the mozilla core modules which are shared between most of the mozilla applications such as firefox bugzilla thunderbird and seamonkey.
we also examined all firefox versions million lines of code on average from the same time period as this is one of the largest applications in the mozilla family.
this corresponds to major releases of firefox from version .
to version .
.
since the core modules are also used within firefox and the release schedules for these two may be different we used the firefox versions as our baseline for evolution and studied the versions of the core modules that corresponded to those versions of firefox.
this allowed us to examine and differentiate inconsistencies across the two sets of modules using a single timeline.
wetable number of inconsistencies.
modules source ui inconsistencyprogramming languages cpp js markup core firefox total percent compared our analysis result against the configuration options that are exposed through about config .
if there was any preference in about config in a particular version that did not exist in the source code of the same version we marked that as an inconsistency.
for each version of each application we ran scic and identified both the new inconsistencies and those which persisted from earlier versions.
for each of the inconsistencies found we confirmed that the source code was missing through manual examination.
.
rq1 finding inconsistencies accurately across the major releases that we studied we found inconsistent preferences.
table provides some statistics about these preferences.
the first column lists the modules that we studied and shows the totals for both applications.
the next column sourceui inconsistency shows the number of inconsistencies found in each module between the source code and the about config list.
the next group of columns shows the distribution across different programming languages.
as table shows of the preferences belong to the core modules and to the firefox modules.
although firefox also uses the mozilla core modules the inconsistencies reported for firefox are in addition to those found in the shared modules which affect any mozilla based application including firefox seamonkey and thunderbird .
the table also shows that of the inconsistencies exist in c code most of which are in the core modules.
the remaining is shared between javascript and markup languages such as xml and xul .
our manual check for false positives found none so to the best of our knowledge scic correctly identified the inconsistent preferences.
although we do not have a complete list of preference inconsistencies in the analyzed code and therefore we cannot as3010 frequency versions figure number of source ui inconsistencies in each version.
sess the recall of scic we can nevertheless provide some initial promising evidence all the inconsistencies reported by users i.e.
all the inconsistencies described in bug reports for the mozilla core modules and firefox were detected by scic.
we can therefore conclude that at least for the known inconsistencies in the analyzed code scic produced no false negatives.
summary of rq1.
scic was able to accurately identify inconsistencies distributed between the core modules and firefox.
the inconsistencies involve multiple programming languages which indicates that single language analyses would not be able to detect them.
.
rq2 life span of inconsistent configurations since we studied the evolution of mozilla based applications for major releases during years we also wanted to identify when the inconsistencies happened how long they existed and when they got removed if ever .
this data provides information on the potential impact and difficulty of detection of these inconsistencies.
we therefore studied the lifespan of each inconsistency detected by scic.
figure shows how many inconsistencies appeared for the first time in each version.
versions without inconsistencies are not shown.
of the versions that we studied did not have any new inconsistencies.
inconsistencies appeared for the first time in versions where they were individual instances.
in one version version inconsistencies newly appeared.
interestingly the largest portion of inconsistencies happened in two versions versions and each newly introducing about half of these inconsistencies.
the inconsistency that appeared in version for the first time has never been defined in the source code of major releases neither in version nor in the previous or later versions.
we only analyzed major releases so it might exist in some beta versions.
this was an interesting case so we searched for any history related to this preference.
we found a bug report from where there was a discussion about introducing this preference.
in the comments the name toolkit.asyncshutdown.timeout.crash was initially chosen for the preference.
however someone later suggested to use toolkit.asyncshutdown.crash timeout instead.
developers therefore changed the name in the source code whereas the name in the intermediate ui was never changed.
in fact it still exists in the latest version we studied.
figure shows how many inconsistencies exist in each version and how many of them were removed from each version.
there areonly two versions where the inconsistencies were removed.
two of the removals occur in version and one in version which was our motivating example .
the number of remaining inconsistencies in version the last version we studied is instead of because of the removed inconsistencies.
summary of rq2.
our evaluation shows that the lifespan of inconsistencies can be long.
very few only of the inconsistencies that we found were removed.
.
rq3 type and relevance of inconsistent preferences we identified several classes of inconsistent preferences.
table lists these classes their description and the number of inconsistent preferences that belong to each of the classes.
in total there are classes and an additional class others which contains those preferences that do not belong to any of the other classes.
class performance is the largest one with six preferences.
these are preferences that help users do tasks more efficiently.
for example preference layout.frame rate.precise provides smoother scrolling for the users and preference application.use ns plugin finder enables the automatic plugin finder if a plugin is not found.
class profile is the next largest one with five preferences.
browsers store user personal data such as history bookmarks and extensions in a profile and a user can have multiple profiles.
profilerelated preferences allows customization of such profiles.
for example preference profile.confirm automigration enables migration of other browser bookmarks when creating a new profile and preference profile.seconds until defunct allows for specifying after how long an unused profile should be removed.
classes accessibility user interface and security have four preferences each.
accessibility preferences provide services for people with disabilities.
preferences accessibility.usebrailledisplay and accessibility.usetexttospeech for instance are designed to accommodate alternate devices with enhanced accessibility features.
user interface preferences enable customization of the user interface.
preference browser.chrome.toolbar style for instance determines how the navigation toolbar buttons e.g.
back forward reload are displayed either as text or icon.
security preferences are related to security features and we discuss them in more detail later in this section.
classes dom andprinter contain three inconsistent preferences each.
the former relates to the manipulation of the document object model e.g.
dom.workers.maxperdomain which specifies the maximum number of workers whereas the latter is used to customize printing settings e.g.
print.print extra margin which al302table classification of inconsistent preferences.
class namedescription frequency accessibility provide services for people with disabilities dom related to document object model dom which is a programming interface encoding allows different character encoding history related to browser history network related to networking performance enables users to perform tasks faster printer enables users to configure printer profile allows customization of browser profiles security provides secure way of tasks user interface related to users interaction with interface others anything that does not fit into any of the above classes lows for specifying an extra gap or margin around the content of the page .
classes history andencoding contain two inconsistent preferences each.
history related preferences are used to customize the browser history settings whereas class encoding refers to character encoding.
finally there is only one inconsistent preference of class network whereas we put all remaining inconsistent preferences in class others .
some examples from this class are browser.eula.version which specifies the version of end user license agreement that has been viewed and accepted by the user and capability.policy.default.soapcall.invokeverifysourceheader which permits users to make verified soap simple object access protocol calls by default.
among the above classes the security related preferences seem to be particularly important as they might affect the overall security of the system.
we therefore discuss the four inconsistent preferences in this class in greater detail.
security.checkloaduri forbids external sites to link to files that are stored locally and security.xpconnect.plugin.unrestricted allows plugins to access xpcom methods that would normally be unaccessible.
when modifying these preferences in the ui users would assume that they operate as expected which they do not and would therefore use the browser under wrong security assumptions.
preferences security.ask for password andsecurity.password lifetime define whether the browser should ask to remember passwords when logging into a web page and for how long.
in this case we found both a bug report and a complaint in which users were considerably annoyed by the fact that these preferences did not work as expected.
other inconsistencies although not related to security may create issues too.
inconsistencies in the printer category may result in annoyances for the user for instance and those in the history category may impact privacy.
to provide an example consider preference browser.history.grouping which defines how to group history urls which scic identified as inconsistent and for which we found a bug report complaining about it .
summary of rq3.
we found distinct classes of inconsistencies in the applications studied.
although we do not have strong evidence that all classes are harmful we found several examples of issues that are clearly problematic.
in particular security related preferences when inconsistent are likely to provide a false sense of security to users who may use the browser in a way that makes them more vulnerable to attacks.
.
lessons learned we now summarize the key lessons learned for this evaluation.
inconsistencies do exist and we should test for them.
when we started this work we were not sure of whether we could find realinconsistencies and whether they would be relevant.
based on our initial results we believe that inconsistent preferences exist and are potentially problematic for the users.
multi language analysis is needed.
we found inconsistencies that involved different parts of the system written in different languages.
this means that an inconsistency analysis could not be performed without using a multi language approach.
individual analyses and merging their results seems to be a promising approach.
an alternative approach to scic is to build a single analysis that works across multiple languages at once.
the approach we have used to merge individual analysis results is considerably simpler and seems to be effective in this context.
as a user do not trust preferences.
it appears that the layered approach for setting and using preferences can lead to inconsistencies so users should not trust preference settings without making sure that they behave as expected at least for the critical ones .
.
reporting our findings to developers we submitted a bug report about the inconsistencies that we found to the mozilla developers who told us that some features were indeed left in the ui due to negligence whereas others were left because in use in other applications of the mozilla family and having only one version of the ui was convenient .
however they recognized that some users found this to be annoying and that such issues should be further investigated and fixed .
.
threats to validity the primary threat to external validity of this work concerns whether or not our results will generalize.
to mitigate this threat we used the core modules from a large family of applications as well as one of the most widely used applications in this family.
although we need to perform more studies on different systems before being able to claim that our approach works in general considering the body of related work e.g.
we believe that our results can generalize to other families of application that have a tree structured preference system and are multi lingual e.g.
the openoffice applications industrial systems and other applications that rely on the windows registry .
in future work we plan to instantiate our approach for these systems as we did for the applications that we targeted in this paper.
to address possible threats to internal validity we manually evaluated the inconsistencies found by scic and did not find any problem with the results.
although this is not a guarantee of correctness it excludes the presence of obvious issues with our implementation of scic.
finally with respect to construct validity we might have used different metrics to answer our research questions which is true 303for every empirical study.
however we believe that the ones we chose are appropriate for the questions that we were investigating.
.
related work there has been a large body of research on testing of highly configurable systems as well as on extracting feature models configurations and constraints from both source code and intermediate representations e.g.
kconfig for linux .
this line of research uses only a single view of the configuration space and does not measure inconsistencies between code and other representations.
in prior work we used a model of the firefox configuration space to perform failure avoidance .
however we used only the about config information to build the model.
interestingly upon examining that model retrospectively we have found multiple instances of preferences that scic identified as inconsistent.
in fact we discovered that in that work we might have been manipulating preferences that had no associated code and no behavioral impact.
we focus the rest of the discussion on the work that is most closely related to scic that is work on identifying mismatches between source code and other components of the software and on diagnosis and debugging of configuration errors.
.
identifying mismatches most of the work on identifying mismatches between source code and other components of software focuses on documentation.
rubio gonz lez and liblit examined mismatches between documented and actual error codes returned by system calls.
tan and colleagues presented a technique that detects inconsistencies between comments and source code to identify both bugs and low quality comments.
the closest work to scic is that of rabkin and katz .
their approach statically extracts the list of configuration options from source code and compares those options with those listed in the documentation.
although our analysis is inspired by their work we are looking into a different type of preference systems that is those that have a hierarchical tree structure which requires a more complex analysis.
in addition we focus on the user interface preference system rather than on the documentation.
furthermore the systems we are studying are written in multiple programming languages and are highly configurable.
their work conversely was limited to java programs with a relatively low total number of configurations less than across seven programs in their evaluation.
for comparison each version of the mozilla based applications we studied have more than configurations.
finally we studied the application along a long history or versions years rather than focusing on individual versions which adds a longitudinal dimension to the analysis.
.
error diagnosis and debugging there has also been a good deal of research on configuration error diagnosis and debugging much of which has been empirical in nature.
jin and colleagues studied several highly configurable software systems to identify the challenges that configurability adds to testing and debugging .
in follow up work they built a system for helping identify preferences at the user interface level .
yin and colleagues conducted an empirical study on configuration errors in commercial and open source systems.
rabkin and katz defined a technique that precompute program points where there is a possibility that some configurations cause an error at those points to aid debugging.
zhang and ernst proposed a technique for identifying the root cause of crashing and non crashing configuration errors.
they also proposed a technique for debugging configuration errors thatare caused by software evolution .
however these approaches require some form of user traces and are limited to a single programming language.
attariyan and flinn proposed several techniques to diagnose and troubleshoot configuration faults while keller and colleagues presented a tool for assessing resilience of software systems to human configuration errors.
finally wang and colleagues presented a technique for diagnosing the root cause of misconfiguration.
scic differs from these techniques in its primary goal which is to find inconsistencies between source code and high level user interface preferences with particular emphasis on those introduced during evolution .
scic does not need to identify changed behavior ahead of time and can handle systems written in multiple programming languages and using complex hierarchical preference structures.
the inconsistencies that scic finds may be eventually classified as configuration errors that affect the usability of the software systems but they may also point to preferences that simply need to be removed from the interface.
.
conclusions and future work in this paper we presented scic our static analysis based software configuration inconsistency checker.
scic can identify preference inconsistencies on highly configurable complex applications.
scic can handle applications that are written in multiple programming languages and that use complex e.g.
tree structured configuration systems which are both common characteristics in modern software e.g.
mozilla applications open source office suites and applications that use the windows registry .
we have empirically evaluated scic on years of releases of the core modules from the mozilla family as well as on the releases of the firefox application that appeared during the same timeframe.
scic was able to find inconsistencies across these versions and both within the core modules and in application specific code.
the inconsistencies found were not isolated to a single language but rather involved code written in c javascript and various markup languages e.g.
xul and xml .
in addition their lifetime spanned multiple versions.
we were able to classify the inconsistencies found by scic into ten categories where each category contains from one to six preference inconsistencies and whose potential severity varies from mild annoyances to more serious security or performance problems.
we also found postings in various forums with user complaints and bug reports that are related to some of the inconsistencies that scic found.
finally the mozilla developers confirmed some of the issues we reported to them which are currently being investigated.
these reports complaints and confirmations provide clear evidence that at least some of these inconsistencies are perceived as problematic and harmful by the users and are thus worth discovering.
in future work we plan to extend scic to additional applications including the libreoffice application family.
we also intend to package and release scic as a tool that can be readily used and provides a way to plug in new individual analyses into the framework e.g.
to add analysis for new languages .
finally we will investigate techniques for either automatically repairing the inconsistencies found by our approach or at least modify the codebase so that users are warned when trying to use an inconsistent preference.
.