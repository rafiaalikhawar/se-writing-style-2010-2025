on the fly decomposition of specifications in software model checking sven apel1 dirk beyer2 vitaly mordan3 vadim mutilin3 and andreas stahlbauer1 1university of passau germany2lmu munich germany3isp ras russia abstract major breakthroughs have increased the e ciency and e ectiveness of software model checking considerably such that this technology is now applicable to industrial scale software.
however verifying the full formal speci cation of a software system is still considered too complex and in practice sets of properties are veri ed one by one in isolation.
we propose an approach that takes the full formal speci cation as input and rst tries to verify all properties simultaneously in one run of the veri er.
our veri cation algorithm monitors itself and detects situations for which the full set of properties is too complex.
in such cases we perform an automatic decomposition of the full set of properties into smaller sets and continue the veri cation seamlessly.
to avoid state space explosion for large sets of properties we introduce on they property weaving properties get weaved into the program s transition system on the y during the analysis which properties to weave and verify is determined dynamically during the veri cation process.
we perform an extensive evaluation based on veri cation tasks that were derived from linux kernel modules and a set of properties that de ne the correct usage of the linux api.
checking several properties simultaneously can lead to a signi cant performance gain due to the fact that abstract models share many parts among di erent properties.
ccs concepts software and its engineering formal software veri cation keywords software model checking program analysis multi property veri cation speci cation formal methods decomposition1.
introduction software model checking is an automatic exhaustive and precise approach for veri cation.
a software model checker takes a program and a formal speci cation as input constructs an abstract model of the program to verify whether the program adheres to the speci cation and provides the veri cation result true orfalse ideally accompanied by a witness .
the challenge in model checking is to represent huge state spaces by sound and complete approximations that avoid the state space explosion problem.
abstraction is crucial to construct an abstract state space of tractable size the abstraction precision de nes the level of abstraction.
the model of a program has to be abstract enough to allow for an e cient veri cation process and precise enough to be able to prove or refute that the speci cation is satis ed .
the complexity of the model and the resources required for computing an abstraction increase with the complexity of the speci cation to verify.
the formal speci cation of a software system is typically described by dozens or hundreds of properties.
for example given a linux kernel module there is a set of api usage rules that the module must ful ll each of these rules is a safety property.
de ning each property in isolation respects the principle of separation of concerns and ensures maintainability and comprehensibility of the formal speci cation.
due to the size and structure of an elaborate software system such as the linux kernel it is state of the art to decompose the speci cation before the veri er starts and to verify each part property of the speci cation in isolation in a new instance of the veri cation tool.
verifying many properties simultaneously can exhaust computing resources in particular due to state space explosion expensive solver queries and complex abstraction computations.
thus small sets of properties are preferred to reduce the complexity of the abstract model a lower precision is su cient .
several signi cant improvements in the last years most prominently the performance breakthrough of smt solving make us believe it is time to address the challenge of verifying large sets of properties at once.
verifying a set of properties in one run has major advantages over the state of the art approach especially in industrial practice the program is parsed only once invariants can be reused across di erent properties and the overall number of expensive satis ability checks can be reduced.
we developed a set of techniques as a foundation for verifying many properties simultaneously in one run of a software model checker including on they property weaving and dynamic speci cation decomposition.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
artifact evaluated by fse 349speci cation automata.
a required property1is usually represented by a monitor automaton .
generally there are two alternative methods to verify a property for a program with software model checking a the monitor automaton is weaved into the source code of the program and thus reduced to the reachability of a certain program location and b the monitor automaton runs in parallel and the current state of the automaton is represented separately with an abstract domain over the automaton states .
method a is easy to implement in a pre processing step for example by an aspect weaver but has the drawback that the source code is changed blown up considerably and traceability is more di cult to ensure.
if applied to a multiproperty setup instrumenting all properties of a speci cation into the program code introduces a lot of noise in the program especially in cases where only a subset of the properties is veri ed this adds another burden to the abstractionre nement procedure makes calls to the smt solver more expensive and makes the program comprehension task for the veri cation engineer harder.
method b is conceptually much more elegant but has the following drawback because each property is equivalent to an automaton that is each property has an own state space which needs to be tracked in addition to the current state in the program exploration and the combination of the properties can be seen as a product construction there is a new kind of state space explosion a huge number of di erent states in the speci cation.
both methods have advantages that seem mutually exclusive method a allows us to encode the speci cation state space into the program s control ow and thus bene t from the same symbolic representation as in the program state space.
it helps to avoid an explicit representation of the automaton states of the resulting product speci cation.
method b allows us to integrate the concept of abstraction precisions which makes it possible to enable and disable properties on the y. we can view the process of reducing the number of properties as abstraction and the process of adding properties as re nement of the abstract state space.
on the fly property weaving.
we have solved the above dilemma by designing the loom analysis which is a exible and con gurable analysis preventing state space explosion that arises from the speci cation.
this analysis weaves only those properties on they into the program s transition system that are to be veri ed and allows us to use the concept of dynamic precision adjustment to dynamically enable and disable properties during the veri cation process.
while we would like to leverage reuse between properties abstract models for di erent properties often overlap we sometimes have to reduce the number of simultaneously veri ed properties to keep the complexity of the abstract model to construct manageable.
dynamic speci cation decomposition.
our goal is to automatically decompose large sets of properties into smaller sets instead of requiring the decomposition from the verication engineer.
a multi property model checker takes a set of properties the speci cation as input and provides a separate result for each property as output.
the veri er automatically decides which properties to verify in combination 1we focus on safety properties that de ne the correct usage of an operating system api .
in our experiments we verify properties of linux kernel modules due to their opensource availability and their well understood requirements.table simultaneous veri cation of di erent sets of properties of a linux kernel module for a network device verifying all properties simultaneously runs into a timeout .
hours property 132a 134a 43a 68a 68b analysis speedup total speedup analysis cpu time s total cpu time s loop unrollings re nements or individually.
the goal is to decompose the speci cation such that the overall e ectiveness and e ciency of the veri cation process is improved.
we developed a technique that allows us to dynamically on demand and on they adjust the speci cation by switching on and o individual properties using the concept of dynamic precision adjustment .
to determine when and where to decompose our analysis algorithm monitors itself to detect situations in which the abstract model for a certain set of properties becomes too complex to be e ciently constructed.
the approach requires heuristic estimates for choosing a promising decomposition alternative.
to discuss this aspect in more detail we show results of verifying a linux kernel module in table with all possible decompositions of a set of properties.
the module provides access to a family of siemens gigaset devices.2we chose this module for discussion because it is one of the most challenging for nding a good decomposition which is a central problem to be solved we obtain signi cant speedups for other kernel modules as well see fig.
.
the analysis cpu time only includes the time for model checking model construction re nement based on infeasible error paths the cpu time for parsing the input program constructing the 350controlow graph and other preparation and initialization steps is included in the total cpu time.
verifying all ve properties simultaneously is not possible because we run into a timeout last row of table .
if we choose a decomposition where property 132a is veri ed in isolation and the other four properties simultaneously we spend a total analysis time of s s s. the decompositionff134a 68a 68bg f132ag f43aggneeds an analysis cpu time of s s s s. admittedly this is not a too big speedup compared to s for verifying each property separately the overall cost is dominated by the one hard property 132a.
the potential speedup of verifying several properties simultaneously depends on the program and on the properties.
some program parts require a high precision for verifying several properties whereas the precision can be coarse for other parts because they are not relevant for any property .
di erent properties have di erent scopes and thus could bene t from intermediate veri cation results that are available in the scope from other properties.
overlapping scopes of properties can also have a negative impact on the verication performance the state space might in some cases explode for those regions.
our approach tries to detect such situations early and verify certain properties in isolation.
related work.
we classify the related work into approaches related to multi property veri cation and approaches related to speci cation automata and speci cation weaving.
multi property veri cation.
checking properties individually has already been identi ed to be impractical in the context of hardware veri cation .
some of the discussed problems and ideas are applicable to verifying software grouping properties according to their potential of reuse of intermediate results reuse of learned facts and projection of constraints and reachable states between properties based on a cone of in uence analysis.
the tool varvel which uses abstract interpretation and bounded model checking has been used for verifying several properties of software it is applied function wise and does not perform a whole program analysis function contracts can be used to reason about whole programs .
multi aspect veri cation is the work closest to our approach it was inspired by the positive e ects of precision reuse and led to our new concepts and experiments.
the idea is to use the ldv toolkit to produce for a given program source code and a set of properties a source code that is instrumented with the given properties.
the model checker cpachecker is repeatedly queried to verify such instrumented programs.
the potential of reuse for similar queries was explored in the area of sat solving .
large sets of test goals are considered in the context of dynamic test generation or in dynamic analysis .
in general test generation can bene t from reusing parts of abstract reachability graphs .
also regression veri cation can bene t from the reuse of abstract reachability graphs or of abstraction precisions to reduce the veri cation e ort over several veri cation runs.
our work complements the existing approaches by automatic speci cation decomposition with self monitoring for the case that the full speci cation is too complex an implementation using unbounded software model checking verifying full programs as a whole and by avoiding pre processing combine or weave of properties.
we conduct an extensive study on the e ects and speci cs of verifying several properties in one run of a software model checker.speci cation weaving and automata.
in the past two decades several languages for expressing formal software speci cations have been proposed .
our speci cation language is inspired by the blast query language .
every safety property can be reduced to the reachability of an error label a new version of the program where the speci cation is part of the program code is generated in a pre processing step and a veri er checks then whether an error label that represents a violating program location is reachable.
aspect oriented programming is one way of instrumenting a program with its speci cation .
in the spirit of con gurable software veri cation it is desirable to integrate the speci cation automaton as a con gurable program analysis that runs simultaneously with the main analysis on they product construction of program and speci cation .
our specication automata can encode several properties similar to supermonitors .
our speci cation analysis uses dynamic precision adjustment to enable or disable certain properties on demand.
a work that is closely related to our approach for on they weaving can be found in the context of performance monitoring .
code instrumentation is added or removed dynamically at any point during the program execution the main goal of that work is to collect performance data.
our loom analysis applies the idea of dynamic instrumentation to static analysis that is at veri cation time without changing the actual program.
contributions.
we summarize our results as follows we propose a fully integrated approach for verifying sets of properties in one run of a software model checker.
we developed the loom cpa a technique that makes the simultaneous veri cation of large sets of properties e cient by weaving properties on they into the program.
we developed a con gurable algorithm that dynamically decomposes a set of properties into smaller sets whenever self monitoring detects that the veri cation task is too complex for the current set of properties.
we perform an extensive experimental evaluation of our approach to illustrate how an on they speci cation decomposition can increase both the e ciency and the e ectiveness of the overall veri cation process.
our benchmark suite comprises linux kernel modules.
we provide a replication package3that contains all data and a detailed description for reproducing our experiments.
our implementation is based on the open source softwareveri cation framework cpachecker the source code is available under the apache license.
.
preliminaries before we introduce our new approach and the corresponding techniques we start with some preliminary de nitions.
control flow automata.
we represent a program ascontrolow automaton cfa which is a tuple pl l0 gq consisting of a set lof program locations the entry locationl0pl and a set g l ops lof controlow edges an operation in ops represents an assignment operation or an assume operation in the programming language and if available its abstract syntax tree the subset r ops represents all assume operations boolean expressions the subsets opszrrepresents all assignment operations.
for a setm we writem for the set of all words over m 351and for the word of length zero.
the concatenation of two wordsw1andw2is written as w1 w2.
properties and partitions.
the set p tp1 pnuconsists of all properties of a program that are to be veri ed.
apartitioning p 2xof a setxis a set of non empty sets where all elements p1 p2pp withp1 p2 are pairwise disjoint p1xp2 h andx pppp.
con gurable program analysis.
our work builds on the concept of con gurable software veri cation with dynamic precision adjustment .
cpas of the form d pd merge stop prec targetqare the central building blocks of this formalism.
the fulledged program analysis is composed of several component cpa to form a composite analysis .
the abstract domain d pc e rr ssq with the semi lattice e pz jqde nes the type of abstract representation of concrete states from c wherecis the set of all concrete states of the program one abstract state epz represents a set of concrete states region which can be obtained by the concretization function rress c. a precision p de nes certain aspects of the state space that should be represented by abstract states in a given abstract domain.
the transfer relation de nes for each abstract state a set of successor abstract states.
the operator merge can combine two abstract states such that both abstract states are subsumed by the resulting abstract state given an abstract state e and a set r zof abstract states the coverage check operator stop returns true iferepresents only concrete states that are already represented in r that is rress e1prrre1ss and returns false otherwise.
given an abstract state e a precision and a set r z the precision adjustment operator preccan provide a new abstract state e1 with an adjusted precision .
the operator target z b returns true if a given abstract state is the goal of the reachability analysis that is if the abstract state violates the speci cation and returns false otherwise.
the strengthening operator of a cpa can be used to get information from the abstract state of another component cpa to compute a stronger successor abstract state it is called within the transfer relation of the wrapping composite cpa after all component cpas have done their transfers.
more details on the cpa formalism can be found in the literature .
abstract reachability graph.
to verify properties of a program we run a program analysis alg.
that is de ned by a cpa d. starting from all initial abstract states with precision from w0 we compute all successor abstract states until we have reached the xed point.
all abstract states that have been reached so far are stored in the set reached the set waitlist represents the frontier that is the set of abstract states for which the successor abstract states still have to be computed.
the abstract states in the setreached are the nodes of an abstract reachability graph arg a directed graph that is rooted at the initial abstract states with precision from w0 .lazy abstraction proposes to use di erent precisions for di erent parts of the arg both the set reached and waitlist consist of pairs of an abstract state with abstraction precision.
.
loom cpa on the fly wea ving this section introduces our speci cation automata our speci cation analysis which provides on they speci cation decomposition and the loom analysis whichalgorithm cpaalgdpr0 w0q adopted from input a cpa d pd merge stop prec targetq a setr0 e of abstract states with precision a subsetw0 r0of frontier abstract states with precision whereedenotes the elements of the lattice of d output a set of reachable abstract states with precision a subset of frontier abstract states with precision variables a set reached e a set waitlist e reached r0 waitlist w0 while waitlist hdo pe q choosepwaitlistq for eache1withe pe1 qdo ppe p q precpe1 reachedq for eachpe2 2qpreached do enew mergeppe e2 p q ifenew e2then waitlist waitlistytpenew p qu ztpe2 2qu reached reachedytpenew p qu ztpe2 2qu if stopppe te pe qpreachedu p qthen waitlist waitlistytppe p qu reached reachedytppe p qu iftargetppeqthen returnpreached waitlistq returnpreached hq provides on they weaving of operations from the speci cation automata into the transition relation of the analysis.
a key design decision of our approach is to give the formal speci cation and the program code to the veri er as separate objects.
instead of instrumenting the speci cation into the program code before running the veri er the veri er weaves the speci cation on they into the transition relation of the program during the analysis.
whenever a di erent sub set of properties is to be veri ed we do not have to re instrument the input program and restart the veri er.
in our method of on they speci cation weaving only selected properties are weaved and only for a speci c part of the state space which properties and where to weave them can be dynamically adjusted e.g.
via lazy abstraction .
irrelevant noise in terms of unnecessarily instrumented properties is avoided and the algorithm and the engineer who tries to understand an error path deals with clean abstract program paths.
a formal speci cation that represents a set of program executions can be expressed as a temporal logic formula or by an automaton that accepts the same set of executions .
we concentrate on temporal safety properties which can be expressed using nite automata .
speci cation automata.
a speci cation automaton encodes a set of properties and observes but not restricts the state space of an analysis run.
a speci cation automatonpq q fqfor a given cfa pl l0 gqis a nondeterministic nite automaton with a nite set qof control states an alphabet 2g s r a transition relation q q an initial control state q0pq and a set f of accepting control states.
each qppfrepresents that propertypppis violated i.e.
a path through the program that violates pis found .
we write q q1ifpq q1qp holds.
a symbolp s rq p consists of a set of controlow edges a sequence sof assignment operations to weave and a sequence rof assume operations.
to increase traceability and to support enabling and disabling automaton transitions that are irrelevant for speci c properties we calculate two maps that assign to each control stateqpqand to each transition p the sets of relevant properties ppqqandpp q respectively.
352our speci cation automata support three modes of expressing and encoding properties.
the pure automata based mode tracks every possible state of the speci cation explicitly and thus contributes to the explosion of the speci cation spate space.
in the pure weaving mode the speci cation that is represented by the automaton gets weaved into the program completely.
the set of control states only consists of the initial control state and a number of accepting control states each representing a di erent property.
the hybrid mode combines the rst two modes.
di erent control states are used for guiding the process of weaving the given set of properties into the transition relation of the underlying analysis.
a control state of an automaton typically models the current context of the program.
to not a ect the completeness or soundness of the program analysis the operations that are introduced by the weaving process must never modify or restrict the state space of the program under analysis assignment operations are allowed to assign values to only such variables that were introduced by the automaton itself and for each control state the disjunction of all predicates from assume operations on the outgoing transitions must evaluate to true.
property relevance.
a property pisrelevant for a given program if the speci cation automaton has a transition to control state q1withppppq1qorpppp qand transition syntactically matches a controlow edge of the program.
situations where a property is not relevant for a program can also indicate a aw in the speci cation.
speci cation analysis.
for each speci cation automaton we instantiate one speci cation analysis.
the speci cation analysis keeps track of the current state of the automaton and determines its successors based on the transition relation and the current controlow edge of the cfa it provides operations that should later be weaved into the control ow it provides assumptions on the state space for strengthening the composite abstract state it can disable the veri cation of certain properties on they for some region of the state space and it is responsible for determining whether a violating state has been reached.
by running several speci cation analyses in parallel we lazily accept the union of words without any explicit automaton construction.
the speci cation analysis for a speci cation automaton is a cpads pds s s merges stops precs targetsq.
a precision p sof this cpa is a set of properties to verify it implicitly de nes the subset of transitions of the speci cation automaton that are relevant for verifying properties from t p pp qx hu .
the speci cation analysis interprets the transitions of the speci cation automaton according to the precision for a given transition q q1 it uses the precision adjusted transitionq q1 i.e.
it uses only transitions that are relevant for verifying a property pp .
the cpa is de ned as follows .the abstract domain ds pc q rr ssqconsists of the set cof concrete states a semi lattice q and a concretization functionrr ss.
the semi lattice q pz jqqis a at lattice on the set of abstract states z pqyjq ops where one abstract state pq oqpzconsists of an automaton stateqand a sequence oof operations.
.
the transfer relation shas the transfer pq oqg sppq1 o1q q if the speci cation automaton ahas a precision adjusted transition q q1 with p s rqandgp ando1 r s. if no transition is applicable it has the stuttering transfer pq oqg sppq oq q. an analysis shall not stop exploring a program path after a property violation other properties could be violated later along the path as well soundness .
our speci cation language supports patterns variables the sequencessandrof assignment and assume operations respectively have to be instantiated within the transfer relation based on the current automaton state and the controlow edgeg.
the set of matching controlow edges can be de ned by patterns like malloc which matches for example the controlow edge with the assignment operation ptr malloc .
the expressions that match the pattern variables can then be referenced for instantiating new sequences of assignment or assume operations.
continuing the example the pattern null would be instantiated as the assume operation ptr null .
.the precision sof the analysis determines which properties are veri ed for which part of the state space.
the precision adjustment operator precs z s 2z s z s is central in the on they decomposition of a speci cation.
based on several measures of the veri cation e ort spent on each property we dynamically decide whether we should stop verifying a property starting from a given abstract state onwards.
the operator exceeds p breturns true if a speci c budget for a given property is exceeded and false otherwise.
a property pis removed from the precision precspe s reachedq pe sztpuq ifexceedsppq true.
.the operator merges z z zkeeps two abstract states always separate mergespe e1q e1.
.the operator stops z 2z bchecks whether there is already an abstract state that subsumes a given state stopspe rqreturns true ifde1pr e e1 otherwise false.
.the operator targets z breturns true if the speci cation automaton is in an accepting control state qppf which signals the violation of property p given an abstract statepq qpz it returns true ifqpf otherwise false.
on they weaving with the loom analysis.
the loom analysis is a composite cpa dl that weaves sequences of operations from the speci cation cpa into the transition relation of the analysis.
the de nition of speci cation automata ensures that this process does not make the dataow analysis for the program unsound.
theloom analysis is composed of at least the location cpa as well as the instances of the speci cation cpa.
given the composite state e pl pq1 o1q pqm omqqand the concatenation oc o1 om pop1 opnqof all operation sequences with oc we add new controlow edges tog pl op1 l1q pln opn lq where the last controlow edge leads to the original location l the transfer relation l has the transfer pl q l pl q which is taken after all component cpas have performed their transfers and strengthenings.
the only operator that is allowed to modify the components of the composite state is the strengthening operator.
the strengthening of the location cpa is used to modify the current location based on the operations to weave that are provided in the states of the speci cation cpas.
without loss of generality we assume that no transition gpg of the cfa leads to the entry location l of the sequence of newly introduced controlow edges.
figure illustrates this process on an example.
353la lb l lnopk op1opn 1opn la lb l lnopk op1opn 1opn figure given an abstract state e plb pq oq q created based on the controlow operation opk witho pop1 opnq the loom cpa introduces a sequence of controlow edges that correspond to the operations o. the program analysis is redirected to their entry location l such that e1 pl pq q q. .
decomposing property sets di erent properties exhibit di erent characteristics which determine whether some properties should be veri ed on the same abstract model or separately.
ideally a decomposition strategy separates those pairs of properties that if veri ed simultaneously lead to a decrease of e ciency and it bundles those properties that bene t from simultaneous veri cation.
we propose run time strategies for speci cation decomposition which can consider measures of the veri cation process and the state space under construction for deciding which properties to verify separately or in a speci c combination.
depending on the chosen abstract domain or analysis con guration di erent measures might be appropriate.
such measures can help to identify properties whose scope spans across loops properties that involve an undecidable theory or any property that would cause a blow up of the abstract reachability graph.
we de ne three points in time for providing or performing a decomposition of the speci cation a domain expert can provide an authoritative decomposition of the speci cation before starting the veri er the decomposition can be performed dynamically each time before running the modelchecking algorithm and it can be performed on the y during the execution of the model checking algorithm.
.
decomposition framework model checking algorithms found in the literature are neither designed for decomposing a speci cation nor are they able to handle the fact that only a fraction of the speci cation might have been veri ed.
algorithm sdc speci cation decomposition was particularly designed for this concern it wraps a standard analysis algorithm analyze4 and its speci cs are de ned by a decomposition strategy s. the algorithm takes four parameters.
the initial abstract statee0with the adjusted line initial precision 0denes the initial frontier line which is the starting point for the analysis to compute successor states until a xed point is reached.
the initial partitioning of the speci cation and the initial resource budget de ne the initial decomposition process.
if no property is left for veri cation line the algorithm terminates with a pair of satis ed proper4this can be a standard program analysis such as cpaalg alg.
or even testing algorithm analyze must satisfy the interface operate on sets reached and waitlist and return a set of error paths.
while we base our implementation on cpachecker our concepts are not bound to this framework.ties and violated properties.
properties are removed from the set remaining if a feasible error path was found line or a xed point was reached with the properties enabled for veri cation line or if the analysis resigns to verify them line .
resource budgets.
due to the general undecidability of the veri cation problem some properties cannot be veri ed even with an arbitrary amount of resources the algorithm would terminate without reaching a xed point returning the result unknown .
appropriate resource budgets for speci c properties or sets of properties are therefore crucial for the overall e ciency and e ectiveness of veri cation with speci cation decomposition.
di erent resources hcan be taken into account for de ning budgets on properties or the overall veri cation process.
aresource phcan be for example the cpu time that is spent on a speci c operation of the analyzer or the full enclosing analysis algorithm or the number of precision elements with speci c characteristics or the number of branchings in the arg this list is not exhaustive .
aresource utilization monitor u put utpqtracks the amount of resources consumed by the analyzer.
the utilization operator ut h zreturns the total amount utpuqfor a given resource phthat was consumed between the start of the monitor and the time the operator was invoked.
the utilization operator utp p h zreturns the amount utppuq for a given resource phthat was consumed for a speci c propertyppp.
we denote the set of all resource utilization monitors by u. whenever the speci cation decomposition algorithm starts with a new set of properties the resource utilization monitor is reset all utilization operators are set tozero whenever operator initis called .
aresource budget u bis an operator that returns true for a given pair of utand utpif there are su cient resources left for a given property ppp and false otherwise.
we denote the set of all budgets by b budget jdoes not restrict budget kdeclares all resources unavailable.
as part of our framework we de ne a set of operators that take the resource monitors and the resource budgets into account for performing the speci cation decomposition dynamically on they the precision adjustment operator precsof the speci cation analysis and the operators of the decomposition strategy the exhaustion operator resigned and the partitioning operator adjprecision .
decomposition strategy.
algorithm sdc for speci cation decomposition is con gured by a decomposition strategys padjprecision resignedq .the operator adjprecision 2p bfor a given decomposition strategy stakes as input a precision and a set of remaining properties that are still to be veri ed and returns as output a pair of precision and budget .
the precision de nes which properties to verify simultaneously in the next run of the analyzer.
our stateful implementation of operator adjprecision internally maintains a decomposition of the speci cation which is represented as partitioning p of properties.
the partitioning is iteratively adjusted based on the veri cation progress in terms of remaining properties and consumed resources and the next partition is returned as part of .
the new resource budget limits the cpu time number of transitions number of re nements for the next run of the analyzer.
354algorithm sdc s analyzeppe0 0q p0 0q input a decomposition strategy s padjprecision resignedq an analysis algorithm analyze an initial state e0pewith precision 0p an initial partitioning p0 the initial resource budget output set of satis ed properties set of violated properties variables a set reached e a set waitlist e a precision that determines which properties to track a set remaining pof remaining properties a set satis ed pof satis ed properties a set violated pof violated properties a set cexsof counterexamples abstract program paths which violate properties ppcexsq p satis ed h violated h remaining p repeat p q adjprecisionp0 0p remainingq waitlist tpe0 qu reached waitlist repeat preached waitlist cexsq analyze preached waitlistq violated violatedyppcexsq remaining remainingzviolated waitlist disablepwaitlist violatedq until cexs h ifwaitlist hthen satis ed satis edyactivepreachedq remaining remainingzsatis ed else resource budget exhausted!
remaining remainingzresignedpreachedq until remaining h returnpsatis ed violatedq .the operator resigned 2e 2ptakes as input a set of abstract states with precision reached and returns a set of properties that are considered not veri able within the given resource constraints and should no longer be considered in any further iterations of the decomposition algorithm.
the auxiliary function disable 2e 2p 2e returns for a given set of abstract states with precision and a set of propertiesp a new set of abstract states with precision from which all properties from pare removed from the precision of the speci cation analyses.
the helper function active returns for a given set of reachable abstract states with precision a set of properties that the analysis was still verifying in the last run of the analyzer that is the properties that were still active .
.
decomposition strategies next we describe how speci cation decomposition strategies can be instantiated within our framework.
an experimental evaluation of our strategies can be found in sect.
.
the strategies are di erent in decomposition operatoradjprecision the initial partitioning p0 and the initial budget .
the strategies consider the set h tat rc scuof resources were at rc scdenote the analysis cpu time the number of re nements and the number of transitions taken so far by the analyzer respectively.
all strategies de ne a budget for the analysis cpu time atph for example the budget utpatq 900limits the analysis cpu time to s .
the operator exceeds which is used in the precision adjustment operator precsof the speci cation cpa returns true if any of the resources is exhausted in .
the operator resignedonereturns true if only one property wasenabled for veri cation in the given set of abstract states otherwise it returns false.
strategy s0 padjprecisions0 resigneds0q.this strategy does not perform any speci cation decomposition it places all properties in one single partition and does not specify any resource limit.
this strategy is used as a baseline for evaluating the performance of more advanced strategies.
we use this strategy with the initial partitioning p0 tpuand the initial resource budget j. after the analysis terminates for the initial partitioning p0 the operator adjprecisions0returnsp kq we signal the exhaustion of all resources.
the operator resigneds0returns the full set pas result which leads to the immediate termination of the speci cation decomposition algorithm.
strategy s1 padjprecisions1 resignedoneq.this strategy starts by verifying all properties simultaneously and continues to verify the remaining properties in isolation one by one .
this simple strategy is useful if no measure is available for deciding which properties to verify in the same partition.
the goal of this strategy is to not lose veri cation results in cases where verifying all properties simultaneously is not possible.
we use this strategy with the initial partitioning p0 tpuand the initial resource budget .
after the analysis is nished for the initial partitioning p0 the call adjprecisions1p remainingqreturnsp 900qwhere 1enables exactly one arbitrarily but deterministically chosen property ppremaining .
the operator resignedoneensures that a property is veri ed only once in isolation.
strategy s2 padjprecisions2 resignedoneq.strategy s2 builds on strategy s1but restricts the budget for speci c resources.
we have con gured the strategy to stop verifying a property if it causes relative to the other properties signi cantly more re nement iterations which might correlate with a much higher abstraction precision .
a property p is removed during the veri cation process from the precision if there have been relative to the maximum number of re nements for the other properties in at least twice as much but at least ten re nements given the number of re nements rcp utppp rcq we use the initial budget utppp rcq 10 utppp rcq maxp1pp zpqutppp1 rcq.
the background is that our program analysis uses counterexample guided abstraction re nement cegar for constructing the abstract model of the program that is we use cegar to determine the abstraction precision that is necessary to rule out infeasible error paths.
an error path cexwitnesses the violation of a set of properties ppcexq.
the idea of strategy s2is to use the number of infeasible error paths that have to be ruled out by an abstraction re nement as an indicator for the cost of verifying a speci c property.
the number of re nement iterations is a critical factor that a ects the performance of an analyzer that is based on cegar .
strategy s3 padjprecisions3 resignedoneq.this strategy tries to reduce the e ort for verifying properties that are likely irrelevant for a given program and to focus on the properties that have been identi ed as relevant.
whether a property pis considered relevant is determined based on the number of transitions scphto a control state q of a speci cation automaton with ppppqq which can be queried from the resource utilization monitor utppp scq.
the setprel ttp ppp utppp scq 0uurepresents the set of properties that have already been identi ed to be relevant 355the set pirr pzprel represents the properties that have not yet been identi ed to be relevant and that might be irrelevant for the given program.
each partition of properties is veri ed with the resource budgets .
the strategy operates in three phases we start with the initial partitioning p0 tpu which de nes the rst phase of the strategy.
the full set properties get veri ed simultaneously for s without any limits on certain properties.
in the second phase of the strategy we verify only those properties that have so far not yet identi ed to be relevant for the program the second phase is skipped if pirr .
thus we make sure that all properties that have not been identi ed to be relevant in the rst phase are really irrelevant for the given program at least with the given resource budget .
if any new relevant property was identi ed during that phase the set of relevant properties is corrected and the second phase is restarted.
in the third phase of our strategy we verify all those properties separately that have still not been veri ed successfully but have been identi ed to be relevant for the given program.
that is given the set remaining of remaining properties the properties prelxremaining get veri ed in isolation with the resource budget .
strategy s4.strategy s4combines strategies s2ands3 it considers the relevance of properties to reduce the number of properties to verify separately and a resource budget on properties limits the number of re nements per property.
.
evaluation in a series of experiments we evaluate the potential of software veri cation with on they decomposition of speci cations in terms of e ciency and e ectiveness.
.
research questions our experimental evaluation is guided by ve research questions which are divided into three groups that provide di erent perspectives on our approach.
simultaneous veri cation of all properties.
we rst investigate the performance bene t of verifying all properties of a speci cation in one veri cation run using one shared abstract model one abstract reachability graph of the program.
this reuse of intermediate veri cation results can in uence both the e ciency and the e ectiveness of a software verier.
for now we are only interested in the performance of the analysis procedure itself the e ort for all pre processing steps that are associated with the veri cation run will be investigated separately.
rq1.
how many veri cation tasks can be solved more e ciently and what is the speedup in terms of cpu time for the analysis by verifying all properties of a speci cation simultaneously compared to verifying each property in a separate run of the veri er?
rq1.
how many veri cation tasks can be solved more e ectively in terms of number of veri cation results by verifying all properties of a speci cation simultaneously compared to verifying each property in a separate run of the veri er?
speci cation decomposition strategies.
our initial example see table illustrates that there are cases for which simultaneously verifying all properties of a speci cation with one abstract model is not feasible.
but it can still be bene cial to verify at least some of the properties simultaneously.this set of research questions aims at investigating the potential of automatic speci cation decomposition strategies rq2.
how many veri cation tasks can be solved more e ciently by applying automatic decomposition strategies s1 s4 for verifying several properties simultaneously in one run of the veri er?
rq2.
how many veri cation tasks can be solved more e ectively by applying automatic decomposition strategies s1 s4 for verifying several properties simultaneously in one run of the veri er?
overall performance.
the above research questions have focused purely on the analysis procedure we have not discussed the costs for the pre processing steps.
these steps include parsing the program construction of the cfa and setting up the di erent cpas which includes initializing solvers etc.
.
taking these steps into account results in the last research question rq3.
what overall e ectiveness and e ciency can we expect in practice that is including costs for the preprocessing steps from a veri er with on they speci cation decomposition compared to traditional con gurations that verify each property in a separate run of the veri er?
.
setup our benchmark suite consists of two sets of linux kernel modules the full set with modules and a subset with 250modules.
details on the benchmarking environment and the benchmark suite can be found in sect.
where we describe the replication package.
the replication package includes all tools and data for replicating our experiments as well as a detailed description of all properties.
presentation.
if not stated otherwise we report cpu time in hours rounded to two signi cant digits.
analysis cpu time excludes the time taken by pre processing steps that are performed before the analysis itself starts.
analysis domain.
we have con gured a composite analysis where one of the components is a predicate analysis with adjustable block encoding .
this analysis is used for representing central aspects of the state space of the program and the portion of the speci cation that was weaved onthey with our loom analysis assume operations that are provided by the speci cation automata get encoded within the strengthening operation of this analysis.
the program counter the call stack and the control states of the speci cation automata are tracked each by separate analyses.
our predicate analysis is con gured to compute a boolean predicate abstraction for each function call location and for each head of a loop we perform a large block encoding .
experiments.
the baseline for all our discussions and experiments is an analysis where only one property is veri ed in one instance of the veri er.
we have limited the analysis cpu time for one property to h. limiting the analysis cpu time instead of the total cpu time helps us to exclude costs for pre processing and focus on the costs of the statespace exploration.
given the set of 250kernel modules see sect.
and the set of 14properties we run singleproperty veri cation tasks the analysis can provide results in3 cases from which 97violate and satisfy the property.
the analysis cpu time for the solved veri cation tasks sums up to h includes the time for tasks that ran into a timeout .
356to answer rq1.
and rq1.
we compare the baseline to a multi property veri cation run that is con gured to verify all properties in one partition that is we use the decomposition strategy s0on250kernel modules for which we verify all 14properties the overall cpu time for analysis is limited to h h .
to answer rq2.
and rq2.
we perform two experiments where we evaluate the decomposition strategies s1 s4.
the rst experiment is on the 250kernel modules for which we verify all 14properties.
the second experiment evaluates the e ciency and e ectiveness of our decomposition strategies on hard tasks that is tasks for which the baseline con guration is either able to provide results for more properties or is more e cient than strategy s0.
for both experiments we have limited the overall cpu time for the analysis to h. to answer rq3.
we run two experiments for which we do not force the java virtual machine jvm to compile most of the bytecode during its startup.
the rst experiment is on the250kernel modules for which we verify all 14properties.
to con rm our results and increase their validity the second experiment is on the larger set of veri cation tasks that is we verify the 14properties of all linux kernel modules.
.
results this section presents the results of our experiments raw data and more details are shipped with our replication package sect.
.
rq1.
e ciency of multi property veri cation.
verifying all properties simultaneously is faster for 80percent 199modules of the modules compared to verifying each property individually.
overall we gain an average speedup of5 2in terms of cpu time for the analysis.
a graphical illustration of the results can be found in fig.
.
several relevant properties can be veri ed without any re nements purely based on the state of the speci cation automata.
in the cases in which verifying the properties individually is more e cient the simultaneous checks ran into a timeout for 14modules without providing any result the individual checks were able to provide results for some of the properties of eleven of those modules.
rq1.
e ectiveness of multi property veri cation.
the results illustrate that verifying all properties simultaneously without any decomposition strategy can lead a substantial loss of results we lost of the results the goal of speci cation decomposition is to improve this.
on the other hand the analysis is able to provide ve additional results for di erent properties in di erent modules because the resources are not divided across di erent partitions.
rq2.
e ciency by speci cation decomposition.
for the set of 250modules each decomposition strategy can provide an average speedup of at least .
there are subsets of these modules for which speci c decomposition strategies are the most e cient choice.
strategy s0is the best choice only those strategies are considered that provide results for all properties of a given module for s1for15 s2for18 s3for19 and s4for12 of the modules.
the baseline con guration provides the best e ciency for of the modules.
for the subset of hard modules strategy s4provides an average speedup of and is able to provide a speedup for33 of these modules without a speci cation decomposition no speedup was possible for this set of modules.
each separatelyall simultaneouslyfigure scatter plot that compares the simultaneous veri cation of all properties y coordinate to the classical approach where each property is veried in a separate instance x coordinate of the veri er in terms of cpu time for the analysis table results for di erent decomposition strategies the rst set of tasks covers 250linux kernel modules the set of hard tasks is a subset of those tasks tasks for which the baseline con guration is either able to provide results for more properties or is more e cient than strategy s0 strategy satis ed violated partitions analysis cpu time h average speedup additional results lost results lost results speedup 1allmodulesbl s03 s13 s23 s33 s43 84hard modulesbl s0 s1 s2 s3 s4 the strategies s2ands4 which implement a decomposition heuristic based on the number of abstraction re nements are more e cient than strategies s1ands3that do not use such a heuristic.
table provides more details on the e ciency of di erent decomposition strategies on the discussed sets of tasks.
rq2.
e ectiveness by speci cation decomposition.
according to table all our strategies that perform some kind of speci cation decomposition can reduce the number of lost results to less than .
rq3.
overall performance.
for estimating the practical potential of multi property veri cation with speci cation decomposition and on they speci cation weaving we consider the total process cpu time of strategy s4.
because the jvm is now allowed to take the full advantage see sect.
.
357of its just in time compiler the results are slightly di erent from those for the earlier research questions.
for the set of 250kernel modules the overall process cpu time reduces compared to the baseline from hto25 h with an average speedup of .
median .
.
to con rm our results and increase their validity we evaluated our approach on a larger set of veri cation tasks that covers kernel modules.
the overall process cpu time is considerably reduced from h to130 h with an average speedup of .
median .
and a lower speedup for of modules of the modules.
at the same time results for separate properties were lost in comparison to the baseline.
note that this set of modules contains entries for which none of the properties is relevant leading to the best possible speedup for them.
.
discussion our results illustrate that multi property veri cation is in many cases more e cient than verifying every property individually.
the number of solved problems can be kept on a similar level by using a speci cation decomposition strategy.
taking the relevance of properties into account helps to further improve the e ciency of the overall veri cation process.
measures of the veri cation process can indicate properties that are likely to cause high costs.
the measures can be used to decide which properties to better verify later in another partition or even in isolation .
on they weaving of speci cation automata with dynamically adjustable precision helps the veri er to focus on properties that are enabled for analysis at the moment and the current state of the speci cation can be encoded in an appropriate abstract domain.
such an encoding is crucial for our approach it helps avoiding state space explosion considerably.
an experimental comparison to traditional approaches that instrument the speci cation into the program code before the veri er starts may be promising but is outside the scope of this paper.
one hypothesis is that our approach can bene t from a large portion of intermediate veri cation results that are similar for di erent properties.
as we use lazy abstraction only those parts of the state space are modeled with higher precision that are relevant for at least one of the analyzed properties.
common states might be the result of expensive computations such as the computation of a boolean predicate abstraction.
an indicator for the similarity of state spaces is their size that is the number of states in the set reached .
we can compare the maximum number of reached states of veri cation runs that verify a single property to the size of the set reached of multi property veri cation runs.
this analysis reveals that the number of reached states is indeed similar in many cases that is we likely take advantage of this sharing potential we leave a more elaborate analysis of this observation to future work.
our decomposition strategies are con gured to re construct the state space from scratch for each partition of properties which is still a waste of precious intermediate veri cation results.
re using parts of previously constructed state space graph for successive partitions could lead to a signi cant improvement of the performance .
.
threats to validity our benchmark suite consists of a substantial set of linux kernel modules and a set of safety properties that are relevant in that domain.
the size and diversity of our benchmark suite ensures that our conclusions are externally valid in that application domain.
di erent tools with di erent abstract domains and analysis techniques work di erently in terms of sharing abstraction precisions and abstract states similarly the smt solver is critical for the performance.
the chosen time limit of hfor a single property is chosen more or less from previous experience most veri cation tasks that we encounter can be solved within this time period bycpachecker cf.
one of the reports on the international competition on software veri cation .
the speedup depends on the number of properties that are veri ed and can be arti cially increased by including many properties that are not relevant for a veri cation task.
we use a subset of the properties that were de ned in context of the linux driver veri cation project each property can be potentially relevant for each kernel module or might become relevant by a minor change to its code.
the distribution of code that is relevant for proving a property is important.
the scope of properties in a program in uences the potential speedup of our approach.
it is not possible to control this variable thus we increase internal validity by the large number of experiments on many di erent modules.
proving a property is in general considered harder than showing its violation.
our set of veri cation tasks has only a small percentage of violations such that the overall picture is still valid.
.
conclusion we presented a set of enabling techniques for verifying formal speci cations that can be further decomposed into sets of properties.
first we presented the loom analysis a new technique that on demand and on they weaves properties into the transition system.
this way we can switch on and o as needed during the veri cation process properties independent from other analysis components the precision of the speci cation analysis de nes the set of properties to verify for a speci c part of the state space.
second we developed several promising heuristics for self monitoring the veri cation progress and reduce or increase the precision of the analysis the set of properties to be veri ed dynamically during the analysis.
the combination of these concepts leads to an e cient and e ective analysis of large sets of properties in one run of the veri er.
the results of our experimental study are promising verifying several properties in one veri cation run can in most cases signi cantly increase the e ciency of the veri cation process this complements the current practice where only single properties are veri ed in one run of the veri er.
our results open up a number of interesting research directions techniques that were successful for verifying single properties in one run might not be the best choice for verifying larger sets of properties.
.