testing cross platform mobile app development frameworks nader boushehrinejadmoradi vinod ganapathy santosh nagarakatte liviu iftode department of computer science rutgers university naderb vinodg santosh.nagarakatte iftode cs.rutgers.edu abstract mobile app developers often wish to make their apps available on a wide variety of platforms e.g.
android ios and windows devices.
each of these platforms uses a different programming environment each with its own language and apisfor app development.
small app development teams lack theresources and the expertise to build and maintain separate codebases of the app customized for each platform.
as a result we are beginning to see a number of cross platform mobileapp development frameworks.
these frameworks allow the appdevelopers to specify the business logic of the app once using thelanguage and apis of a home platform e.g.
windows phone and automatically produce versions of the app for multiple targetplatforms e.g.
ios and android .
in this paper we focus on the problem of testing crossplatform app development frameworks.
such frameworks arechallenging to develop because they must correctly translate thehome platform api to the possibly disparate target platformapi while providing the same behavior .
we develop a differentialtesting methodology to identify inconsistencies in the way thatthese frameworks handle the apis of the home and target plat forms.
we have built a prototype testing tool called x checker and have applied it to test xamarin a popular framework thatallows windows phone apps to be cross compiled into nativeandroid and ios apps.
to date x checker has found bugsin xamarin corresponding to inconsistencies in the way thatxamarin translates between the semantics of the windows phoneand the android apis.
we have reported these bugs to thexamarin developers who have already committed patches fortwelve of them.
i. introduction over the last several years we have witnessed a number of advances in mobile computing technology.
mobile devices are now available in a variety of form factors such as glasses watches smartphones tablets personal robots and even cars.these devices come equipped with powerful processors amplestorage and a diverse array of sensors.
coupled with advancesin operating systems and middleware for mobile devices programmers can now avail rich programming apis to buildsoftware apps that leverage these advances in hardware.modern app markets contain hundreds of thousands of apps and the number and diversity of apps available to end usershas further contributed to the popularity of mobile devices.these advances in hardware and software have made mobiledevices viable replacements for desktop computers.
at the same time we are also witnessing a fundamental shift in the practice of software development due largelyto the dynamics of mobile app development.
until a fewyears ago the task of developing software targeting mainlydesktop computers was mostly confined to teams of softwareengineers either in the open source community or at itcompanies.
in contrast it is common today for small teamsor even individuals to build and distribute software via mobileapp markets.
such teams or individuals may lack the expertiseand experience of a large team of developers and oftenface economic and time constraints during app development.nevertheless mobile app development teams aim to maximizerevenue by making their apps available on a wide variety ofmobile devices i.e.
those running software stacks such as android ios and windows.
apps that are available for awide variety of mobile devices can reach a large user base and can therefore generate more revenue either through apppurchases or via in app advertisements.
one way to build apps for different mobile platforms is to create customized versions of apps for each platform e.g.
a separate version of the app for android ios and windowsdevices.
however this approach leads to multiple versions ofthe app s code base which are difficult to maintain and evolveover time.
therefore developers are increasingly adoptingcross platform mobile app development frameworks.
theseframeworks allow developers to program the app s logic oncein a high level language and provide tool support to allow theapp to execute on a number of mobile platforms.
there are two broad classes of cross platform frameworks available today.
the first class which we call w eb based frameworks allows developers to build mobile apps usinglanguages popularly used to build web applications such ashtml5 javascript and css.
examples of such frameworksinclude adobe phonegap cordova sencha and ibmmobilefirst .
developers specify the app s logic and userinterface using one or more of the web development lan guages.
however these languages do not contain primitives toallow apps to access resources on the phone e.g.
peripherals such as the camera and microphone the address book andphone settings.
thus web based frameworks provide sup porting runtime libraries that end users must download andexecute on their mobile devices.
mobile apps interface withthese libraries to access resources on the mobile devices such mobile apps are also popularly called hybrid mobile apps.web based frameworks allow developers to rapidly prototypemobile apps.
however these frameworks are ill suited forhigh performance apps such as games or those that useanimation.
the expressiveness of the resulting mobile apps isalso limited to the interface exported by the runtime librariesoffered by the frameworks.
the second class which we call native frameworks addresses the above challenges.
examples of such frameworksinclude xamarin apportable md and the recently announced cross platform bridges to be available onwindows .
these frameworks generally support ahome platform and one or more target platforms.
developers build mobile apps as they normally would for the home plat2015 30th ieee acm international conference on automated software engineering .
ieee fig.
.
overall operation of a cross platform mobile app development framework using xamarin as a concrete example.
developers build apps as they would for the windows phone in c using calls to the api of the windows phone sdk.
this code can directly be compiled to windows phone apps using the visualstudio toolchain.
xamarin allows developers to use the same source code to build native android or ios apps.
xamarin provides compatibility libraries thattranslate windows sdk api calls in the code to the relevant api calls of the underlying android and ios sdks.
form and leverage the framework s support to automatically produce apps for the target platforms as well.
for example thehome platform for xamarin is windows phone and developersbuild apps using c and the api of the windows phone sdk.the xamarin framework allows developers to automaticallybuild android and ios apps using this code base.
likewise thehome platform for apportable is ios.
developers build appsusing objective c and the ios sdk and leverage apportableto produce android apps from this code base.
one of the mainhighlights of the microsoft build developer conference heldin april may was the announcement that the upcomingrelease of windows will contain interoperability bridgesthat allow android and ios developers to easily port theirapps to the windows platform .
these bridgesallow android or ios apps written in java or objective c and programmed to use calls from the android or ios sdkto transparently execute atop windows devices.
while thetechnical details of this platform are forthcoming as of thispaper s publication it is reasonable to assume that the bridgeswill incorporate a compatibility library to bridge the android or ios sdk and the windows sdk.
in this paper wewill focus on native frameworks for cross platform mobileapp development.
figure shows the typical workflow of appdevelopment using a native framework.
we use xamarin as aconcrete example but the same general workflow applies toall such native frameworks.
when an app developer uses native frameworks he implicitly expects the apps to behave consistently across the homeand target platforms.
realizing this expectation depends to alarge extent on the fidelity with which the native frameworktranslates the api calls to sdk of the home platform to thecorresponding sdk of the target platform s .
unfortunately this translation is a complex task because the platform mustcorrectly encode the semantics of both the home platformand target platform sdk and the relationship between them.this complexity translates into bugs in the frameworks.
forexample as of may xamarin s bugzilla database showsa history of about bugs that are related to cross platformissues about of which are still unresolved listed as open or new .
although initial development of xamarinonly started in its code is based on mono which startedin as an open source implementation of .net.
the fact that such a large number of bugs exist in a mature and heavily used platform over users such as xamarin monopoint to the complexity of translating between platforms.
othernative frameworks are no exception either.
apportable s bugdatabase for instance shows a history of bug reports 449of which are still unresolved.
in this paper we develop an approach to test native frameworks.
specifically we aim to discover cases wherethe behavior of the application on the home platform isinconsistent with the behavior of its counterpart on a targetplatform.
our approach is based on differential testing .
we generate random test cases using methods described inprior work which in our case are mobile apps in thesource language of the home platform.
we then use this codeto produce two versions of the app one for the home platform and one for the target platform using the native framework.we then execute the apps and examine the resulting statefor inconsistent behavior.
when two versions of the app areproduced from the same source code any differences in thebehavior across the versions are indicative of a problem eitherin the home platform s sdk the target platform s sdk or theway the native framework translates between the two sdks.
to realize this approach we must address two issues test case generation.
the key research challenge in generating effective test cases is that the space of valid programsthat we can generate as test cases is essentially unbounded.while we could sample from this space the probability thatthese test cases will induce inconsistent behavior is low.
1there are a total of about bugs in the database related to various related products offered by xamarin e.g.
the profiler the ide environment etc.
we do not count those bugs because they are not directly related to crossplatform issues.
442to address this challenge we observe that the main difficulty in building cross platform mobile app development tools is translating between the semantics of the sdks of the home and target platforms.
our test case generator thereforeproduces programs that contain random sequences of invoca tions to the home platform s sdk.
we then observe whetherthe resulting apps on the home and target platforms behaveconsistently.
by focusing on the sdk alone our approachnarrows testing to the most error prone components of thecross platform frameworks.
test oracle design.
each of our test cases is compiled into a full fledged app one each for the home and targetplatforms.
when we run the corresponding apps the test oraclemust observe their behaviors to identify inconsistencies.
themain research challenge here is in defining a suitable notionof behavior that can be incorporated into our test oracle.
we address this challenge by observing all data structures that are reachable from the variables defined in the test cases.we serialize these data structures into a standard format and compare the serialized versions on the home and targetplatforms.
assuming that the state of the home and targetplatforms is the same before the test cases are executed thefinal state in each platform after the test cases have beenexecuted must also be the same.
if not we consider thisinconsistent behavior and report an error.
we have prototyped this approach in a tool called xchecker which we have applied to test the xamarin frameworkusing android as the target platform.
using x checker wehave found inconsistencies which corresponded to bugseither in xamarin or the microsoft sdk we have reportedthese to xamarin or microsoft .
to date of these bugs havealso been fixed in the development branch of xamarin and others are still open.
to summarize our contributions are we initiate the study of cross platform mobile app development frameworks and present an analysis of the kinds ofbugs that may arise when these frameworks translate betweenthe semantics of the programming interfaces of two differentplatforms section iii .
we present the design of x checker a testing tool for crossplatform frameworks that uses random differential testing toexpose bugs in these frameworks section iv .
we also presenta number of practical challenges that we had to overcome inthe implementation of x checker section v .
we show the effectiveness of x checker by applying it to xamarin.
specifically x checker tests xamarin s fidelity as ittranslates between the windows phone and android platforms.to date x checker has found bugs of which have beenfixed after we reported them section vi .
ii.
b ackground on native frameworks in this section we provide background on native frameworks using xamarin as a concrete example.
xamarin allowsthe development of native mobile apps for multiple platformswhile aiming to maximize code reuse across platforms.
de velopers using xamarin target their apps to its home platform windows phone and can re use much of the same code tobuild native apps for ios android and mac.
in this section fig.
.
structure of a cross platform app written using xamarin.
we discuss the structure of a cross platform app written usingxamarin and discuss the techniques that xamarin uses toallow app logic and data storage code to be written once andreused across platforms.
a developer using xamarin can build apps in c using features such as generics linq and the parallel task library.the developer splits the app into two logical pieces figure the application core which encodes the business logic andcontains code that is common across all platforms and user interface ui which is written for each platform and usesthe native ui features of that platform e.g.
buttons widgets and the overall look and feel of the specific platform.
thedeveloper implements the ui layer in c as well using nativeui design tools such as android.views monotouch.uikit for ios and xaml silverlight and metro apis for windowsphone.
the functionality and layout of the ui elements can becontrolled by the business logic in the application core e.g.
in determining which button triggers what functionality in theapp.
xamarin is built atop the mono .net framework which provides the core cross platform implementation ofmicrosoft s .net framework.
c source code can be compiled with xamarin s compiler to produce a native ios app or anandroid app with integrated .net runtime support.
in this case the c code is compiled to an intermediate language and packaged with monovm configured for just in time com pilation on android.
xamarin aims to provide support to developers to minimize the amount of platform specific code that is needed toport an app across platforms.
to achieve this goal one ofthe main components of the core of a xamarin based appare cross platform compatibility libraries also called portable class libraries or pcls in xamarin a technology originally developed by microsoft.
on visual studio and other microsoftenvironments a pcl is a special type of a project that allowsdevelopers to write code and produce libraries that can beshared across multiple platforms such as ios android andwindows phone.
to support this pcls export an interface ofmethods and properties that are portable across platforms anddevelopers program to this interface.
the app developer en codes platform independent business logic by programming tothis interface.
the pcl provides forwarding stubs that ensuresthat calls to methods or property accesses are routed to thecorrect underlying platform libraries at runtime.
the developer 443of the pcl typically identifies the interface by choosing a set of target platforms that the pcl will support.
because differentplatforms provide implementations of differing subsets of thebase.net class library the pcl interface is typically restricted to the common .net functionality that is supported by all the target platforms.
pcls play a key role in xamarin because they serve as the compatibility layer between two different platforms.
aspreviously mentioned about xamarin s bugzilla database listsabout that are related to pcl.
despite the functionalityprovided by the pcls some platform dependent business logicmay be necessary in the application core.
for example pclsare still in active development and if the app developer wishesto use features that are not currently supported by the pcl hehas to do so by writing platform specific code called shared assets on xamarin.
it is possible to write this code once and compile it for all desired target platforms using compiler orpre processor directives e.g.
code specific to android or ios would be guarded using a directive such as ifdef android or ifdef ios respectively .
naturally the goal of projects such as xamarin is to increase the coverage provided by theirpcls so as to minimize the amount of code that must bewritten as shared asset projects.
in addition to the application core the app also includes ui code.
currently ui code is largely platform specific becauseui elements e.g.
the look and feel of buttons and widgets are customized to specific mobile platforms.
nevertheless thereare ongoing efforts such as xamarin.forms to even minimize the amount of platform specific ui code.
in this paper we are primarily concerned with testing the functionality of the pcls on xamarin that provide support forplatform independent app code.
therefore the test cases gener ated by x checker only target the pcl interface.
our test casesdo not directly target the platform specific ui code.
however note that many aspects of the layout and functionality of theui are controlled by the business logic which interacts withthe target platform s sdk via the pcls.
therefore by testingthe functionality of the pcls we indirectly test the overallfunctionality of the app s execution on the target platform including its ui .
iii.
inconsistent behavior in this section we present a few motivating examples of real inconsistencies that x checker found in xamarin.
for ourexamples we use android as the target platform the defaulthome platform is windows phone.
we use these examples tomotivate some design features of x checker and classify thetypes of inconsistencies that it can identify.
figure shows a test case generated by x checker.
this code is in c and uses classes and methods from the windowsphone sdk.
in this test case the code first creates two objects base andexp from the systems.numerics.complex class and initializes them to 0i and 0i.
on line it uses the complex.pow operation to raise base to the power of exp.
we used the visual studio toolkit and the xamarin framework to produce a windows phone app and an androidapp respectively and ran the apps on the correspondingplatforms.
both apps execute and return success.
however in using system.numerics serializer serializer serializer is a data structure serializer.
public class testcase public static int testmain myfileio serialstream myfileio logstream try complex base new complex complex exp new complex complex res complex.pow base exp serialstream.append base.gettype .fullname serializer.serialize base serialstream.append exp.gettype .fullname serializer.serialize exp serialstream.append res.gettype .fullname serializer.serialize res return success catch system.exception e logstream.append e.gettype .fullname return exception fig.
.
a test case that illustrates inconsistent handling of the semantics of the windows phone sdk.
the values of res are different in the windows phone and the xamarin produced android versions of this code.
type platform platform consistency checks example check check check app state figure check exception code figure check always inconsistent figure fig.
.
different ways in which a test case produced by x checker can exhibitinconsistent behavior when executed on two platforms.
checkdenotes that the test case returns success while denotes that the test case returns exception.
the windows phone app the value of res is 0i while on the android app the value is nan not a number .
this is clearly an inconsistency in the way the two apps handled the semantics of the complex.pow operation.
since we reported this bug on xamarin s bugzilla forum it has been fixed in themaster branch for the next release .
in this example eliciting the inconsistent behavior between the windows phone and the android versions of the apprequires the calls on lines with the corresponding datadependencies.
to systematically uncover more examples ofsuch inconsistencies x checker must therefore generate manymore such test cases by systematically invoking methods fromthe api of the windows phone sdk with suitable arguments.
when the apps produced from these test cases are executed on their corresponding platforms inconsistent behavior maymanifest itself in one of three ways figure .
the first way as illustrated in the example in figure is where the testcase returns success on both platforms but the resulting state is different.
such inconsistencies are latent in the state of theapps in this case the values of the objects and are not visibleunless this state is made explicit and compared across the twoversions.
x checker achieves this goal by serializing all objects that are reachable from the variables that are in scope within thesource code of the app.
lines in figure show theobjects being serialized and appended to a log.
x checkercompares the logs produced by the windows phone and theandroid versions of the apps to identify inconsistencies.
inthis example serializing the complex object simply prints its value to the log.
however x checker s serializer supportsarbitrary data types and serializes them in a custom format.the serializer itself is written in c with calls to the windowsphone sdk and is included as a library within the nativeapp.
as with all our test cases we use xamarin to producethe android version of the serialization library.
because x checker s test cases include calls to the serializer in the sourcecode of the test case we expect the serialized versions ofsimilar objects to also be similar on the windows phone andandroid versions.
public class testcase public static int testmain myfileio serialstream myfileio logstream try string s test int32 index double val system.globalization.charunicodeinfo.getnumericvalue s index return success catch system.exception e logstream.append e.gettype .fullname return exception fig.
.
a test case that triggers an inconsistent exception behavior.
in the windows phone version of this code line throws asystem.argumentoutofrangeexception while on the xamarin producedandroid version it throws a system.indexoutofrangeexception.f o r brevity we have omitted some code such as calls to the serializer.
a second way for inconsistencies to manifest is when a test case returns exception on both platforms but the exceptions thrown are different on both platforms.
figure illustrates a test case in which this scenario occurs.
thecall on line throws an exception because the valueofindex is negative.
however the windows phone version throws a system.argumentoutofrangeexception while the android version throws asystem.indexoutofrangeexception.
in this case thewindows phone and android versions are inconsistent inthe way they handle the semantics of the getnumericvalue method.
x checker therefore logs the exception code andcompare it across executions of the apps on the two platforms.this bug has also been fixed in the master branch for the nextrelease .
in cases such as these where the test cases on both platforms throw exceptions the logs only contain the exceptioncode.
in particular the logs do not contain the serialized datastructures because the calls to the serializer appear before thereturn success statement and the exception was raised before control reached the calls to the serializer.
it may be possiblethat both the windows phone and the android versions throwthe same exception code but the state of the data structuresin the apps may have diverged before the code that raisedthe exception was executed which is also an example ofinconsistent behavior.
as will be clear when we discuss x checker s approach to test case generation in section iv x checker would have also identified the divergence of state.in particular x checker uses an iterative test case generationalgorithm that preserves the following property any prefix of amethod sequence in a test case generated by x checker is alsoa test case that would have been generated by x checker in aprevious iteration.
therefore if the state is inconsistent aftera call sequence preceding the exception generating method it would have been identified as an inconsistency when theshorter method sequence was used as a test case.
note that in figure the test case executes the code and catches a generic system.exception.
in practice it may be that a developer writing a windows phone app familiar with the windows phone sdk may write this codeto catch a system.argumentoutofrangeexception.i fh e uses xamarin to produce an android app it is possible for thethe inconsistent behavior to manifest itself in one of the othertwo forms shown in figure .
the final possibility for an inconsistency is when a test case returns success on one platform and exception on the other.
figure shows an example of such a test case.
the using system.xml public class testcase public static int testmain myfileio serialstream myfileio logstream try nametable nt1 new nametable nametable nt2 new nametable xmlnamespacemanager nsmgr new xmlnamespacemanager nt2 ... xmlparsercontext xpctxt new xmlparsercontext nt1 nsmgr ... ... return success catch system.exception e logstream.append e.gettype .fullname return exception fig.
.
a test case that triggers an exception in the windows phone version.
the constructor on line throws an xmlexception because nsmgr is independent of nt1.
this test case executes without throwing an exception on the xamarin produced android version.
xmlparsercontext constructor in line expects its second argument nsmgr to be created from the first argument nt1 .
however in this case nsmgr is created from another object nt2.
as a result this constructor call must throw an xmlexception according to microsoft s documentation and it does on the windows phone version.
however on theandroid version the constructor executes without throwing anexception.
as with the previous two bugs this one also hasbeen fixed by xamarin developers after we reported it .
iv .
design of x checker x checker aims to find bugs in xamarin by generating apps executing these apps on windows phone and android and looking for inconsistencies in them.
thus x checker sdesign consists of two parts the test case generator and theinconsistency checker.
test case generation.
x checker generates test cases that exercise the programming api used by windows phone developers.
as illustrated in section iii each test case is a sequenceof method calls to this api.
the arguments to these calls areeither values with primitive data types or