a comprehensive study on real world concurrency bugs in node.js jie wang1 wensheng dou1 yu gao1 chushu gao1 feng qin3 kang yin1 jun wei1 1state key lab of computer science institute of software chine se academy of sciences china 2university of chinese academy of sciences china 3dept.
of computer science and engineering the ohio state unive rsity united states wangjie12 wsdou gaoyu15 gaochushu yinkang15 wj otcaix.is cas.ac.cn 3qin.
osu.edu abstract node.js becomes increasingly popular in building server side javascript applications.
it adopts an event driven model which supports asynchronous i o and non deterministic event processing.
this asynchrony and non determinism can introduce intricate concurrency bugs and leads to unpredictabl e behaviors.
an in depth understanding of real world concurrency bugs in node.js applications will significantly promote effecti ve techniques in bug detection testing and fixing for node.js.
in this paper we present nodecb a comprehensive study on real world concurrency bugs in node.js applications.
specifical ly w e h a v e c a r e f u l l y s t u d i e d r e a l b u g c a s e s f r o m o p e n source node.js applications and have analyzed their bug characteristi cs e.g.
bug patterns and root causes bug impacts bug manifestat ion and fix strategies.
through this study we obtain several interesting findings which may open up many new research directions in combating concurrency bugs in node.js.
for exampl e one finding is that two thirds of the bugs are caused by atomic ity violation.
however due to lack of locks and transaction mechanism node.js cannot easily express and guarantee the atomic intention.
i ndex terms javascript node.js event driven concurrency bug empirical study.
i. introduction javascript has become one of the most popular programming languages.
according to the recent surveys from stack overflow and node.js foundation javascript is quickly surpassing the popularity of other back end programming languages e.g.
php and java .
as a server side framework node.js which is built on google s v8 javascript engine is becoming a popular platform for server side applications.
one prominent evidence is that the node.js default package repository npm has become the largest package registry in the world and cont ains over available packages doubling the next most popular package registry the apache maven repository .
in order to optimize throughput and scalability of server side applications node.js adopts an event driven architecture whic h is capable of asynchronous i o. thus developers can create highly scalable server side applications without using threading.
however asynchronous i o and non deterministic event processing in node.js can introduce intricate concurrency bugs.
these concurrency bugs can result in unreliable and unpredictable application behaviors such as crashes and inconsistent states in databases and files.
existing studies have focused on concurrency bugs in multithreaded systems distributed systems android and client side javascript applications and also proposed many interesting testing and analysis techniques .
th e concurrency bugs in node.js differ from those in traditional systems as they originate from different programming paradigms and execution enviro nments.
first multi threaded systems and distributed systems focus on concurrency bugs related to multi thread or untimely external events wh ile node.js atomically processes each event one by one in a single thread without interruption.
second the concurrency in android mostly concerns the android gui model and asynchronous tasks executed in other threads while node.js does not have these features.
third existing studies o n concurrency bugs in client side javascript applications mostly focus on the features like dom and ajax while node.js does not have dom and ajax.
in contrast node.js has the ability to access system resources e.g.
databases and fil es.
node.js is relatively new and little is known about concurrency bugs in node.js applications.
whether existing studies and techniques are applicable to node.js applicati ons remains an open question.
therefore we aim to bridge this gap by conducting a comprehensive study on such concurrency bugs in node.js applications.
we believe a deep understanding of real world concurrency bugs will significantly promote effective techniques in concurrency bug detection testing and fixing in node.js.
in this paper we present nodecb the first to the best of our knowledge comprehensive real world concurrency bug study in node.js applications.
by using the keyword based searching we obtain concurrency and ja vascript related bug reports i n github.
then we check these bug reports and finally collect real world concurrency bugs in open source node.js projects.
we thoroughly study these concurrency bugs and try to answer the following research questions x rq1 bug patterns and root causes what are common bug patterns of concurrency bugs in node.js?
what are their root causes?
x rq2 bug impacts do concurrency bugs have severe failure symptoms?
what impacts do they have in node.js applications?
corresponding author .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research520 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
x rq3 bug manifestation how do concurrency bugs in node.js manifest themselves?
how are they triggered e.g.
the timing condition and input conditions?
x rq4 bug fix strategies how do developers fix concurrency bugs in node.js in practice?
are there any common fix strategies ?
through investigating the above four research questions we made many interesting findings.
the main ones are x concurrency bugs in node.js can be caused by atomicity violation order violation and starvation .
although each event is guaranteed to be processed atomically by node.js atomicity across multiple events cannot be properly enforced without lock or transaction mechanisms.
furthermore exi sting work mostly focuses on order violation in event driven applications e.g.
client side javascript and android .
this suggests that more research should be conducted on atomicity violation in node.js.
x most concurrency bugs contend against shared variables databases and files .
this suggests that besides shared variables concurrency bug detection approaches should pay more attention to shared resources like databases and files.
x apis in node.js are written in an asynchronous and event driven way.
they usually have unclear api protocols e.g.
event order and atomicity specifications .
of concurrency bugs are caused by api misuse indicating that developers may misunderstand the specifications of asynchronous apis .
x almost all concurrency bugs in node.js are triggered by enforcing orders among no more than events.
this indicates that exploring possible orders among every small group of events can test node.js concurrency efficiently.
x almost all the studied concurrency bugs cause severe failures including crashes exceptions hangs incorrect database file states wrong outputs and other operation failures .
x most concurrency bugs were fixed by a small set of fix strategies.
but only a small portion of bugs were fixed by simply adding synchronization e.g.
nested callbacks which is the main approach used by existing automated concurrency bug fixing approaches .
this indicates that further automated bug fixing approaches are needed.
in summary we make the following contributions x we conduct the first comprehensive study of real world concurrency bugs in node.js applications.
our findings can help better understand concurrency bugs in node.js applications and provide guideline s to this topic.
x our documented concurrency bugs can serve as a basis for future work on finding and fixing them.
we have made the collected bugs available online for future studies ii.
b ackground in this section we first introduce the event driven model in node.js and then explain the sources of non determinism in this model.
a. event driven model in node.js the event driven model in node.js is shown in fig.
.
it mainly consists of two parts a single looper thread a n d a worker pool .
both parts are supported by libuv in node.js.
the looper thread is responsib le for executing user code including callbacks that are defined to respond to events.
for some expensive tasks e.g.
file operations node.js offloads them to the worker pool and executes them asynchronously.
by offloading expensive tasks to the worker pool the looper thread would not be blocked by these expensive tasks.
in node.js the basic event processing flow is described as follows the looper thread fetches an event in the event lo op and executes its callback cb.
if the callback cb invokes an asynchronous i o operation the looper thread will offload it t o the worker pool and register a new callback associated with th e asynchronous i o operation.
for example in fig.
callback cb offloads two i o operations createfile a.txt cb a n d readfile a.txt cb to the worker pool and uses cb1 and cb as their callbacks respectively steps .
and .
.
thus the looper thread can proceed with ot her events in the event loop instead of waiting for the completion of these two operations.
the worker pool can use a worker thread to perform each asynchronous i o operation and p ut an event into the event loop when the operation is done.
for example the worker pool puts two events read done and create done into the event loop steps .
and .
.
the looper thread fetches these two events one by one sometime later and executes their callbacks cb2 a n d cb1 steps .
and .
.
the node.js application continues the above steps until the application exits.
note tha t each callback is guaranteed to be executed without interruption .
in node.js the event loop consists of seven fifo event queues that hold different types of events timer i o pending idle prepare check and close .
for example all events scheduled by settimeout will be put into the timer event queue while i o events will be put into the i o event queue.
the looper thread in turn processes these seven event queues in a roundrobin manner when a queue has been exhausted or the amount worker pool fig.
.
the event driven model in node.js.
the solid arrows denote the invocation of an asynchronous operation .
and .
the dotted arrows denote that the operations are completed .
and .
and the corresponding callbacks are invoked .
and .
.
the looper thread executes each callback one by one without interruption.
looper thread .
createfile a.txt cb1 .
read done .
readfile a.txt cb2 .
create done timer .
cb .
cb cb2 cb1 t1 ... cb i o authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of the invoked callbacks for a queue reaches a given threshold the looper thread will move on to the next queue.
although the events in each queue are scheduled in order the events across queues can be scheduled non deterministically.
for example we cannot know the processing order of a timer event and an i o event.
worse the looper thread may register high priority callbacks first.
for example a callback scheduled by process.nexttick will be executed immediately after the current callback completes and the i o events will be processed before moving on to process the events set by setimmediate .
b. non determinism in node.js node.js applications make heavy use of asynchronous operations and further handle these operations results by the ir callbacks.
although the looper thread atomically processes each event one at a time without interruption node.js applications still suffer from various non determinism.
we summarize the sources of non determinism in a single node.js process into the following three phases according to the time when it occurs.
non deterministic execution of asynchronous operations .
when multiple asynchronous tasks are delegated to the worker pool simultaneously their processing order is unknown.
for example in fig.
operations .
and .
createfile a n d readfile are issued almost simultaneously.
we cannot know which operation is scheduled first.
if operation .
readfile is scheduled first then an error file not exist will be thrown since the file a.txt has not been created yet.
non deterministic event triggering.
for two asynchronous operations scheduled by the worker pool their completion order is unknown.
the system environments e.g.
cpu can affect the completion order of the operations .
for example in fig.
if operation .
completes before operation .
the read done event of operation .
will be put into the queue first.
thus callback cb2 will be invoked before cb1.
besides a network request may arrive at any time its order relative to other eve nts e.g.
completion event s of asynchronous operations is unknown.
non deterministic event handling.
it is possible to have multiple callbacks available for execution at any point and th e choice for which one of these callbacks to schedule next is non deterministic as discussed earlier in section ii.a .
thus callbacks may not be processed in their expected order.
non determinism among multiple node.js processes.
the looper thread in node.js is single threaded.
so in order to ta ke advantage of multi core processors node.js can spawn many processes to distribute the workload.
node.js provides an elegant solution cluster to scale up applications by splitting a single process into multiple ones.
these node.js processes may have conflicting accesses to the same resources e.g.
a node.js process copies a file in a directory while anot her process deletes the directory.
this non determinism could introduce concurrency bugs.
iii.
m ethodology to answer the research questions rq1 we collect real world concurrency bugs in open source node.js applications as our study subjects.
this section presents how we collect real world concurrency bugs from node.js applications and further explains the methodology of our characteristic study.
a. collecting concurrency bugs existing bug studies e.g.
often first identify the mature projects and then collect bugs in the projects.
however node.js is relatively new and its applications are still young .
we find that node.js applications usually report very few concurrency bugs.
therefore in order to collect sufficient bugs for our study we directly collect concurrency bugs from all node.js projects in github.
our approach to collect concurrency bugs in node.js is described as follows.
step searching concurrency bug reports in github node.js projects.
as the most popular open source platform github has hosted about node.js projects.
through an initial investigation on some node.js projects we find that th ere is no clear categorization for concurrency bugs in these projec ts.
thus we use concurrency related keywords to search candidate concurrency bugs in node.js projects from github.
the keywords we used are as follows concurrent race synchronization atomic mutex transaction deadlock compete and starve .
to answer our research questions we further use advanced search conditions provided by github to filter out bugs that are labeled as bug already in closed state and contains keywords like submit or fix .
this implies that these bugs are confirmed as bugs and may have fixing solutions.
after this step we obtain bug reports.
step selecting concurrency bugs in node.js projects.
since containing the previous mentioned keywords does not mean that a selected bug report really contains a concurrency bug in node.js we manually validate these bug reports and exclude bug reports that are not related to concurrency and node.js.
finally we obtain concurrency bug reports i n node.js projects.
we further carefully inspect these concurrency bug reports and only keep the concurrency bug reports that contain enough information to answer the research questions rq1 .
some concurrency bug reports are incomplete e.g.
we cannot find its corresponding bug fixing patch or the bug report only contains a one line description and we cannot infer how the bug happens.
we exclude these incomplete bug reports from our characteristic study.
after this step we obta in concurrency bugs for our bug characteristic study.
these concurrency bugs come from node.js projects including serverside applications desktop applicati ons and libraries e.g.
network communication api socket.io .
fig.
shows the statistics of our studied projects.
t hese projects are popular there are on average stars and of them have more than stars .
these projects ar e well maintained there are on average revisions and issues of them have more than revisions and of them have more than issues .
these a popularity distribution of stars b code revision distribution of revisions c issue distribution of issues d project size distribution lines of code fig.
.
statistics of our studied node.js projects.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
projects are big and complicated there are on average lines of javascript code and of them contain more than lines of code .
b. analyzing concurrency bugs in node.js we manually study all the concurrency bugs to answer the research questions rq1 .
specially we study the bug reports bug fixing patches and related discussions e.g.
comments and then assign them into different categories according to their bug patterns and root causes section iv failure impacts section v bug manifestation section vi and fix strategies section vii respectively.
specially we categorize concurrency bugs into different categories in three phases.
we propose initial categories in advance according to the taxonomy in related work .
we carefully study each bug and try to assign it into different categories.
if a bug does not belong to any known category we create a new category for it.
in the last we review the ab ove categorization and ensure that the categorization demonstrates common bug characteristics does not overlap and covers most bugs.
in this phase we may need to adjust current categories e.g.
merge categories rename category names or remove useless categories.
in the above process we make sure that eac h bug is studied at least by two authors.
if we have conflicts ab out the bug or categorization we will reinvestigate the bug furthe r until we form a final decision.
c. threats to validity similar to other bug characteristic studies our study is subject to the validity problem.
potential threats to the validity include the representativeness of our studied concurrency bugs and our study methodology.
representativeness of the studied concurrency bugs.
all concurrency bugs we studied are collected from open source node.js projects.
the keywords we used to select these bugs are a union set of keywords used by related studies .
we keep all the bugs that have enough information for categorization without bias.
further our studied projects include various types of node.js applications e.g.
server sid e applications and libraries.
most of these projects have high popularity and are well maintained.
of course some concurrency bugs may never be reported or fixed by developers.
however there is no proper way to study these bugs.
we believe our studied bugs provide a representative sample of real world concurrency bugs in node.js.
study methodology.
for each bug every piece of information related to the bug including developers explanations source code fixing patches and bug triggering t est cases needs to be studied.
to minimize subjective errors in our study each bug is studied by at least two authors in this pape r. iv.
bug patterns and root causes concurrency bugs in node.js applications can have complex timing involving multiple events and asynchronous operations.
first we study the triggering conditions to categorize the stu died bugs into different bug patterns section a .
second we study the root cause of each bug from two aspects bug inducing phase and bug inducing api to understand why these bugs are introduced by developers section b .
a. bug patterns we study the bug reports of the selected concurrency bugs in node.js and then assign them into different categories according to their triggering conditions.
finally we categoriz e these bugs into three bug patterns order violation atomici ty violation and starvation.
note that we do not find deadlock bu gs in node.js which are common in multi threaded systems .
order violation .
about one third of the studied concurrency bugs are caused by violation to developers order intention between two events or asynchronous operations.
in this case two or more events asynchronous operations which access the same shared resources e.g.
variables files are expected to be processed in a certain order.
however the order is not enforced during execution.
order violation can happen in two situations.
first it happens between two asynchronous operations.
consider bug gp js client in fig.
.
the two asynchronous operations create and uploadstr are issued one after another.
developers assume that these two operations are executed sequentially.
since these two operations are asynchronous node.js may execute them in any order.
in the buggy order the uploadstr operation is first processed by the remote server and returns a n error the data to update does not exist .
to avoid this buggy order the uploadstr operation can be moved to the callback of the create operation line .
second order violation can also happen between two callbacks.
in fig.
the callbacks of two operations steps .
and .
i.e.
cb1 and cb2 are expected to be invoked as cb1 cb .
however this order is not enforced by user code and there is a chance that cb2 is invoked before cb1.
atomicity violation.
about two thirds of the studied concurrency bugs are caused by violation to developers atomic intention among several callbacks or asynchronous .
var bundle client.bundle somebundle .
bundle.
create ... function create is async .
bundle.
uploadstr ... .
.
bundle.
uploadstr ... uploadstr is async fig.
.
gp js client order violation caused by non deterministic execution of asynchronous operations .
the code snippet aims to create a data in the remote server in l ine and then updates the data in line create and uploadstr are two asynchronous operations .
the two asynchronous operations are issued almost simultaneously and may result in a possible buggy order in which the uploadstr operation is first processed by the remote server and returns an error the data to update does not exist .
the fix is to move the uploadstr operation into the callback of the create operation so that the two asynchronous operations are ordered and can be executed sequentially.
1gp js client denotes the concurrency bug reported by the issu e in project gp js client.
other concurrency bugs have the same representation in this paper.
looper remote server buggy order uploadstr create data not exist yet!
err fixed order looper remote server create uploadstr authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
operations.
in this case a set of events asynchronous operat ions are assumed to be processed atomically without interruption bu t the atomicity is not enforced during execution.
consider bug porybox in fig.
.
when a user requests to add a new id the function addidtoarray first triggers an asynchronous operation findone line to query the user s current ids from the database and then triggers another asynchronous operation save line to save the updated ids back to the database.
note that for each user request the abo ve two asynchronous operations are correctly ordered through nested callbacks and thus there is no order violation.
for eac h user request developers assume that this small code region wil l be executed atomically.
however the two operations findone and save are executed in response to two different events and other events may interleave in between.
for example if two use r requests with the same username ownername arrive simultaneously it may trigger the following interleaving findone findone save save .
here the subscripts denote the user request id.
in this case findone an d findone b oth obtain the same ids e.g.
.
for the first request it updates ids from to and then saves ids to the database save .
for the second request it updates ids from to and then saves ids to the database save .
now ids i n t h e d a t a b a s e be com es an d th e u p dat e by th e f irs t re qu es t is l os t .
t h e correct interleaving of two user requests should be findone save findone save as shown in the right part of fig.
.
in this case the second request updates ids based on the first request s result.
thus ids in the database becomes .
atomicity violation can also originate from multiple processes .
two bugs are in this case.
in bug cordova lib the application a tool for installing uninstalling plugins extracts each .tgz file into the same directory and then copies the extracted files out.
when installing two different plugins the first process has extracted a .tgz file into the directory and then is copying the extracted files the second process is extra cting another .tgz file into the same directory.
thus the first proc ess can copy some files that belong to the second process.
starvation.
few concurrency bugs happen when some tasks take a long time and prevent other events from processing.
usually callbacks registered by higher priority ca n starve the lower ones.
consider bug hapi in fig.
.
for each i o request from the client the internals.emit line is called to push the notification to the queue notificationsqueue line .
if no notification is in process lines the first notification is obtained from the queue notificationsqueue line and scheduled in a deferred task through setimmediate line .
it further iteratively emits the internals.emit in another deferred task in order to process the remaining notifications in the que ue notificationsqueue lines .
as mentioned in section ii.a the i o events have higher pri ority than events scheduled by setimmediate .
so if the i o keeps busy the events scheduled by setimmediate will have no chance to be processed.
as a result the notificationsqueue keeps increasing and hits an error allocation failed process out of memory .
.
function addidtoarray ownername id .
return user.
findone name ownername .then user .
user.
ids.push id .
return user.
save .
.
db.user.update name ownername push ids id .
fig.
.
porybox atomicity violation caused by non deterministic event triggering .
each user request addidtoarray triggers two asynchronous operations findone and save in order.
first it triggers findone operation line which queries a list of ids from the database asynchronously.
second after findone returns it modifies the data and triggers save operation line which saves the data back to the database asynchronously.
for each user request the above two steps should be atomic.
however two successive user requests with the same ownername may cause buggy interleaving findone findone save save resulting in the first save to the database get ting lost i.e.
the ids should be not .
this bug is fixed by changing findone and save into an atomic api update supported by mongodb.
.
internals.emit function emitter notification .
if notification .
emitter.
notificationsqueue.push notification .
.
if emitter.isprocessing !emitter.
notificationsqueue.length .
return .
.
emitter.
isprocessing true .
const item emitter.
notificationsqueue.shift .
const finalize .
if item.callback .
setimmediate item.callback .
process.nexttick itemcallback item .
.
emitter.
isprocessing false .
setimmediate internals.emit emitter .
process.nexttick emitemitter emitter .
.
some code in voking finalize asynchronously.
.
fig.
.
hapi starvation caused by non deterministic event handling .
an i o request results in the invocation of internals.emit line which push es a notification to notificationsqueue line .
i f no notification is in process it then shifts an item from the queue line processes it in a deferred setimmediate task line and invokes internal.emit in another deferred task line to process the remaining notifications in the queue later.
this will cause a starvation bug since the event loop keeps processing the i o event queue when the i o is busy before it proceeds with the event queue that the setimmediate event lies in .
as a result the notificationsqueue increases a lot before the notifications are processed and ends up throwing the error allocation failed process out of memory .
finding .
concurrency bugs in node.js can be categorized into three simple bug patterns order violation atomicity violation and starvation.
two thirds of the studied bugs are atomicity violation.
looper libuv setimmediate i o i o i o looper buggy interleaving findone findone ids ids ids save save ids looper correct interleaving findone save ids ids ids findone save ids the 1st save gets lost!
database database authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. root causes it is difficult to know why these concurrency bugs were introduced by developers.
by analyzing bug patterns and related bug descriptions in the bug reports we try to understand the r oot causes from the following two aspects.
bug inducing phase in which phase non determinism is introduced?
buginducing api what asynchronous apis are responsible for the racing events?
further we try to postulate some possible and common misunderstanding behind these concurrency bugs.
bug inducing phase.
as discussed in section ii.b concurrency bugs can be introduced in three different phases execution of asynchronous operations event triggering and event handling.
as shown in table concurrency bugs mostly happen due to non determinism in event triggering and execution of asynchronous operations .
only bugs happen due to non deterministic event handling.
note that bugs are introduced by both non deterministic execution of asynchronous operations and event triggering so the accumulated percentages exceed .
additionally bugs happen among multiple node.js processes.
bug gp js client in fig.
is caused by non deterministic execution of asynchronous operation s. in this example the two asynchronous i o operations i.e.
create and uploadstr may be reordered by the underlying worker pool.
fig.
shows an example of concurrency bug due to non deterministic execution of asynchronous operations and event triggering.
for the buggy interleaving the node.js framework determines the two asynchronous i o operations i.e.
findone a n d save in one request happen in order.
however the event order between two requests is non deterministic.
while fig.
shows an example of concurrency bugs due to non deterministic event handling.
this kind of bugs are rare since they only relate to non deterministic event schedule for the looper thread.
bug inducing api.
understanding which asynchronous apis are responsible for the racing events i.e.
events involv ed in a concurrency bug is important for understanding the root cause of a concurrency bug.
we categorize related apis into two categories s chedule api and high level api protocol .
schedule apis refers to native apis provided by node.js e.g.
settimeout process.nexttick and promise which are used to schedule deferred tasks.
the apis in node.js are usually developed in th e asynchronous and event drive style.
high level api protocol refers to the asynchronous and event driven specification that developers should follow when they use those apis.
the code snippet in fig.
shows a typical example for high level api protocol for a bundle before it is created by the create asynchronous operation no further actions on the bundle e.g.
uploadstr should be performed.
for another example a xlsx file extraction api provides two types of events row event issued when a row in the xlsx file is parsed and end event issued when the whole file is parsed.
the end event should be processed only after all row events have been processed.
bug xlsxextract does not respect this protocol and causes an exception.
table shows the statistics about bug inducing apis.
note that the remaining bugs are not related to schedule apis or wrong assumptions about high level api protocols.
for example two user request s trigger two events that modify the same variables non deterministically.
we exclude them in table .
x schedule api in node.js .
asynchronous operations can be scheduled by the commonly used schedule apis.
concurrency bugs schedule their events with schedule apis in node.js including settimeout process.nexttick setinterval setimmediate and promise .
thus these schedule apis can introduce non determinism to node.js applications.
x high level api protocol .
concurrency bugs are caused by improper high level api usage e.g.
bugs gp js client and xlsx extract .
the asynchronous or event driven style protocols are usually not clearly described or understood by developers.
thus developers may have wrong assumptions of the event order and or atomicity.
for example in bug sequelize a developer commented i would expect findorcreate method to be atomic.
however it just calls find and if unsuccessful it will call create .
in bug kue a developer commented the redis client.subscribe is asynchronous but that is completely ignored .
v. bug impacts we study the failure symptom of each bug to better understand how severe a concurrency bug is.
our studied concurrency bugs can cause fatal failures including crashes exceptions incorrect states wrong outputs hangs no respons e and other operation failures.
note that incorrect states and wrong outputs can also cause some operation failures.
to avoid double counting we consider a bug as causing operation failure s only when it does not cause incorrect states and wrong outputs.
crashes exceptions.
of the studied bugs can cause crashes or uncaught exception s e.g.
null pointer exception.
for example in bug hapi node.js crashes due to out of memory.
finding .
non deterministic event triggering and execution of asynchronous operations are two main sources of concurrency bugs while existing work only focuses on non deterministic event triggering.
bugs are caused by using high level api protocols in an improper way.
table .
bug inducing api cases order atomicity starvation total schedule api settimeout process.nexttick setinterval setimmediate promise api protocol table .
bug inducing phase order atomicity starvation total asynchronous operation event triggering event handling multi processes atomicity violation bugs shown in can be introduced by both non deterministic execution of asynchronous operations and event triggering.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
incorrect states.
of the studied bugs can cause incorrect states e.g.
incorrect persistence data in database.
for example in bug porybox the first update is lost in the database .
wrong outputs.
bugs can generate wrong results and present them to users.
hangs no response.
bugs can cause hangs or no response.
for example in bug fiware pep steelskin the application register s a listener for an event.
however an unexpected event may happen and remove the listener before it is triggered.
as a result the event cannot be processed correc tly.
operation failures.
the other bugs cause unexpected behaviors jobs getting processed incompletely jobs getting rejected job s getting processed twice i o starvation issues under heavy load and others e.g.
a server cannot be shut down normally.
vi.
bug manifestation understanding how concurrency bugs manifest themselves in node.js applications can provide useful implications on how to effectively detect and test concurrency bugs.
a. input preconditions while section iv.a presents the timing conditions of concurrency bugs this section focuses on input preconditions.
in practice many input conditions should be satisfied in order to trigger the concurrency bugs such as external requests application configuration and deploy environment .
for example in bug porybox two external requests with the same ownername are required.
otherwise this concurrency bug cannot be triggered.
table shows the input preconditions for our studied bugs.
external requests.
node.js is usually used to process user requests in server side applications.
these user requests are external to node.j s applications and can happen anytime.
as table shows bugs do not need any external request.
these bugs usually occur in desktop applications and libraries and they do not receive any external request.
bugs only need external request.
bugs need only concurrent requests and interestingly of them only require same requests with the same inputs e.g.
porybox .
for the remaining bugs they require different external requests.
only concurrency bugs require more than external requests.
we observe that about three quarters of the studied bugs can manifest themselves with no more than one external request or two same requests.
this indicates that inpu t preconditions are usually simple and developers can test their applications with simple input preconditions first.
the other bugs need relatively complicated conditions and are not easy to trigger.
they require at least two different external requests and may also require a specific order among them.
for example bug browser laptop is triggered only when three external requests are ordered as on off on.
configuration and deploy environment.
we observe that bugs require special configuration cases or deploy environment cases .
for example it requires specific databa se for bug five bells shared and certain node.js version f or bug asset smasher to be manifested.
b. racing resources racing resources usually denote the states of an application and a concurrency bug is introduced when these states hold unexpected or inconsistent values.
we categorize racing resources as shared variable database file and others.
shared variable .
bugs contend against shared variables.
shared variables are commonly used to store shared data in memory or as condition variables used for synchronization between callbacks.
database.
bugs contend against the data in database.
this usually happens when several database operations e.g.
query and update are not ordered or executed in an atomic region and cause inconsistency in the database.
f or example bug porybox in fig.
contends against database.
file.
bugs contend against files e.g.
bug cordovalib .
this usually happens when several file operations e.g.
read and write to the same file are not ordered.
other.
bugs do not have racing resources such as a starvation bug that is only s ensitive to event schedule.
c. triggering scope we analyze the triggering scope to provide a complexity measure of the triggering of a concurrency bug in node.js.
we use the following metrics to measure the triggering scope even ts asynchronous operations count node.js process count and racing resource count as shown in table .
events asynchronous operations.
for each concurrency bug we identify the smallest set of events asynchronous operations e so that a specific order of e can guarantee that the bug manifests.
as table shows most bugs only involve no more than events asynchronous operations.
this indicates that testing node.js applications and detecting concurrency bug s in node.js can be simplified to check no more events asynchronous operations without losing bug detection capability much.
finding .
all the studied concurrency bugs in node.js can cause severe consequences e.g.
crashes incorrect states hangs and operation failures.
finding .
three quarters of the studied concurrency bugs only require simple input preconditions.
of the studied bugs require special configuration or deploy environment.
finding .
a significant number out of of concurrency bugs contend against databases or files rather than variables.
table .
preconditions cases order atomicity starvation total external request configuration deploy environment the bugs shown in only require same external requests with the same inputs .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
involved node.js processes.
concurrency bugs only involve node.js process.
this indicates most concurrency bugs happen in one single node.js process and bug detection approaches only focusing on one node.js process can cover most concurrency bugs.
racing resources.
bugs race for only resource e.g.
a shared variable a file or an entity in database .
bug change propagation is a n example of racing for two shared variables the program makes a commit to database if certain conditions about two shared variable are satisfied.
vii.
b ug fixing a. fix strategies before we investigate how concurrency bugs in node.js were fixed in practice our intuition is that adding synchronization forcing orders among events asynchronous operations should be the most common way to fix concurrency bugs in node.js.
surprisingly it is not the case.
in total we summarize fix strategies that can fix out of bugs as shown in table .
only one quarter of the bugs were fixed by adding synchronization.
there are several potential reasons.
first it is difficult to enforce atomic intentions by forcing orders among callbacks or asynchronous operations.
second simply using synchronization on all the operations can lower the parallelization and thus degrade the performance.
therefore about three quarters of bugs were fixed without synchronization .
developers usually need to consider correctness and performance to decide the most appropriate fix strategies.
in t he following we describe these different strategies.
adding synchronization.
one quarter of concurrency bugs were fixed by changing the timing of callbacks or asynchronous operations.
node.js can use callbacks or equivalent async control flow libraries e.g.
async and syncify to add synchronization.
for example bug gp js client in fig.
was fixed by moving uploadstr into the callback of create line .
thus the order of these two asynchronous operations is enforced.
node.js can also use condition variables to enforce orders.
for example in the code snippet in fig.
two callbac ks lines and by process.nexttick should be invoked as an atomic region.
it uses a condition variable isprocessing to avoid concurrent processing of external requests.
if isprocessing i s true it just puts the new incoming request in a queue line and will reschedule it later.
an equivalent way to do this is u sing third party lock or mutex .
only out of atomicity violation bugs were fixed by adding synchronization bugs were fixed by using shared variables and bugs were fixed by using third party lock mutex.
most atomicity violation bug were not fixed by adding synchronization.
developers would try to fix these bugs by tolerating wrong event timing instead of preventing the buggy timing with synchronization.
bypassing.
bugs were fixed by bypassing code when certain variable conditions are satisfied.
order violation bu gs were fixed this way.
for example bug js ipfs results in calling a callback twice and finally throws an exception.
it was fixed by introducing a variable denoting whether the callback has been called to avoid calling it again.
atomicit y violation bugs were fixed by skipping code to avoid erroneous behaviors when its concerned variable is modified by an unexpected event i.e.
under buggy interleaving .
the fix of b ug strider just moves on if certain variable is not null.
tolerance.
bugs were fixed by tolerating the buggy event timing.
order violation bug was fixed by tolerating buggy timing.
for example b ug session was fixed by correcting the states of shared variables so that the following code can also run under buggy event order.
atomicity violatio n bugs were fixed by tolerating the incorrectly interleaved event s. for example the fix of bug fiware pep steelskin corrects the value of the concerned variable when it detects the variable is modified by an unexpected event s callback.
note that this kind of fixes are usually semantic related develope rs need to confirm how to update the corrupted states.
switching to atomic apis.
bugs were fixed by replacing current apis with their atomic versions.
for example bug porybox was fixed by replacing findone and save with the atomic api update which can do the same task in a single query supported by mongodb.
ignoring retrying.
bugs were fixed by catching the failure or retry ing the failed operation.
for example bug browser laptop was fixed by catching the error and showing it to users.
in bug done ssr the application launches the component can serve and live reload at the same time the can serve may get ready first and tr ies to send a request to the live reload server which has not started yet.
this bug was fixed by letting the can serve retry the request later.
moving code.
atomicity violation bugs were fixed by moving code.
their fixes merge the supposed atomic operations but separated in two callbacks together in one callback.
thus they are guaranteed to be executed atomically.
finding .
most concurrency bugs only involve no more than events asynchronous operations node.js process and resource.
table .
fix strategies fix strategies order atomicity starvation total adding synchronization bypassing tolerance switching to atomic apis ignoring retrying moving code data privatization changing priority other total table .
triggering scope cases order atomicity starvation total events asynchronous operations involved processes racing resources authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
data privatization.
bugs were fixed by making shared variables private under the same buggy context.
thus racing events callbacks cannot access the shared variables.
atomicity violation bugs were fixed by data privatization.
changing priority.
starvation bugs were fixed by adjusting the priorities of relevant events.
the event queues have different strategies as shown in section ii.a.
for exampl e recursively scheduling events by process.nexttick can starve the event loop since it has very high priority.
this can be fixed b y using setimmediate that has relatively lower priority.
similarly i o events can starve callbacks registered by setimmediate .
this can be fixed by using process.nexttick that has higher priority.
other.
the remaining bugs were fixed by various ad hoc approaches such as changing underlying c c node.js plugin code updating dependent databases and redesigning related data structure and code logic.
b. fix complexity to quantify the effort and complexity of fixing the concurrency bugs in node.js we use five metrics to measure the fix complexity the time to resolve the bug the number of bug comments among developers the patch size in terms of loc changed the number of patches submitted the number of shared variables introduced during fixing.
for the first four metrics we extract the corresponding information from the bug reports in github.
table shows the statistics of the first four metrics.
on average our studied bugs take days to fix have comments submit patches and have lines of code changed.
due to space constraints we do not provide further cross cutting analyses e.g.
how many bugs have patches with more than loc.
shared variables introduced in bug fixes.
due to lack of synchronous primitives e.g.
lock a n d wait notify shared variables are prevalently used for fixing concurrency bugs in node.js.
here we only count the number of shared variables which are used as condition variables for checking program states or to store state information for bypassing or toleranc e. the use of shared variables can complicate fixes since developers need to consider how to form the conditional statement and where to place it.
we analyze how many shared variables are introduced in the patches.
for concurrency bugs shared variables are used as condition variables or to store state information.
for these bu gs bugs use shared variable bugs use shared variables bugs use shared variables and bug uses shared variables.
for bug fixing bugs introduce new shared variables to fix bugs.
among these bugs bugs have used shared variables for preventing concurrency bugs but they were used in the wrong way.
the final patches fix them.
this also indicates fixi ng concurrency bugs with shared variables is difficult.
viii.
lessons learned we now discuss the lessons learned implications to existing tools and the opportunities for new research in combating concurrency bugs in node.js.
a. concurrency bug detection in node.js concurrency bugs in node.js can cause severe consequences finding and thus resolving these bugs is of great significance for the reliability of node.js applications.
since node.js is new concurrency bug detection tools are unfortunately rare.
our study provides some patterns and guidance that can facilitate future studies on concurrency bug detection in node.js.
pattern based bug detection.
finding implies that concurrency bug detection in node.js can focus on three simple bug patterns order violation atomicity violation and starvati on.
although there exists some concurrency bug detection tools in other event based systems like android and client side javascript they mainly focus on order violation.
atomicity violation bugs are not well addressed in event based systems yet.
however atomicity violation bugs are dominant finding .
thus new bug detection approaches should be developed to address atomicity violation in node.js.
resource o rient ed bug detection.
finding shows that a significant number out of of concurrency bugs contend against databases or files other than shared variables.
while existing concurrency bug detection tools mostly focus on shared variables i.e.
shared memory .
new approaches to detect concurrency bugs on these shared resources e.g.
databases and files are needed.
researchers may build the access models on these shared resources to facilitate concurrency bug detection.
api usage guided bug detection.
the asynchronous or event driven style protocols in node.js apis may not be clearly d e s c r i b e d a n d t h e n incorrectly understood by developers.
finding provides empirical evidence that automatically extracting protocols and checking api uses against the protocol s can be effective to detect concurrency bugs in node.js.
system testing.
testing plays an important role in exposing concurrency bugs.
however few testing techniques are proposed for node.js .
it is challenging to systematically test all possible event interleavings for node.js applications.
our finding implies that to reduce the test complexity developers can focus on testing applications with simple input preconditions for triggering most concurrency bugs.
however testing also needs to take configurations and deploy environments into consideration finding .
furthermore finding implies that testing can be simplified to check no finding .
most of the studied bugs can be fixed by a small set of fix strategies.
three quarter s o f t h e s t u d i e d bugs are not fixed by simply adding synchronization.
finding .
using shared variables to fix bugs are more often and error prone in a half of the studied bugs they use shared variables a s condition variables or state check recovery to prevent concurrency bugs.
one third of the fixes introduce new shared variables.
table .
fix complexity 25th percentile median 75th percentile max time of days of comments loc of final patch of patches authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
more than events in node.js process without losing bug detection capability much.
this will be more effective than testing all possible interleavings.
b. bug fixing in node.js recent studies on concurrenc y bug fixing mostly focus on multi threaded programs and fix bugs by inserting lock unlock .
due to lack of lock mechanism in node.js these approaches cannot be directly used for concurrency bugs in node.js.
arrow and eve ntracecommander fix order violation bugs using ad hoc synchronization for client si de web applications.
they need to take advantage of ui features e.g.
dom to build precise happens befo re model that node.js does not have.
further finding shows that using synchronization is not appropriate for most bugs in node.js.
future studies should consider other fix strategies e .g.
bypassing or tolerance and try to generate high quality fixes that are similar to human written ones.
c. api design and comprehension in node.js in node.js apis often are written in asynchronous and event driven style while developers may consider them as synchronous and non event driven apis.
finding indicates that developers can easily make wrong assumptions about how the apis are used and thus introduce concurrency bugs.
this indicates that good api specifications on their asynchronous protocols should be helpful to avoid concurrency bugs.
this als o presents a unique opportunity for developing and inferring good api usage patterns in node.js.
d. transaction suppor t in node.js finding shows two thirds of our studied bugs are atomicity violation bugs.
however no convenient way exists to express developers atomic intentions in node.js i.e.
two or more events should be processed without interruption .
in section vii.a we can see developers use some strategies to fix concurrency bugs e.g.
preventing other events from atomic regions atomic api consistency check and retry.
it is not eas y to adopt these fix strategies as they usually introduce condit ion variables state variables for recovery and so on.
however these strategies are similar to transactional memory tm .
based on our initial analysis about whether tm can help avoid the studied concurrency bugs we find that bugs can benefit from tm.
thus tm can be treated as an efficient approach to avoid concurrency bugs in node.js.
more studies are needed to design a simple and effective tm in node.js.
ix.
r elated work our study relates to a large body of existing work on detecting debugging and understanding for concurrency bugs.
in this section we discuss some representative work in bug studies concurrency bug analysis and program analysis.
bug studies.
there are some representative works on bug studies in javascript and concurrency bugs.
existing bug studies in javascript mainly focus on client side javascript applications .
many bugs in these studies relate to dom whereas node.js does not have dom.
these studies merely mention concurrency bugs.
only the study observes that non deterministic errors are common in web applications.
node.fz provides an initial study on a small set of concurrency bugs only bugs in node.js to help design a fuzzing tool for node.js.
whereas we perform a compressive study on concurrency bugs in node.js and obtain many new findings and implications e.g.
api misuse related concurrency bugs many new fix strategies various new statistics and lesso ns learned.
some studies have focused on concurrency bugs in multi threaded systems and distributed systems .
these studies have promoted a large amount of research on concurrency bug detection testing automated fixing and so on .
however the concurrency bugs in node.js differ from those in traditional systems as they originate from different programming paradigm s and execution environments.
concurrency bug analysis.
amounts of studies focus on concurrency bug detection testing reproduction and fixing in traditional programs e.g.
c and java .
in recent years much research effort has a lso been devoted to concurrency bugs in event driven applications e.g.
android and web applications .
our study shows that concurrency bugs in node.js have different characteristics in bug patterns manifestations and fix strategies from theirs.
thus those approaches may be ineffective for node.js.
our comprehensive study on concurrency bugs in node.js provides further motivations and guidance for future studies.
program analysis on node.js applications.
madsen et al.
build an event based call graph for a node.js application and then use it to statically detect bugs related to event hand ling e.g.
dead event listeners.
their tool is not designed for find ing and resolving concurrency bugs in node.js.
synode combines static analysis and runtime enforcement of security policies to allow vulnerable modules in node.js to be used in a safe way.
sahand builds asynchronous interactions for full stack javascript applications.
it captures the behavioral model of a full stack javascript application and provides scheduling lifelines of callbacks.
our study can open up new research directions on reliability issues in node.js applicatio ns.
x. c onclusion node.js has become one of most popular platforms for building server side applications.
applications built on node.j s face various non determinism and may contain intricate concurrency bugs.
this paper presents nodecb a comprehensive study on real world concurrency bugs in node.js.
we collect real world concurrency bugs from various open source node.js applications.
we examine their bug patterns roo t causes failure symptoms manifestation and fix strategies.
ou r study reveals many interesting findings which can promote future concurrency bug detection testing and automated fixing in node.js.
in the future we will design approaches and tools for detecting avoiding and fixing concurrency bugs in node.js.