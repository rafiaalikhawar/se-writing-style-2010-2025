towards refactoring aware regression test selection kaiyuan wang chenguang zhu ahmet celik jongwook kim don batory and milos gligoric the university of texas at austin iona college kaiyuanw cgzhu ahmetcelik utexas.edu jkim iona.edu batory cs.utexas.edu gligoric utexas.edu abstract regression testing checks that recent project changes do not break previously working functionality.
although important regression testing is costly when changes are frequent.
regression test selection rts optimizesregressiontestingbyrunningonlytestswhose results might be affected by a change.
traditionally rts collects dependencies e.g.
on files for each test and skips the tests at a new project revision whose dependencies did not change.
existing rts techniques do not differentiate behavior preserving transformations i.e.
refactorings from other code changes.
as a result tests are run more frequently than necessary.
we present the first step towards a refactoring aware rts technique dubbed reks which skips tests affected only by behavior preserving changes.
reks defines rules to update the test depen dencies without running the tests.
to ensure that reks does not hide any bug introduced by the refactoring engines we integrate reks only in the pre submit testing phase which happens on the developers machines.
we evaluate reks by measuring the savings inthetestingeffort.specifically wereproduce100refactoringtasksperformedbydevelopersof37projectsongithub.ourresultsshow that reks would not run on average of available tests that would be run by a refactoring unaware rts technique .
additionally wesystematicallyrun27refactoringtypesontenprojects.the results based on refactoring tasks show that reks would not run on average of tests max and sd .
finally our results show that the reks update rules are efficient.
ccs concepts software and its engineering software evolution keywords regression test selection behavior preserving changes reks acm reference format kaiyuan wang chenguang zhu ahmet celik jongwook kim don batory and milos gligoric.
.
towards refactoring aware regression test selection.
in icse icse 40th international conference on software engineering may june gothenburg sweden.
acm new york ny usa pages.
introduction regression testing runs available tests against each project revision to check that recent changes did not break previously working permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
although important regression testing is costly due toboththenumberoftestsandthenumberofrevisions asrecently reported by large software organizations including google and microsoft .
regression test selection rts techniques optimize regression testing by skipping tests that are unaffected by recent project changes.
traditionally an rts technique collects dependencies e.g.
statements methods or files for each test and then runs tests whose dependencies are modified.
rts is considered safe if it guarantees to select all affected tests under standard assumptions e.g.
there are no changes in the environment between test runs and preciseif it does not select unaffected tests.
many rts techniques have been proposed over the last several decades these techniquesdifferingranularityonwhichtheycollectdependencies.
for example ekstazi is a recent rts technique that collectsdependencieson files i.e.
ekstazicollectsfilesthatareused by each test class and runs a test class at the new project revision if any of its dependent files changes.
motivation .
despite recent improvements of rts techniques no rts technique specially treats behavior preserving changes i.e.
refactorings whicharecommoninpractice .our key insight is that formally proven behavior preserving changes d onotimpact the test outcomes and therefore no test needs to be run after refactorings.
however the existing rts techniques run all tests affected by refactorings e.g.
if a developer renames a method in class c and the method is used in class c prime ekstazi selects all tests that depend on either cor c prime.
in other words the existing rts techniques are imprecise i.e.
too conservative for changes made by refactorings.
technique .
we present the first step towards a refactoring aware rts technique dubbed reks which does not run tests that are affected only by refactorings.
at the same time because refactorings modify the structure of code dependencies for tests need to be updated e.g.
when a class is renamed from cto c prime each test that depended on the old class chas to depend on the new class c prime.
reks defines necessary rules to update the set of dependencies of each test after refactorings are performed withoutrunningthe tests.
these rules require a close integration of refactoring engines and rts tools.
whenever a user performs an automated refactoring the refactoring engine should notify reks about the filesthat are affected by the refactoring and the way in which those files are affected.
reks optimizes regression testing even in cases whenchanges are made by a mixof refactorings and manual nonrefactoring changes.implementation .
we implemented a prototype of the reks rules asalibrary whichcanbeeasilyintegratedintoanyide.wefurther integrated the reks library into eclipse via a plugin.
1we consider traditional refactoring types that are frequently integrated in ides e.g.
rename method extract method etc.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden k. wang et al.
pre submit testing post submit testing executed on local machine continuous integration system uses rts reks test case prioritization runs selected tests all tests figure recent work which involved google developers described a testing process that includes two phases pre submit and post submit .
pre submit testing executes only selected tests locally while post submit testing executes all testson a continuous integration system.
reks integratesintothepre submitphasetoskiptestsaffectedonlyby refactoring changes the integration into the pre submitphase ensures that potential bugs introduced by the refac toring tools will be detected in the post submit phase.
to ensure that reks does not hide any bug introduced by the refactoring engines we integrate reks only in thepre submit testing phase which happens on the developers machines .
large companies including google split testing into the pre submit and post submit phases to balance the testing load many other developers follow the same approach .
if any bug remains undetected in the pre submit phase the bug would be detected in the post submit phase that runsallavailable tests.
figure shows the way in which reks should be integrated into the testing process.evaluation .
we evaluated reks by measuring savings in the testing effort.
specifically we reproduced refactoring tasks performed by open source developers of projects on github .
our results show that reks would not run on average max and sd of available tests these tests would be run by a refactoring unaware rts.
additionally we systematically ran refactoring types on ten open source projects and measured the percent of tests not run due to reks and time to update the set of dependencies with the reks rules.
the results based on refactoring tasks show that reks does not run on average of available tests max and sd .
our experiments also revealedthatonly0.
testmethodsfailduetobugsinrefactoring engines.
although these bugs would be hidden in the pre submit testingphase thebugswouldbedetectedinthepost submittestingphase see figure .
finally our experiments show that the update rules are efficient regardless of the size of the target project.
motivating example this section illustrates an existing rts technique shows the limitations of the technique and other existing rts techniques and introduces a novel refactoring aware rts technique dubbed reks.
project.
consider the byte buddy project which is a popular light weightjavalibrarythatsupportsruntimecodegenerationandmanipulation the project is hosted on github.
at revision 35da279 thebyte buddy project had test methods in test classes that execute in about seconds.
developers then made several changes and obtained a new project revision f1dfb66 .
figures 2a and 2b show code before and after the change respectively.
thechange triggered the execution of all available test classes byte buddy projectusestheekstazitool .
ekstazi collects for each test class the set of dynamically accessed files.
the set of collected files includes both the executable e.g.
java classfiles and non executable e.g.
property files.
duringtheexecutionofthetestsatoldrevision 35da279 ekstazi would collect a set of dependencies for each test class.
figure 3a shows a subset of dependencies for three test classes.
each dependency is a pair of the file name and the checksum of the file.
after the developers make changes between 35da279 old and f1dfb66 new ekstazi analyzes the changes and runs only tests that are affected by the changes.
specifically to detect modified files ekstazicomputesthechecksumforeachfileandfindsthefiles whose checksum has changed.
any test that depends on at least one of the changed files is selected for the execution.
inourexample thedevelopersmodified abstractbase and forloadedexecutable files.
we can see in figure that some tests depend on the modified files and are selected.
specifically at new revision f1dfb66 ekstazi selects test methods in test classes out of test classes taking about seconds including time to find modified files .
additionally during the execution of the affected tests ekstazi collects new dependencies for these tests.
figure 3b shows the updated dependencies for our example.reks .
what is interesting about the changes between 35da279and f1dfb66is that these changes are refactorings i.e.
behavior preservingtransformations.specifically bymanuallyanalyzingthechange we found that a developer pulled up the wrap list parameterdescription methodfromsubclassestothesuperclass abstractbase between two revisions.
as we illustrated above ekstazi like other existing rts techniques is refactoring unaware i.e.
it runs tests affected by refactorings.
however behavior preserving changes d onot impact the test outcomes and therefore no test has to be run af ter refactorings.
we are aware that refactorings may introduce bugs as we discussed in the introduction.
reks is a novel rts technique that skips running the tests after refactorings but updates the dependencies for each test.
reks is builtontopofekstazi i.e.
itkeepsdependenciesonfilesanddefinesthe rules to update such dependencies.
in our example reks wouldnotrun any test between 35da279and f1dfb66 but it would update the set of dependencies to match those in figure 3b.
reks also supports mixed changes i.e.
changes with refactorings and other manual edits.
the following section defines the update rules.
technique this section formally introduces the reks update rules and section illustrates these rules using two refactoring types.
.
preliminaries wewrite pttodenotethestateoftheproject pattimet.ptincludes all files on disk at time t which belong to the project.
project revisions are states of the project that are observable in the versioncontrol system i.e.
commits on github .
there can be one or more changes between two project revisions .
atestsession identifies a point in time when tests were executed a test session is started either by a developer or a continuous integration system e.g.
travis ci .
for simplicity of exposition we assume that a test session runs all affected tests.
a test session authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards refactoring aware regression test selection icse may june gothenburg sweden abstract class abstractbase ... class forloadedexecutable extends abstractbase override protected parameterlist wrap list parameterdescription values return new explicit values ... ... a code before refactoringabstract class abstractbase override protected parameterlist wrap list parameterdescription values return new explicit values ... class forloadedexecutable extends abstractbase ... ... b code after refactoring figure2 anexamplerefactoringchangeinthebyte buddyproject.developersusedpulluprefactoringtomovethemethod wrapfrom sublasses e.g.
forloadedexecutable to their superclass abstractbase .
javamethodtest bytebuddycommons javamethod ... javainstancemethodtypetest abstractbase forloadedexecutable ... javainstancemethodhandletest abstractbase forloadedexecutable ... a dependencies for three tests at 35da279javamethodtest bytebuddycommons javamethod ... javainstancemethodtypetest abstractbase forloadedexecutable ... javainstancemethodhandletest abstractbase forloadedexecutable ... b dependencies for three tests at f1dfb66 figure impact of refactoring changes from figure on ekstazi dependencies.
a shows test dependencies for three tests beforerefactoringand b showstestdependenciesforthesametestsafterrefactoring.eachdependencyisapairofafileandits checksum.
we highlight the dependencies that are changed and tests that are affected between the two revisions.
can be triggered at any point in between revisions i.e.
pre submit testing phase .
we write poldto denote a project state after the latest test session.
a refactoringtask identifies a point in time when one of the refactoring types is invoked by a developer.
we writepmiddleandpnewto denote the states immediately before and immediately after the latest refactoring task respectively.
we define a sequence as a triple pold pmiddle pnew .
figure shows an example project timeline including revisions test sessions a refactoring task and a sequence.
wedefineafunction tests pt thatreturnsasetofavailabletests at the state pt.
similarly we define a function files pt that returns a set of files i.e.
normalized paths that belong to the project at the statept.
wewilluse casavariableoftypefile andfunction content pt c returns the content of the file at state pt.
we also define a function cksum content pt c that computes the checksum of the file s content as a string at state pt the function returns a special value if the file does not exist.
if the state is clear from the context we simply write cksum c .w eu s e sas a free variable of type string.
further we overload the cksumfunction to accept a project state as an argument i.e.
cksum pt .
this function returns a set of pairs c cksum c for all files at the state pt i.e.
cksum pt c cksum c c files pt .
we define a function deps pt s.t.
deps pt cksum pt where tests pt that returns a set ofdependencies i.e.
a set of c cksum c pairs for a given test inthegivenprojectstate.thesetofdependenciesforeachtestiscollectedbyacodecoveragetool .wewrite deps pt c cksum c to denote an addition of the pair c cksum c to the setofdependenciesof forstatept.similarly wewrite deps pt c s to denote a removal of the pair c s from the set of dependencies.
finally we write deps pt unionmulti c cksum c to denote an update of the set i.e.
deps pt unionmulti c cksum c deps pt c s c cksum c where sisanoldchecksumof c.theaddition removal and update are overloaded to also work with a set of pairs.
poldpnewpmiddleproject revisions test sessions refactoring task figure an example project development timeline that il lustrates revisions which are available in version controlhistory of the project test sessions which are points intime when developers run tests refactoring tasks whichare points in time when developers run one of the refactorings and various project states.
we define a function diff pold pnew that returns a set of modified files between two states i.e.
diff pold pnew c prime c files pold c prime files pnew cksum c nequalcksum c prime c c prime .
we also define functions that return sets of added and deleted files i.e.
added pold pnew c c nelementfiles pold c files pnew anddeleted pold pnew c c files pold c nelementfiles pnew .
devdenotes files that are added modified and deleted by developers in a single sequence pold pmiddle pnew i.e.
dev diff pold pmiddle added pold pmiddle deleted pold pmiddle .
similarly rftdenotes a set of files that are modified by the invoked refactoring i.e.
rft diff pmiddle pnew .
further we write filesto denote a set of file pairs that describe replacements of files i.e.
the first file of each pair is a file that is replaced with the second file of the pair.
similarly we write elemsto denote a set of file pairs such that some code elements e.g.
methods or fields from the first file are moved to the second file both files exist after the elements are moved.
the last three sets rft filesand elems canbeextractedfromtherefactoringengine when a refactoring task is invoked.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden k. wang et al.
.
update rules let pold pmiddle pnew be a sequence.
we define three rules to update the set of dependencies for at statepnew where tests pold tests pnew .
modifieddependencies .forthesetofdependenciesthataremodified by the refactoring engine rft we have to recompute the checksum for each of these dependencies.
however we do not update the checksum of the dependencies that are also modified by the developers dev in the current sequence.
deps pnew deps pold unionmulti c cksum c c rft c nelement dev c s deps pold replaced files .
for each pair of files that describes a file replacement files we have to remove the old file from the set of dependencies and include a new file in the set of dependencies.
as in the previous rule we have to skip the files that are modified by the developers dev prior to file replacement in the current sequence.
therefore we update the set of dependencies as follows deps pnew deps pold c s c c prime files c nelement dev c prime cksum c prime c c prime files c nelement dev c s deps pold moved elements .
for each pair of files that identifies movement of some code elements from one file to another elems we have to include the file into which the elements are moved to the set of dependencies.
at the same time we keep the file from which the elements are moved in the set of dependencies.
deps pnew deps pold c prime cksum c prime c c prime elems c prime nelement dev c s deps pold rules and are mutually exclusive because the former requires that the first element of each file pair does not exist at pnew and the latter requires that the first element of each file pair exists atpnew.
rule and rule rule always commute for a single sequence.
.
advanced considerations added and removed tests .
there is no need to specially treat newly added tests i.e.
nelementtests pold tests pnew .
these tests will have no associated dependencies initially so they will always be selected by the rts technique .
deleted tests i.e.
tests pold nelementtests pnew donotrequirespecialtreatment either because their set of dependencies will not be used in the subsequent test runs .relaxeddefinitionofasequence .intheupdaterules weassume that each sequence starts with a test session and ends at the time of the first subsequent refactoring task.
this means that there can be an arbitrary number of manual changes between a test session and a refactoring task but there has to be at least one test session between two refactoring tasks.
we set this requirement only to simplify the definition of diff added anddeletedfunctions there is no such limitation in our implementation.
this requirement is relaxed by computing the modified added and deleted files at every refactoring invocation by comparing the file checksum witheither the checksum at the previous refactoring task or previous test session whichever one is the latest in the project development history and then taking the union with already existing sets of modified added and deleted files.
overapproximation .
rule may lead to an overapproximation of the set of dependencies.
namely if usedonlythe moved elements in the original file then does not have to depend on the original file after the elements are moved.
however we are unable to identify if should not depend on the original file any more because we keep the set of dependencies on files and we do not know the reason why depended on that file in the first place.
this is not a problem however because overapproximation of the set of dependencies does not impact the safetyof regression test selection .
we can reduce the overapproximation by reasoning about each refactoring type independently.
for example consider the movemethod refactoring that moves an instance method from file c to c prime.
based on our rule we would always add c primein the set of dependencies.
however based on the definition of move method refactoring at least in the eclipse jdt there is no way that the test could start depending on c primein this case.
although case analysis could be interesting it would lead to a less elegant solution and it would be specific to a refactoring engine.
update rules illustrated this section illustrates the reks rules using the move method and convert anonymous to nested refactoring types that are available in the eclipse jdt .
we chose to present move method because it is one of the most frequently used refactorings in practice .
we chose convert anonymous to nested because it createsanewfileandithassignificantimpactonregressiontesting section .
in this section with the goal to simplify the presentation we assume that a developer runs a test session prior to each refactoring task i.e.
pold pmiddle.
.
move method move method refactoring moves the selected target method from file cto c primeand updates all