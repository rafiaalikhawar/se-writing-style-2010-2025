dapanda detecting aggressive push notifications in android apps tianming liu1 haoyu wang1 letter l il i2 guangdong bai3 y ao guo4 and guoai xu1 1beijing university of posts and telecommunications beijing china 2monash university australia3the university of queensland australia 4key laboratory of high confidence software technologies moe peking university beijing china abstract mobile push notifications have been widely used in mobile platforms to deliver all sorts of information to app users.
although it offers great convenience for both app developers and mobile users this feature was frequently reported to serve malicious and aggressive purposes such as delivering annoying push notification advertisement.
however to the best of our knowledge this problem has not been studied by our research community so far.
to fill the void this paper presents the first study to detect aggressive push notifications and further characterize them in the global mobile app ecosystem on a large scale.
to this end we first provide a taxonomy of mobile push notifications and identify the aggressive ones using a crowdsourcing based method.
then we propose dapanda a novel hybrid approach aiming at automatically detecting aggressive push notifications in android apps.
dapanda leverages a guided testing approach to systematically trigger and record push notifications.
by instrumenting the android framework dapanda further collects all notificationrelevant runtime information to flag the aggressive ones.
our experimental results show that dapanda is capable of detecting different types of aggressive push notifications effectively in an automated way.
by applying dapanda to android apps from different app markets it yields over aggressive notifications which have been further confirmed as true positives.
our in depth analysis further reveals that aggressive notifications are prevalent across different markets and could be manifested in all the phases in the lifecycle of push notifications.
it is hence urgent for our community to take actions to detect and mitigate apps involving aggressive push notifications.
index t erms push notification dynamic analysis advertisement android mobile app i. i ntroduction since the mobile push notification service was introduced by apple in it has been widely adopted in various mobile platforms including android .
in essence it provides a mechanism to display messages outside of the normal interface of a mobile app usually in the status bar at the top of the screen .
push notifications are generally used by app developers to deliver various kinds of information such as timely reminders and up to date messages e.g.
location based messages and new content available in news .
push notifications could be delivered without a specific request from the app which means that the app does not have to be relaunched during the process.
users can directly react to the notification by simply tapping on it providing timely information and allowing quick and easy responses for the names of the first two authors are in alphabetical order.
haoyu wang is the corresponding author.
rx uhfhlyhg d uhg hqyhorsh 2qo wrgd kxuu xs dqg folfn wklv lqna popular free starshared by lock wuhph 7hpswdwlrq fig.
.
motivating examples of aggressive and malicious push notifications.
app users.
the notification interfaces are further allowed to be customized by developers to provide flexibility and better user experiences.
thanks to these benefits push notifications have been favored by both mobile users and app developers and hence been extensively integrated into modern mobile apps.
because notifications can effectively push an app into the user s attention app developers are encouraged to utilize push notifications for re engaging mobile app users.
however despite users are generally in favor of push notifications the abuse of such notifications can still annoy app users and likely result in user complaints.
for example a number of reports revealed that app developers have been abusing push notifications for various purposes .
in addition to the way notifications are pushed recent studies reveal that app users are likely to also complain about the contents delivered in the notifications .
for example bell argues that facebook has a notification problem and enumerated most annoying push notifications from facebook .
most of these notifications are considered as annoying because their contents are considered inappropriate by users.
specifically app users especially hate notifications that contain advertisements .
actually both google and apple have released strict policies to regulate the use of mobile push notifications push notifications must not be required for the app to function and should not be used for advertising promotions or direct marketing purposes or sending sensitive personal or confidential information .
unfortunately despite that mobile push notifications are explicitly disallowed to deliver ads and promotions by app markets many app developers appear to be still enticed to such practices and even employing more sophisticated methods so as to avoid being caught during app vetting.
as shown in fig.
34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a it is an ad related push notification while the interface of this notification has been customized such that it does not explicitly mention which app it belongs to.
the most annoying part is that it tricked the user into clicking the notification and the link will be redirected to a page full of ads.
this suggests that even though both google and apple have declared strict policies it is still difficult for app markets to automatically regulate the apps that violate the policy such that anomalous apps are still able to sneak into app markets and mobile devices.
consequently annoying notifications are frequently pushed to mobile app users in the real world.
more seriously push notifications could also be exploited for malicious purposes.
fig.
b shows a push notification triggered from the app com.keeeweee.lockscreen .
the annoying part of this notification is that it cannot be closed by the users i.e.
mobile users have to click it.
even worse once the user clicks it an app downloading process will be triggered immediately specifically app upyel.patyzbg.vbxsoef.kncp.cbsmk.rnnbs will be downloaded and the installation ui will pop out.
when we uploaded this downloaded app to virustotal over antivirus engines flagged it as malicious .
this example suggests that push notifications could be used as a new covert channel to spread malware which has been largely overlooked by our community.
in this work we refer to such annoying and even malicious notifications as aggressive push notifications apns for short .
to the best of our knowledge except for some sporadic news reports discussing specific instances of apns our research community has not studied this problem systematically and hence no research tools have been proposed to detect and mitigate the occurrences of apns.
this paper seeks to develop an automated approach to detect apns and further dissect mobile push notifications and characterize their behaviors in large scale.
to that end we first provide a taxonomy that characterizes a variety of apns based on a comprehensive user survey and a summary of market policies.
towards the automated detection of apns we aim to address several key challenges how to automatically trigger push notifications efficiently?
as push notifications are displayed outside of the normal uis of a given app no existing tools explicitly support automated testing of push notifications e.g.
identify the notification views .
besides apns could be triggered in either the foreground or background.
thus we need to develop a new approach that is scalable enough and also ensures good coverage of apns.
how to accurately identify the content and network traffic from push notifications?
as push notifications are running within the hosting app the network traffic triggered by push notifications would be mixed together with the traffic generated by other parts of the app e.g.
banner ads or the contents in the main activities .
as we seek to characterize the malicious contents delivered by push notifications it is important to pinpoint the corresponding content accurately.
how to trace the origins of apns?
mobile push notifications could be implemented by the app developers or third party libraries e.g.
google cloud messaging .
in addition to detecting apns we also seek to trace back to the origin of apns i.e.
analyzing who should be responsible for the aggressive behaviors e.g.
app developers or ad networks .
to address the aforementioned challenges we propose dapanda detecting aggressive push notification in and roid apps a novel hybrid approach that supports accurate detection of apns.
d apanda mainly relies on two key techniques to characterize the behaviors of mobile push notifications at runtime.
to trigger push notifications efficiently we have proposed an app queuing approach to enforce automated exploration of push notifications.
to accurately pinpoint the information related to each notification we have implemented aninstrumentation method that integrates call stacks and intercomponent tracing to record all necessary information to detect apns.
finally we use a manually crafted benchmark set to demonstrate the effectiveness of d apanda .
to further characterize the presence of apns in the wild we have applied d apanda to android apps crawled from popular app markets including google play.
we have identified over apns from apps which accounts for over of the apps studied in this work.
with further inspection we have also found that a large portion of these apns were originated from aggressive third party libraries.
this paper makes the following main contributions we have created a taxonomy of apns in a systematic way.
to the best of our knowledge this is the first work that is focused on detecting and characterizing aggressive malicious push notifications.
we have implemented d apanda a new approach that is able to expose push notifications with an automated exploration strategy and then characterize the behaviors of apns accurately.
we have performed a large scale measurement study by applying d apanda to apps seeking to measure the phenomenon of apns in the wild.
we have revealed the severity of apns in the mobile app ecosystem and further investigated the underlying working mechanisms behind apns.
to boost research along this direction we have released the benchmark and our experiment results at ii.
a t axonomy of aggressive push notifica tions in order to automatically identify apns we seek to explore why push notifications were considered as aggressive and what types of apns exist in the mobile app ecosystem.
to this end we resort to a straightforward approach to understanding push notifications manually.
this manual process allows us to form a taxonomy of all possible types of push notifications cf.
ii a .
we then leverage the taxonomy to confirm apns using a crowdsourcing based approach i.e.
following the opinions authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of android app users responded in a survey and the policies given by app markets cf.
ii b .
a. a taxonomy of android push notifications hkdylru rqwhqw dfnjurxqg 3xvk qrq prxv 3xvk 0dolflrxv rqwhqw ulyh e rzqordg gyhuwlvlqj rqwhqw 8sgdwlqj rqwhqw 1rupdo rqwhqw uhtxhqw 3xvk rpsxovlyh 3xvk 1rupdo hkdylru 3xvk 1rwl fdwlrq fig.
.
a taxonomy of push notifications.
the first step is to understand the characteristics of android push notifications and their types.
we resort to various sources including android documentation news reports user comments about annoying push notifications on app markets as well as running different android apps ourselves.
in the end we have created a taxonomy of android push notifications from two different aspects as listed in fig.
.
the first aspect is concerned about the pushing behavior based on the way notifications are pushed displayed to mobile users.
we found four specific types for this category and regard all remaining scenarios as the normal behavior type1.
the specific types are explained as follows background push.
the notification would be triggered while the hosting app is running in the background.
compulsive push.
in general a notification could be canceled or cleared by swiping it or clicking the clear button provided by the system.
however some intrusive notifications cannot be canceled i.e.
users are forced to click it.
such kind of push notifications is caused by the misuse or malicious use of push notification configurations.
two flag fields flag ongoing event and flag no clear are related to this behavior.
aggressive malicious developers might intentionally set the flag and force users to click these notifications.
anonymous push.
in general push notifications should explicitly show the icons and names of their hosting apps.
however anonymous push may deliberately hide its hosting app from mobile users cf.
fig.
.
1note that the normal behavior type may also contain some other types of abnormal behaviors however because we cannot assign them a specific type we will consider them as normal in this taxonomy.
it is the same for the normal content type discussed later in this section frequent push.
it refers to the situation where a number of notifications are pushed from the same hosting app during a short period of time e.g.
less than minutes .
for the second aspect we are concerned about the contents of the push notifications including both the contents displayed and the redirected contents after clicking.
we have also observed four specific types in this aspect as follows putting the rest into the normal content type advertising content.
it refers to a notification that contains advertising content which is explicitly disallowed by both google and apple.
in general it is non trivial to detect whether the content is ad related or not.
thus in this paper we regard the push notifications originated from advertising libraries as ad push which is a reasonable assumption and we will further discuss it in section v. updating content.
it refers to a notification that serves as a reminder of updating or downloading app related resources.
for example such push notifications would always remind users to update the app with contents like new version found need to update .
drive by download.
this kind of notification may trigger unintentional downloads e.g.
of advertised apks when a user clicks the notification without requiring user confirmation.
such behaviors often heavily impact user experience and in most cases drive by downloads cannot even be easily canceled.
malicious content.
this category refers to such notifications that after clicked may jump to landing pages where malicious content is presented or trigger the downloading of malicious files e.g.
apks .
with this taxonomy we are able to classify each push notification into one or more types considering both their behavior and content .
for example a push notification that is frequent and with advertising content will be classified into the frequent advertising type.
ideally we could have as many as different types including the normal behavior normal content type .
however since frequent updating and anonymous updating are not possible in practice we did not take these two types into account.
finally we have obtained different notification types based on our taxonomy.
note that while this taxonomy covers most common cases of push notifications it is not completely orthogonal.
the actual push notification may belong to more than one behavior type and more than one content type simultaneously.
for example the motivation example shown in fig.
b belongs tocompulsive and anonymous behavior types and malicious drive by download and ad content types.
b. user survey although we are now able to classify mobile push notifications into different types based on their behavior and content aspects we still do not know which types are considered to be aggressive as no previous studies have characterized them.
instead of labeling them ourselves we seek to adopt a crowdsourcing based approach i.e.
assigning the level of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
the survey results.
the green cell stands for benign and not aggressive at all the yellow stands for disturbing to users but not aggressive and the red ones stand for aggressive cases and the deeper the color the more aggressive it is from users perspective.
overall ones in red are regarded as apns.
aggressiveness of all possible types of the push notifications from the perspective of real android app users in order to confirm which notifications are more likely to be apns.
survey design.
based on the taxonomy we created cf.
fig.
we further embed it into a likert scale online survey to measure the aggressiveness for each type of notifications.
participants in the survey with the experience of using android mobile devices and the basic understanding of mobile notifications were provided with types of push notifications together with example screenshots and their explanations.
the details of the user survey could be found at the project on github .
participants are asked to grade each type of push notification from a level of to based on its aggressiveness which is defined as follows 1stands for benign and not aggressive at all.
2stands for disturbing to users but not aggressive.
3stands for somewhat aggressive.
4stands for aggressive.
5stands for extremely aggressive.
to encourage users to respond to our survey we pay us dollars to the person who responds to our full survey.
eventually our online survey receives effective responses which is a fairly representative number considering the difficulties to encourage people to answer online surveys .
survey result.
the responding results are illustrated as a heatmap in fig.
.
this heatmap is drawn based on the average scores by all respondents.
following the convention of likert scale in this work we define five aggressiveness levels benign disturbing somewhat aggressive aggressive and extremely aggressive which are regarded as such if the average score of all the responses falls into ranges respectively.
in this work we consider such combinations that have an average score higher than three as apns .
eventually as shown in fig.
combinations fall into this category and hence are regarded as apns.
c. market policies after identifying the types of apns we go one step deeper to check if some of the notification types which are considered to be aggressive by app users have been explicitly restricted by market policies.
app markets have responsibilities and incentives to regulate app behaviors that may lead to dissatisfaction of users.
when using apps with apns users may not only complain about the app itself but also complain about the market where the app is downloaded from.
to thist able i apn rela ted policies declared by app markets .
beha vior content freq anonymous compulsive bkg malicious drive by ad update gplay huawei tencent push exploration foreground ba ckground app queue vieetree click push source targetnetwork trafficinstrumented android frameworkapn detection behavior based detection content based detectionapns fig.
.
overview of d apanda .
end we crawl the policy descriptions from several android app markets including google play and manually go through them to check if the policy has explicitly mentioned that certain types of push notifications are not allowed by the apps submitted to its market.
as illustrated in table i market policies have explicitly disallowed malicious pushes ad related pushes and anonymous compulsive pushes which are generally in line with the choice of users from our survey providing concrete evidence to confirm the correctness of our survey results.
note that the market polices are generally coarse grained while our survey results have extended the policies with more detailed combinations.
iii.
a pproach aiming at systematically detecting apns in android apps we propose a dynamic analysis approach called d apanda for automatically exploring and characterizing push notifications.
fig.
illustrates the working process of d apanda which is mainly made up of three modules automated exploration of push notifications.
this module leverages automatic android gui traversal techniques for triggering the appearance of push notifications and clicking subsequently the pushed notifications.
framework instrumentation.
this module aims at hooking relevant methods for capturing runtime information of push notifications e.g.
how is a push notification triggered and consumed?
.
aggressive push notification detection.
this module follows the pre defined definition of apns to identify the aggressive ones from all the triggered notifications utilizing the information collected in the instrumented framework after the completion of automated gui exploration.
a. automated exploration of push notifications the general idea of this module is to identify and understand the layout of push notifications by constructing the corresponding view trees of each ui page and click the notifications by simulating the touch events at runtime.
since push notifications could be triggered in both the foreground and background existing ui exploration tools focused on a single app becomes ineffective thus we propose a new exploration strategy called authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
app queuing aiming at exploring as many push notifications as possible.
app queuing the key idea of app queuing is that instead of quitting the app directly after running it in the foreground which has been done by almost all the stateof the art app testing approaches we will put the app into the background allowing silent notifications to be still pushed.
additionally the app queuing approach can also improve exploration efficiency.
in practice although only one app runs in the foreground more than one app could run in the background which allows us to test multiple apps at the same time.
specifically our exploration strategy maintains an app queue structure with three principal operations insert which adds an app to the app queue and automatically tests it in the foreground downgrade which puts the app into the background and remove which removes an app from the queue based on their arriving order fifo .
during exploration we can configure the capacity of the queue nand the foreground execution time tffor each app.
specifically napps are allowed to be concurrently tested in our system and each app is running in the foreground fortfseconds.
when experimenting on a large set of apps we follow the fifo principle as in the queue structure i.e.
once an app runs in the foreground for time tf we will put it into the background.
once the app queue reaches its capacity n the app at the rear of the queue who enters the queue earliest would be removed and further be closed and uninstalled making room for new apps.
note that each app runs in the foreground fortftime and in the background for n t ftime thus n tf time in total while the expected average execution time for each app is still tf.
to ensure each app strictly follows this strategy and prevent exceptional cases e.g.
app crash or interference of concurrent running apps our system monitors the execution states e.g.
use adb shell command dumpsys activity top to query the foreground activity at runtime for every seconds.
once exceptional cases are found our system will either revoke the app back to the foreground or restart the app e.g.
use adb shell command am start with the launcher activity of the app .
view tree based ui exploration for each app we split the ui exploration into two phases exploration of in app uis to trigger push notifications exploration of notification uis to identify push notification views and click them.
thus we can not only trigger the corresponding behaviors but also harvest their distribution contents.
exploration of in app uis.
in this work we plan to trigger push notifications by exploring apps with randomly generated ui focused test inputs as the occurrence of push notification is unpredictable without the knowledge of predictable trigger points.
however some apps present welcome pages or user agreements on their first run during the experiment which may stop us from triggering the main app functionality.
therefore we take advantage of a model based ui input generation method here.
during the exploration of the in app ui we propose to analyze the view tree of each ui state and then apply the dfs depth first search algorithm to generate the possibleinput events in order to trigger the functionality of the app.
fig.
a shows an example of the view tree we constructed during in app ui exploration.
exploration of notification uis.
in order to fully exploit the app queuing mechanism we decide to explore the notification related uis when the testing app switches its state from running in the foreground to running in the background.
during this interval before the next app runs in the foreground we first simulate the swipe down action on the status bar to open the notification drawer where we can view more details and take actions with the notification.
we then get the view trees of the current state notification drawer based on google accessibility .
fig.
b shows an example of the view tree we constructed for a notification drawer.
three framelayout nodes are laid at the bottom and each of them corresponds to a notification view which is also a tree like structure as shown in fig.
c .
we can retrieve the notification related information from the view tree including its coordinates text messages resource id the package name of the original app.
finally with the retrieved coordinate information we click on the notification view accordingly by simulating a click event at the center of the view.
this process would be repeated several times if we found more than one notification views.
note that we only click once for each unique push notification.
b. framework instrumentation the objective of this phase is to collect all the necessary information relevant to push notifications mostly the ones that could be useful for characterizing apns.
specifically in order to accurately identify apns we seek to collect three types of runtime information.
as shown in fig.
which illustrates the typical working scenario of push notifications the following three types of runtime information are needed the source where the notification is pushed to the system the target where the execution will jump to after the notification is clicked and the network traffic triggered by the consumption of the notification.
unfortunately it is not straightforward to collect some of the aforementioned information.
for example it is difficult to track the source where the notification is pushed .
furthermore although it is relatively easy to collect all network traffic after a notification is clicked e.g.
via tcpdump it is still difficult to locate the app that has actually generated those traffic as there are always multiple apps running at the same time .t o this end we propose an instrumentation based approach in which we leverage the xposed framework to hook all the notification relevant methods to collect the app execution logs on demand.
the xposed framework allows us to collect the runtime information of tested android apps without actually instrumenting the apk.
we only need to set up the framework once and it works for all the apps to be tested.
table ii summarizes the key methods hooked by the instrumentation module in order to extract runtime information that our approach is interested in i.e.
the runtime information involved in the lifecycle of push notifications .
listing further authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dqgurlg zlgjhw udph d rxw9lhz 7uhh dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw xwwrq .
rxqgv dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw 7h w9lhz orvh rxqgv a the view tree of a user agreement.
dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw 7h w9lhz9lhz 7uhh dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw udph d rxw rxqgv dqgurlg zlgjhw udph d rxw rxqgv dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw 6furoo9lhz dqgurlg zlgjhw udph d rxw rxqgv b the view tree of a notification drawer.
dqgurlg ylhz 9lhz dqgurlg zlgjhw pdjh9lhz9lhz 7uhh dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw udph d rxw rxqgv dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw 7h w9lhz ffhvv hvwxuh doo dqgurlg zlgjhw 7h w9lhz dqgurlg zlgjhw 7h w9lhz hvwxuh doo rqdwh uhvrxufhblg dqgurlg lg vwdwxvbedubodwhvwbhyhqwbfrqwhqw erxqgv sdfndjh df jhvwxuh doo3ur c the view tree of a typical push notification.
fig.
.
constructing the view tree of push notifications.
stack tracing sourceicc targetpushing clickingnotification network traffic fig.
.
the life cycle of a standard mobile push notification and the corresponding information we collected in gray .
t able ii key informa tion extracted with framework instrument a tion .
cate gory specific info method sourcepackagename api hooking notificationmanager.notify service.startforeground title texts icons images flags resourceid notificationid source classname call stack tracing targetintent api hooking pendingintent.getactivity getactivities getbroadcast getservice target classname netw ork trafficclassname of url api hooking and trace call stacks in network module packagename of url drive by download api hooking execstartactivity packagename text extracted from viewtree urlsextracted from pcap filedownloaded files illustrates the detailed runtime information we could collect with the instrumentation module.
notification source we mainly retrieve two types of information for the notification source.
the first is necessary configuration information the other one is the origin of the push notification e.g.
the class that issues it .
during the implementation of push notifications the developers would need to specify the detailed configurations.
some of them could be obtained during runtime from the view trees e.g.
text and icon while some others cannot e.g.
flags .
thus we have instrumented a list of apis that can push notifications including android.app.notificationmanager .notify and android.app.service.startf oreground to get the instances ofnotification and then we further get the configuration data by checking the corresponding properties as show in table ii.
source 2source classname com.appquanta.dll.cookiemanager.ag 3packagename cn.happyeclub.tjraduyy 4title texts come and buy!
click to see details.
5icons images .jpg 6flags flag ongoing event 7resourceid of templates notification template base 8notificationid target 11intent 12flg 0x18800000 13cmp cn.happyeclub.tjraduyy com.appquanta.wk.mainactivity has extras from api getactivity 15target classname com.appquanta.wk.mainactivity network traffic url http c1.apkads.com get w 3d991cf 380d8422ab581e69f8cdc0a3c.
.
.apk 20classname of url com.appquanta.dll.cookiemanager.be 21packagename of url cn.happyeclub.tjraduyy url http alog.umeng.com app logs 23classname of url com.umeng.analytics.g 24packagename of url cn.happyeclub.tjraduyy 25drive by download apk file storage emulated download com.yiqimmm.apps.android .zip below are from pcap 29packagename text messages cn.happyeclub.tjraduyy come and buy!
click to see details.
30url c1.apkads.com get w 3d991cf380 d8422ab581e69f8cdc0a3c.
.
.apk 32alog.umeng.com app logs 33downloaded files 3d991cf380 d8422ab581e69f8cdc0a3c.
.
.apk listing .
an example of obtained runtime information.
com.example.pushhook.hook .afterhookedmethod hook.java de.robv.android.xposed.xposedbridge.handlehookedmethod xpo sedbridge.java android.app.notificationmanager.notify native method android.app.notificationmanager.notify notificat ionmanager.java com.appquanta.dll.cookiemanager.ag.run unknown source notification load method fig.
.
an example of stack traces.
to trace the origin of push notifications we apply a call stack based method.
from the notification instance we located via instrumentation we log its call stack and further pinpoint the package and class issuing this notification.
fig.
shows an example of a call stack we harvested at runtime.
in the example the notification is implemented by an ad library called authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
quanta where we can trace to its load method from the call stack.
note that to further assist our source tracing our system also integrates a third party static library detection tool which could help us flag the possible ad libraries and push libraries even if in the form of naming obfuscation e.g.
com.a.b.c .
in this work during our implementation we have embedded libradar and based on which we have labeled over ad libraries and push libraries.
notification target the actual target of each push notification i.e.
the component it connects to is essential for us to identify the actual traffic triggered by the corresponding push notification.
the target component is set via a pendingintent a special intent that can take an action in the future.
after the notification is clicked the pending intent will be sent to the system.
following the inter component communication mechanism the appropriate target component will be activated to execute in the foreground.
thus our goal is to demystify the corresponding intent .
in android there are two forms of intents explicit intents and implicit intents .
explicit intents specify the target component i.e.
via the cmp attribute which can be directly inferred.
however for implicit intents the value of cmp is not directly set but via several special attributes such as action category etc.
these attributes will be leveraged by the system to locate the target components which should have declared an intent filter with the same attribute values.
by instrumenting a series of apis getactivity getactivities getbroadcast getservice under android.app.pendingintent we can acquire the value of intent concerning three types of components in android activity service and broadcast receiver.
we check the cmp attribute value to directly locate target components for explicit intents e.g.
line in listing .
for implicit intents we resort to the intent and intent filter matching mechanism to pinpoint the target component.
normally the intent filter contents can be extracted from the manifest configuration file of android apps e.g.
lines in listing .
however this is not always true for broadcast receivers in which dynamic intent filters can be registered without mentioning in the manifest file.
to this end we additionally hook method android.app.contextimpl.registerreceiverinternal the underlying implementation of api registerreceiver t o further include dynamically registered intent filters e.g.
lines in listing .
network traffic for each push notification clicked a pcap file is generated using tcpdump to record its network traffic.
we also gather the package name of the source app that pushed the notification via the view tree.
this package name will be used to check whether the notification is triggered by the app running in the foreground.
we then analyze the pcap files using bro where several scripts are further introduced to extract contents from the traffic.
to further pinpoint the notification traffic we have instrumented a list of network apis in httpclient httpurlconnection and okhttp which are widely used networking modules.
by hooking and tracing the call stacks of these key apis we1 explict intent 2intent flg 0x24000000 cmp be.ppareit.swiftp free be.ppareit.swiftp.gui.fspreferenceactivity implict intent targetting statically registered component 6intent act com.zhiyoo.update click has extras 7androidmanifest.xml registration info receiver android name com.zhiyoo.app.bbsreceiver intent filter action android name com.zhiyoo.update click ...... intent filter receiver implict intent targeting dynamically registered broadcast receiver 16intent act com.unipay.secservice.action.sync has extras 17instrument api android.app.contextimpl.registerreceiverinternal 18intentfilter.mactions com.unipay.secservice.action.sync 19broadcastreceiver com.unipay.xiaowo.pluginmgr.plugin1 .mybroadcastreceiver listing .
three types of intents and their target components.
can acquire the urls in the network traffic and the origin package that triggered the urls cf.
line in listing .
the extracted information will help identify network traffic introduced by the corresponding push notification.
for example as shown in listing the traffic of umeng analytics does not belong to the push notifications as its origin package cf.
line does not equal to the package of notification target cf.
line .
note that as drive by download notifications would trigger app downloading first and then pop up an installation activity interface provided by the system we further instrument the api execstartactivity to capture this behavior.
c. aggressive push notification detection as demonstrated in fig.
push notifications are categorized from two aspects runtime behavior and notification content.
with the runtime information collected we are now able to detect apns based on our taxonomy.
behavior based detection.
it is quite straightforward to characterize a given push notification to the specific types of notifications based on the behaviors specified in fig.
.
for example we regard a notification as a background push if it is not pushed by the foreground app compulsory push if flag ongoing event orflag no clear flags are enabled and frequent push if three or more notifications with different notification id are pushed from the same app within two minutes.
regarding the anonymous push since android .
the system forces notifications implemented with system templates to display its source app name .
in order to keep pushing anonymous notifications app developers are required to implement customized templates.
we are able to extract all possible system templates seven kinds in total based on the resourceid .
therefore we regard a notification as an anonymous push if system templates are not used while neither the title nor icon is matched between the notification and the tested apps.
content based detection.
content based notification types are also quite easy to classify once the relevant runtime authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
information is collected.
we can identify updating contents based on keyword matching e.g.
download update and new version a total of keywords while drive by download based on if an apk file is downloaded after each notification is clicked since no other interaction will be introduced.
for malicious content virustotal will be leveraged to scan every url and files recognized from the network traffic collected after the notification is clicked .
we consider a notification as containing malicious content as long as virustotal flags its content as such.
for advertising content we will check if the source method which pushed the notification belongs to ad libraries.
finally the remaining push notifications that cannot be classified into the above types will be considered as normal behavior content types.
iv .
e v alua tion to evaluate the performance of d apanda we consider answering the following three main research questions.
rq1 can d apanda effectively and accurately identify apns in android apps?
rq2 what is the percentage of apps with apns in the wild?
what is the distribution across different app markets?
rq3 how are the underlying working mechanisms of apns manifested in the lifecycle of push notifications?
a. experimental setup to effectively answer the above research questions we will conduct both in the lab and in the wild experiments.
the inthe lab experiment aims to provide reliable indications on the performance of our approach and at the same time identify appropriate parameters for setting up the in the wild experiment which subsequently is applied to evaluate the performance of our approach for a large number of apps in real world settings.
setup for rq1 in the lab .
to evaluate the effectiveness of our tool we need to build a benchmark to support in thelab experiments.
unfortunately to the best of our knowledge there are no publicly available benchmarks on mobile push notifications in our community.
therefore we resort to user comments on app markets google play in particular to manually construct such a benchmark.
if a given app receives at least two comments complaining about the annoying behaviors of its notifications the app has a high probability to push aggressive notifications and hence is a good candidate to be included in our benchmark.
we first use a keyword based e.g.
push notification notification bar method to filter relevant user comments and then we manually went over the reviews and randomly selected such apps to form our benchmark set.
note that during our selection of benchmark apps we cannot figure out the type of apns accurately as some user comments are vague and hard to infer their corresponding behaviors.
as for the parameters in the app queuing exploration strategy we further set the capacity n of our app queue to four different scales from to .
for n representing that our system also supports running only one app each time the app would be explored fully in the foreground state.
we set the maximumcapacity as in our experiment as the testing phone we used nexus is unable to host more apps running at the same time due to its hardware constraints.
we set the exploration time per app t to different scales from seconds to seconds.
note that the upper bound was set dynamically during our experiment based on whether we could trigger more apns.
setup for rq2 and rq3 in the wild .
for rq2 and rq3 we rely on real world android apps to support the in the wild experiments.
from august to december we had crawled and collected over million android apps from markets including google play.
to perform an efficient study we seek to focus on those apps that are likely to invoke apis related to notifications delivery e.g.
notify .
to this end we have incorporated our system into a static analyzer to identify the invocations of those apis in the apps.
by so we have managed to obtain apps without considering the markets at this point as our dataset.
in the large scale experiments we launch d apanda on actual smartphone devices i.e.
nexus smartphones with android .
or api level .
we do not use emulators since apps may embed evasion techniques to avoid running on emulator environments .
we use four nexus smartphones running in parallel for testing.
it takes roughly hours to explore all 20k apps with the app queue size n such that apps were running at the same time and the exploration time t s where each app would be running in the foreground for 120s and in the background for 480s.
b. rq1 effectiveness of dapanda table iii shows the overall result of our evaluation on the crafted benchmark under different configurations.
in general our approach could achieve a high recall rate apntriggering apps at most out of labeled apps .
we manually confirmed and categorized those apps into our taxonomy as shown in table iv.
to further explore the reasons why our exploration cannot recall all labeled apps we conducted a manual analysis.
we installed and ran the remaining apps for a long time and we found that the notifications could not be triggered even manually.
there could be multiple explanations on this.
first the apps were released years ago and the notification services could be invalid or we did not get the appropriate app version as users complained.
second it may require the right combinations and configurations in order for the apns to appear.
finally it is also possible that some user comments might not be accurate at all.
from our experiment result shown in table iii we also identified the appropriate parameters for the large scale study.
in general the number of apn triggering apps is positively correlated with the exploration time.
however the number reaches its peak at t sort sin most cases and increasing the exploration time further would not significantly improve the results.
with the exploration time growing it is interesting to see that strategies with app queuing n achieve better 2this configuration is selected because it achieves the best performance in the study of rq1.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able iii the number of apn triggering apps with different parameter settings for the apps in our benchmark .
time strategyapp queue n foreground n n n 5s 30s 60s 180s 300s 450s 600s 900s 1200s 1500s 1800s t able iv the distribution of different types of apn s in our benchmark .
weo n l ys h o wt h e ones tha t were triggered with apn sa n d further confirmed by us .
beha vior content malicious driv e by ad updating other total frequent anon ymous compulsi ve background other total results than the strategy with fully foreground exploration n .
the underlying reason is that a number of apns were triggered when the apps were running in the background which is the advantage of our app queuing strategy.
note that with very limited time t cf.
table iii we did not perform exploration based on app queuing.
this is because with multiple apps running simultaneously the app install uninstall process may take longer than the foreground running time which may cause conflicting issues.
it is interesting to observe that the strategy with n is slightly better than n and both of them achieve better results than n .
we seek to investigate the reasons and found that with n more background cases could be triggered.
however with n due to the hardware limitations of nexus the smartphone would be lagging and some apps cannot work properly.
as a result the best configurations for the following largescale study are the app queue size n and the exploration time t s. findings dapanda is able to effectively and accurately detect apns in our manually crafted benchmark set.
among google play apps received complaints about their annoying notification behavior dapanda can automatically flag of them a recall of .
c. rq2 the distribution of apns in the wild we then show results of rq2 to understand how many apps with apns exist in the wild.
for the selected market apps we have successfully triggered unique pusht able v the overall result .
beha vior content malicious drive by ad updating other total frequent anon ymous compulsi ve background other total notifications from apps which accounts for over of the apps in our dataset.
the distribution among different notification types is shown in table v. note that although all the apps selected in our dataset have been found incorporating the related apis not all of them were identified with push notifications during our experiment mainly due to two reasons.
on one hand the push notification related apis would never be executed by the app and checking statically whether an api is reached is an instance of the undecidable halting problem .
on the other hand for non aggressive push notifications most of them were implemented based on third party services e.g.
google cloud messaging and fully controlled by the developers e.g.
pushing messages at a certain time of the day with strict regulations by the service providers e.g.
google gcm regulates that developers cannot push repetitive push notifications in a single day .
for the identified push notifications of them are considered to be apns based on the results of our user survey cf.
section ii a .
the apns were found to be pushed from apps taking up .
of our dataset.
distribution across markets.
table vi shows the distribution of our dataset and identified apps with apns across market3.
over .
to .
of app candidates in the studied markets were flagged as apps with aggressive notifications.
although each market has declared strict developer policies to regulate the apns we still find a number of aggressive cases in these markets.
this result suggests that it is challenging to perform automated regulation of apns thus both the app markets and our research community should pay more attention to this issue.
findings apns are prevalent across all the app markets we studied i.e.
covering over of the apps in our dataset.
it is urgent for app markets to adopt techniques like dapanda to identify and remove apps with aggressive notification behaviors.
d. rq3 understanding the lifecycle of apns we further characterize the push notifications triggered in the large scale experiment from different phases in their lifecycle including the origin of the push notification including its implementation template the reflected runtime behaviors the triggered contents and the corresponding actions after the notifications are consumed.
3note that one apk may correspond to several markets as different markets have overlapped apps.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able vi the distribution of our da t aset and identified aggressive apps .
market app aggressive aggressive google play .
huawei market .
tencent myapp .
pp helper .
wandoujia .
himarket .
oppo mraket .
anzhi market .
total .
t able vii distribution of push notifica tions from different libraries .
ad library push library library name push app library name push app airpush tencent bugly moxiu jpush dao youdao umeng message push jypush tencent tpush xinge wostore unipa y gcm fcm pandaad baidu push services feiw o rongyun push kuguo migu sdk mipush other total total origin of the push notifications.
based on resourceid of templates obtained from framework instrumentation we observed that most push notifications were implemented using system templates while over of the apps in numbers and over of the push notifications in numbers triggered were implemented using customized templates.
in these notifications over were labeled as apns in numbers .
we further analyze the origin of the triggered push notifications taking advantage of the call stack based approach we proposed in section iii b .
over of the notifications were triggered by third party libraries including ad libraries and push libraries.
we listed the ad libraries and push libraries with the number of triggered notifications in table vii.
while notifications originated from ad libraries were all considered to be apns taking up of all notifications and of apns some popular push notification services including google gcm fcm and baidu push services were only identified with a few cases in our experiment and no sensitive ones.
as we mentioned earlier these notification services have strict regulations to keep away apns.
for example google gcm fcm does not allow developers to use customized push notifications which prevents anonymous pushes completely.
runtime behaviors we then provide a detailed characterization of their runtime behaviors based on the taxonomy we summarized in section ii a. frequent push.
we have identified apps with frequent push notifications i.e.
pushing messages in less than minutes.
for the push notifications over of them were considered to be malicious leading users to malicious urls or downloading malware.
over of them were also drive by download pushes and of them push ads frequently.
anonymous push.
for the push notifications that use customized templates of them were considered to bet able viii the top 5domains tha t host the most number of malicious url s. domain number aggressive aggressive api.airpush.com .
mobile.eagla.com .
ff.td68x.com img.qycdn.daoyoudao.com ei.nd.enjoyfinance.cn t able ix the top 5downloaded malicious apps .
md5 vt source app b0490a5d8cce59616a12705adc546b61 com.androidemu.harveshihun.alvinshihun f93ec3d8490d583f425b0b5f312cb809 com.budwbo 7d8d182bf06d500217abca147ede9be1 com.runnergames.game.jesgtingche fd23f172bb3633453cf154e769884dfe com.june.sixteen.juejizhuti 4a1417007cce3309e04b28f326953288 com.suishouxie.yemdssfhgfekeji anonymous i.e.
hiding app name and app icon in any android versions.
additionally push notifications could also be considered as anonymous in android versions prior to v7.
as they do not provide such information but they implement the notifications based on system templates.
the systems will force them to show app names in android .
and afterwards.
compulsive push.
over of the push notifications we identified belong to the compulsive notification category.
the most aggressive cases were that of them deliver malicious contents in this way i.e.
users cannot close the notifications and have to visit malicious urls or download malware.
background push.
over of the push notifications were triggered when the apps run in the background which demonstrates the effectiveness of our app queuing strategy.
over half of the background notifications were malicious and advertisement related.
triggered contents the apns usually pose threats and spread sensitive contents including malicious contents.
then we further analyzed the triggered malicious contents.
urls domains.
as we have recorded all traffic triggered by clicking push notifications we are able to harvest distinct urls belonging to different domains.
we further analyzed the malicious urls i.e.
the malicious or phishing pages introduced by clicking the push notifications.
as reported by virustotal urls from domains were flagged as malicious.
table viii shows the top domains that host the most number of malicious urls we identified.
drive by download apps.
during our exploration we have collected drive by download apps triggered by apps with aggressive notifications.
for the apps we harvested only were unique i.e.
some apps were downloaded several times.
we further send these apps to virustotal.
the result suggested that of them were flagged as positive and of them were flagged by anti virus engines while apps were flagged by anti virus engines.
table ix shows the top downloaded malicious apps flagged by the most number of anti virus engines.
the targets of push notifications we further categorized target components of push notifications.
over of them invoke components within the app while over of them invoke third party components that belong to ad libraries or authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
push libraries.
besides over of them invoke system components e.g.
android.intent.action.view to perform actions including opening files and visiting urls.
findings apns could be manifested in all the phases in the lifecycle of push notifications ranging from the origin of the notifications to their triggering behaviors and from the contents to their target components once the contents are consumed.
v. t hrea ts to v alidity to the best of our knowledge this work is the first attempt in the community towards detecting apns in android.
the implementation of d apanda however carries several limitations.
first although we have created an effective app automation tool to trigger push notifications the timing of push notification messages usually depends on the developers advertisers.
our empirical study on the labeled benchmark suggested that most aggressive push notification behaviors could be triggered within minutes of app running cf.
section iv b however malicious developers could use sophisticated ways to bypass our detection.
indeed the classic principle of the unwinnable arms race between the attackers and defenders also applies to our work.
there is hence a need to continuously improve our approach towards inventing advanced techniques for detecting aggressive push notifications in the long run.
second we consider a push notification as advertisement related by tracing whether it is originated from known ad libraries as it is non trivial for us to identify ads from the contents.
however there may exist exceptional cases where the notifications are pushed by app code to perform some in app promotions.
so far in this case we will still regard them as non advertisement push notifications.
third the contents landing urls or the downloaded apks in push notifications may vary due to factors such as time location and user identifiers etc which unfortunately are ignored at the moment.
vi.
r ela ted work mobile push notifications.
this paper is the first to detect aggressive push notifications for android apps.
nevertheless there are several studies focused on analyzing mobile push notifications from other aspects.
for example chen et al.
studied the security qualities of emerging push messaging services and developed a tool to evaluate the security qualities of the service s sdks and its integration within different apps.
ahmadi et al.
characterized the usage of google cloud messaging gcm in android malware and proposed to trace the flows of gcm to improve malware detection.
lee et al.
have explored a new c c channel for mobile botnets based on the push notification service of android.
these studies may have a correlation with part of our work however our workis the first to identify and characterize aggressive behaviors in mobile push notifications.
mobile advertising.
mobile advertising has been widely studied including different techniques to detect third party libraries including ad libraries analyzing the security and privacy behaviors of mobile ad libraries mobile ad fraud detection and malicious contents distributed .
mobile push notification which could also be used as a means for delivering mobile advertisement has not been well studied in our research community.
nevertheless some related techniques could be applied in our study.
malicious and gray behaviors of mobile apps.
android malware detection is a more general research direction with a large number of techniques and measurement studies proposed.
besides a number of studies were focused on analyzing gray behaviors and aggressive annoying behaviors in mobile apps.
andow et al.
proposed to design and implement heuristics for seven main categories of grayware and then use these heuristics to simulate grayware triage on a large set of android apps.
tang et al.
proposed a systematic and comprehensive empirical study on a large scale set of fake apps.
hatada et al.
analyzed potentially unwanted applications puas in android and proposed to classify them based on the similarity of dns queries.
a number studies were focused on fraudulent behaviors in mobile apps e.g.
promotion attack fake review and new kinds of scams .
as apns cover both malicious behaviors e.g.
spreading malware and gray behaviors e.g.
compulsive or anonymous our work is a complementary study of these existing efforts.
vii.
c onclusion in this paper we present the first work to demystify mobile push notifications and detect aggressive push notifications apns automatically.
in particular we first create a comprehensive taxonomy and then propose d apanda a hybrid approach that leverages ui automation and framework instrumentation techniques to identify apns.
we have applied d apanda to 20k android apps crawled from app markets.
our experimental results show that apns indeed exist in many android apps.
among these aggressive notifications some of them were found to be maliciously used to distribute malware and create annoying messages.
our results encourage our research community to invest more efforts into the detection and mitigation of apns.
acknowledgment we sincerely thank our shepherd prof. amin alipour university of houston and all the anonymous reviewers for their valuable suggestions and comments to improve this paper.
this work is supported by the national key research and development program of china grant no.2018yfb0803603 and the national natural science foundation of china grants no.
and no.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.