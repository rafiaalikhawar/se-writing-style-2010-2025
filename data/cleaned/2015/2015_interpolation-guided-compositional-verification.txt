singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems interpolation guided compositional v erification interpolation guided compositional v erification shang w ei lin jun sun singapor e management univ ersity junsun smu.edu.sg truong khanh nguyen yang liu jin song dong follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the softwar e engineering commons citation citation lin shang w ei sun jun nguyen t ruong khanh liu y ang and dong jin song.
interpolation guided compositional v erification.
.
proceedings of the 30th ieee a cm international conf erence on automated softwar e engineering lincoln nebr aska no vember .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
interpolation guided compositional verification shang wei lin jun sun truong khanh nguyen yang liu and jin song dong school of computer engineering nanyang technological university singapore university of technology and design school of computing national university of singapore abstract model checking suffers from the state space explosion problem.
compositional verification techniques such as assume guarantee reasoning agr have been proposed to alle viate the problem.
however there are at least three challengesin applying agr.
firstly given a system m bardblm2 h o w do we automatically construct and refine in the presence ofspurious counterexamples an assumption a which must be an abstraction of m2?
previous approaches suggest to incrementally learn and modify the assumption through multiple invocationsof a model checker which could be often time consuming.secondly how do we keep the state space small when checkingm bardbla if multiple refinements of a2are necessary?
lastly in the presence of multiple parallel components how do wepartition the components?
in this work we propose interpolation guided compositional verification.
the idea is to tackle threechallenges by using interpolations to generate and refine theabstraction of m to abstract m1at the same time so that the state space is reduced even if a2is refined all the way to m2 and to find good partitions.
experimental results show that theproposed approach outperforms existing approaches consistently.
keywords model checking automatic compositional verification satisfiability interpolation i. i ntroduction model checking is a successful formal verification technique which can automatically check whether a system model msatisfies a property denoted by m .
however it suffers from the infamous state space explosion problem .
to alleviate the problem assume guarantee reasoning agr a well known compositional technique has been proposed and applied on model checking.the most common rule used in agr is the following assume guarantee non circular ag nc rule m bardbla2 andm2 precedesequala2 m1 bardblm2 given a system with two components modeled by m1and m2and a property the ag nc proof rule says that if m1 can satisfy a property under an assumption a2anda2 is an abstraction of m2 i.e.
m2can be simulated by a2 denoted by m2 precedesequala2as formulated in section iii a then we can conclude that m1 bardblm2satisfies .
however the the corresponding author shang wei lin can be contacted via the following e mail address shang wei.lin ntu.edu.sg.
this research is supported in part by the national research foundation prime ministers office singapore under its national cybersecurity r d program award no.
nrf2014ncr ncr001 and administered by thenational cybersecurity r d directorate.challenge of applying agr is at least threefold.
the first is how to automatically construct and refine in the presence ofspurious counterexamples the assumption a .
in general the assumption should be kept as small as possible i.e.
containingonly sufficient details to prove or disprove m bardbla2 .
besides relying on human creativity to create a2manually there is a line of works on applying learning techniques e.g.
to learn the assumption.
theidea is to construct a candidate assumption through learningand then verify that the candidate is indeed an abstraction ofm .
otherwise the assumption must be modified sometimes multiple times until it becomes an abstraction of m2.s u c h a process requires multiple invocations of a model checkerand therefore could be time consuming.
secondly the worstcase scenario for agr is that every detail of m 2is needed in order to prove or disprove m1 bardblm2 and thus a2is refined all the way to m2.
as a result all the effort on finding the assumptions and checking m1 bardbla2 often multiple times is wasted.
the question is then is itpossible to make use of the intermediate checking results soas to keep the state space reduced even in the worst casescenario?
the last challenge is in the presence of multipleparallel components how do we partition components to applyagr?
it has been reported in that without a good partitionstrategy model checking based on agr might be even worsethan the traditional monolithic model checking.
in this work we propose an approach to complement existing agr based compositional verification techniques bytackling the three challenges above.
central to our approachis the idea of learning from bounded model checking bmc results.
in the following we briefly present our approach andfig.
shows its workflow.
a model in our work is a paral lel composition of multiple components which communicatethrough shared variables .
at the beginning the components are partitioned into two groups either randomly or based onsimple heuristics.
let us assume that the model is g bardblg2 wheregiwherei itself is a parallel composition of multiple components.
in our method we change the partitionbased on intermediate verification results.
in addition wewould construct not only an abstraction a 2forg2but also an abstraction a1forg1.
initially we set the transition relation ofa2to be true which is the weakest over approximation anda1to beg1.
we then model check a1 bardbla2.i fa1 bardbla2 satisfies the property we prove the system satisfies .
otherwise we check whether the counterexample is spuriousor not.
this is done by bounded model checking g bardblg2up to the length of the counterexample.
if the counterexample isnot spurious we find a counterexample.
otherwise we obtain 1our work can be extended to support messaging or barrier synchronization.
30th ieee acm international conference on automated software engineering .
ieee a1 bardbla ?
g1 g2 g1 bardblg2 k step bmc formula g1 bardblg2 negationslash interpolationsun sat core a counterexample in kstepsinitial partition a1 g1a2 true yes satisfiable unsatisfiablerefinea2abstracta1repartition fig.
.
overall flow the unsatisfiability unsat core from the bmc formula.
we re partition the components such that those relevant to theunsat core are grouped into g since intuitively details of those components matter at least in avoiding the spuriouscounterexample .
if the partition g g2 cannot be improved by unsat cores anymore we refine a2 the abstraction of the new g2 based on the interpolants from the unsatisfiable bmc formula.
lastly we use the interpolants toconstruct the abstraction a 1ofg1 so as to avoid details of the processes which are irreverent at least to the proofof unsatisfiable bmc formula .
the above process continuesuntil a verification result can be concluded i.e.
the propertyis proved or a real counterexample is found.
our interpolation guided approach tackles the abovementioned three problems as follows.
firstly the assumptionsare generated and refined automatically based on interpola tions.
different from existing approaches on learning assump tions the assumptions in our approachare abstractions of g 2by construction.
secondly unlike in existing agr based approaches where the component g1is never changed we actively abstract the transition relation ofg 1based on interpolations.
as a result we would not explore g1 bardblg2even ifa2has to be refined all the way to g2.
lastly we use unsat cores to guide the partition of components.
wehave implemented the approach in the pat model checker and experiments show the benefits of our approach.
the rest of this paper is organized as follows.
section ii illustrates our approach with a simple example.
section iiireviews some preliminary backgrounds and recalls the transi tion over approximation based on interpolants.
in section iv we show how we construct and refine a 1anda2by using interpolations.
experiment results are presented in section v toshow the effectiveness of our approach.
section vi summarizesrelated works.
section vii concludes this work.
ii.
a s imple example we illustrate how our approach works using a simple example.
we first show abstracting m1whilst refining m2 could be beneficial to a system with two components.
next we generalize the system to ncomponents and then show how a good partition is found.
a two bit counter is modeled by twocomponents cell 1andcell2in fig.
.
each component cellifori has three boolean variables as follows.
theinivariable indicates whether the carry in value of celli is asserted.
the bitivariable stores the current bit value ofcelli.
it is initialized as false and its next value depends on the exclusive or of its current value and its carry in value.theout iindicates whether the current bit value of celli should be carried out.
if the bit value of cell1is carried out then the carry in value of cell2should be asserted.
the initial condition iiand transition relation tiof the two components are encoded as follows respectively.
i1 bit1 in1 i2 bit2 t1 bit prime bit1 in1 out prime bit1 in1 t2 in prime out1 bit prime2 bit2 in2 out prime bit2 in2 suppose we want to verify the property requiring thatout2 bit2 and in2do not hold simultaneously i.e.
g out2 bit2 in2 .
let cell1bem1andcell2be m2 respectively.
we use tl ito denote the over approximation oftiafterl th iteration.
initially in our approach t0 2is set to the weakest transition relation latticetop and t0 1is kept as t1.
let al ibe the component encoded by the initial condition iiand the abstract transition relation tl i. in the first iteration a counterexample is found in one step when model checking a0 bardbla02 .
to check whether there is any one step counterexample in the concrete system a bounded model checking bmc of length one based ont 1andt2is performed.
however the bmc formula is not satisfiable meaning that the counterexample is spurious and t0 2should be strengthened.
from the proof of unsatisfiability we obtain the symmetric interpolant 1 latticetopfort1and 2 bit2 out prime 2fort2 respectively c.f.
section iii b for details .
we use the obtained interpolant to weaken t0 1and strengthen t0 2as follows t1 1 latticetopand t1 t0 2 bit2 out prime2 .
by the characteristics of interpolants t1 and t1 2are over approximations of t1andt2 respectively.
in addition i1 t1 i2 t1 2does not admit any one step counterexamples.
in the second iteration a11 bardbla12 are verified again and a counterexample in three steps is found.
to check the feasibility of any three step counterexamples a bmc of lengththree based on the concrete transition relations t 1andt2 i s performed.
however the bmc formula is not satisfiable and t1 2still needs to be strengthened.
we obtain the interpolants prime 1and prime2from the unsatisfiability proof to refine t1 1and t1 module cell1 var bit1 bool var in1 bool var out1 bool init bit1 false init in1 true next bit1 bit1 xor in1 next out1 bit1 in1 end modulemodule cell2 var bit2 bool var in2 bool var out2 bool init bit2 false next in2 out1 next bit2 bit2 xor in2 next out2 bit2 in2 end module fig.
.
the counter example respectively as follows t2 prime bit1 out prime1and t2 t1 prime2 out prime2 out1 out prime2 in prime in2 bit2 .
in the third iteration a spurious counterexample in seven steps is found and t2 1and t2 2are strengthen by interpolants as follows t3 bit1 out prime 1and t3 t2 bit prime out prime .
in the fourth iteration a31 bardbla32 is verified by model checking again but no counterexamples are found this time meaning that cell bardblcell2 .
we remark here that abstracting t1is optional but so reduces the state explosion problem when checking m1 bardbla2 .
let us do the verification again but this time let cell2 bem1instead of cell1.
the verification can be done in one iteration where a1 cell2anda2with the weakest transition relation true.
this is because cell2is sufficient to prove the property.
from this example we canobserve the importance of partitioning components for agr.in our approach we utilize the unsatisfiability core to predictthe components which are necessary to prove the property.within each iteration if the bmc formula for checking thespuriousness of counterexamples is unsatisfiable we obtainits unsatisfiability core.
any component whose variables areappearing in the unsatisfiability core might be necessary forproving the property and is included into the m 1group.
once them1group is changed the verification is restart for the new partition in the next iteration.
for the same counter example if we have ncells nbit counter and suppose we want to verify the property j g outj bitj inj forj ... n our approach is able to detect that celljis the only necessary component to prove j i.e.
celljis in them1group and the rest are in them2group which is the best partition only one iteration is required for verifying j .
iii.
b ackground in section iii a we review some definitions borrowed from of symbolic model checking and boundedmodel checking.
then we briefly recall the transition approx imation based on interpolations in section iii b. a. preliminaries define b latticetop to be the boolean domain where latticetopand denote the truth values true andfalse respectively.
let xbe a set of boolean variables and x the size of x. a boolean formula x overxis a function from b x tob.
a valuation x boverxis a function from boolean variables to truth values.
we use to denote the result of evaluating by replacing each x xwith x .
to represent transition systems symbolically we also define a set of boolean variables x prime x prime x x which corresponds to xsuch that x x represents the current value of x while x prime x primerepresents the value of xin the next state.
moreover let x x prime be a boolean formula over xandx prime.i f and primeare valuations over xandx prime respectively we use to denote the result of evaluating by replacing each x xwith x and replacing eachx prime x primewith prime x prime .
letcbe a set of formulas.
we use logicalandtextcto denote the conjunction of all formulas.
a transition system m x i x t x x prime consists of its state variables x its initial predicate i x and its transition relationt x x prime .
we sometimes write x i t to denote a transition system if there is no risk of confusion.
a trace of m is a finite sequence of valuations 0 1 k where iis a valuation over x such that i 0 latticetopandt i i latticetop for alli k .
the language of m denoted by l m contains all the traces of m. a state predicate x is a boolean function over x. we say msatisfies denoted bym if for each 0 1 k l m w eh a v e latticetop for alli ... k .
a counterexample of m is a trace 0 1 tofmsuch that latticetop for alli ... t but .
letm x i x t x x prime anda x ia x ta x x prime be two transitions systems over x.w es a ym is simulated by aorasimulates m denoted by m precedesequala i f x squaresmallsolidi x ia x and xx prime squaresmallsolidt x x prime ta x x prime .
that is the initial condition ofmis stronger than that of aand every transition in m is also allowed in a. obviously if m precedesequala holds then l m l a holds.
let mi xi ii xi ti xi x prime i be two transition systems for i .
the parallel composition ofm1andm2is the transition system m1 bardbl m2 x1 x2 i1 x1 i2 x2 t1 x1 x prime t2 x2 x prime2 .
given a transition system m x i x t x x prime and a state predicate x whether isk reachable in mcan be expressed symbolically as a boolean formula.
for each variablex xand a natural number i we use x angbracketlefti angbracketrightto denote the variable xwithiprimes added which represents the value ofxat timei.
for example x angbracketleft3 angbracketright x prime prime primerepresents the value ofxat time3.
we also extend this notation to the set of variables and formulas.
thus x angbracketlefti angbracketrightcontains variables with i primes added x angbracketlefti angbracketrightis the formula over x angbracketlefti angbracketright and x x prime angbracketlefti angbracketright is the formula over x angbracketlefti angbracketrightandx angbracketlefti angbracketright.
a state predicate x isk reachable in x i x t x x prime if the following bounded model checking bmc formula is satisfiable.
i x angbracketleft0 angbracketright t x x prime angbracketleft0 angbracketright t x x prime angbracketleft1 angbracketright t x x prime angbracketleftk angbracketright x angbracketleftk angbracketright algorithm verification by transition approximation input x i t the concrete transition system the property to be checked output yes no with a counterexample 1 t latticetop 2while true do if x i t then return yes else suppose isk reachable in x i t i angbracketleft0 angbracketright t angbracketleft0 angbracketright ... t angbracketleftk angbracketright angbracketleftk angbracketright if logicalandtext is satisfied by a valuation then return no else let i angbracketleft0 angbracketright t angbracketleft0 angbracketright ... t angbracketleftk angbracketright angbracketleftk angbracketright be the symmetric interpolant for t t logicalandtextk i t angbracketlefti angbracketright angbracketleft i angbracketright b. interpolation based approximation of transition relations in transition relations are approximated by interpolations as formulated in definition obtained from unsatisfiability proofs of bounded model checking.
definition given a pair of boolean formulas a b such that a bis unsatisfiable an interpolant for a b is a formula asatisfying the following properties aimplies a i.e.
a a a bis unsatisfiable arefers only to the common variables of aandb.
ifa bis unsatisfiable with an unsatisfiability proof an interpolant for a b can be obtained from the proof .
in a formula of a k step bounded model checking problem if the formula is unsatisfiable the over approximation of the transition relation can be obtained from the symmetric interpolants as formulated in definition among the transition relations from steps 0tok .
definition given an indexed set of boolean formulas a a1 a2 ... a n such that logicalandtextais inconsistent a symmetric interpolant forais an indexed set of boolean formulas a a1 a2 ... an satisfying the following conditions ai aifor alli ... n logicalandtext ais inconsistent airefers to the variables common to aianda ai .
algorithm shows a verification approach by overapproximating the transition relation based on symmetric in terpolants .
the details are as follows initially the approximation tis initialized as latticetop line1 .
if x i t holds we can conclude x i t also holds because t t lines3 .
if isk reachable in x i t there could be two cases where either is also k reachable in x i t o r tis too weak an approximation.
bounded model checking can help to find outwhich case it is.
we construct a set of formu las i angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft1 angbracketright ... t angbracketleftk angbracketright angbracketleftk angbracketright where logicalandtext is exactly the bmc formula.
we use a decision procedure to determine the satisfiability.
if logicalandtext is satisfiable then x i t does not hold lines .
if logicalandtext is not satisfiable then t is too weak and needs to be refined.
let i angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft1 angbracketright ... t angbracketleftk angbracketright angbracketleftk angbracketright be the symmetric interpolant for .
let us define t llbracketi rrbracket t angbracketlefti angbracketright angbracketleft i angbracketright where t angbracketlefti angbracketright angbracketleft i angbracketrightdenotes the formula obtained by removing iprimes from t angbracketlefti angbracketrightif possible.
because of the properties of symmetric interpolants the formula i angbracketleft0 angbracketright t angbracketleft0 angbracketright llbracket0 rrbracket t angbracketleft1 angbracketright llbracket1 rrbracket t angbracketleftk angbracketright llbracketk rrbracket angbracketleftk angbracketright is unsatisfiable i.e.
logicalandtextk i 0 t llbracketi rrbracketadmits no path in k steps from ito .
thus tis refined as t logicalandtextk i 0 t llbracketi rrbracket which becomes the new approximation in the next iteration for verification lines .
the process continues until a verification result can be concluded.
the correctness and termination of algorithm are proved in .
iv .
i mproving compositional verification by interpolations in this section we introduce how the compositional verification based on assume guarantee reasoning agr can beimproved using interpolations.
we first show how our approachworks for systems with two processes in section iv a. next we show how to extend our approach to systems with manyprocesses in section iv b. a. generating assumptions by interpolations let us recall the ag nc proof rule in equation .
to automatically generate the assumption a we can construct a2as the symmetric interpolants of m2from the bounded model checking problem of m1 bardblm2 .
since the transition relation of a2is an over approximation of that of m2 the second condition of equation m2 precedesequala2 holds naturally.
we only have to check whether the first condition m1 bardbla2 holds or not.
if it does then we have a conclusive result showing that m1 bardblm2 .
if it does not hold with a counterexample in ksteps the transition relation of the assumption a2is refined strengthened by the interpolants obtained from the k step bounded model checking problem of m1 bardblm2 provided that the problem is unsatisfiable.
furthermore applying the agr rule twice it is easy to seethat the following rule holds.
a bardbla2 andm2 precedesequala2andm1 precedesequala1 m1 bardblm2 thus using the same formula for bounded model checkingofm bardblm2 we can obtain the symmetric interpolant of the algorithm compositional verification based on interpolation input m1 x1 i1 t1 andm2 x2 i2 t2 concrete transition systems the property to be checked output yes no with a counterexample 1 t1 t1 2 t2 latticetop 3while true do if x1 i1 t1 bardbl x2 i2 t2 then return yes else suppose isk reachable in x1 i1 t1 bardbl x2 i2 t2 i angbracketleft0 angbracketright i angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft1 angbracketright t angbracketleft1 angbracketright ... t angbracketleftk angbracketright t angbracketleftk angbracketright angbracketleftk angbracketright if logicalandtext is satisfied by a valuation then return no else let i angbracketleft0 angbracketright i angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft1 angbracketright t angbracketleft1 angbracketright ... t angbracketleftk angbracketright t angbracketleftk angbracketright angbracketleftk angbracketright be the symmetric interpolant for t2 t2 logicalandtextk i t angbracketlefti angbracketright angbracketleft i angbracketright t1 logicalandtextk i t angbracketlefti angbracketright angbracketleft i angbracketright abstracting m1 optional transition relation for m1as well which gives a1 i.e.
the abstraction of m1.
algorithm shows the pseudo code of the proposed automatic compositional verification approach based on interpolations with a2strengthened and a1abstracted simultaneously .
the details are described as follows.
initially the approximation t1is initialized as t1 and the approximation t2is initialized as latticetop respectively lines .
if x1 i1 t1 bardbl x2 i2 t2 holds then we can conclude that x1 i1 t1 bardbl x2 i2 t2 also holds lines because t1and t2are over approximations of t1andt2 respectively.
note that both t1 t1andt2 t2hold according to the properties of interpolations cf.
definition .
if isk reachable in x1 i1 t1 bardbl x2 i2 t2 there could be two cases is alsok reachable in x1 i1 t1 bardbl x2 i2 t2 or t2is too weak an approximation.
we construct a set of formulas i angbracketleft0 angbracketright i angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft0 angbracketright ... t angbracketleftk angbracketright t angbracketleftk angbracketright angbracketleftk angbracketright where logicalandtext is exactly the bounded model checking formula.
we use a decision procedure to determine its satisfiability.
if logicalandtext is satisfiable we can conclude that x1 i1 t1 bardbl x2 i2 t2 violates the property because there exists a real counterexample in ksteps lines9 .
if logicalandtext is unsatisfiable then t2is too weak and needs to be strengthened which can be done as follows.
let i angbracketleft0 angbracketright i angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft0 angbracketright ... t angbracketleftk angbracketright t angbracketleftk angbracketright angbracketleftk angbracketright be the symmetric interpolant for .
let us define t llbracketi j rrbracket t angbracketlefti angbracketright j angbracketleft i angbracketrightfori ... k and j where t angbracketlefti angbracketright j angbracketleft i angbracketrightdenotes the formula obtained by removing iprimes from t angbracketlefti angbracketright jif possible.because of the properties of symmetric interpolants the following bounded model checking formula i angbracketleft0 angbracketright i angbracketleft0 angbracketright k logicalanddisplay i 0 t angbracketlefti angbracketright llbracketi rrbracket k logicalanddisplay i 0 t angbracketlefti angbracketright llbracketi rrbracket angbracketleftk angbracketright is unsatisfiable.
that is to say logicalandtextk i 0 t llbracketi rrbracket and logicalandtextk i 0 t llbracketi rrbracket admit no path in ksteps from i1 i2to violate .
note that logicalandtextk i 0 t llbracketi rrbracket is an overapproximation of t2as well as a refinement of t2.
thus we strengthen t2as t2 logicalandtextk i 0 t llbracketi rrbracket for the next iteration line .
in addition since logicalandtextk i 0 t llbracketi rrbracket is an over approximation of t1 we can optionally abstract t1as logicalandtextk i 0 t llbracketi rrbracket in line14 which alleviates the state space explosion problem when checking whether x1 i1 t1 bardbl x2 i2 t2 holds.
theorems and prove the correctness and termination of the proposed interpolation based approach.
theorem algorithm is correct.
proof to establish the correctness of algorithm we want to prove that it returns yes only if m1 bardblm2 and returns no with a counterexample only if m1 bardblm2 negationslash .
let m1 x1 i1 t1 and m2 x2 i2 t2 be the transition systems with respect to t1and t2 respectively.
since t1and t2are obtained by interpolations both t1 t1and t2 t2hold i.e.
m1and m2are the abstractions of m1 andm2 respectively.
algorithm returns yes only when m1 bardbl m2 which implies m1 bardblm2 .
on the other hand algorithm returns no only when logicalandtext is satisfiable by a valuation .
since logicalandtext is a bounded model checking formula to check whether is reachable within k steps in m1 bardblm2 the valuation is a witness of m1 bardblm2 negationslash .
from the above arguments we can conclude that algorithm is correct.
algorithm partition input c1 c2 ... c n a set of components k the number of steps output m1 m2 the partition of all components 1m1 m2 2letu be the unsatisfiability core of 3forj tondo ifcjhas any variable appearing in u then m1 m1 cj 6m2 c1 c2 ... c n m1 7return m1 m2 theorem algorithm terminates.
proof to establish the termination of algorithm we want to prove that the number of refinement iterations for t1 and t2is finite.
in algorithm t2is initialized as latticetop and t1is set to the most abstract over approximation after the first iteration.
in the following iterations of algorithm t1and t2are refined and approaching to t1andt2 respectively.
for finite state systems the refinement loop for t1and t2in algorithm must terminate.
this is simply because we cannot strengthen a formula with a finite number of models infinitely.that is m bardblm2 will be either proved or disproved in algorithm within a finite number of iterations.
b. generalization to multiple components the proposed compositional verification approach based on interpolation is presented in the context of two compo nents.
if a system consists of ncomponents modeled by m c c2 ... c n wheren an intuitive approach to generalize our approach is to partition the components intotwo groups to fit the ag nc proof rule.
for example if n we can obtain m c1 bardblc2andm2 c3 bardblc4 and apply our approach on m1andm2.
however the number of possible partitions is 2n which is exponential to the number of components.
in addition cobleigh et al.
showed that a good partition is veryimportant to agr with the ag nc proof rule.
with a badpartition assume guarantee reasoning may not be beneficial which is corroborated in our experiments in section v. in the following we would like to show that bounded model checking can help to find good partitions efficiently.let us recall the ag nc proof rule for agr.
an ideal case isthat we can have a conclusive verification result when the as sumption a 2is the most abstract one whose transition relation is latticetop.
that is to say considering only the m1group is sufficient to have a conclusive result or the property to be verifiedis only related to the m 1group.
based on this observation we propose a partition heuristic based on the unsatisfiabilitycore of bmc formula.
consider the following bounded modelchecking formula in ksteps for the ncomponents where c j xj ij tj andj ... n .
n logicalanddisplay j 1i angbracketleft0 angbracketright j k logicalanddisplay i 0n logicalanddisplay j 1t angbracketlefti angbracketright j angbracketleftk angbracketrightif is not satisfiable the property is not going to be violated in ksteps.
we can obtain its unsatisfiability core denoted by u which includes the formula showing why the property cannot be violated in ksteps.
in the other hand the unsatisfiability core also gives us a hint of which componentsare necessary to prove that the property is satisfied.
the heuristic p artition for partitioning components is shown in algorithm .
initially groups m1andm2are initialized as empty respectively line .
the satisfiability of the bounded model checking formula inksteps is checked by a decision procedure.
if it is unsatisfiable we obtain itsunsatisfiability core denoted by u line2 .
if a component cjfor some j ... n has a variable appearing in the unsatisfiability core u we include cjinto the group m1 because it is strongly necessary to prove that the property issatisfied lines .
the remaining components that do not have any variables appearing in u are included into the group m2 line6 and the final partitioned groups m1andm2are returned line .
algorithm gives the pseudo code of the generalized interpolation guided compositional verification for multiplecomponents.
initially we assume that there is an initial par tition of groups m 1andm2 line2 .
then algorithm works similarly to algorithm as if there are only twohypothetical components m 1andm2.
when a counterexample is found in abstract components in ksteps line a bmc of length kis performed to check whether there exists any k step counterexample in the concrete components line .
if the bmc formula is satisfied by an valuation line11 then a real counterexample is found and returned line .
if the bmc formula is not satisfiable line the partition heuristic is performed line with the value kto obtain a new partition m prime m prime .
if there is any component in m prime 1but not inm1 it is then included into m1 lines15 and the verification restarts from scratch for the new partition line .
if there is no re partition that can be made line the process continues similarly to algorithm until a verificationresult can be concluded.
we remark that the k step bmc formula in the partition heuristic is equivalent to the formula logicalandtext for checking whether isk reachable in the concrete components.
thus the formula could be solved only once suchthat the unsatisfiability core as well as the interpolants areobtained from the same unsatisfiability proof.
the correctness of algorithm can be proved by theorem as well while the termination has to be established basedon theorem plus the finite number of re partition iterations.notice that the number of components in the m 1group is strictly increasing and therefore the number of re partitions inalgorithm is at most niterations.
since the re partitions are finite and the verification terminates for each new partition bytheorem we can conclude that algorithm terminates ina finite number of iterations.
v. e v aluation the proposed interpolation based compositional verification framework has been implemented in the pat modelchecker .
we use mathsat an smt solver to obtaininterpolations.
mathsat supports three different ways to ob tain interpolations from unsatisfiability formulas.
we use the algorithm generalized interpolation based compositional verification input c1 c2 ... c n a set of components the property to be checked output yes no with a counterexample 1while true do let m1 m2 be a partition where mi xi ii ti fori 3 t1 t1 4 t2 latticetop while true do if x1 i1 t1 bardbl x2 i2 t2 then return yes else suppose isk reachable in x1 i1 t1 bardbl x2 i2 t2 i angbracketleft0 angbracketright i angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft1 angbracketright t angbracketleft1 angbracketright ... t angbracketleftk angbracketright t angbracketleftk angbracketright angbracketleftk angbracketright if logicalandtext is satisfied by a valuation then return no else m prime m prime partition c1 ... c n k ifm prime m1 negationslash then m1 m1 m prime m1 m2 c1 c2 ... c n m1 goto line2 let ... t angbracketleft0 angbracketright t angbracketleft0 angbracketright t angbracketleft1 angbracketright t angbracketleft1 angbracketright ... t angbracketleftk angbracketright t angbracketleftk angbracketright angbracketleftk angbracketright be the symmetric interpolant for t2 t2 logicalandtextk i t angbracketlefti angbracketright angbracketleft i angbracketright t1 logicalandtextk i t angbracketlefti angbracketright angbracketleft i angbracketright abstracting m1 optional approach proposed by mcmillan in our implementation.
to demonstrate the feasibility and benefits of our approach the following systems are used as benchmarks.
fms.
a flexible manufacturing system fms produces blocks with a cylindrical painted pinfrom raw blocks and raw pegs.
the manufacturingdevices are connected through buffers and the ca pacity of each buffer is one.
we verify the propertiesrequiring that each buffer should not overflow.
dp.
the dining philosophers dp problem illustratesa resource sharing problem in concurrent systems.philosophers sit at a round table and there is onlyone fork between any two philosophers.
a philosopherrequires two forks shared with his her neighbors toeat.
we verify the properties requiring that any pair ofneighboring philosophers cannot eat simultaneously.
aip.
the aip manufacturing system produces two products from two types of materials indifferent production routes.
we verify the propertiesrequiring that the routes of the two types of materialsshould be opposite.
sba.
the synchronous bus arbiter sba is a busarbitration protocol for synchronous circuits .
abus is connected by nodes the components to accessit in a ring and a token is passed around the nodes.we verified the properties requiring that a bus cannotbe accessed simultaneously by more than two nodes.
msi.
in the msi cache coherence protocol amemory is shared by nnodes each of which has a cache.
a bus connects the caches of the nodes andthe memory.
we verified the properties requiring thatthe bus cannot be owned simultaneously by more thantwo nodes.
the system models 2and verified properties of all the experiments and the implementation of our framework can befound in on line.
in our experiments all the propertiesare satisfied.
we compare three verification techniques tra ditional bdd based model checking mcmillan sinterpolation based transition over approximation and our interpolation guided compositional verification.
sinceboth of mcmillan s and our approaches require an underlyingverification engine we adopt the traditional bdd based modelchecking .
the following experimental results were obtained by running the pat model checker on a bit windows laptop with a .8ghz intel r core tm i7 2640m processor and4gb ram.
table i shows the verification results of different techniques where bdd denotes the traditional bdd based modelchecking mc itp denotes mcmillan s interpolation basedtransition over approximation c itp denotes the proposed 2the input language of our models which is a simplified version of nusmv s input language does not support parameterized module definitions.
3we integrate the cudd library in our implementation and the default settings are used for all experiments.
table i. v erification results bdd mc itp c itp c itp a c itp p a system n time time r time r time r time p fsm .
.
.
.
.
fsm .
.
.
.
fsm .
.
.
.
fsm .
.
.
fsm .
.
.
.
fsm .
fsm .
.
.
.
fsm .
.
.
.
fsm .
.
.
.
fsm .
.
.
.
fsm clock .
.
.
fsm clock clock clock .
dp .
.
.
.
.
dp .
.
.
dp .
.
.
dp .
.
.
dp .
.
.
dp .
.
.
dp .
.
.
dp .
.
.
dp .
.
.
dp .
.
.
aip .
.
.
.
.
aip .
.
.
.
aip .
.
.
aip .
.
.
aip .
.
.
aip .
.
.
aip .
.
.
aip .
clock .
sba .
.
.
sba .
.
.
sba .
.
.
sba .
.
.
sba clock .
.
sba clock .
.
sba clock .
.
sba clock .
.
sba clock clock .
msi .
.
.
.
msi .
clock clock .
msi clock clock clock .
msi n number of components number of verified properties time verification time in secs r number of refinements p number of re partitions out of memory clock time out minutes interpolation guided compositional verification and c itp a denotes the c itp approach with abstraction of m1.w e remark in the above experiments the number of components involved in the systems denoted by n is more than and therefore we need to partition the components into two groupsfor the c itp and c itp aapproaches.
specifically we put the first four components in the m1group and the remains in them2group.
note that the order of components can be specified by users in the input model.
in this set of experiments we randomly picked one possible order and fixed it for allexperiments unless the partition heuristic is performed.
as we expected bdd based model checking performed worst because it ran out of all available memory for most ofthe cases.
in average mcmillan s approach performed betterthan the c itp approach because the partition of the m 1and m2groups is not good which leaded to many cases of running out of memory or time out.
however with the abstractionofm most of these cases can be verified by the c itp a approach in 30minutes which shows the significant benefit of abstracting m1in assume guarantee reasoning.
we remark here that the integration of the smt solver mathsat isdone by interprocess communications i.e.
a dedicated processis created for mathsat and the problems in smt lib format to be solved as well as the output interpolations or theunsatisfiability cores are stored in shared string buffers.
thisimplementation is not optimized because it invokes systemcalls many times which is time consuming.
the performancecould be improved if mathsat is integrated natively as alibrary.
we also applied our generalized approach with the partition heuristic as well as abstracting m denoted by citpp a on the application examples and the verification results are shown in the right most column.
the initial partitionis obtained by performing the partition heuristic with lengthtwo which is short but gives a rough understanding of thecomponents.
we did not list the number of refinements for thec itp p aapproach in the table because the partition heuristic is able to find good partitions where all the componentsrelated to the property are put into the m 1group so that the property can be proved to hold with the most abstractassumption whose transition relation is latticetop i.e.
no refinements are required.
instead we list the number of re partitions for thec itp p aapproach.
in the fsm example good partitions can be found initially while other examples require re partitions.in the msi example no approach can handle the case of fivenodes which consists of seventeen components because of running out of memory.
after our investigation we found that the bottleneck is the underlying bdd based verificationengine.
since the transition relations of the msi componentsare rather complicated the underlying bdd based verificationeasily runs out of memory.
in average the c itp p aapproach is the best one especially when the system size is large.
vi.
r elated work model checking suffers from the state explosion problem.
to alleviate the problem pnueli firstly proposed theassume guarantee paradigm to verify system componentsindividually and use the individual verification results to de duce additional properties of the system.
clarke et al.
used interface processes to model the abstract environmentfor a component which is much smaller than the real one such that the state space is reduced.
for formal verificationthat is not based on model checking xu et al.
proposeda proof system based on the assume guarantee paradigm forverifying shared variable concurrent programs.
henzinger etal.
reported several case studies about applying assume guarantee reasoning on real world systems.
cobleigh et al.
proposed a framework that generates the abstract environment of components automatically usingthe l algorithm based on the ag nc proof rule.
this work is a pioneer of automating the compositional verification basedon learning techniques.
consequently several improvements have been proposed to further reduce the com plexity.
these improvements focus on reducing the size of thealphabet during learning which dominates the time complexityof the membership query required the l algorithm.
instead of adopting the non circular ag nc proof rule barringer et al.used the l algorithm to learn assumptions automatically for agr based on the circular and symmetric proof rule .
linet al.
extended the learning based compositional verificationon timed systems .
in traditional assume guarantee reasoning agr the m component in the ag nc proof rule is never changed duringthe whole verification process which is very different fromcompositional abstraction where each component is abstracted and refined iteratively.
the approach proposed inthis work breaks with tradition of agr such that both of them 1andm2components are abstracted and refined by the interpolants obtained from unsatisfiability proofs of boundedmodel checking formulas.
the closest work to the proposed approach in this paper is which focuses on automatic assumption generationfor compositional symbolic verification as well.
we havetried to obtain an implementation of for experimentalcomparisons but failed.
the differences between this workand are listed as follows and we compare them intheoretical point of views.
our approach uses interpolation techniques to generatethe assumption while uses the cdnf algo rithm which is an active algorithm for learningboolean formulas from membership and candidatequeries.
regarding the ag nc proof rule in equation our approach need not check the second condition m precedesequala2 because a2is an abstraction of m2 by construction according to the characteristic ofinterpolations.
however in m precedesequala2has to be verified by model checking each time when acandidate assumption a 2is constructed which is an additional overhead compared to our approach.
the partition problem in agr is not solved in i.e.
the partition has to be given manually while ourapproach solves it by unsatisfiability cores of bmcformulas.
vii.
c onclusion and future work in this work we propose an automatic compositional symbolic verification based on interpolations.
the assump tiona 2required by assume guarantee reasoning is obtained by symmetric interpolants from the unsatisfiability proofs ofbounded model checking.
in addition the proposed approachalso weakens the component m 1based on interpolations during the verification which further alleviates the state spaceexplosion problem when checking m bardbla2 .
currently we use mcmillan s interpolation technique.
in the future weplan to use different interpolation techniques to generate theassumptions and to compare the verification results based ondifferent interpolation techniques.
r eferences fabio cudd .
r. alur p. madhusudan and w. nam.
symbolic compositional verification by learning assumptions.
in ca v volume of lncs pages .
d. angluin.
learning regular sets from queries and counterexamples.
information and computation .
h. barringer d. giannakopoulou and c. s. p as areanu.
proof rules for automated compositional verification through learning.
in sa vcbs pages .
s. bensalem y .
lakhnech and s. owre.
computing abstractions of infinite state systems compositionally and automatically.
in ca v volume of lncs pages .
n. h. bshouty.
exact learning boolean function via the monotone theory.
information and computation .
s. chaki e. clarke o. grumberg j. ouaknine n. sharygina t. touili and h. veith.
state event software verification for branching time specifications.
in ifm volume of lncs pages .
s. chaki j. ouaknine k. yorav and e. clarke.
automated compositional abstraction refinement for concurrent c programs a two levelapproach.
electronic notes in theoretical computer science .
s. chaki and o. strichman.
optimized l based assume guarantee reasoning.
in tacas volume of lncs pages .
y .
f. chen e. m. clarke a. farzan m. h. tsai y .
k. tsay and b. y .
wang.
automated assume guarantee reasoning through implicitlearning.
in ca v volume of lncs pages .
a. cimatti a. griggio b. schaafsma and r. sebastiani.
the mathsat5 smt solver.
in tacas volume of lncs .
e. m. clarke and e. a. emerson.
design and sythesis of synchronization skeletons using branching time temporal logic.
in logics of programs workshop volume pages .
e. m. clarke d. e. long and mcmillan k. l. compositional model checking.
in lics pages .
j. m. cobleigh d. giannakopoulou and c. s. p as areanu.
learning assumptions for compositional verification.
in tacas volume of lncs pages .
j.m.
cobleigh g. s. avrunin and l. a. clarke.
breaking up is hard to do an investigation of decomposition for assume guarantee reasoning.
inissta pages .
m. craig.
a new form of the herbrand gentzen theorem.
journal of symbolic logic .
m. gheorghiu d giannakopoulou and c. s. p as areanu.
refining interface alphabets for compositional verification.
in tacas volume of lncs pages .
o. grumberg and d. e. long.
model checking and modular verification.
inconcur volume of lncs pages .
t. a. henzinger s. qadeer and s. k. rajamani.
you assume we guarantee methodology and case studies.
in ca v volume of lncs pages .
r. jhala and k. l. mcmillan.
interpolant based transition relation approximation.
in ca v volume of lncs pages .
r. jhala and k. l. mcmillan.
interpolant based transition relation approximation.
logical methods in computer science .
r. j. leduc m. lawford and p. c. dai.
hierarchical interfacebased supervisory control of a flexible manufacturing system.
ieee transactions on control systems technology .
s. w. lin e. andr e j. s. dong j. sun and y .
liu.
an efficient algorithm for learning event recording automata.
in atva volume oflncs pages .
s. w. lin e. andr e y .
liu j. sun and j. s. dong.
learning assumptions for compositional verification of timed systems.
ieee transactions on software engineering tse .
s. w. lin and p. a hsiung.
counterexample guided assumeguarantee synthesis through learning.
ieee transactions on computers .
s. w. lin and p. a. hsiung.
compositional synthesis of concurrent systems through causal model checking and learning.
in fm volume of lncs pages .
s. w. lin y .
liu j. sun j. s. dong and e. andr e. automatic compositional verification of timed systems.
in fm volume of lncs pages .
k. l. mcmillan.
symbolic model checking an approach to the state explosion problem.
ph.
d. thesis carnegie mellon university .
k. l. mcmillan.
interpolation and sat based model checking.
in ca v volume of lncs pages .
w. nam and r. alur.
learning based symbolic assume guarantee reasoning with automatic decomposition.
in atva volume of lncs pages .
t. k. nguyen j. sun y .
liu and j. s. dong.
a model checking framework for hierarchical systems.
in ase pages .
a. pnueli.
in transition from global to modular temporal reasoning about programs.
in logics and models of concurrent systems pages .
j. p. queille and j. sifakis.
specification and verification of concurrent systems in cesar.
in international symposium on programming volume pages .
m. h. queiroz j. e. r. cury and w. m. wonham.
multitasking supervisory control of discrete event systems.
discrete event dynamic systems .
n. sinha and e. m. clarke.
sat based compositional verification using lazy learning.
in ca v volume of lncs pages .
j. sun y liu j. s. dong and j. pang.
pat towards flexible verification under fairness.
in ca v volume of lncs pages .
q. xu w. p de roever and j. he.
the rely guarantee method for verifying shared variable concurrent programs.
f ormal aspects of computing .