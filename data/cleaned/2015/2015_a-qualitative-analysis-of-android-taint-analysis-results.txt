a qualitative analysis of android taint analysis results linghui luo paderborn university paderborn germany linghui.luo upb.deeric bodden paderborn university fraunhofer iem paderborn germany eric.bodden upb.dejohannes sp ath fraunhofer iem paderborn germany johannes.spaeth iem.fraunhofer.de abstract in the past researchers have developed a number of popular taint analysis approaches particularly in the context of android applications.
numerous studies have shown that automated code analyses are adopted by developers only if they yield a good signal to noise ratio i.e.
high precision.
many previous studies have reported analysis precision quantitatively but this gives little insight into what can and should be done to increase precision further .
to guide future research on increasing precision we present a comprehensive study that evaluates static android taint analysis results on a qualitative level.
to unravel the exact nature of taint flows we have designed cova an analysis tool to compute partial path constraints that inform about the circumstances under which taint flows may actually occur in practice.
we have conducted a qualitative study on the taint flows reported by flowdroid in real world android applications.
our results reveal several key findings many taint flows occur only under specific conditions e.g.
environment settings user interaction i o. taint analyses should consider the application context to discern such situations.
cova shows that few taint flows are guarded by multiple different kinds of conditions simultaneously so tools that seek to confirm true positives dynamically can concentrate on one kind at a time e.g.
only simulating user interactions.
lastly many false positives arise due to a too liberal source sink configuration.
taint analyses must be more carefully configured and their configuration could benefit from better tool assistance.
index t erms taint analysis path conditions android i. i ntroduction the past few years have brought to light a wealth of diverse taint analysis approaches most of them static and for the android platform .
static taint analysis is not a trivial task due to the static abstractions and sometimes approximations it requires.
static taint analysis for android is particularly challenging since one must consider some rather unique features of android android apps are not standalone applications but rather plugins for the android framework.
as such they have a distinct life cycle and often numerous callbacks that respond to various environmental stimuli such as button clicks or location changes.
android apps often need to operate correctly for different platform versions and devices which is why they often contain code that is conditionalized with respect to various environment parameters.
in android it is a common and recommended practice for instance to obtain backward compatibility by probing the platform version.existing studies show that code analysis tools are most likely to be adopted if they yield high precision i.e.
a low rate of false positives which is hard given the challenges named above.
while all existing papers proposing those tools do comprise an insightful evaluation often even on a large scale these evaluations are virtually all entirely quantitative .
as such they do permit one to conclude how many taintflow warnings a given taint analysis tool reports on a given benchmark set but not of which nature those taint flows exactly are i.e.
under which conditions they can occur at runtime and what could be done further to discard potentially remaining false positives within those taint flows.
the lack of such qualitative data currently hinders progress in upcoming directions of research.
researchers are investigating novel hybrid combinations of static with dynamic analysis which for instance seek to dynamically confirm static analysis findings by computing an actual witness path exposing the taint flow at runtime .
to guide such research we present the first study that evaluates static android taint analysis results at a qualitative level.
in particular this study seeks to identify how taint flows are conditioned on ... environment settings platform versions country etc.
malicious applications can leak data based on environment settings .
user interactions previous work has shown that many android apps leak data as a result of user actions on certain widgets in the apps.
i o operations leaks that depend on specific inputs are difficult to trigger dynamically since the search space is often very large.
to facilitate this study we have implemented cova a static analysis tool that computes partial path constraints.
cova can be configured to track information about the three factors named above and thus the circumstances under which taint flows may actually occur in practice.
we conducted a case study of the most common taint flows data leaks reported by the static taint analysis tool flowdroid from real world android apps.
during manual inspection of the sampled taint flows we observed some default sources and sinks provided by flowdroid to be inappropriate they were causing only false positives and in large quantities.
unfortunately we found this to impact 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the empirical evaluation of many previously published papers .
after having eliminated these false positives we classified the reported taint flows with cova based on the three factors mentioned above.
our study reveals that at least of the flows are conditioned on at least one of the three factors environment interaction i o but also that few flows are conditioned on multiple factors at the same time.
this means that hybrid analysis tools must be able to deal with those factors but for each factor one can likely build specialized support.
of special interest to developers are taint flows that are not conditioned on the three factors above and which are also are intra procedural those low hanging fruits can be identified purely statically and are likely to be both correct and actionable to the developers.
static analysis tools should thus aim to prioritize their reporting.
we find that .
of all taint flows fall into this category.
to summarize this paper presents the following original contributions cova a static analysis tool to compute path constraints.
a micro benchmark to assess cova and similar tools.
a cova supported qualitative study of taint flows from android apps.
the insights drawn from the study are source sink configurations are essential to precision.
previous bad defaults have caused vast amounts of false positives.
many inter procedural taint flows in android applications are conditioned on user interactions and fewer on environment configurations or i o operations.
the three categories are almost disjoint.
this is good news one can build effective hybrid analysis tools that specialize on either category.
reported intra procedural taint flows are most likely to be true positives.
one should thus prioritize their reporting.
we make cova and the android apps we analyzed publicly available at a.git the rest of this paper is organized as follows we first motivate the need for the tool cova then explain its design and lastly our experimental study.
ii.
a m otiv a ting example figure shows an activity of an android application that contains a data leak a simplified example.
the activity first reads the unique device identifier line stores it into variable deviceid before method onclick uses the variable and sends an sms containing the identifier to the phone number line .
state of the art static taint analysis tools for android e.g.
flowdroid amandroid or droidsafe are capable of detecting such leaks with a high precision.
the tools deliver highly precise context field and flow sensitive results.however as we observed during our study these precision dimensions are insufficient when trying to understand how and when apps leak data.
while any of the mentioned taint analysis tools reports the leak in figure none of the tools reports that the leak can only occur under a specific execution path.
the tools are not pathsensitive .
the app leaks the device identifier only when it executes the source and sink statements.
their execution depends on three path conditions .
first the app must run the correct android sdk version line second the user must trigger the app to execute the onclick callback by pressing a button line and third a special system feature has to be enabled on the execution device line .
for an automatic qualitative evaluation of the path conditions of data leaks reported by the taint analysis tools we implemented the static analysis tool cova.
cova computes aconstraint map which associates with each statement of a program the path conditions required to execute the statement.
figure describes the workflow of cova when used with a taint analysis tool.
cova accepts as input an android application in bytecode format and a set of pre defined constraint apis .
cova then computes the path conditions i.e.
the constraint map which depend on values from the constraint apis.
instead of computing all path conditions for the program which is practically infeasible cova focuses on propagating values of the constraint apis and path conditions dependent on these.
the constraint map computed by cova can be used to refine the data leaks reported by an existing taint analysis tool i.e.
leaks can be reported with path constraints.
although we applied cova to taint analysis cova is applicable to any other client analysis that can benefit from path information.
to understand for instance the leak in figure it suffices to track the following constraint apis build.version.sdk int onclicklistener.onclick and packagemanager.hassystemfeature .
cova performs a context flow and field sensitive dataflow analysis starting from the entry point of the program.
in figure the entry point of the activity is oncreate and it is always executable thus the statement at line has the initial constraint true .
at each reachable invocation of a constraint api cova generates a tainted data flow fact simply referred to by taint .
in figure cova propagates the taint sdk true sdk starting from line .
the symbol sdk is the variable containing the value returned from the constraint api the second entry true is the constraint under which the data flow fact at the statement is reachable sdk stands for the symbolic value of the static field build.verson.sdk int .
cova then propagates the taints along the inter procedural control flow graph icfg of the program and creates constraints over the symbolic values of taints whenever taints are used in conditional statements.
for instance the return value of the method isrightversion istrue when the sdk version is at most .
the android app further branches indirectly based on the version at the if statement in line .
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
public class leakyapp extends activity ... override protected void oncreate bundle savedinstancestate string deviceid boolean z isrightv ersion if z deviceid telephonymanager.getdeviceid source button.setonclicklistener new view.onclicklistener override public void onclick view view packagemanager pm getapplicationcontext .getpackagemanager boolean t pm.hassystemfeature android.hardware.telephony if t smsmanager.sendtextmessage null deviceid null null sink private boolean isrightv ersion int sdk build.version.sdk int if sdk return false else return true sdk true sdk ret sdk false ret sdk true z sdk false z sdk true t click telephony true true true sdk true true click click click click telephony true true sdk sdk sdk 26variable constraint valueconstraint map fig.
.
a motivating example.
constraint mappre defined constraint apispre defined constraint apiscova data leakstaint analysis toolconstrained leaksbytecode fig.
.
the workflow of applying cova to taint analysis results.
constraint map of cova captures these path conditions.
cova computes the taint ret sdk true for the statement in line the taint encodes that the return value ret equals true when the version is sdk .
this taint propagates back to the call site in line as taint z sdk true .
in early results of our qualitative study we observed many data leaks to depend on callbacks of user interfaces which motivated us to symbolically represent them in cova.
technically cova creates a constraint click at the callback onclicklistener.onclick and propagates this constraint to all statements reachable from this method.
click is a symbolic value representing a button click only when a user clicks the button the statements become reachable.
cova propagates all taints from all constraint apis and simultaneously computes a constraint for each reachable statement based on available taints at the current statement.
once the data flow propagation is completed the constraint map isalso computed.
in this paper we enrich the leak reports by flowdroid with the constraints computed by cova.
we compute the constraint of a leak its leak constraint according to the logical formula csource csink in which csource denotes the constraint under which the source statement may be executed andcsink the same for the sink.
in the example the resulting leak constraint is sdk click telephony .
this leak constraint is used later in our study to classify the taint flows.
iii.
c omputing the constraint map computing the constraint map as shown in figure is nontrivial.
the execution of a branch may simultaneously depend on two or more values of some constraint apis.
a static analysis must jointly propagate all values to compute the final constraint for a branch.
as the values have to be propagated jointly the analysis is non distributive .
furthermore each value of a constraint api must be propagated throughout the whole program since values can flow to fields of objects before the fields are re accessed elsewhere and aliasing relations must be computed.
we implemented the analysis within the data flow framework v asco which solves non distributive interprocedural data flow problems in a highly precise contextand flow sensitive manner.
v asco propagates data flow facts elements of a data flow domain d from statement to statement along the inter procedural control flow graph icfg of the program.
the flow functions accept a data flow fact d d and a control flow edge angbracketleftn m angbracketrightof the icfg as input and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
output a new value d prime d. similarly to ifds v asco differentiates between the following four kinds of functions normal flow func handles intra procedural flows wherenis not a call site.
call local flow func handles intra procedural flows wherenis a call site.
it propagates the values of local variables not used at the call site.
call entry flow func handles an inter procedural flow from call site nto the first statement mof a callee.
it typically maps actual method arguments to formal parameters.
call exit flow func it is the inverse of c all entry flow func .
a. analysis domain the domain d for our analysis in v asco is twodimensional c 2t where cis a constraint domain and t is a taint domain.
we use dto denote an unknown fact.
consider data flow fact c t c 2tto hold at statement n thencis the constraint under which statement nis reachable.
we seed the data flow propagation with the fact true at the entry point of the application.
the constraint is true as the entry point statement is always reachable.
at the entry point the set tis the empty set as no constraint api call has been encountered.
in general tis the set of taints generated at constraint apis reaching statement n. each taint is a triple a c v tand consists of an access path a local variable followed by a finite sequence of fields .
the access path aencodes how the value of the constraint api is heap referenceable at statement n. v aluevholds the actual value of a. in the case it is the return value of a constraint api it is represented symbolically if possible concrete values of primitive types are traced.
the constraint cdescribes under which conditions ahas the value v. note at a statement nthe constraint cof a taint within the settand the constraint care not necessarily equal e.g.
line in figure .
the meet operator unionsqis the logical disjunction for the constraint domain and set union for the taint domain i.e.
c1 t1 unionsq c2 t2 c1 c2 t1 t2 for two data flow facts c1 t1 and c2 t2 .
for any c t w e define c t unionsq c t .
in the following we separate the flow functions into two parts the flow functions of the taint domain and of the constraint domain.
let angbracketleftn m angbracketrightbe a control flow edge and let cin tin refer to the data flow fact before nand cout tout denote the fact before m then we describe the flow function fin form of the result set cout tout f cin tin .
the analysis operates on an intermediate representation called jimple .
we define the analysis based on the statements affecting either cortof a data flow fact c t .
b. flow functions of the taint domain the flow functions of the taint domain mostly follow standard access path based taint tracking data flow propagation .
for instance as a field sensitive analysis cova1.
int a obj.randomv alue true .
boolean x getoptionx true .
if x true x true x .a x x x x !x x !x x .
if a x x x x a x unionsq true x !x x x x x a x !x x !x x .
print secret true false true incomplete taint set tin fig.
.
an example shows an incomplete taint set.
assume getoptionx is a constrain api whose return value is represented by the symbolic value x. kills any tainted access path with local variable xat an assignment statement n x .
lett in tin x .
for an assignment statement n x yit istout t in x c v if there is a taint y c v tin i.e.
if any incoming access path matches the right side an access path for the left side is added to the out set.
for a field store assignment statement i.e.
n x.a y an access path based analysis has to add the indirectly aliasing access paths ofx and cova relies on an on demand alias analysis .
a new taint is created at any assignment statement where the right side of the statement is labeled as a constraint api.
cova also tracks values which are indirectly influenced by constraint apis in form of taints.
we omit the details of each flow function here due to space constraints2.
c. flow functions of the constraint domain to compute cout cova conjoins the constraint cinwith an extending constraint cnew which is created at conditional statements or ui callbacks i.e.
cout cin cnew .
the constraint of each taint in tinwill also be extended with cnew .
moreover cova only propagates taints whose constraints are not equal to f alse .
thus tout x c cnew v x c v t inand c cnew negationslash f alse .
in the following we focus on introducing how cnew is computed.
normal flow func for an if statement n if a b with a comparison operator cova creates cnew based on the available taints in tin.
the following cases are considered i tincontains only taints for variable a analog for b .
assume there are ktaints a ci vi tinwithi ... k .
ifbis a constant cova creates a constraint eiby substituting the variable ain the formula a bwith its value viand 1the symbol is a placeholder representing an irrelevant argument.
2detailed flow functions can be found in the long version of this paper at a blob master longversion.pdf authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conjoining the result with cifor each taint a ci vi i.e.
ei vi b ciif the successor statement m is in the true branch of n. for the case mis in the f alse branch ei vi b ci.i fbis an untracked variable the formula vi bis replaced by the imprecise constraint im vi inei.
cova then computes cnew logicalortextk i 1ei cmiss .
we explain the constraint cmiss in the following.
if cova would track all values used in an if statement the taints a ci vi tin share the following invariant logicalortextk i 1ci cin.
in practice we often have an incomplete taint settin which means the value of afor some constraint is present but not for the other constraints and the invariant is violated.
figure illustrates such a case.
the taint set before the statement if a indicates ato hold the value under the constraint x. the statement if a has constraint cin true in red and is unconditionally reachable.
the taint set for ais incomplete because cova cannot propagate a taint for aunder the constraint !xasaholds an unknown return value of the method call obj.randomvalue .f o r variableathe constraint !xis the missing constraint cmiss .
ii tincontains taints for both aandb.
assume there are ktaints a ci vi tinandqtaints b dj wj tin.
cova computes eijby substituting aandbanalogously as in the previous case.
eij vi wj ci djfor the true branch andeij vi wj ci djfor the f alse branch.
let cmiss anddmiss be the missing constraints for variable aand brespectively cnew logicalortext ijeij cmiss dmiss .
for a switch statement the flow function is analog.
call entry flow func for a call n o.f a1 ... a k cnew sym f iffis a callback from the constraint apis.
call local flow func this function is the same as c allentry flow func .
call exit flow func the constraint stays unchanged.
d. obtaining the constraint map v asco terminates once a fixed point is reached.
the result computed by v asco is a map from ctx n context statement to data flow facts in c 2t.
thecinvalues before each statement are used to extract the constraint map.
since a statement ncan be in multiple contexts cova merges the cinvalues of nfrom different contexts by logical disjunction.
iv .
i mplement a tion we implemented cova as an extension to soot that computes partial path constraints for java and android applications.
the constraint apis are given in configuration files.
for android apps we construct call graphs using flowdroid .
for alias analysis cova s taint analysis uses boomerang a demand driven flow and context sensitive pointer analysis.
to simplify and evaluate the constraints during the constraint analysis we rely on the theorem prover z3 .
cova only propagates taints with satisfiable constraints.
the current implementation fully supports constraints in boolean propositional logic equality logic and linear arithmetic logic.
to increase scalability we did not model stringoperations precisely but instead only use imprecise symbolic values to express them.
to be able to judge the confidence in the results cova reports we developed a new micro benchmark publicly available with cova comprising specially crafted test programs e.g.
primitives or heap objects used in conditional statements nested conditional statements intra and interprocedural conditional dependencies callback invocations indirect conditional dependencies etc.
.
on this benchmark cova achieved a precision of and a recall of which gives us a reasonable confidence of the results cova computes.
v. e v alua tion our evaluation is designed to understand the nature of taint flows detected by a static android taint analysis tool and potential avenues to eliminating false positives among those taint flows.
we chose flowdroid as our evaluation tool since it is well maintained and according to previous studies beats other tools both in accuracy and efficiency.
the evaluation intends to answer the following research questions rq1.
what types of taint flows does flowdroid report?
how common is each type?
rq2.
how large is the fraction of easily actionable unconditional intra procedural taint flows and what characteristics do these flows have?
we next address both questions one after the other.
rq1.
what types of taint flows does flowdroid report?
how common is each type?
a methodology we randomly sampled android apps from the androzoo dataset .
all sampled apps were available in popular app stores google play and anzhi market between year and .
these criteria ensure that we report on the real world apps from recent years.
the apps can be downloaded from this link3.
we used flowdroid v2.
.
in its default configuration.
in this configuration flowdroid lists methods as sources4and as sinks.
we applied flowdroid to these apps and it reported apps to contain data leaks.
flowdroid reported taint flows for these apps which makes it intractable to study every single taint flow in every app.
thus our methodology follows these two steps we measured which source sink pairs appeared in the taint flows and chose the top source sink pairs among intraand inter procedural taint flows see table i for our case study since these source sink pairs dominate a large amount of taint flows and among most of the remaining pairs each pair only appeared in fewer than taint flows out of in total .
to determine apps for our case study we applied stratified random sampling the apps with taint flows using these source sink pairs are divided into groups one for sources are listed in the configuration file sourcesandsinks.txt and source android.app.activity.findviewbyid int is treated specially by only considering password input fields.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able i stra tified sampling the top source sink p airs among the t aint flows reported by flow droid gr .
source sink taint flows apps sampled apps intra procedural a java.net.url.openconnection java.net.httpurlconnection.setrequestproperty b android.os.handler.obtainmessage android.os.handler.sendmessage c java.net.httpurlconnection.getoutputstream java.io.outputstream.write inter procedural d android.database.cursor.getstring android.app.activity.startactivityforresult e java.net.url.openconnection java.net.httpurlconnection.setrequestproperty f android.database.cursor.getstring android.os.bundle.putstring each pair which we here label with a to f. due to large amount of reverse engineering and manual work involved in the inspection we only sampled of the apps of each group.
the manual inspection was done in pair by two of the authors.
we conducted an experiment in which we applied both flowdroid and cova to the apps in our dataset.
an app is passed to both flowdroid and cova see figure .
the experiment was designed to classify the taint flows with the following types ui constrained taint flows are dependent on ui actions.
configuration constrained taint flows are dependent on hardware software configuration.
i o constrained taint flows are dependent on data inputs through streams or file system.
whenever a taint flow is reported by flowdroid we conjoin the constraints of the source and the sink computed by cova to obtain the leak constraint and use it to classify this taint flow.
for instance the leak in our motivating example see figure will be classified to both ui constrained and configuration constrained since the leak constraint sdk click telephony contains symbolic values which stand for configuration sdk and telephony and ui action click at the same time.
we collected a list of constraint apis from the android platform api level that cova ought to track apis for ui actions which are ui callbacks.
we first scanned the whole android platform with gestural keywords such as click scroll etc.
to extract a list of possible ui callbacks.
based on this list callbacks were manually selected.
apis for hardware and software configuration.
we collected the apis based on the official android guide of device compatibility .
apis for data input via i o streams or file system which are mainly from the java.io package.
the selection of the apis was done by pair reviewing by two researchers.
the list is publicly available with cova.
we set a timeout of minutes per app for cova.
cova terminated its analysis and computed a complete constraint map for apps.
in cases in which analysis times out this was most often due to slow constraint solving in z3 see section vi.
for the remaining apps cova only computed partial constraint maps.
the experiment was conducted on aui constrained configuration constrained i o constrainedinfeasible false positives unconstrained9.
.
.
.
.
.
.
.
.
fig.
.
different types of taint flows.
code pattern httpurlconnection c httpurlconnection new url http... .openconnection source c.set true c.setrequestproperty user agent mozilla .
sink code pattern message m handler.obtainmessage source handler.sendmessage m sink code pattern httpurlconnection c httpurlconnection new url http... .openconnection c.setdooutput true outputstream s c.getoutputstream source s.write data sink listing .
code patterns from group a b c. virtual machine with an intel xeon cpu running on debian gnu linux with oracle s java runtime version .
bit .
the maximal heap size of the jvm was set to gb.
b results figure shows the different types of taint flows and their fractions in our study.
while the false positives were all identified in step the fractions of other types ui constrained configuration constrained i o constrained infeasible unconstrained and intersections were computed in step .
the infeasible taint flows are those with unsatisfiable leak constraints reported by cova.
the fraction of the unconstrained taint flows is only an upper bound.
for apps on which cova timed out if there is no constraint for the source and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
public class mainactivity extends activity private string secret public void caller this .secret cursor.getstring i source callee public void callee intent i new intent this .startactivityforresult i ... sink listing .
code pattern from group d. sink statements of a taint flow in the partial constraint map we assigned this taint flow with the type unconstrained .
in step we studied the most common taint flows while keeping the following questions in mind is this taint flow feasible i.e.
could it be a leak?
do some code patterns with the same source sink pair exist in the taint flows?
to assess the feasibility we used the data flow path in jimple between source and sink of each taint flow reported by flowdroid and the decompiled code of the apps.
intra procedural taint flows groups a c as shown in table i the source sink pair url.openconnection httpurlconnection.setrequestproperty appeared most frequently in both intra and inter procedural taint flows group a and e .
while the given source method creates a connection object with a given url the sink sets the general properties of a http request.
this source sink pair combination apparently does not constitute a leak since the connection is not even opened when only calling url.openconnection .
one instead still has to call urlconnection.connect or equivalent methods e.g.
urlconnection.getinputstream to initiate the communication .
during the inspection for the above mentioned source sink pair in group a we discovered that the reported taint flows share some common patterns.
code pattern in listing shows an example usage of this source sink pair which is a common way to set up the header of a http request.
this is no leak.
code pattern in listing is another common pattern we identified in group b. the factory method handler .obtainmessage is regarded as a source by flowdroid.
this method creates a new empty message instance.
it does not poll a message from the message queue of the android handler.
this method should thus be excluded from the list of sources.
code pattern from group c is a similar case.
in summary taint flows which fall into these code patterns are false positives.
to determine how many taint flows match these code patterns we extended flowdroid to detect these patterns and re analyzed the apps in groups a b and c. in the end reported intra procedural taint flows matched these three code patterns.
as shown in these code patterns the root cause of these false positives is that their sources which flowdroid uses in its default configuration are actually inappropriate i.e.
they do not return sensitive data.
such a big fraction of false positives caused by this reason cannot be ignored.
thus the first author examined all 47t able ii inappropria te sources and sinks used by flow droid signature android.os.handler.obtainmessage android.os.handler.obtainmessage int int int android.os.handler.obtainmessage int int int object android.os.handler.obtainmessage int android.os.handler.obtainmessage int object android.app.pendingintent.getactivity context int intent int android.app.pendingintent.getactivity context int intent int bundle android.app.pendingintent.getbroadcast context int intent int android.app.pendingintent.getservice context int intent int java.net.urlconnection.getoutputstream java.net.url.openconnection sources by reading the javadoc carefully together with one developer with more than years experience in java.
altogether they identified apis that were mistakenly made source sink see table ii .
these inappropriate sources and sinks resulted in reported taint flows which is of all reported taint flows intra and inter procedural .
about a quarter of default sources provided by flowdroid are inappropriate and cause more than a quarter of all reported taint flows being false positives.
after a discussion with flowdroid s maintainers they confirmed the mistake and removed the inappropriate sources and sinks from the default list in flowdroid s github repository.
this affects the pairs a b c and e. inter procedural taint flows groups d f because the source of group e is inappropriate the manual inspection of this group was unnecessary.
we next describe the results of the manual inspection of the remaining groups d and f. the taint flows from group d use the source sink pair cursor .getstring activity.startactivityf orresult .
taint flows with this source sink pair could be part of a leak when the intent passed to activity.startactivityf orresult contains data reading from cusor .getstring and the second activity passes this received data to an untrusted sink.
since taint flows using such inter component communication are outside the scope of flowdroid our goal for inspection was only to check if this partial data flow is feasible.
surprisingly of the taint flows from group d proved to be false positives.
all these false positives share a similar code pattern shown in listing .
in this example flowdroid taints this.secret and reports a leak when the sink method is called on the base object of the taint this.secret which is the this object.
however there is no tainted data that flows into the intent passed for the sink method.
such over approximation in flowdroid s analysis logic while sometimes useful is too approximative for the sink activity.startactivityf orresult .
generally taint flows with taints connecting sources and sinks on the same objects should be filtered.
thus we extended flowdroid with a static analysis that detects such cases and re5the link to the commit flowdroid commit 211b73e32a0ade1ded021f2fc30b0aa647be5862 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
analyzed the relevant apps.
taint flows matched the false positive pattern in listing .
in total we identified taint flows with taints connecting sources and sinks on the same objects.
the sinks appearing in these taint flows are mainly apis used for inter component communication.
the remaining sinks e.g.
httpresponse.execute httpurirequest only make sense when the right parameter was tainted.
however flowdroid reported these taint flows when the base object was tainted.
in our study all taint flows reported by flowdroid with taints connecting sources and sinks on the same objects are false positives.
the sink bundle.putstring used in taint flows from group f is also an api for inter component communication.
similar to group d we checked if the reported partial flow is feasible.
we found out that while of the reported flows are feasible the false positives all happened in one app and the flows were just for putting the name of the app into the sink.
however the fact that the partial flows are feasible does not mean they are a part of true leaks since one does not know how the sensitive data stored in bundle were used in other activities which was not reported by flowdroid.
in total we identified that at least one third of taint flows reported by flowdroid in the default configuration are false positives.
in step we classified6taint flows that are dependent on the constraint apis with cova.
for instance if the leak constraint contains symbolic values that relate to the constraint apis from ui callbacks then this taint flow belongs to category ui constrained .
certainly there can be taint flows which belong to multiple categories.
as shown in figure among the .
taint flows whose occurrences are dependent on the constraint apis in the categories the majority are in a single category ui constrained which means they only occur when some specific ui actions are performed.
.
of the taint flows may happen under certain environment configurations and .
are dependent on inputs from i o operations.
the numbers in the v enn diagram s intersections of different categories indicate that interactions between values read from apis in different categories are rare but do exist.
taint flows are seldom conditioned by combinations of ui interactions environment configurations and i o operations.
most taints could thus be dynamically confirmed by different tools that specialize on the respective category.
because complex ui dependencies may require a test harness to drive the application with the needed sequences of events we investigated the complexity of the ui actions.
intuitively taint flows triggered by a sequence of user actions should exist.
a previous study has found malicious applications in which a user needs to click a series of buttons to trigger the display of a widget which leaks the data.
to 6note for the classification we excluded the false positives we identified in step .
number of ui actionsnumber of taint flows fig.
.
the distribution of ui constrained taint flows.
t able iii top constraint api s rela ted to t aint flows ui callback flows android.view.view.onclicklistener.onclick android.widget.adapterview.onitemclicklistener.onitemclick android.content.dialoginterface.onclicklistener.onclick configuration flows android.os.build.version.sdk int android.content.context.getsystemservice connectivity android.content.context.getsystemservice location i o operation flows java.io.inputstream.read java.io.bufferedreader.readline java.io.objectinputstream.readobject estimate the complexity we calculated how many different ui actions are involved in a ui constrained taint flow by counting the number of symbolic values for ui actions used in the leak constraint.
note that our constraint encoding is able to distinguish different ui actions.
figure shows the distribution of ui constrained taint flows.
.
of taint flows happen after a single ui action.
there are only .
of taint flows that may require or more ui actions.
maximally different actions appeared in a leak constraint.
however executing the taint flow does not require all actions at the same time since there are disjunctions in the leak constraint e.g.
a bcontains two actions aandb b u t one action is sufficient to execute the taint flow .
despite the existence of sophisticated sequences of ui actions our results indicate the dynamic exploration of most ui action related taint flows could be easier than expected.
among the configuration constrained taint flows the distribution is even simpler the largest number of taint flows .
require a single configuration option and .
of them are dependent on two options.
only taint flows happen under a complex configuration with more than two options.
the necessary configuration based conditions for exposing taint flows are easy to be satisfied in the majority of cases.
table iii shows which constraint apis from our categories are most frequently used.
while click events are relevant to most taint flows related to ui actions the android sdk authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
version plays a considerable role in environment configurations.
this is not surprising to us since the android operating system remains highly fragmented and developers are challenged to produce applications that are compatible to multiple platform versions.
however the importance of taint flows which only occur in obsolete versions of android may be limited in practice.
constraints based on i o operations are mostly checking if the end of a data stream has been reached e.g.
if inputstream.read !
.
additionally we observed that for of the infeasible taint flows their source statements were not executable since the path constraint is f alse .
for of the infeasible taint flows their sink statements will never be executed at runtime.
such dead code was probably intentionally built in by developers e.g.
during sampling we inspected code used for logging sinks of taint flows that was disabled with a boolean flag for the released apk but not removed.
rq2.
how large is the fraction of easily actionable unconditional intra procedural taint flows and what characteristics do these flows have?
c methodology taint flows that are intra procedural and unconstrained i.e.
the leak constraint computed by cova is equal to true are easy to detect and clearly directly actionable for developers.
we call such flows low hanging fruits .
we sought to acquire the characteristics of the lowhanging fruits and thus again applied stratified random sampling with proportion to the taint flows with top source sink pairs in table iv.
d results in our study only .
of the taint flows are low hanging fruits intra procedural and unconstrained .
however low hanging fruits are still the majority of the intra procedural taint flows and they exist in of the apps in our dataset.
during the manual inspection for taint flows with top source sink pairs in table iv we found that taint flows with source sink pair of group x cannot usually be interpreted as leaks.
listing shows a simplified taint flow using this source sink pair.
the private field this.secret is first tainted.
flowdroid taints the return value of this.getcontentresolver since the base object is the prefix of the tainted this.secret .
finally the taint flow is then reported when the sink is called on the tainted this.getcontentresolver .
this is again an over approximation flowdroid uses similar to the one in listing .
however such taint flow could be a leak since the implementation of context.getcontentresolver and contentresolver .query could be overridden maliciously.
in comparison to group x taint flows of group y and z are straightforward they log data from databases.
actually the log methods from android.util.log are the most frequently used sinks.
about half of the low hanging fruits are leaks in which sensitive information such as data from databases location information device id the mac addresses or even passwords are logged.
many of these leaks even have source and sink at the same line of code.
in addition the text that will be logged often specifies what kind of data is being logged.t able iv top source sink p airs among low hanging fruits gr .
source sink sampled total taint flows xandroid.database.
cursor.getstringandroid.content.
contentresolver.query14 yandroid.database.
cursor.getstringandroid.util.log.e zandroid.database.
cursor.getstringandroid.util.log.i public class mainactivity extends activity private string secret public void foo this .secret cursor.getstring i source this .getcontentresolver .query ... sink listing .
code pattern from group x. besides log methods sinks for inter component communication such as bundle.putstring sharedpreferences.putstring and context.sendbroadcast are also popular among the lowhanging fruits .
they appeared in of the taint flows.
to determine if these taint flows are malicious additional context must be provided since benign applications often use these methods for accessing and modifying preference data between activities.
discussion first our results show important ways in which taint analysis tools can and should be improved.
on the one hand the sources and sinks configured for the tools should be checked more carefully since an inappropriate source can cause a large amount of false positives as we determined for flowdroid in rq1.
researchers who used flowdroid in the default configuration may need to re evaluate their conclusions.
even in just a short investigation we already found papers in which the respective work was built on top of flowdroid and inappropriate sources or sinks were used .
in none of these papers did the authors mention that they have manually checked for false positives that would have been caused by the inappropriate source sink configurations.
hence while it is possible that such manual checks were conducted without mentioning them it is equally possible that the papers report results that are distorted by the presence of those false positives.
given the over citations of the flowdroid paper many more such works are likely to exist.
on the other hand some rules used in taint analysis may be not suitable for all sources and sinks as we have seen in the case shown in listing for flowdroid a taint flow was reported when the base object calling the sink was tainted.
however here the correct way to report a taint flow is when the actual argument intent of the sink is tainted.
such cases could be handled easily without increasing analysis complexity.
although we only studied the results reported by flowdroid problems we discovered for such a widely used tool may not be a single case among numerous taint analysis tools.
second hybrid analysis tools may well be feasible for the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
case of android.
the results of rq1 show that to confirm static taint flows dynamically they should focus on modeling ui actions but in some cases must be able to set correct environment options as well and must deal with stream i o to some limited extent.
luckily the overlap between those three classes is small so that one can probably go a long way even by designing specific decoupled analysis tools for all three situations.
our tool cova can further aid the implementation of such hybrid analysis tools the path constraints it computes can guide dynamic analyses even in situations where flows are not conditioned on external stimuli at all.
third low hanging fruits i.e.
unconditional intraprocedural flows are quite common they exist in of all apps as we show in rq2.
many of such leaks can be easily fixed and so even purely static taint analysis tools can and should prioritize these leaks in the report.
vi.
l imit a tions cova computes partial path constraints it only considers control flow decisions that are dependent on a list of constraint apis we collected.
however as we discuss in section v we feel that by the way this list was collected it is comprehensive.
although cova supports most language features some corner cases such as reflection or native calls are not covered .
in some cases the taint set computed by cova may be incomplete due to unknown return values of api method calls such that an over approximated constraint is computed.
for android applications we use the call graph constructed by flowdroid.
this call graph however is partially incomplete for library methods and some ui callbacks a known limitation of flowdroid.
since cova uses z3 for constraint solving the limitations of z3 are inherited by cova.
in our experiments an average of percent of the analysis time was occupied by z3.
in fact this is also one of the main reasons why cova failed to analyze some apps within the given time budget.
in the worst case of the analysis time for an app was spent for constraint solving.
increasing the time budget may not help since z3 can hit memory pressure and throw exceptions when solving large formulas which happened in our preliminary experiments.
such exceptions cannot be evaded by increasing the jvm heap size since they originate from the native code of z3.
in the future we plan to turn cova into an ondemand analysis such that it only computes a constraint for a given statement instead of computing a constraint map for all reachable statements.
since cova failed to analyze some apps in our experiment our study may have been biased to include only certain kinds of taint flows.
many of the unconstrained taint flows might be constrained by multiple factors in reality.
vii.
r ela ted work we discuss how our approach relates to previous work in the areas of taint analysis path conditions as well as hybrid analysis approaches.studies involving taint flows many researchers have studied android applications from various perspectives .
avdiienko et al.
compared the taint flows in benign apps against those in malicious apps and used machine learning to identify the differences in usage of sensitive data.
unlike cova their approach mudflow does not consider path constraints.
keng et al.
monitored android apps with the dynamic taint analysis tool taintdroid to study the correlation between user actions and leaks.
however their results are limited to the leaks they observed during the runtime.
their results show that many apps leak data due to user actions on certain gui widgets which we were able to show statically.
closely related to our approach lillack et al.
also extended taint analysis to explore the variability of android apps based on load time configuration.
however their approach encodes constraint analysis as a distributive problem in the ifds framework .
for our purpose this model is insufficient since the execution of a branch may depend simultaneously on two or more configuration options which ifds cannot express .
path conditions many approaches have considered path conditions to increase the accuracy of their analysis.
snelting has shown how exacting and simplifying path conditions can improve slice accuracy.
taghdiri et al.
made information flow analysis more precise by incrementally refining path conditions with witnesses that did not yield an information flow in execution.
t asman leverages backward symbolic execution as a post analysis to eliminate false positives in which taint flows along paths are infeasible at runtime.
t asman is based on the distributive ifds framework but constraint computation is not a distributive problem.
t asman thus needs to approximate in places which cova can handle precisely.
in result cova s computation is more expensive but cova s path expressions are also more precise.
a general major limitation of symbolic execution is that it cannot explore executions with path conditions which the underlying smt solver cannot deal with in the given time budget .
this limitation is shared with cova.
to improve scalability modern symbolic execution techniques mix concrete and symbolic execution in so called concolic execution.
anand et al.
propose a concolic execution approach to generate sequences of ui events for android applications.
sch utte et al.
also use concolic execution to drive execution to cover target code.
they claim that their approach is not limited to any specific kind of conditions i.e.
can handle all kinds of condition user input environmental setting and even remote site input .
y et their prototype condroid was only designed and evaluated for one specific vulnerability.
cova was evaluated on a wide range of taint flows.
the results of our study indicate that tools which seek to expose taint flow dynamically could concentrate on one kind of condition at a time which is important for scalability.
hybrid analysis a number of hybrid approaches i.e.
combinations of static and dynamic analysis have been proposed for android malware detection .
smartdroid by zheng et al.
statically detects ui interaction sequences authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that lead to sensitive api calls and it exposes those behaviors dynamically.
y ang et al.
propose a hybrid approach in which they first identify the possible attack critical path with static mining algorithms based on sensitive apis and existing malware patterns then execute the program in a focused scope under dynamic taint analysis.
wong et al.
demonstrate intellidroid a tool which generates a reasonably small set of inputs statically to trigger malicious behavior of applications.
their evaluation shows that one only needs to execute a very small part of the application to expose malicious behaviors.
recent work of rasthofer et al.
combines a set of static and dynamic analyses with fuzzing to generate execution environments to expose hidden malicious behaviors efficiently.
viii.
c onclusion in this paper we introduced cova a new tool for tracking user defined apis through the program and computing path constraints based on these apis.
we conducted a covasupported study which gathers information about the nature of static taint analysis results particularly with flowdroid.
our study shows important ways how static taint analysis tools can be improved and how information about taintflows conditioned on different factors can be used for future taint analysis research particularly with the aim of further eliminating false positives.
ix.
a cknowledgment we would like to thank manuel benz for his assistance in selecting the constraint apis and jonas manuel for his assistance in reviewing the default list of sources and sinks provided by flowdroid.
we would also like to thank our reviewers for their comments.
this research was supported by the research training group human centered systems security nerd.nrw sponsored by the state of north rhine westphalia in germany.