classifying developers into core and peripheral an empirical study on count and network metrics mitchell joblin siemens ag erlangen germanysven apel claus hunsen university of passau passau germanywolfgang mauerer siemens ag oth regensburg munich regensburg germany abstract knowledge about the roles developers play in a software project is crucial to understanding the project s collaborative dynamics.
in practice developers are often classified according to the dichotomy of core and peripheral roles.
typically count based operationalizations which rely on simple counts of individual developer activities e.g.
number of commits are used for this purpose but there is concern regarding their validity and ability to elicit meaningful insights.
to shed light on this issue we investigate whether count based operationalizations of developer roles produce consistent results and we validate them with respect to developers perceptions by surveying developers.
improving over the state of the art we propose a relational perspective on developer roles using fine grained developer networks modeling the organizational structure and by examining developer roles in terms of developers positions and stability within the developer network.
in a study of substantial open source projects we found that the primary difference between the count based and our proposed networkbased core peripheral operationalizations is that the networkbased ones agree more with developer perception than countbased ones.
furthermore we demonstrate that a relational perspective can reveal further meaningful insights such as that core developers exhibit high positional stability upper positions in the hierarchy and high levels of coordination with other core developers which confirms assumptions of previous work.
i. i ntroduction the popular onion model first proposed by nakakoji et al.
comprises eight roles typically appearing in opensource software projects.
these roles extend from passive users of the software to testers and active developers.
according to this model there is a clear and intentional expression of the substantial difference in scale between the group sizes fulfilling each role.
quantitative evidence from several empirical studies substantiates this model by showing that the number of code contributions per developer is described by heavytailed distributions which implies that a very small fraction of developers is responsible for performing the majority of work .
on the basis of these results the distinction between different roles of developers is often coarsely represented as a dichotomy comprised of core and peripheral developers .
in an abstract sense core developers play an essential role in developing the system architecture and forming the general leadership structure and they have substantial long term involvement .
in contrast peripheral developers are typically involved in bug fixes or small enhancements and they have irregular or short term involvement .despite having a substantial understanding about the defining characteristics of core and peripheral developers and recognizing the importance of the interplay between these roles there is significant uncertainty around core peripheral operationalizations.
a valid and reliable core peripheral operationalization is crucial for testing empirical evidence of proposed theories regarding collaborative aspects of software development .
while several basic operationalizations have been proposed and loosely justified by abstract notions they may be overly simplistic.
for example one common approach is to apply thresholding on the number of lines of code contributed by each developer but this could result in incorrectly classifying developers who just make large numbers of trivial cleanups.
further evidence suggests that as a developer moves into a core role their activity in terms of commit count or lines of code decreases substantially because they shift their efforts to coordinating the work of others .
the major weakness of existing core peripheral operationalizations stems from the fact that they are primarily based on counting individual developer activity e.g.
lines of code number of commits number of e mails sent which lack any explicit consideration of interdeveloper relationships.
since many important characteristics of developer roles are concerned with how developers or their actions interact with other developers we recognize inter developer relationships to be of primary importance for the operationalization of developer roles.
the contributions of this work can be summarized by two main achievements.
firstly we statistically evaluate the agreement between the most commonly used operationalizations of core and peripheral developers by examining data stored in the version control systems vcs and developer mailing lists of substantial open source projects.
secondly we establish and evaluate richer notions of developer roles with a basis in relational abstraction.
more specifically we adopt a network analytic perspective to explore manifestations of core and peripheral characteristics in the evolving organizational structure of software projects as operationalized by finegrained developer networks .
for evaluation we performed a survey among developers to establish a ground truth classification of developer roles to test whether the existing operationalizations and our network based insights are consistent with respect to each other and valid with respect to developer perception.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in summary we make the following contributions we statistically evaluate the agreement between classifications of core and peripheral developers generated from commonly used operationalizations henceforth called count based operationalizations by studying substantial open source projects over at least one year of development with data from two sources version control system and mailing list .
we conducted a survey among developers to establish a ground truth composed of samples which we use to evaluate the validity of several core peripheral operationalizations with respect to developer perception.
we identify structural and temporal patterns in the project s organizational structure that operationalize core peripheral roles using network analysis techniques referred to as the network based operationalizations.
we demonstrate that network based operationalizations exhibit moderate to substantial agreement with the existing count based operationalizations but the networkbased operationalizations are more reflective of developer perception than the count based operationalizations.
we highlight and discuss a number of insights from our network based operationalizations that are incapable of being expressed by count based operationalizations such as positional stability hierarchical embeddings and interaction patterns between core and peripheral developers.
all experimental data and source code are available at a supplementary web site.
ii.
b ackground r ela ted work researchers have examined the core and peripheral developer roles from two distinct perspectives from a social perspective by studying communication and collaboration patterns and from a technical perspective by studying patterns of contributions of developers to technical artifacts .
regarding social characteristics core developers play a central role in the communication and leadership structure and have substantial communication ties to other core developers especially in projects with a small developer community people .
regarding technical characteristics core developers typically exhibit strong ownership over particular files that they manage they often have detailed knowledge of the system architecture and they have demonstrated themselves to be extremely competent .
in contrast peripheral developers are primarily involved in identifying code quality issues and in proposing fixes while also participating moderately in development related discussions .
as the roles of developers are not static prior research has also investigated temporal characteristics of core and peripheral developers in terms of the advancement process to achieving core developer status.
advancement is typically merit based and often involves long term consistent intensive involvement in a project .
many of the aforementioned studies applied empirical methods based on interviews questionnaires personal experience reports and manual inspections of data archives to identify characteristics of core and peripheral developers.
an alternative line of research has attempted to operationalize the roles of core and peripheral developers using data available in software repositories such as version control systems bug trackers and mailing lists .
by operationalizing the notion of core and peripheral developers these studies have taken important steps towards gaining insight that is not attainable with more manual approaches including evaluating and basing conclusions on results from hundreds of projects .
despite the usage of numerous operationalizations by researchers we have very limited knowledge about their validity though.
there is a reasonable cause for concern that some corresponding metrics are overly simple most operationalizations are single dimension values that represent the developer s activity level e.g.
the number of commits made with a corresponding threshold based on a prescribed percentile.
a commonly used approach is to count the number of commits made by each developer and then to compute a threshold at the percentile.
developers that have a commit count above the threshold are considered core developers below are considered peripheral .
this threshold was rationalized by observing that the number of commits made by developers typically follows a zipf distribution which implies that the top of contributors are responsible for of the contributions .
following a similar direction mockus et al.
found empirical evidence for mozilla browser and apache web server that a small number of developers are responsible for approximately of the code modifications .
however in a replication study performed on freebsd the results indicated that a set of top developers are responsible for approximately of the changes but this group does not coincide well with the elected core developer group .
further attempts have been made to investigate the difference between core and peripheral developers by using basic social network centrality metrics and a corresponding threshold .
in these cases developer networks have been constructed on a dyadic domain of either mutual contributions to mailing list threads or sourcecode files.
while many approaches exist to classify developers into core and peripheral no substantial evidence has been accumulated to evaluate the validity and consistency of these different operationalizations.
crowston et al.
investigated three operationalizations of core and peripheral developers but they focused only on bug tracker data and neglected code authorship entirely.
olivia et al.
dedicated attention on developing a more detailed characterization of so called key developers which is similar to the core developer dichotomy.
they investigated mailing lists and version control systems with three operationalizations to classify developers as core or authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
peripheral.
their results indicate that there is some evidence of agreement between the different operationalizations but this was only shown for one release of a single small project with only developers in total and core developers.
we improve over the state of the art by considering a larger and more diverse set of projects with larger developer communities by using more metrics and by analyzing at least one year of development to evaluate the temporal stability of our results.
additionally we use developer network models that have been validated in prior studies .
iii.
count based opera tionaliza tions based on a review of the existing literature we have identified three variations of count based operationalizations of core peripheral roles .
in the literture metrics are used with a percentile threshold to define a dichotomy composed of core and peripheral developers.
we apply the standard 80th percentile threshold because of its wide use and its justification based on the data following a zipf distribution see section ii .
two operationalizations capture technical contributions to the version control system and one captures social contributions to the developer mailing list.
commit count is the number of commits a developer has authored merged to the master branch .
a commit represents a single unit of effort for making a logically related set of changes to the source code.
core developers typically make frequent contributions to the code base and should in theory achieve a higher commit count than peripheral developers.
lines of code loc count is the sum of added and deleted lines of code a developer has authored merged to the master branch .
counting loc as it relates to developer roles follows a similar rationale as commit count.
as core developers are responsible for the majority of changes they should reach higher loc counts than peripheral developers.
a potential source of error is that developers writing inefficient code or changing a large number of lines with trivial alterations e.g.
whitespace changes could artificially affect the classification.
mail count is the number of mails a developer contributed to the developer mailing list.
core developers often posses indepth technical knowledge and the mailing list is the primary public venue for this knowledge to be exchanged with others.
core developers offer their expertise in different forms making recommendations for changes discussing potential integration challenges or providing comments on proposed changes from other developers.
typically peripheral developers ask questions or ask for reviews on patches they propose.
core developers often participate more intensively and consistently and have greater responsibilities than peripheral developers in general.
this should result in core developers making a large number of contributions to the mailing list.
this is still only a very basic metric because a developer answering many questions and one asking many questions will appear to be similar and there is no inter developer information so who is speaking with whom or with how many people is completely ignored.each of the above metrics has a foundation rooted in our current empirical understanding of the characteristics of core and peripheral developers but in the end they are all relatively simple abstractions of a potentially multifaceted and complex concept .
a comparison between the resulting classification of developers from these different metrics will provide valuable insights into whether systematic errors exist in these count based operationalizations which we perform in section vi a. however as the focus of these metrics is still only to assign developers exclusive membership to one of two unordered sets without relational information between sets or within the sets the insights offered by the classification are of limited practical value.
to address this shortcoming we propose a relational view on developer coordination and communication as the basis for developer role operationalizations.
iv .
a n etwork perspective a developer network is a relational abstraction that represents developers as nodes and relationships between developers as edges.
the promise of a network perspective is greater practical insights concerning the organizational and collaborative relationships between developers .
but to what extent can this promise be fulfilled?
so far we know that developer networks when carefully constructed on version control system and mailing list data can be both accurate in reflecting developer perception and reveal important functional substructure or communities with related tasks and goals .
what can be elicited from developer networks regarding the core peripheral dichotomy has not yet been greatly explored especially in comparison to non network based approaches which is our intention in this work.
practical opportunities for network insights are for example identifying core developers that are overwhelmed by the peripheral developers they need to coordinate with structural equivalence that is two nodes with the same neighbors could reveal which core developers have similar knowledge or technical abilities which helps to determine appropriate developers for sharing or shifting development tasks structural holes between core developers may indicate deteriorating coordination or a single globally central core developer may indicate an important organizational risk.
a. network model we now present the details of our network analytic approach for analyzing data from version control systems and mailing lists to examine relational characteristics of core and peripheral developers.
intuition and prior research led us to the conclusion that the role a developer fulfills can change over time .
for this reason we analyze multiple contiguous periods over one year of a project in question using overlapping analysis windows.
each analysis window is three months in length and each subsequent analysis period is separated by two weeks .
we chose three month analysis windows because it has been shown that beyond this window size authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the development community does not change significantly but temporal resolution in their activities is lost .
e mail networks for a given project we download the mailing lists archives either from gmane using nntp pull or directly from the project s homepage to obtain an mbox formatted file containing all messages sent to the mailing list.
most projects have different mailing lists for different purposes.
we consider only the primary mailing list for development related discussions.
we apply several preprocessing steps to remove duplicated messages normalize author names and organize the mails into threads using the message ids and in replyto ids .
furthermore we decompose the from lines of each mail into a angbracketleftname e mail address angbracketrightpair.
in some cases only an e mail address or only a name is possible to recover and this can present issues with identifying all e mails that a single person sent.
to resolve multiple aliases to a single identity we use a basic heuristic approach similar to the one proposed by bird et al.
.
despite the potential problems regarding author name resolution as developers accumulate valuable credibility through contributions to the mailing list it is counterproductive for highly active individuals to use multiple aliases and conceal their identity.
to construct a network representation of developer communication we apply the standard approach where edges are added between individuals who make subsequent contributions to a common thread of communication .
v ersion control system networks data in version control systems are organized in a tree structure composed of commits.
we analyze only the main branch of development as a linearized history by flattening all branches merged to master.
furthermore we analyze only the authors of commits not the committer which are expressed differently in git and attribute the commit to a unique individual using the same aliasing algorithm as for the mailing list data.
we count lines of code for each commit based on diff information where the total line count is the sum of added and deleted lines.
the network representation of developer activities in the version control system is constructed using fine grained function level information which was observed to produce authentic networks that agree with developer perception .
in this approach changes are localized to function blocks using source code structure to identify when two developers edit interdependent lines of code.
we enhance the network with semantic coupling relationships between functions which has shown to also reflect developer perception of artifact coupling .
the semantic relationships are identified by making use of the domain specific words that are embedded in the textual content of the implementation e.g.
variable and function identifiers .
b. core and peripheral developers in developer networks in section ii we discussed the expectation that characteristics of core and peripheral developers should manifest in ways that transcend the count based operationalizations introduced in section iii an expectation that is also supported by a survey among open source developers see section vi e .next we introduce five network based operationalizations that are rooted in the structure and evolution of developer networks see section iv a .
degree centrality aims at measuring local importance.
it represents the number of ties edges a developer has to other developers .
as essential members of the leadership and coordination structure core developers associate with other core members and with peripheral developers that require their technical guidance.
peripheral developers are likely involved in only a small number of isolated changes and thus have only a limited number of interactions with other members of the development community.
the expectation is that core developers then have a larger degree than peripheral developers.
eigenvector centrality is a global centrality metric that represents the expected importance of a developer by either connecting to many developers or by connecting to developers that are themselves in globally central positions .
since core developers are critical to the leadership and coordination structure we expect them to occupy globally central positions in the developer network.
hierarchy is present in networks that have nodes arranged in a layered structure such that small cohesive groups are embedded within large less cohesive groups.
in a hierarchical network nodes with high degree tend to have edges that span across cohesive groups thereby lowering their clustering coefficient .
prior work has shown that developers tend to form cohesive communities and we expect core developers to play a role in coordinating the effort of these communities of developers.
if this is true then core developers should have a high degree and low clustering coefficient placing them in the upper region of the hierarchy while peripheral developers should exhibit a comparatively low degree and high clustering coefficient placing them in the lower region of the hierarchy.
role stability is a temporal property of how developers switch between roles.
for this reason we investigate the patterns of developers transitions through different roles by observing changes in the corresponding developer network over time.
as core developers typically attain their credibility through consistent involvement and often have accumulated knowledge in particular areas of the system over substantial time periods see section ii we expect their stability in the developer network to be higher than for peripheral developers.
we operationalize developer stability by estimating the probability that a developer in a given role leaves the project by not participating for at least three months.
for each developer the role during each development window is determined using the degree centrality operationalization.
the time ordered sequence of roles for each developer is then used in a maximum likelihood estimation to solve for each state transition parameter e.g.
the probability that a core developer transitions to a peripheral role .
core peripheral block model is a formalization proposed in the social network literature that captures the notion of core periphery structure based on an adjacency matrix representation.
the block model specifies the core core region of the matrix as a block i.e.
completely connected the core authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
peripheral regions as imperfect blocks and the peripheral peripheral region as a block .
intuitively this model describes a network as a set of core nodes with many edges linking each other surrounded by a loosely connected set of peripheral nodes that have no edges connecting each other.
of course this idealized block model is rarely observed in empirical data .
still we are able to draw practical consequences from this formalization by estimating the edge presence probability of each position to test if core and peripheral developers operationalized by degree centrality occupy core and peripheral network positions according to this block model.
from the block model one can mathematically reason that the probability of observing an edge in each block is distinct and related according to pcore core p core periph pperiph periph .
this model aligns with empirical data that indicate that core developers are typically well coordinated and are expected to be densely connected in the developer network .
since peripheral developers often rely on the knowledge and support of core developers to complete their tasks it follows that peripheral developers often coordinate with core developers and only in rare cases would we expect substantial coordination between peripheral developers.
this expected behavior aligns very well to the formalized notion of core periphery positions from social network analysis.
v. e mpirical study a. subject projects we selected ten open source projects listed in table i to study the core peripheral developer roles.
we specifically chose a diverse set of projects to avoid biasing the results.
the projects vary by the following dimensions a size source lines of code from 50kloc to over mloc number of developers from to b age days since first commit c technology programming language libraries d application domain operating system development productivity etc.
e development process employed.
developers of the project referred to as project x have requested that their project name remains anonymous.
b. research questions while each of the approaches for classifying core and peripheral developers is inspired by common abstract notions rooted in empirical results it has not been shown that the approaches agree.
it may be the case that they capture orthogonal dimensions of the same abstract concept which gives rise to our first research question rq1 consistency do the commonly applied operationalizations of core and peripheral developers based on versioncontrol system and mailing list data agree with each other?
compared to the extent of our knowledge regarding the characteristics of core and peripheral developers existing count based operationalizations are relatively simple.
since core developers often have strong ownership over particular files and play a central role in coordinating the work of others on those artifacts we would expectcore developers to differ in a relational sense from peripheral developers in how they are embedded in the communication and coordination structure.
furthermore as core developers typically achieve their status through long term and consistent involvement we expect their temporal stability patterns to differ from peripheral developers.
rq2 positions stability do the differences between core and peripheral developers manifest in relational terms within the communication and coordination structure with respect to their positions and stability?
the utility offered by an operationalization is limited by the extent to which the operationalization is able to accurately capture a real world phenomenon.
so far it is unclear to what extent the core peripheral operationalizations reflect developer roles as seen by their peers.
we explore whether relational abstraction as in the network based operationalizations improves over the count based operationalizations by more accurately reflecting developer perception through explicit modeling of developer developer interactions.
rq3 developer perception to what extent do the various count based and network based operationalizations agree with developer perception?
c. hypotheses the existing count based operationalizations of core and peripheral developers discussed in section iii claim to be valid measures and if this is a matter of fact we expect to reach consistent conclusions about whether a given developer is core or peripheral.
due to finite random sampling and sources of noise we expect imperfect agreement between two operationalizations even if they are consistent in capturing the same abstract concept.
however if the operationalizations are consistent the level of agreement should be significantly greater than the case of random assignment of developer roles.
our null model for zero agreement is the amount of agreement that results from two operationalizations that assign classes according to a bernoulli process.2to operationalize agreement between two binary classifications core or peripheral of a given set of developers we use cohen s kappa po pe pe wherepois the number of times the two classifications agree on a role of a developer divided by the total number of developers and where peis the expected probability of agreement when there is random assignment of roles to developers but the proportion of each class is maintained.
cohen s kappa is more robust than simple percent agreement because it incorporates the effect of agreement that occurs by chance .
this characteristic is particularly important in our case since the frequency of roles is highly asymmetric as the majority of developers are peripheral and only a small fraction are core.
the ranges for cohen s kappa and corresponding strengths of agreement are .
.
al2a bernoulli process generates a sequence of binary valued random variables that are independent and identically distributed according to a bernoulli distribution.
the process is essentially simulating repeated coin flipping.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able i overview of subject projects edge probabilities hierarchy project domain lang devs sloc commits date c c c p p p rho1p value project x user c js 10m 276k .75e .19e .70e .
.51e django devel python 430k 41k .95e .09e .08e .
.28e ffmpeg user c 1m 78k .50e .44e .16e .
.10e gcc devel c .5m 144k .07e .84e .01e .
.12e linux os c 18m 637k .39e .93e .60e .
.06e ll vm devel c .1m 62k .80e .54e .62e .
.72e postgresql devel c 1m 40k .00e .62e .13e .
.31e qemu os c 1m 43k .20e .95e .16e .
.76e u boot devel c .3m 35k .00e .59e .20e .
.27e wine user c .8m 110k .46e .91e .28e .
.04e 1spearman s correlation coefficient most perfect .
.
substantial .
.
moderate .
.
fair .
.
slight and .
poor .
h1 existing count based operationalizations of core and peripheral developers based on version control system and mailing list data are statistically consistent in classifying developer roles.
the abstract notion of core and peripheral developers discussed in section ii emphasizes the multitude of ways the two groups differ e.g.
contribution patterns knowledge level of engagement organization responsibility etc.
.
while existing operationalizations of core and peripheral developers are primarily based on simple metrics of counting high level activities of developers these metrics largely ignore the richness in the definition of core and peripheral roles.
in particular the dimension of time is largely ignored though time plays a central role in the developer advancement process .
h2 the well known abstract characteristics of core developers will manifest as distinct structural and temporal features in the corresponding developer network core developers will exhibit globally central positions relatively high positional stability and hierarchical embedding.
as core developers form the primary coordination structure we expect to observe many edges in the developer network between core developers less edges between core and peripheral developers and even fewer edges between peripheral developers.
we investigate this hypothesis in terms of preferences between the groups to associate based on the probability of an edge occurring between them according to the core peripheral block model see section iv b .
h3 core developers have a preference to coordinate with other core developers peripheral developers have a preference to coordinate with core developers instead of other peripheral developers.
we expect developer networks to reveal core and peripheral developers albeit in a richer representation with comparable precision to the currently accepted operationalizations.
more specifically we expect developer networks capture the core peripheral property to an equally high standard as the currently accepted operationalizations any disagreement should be onthe order of the discrepancy between existing operationalizations.
h4 the core peripheral decomposition obtained from developer networks will be consistent with the core peripheral decomposition obtained from the prior accepted operationalizations.
the discrepancy in agreement will not exceed the amount observed between the existing operationalizations.
as the count based operationalizations appear to reasonably capture simple aspects of developer roles we expect a certain level of agreement between these operationalizations and developer perception.
in the case of the network based operationalizations we expect even higher agreement with developer perception since the relational abstraction explicitly captures developer developer interactions which are neglected by the count based operationalizations.
h5 count based operationalizations agree with developer perception but network based operationalizations exhibit higher agreement.
d. developer perception to establish a ground truth classification of developer roles we designed an online survey in which we asked developers to report the roles of developer s in their project according to their perception.
the goal of acquiring these data is to test whether the core peripheral operationalizations are valid with regard to developer perception not only to other operationalizations .
a sample of the survey instrument can be found at the supplementary web site.
we recruited participants for the study from the versioncontrol system data of our ten subject projects by identifying the e mail addresses of individuals that made a commit within the three months prior to the survey date see table i .
this was to ensure that the selected developers have current knowledge of the project state so that their answers are temporally consistent with our analysis time frame.
one subject project gcc was excluded from the survey because the developer email addresses are not available in the version control system.
for the remaining projects we sent recruitment e mails to addresses of which elicited a complete response.
in total we obtained role classifications.
the distribution of responses from the projects was for linux for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
django for qemu for ll vm for postgresql for wine and for ffmpeg.
one explanation for thelow response rate is that the e mail addresses in the version control system are often inactive or unreachable.
the survey includes two primary sections the first section contains questions that require the developers to self reporttheir role in the project core or peripheral and to providea textual description of the nature of their participation.this question is useful for identifying potential sampling biasproblems and to determine if developers self reported role isconsistent with the answers provided by their peers.
the sec ond section includes a list of developers identified by nameand e mail address sampled from their specific project.
foreach developer appearing in the list the respondent was askedto provide a classification of the developer s role.
appropriateoptions are also available if the respondent did not know thedeveloper in question or was unsure of the role.
we appliedthe following sampling strategy to select the list of twelvedevelopers five developers were randomly selected from thecore group and five from the peripheral group classifiedaccording the the commit count based operationalization seesection iii .
the remaining two developers were randomlyselected from the direct neighbors in the developer network of the survey participant.
we chose to use neighbors becauseit is likely that neighbors work directly together and are awareof each other s roles.
vi.
r esul ts we now present the results of our empirical study and address the five hypotheses described in section v c. forpractical reasons we are only able to present figures for asingle project that is representative of the general results.please refer to the supplementary web site for the remainingproject figures.
a. rq1 consistency of count based operationalizations to address h1 we compute the pairwise agreement between all count based metrics for a given project.
for this purpose we analyze each subject project in a time resolvedmanner using a sliding window approach see section iv to generate time series data that reflect the agreement fora particular three month development period.
an exampletime series is shown in figure for qemu.
while beingonly one project the insights are consistent with the resultsfrom the other projects.
the figure illustrates the agreementfor cohen s kappa and we see that for all comparisons the agreement is greater than fair e.g.
greater than .
which significantly exceeds the level of agreement expected bychance see section v c .
this is evidence that the differentcount based operationalizations do not contradict each other.for operationalizations that are based on the same data source i.e.
version control system we typically see substantialagreement .
.
.
one reason for the lower cross archiveagreement could be due to problems of multiple aliases whichwill be discussed in detail in section vii.
another interestingresult is that the agreement is relatively stable over time which fig.
qemu time series representation of pairwise agree ment between count based operationalizations.
the data in dicate that agreement is fair to substantial and is temporallystable i.e.
mean and variance are time invariant .
is again visible in figure for qemu.
more specifically the arithmetic mean and variance do not significantly change overtime a property referred to as wide sense stationary in thetime series analysis literature .
this feature of the data isa testament to the validity of the operationalizations as wewould not expect the agreement between operationalizationsto change drastically from one development window to thenext.
the wide sense stationary property is also importantbecause it permits us to aggregate the data by averaging overthe time windows to attenuate noise and generate more conciseoverviews without sacrificing scientific rigor or interpretabilityof the result.
overall the results demonstrate that the count based operationalizations largely produce consistent results regarding theclassification of developers into core and peripheral groups.we therefore accept h1.
b. rq2 core and peripheral developers in developernetworks hierarchy in a hierarchical network nodes at the top of the hierarchy have a high degree and low clustering coefficient nodes at the bottom of the hierarchy have a low degreeand high clustering coefficient .
if hierarchy exists in adeveloper network we should see mutual dependence betweenthe clustering coefficient and the degree of nodes in the net work .
the hierarchical relationship for qemu is shownin figure there is an obvious dependence between the nodedegree and clustering coefficient.
nodes with a high degree areseen to exclusively have very low clustering coefficient and areindicative of core developers according to section iv b lowdegree nodes have consistently higher clustering coefficientsand are indicative of peripheral developers.
for the remainingprojects the scatter plots are available on the supplementaryweb site here we illustrate the relationship in a more compactform in terms of spearman s correlation coefficient betweenclustering coefficient and degree see table i hierarchy .we see that for all projects there is a strong negativecorrelation indicating that the developers are indeed arrangedhierarchically.
in sections vi c and vi d we will see if authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
qemu s developer hierarchy during four development periods.
the linear dependence between clustering coefficientand degree expresses the hierarchy.
core developers shouldappear clustered at the top of the hierarchy bottom right re gion and peripheral developers at the bottom of the hierarchy upper left region a developer s position in the hierarchy is an organizational manifestation of their particular role.
stability developers who fulfill a particular role within a project and who maintain participation over subsequent devel opment periods are defined to be stable see section iv b .we study this characteristic by examining the developers transitions from one state to another e.g.
core to peripheral ina time resolved manner.
the result of examining the developertransitions over one year of development for qemu are shownin figure .
in this figure the transition probabilities betweendeveloper states are shown in the form of a markov chain.the primary observation is that developers in a core state aresubstantially less likely to transition to the absent state i.e.
leave the project or isolated state i.e.
have no neighbors in the developer network by working exclusively on isolated tasks in comparison to developers in a peripheral state.
so the core developers represent a more stable group than peripheral developers.
core periphery block model the core periphery block model describes the core and peripheral groups formalizedas positions in a network as a particular two class partitionof nodes see section iv b .
to test whether our empiricaldata are plausibly described by the core periphery blockmodel we must compute the edge presence probabilities forcore core core peripheral and peripheral peripheral edges.if the edge presence probabilities are arranged according to p core core p core periph p periph periph then we can conclude that core developers constitute the most coordinated developersin the project peripheral developer coordinate primarily withcore developers and peripheral developers rarely coordinateperipheral core isolatedabsent10 fig.
developer group stability for qemu shown in the formof a markov chain.
a few less important edges have beenomitted for visual clarity.
with other peripheral developers.
this provides an example of a relational perspective that captures intra and inter relationalinformation see section iv b .
the edge presence probabilities for all projects are shown in table i column edge probabilities .
in all projects theinequality holds indicating that the model plausibly describesour projects.
the edge presence probability for core core hasa mean value of .
for core peripheral edges it is significantly lower with a mean value of .
and the peripheral peripheral edge probability is lower yetwith a mean value of .
.
the interpretation is that peripheral developers are twice as likely to coordinate withcore developers as opposed to other peripheral developers.
two projects are noteworthy outliers but are still described by the core periphery block model linux and postgresql.for linux the edge presence probabilities are notably lowerin all cases and the difference in scale between core coreedge probabilities and the others is two orders of magnitude.in the case of postgressql we see an outlier in the oppositedirection.
the core core edge probability is notably higherthan for all other projects much like core peripheral edges.it is interesting that both of these projects are also outliersin terms of the size of the developer community linux ismuch larger than most projects developers postgresqlis much smaller developers .
from this result it appearsthat the scale of a project influences how likely it is for twodevelopers to coordinate and this influence has a greater effecton the coordination of peripheral developers.
overall the network based operationalizations illustrate clear manifestations of core and peripheral developer roles thatagree with the abstract characteristics established by earlierempirical work.
we also found evidence in terms of the core peripheral block model that developer roles imply specificcoordination preferences.
on the basis of these results weaccept h2 and h3.
c. agreement network based vs. count based so far our results have provided evidence that the countbased operationalizations produce consistent classifications ofdevelopers which is a testament to their validity and that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
time averaged agreement in terms of cohen s kappa for qemu.
the pairwise agreement is shown for the countbased and network based operationalizations developer networks exhibit specific characteristics that are indicative of core and peripheral developer roles.
next we present the results to relate the network based to the countbased operationalizations for identifying core and peripheral developers.
we approach this evaluation again using cohen s kappa by averaging the level of agreement over one year of development.
qemu is used as an example project and the pairwise agreement for each operationalization is illustrated in figure .
the stability and core periphery block model operationalizations do not show up explicitly since they are derived from degree centrality.
in general the level of agreement always exceeds which indicates that the strength of agreement between all operationalizations significantly exceeds what is expected by chance.
the rows columns beginning with vcs are based on data stemming from the version control system and those with mail are based on the mailing list.
we again see that agreement between operationalizations defined on same data source typically have substantial agreement .
.
.
overall the results indicate that the network based and countbased operationalizations are mostly consistent.
while the agreement is imperfect the results show that the divergence from perfect agreement is similar what is seen among the count based operationalizations.
we therefore accept h4 .
d. rq3 developer perception vs. network based and count based operationalizations to establish a ground truth classification of developers based on the perception of our survey participants we computed the number of core and peripheral votes for each developer from the survey responses see section v d .
for each developer we chose the role with the highest number of votes as the ground truth and if the count was equal the developer was removed.
upon inspection of the responses we found that they were largely consistent regarding a given developer s role.t able ii agreement with developer perception cohen s kappa p valuecountscommit count .
.12e loc count .
.91e mail count .
.08e 05networksvcs degree .
.48e vcs hierarchy .
.22e vcs eigencent .
.74e mail degree .
.23e mail eigencent .
.26e the results of comparing both the count and network based operationalizations to the ground truth classification are shown in table ii.
agreement was computed for ground truth samples provided by the survey participants.
three participant responses were eliminated because they were incomplete.
the nominal agreement values in terms of cohen s kappa exceed indicating that all operationalizations agree with developer perception significantly more than what is expected by chance see section v c .
the highest and second highest agreement is seen in the node degree metric for the e mail network and vcs network respectively.
the lowest agreement is seen for the count based version control system metrics commit and loc count .
in general all network based operationalizations agree better albeit in some cases only slightly with developer perception than the basic versioncontrol system count based metrics.
focusing on the comparison between different data archives the agreement for the mailing lists metrics have even greater agreement than the corresponding version control system metric.
however network based metrics always outperform the count based metrics when the data source is the same.
in general the mailing list is most accurate in capturing characteristics that reflect developer perception of roles.
however in many projects communication archives are not available and in this case a network perspective on versioncontrol system data can closely resemble the insights regarding developer roles provided by the communication archive.
overall we see that a network perspective always improves the agreement with developer perception over the simpler countbased operationalizations.
to this end we accept h5 .
e. support for relational perspective in addition to providing data for testing our hypotheses the developer survey provides additional evidence for and insights into the usefulness of a relational perspective on developer roles.
our survey results suggest that developer roles are often defined in terms of differences in the mode of interaction between developers.
for example one developer wrote core maintainers participate in discussions on areas outside the ones that they maintain .
only a relational perspective is able to capture this view for example in terms of core developers having a higher degree than peripheral developers 3the survey response data are available at the supplementary web site.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
because they interact with developers working in areas that are distinct from the ones that they maintain.
in the same vein core developers are likely to occupy upper positions in a hierarchy as they provide coordination bridges between the peripheral developers that have a comparatively narrow focus.
another core developer mentioned i may not be contributing as much as i did in past years but i am still active and available to answer questions from and provide guidance to other developers.
again the developer has emphasized their role based on a mode of interaction with other developers.
another survey participant commented the wine project has lots of committers and a very loose structure.
it s very hard to know who does what.
a relational view on the global organizational structure has practical value to support this kind of developer awareness that is currently missing.
beside static network properties we argue that the temporal dimension is needed to accurately operationalize developers roles which is also supported by survey responses the boundaries are fuzzy and can change over time sometimes i m a core developer on libvirt while at the present i m only a peripheral developer o r i tend to classify contributors as regular opposed to occasional.
this is especially important as count based operationalizations do not capture temporal relationships.
vii.
t hrea ts to validity construct v alidity quantifying the extent to which the operationalizations of developer roles represent the real world is one of the primary contributions of this work.
we used the concept of mutual agreement as a testament to the validity of the operationalizations however one explanation for observing mutual agreement could be that all the operationalizations consistently reach the same wrong conclusion.
while this would be a rather improbable explanation we carried out a developer survey to provide additional evidence for that the operationalizations are valid.
for the network based operationalizations we used developer networks and network analysis techniques to establish a relational basis for studying core and peripheral developers.
this poses the threat that the networks and metrics do not accurately capture reality.
this threat is minor as there is already evidence indicating that both the networks and the metrics are authentic in reflecting developer perception .
one concern we have is regarding the unification of developers contributions across multiple archives i.e.
mailing list and version control system to a single alias.
however core developers have an interest in being recognized for each contribution they make therefore maintaining multiple aliases would not be productive.
for this reason we think this issue has limited influence on developer classifications.
internal v alidity we quantify the agreement between different operationalizations in terms of cohen s kappa.
for these experimental conditions we required a probabilistic definition of agreement because a non error tolerant agreement metric would be too strict to yield practical results.
cohen s kappa requires some degree of interpretation though so we haveconservatively chosen thresholds that have been established in the literature.
the results of the developer survey depend partially on individual perceptions.
to limit this threat we designed the questionnaire such that multiple developers classified the same developer and we then took the average classification to limit individual bias.
external v alidity the results of our study are based on the analysis of ten open source projects.
although the projects do represent a broad spectrum in several dimensions they are still limited to relatively successful mature and large projects.
so the results may not be relevant to immature or very small projects.
likewise some projects while having significant commercial involvement e.g.
linux are still in the end open source and it is not yet clear if these results hold for commercial projects.
viii.
c onclusion information on developer roles is crucial to understanding the collaborative dynamics of software projects.
in particular accurate knowledge of developer roles provides insight into which developers are appropriate for coordinating other developers efforts given their current skill set and expertise.
in large globally distributed projects this kind of insight can provide enormous efficiency advantages by reducing the overhead associated with developer coordination .
in an empirical study of ten substantial open source projects we established evidence that the commonly used count based operationalizations of developer roles are outperformed by network based operationalizations in terms of reflecting developer perception.
while offering some utility for identifying developer roles the insights count based operationalizations can provide are clearly limited in particular with regard to the manifold relationships between developers which may even vary over time.
as a novel contribution we use fine grained developer networks to establish a relational perspective on developer roles.
a key hypothesis is that developer roles should manifest distinctly in the organizational structure which is also supported by a survey among developers.
to this end we have proposed a number of corresponding network metrics such as positional stability hierarchy and a core peripheral block model to explore structural characteristics that capture differences between core and peripheral developers.
our results suggest that a network perspective can offer valuable insights regarding developer roles that are concealed by non relational operationalizations.
for example the core group is comprised of the most heavily coordinated developers and peripheral developers are more likely to coordinate with core developers than with other peripheral developers.
the richness of a network perspective has only begun to be explored and we hope that our work establishes the foundation and inspiration to explore further.
acknowledgment we thank all participants of the online survey.
this work has been supported by siemens and the dfg grants ap ap and ap .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.