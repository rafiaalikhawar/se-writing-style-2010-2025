recovering variable names for minified code with usage contexts hieu tran ngoc tran son nguyen hoan nguyen and tien n. nguyen computer science department the university of texas at dallas usa email trunghieu.tran nmt140230 sonnguyen tien.n.nguyen utdallas.edu computer science department iowa state university usa email hoan iastate.edu abstract to avoid the exposure of original source code in a web application the variable names in js code deployed in the wild are often replaced by short meaningless names thus making the code extremely difficult to manually understand and analysis.
this paper presents jsn eat an information retrieval ir based approach to recover the variable names in minified js code.
jsn eat follows a data driven approach to recover names by searching for them in a large corpus of open source js code.
we use three types of contexts to match a variable in given minified code against the corpus including the context of the properties and roles of the variable the context of that variable and relations with other variables under recovery and the context of the task of the function to which the variable contributes.
we performed several empirical experiments to evaluate jsn eat on the dataset of more than 322k js files with 1m functions and .5m variables with 176k unique variable names.
we found that jsn eat achieves a high accuracy of .
which is the relative improvements of .
and over two state of theart approaches jsnice and jsnaughty respectively.
the time to recover for a file or a variable with jsn eat is twice as fast as with jsnice and 4x as fast as with jnaughty respectively.
keywords minified js code variable name recovery naturalness of code usage contexts.
i. i ntroduction software developers have to spend a significant portion of their efforts in comprehending the code.
an important aspect of program understanding is the names of the identifiers used in the source code .
meaningful identifiers help developers tremendously in quickly grasping the essence of the code.
thus naming conventions are strongly emphasized on prescribing how to choose meaningful variable names in coding standards .
these principles also apply to web development.
web technologies and programming languages require the exposure of source code to web browsers in the client side to be executed there.
to avoid such exposure the source code such as javascript js files are often obfuscated in which the variable names are minified i.e.
the variable names are replaced with short opaque and meaningless names.
the intention has two folds.
first it makes the js files smaller and thus is quickly loaded for better performance.
second minification diminishes code readability to hide business logics from the readers while maintaining the program semantics.
due to those reasons there is a natural need to automatically recover the minified code with meaningful variable names.
when the original code is not available with such recovery the minified js code will be made accessible for code compre hension as well as other maintenance activities such as code review reuse analysis and enhancement.
recognizing that need researchers have been introducing the automatically recovering tools for variable names in js code.
jsnice is an automatic variable name recovery approach that represents the program properties and relations among program entities in a js code as dependence graphs.
it leverages advanced machine learning ml to recover missing variable names.
using also ml jsnaughty formulates the variable name recovery problem for js code as a statistical machine translation from minified code to the recovered code.
despite of their successes both approaches still suffer low accuracy and scalability issues with the use of computationally expensive ml algorithms.
in this work we present jsn eat a data driven information retrieval ir based approach to automatically recover variable name for minified js code.
the recovered names for variables must be natural in the context of the code and follow naming conventions.
thus we conform jsn eat in a datadriven direction in which we aim to search for the name recovered for a minified variable in a large corpus of opensource js code.
we conjecture that meaningful natural names of minified variables could be seen before in such corpus.
our key idea is to utilize the contexts for the variables in source code to search for its name .
for the minified variables in a given a minified js code jsn eat aims to match their contexts against the contexts in the corpus.
if two contexts of two variables are similar they should be named similarly thus the variable s name in the corpus with the matched contexts should be a candidate name for the corresponding minified variable.
for a given minified variable v we model three types of contexts.
first the name of a variable should be affected by its own properties and roles in the source code .
for properties ifvaccesses to a method mor a field fin the code then the recovered name for vshould be naturally compatible with the names of the method and the field .
for example the variable named datatransfer is the receiver of the method call getdata .
however a variable that calls the method getdata cannot be randomly named in a regular program.
for a role if vis used an argument of a method call m the data type of vmust be compatible with m thus their names should also naturally be in conformance with one another.
for example in jquery.trigger ... the first argument is either an event or an event type thus the name of the first argument should be consistent with a direct object of the verb trigger .
ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
second the name of a variable should be affected by the names of variables co occurring in the same function .
several variables are used together to contribute to the current task of the function thus their names are naturally in concordance with one another.
observing some variable names jsn eat could predict the names for other co occurring variables.
it takes into account the naming of multiple variables at once considering such co appearances.
finally the third type of context is the current task of the function to which the variable belongs and contributes .
the names of the variable should be relevant to the common task purpose of the function.
for example the variables in a function getclipboardcontent should serve the task of getting the content from the clipboard and have the names closely relevant to that task.
we combine the above contexts in the jsn eat tool.
we built a database to store the information about the variable names and the contexts extracted from a large corpus of opensource js code.
to recover the names for a given minified js file we use jsn eat with three types of contexts to search for and rank the candidate names.
we performed several experiments to evaluate jsn eat on the dataset of 322k js files with almost 1m functions and .5m variables with 176k unique variable names.
jsn eat achieves high accuracy of .
which is the relative improvements of .
and over two state of the art approaches jsnice and jsnaughty respectively.
a high percentage .
o f variables is recovered only by jsn eat while .
and .
of variables are recovered only by jsnaughty and jsnice respectively.
we reported that the time to recover for a file or for a variable with jsn eat istwice as fast as with jsnice and 4x as fast as with jnaughty respectively.
importantly jsn eat s training time is 4x faster than jsnice and 6x faster than jsnaughty .
this paper makes the following contributions .jsn eat an ir based data driven approach to recover variable names for minified js code using types of contexts .an extensive comparative evaluation and analysis on jsneat s accuracy and running time to show that it outperforms the state of the art approaches see results in a website .a novel formulation of variable name recovery problem in minified js code as an information retrieval problem.
ii.
m otiv ation and approach overview figures and show the original and minified versions of the js function getclipboardcontent in the vue medium editor project.
the function is to retrieve the content of the clipboard.
in the minified code all local variables are randomly renamed with short and meaningless names e.g.
datatransfer becomes r data becomes n by a minification tool e.g.
uglifyjs .
this makes developers difficult to comprehend it.
our goal is to assign meaningful names for the variables in the minified code.
the name chosen for a variable in the code should be natural unsurprising in the context and follow naming conventions so that the de minified code becomes easy to understand for developers.
to achieve this goal we conjecture that the meaningful names of minified variables could be observed in a large cor 1function getclipboardcontent event win doc 2var datatransfer event.clipboarddata win.clipboarddata doc.datatransfer data 4if !datatransfer return data 5if datatransfer.getdata var legacytext datatransfer.getdata text if legacytext legacytext.length data legacytext if datatransfer.types for var i i datatransfer.types.length i var contenttype datatransfer.types data datatransfer.getdata contenttype return data figure an original code from a project in github 1function getclipboardcontent t a e 2var r t.clipboarddata a.clipboarddata e.datatransfer n 4if !r return n 5if r.getdata var i r.getdata text if i i.length n i if r.types for var p p r .
t y p e s .
l e n g t h p var f r.types n r.getdata f return n figure the minified code for the code in figure pus of existing source code.
this motivates us to conform our approach to a data driven direction where we learn the names from original source code to recover the names for variables in the minified code.
indeed for the minified code in figure all original names are found in our experimental dataset that contains 322k js files collected from 12k github projects.
a. observations the name recovering process of variables in minified code is affected by multiple factors.
let us illustrate these factors through the following observations o1.each individual variable has certain properties and plays particular roles in the code.
thus the name of a variable is intuitively affected by its properties and roles .
the properties are the method calls or field accesses to which a variable of a certain type can access.
if a method is called or a field is accessed by a variable the name of the variable should be compatible with the method s or the field s name.
for example in our experimental dataset the number of candidates that can authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
call method getdata lines and is only out of variables names found in a function named getclipboardcontent .
such number is down to a single candidate if we additionally consider that it can also access the fields getdata line and types line .
thus rcould be named as datatransfer which is the same name in the original code in figure .
for the variable fthat is created and assigned as an element of the array types at line there are candidates for such variable that can be used as an argument of the method named getdata line .
the number of candidates for i which is the returned result of the call to getdata line and also has a field with the name length line is only .
o2.in a function a variable might collaborate with other variables to implement the function.
consequently the recovering name for a variable might be influenced by the name of others .
intuitively since the variables are used together their names are often consistent with each other to achieve the common task in the function.
in the example in possible pairs of candidates for i candidates and f candidates there are only pairs of candidates that are used to name two variables in the same function in our dataset.
one of them is the correct pair which is legacytext andcontenttype .
o3.
within a function e.g.
getclipboardcontent a variable name e.g.
contenttype is affected by the specific task of the function that is described by the function s name .
this is intuitive because the names of variables are often relevant to the task that the variables are used in the code to achieve.
such task is typically described with a succinct function name.
in figure the task of the function is to get the clipboard s content thus it is named getclipboardcontent .
in our dataset there are names being used to specify the variables in function getclipboardcontent e.g.
data datatransfer contenttype .
meanwhile the variable names students or salary have never been used in the function with that name.
overall these observations indicate that the names of the variables in a particular function not only depend on the task in which the variable is used to implement called taskspecific context but their names are also affected by their own properties and roles in the code called single variable usage context and on the names of the other variables in the same function called multiple variable usage context .
b. approach overview from the observations we propose an ir based data driven approach to recover the variables names in a minified js code based on the contextual information including singlevariable usage context svc multiple variable usage context mvc and task specific context tsc .
we initially construct a database to store the variables names and the corresponding context information extracted from a large corpus of js code.
to recover the names given a minified js code we first use the svc and tsc information to find in our database the candidate names for each variable.
then these candidates for each variable are ranked by the likelihood that they are used along with the candidates of other variables in order to name the variables in the same function by using mvc .iii.
s ingle variable usage context svc this section presents the single variable context that we use in the name recovery process.
the intuition for this context is that to recover the name of a variable one could use its own context based on its own properties and roles in the code.
by properties of a variable we refer to the methods or fields to which a variable of certain type can access.
in the minified code the names of the called methods and accessed fields are not minified.
thus it could play the role of the pivots in recovering the variables names.
importantly due to nature of naming the name of the variable should be compatible with the name of the method being called or the name of the field being accessed .
thus they provide hints on the names of the variables.
for example in figure the only candidate that calls the method getdata and accesses the field types is datatransfer .
those names are compatible with each other.
to learn compatible names we follow a data driven approach by learning from a large corpus of non minified js code.
by the role of a variable we refer to its usage context with the method calls or field accesses that were not minified.
for example a variable could be an argument of a method call or a variable could be assigned with the returned value from a method call or field access.
the name of a variable used as an argument is often compatible with its type role and thus coupled with the name of the method call itself.
on line of figure the argument contenttype is in conformance with the method name getdata .
thus it helps recover the name of the minified variable fon line of figure .
similarly the name of a variable receiving the returned value of a method call or a field access should conform with the name of the method or field.
such conformance can be learned from a large corpus of non minified code and helps recover variable names.
a. property and role relations to realize the single variable context for name recovery with properties and roles of a variable we define two key relations property and role .
those relations form the single variable usage context for name recovery.
definition .
property relation represents the relationships between a variable and its fields or methods to which the variable can access or call.
a property relation between a variable vand its property pis denoted by a triple v p t where tis the type of relation which can be either fieldaccess or methodcall .
in figure a set of property relations for r includes r types fieldaccess r getdata fieldaccess r getdata methodcall .
definition .
role relation represents the relationships between a variable and the method calls or field accesses in its usages.
since the names of methods or fields are not minified we consider them as the pivots in the usage context for recovering names of the minified variables.
we focus on the roles of a variable used as an argument in a method call orreceiving authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
datatransfer clipboarddata assignment rolerel assignment rolerel getdata getdata types methodcall proprel fieldaccess proprel fieldaccess proprel figure the relation graph of variable rin figure the value returned by a method call or field access .i fw eh a v e o.m ... v ... v o.m ... o rv o.f then there exist the role relations between vandm and between vandf.
the rationale is that the names of mand its argument are often in conformance with each other e.g.
getdata contenttype .
similar rationale is applied to the above assignments to v. a role relation between a variable vand a field method pis denoted by a triple v p t where tis the type of role relation.
a role relation could be either argument orassignment .
b. graph representation of single v ariable context definition .
a relation graph rg for a variable vis a directed graph in the shape of a star to represent the single variable usage context of vwith regard to its property and role relations with the fields and methods in its usage.
the center vertex of the rg represents the variable.
the other vertices represent the methods fields in method calls or field accesses respectively and are labeled with their names.
edges represent relations and are labeled with relation types.
figure shows the relation graph of the variable r which includes a set of property relations r types fieldaccess r getdata fieldaccess r getdata methodcall and a set of role relations r clipboarddata assignment r datatransfer assignment in our example.
c. deriving candidate names using single v ariable context let us explain how we use the relation graphs to derive the ranked list of candidate names for a minified variable.
our idea is that if two variables have the same similar contexts they are often named similarly.
given a minified functionf we first parse fto produce a relation graph gvfor each variable v. we then search for the single variable contexts that are matched with the context of vwithin a dataset gof the relation graphs built from a large corpus of open source projects we will explain how to build the dataset later .
definition .
two single variable usage contexts for a minified variable vand a variablev primein the dataset are considered to be matched if and only if their corresponding relation graphs are matched.
definition .
a relation graph gvof a minified variable vis considered as matched withrelation graph gv primeofv primeingif and only if their graph matching score is equal or greater than a threshold .
since rgs all have star shape matching graphs can be done by matching their sets of edges.
definition .
the graph matching score gv gv prime betweengvof a minified variable vand a relation graph gv primeofv primeis computed as the percentage of the number of edges in gvfound in gv prime.
a variable name might appear in multiple functions so it might have multiple relation graphs.
thus we define a name matching score considering all of those functions as follows.
definition .
single variable score represents how well name vncan be used for a minified name vand is computed based on graph matching score sc v vn m a x gv prime g vn gv gv prime wheregvnis the set of relation graphs of name vn that matchgv.gvnrepresents multiple usages of the name vn.
if a match is found the name vnof the variable v primein the matched relation graph in gis considered as a candidate name forv.
there might exist many candidate names having similar contexts with the context of a variable v. the candidate names are ranked based on their name matching scores.
the higher the name matching score the higher the confidence of our model in using the name vnofv primeforv.
for example when recovering the variable rin figure by searching on the dataset we found that the variables named datatransfer anddataobj have the relation graphs matching with that of r. this implies that these variable names have been used in the past and they have similar svc contexts with r. therefore rcould be recovered as datatransfer ordataobj .
iv .
m ultiple v ariable usage context mvc let us present how we define and use multiple variable usage context.
to achieve a specific task developers use one or multiple variables in their code.
because the variables all play their roles in the code their names are often relevant and consistent with one another in order to achieve the common task in the function to which they belong.
for example in figure the variables datatransfer contenttype and data serve their roles in the task to retrieve the content of a clipboard and their names are naturally consistent with one another with regard to that task.
in name recovery we utilize such co occurrences of variable names to recover the name for one variable while another one was recovered with the co occurring name if the contexts of two variables allow.
a. multiple v ariable score to formulate the co occurrence of variable names we define the association score for a set of variable names which represents how likely those names appear together in a function.
assume that we have a set of nvariable names and the name authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ofithvariable is vni.
the association score for a set sofn names vn1 vn ... vn n is computed as follows.
assoc s nvn1 vn2 ... vnn nvn1 vn2 ... vnn wherenvn1 vnn ... vnnis the number of functions that contain all the names vn1 vn ... vn n in the corpus.
nvn1 vn2 ... vnnis the number of functions that contain at least one of the names vn1 vn ... vn n in the corpus.
for a set of nrecovered names we define a multiplevariable score mc that represents the likelihood of those variable names to be assigned to the variables based on mvc.
mc can be computed using the association score.
however due to the fact that not all possible sets of nnames appear together in a corpus we compute mc based on the associations of all subsets of the size jwithj n as follows mc vn1 vn2 ... vn n summationtextnsubj i 1assoc si nsubj wheresiis a subset of size jof vn1 vn ... vn n nsubj is the number of such subset and assoc si is the association score of all variable names in set si computed by formula .
b. deriving candidate names using multi v ariable context this section presents our algorithm to derive candidate names using multiple variable usage context.
the algorithm takes as input a set of minified variables in a js code in which each variable has a set of candidate names derived using the single variable context as explained in section iii c or using task specific context in section v .
the output is the ranked list of the results with associated scores.
each result is a set of the recovered names for all of the given variables.
design strategies in developing our algorithm we face three key challenges.
first each variable might have a large number of candidates thus there are an exponential combination among variables names.
how would we deal with such complexity to make our algorithm scale?
second given a set of minified variables needed to be recovered which one should jsn eat start ?
this is important since if the algorithm does not recover well the first variable this would affect much to the accuracy of recovering the next variables.
finally in which recovery order for the variables in a function would it be beneficial from multiple variable usage context?
to address those questions we have the following design strategies.
s1.
pruning with beam search.
to deal with the scalability issue of the exponential combination among all possible names of variables we use the beam search strategy at a step during name recovery our algorithm keeps only the best ksets of partially recovered results according to the association scores.
this would help to reduce significantly the number of partially recovered sets that need to be considered.
s2.
starting with variable with most contextual information.
a naive answer is to use the appearance order of the variables in the code.
however the first variable in the code might not be the one that we have sufficient information to recover its name.
thus we follow the idea of using context toalgorithm multiple var name recovery algorithm mvar function mv ar candidates n context firstvar pick the first var using context clist candidates whilenrecovered n do nextvar decide the next variable using s3 cl candidates clist beamsearch clist cl returnclist function beam search clist cand allpossiblepartialrecoveredsets clist cand for partialres inallpossiblepartialrecoveredsets do mc calculatescore partialres via formula sortall partialres bymc toprankedresult topkhighestscores returntoprankedresult decide the initial variable for name recovery.
our intuition is that the more context information a variable has the more chance we have in correctly recovering its name.
jsn eat starts with the variable having the most single variable usage information.
that is the variable has the most relations with method calls and field accesses.
the appearance order is used to break the tie if multiple variables have the same number of relations in their single variable contexts.
s3.
selecting next variable with greedy strategy.
after one or multiple variable names are recovered we need to determine which variable to recover next.
the appearing order in the code might not give us the optimal one.
the variable with the most single variable context might not work either since it might not go together well with others.
in jsn eat we select the next variable vwith the list of candidate names vns that gives us the best partially recovered result.
that is together with the selected names for the previously recovered variables the best possible choice for vwould give the highest score with respect to the likelihood of the co occurrences of the recovered variables including v. this is a greedy strategy that favors the variable and its candidate name that has most co appearances with the previously recovered variable names.
it helps avoid considering all possible candidate names for all the variables.
we use the phrase partially recovered result because only a subset of all variables including vis recovered for their names while other variables have not been processed.
detailed algorithm algorithm shows the pseudo code for our algorithm mvar to derive names using the multiplevariable contexts.
given a set of nminified variables in which each variable has a set of candidate names candidates provided by a context e.g.
single variable or task specific contexts mvar determines the first variable to start.
using the strategy s2 it chooses the first minified variable with the highest score according to the context line .
for example if the single variable context is chosen formula is used.
all the candidates for the first variable are initially stored in the current candidate list clist .
then the algorithm authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iterates to recover the variable names until all the variables are recovered lines .
at a step of the iteration assume that it has recovered nrecovered variables.
using the strategy s3 the next variable nextvar is chosen such that together with the selected names for nrecovered previously recovered variables the possible names for nextvar will give the highestmc score formula considering the co occurrences of currently recovered variables lines .
after selecting the next variable mvar performs beam search by first generating all possible names for the nrecovered variables with combining the name candidates for nextvar andclist line .
each of those sets of names represents a partially recovered result for those nrecovered variables.
the scores of all of those sets are computed lines using formula .
then we keep only the best ksets of results with highest scores and then store them in clist lines .
mvar stops when all variables have been recovered.
clist is returned as the list of best ksets of variable names for all the variables in the input line .
in our example using the single variable context and or the task specific context we have the set of name candidates for each variable e.g.
r datatransfer datacontent ... f elementtype datatype contenttype ... p i j ... n data cachedata datacontent ... etc.
the variable ris chosen first since its single variable context has most relations.
all the name candidates for rare stored in clist .
after that the next variable is nbecause in all the candidate names of the non yet recovered variables the name data fornwhen appearing with the current candidate name ofrgives the highest score.
in this case the candidate name of risdatatransfer .
then all the sets of variable names for r n include datatransfer datacontent datatransfer cachedata datatransfer data etc.
ranking these partially recovered results with formula and keeping only the top kones clist includes datatransfer data datatransfer datacontent ... the next variable for recovery is f. the process continues until all variables are recovered.
clist results are returned as the output.
v. t ask specific context tsc in a program a function has its functionality and is written to realize a specific task.
each variable used in that function plays a certain role toward that task.
thus the names of variables are relevant to the task of the function and often consistent with one another.
the task of a function is typically described by a succinct name of the function.
to derive a variable name using the task context we use the association relation to compute how likely a variable name appears within a function with a particular name.
given a variable name vn and a function name fn task context score tc represents the likelihood that the name vnappears within the body of a function named fn.
we utilize fuzzy set theory as follows.
tc vn fn nvn fn nvn nfn nvn fn wherenvn fn is the number of functions in the corpus in which vnand fnare observed together nvnis the numberof functions in which vnis used and nfnis the number of functions named fn.
as seen in formula the value of tc is between .
the higher the value tc vn fn the higher the likelihood that the variable name vnappears in the function fn.
in figure using our experimental dataset we can compute tc score between the function name getclipboardcontent and the variable name datatransfer astc .
.
a function name might contain multiple tokens e.g.
get clipboard content ingetclipboardcontent .
each token contributes to an aspect to emphasize the common task of the function.
a variable might be relevant to one specific aspect of the task.
thus if we tokenize the function names we can account for those cases.
by tokenizing a function name fn could be represented by a set of key tokens s t1 t2 t3... stopwords are removed and the tc score between a variable name vnand a function name fnis computed as follows tc vn fn m a x t snvn t nvn nt nvn t wheresis the set of key tokens of fn tis a token in s nvnis the number of functions in which vnis used ntis the number of functions containing token t andnvn t is the number of functions in which vnand toccur together.
vi.
v ariable name recovery with contexts this section presents jsn eat our approach to recover the variable names in minified code using the combination of those above contexts.
given a minified js file whose variables have been minified jsn eat produces a recovered js file in which all variables are recovered with meaning names.
algorithm shows the pseudo code for jsn eat.
first jsn eat builds the relation graph representing single variable context svc for each variable in a function and derives the candidate list.
it then computes the task specific context tsc for each variable and derives the corresponding candidate list.
the two candidate lists produced by the contexts are combined into a new list in which the likelihood that a candidate name vnis assigned to a variable vis computed as follows.
stv vn sc v vn tc vn fn wherefnis the function name tc vn fn is task context score between vnandfn sc v vn is the name matching score between vnandv and and are weighting parameters representing the importance of the contexts.
after this step for each variable we have a candidate list stlist in which each candidate name has a score.
jsn eat then uses stlist as the input for mvar algorithm to compute the top ranked sets of names for all variables.
note that the scoring function for a partially recovered result inmvar algorithm formula needs to be adjusted to account for the above combined score st as follows.
mc vn1 vn2 ... vn n summationtextnsubj j 1assoc sj nsubj stv1 vn1 stv2 vn2 ... stvn vn n n where and are weighting parameters.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm context based name recovery algorithm function jsn eat minifiedfile f svcs build single var contexts for variables in f tscs compute tsc contexts for all variables in f stlist combine cand lists from svc and tsc topresults mvar stlist n svcs returntopresults table i data collection category test corpus training corpus total files 2k 320k 322k functions 6k 961k 967k variables 19k 3481k .5m unique variable names 5k 171k 176k variables per file .
.
.
vii.
e mpirical methodology to evaluate jsn eat we answer the following questions rq1 comparative study .
how accurate is jsn eat in name recovery for minified js code and how is it compared with the state of the art approaches jsnice and jsnaughty ?
rq2 context analysis .
how do different combinations of contexts contribute to jsn eat s accuracy in different settings?
rq3 sensitivity analysis .
how do various factors affect the accuracy e.g.
data s sizes thresholds parameters etc.?
rq4 time complexity .
what is jsn eat s running time?
a. corpora we collected a corpus of open source js projects from github with highest ratings.
for comparison we followed the same procedure in previous work to collect and clean up data.
we removed all duplicate files to avoid overlapping when testing.
we also removed the alreadyminified files because they will not help in training.
table i shows our dataset s statistics.
as seen the number of unique variable names is much smaller than that of variables.
thus such repetition in names would help our data driven approach.
in our comparative study we used the same experimental setting as in jsnice and jsnaughty by randomly splitting the dataset into training and test corpora.
in particular to build testing corpus we randomly sampled 2k js files in the dataset.
the remaining 320k files were used as training corpus .
the level of sizes of testing and training data table i is comparable with that of the experimental studies in existing tools .
we minified the files using the minifying tool uglifyjs and used the original files as oracle.
to build the relation graphs we used rhino to parse the js files and extract the context information.
table ii shows the statistics of our dataset gof relation graphs.
b. evaluation setup comparative study for a tool under study we trained it with the training corpus and tested it against the testing corpus.
for jsnice we used the publicly available tools on their website with default parameters.
for jsnaughty wetable ii database of relation graphs category quantity total number of graphs .5m mean number of graphs per file .
mean number of graphs per function .
min mean max number of edges per graph .
figure accuracy comparison trained the translation and language models and nice2predict framework following the instructions.
we did not run their tools in fold cross validation due to a long running time.
context analysis we study the impact of different contexts we created different variants of jsn eat with various combinations of contexts and measured their accuracies.
we used the fold cross validation setting on the entire corpus of the files folds are used for training and of the files one fold for testing and we repeated testing for each of the folds and training with the remaining folds.
we also performed fold cross validation on the project basis.
sensitivity analysis to study different factors that have impact on jsn eat s accuracy in our entire dataset we randomly chose one fold for testing and the remaining folds for training.
we studied the following factors relation graph size type of relation edges thresholds beam sizes different degrees of associations different weight parameters and data size.
c. procedure and metrics to measure the accuracy of a tool we used uglifyjs to minify the given js files and used the minified code as the input for the tool under study.
we then compared the resulting names from the tool against the original names.
specifically the tool is considered to correctly recover the name of a variablevif the recovered name vnis matched exactly with its original name.
for v if matching we count it as a hit otherwise it is a miss.
accuracy is measured by the ratio between the total number of hits over the total number of cases.
viii.
e mpirical results a. accuracy comparison rq1 in this study we evaluate jsn eat s accuracy and compare it with jsnice and jsnaughty .
as seen in figure for local variables jsn eat achieves high accuracy of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure overlapping among results from the tools .
relative improvements of .
and over jsnice and jsnaughty respectively.
the absolute improvements are .
and .
respectively.
for all variables local and global ones jsn eat achieves even higher accuracy .
the relative improvements of and over jsnice and jsnaughty respectively.
the absolute improvements are .
and .
respectively.
note that global variables are not minified we computed the accuracy for all variables for the completeness purpose.
from now on using the terms variables we refer to the recovery accuracy for local variables.
we further analyze the overlapping between the results from three tools.
the vein diagram in figure shows the percentages of variable names that are correctly recovered.
as seen a high percentage .
of variables is recovered only by jsn eat while .
and .
of variables are recovered only by jsnaughty and jsnice respectively.
meanwhile there are .
of the variables that are correctly recovered only by jsnice or jsnaughty and not by jsn eat.
we also analyzed which contexts in jsn eat contribute to those .
correctly recovered names.
to do that we deactivated each of the three contexts.
when mvc is disabled the percentage of variables that are correctly recovered only by jsn eat decreases by .
compared to the full version.
however when tsc is disabled the accuracy drops dramatically from .
to .
.
taking a deeper look in the cases of .
we found out that of variables that were recovered correctly when using all contexts become incorrectly recovered ones when tsc is off.
out of that come from the function with a single variable.
mvc certainly would not help in those cases because it needs the contexts from other variables.
in fact in such functions the function names are quite relevant to the variable names.
while svc does not have enough information to rank the correct name on the top tsc provides useful information to help in those cases.
for example function responsejson in project mf geoadmin3 uses a variable named response that was minified into x. using only svc and mvc the correct name response is ranked at position but adding tsc response is ranked at the top.
in the next experiment we deactivated the single table iii impact of contexts on accuracy and recovery time combination of contexts acc time ms task tsc .
.
singlevar svc .
.
task singlevar .
.
task multivar mvc .
.
singlevar multivar .
.
6task singlevar multivar jsn eat .
.
variable context svc and the percentage of variables that are correctly recovered only by jsn eat decreases to .
.
this means that svc with property and role relations with the pivots in the code contributes most to that .
of the cases that were not recovered correctly by the other tools.
b. context analysis evaluation results rq2 as seen in table iii using only task specific context tsc line accuracy is low because all the variables in the same function have the same chance to be recovered with a certain name.
in contrast the single variable context svc achieves much higher accuracy .
.
this is reasonable since svc provides more detailed context for individual variables such as the relations to surrounding method calls and field accesses.
combining tsc and svc provides an additional improvement of .
over the tool with only svc lines and .
we found that several correct candidate names that were ranked in the 2nd 4th positions become the top candidates with the addition of tsc.
in contrast the combination of tsc and mvc yields only slight improvement over tsc .
to .
.
the reason is that mvc takes the lists of candidate names as its input and such lists were not initially of high quality only .
accuracy leading to low accuracy.
for the combination of svc and mvc the improvement is .
over svc lines and .
we found that those .
of cases the co occurrences of variable names help rank them in the top positions.
comparing lines and adding tsc to svc improves almost more than adding mvc to svc.
further analyzing we found that such improvement from tsc is for the cases in which the given js function has only one variable mvc cannot help and or the svc has only one relation svc did not perform well with little surrounding context .
finally combining three contexts jsn eat achieves the highest accuracy.
compared to tsc svc lines and jsn eat relatively improves .
.
absolute improvement .
this is reasonable since the two contexts tsc and svc alone achieve the highest accuracy among all the combinations of two contexts.
thus they give mvc algorithm the initial candidate lists for variables with higher quality.
then mvc with the co occurrence information among variables helps an additional improvement of .
.
moreover comparing lines and tsc helps improve .
since tsc helps in the cases of single variable functions or single edge rgs.
to evaluate jsn eat s consistency in achieving high accuracy we performed fold cross validation.
as seen in table iv the accuracies for all the folds are stable .
.
with the recovery time of .
ms for a file.
the results for 10fold cross validation on project basis are similar not shown .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv fold cross validation evaluation on jsn eat test fold mean acc .
.
.
.
.
.
.
.
.
.
.
time .
.
.
.
.
.
.
.
.
.
.
table v impact of relation graphs sizes on accuracy number of edges all of graphs .
.
.
.
.
.
accuracy .
.
.
.
.
.
.
c. sensitivity analysis evaluation results rq3 impact of relation graphs sizes to measure the impact of the sizes of svc we selected in the corpus only certain sizes of rgs measured by the number of edges .
as seen in table v the more relations in svc to be considered more edges a relation graph has the more accurate a variable name can be recovered.
when having more than edges accuracy becomes stable at a high level and gradually increases.
this also reaffirms our strategy s1 in selecting the first variable with most connecting edges in rgs.
impact of type of rg edges by omitting only certain type of edges in rgs for svc we measured the impact of each type of relations on accuracy.
in table vi the lower the accuracy the higher the impact the corresponding relation has.
as seen all the relation types contribute nearly equally to jsn eat.
if one type of relation is not considered accuracy drops from .
to around .
the argument relation has a slightly higher contribution than the others.
impact of threshold for graph matching we evaluated the impact of the threshold used to measure the similarity between two rgs i.e.
two svcs .
to do that we used only svc to recover variable names with varied .
as seen in table vii when .
the accuracy is at the highest.
with .
the number of variables whose contexts are matched with the minified variable is large and the correct name was not ranked at the top.
when .
the condition is too strict and the correct names were dropped because it is not easy to find a completely matched context.
impact of beam size in jsn eat beam size is used to deal with the large combinations of possible names.
figure shows the accuracy and running time per variable when we varied the beam sizes.
as seen when the beam size is small the accuracy is very low.
it is expected because pruning occurs frequently the number of results that were kept is smaller and the best candidates might be dropped out of the beam stack.
as the beam size is increased accuracy increases and reaches the highest point around with the beam size of .
accuracy becomes stable when the beam size is greater than .
the reason is that almost all the correct names are observed in the top results.
therefore when we increase beam size over accuracy is not affected anymore.
regarding the running time the higher the beam size the larger the number of candidate results and the higher the running time.
thus we used for the beam size in other experiments.
impact of association scores in mvc jsn eat considers the co occurrences of j etc or nvariable names.
thetable vi impact of relation types in rgs on accuracy argument assignment fieldaccess methodcall accuracy .
.
.
.
table vii impact of threshold on accuracy threshold .
.
.
.
.
.
accuracy .
.
.
.
.
.
time .
.
.
.
.
.
value of jshows how many associations of variable names that we need to have high accuracy.
in table viii using highdegree association accuracy decreases gradually since finding co occurrences of nvariable names has a lower probability than finding the co occurrences of n variable names i.e.
the co occurrence condition is too strict.
the decrease in accuracy is not much since the high degree association affects only a smaller set of cases with higher numbers of variables in a function.
as expected running time increases.
impact of parameters in context combinations to combine multiple contexts we use parameters to put weights on each of them e.g.
for svc for tsc and for mvc.
we varied their values to observe the impacts of the contexts.
in table ix when combining svc and tsc if the weight of svc is higher accuracy is higher.
in a function task context plays an equal role to all variables in that function while svc provides directly related information to the variable.
combining svc tsc and mvc the higher the higher the accuracy.
this means that mvc contributes more important information than svc and tsc in the formula .
impact of training data size to measure impact of data size we used one fold for testing and increased the sizes of the training dataset by adding one fold at a time until remaining folds are added for training.
we ran jsn eat on each training dataset with the best settings for svc and mvc and two settings of tsc tokenizing or using full function names.
in table x the accuracies in both settings increase linearly and consistently with the training size.
with a small size tokenizing function names gives better accuracy than using full names.
however when the number of training folds is more than folds using full function name is better.
the reason is that when the data s size is large enough the probability of coappearances between a function name and a variable name is higher the candidate names for a variable can be found better.
when data s size is small jsn eat might not see a variable name and a function name appearing together then tokenizing function names would give more useful context.
d. time complexity rq4 all experiments were run on a linux server with intel xeon .2ghz processors 256gb ram.
in table xi the time to recover for a file or for a variable with jsn eat istwice as fast as with jsnice and 4x as fast as with jnaughty .
more importantly jsn eat s training time is 4x faster than jsnice and 6x faster than jsnaughty .
this can be achieved due to the nature of information retrieval in jsn eat in comparison to machine learning in jsnice and jsnaughty.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure impact of beam size on accuracy and running time table viii impact of assoc score jon accuracy and time j accuracy time ms perc.
found pairwise j .
.
.
triple j .
.
.
j .
.
.
j .
.
.
j .
.
.
j .
.
.
e. limitations and threats to v alidity limitations first as a data driven approach unseen data affects our accuracy.
for example with fold training data .
of minified names have not been observed.second for the task context jsn eat did not work well for functions with general names e.g.
next find etc.
more sophisticated solution could involve topic modeling onthe function body.
third for mvc greedy strategy might notachieve the optimal result.
finally if two variables in the samefunction are assigned with the same name e.g.
same svc mvc and tsc we randomly pick different names.
programanalysis could be applied here to improve accuracy.
threats to v alidity our corpus of js code might not be representative however we chose a large corpus with the sizecomparable with those in previous studies.
we used only thetool uglify to minify the code which was also used in jsniceand jsnaughty.
we do not study the usefulness involvinghuman subjects.
however for comparison we used the sameexperimental settings as in jsnice and jsnaughty .
ix.
r elated work jsn eat is closely related jsnice and jsnaughty .
jsnice uses the graph representation of variables andsurrounding program entities via program dependencies.
itinfers the variable names as a problem of structured predictionwith conditional random fields crfs .
in comparison first while jsnice uses ml jsn eat is ir based in which it searches for a list candidate names in a large code corpus.
sec ond jsn eat considers not only the impacts of surrounding program entities in svc but also task and multiple variablecontexts.
third with crf jsnice is effective when variableshave more dependencies and less effective with the functionstable ix sensitivity analysis on combination parameters accuracy accuracy .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table x impact of training data s size on accuracy folds acc.full .
.
.
.
.
.
.
.
.
acc.token .
.
.
.
.
.
.
.
.
table xi running time comparison metric jsn eat jsnice jsnaughty training 2h05m 8h35m 12h25m per file recovery 32ms 72ms 129ms per variable recovery .9ms .6ms .8ms having one variable.
finally jsn eat is much faster and the results are more accurate as shown in section viii.
jsnaughty formulates name recovery as a statistical machine translation from the minified code to the recoveredcode.
first due to the nature of ml it faces the scalabilityissue in much higher time complexity.
second jsnaughty usesa phrase based translation model which enforces a strict orderbetween the recovered variable names in a function.
this is toostrict since a name of a variable might not need to occur beforeanother name of another variable.
third jsnaughty does notconsider the task context of the variables.
finally our train ing testing time is much faster.
in contrast other deobfuscationmethods use static dynamic analyses .
statistical nlp approaches have been used in se.
naturalize enforces a consistent naming style.
other applicationsof statistical nlp include code suggestion codeconvention method name suggestion api sugges tions code mining type resolution patternmining .
statistical nlp was used to generate code fromtext e.g.
swim deepapi anycode etc.
x. c onclusion this paper presents jsn eat an ir based approach to recover the variable names in minified js code.
we follow adata driven approach by searching for names in a large corpusof open source js code.
we use three types of contexts tomatch a variable in given minified code against the corpus.our ir approach enables us to achieve high accuracy with lesstime complexity than the state of the art approaches.
jsn eat achieves a high accuracy of .
the improvement of .
and over jsnice and jsnaughty respectively.
the time torecover for a file or for a variable with jsn eat is twice as fast as with jsnice and 4x as fast as with jnaughty respectively.
acknowledgment this work was supported in part by the us national science foundation nsf grants ccf ccf twc ccf and cns .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.