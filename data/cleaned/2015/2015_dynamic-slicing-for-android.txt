dynamic slicing for android tanzirul azim arash alavi iulian neamtiu and rajiv gupta university of california riverside usa email mazim002 cs.ucr.edu aalav003 ucr.edu gupta cs.ucr.edu new jersey institute of technology email iulian.neamtiu njit.edu abstract dynamic program slicing is useful for a variety of tasks from testing to debugging to security.
prior slicing approaches have targeted traditional desktop server platforms rather than mobile platforms such as android.
slicing mobile event based systems is challenging due to their asynchronous callback construction and the ipc interprocess communication heavy sensor driven timing sensitive nature of the platform.
to address these problems we introduce androidslicer1 the first slicing approach for android.
androidslicer combines a novel asynchronous slicing approach for modeling data and control dependences in the presence of callbacks with lightweight and precise instrumentation this allows slicing for apps running on actual phones and without requiring the app s source code.
our slicer is capable of handling a wide array of inputs that android supports without adding any noticeable overhead.
experiments on apps from google play show that androidslicer is effective reducing the number of instructions to be examined to .
of executed instructions and efficient app instrumentation and post processing combined takes seconds all while imposing a runtime overhead of just .
we present three applications of androidslicer that are particularly relevant in the mobile domain finding and tracking input parts responsible for an error crash fault localization i.e.
finding the instructions responsible for an error crash and reducing the regression test suite.
experiments with these applications on an additional set of popular apps indicate that androidslicer is effective for android testing and debugging.
index t erms mobile apps android dynamic analysis i. i ntroduction while mobile platforms have been very successful android alone runs on more than billion devices they are prone to development testing and reliability issues that affect users developers and manufacturers .
we propose an approach for tackling such issues via dynamic slicing a technique that isolates relevant code and data dependences in an execution.
slicing has proven useful in many contexts from security e.g.
taint analysis to debugging e.g.
fault localization and testing but prior slicing approaches have not targeted mobile platforms .
the smartphone platform compared to traditional desktop server platforms has unique challenges and constraints.
this renders traditional slicing approaches inapplicable and has allowed us to design novel solutions.
first reconstructing control flow is difficult android apps employ callbacks which process events asynchronously .
to cope with this we introduce the concept of asynchronous dependences to control and data dependences between callbacks as supernodes in a supergraph .
second android apps are timesensitive even slight delays in sensor input can change input semantics perturbing app execution.
we use an ondemand static after dynamic analysis to permit low overhead yet precise slicing.
third android has a wide range of inputs multi touch gestures sensors mic camera etc.
capturing this input correctly without losing precision is challenging and introduces significant overhead in other tools e.g.
pin .
we solve this challenge by combining lightweight tracking af wrappers with a layered abstraction supergraph .
fourth android uses ipc heavily for inter and intra app communication which requires tracking dependences from apps through system calls to external apps.
section iii presents our model and dependence rules.
section iv describes our approach to handling android specific challenges e.g.
sensor input low overhead and ipc.
our implementation androidslicer is described in section v androidslicer works on android apps running on actual phones and does not require app source code.
next we show how androidslicer serves as a building block for constructing three applications that facilitate bug finding bug fixing and testing.
first failure inducing input analysis i.e.
finding the input parts that are relevant to an error or a crash and tracking their propagation to the error crash site section vi a .
second fault localization i.e.
finding the part of the code a set of instructions responsible for an error or crash section vi b .
third we show how slicing helps reduce the number of tests for regression testing section vi c .
our analyses are robust and scalable we applied them to isolate causes of real bugs in widely popular apps such as soundcloud etsy k9 mail and npr news.
in section vii we evaluate androidslicer on popular apps from google play.
of these we manually analyzed apps to check androidslicer s correctness.
experiments indicate that androidslicer is efficient it typically instruments an app in just .
seconds and slice computation during post processing typically takes just .
seconds.
at most slice computation took .
seconds for the substantial twitter app whose bytecode size is .
mb.
moreover androidslicer h a sal o w runtime overhead typically .
finally androidslicer is effective it manages to reduce large executions on average instructions down to small slices on average instructions that are much more manageable for developers.
in summary this work makes four contributions ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a novel asynchronous slicing model.
a precise approach for slicing android apps that addresses the specific challenges and constraints of this platform and environment.
androidslicer a tool for slicing android apps while they run on actual phones.
a novel approach to reducing runtime overhead and handling the large array of inputs supported by android.
three slicing applications that facilitate development debugging and testing for android apps.
ii.
b ackground we first present a brief overview of program dependence graphs and program slicing next we discuss the android platform and its event based model.
program dependence graph pdg .
a pdg captures a program s data and control dependences.
each pdg edge represents a data or control dependence between nodes that can either represent an instruction or a basic block.
a directed data dependence edge nj dnimeans any computation performed innidepends on the computed value at node nj.
a control dependence edge nj cniindicates that the decision to execute niis made by nj that is njcontains a predicate whose outcome controls the execution of ni.
a static pdg consists of all possible data and control dependence relations.
a dynamic pdg is a subgraph that contains only those nodes and edges that are exercised during a particular run.
program slicing.
dynamic program slicing a class of dynamic analysis was introduced by korel and laski .
the backward dynamic slice at instruction instance swith respect toslicing criterion angbracketleftt s value angbracketright where tis a timestamp contains executed instructions that have a direct or indirect effect on value more precisely it is the transitive closure over dynamic data and control dependences in the pdg starting from the slicing criterion.
the slicing criterion represents an analysis demand relevant to an application e.g.
for debugging the criterion means the instruction execution that causes a crash.
android platform.
the android software stack comprises of apps a middleware component named android framework af which orchestrates control flow and mediates inter and intra app communication as well as communication between apps and the lower layers libraries and services a run time environment 2and the os an embedded version of linux.
android s event based model.
android apps do not have amain method but rather consist of components e.g.
an app with a gui consists of screens named activities3 and one or more entry points.
unlike traditional programs apps use an event driven model that dictates control flow.
an event can be a user action e.g.
touch a lifecycle event e.g.
onpause 2dalvik vm for android prior to .
in android version .
and later android uses art a runtime system and ahead of time compilation.
our implementation section v is on android .
.
.
3the vast majority of google play apps consist of activities.
there are other component types such as services content providers and broadcast receiver but these are used much more sparsely.when the app is paused arrival of sensor data e.g.
gps and inter or intra app messages.
all these traits from externallyorchestrated control flow to time sensitive sensor input render traditional slicing approaches inapplicable to android.
iii.
m odel in this section we present the model underlying our approach.
slicing precision depends on accurately identifying control and data dependences these dependences form the pdg.
our callback centric design achieves low overhead event capture without sacrificing precision all input data is captured natively from the framework .
instead of considering a single instruction instance as a node we collectively define callbacks as a node containing other nodes instructions or a supernode.
just like a regular node callbacks or supernodes can invoke other events callbacks directly a control dependence or by passing an argument to the framework which in turn is passed to another callback a data dependence .
our model captures both of these dependences for callbacks supernodes and instructions single nodes.
we use a hierarchical pdg constructed as follows.
high level supernodes nrepresent callbacks and their dynamic context superedges represent asynchronous control or data dependences between supernodes.
within supernodes we use low level instruction nodes sit and edges which capture sequential dependences.
supernodes n the core of our model are defined as n angbracketleftc t a angbracketright where callback variables ccontain the address of a callback tis the timestamp for node creation ais the activity context activity s runtime state while sit a regular node represents the instance of instruction siat time t. data and control dependences are denoted dand c respectively.
superedges connect supernodes and regular edges connect regular nodes.
note that supernodes might contain sub graphs consisting of regular nodes sit csjtorsit dsjt hence the hierarchical pdg notion.
we now explain our dependence rules shown in figure .
a. asynchronous dependences asynchronous data dependence.
intuitively asynchronous data dependences capture communication via message passing ipc objects etc.
.
we denote the set of registers defined in callback c1asdef c1 and the reference stored in register vxat time tasref vx t .
then callback instance c2is datadependent on callback instance c1 i.e.
n1 dn2 if at time t c1defines an inter or intra process messaging object intent in a register v1 and c2receives the same reference in register v2as a parameter.
this also introduces a data dependence from the first instruction s2tinc2that uses v2 to the instruction s1tinc1that defines v1.
depending on the callback data dependence can be inter app or intra app we track both.
asynchronous control dependence.
effective asynchronous slicing hinges on capturing dependences between asynchronous events precisely via superedges n cn2 whenever ndetermines initiates the execution of n2via authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
asynchronous data dependence sequential data dependence n1 angbracketleftc1 t1 a1 ... angbracketright n2 angbracketleftc2 t2 a2 ... angbracketright v2 param c2 v1 def c1 r e f v1 t1 ref v2 t2 n1 dn2 s1t ds2tv1 s1t v2 s2t v1 dins s1t v2 uins s2t ref v1 t ref v2 t s1t ds2t asynchronous control dependence sequential control dependence n1 angbracketleftc1 t1 a1 ... angbracketright n2 angbracketleftc2 t2 a2 ... angbracketright a1 negationslash a2 i n i t i a t o r n2 n1 n1 dn2 n1 cn2isbool s1t true sipdt ipd s1t i s po s t s2t sipdt true s1t cs2tn1 angbracketleftc1 t1 a1 ... angbracketright n2 angbracketleftc2 t2 a2 ... angbracketright a1 negationslash a2 i n i t i a t o r n2 n1 n1 dn2 n0 cn1 n0 cn2fig.
dependence rules.
activity context transitions.
being an event based model android s runtime system switches between different ui states activity contexts when asynchronous callbacks are invoked.
assuming the current activity context is a2 the current callback is c2whose supernode is n2 the previous activity context was a1and its exit i.e.
callback that triggered the context transition was c1whose supernode is n1 w e use the shorthand initiator n2 n1to indicate that n1 has triggered the transition to a2.
we define two rules that capture who has initiated n2.
the first rule captures a simple transition no intent passed between the two events i.e.
n1 dn2 .4the second rule applies when n2is data dependent on n1 in that case the initiator is that super node n0thatn1is control dependent on.
we then apply the same rule recursively on n0.
put otherwise these two rules help capture event causality by finding which event ncaused event n2 this is recorded as superedge n cn2.
b. sequential dependences sequential data dependence is captured by tracking the propagation of values through instructions sequentially that is control flow does not leave the current callback or its callees.
note that android is a register based machine hence registers are used to hold values pass values in and out of methods perform computation etc.
we track memory