hybridroid static analysis framework for android hybrid applications sungho lee kaist south korea eshaj kaist.ac.krjulian dolby ibm research usa dolby us.ibm.comsukyoung ryu kaist south korea sryu.cs kaist.ac.kr abstract mobile applications apps have long invaded the realm of desktop apps and hybrid apps become a promising solution for supporting multiple mobile platforms.
providing both platform specific functionalities via native code like native appsanduserinteractionsviajavascriptcodelikewebapps hybrid apps help developers build multiple apps for different platforms without much duplicated efforts.
however most hybrid apps are developed in multiple programming languages with different semantics which may be vulnerable to programmer errors.
moreover because untrusted javascript code may access device specific features via native code hybrid apps may be vulnerable to various security attacks.
unfortunately no existing tools can help hybrid app developers by detecting errors or security holes.
in this paper we present hybridroid a static analysis framework for android hybrid apps.
we investigate the semantics of android hybrid apps especially for the interoperation mechanism of android java and javascript.
then we design and implement a static analysis framework that analyzes inter communication between android java and javascript.
as example analyses supported by hybridroid we implement a bug detector that identifies programmer errors due to the hybrid semantics and a taint analyzer that finds information leaks cross language boundaries.
our empirical evaluation shows that the tools are practically usable in that they found previously uncovered bugs in real world android hybrid apps and possible information leaks via a widely used advertising platform.
ccs concepts theory of computation program analysis software and its engineering automated static analysis keywords android hybridapplications staticanalysis multi langua ge analysis analysis framework1.
introduction mobile applications apps have become the major source of digital media consumption but supporting multiple mobile platforms for each mobile app is a challenging task.
users are spending more time with mobile apps than desktop programs major internet companies consider mobile apps first and several vendors develop their own mobile platforms to serve mobile apps effectively such as android by google ios by apple and tizen os by samsung and intel.
however in order to entice users on diverse platforms developers should develop mobile apps on the various platforms which increases the development time and cost of mobile apps.
traditional approaches to support multiple platforms for a single app is to build either one native app for each platform or one web app for all platforms.
building native apps duplicates programming of the same app logic multiple times for different platforms but they can access platform specific functionalities.
one can build a single web app that can run on any browsers but such a web app cannot access platform specific information.
taking advantage of both native apps and web apps hybrid apps become a promising solution.
they support user interaction via javascript code like web apps and they provide device specific features via native code just like native apps.
by reusing the same user interaction code for multiple platforms and accessing platform specific capabilities via native api calls developers can build multiple apps for different platforms without much duplicated efforts.
moreover various hybrid app development frameworks like apache cordova formerlyphonegap freedevelopersfromwritingplatform specificcode.outsystemssurveyresultsinboth and reported hybrid apps as the most preferred mobile app development .
while hybrid apps simplify development efforts they introduce additional difficulties at the same time.
because most hybrid apps are developed in multiple programming languages with different semantics app developers should well understand such semantic differences.
for example android hybrid apps are written in both javascript for user interaction and java for android specific features java code and javascript code interact with each other by foreign function calls.
even though the statically typed java and extremely dynamic javascript have different behaviors the official android documentation does not specify their interactionthoroughly whichmaybevulnerabletoprogrammer errors.
moreover because untrusted javascript code may access device specific features via native code hybrid apps may be vulnerable to various security attacks .permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c circlecopyrt2016 acm.
... .
in this paper we present hybridroid a static analysis framework for android hybrid apps.
among various hybrid appsondifferentplatforms wefocusonandroidhybridapps because we can check our understanding of the android hybrid semantics by investigating the publicly available android source code .
we inspect the semantics of android hybrid apps especially for the interoperation mechanism of java and javascript.
because even the android documentation does not fully specify the semantics we identify the semantics via extensive testing and confirm the semantics by studying the source code.
then we design and implement a staticanalysisframeworkthatanalyzesandroidhybridapps by constructing call graphs for both java and javascript via an on the fly pointer analysis.
our implementation is built on top of wala an open source analysis framework for java and javascript.
to show possible use cases of hybridroid we present two tools a bug detector that identifies programmer errors due to the hybrid semantics and a taint analyzer that finds information leaks cross language boundaries.
our empirical evaluation shows that the tools are practically usable in that they found previously uncovered bugs in real world android hybrid apps and possible information leaks via a widely used advertising platform.
the contributions of this paper include the following we specify the interoperation semantics of java and javascript in android hybrid apps .
it describes the core inter language semantics empirically tested and confirmed by source code investigation.
we present hybridroid an open source static analysis framework for android hybrid apps1.
usinghybridroid we develop practical tools that detect previously uncovered issues in real world android hybrid apps in the google play store.
in the rest of this paper we provide a brief overview of the android hybrid app semantics section and describe the details of the inter language communication mechanism section .
then we discuss challenges in static analysis of android hybrid apps present how we address them in building hybridroid section and demonstrate two sample tools built on top of hybridroid section .
we show that the tools are practically useful in detecting real world problems section discuss the related work section and conclude section .
.
overview we provide a high level description of the android hybrid app semantics section .
how javascript code is evaluated from java code section .
and how java and javascript code communicate with each other section .
.
.
android hybrid app semantics an android app consists of app components that can be invoked individually and an activity is an app component denoting a single screen with a user interface.
an activity can show a web page to a user and support powerful web browsing features via webview based on the chromium open source project .
for example figure shows a sample code that loads a web page on a webview.
awebviewinstance wvis created on 1hybridroid isavailableat class mainactivity extends activity override 4protected void oncreate bundle savedinstancestate ... webview wv new webview this wv.getsettings .setjavascriptenabled true wv.setwebviewclient new mwebviewclient wv.setwebchromeclient new mwebchromeclient wv.loadurl ... 15class mwebviewclient extends webviewclient override public boolean shouldoverrideurlloading webview view string url ... 23class mwebchromeclient extends webchromeclient override public boolean onjsalert webview view string url string message jsresult result ... figure loading a web page on webview line and the next line allows the javascript code of wvto be evaluated which is disallowed by default.
on line the loadurlmethod of wvgets a string literal argument which denotes a web page url and loads the web page on wv.
in addition to such web page urls loadurlcan take addresses for local web pages denoting packed web pages in android hybrid apps as its arguments and load them on webviews.
it distinguishes the addresses for online web pages and those for local web pages by the prefixes of the addresses if the addresses start with they are online web pages and if they start with file they are local web pages.
awebviewruns on its own thread to load a web page it executes the javascript code in the web page asynchronously with java code.
java code can access the status of a webview by calling callback methods implemented in the webviewclientandwebchromeclient classes.
the setwebviewclient andsetwebchromeclient methods on lines and respectively register such instances.
thewebviewclient class provides callback methods which are invoked when events that impact the rendering of the content happen .
for example the shouldoverrideurlloadingmethod lines is called when its first parameterviewloads a new web page at its second parameter url.
one can intercept url loading by overriding this method.
thewebchromeclient classprovidescallbackmethods which are called when events that may impact the browser ui happen.
for example the onjsalert method lines is called when its first parameter viewexecutes the javascript alertfunction with the third string parameter message as the argument of the alertfunction on a web page at its second parameter url.
the fourth parameter resultprovides a way for javascript to indicate what java should do such as clicking a confirm or cancel button of the dialog window.
.
execution of javascript from java in android hybrid apps java initiates inter operation between java and javascript.
like the javascript evalfunction that creates code from a string value and evaluates the generated code at run time the webviewclass provides methods that create javascript code from java string values and execute the code in the javascript environment.
thewebviewclass provides two such methods loadurland evaluatejavascript .
theloadurl method not only loads a web page but also executes javascript code.
if its argument string value starts with javascript the method recognizes the argument as javascript code and executes it in the current javascript environment.
similarly the evaluatejavascript method creates javascript code from its first string argument executes it in the current javascript environment and invokes its second callback argument with the result of the javascript code.
.
interaction between java and javascript the communication capability between the native java code and the javascript code enables javascript to access platform specific information.
android provides two kinds of communication between java and javascript callback communication and bridge communication.
callback communication.
android hybrid app developers can use callback methods provided by webviewclient andwebchromeclient discussed in section .
as channels for communication between java and javascript.wecallthiskindofcommunication callback communication .
developers first choose specific events that they useforinter communication andoverridethecallbackmethods corresponding to the selected events so that they can receive the events when they occur.
then javascript code can invoke the events to invoke java callback methods and pass some information to java as method arguments.
for example if a developer uses the event that loads web pages as a communication channel the developer should implement a subclass of webviewclient and override the shouldoverrideurlloading method for communication.
when the javascript code location.href command is executed the shouldoverrideurlloading method is invoked with the command argument as its urlparameter and the developer can handle command in java.
similarly if a developer uses the alertevent as a communication channel when the javascript code alert command is executed the onjsalert callback method can handle command in java.
bridge communication.
the second mechanism called bridge communication supports communication between java and javascript directly rather than exploiting callback methods intended for other purposes.
in the bridge communication mechanism java code injects a java object to the javascript environment of awebview and javascript code running on the webview directly invokes methods of the java object.
more specifically the addjavascriptinterface method of webviewinjects its first argument java object to the javascript environment with its second string argument as the javascript name of the injected java object.
we call the injected java object an injected object .
then javascript code can invoke methods of injected objects the bridge communication mechanism does not allow javascript to access fields of injected objects.1class jsbridge javascriptinterface 3public string send string msg return ok 7public string getname return jsbridge override 13protected oncreate bundle savedinstancestate ... 15webview wv new webview this 16wv.addjavascriptinterface new jsbridge bridge 18wv.loadurl file android asset www index.html ... a android java code 1var result bridge.send example 2var name bridge.getname b javascript code in index.html figure bridge communication figure presents an example code for bridge communication.
the java code shown in figure a declares a class namedjsbridge which defines two methods sendandgetname lines .
it injects an instance of jsbridge as the namebridgeinto the javascript environment by calling the addjavascriptinterface method of a webview lines .
then the android system creates a new javascript object from the injected object and attaches it to the javascript global object with the name bridgewhenever a web page is loaded on the webview.
we call the created javascript object abridge object .
at the call site of the loadurlmethod lines the index.html page located in the assets www directory of the hybrid app is loaded on the webview.
thewebview loads the web page makes a new javascript environment for the web page creates the bridge object attaches it to the global object of the javascript environment and executes the javascript code in the web page.
when the javascript code in the web page is as shown in figure b the invocation of the method sendof the bridge object passes the argument example to the corresponding method of the injected object receives the result ok and assigns it to a javascript variable result.
note that because the addjavascriptinterface method enables javascript code to control the java environment it may open the gate to security vulnerabilities.
even the official android documentation makes the following note use of this method in a webviewcontaining untrusted content could allow an attacker to manipulatethehostapplicationinunintendedways executing java code with the permissions of the host application.
use extreme care when using this method in a webviewwhich could contain untrusted content.
thus since the android version javascript code can access only such public methods of injected objects that havethe javascriptinterface annotation.
infigure2 a the 252figure bridge object initialization method sendhas the javascriptinterface annotation but the method getnamedoes not.
therefore in figure b the method call of sendexecutes normally but the call of getname throws the methodnotfound exception on the android version or later.
unfortunately even recent android should allow apps targeting old android versions to use all public methods from javascript to support backward compatibility.
because bridge communication supports interaction between java and javascript more directly than callback communication weconsideronlythebridgecommunicationmech anism throughout this paper.
.
bridge communication semantics in this section we describe the behavior of bridge communication in detail.
because the official android documentation does not specify the behavior thoroughly we identify the bridge communication semantics via extensive testing and confirm the identified semantics via source code inspection of the android system.
.
initialization of bridge objects as we discussed in section .
whenever a web page is loaded on a webview the android system creates a bridge object for each injected object via the addjavascriptinterface method.
it maintains a mapping between names of bridge objects and their corresponding injected objects.
thus no multiple injected objects have the same bridge name.
on the contrary a single injected object may have multiple bridge names which implies that multiple bridge objects may represent a single injected object.
when creating a bridge object for an injected object the android system generates a mock up object for each public method annotated with javascriptinterface of the injected object.
we call such mock up objects bridge methods .
a bridge object has bridge methods as its properties named with the corresponding method names.
figure illustrates how bridge objects are initialized.
the left box shows java code and the right box shows a graph describing the javascript environment where nodes denote javascript objects and edges denote relations between objects and names.
the red circle is the global object in the javascript environment a blue diamond represents a bridge object and green triangles represent bridge methods.
a solid edge represents that its fromjavascript objecthasitstojavascriptobjectasitspropertynamedastheedge label.
a dashed edge represents that its fromjavascript object refers to its tojava object.
a dotted edge represents that itsfromjava name is used in the javascript environment as its toproperty name.
note that the bridge object blue diamond refers to the injected object in java but the bridge methods green triangles do not refer to any methods in java because java methods are not objects.
thus the androidsystemmaintainsonlythenamesof bridgemethods without any mapping to their corresponding java methods.
.
unique semantics of bridge objects whiletheandroidsystemtreatsbridgeobjectsandbridge methods similarly for normal javascript objects bridge objects behave differently from normal javascript objects in somecases.injavascript objectscandynamicallyadd delete and modify their properties depending on the attributes of the properties .
a property associates its name with four attributes and .
if is true the value of the property can change.
if is true the property will be enumerated in the condition expression of the for instatement.
if is true the property can be deleted among other things.
however even though bridge methods are properties of bridge objects and their and attributes arealltrue deletingandmodifyingbridgemethodsofbridge objectsarenotallowed.attemptstodeleteandmodifybridge methods are silently ignored.
.
function calls in bridge communication in android hybrid apps bridge method calls are different from normal javascript function calls.
as we discussed in section .
because java methods are not first class objects the android system does not maintain mappings from bridge methods to their corresponding java methods.
thus when calling a bridge method the android hybrid mechanism finds a target java method using java reflection with the name of the bridge method.
the evaluation of bridge method calls proceeds as follows .
check whether a given receiver object is a bridge object.
if it is not a bridge object throw the noninjectedreceiver exception.
.
find a list of java methods using java reflection with the class name of the injected object corresponding to the receiver object and the name of the bridge method.
ifthelistisempty throwthe methodnotfound exception.
.
find a target java method from the method list using the number of arguments.
if there is no method with the same number of parameters arity throw the methodnotfound exception.ifmultiplemethodswiththe same arity exist select a method among them.
.
convert the javascript argument values to their corresponding java values.
.
call the target java method with the injected object corresponding to the receiver as the thisobject and converted argument values.
.
convert the java method result value to its corresponding javascript value and return the converted javascript value back to the javascript environment.
253table compatible types from javascript values to java val ues object string bytecharshort intlongfloat double boolarray null undefined string boolean number object table compatible types from java values to javascript valu es object string bytecharshort intlongfloat double boolarray void javascript value note that bridge methods support method overloading partially.
java supports overloading which allows multiple method declarations with the same name when they have different arities or the same arity but different parameter types.however javascriptdoesnotallowoverloading when therearemultiplefunctiondeclarationswiththesamename the last one overwrites all the former ones.
on the contrary android hybrid mechanism allows multiple bridge methods with the same name only when they have different arities as the 3rd step in the above process specifies.
when multiple methods with the same name and the same arity exist the android system chooses a method among them as a target method to call without any warning or exception.
one interesting point is that because a bridge method maintains only the name of its corresponding java method without any information about the class that defines the java method bridge method calls may produce unintuitive results.
for example consider the following javascript code bridge2.foo bridge1.receive bridge2.foo wherebridge1andbridge2are bridge objects that refer to injected objects of class aand class b respectively in addition the class adefines a public method named receive with the javascriptinterface annotation.
evaluation of the first line assigns the bridge method to the fooproperty of bridge2.
then evaluation of the second line invokes the bridgemethodnamed receivewiththereceiverobject bridge2 which makes the java method named receive defined in the class bas the target java method to call.
if the class bhappens to define a public method named receive with thejavascriptinterface annotation without any parameters the method will be called.
otherwise the android system throws the methodnotfound exception.
.
type mismatch in java and javascript while java is statically typed and javascript is not the evaluationprocessofbridgemethodcallsinvolvesconversion of values between java and javascript.
the 4th step in the bridge method call process specifies that javascript values denoting method arguments are converted to java values and the 6th step specifies that java values denoting method call results are converted to javascript values.
wedescribesuchbidirectionalvalueconversionrulesbased on our extensive testing and the android source code investigation.
when a javascript value of javascript type 1ispassed as a method argument to a parameter of java type 2 if 1is compatible with 2the android system uses the value accordingly.
in table when a javascript value of javascript type 1such as null undefined string boolean number orobjectis passed to a parameter of java type 2 the corresponding entry is marked if they are compatible marked if the compatibility depends on the javascript value and marked if they are not compatible.
similarly table specifies whether a java value of type 1is compatible with any javascript value.
whenjavascripttypesarenotcompatiblewithjavatypes in table the android system uses default values of java types when java types are not compatible with any javascript values in table the android system usesundefined .
the conditionally compatible cases are more complex than the others.
the case is when a javascript object is passed as an argument to a parameter of java object type 2. if the javascript object is not a bridge object the android system uses null.
if it is a bridge object whose corresponding injected object has type 1 the android system checks the type compatibility between 1and 2. if they are compatible it uses the injected object as the argument otherwise it throws an exception.
when a javascript array value is passed as an argument to a parameter of java object type 2as in if 2is an array type with the element type 3 the android system checks the compatibility of each element of the javascript array value and the type 3 otherwise it throws an exception.
finally when a java object value is returned to javascript as in the case the android system makes and returns a new bridge object that refers to the java object.
note that when the return type of a java method is an array type the android system does not call the method but returns undefined which is a peculiar semantics requiring extreme care from hybrid app developers.
.
challenges in static analysis of android hybrid apps in this section we describe challenges in statically analyzing android hybrid apps and how we address them.
while static analysis of android apps alone or javascript apps alone still has various open problems to solve they are beyond the scope of this paper.
throughout this paper we focus on the issues in static analysis of bridge communication between java and javascript.
254figure modeling of javascript java environments .
multiple javascript environments becauseandroidhybridappsmayloadmultiplewebpages where each web page has its own javascript environment analysis of android hybrid apps requires analysis of interactions between a single java environment and multiple javascriptenvironments.letusconsidertwopossibleapproaches for their analysis separately analyze each web page with the java environment and analyze all web pages with the java environment at the same time.
the first approach is simpler than the second because each analysis considers only one javascript environment but it misses analysis of various hybrid behaviors.
while the javascript environment of a web page can affect the java environment and vice versa viabridgecommunication whichimpliesthatthejavascript environment of one web page can also affect that of another web page the first approach cannot address such behaviors.
thus we take the second approach.
figure illustrates our modeling of multiple javascript environments.
to represent the javascript environment of each web page separately we model that each web page has its own javascript global object red circle and the javascript code in one web page can access only the global object of the web page.
in the figure green triangles represent normal javascript objects blue diamonds represent bridge objects and purple stars represent java objects.
three kinds of edges represent relationships between objects solid undirected edges denote property relations dashed directed edges denote that the frombridge objects refer to thetoinjected objects and solid directed edges denote that the fromobject can affect the status of the toobject directly or indirectly.
note that the javascript environment of each web page is isolated by its own global object.
the javascriptenvironmentsof a.htmlandb.htmlcanaffecteach other indirectly because their bridge objects aandb refer to the same injected object e. also the javascript environment of b.htmlcan affect that of c.html because an injected object freferred by a bridge object cinb.htmlcan directly or indirectly affect an injected object greferred by d a bridge object of c.html.
on the contrary the javascript environment of c.htmlcan affect the java environment but it cannot affect any other javascript environments.
our modeling soundly abstracts the android hybrid app environments.
we can further improve the modeling precision by reflecting asynchronous execution of javascript code inmultiple webviewsforexample.however becauseourbaseline analysis is flow insensitive as we describe in section such modeling improvement belongs to our future work.
.
dynamically obtained source code one of the main difficulties in static analysis of android hybrid apps is the lack of the source code to analyze at compile time.
often apk archives of android hybrid apps do not contain the entire programs.
while running android hybrid apps download and show online web pages using their addresses at run time.
also just as in other javascript web apps javascript code in android hybrid apps may generate code from string values dynamically.
because such dynamically obtained code is not available statically static ana lysis of the code in apk archives alone cannot analyze such code.
to analyze dynamically obtained code statically as much as possible we perform a string analysis for android hybrid apps prior to its main analysis.
the string analysis analyzes string values used for the arguments of the loadurlmethod and categorizes the analysis results into four cases local web page addresses online web page addresses javascript code and unknown.
when the argument is a local web page address it is already available for static analysis.
when the argument is an online web page address we download the whole source code of the web page so that the main static analysis can analyze it.
when the argument is javascript code we include it in the analysis target of the subsequent main analysis.
finally when the argument is not precisely known statically we partially model it by making the main analysis analyze all local web pages in the apk archive.
while this modeling is incomplete it takes the best effort by analyzing all statically available local web pages.
the main analysis maintains mappings between the loadurlcall sites and their argument values to analyze each call site precisely.
even when multiple webviews load the same web page the javascript code in the web page may run differently depending on the webview in which the web page is loaded because each webviewhas its own bridge objects.
therefore for call graph construction we identify which javascriptenvironmentsmapwhichbridgeobjectsusingthe mapping of the loadurlcall sites and their argument values.
.
analysis sensitivity for multiple languages thebestanalysissensitivityconfigurationdependsonseveral aspects.
more context sensitive analyses may produce more precise analysis results with more performance overhead for c programs object sensitive analysis may work well for java programs and more precise analysis may evenimproveanalysisscalabilityforjavascriptprograms .
thus itisnotyetclearwhichanalysissensitivitywouldwo rk the best for android hybrid apps.
in order to experiment with various analysis sensitivities to better support the android hybrid app analysis we provide configurability of analysis sensitivities.
our analysi s framework described in section supports various contextsensitive analyses to construct call graphs.
it also supports different sensitivities for analyses of java and of javascript.
.
semantics specific to android versions analysis of android hybrid apps should work differently depending on the target android versions of the apps.
as we discussed in section .
in the android version or later only public methods with the javascriptinterface annotation in injected objects are accessible from javascript code.
however for backward compatibility the android system allows apps targeting old android versions to use all public methods of injected objects from javascript code.
255figure overview of hybridroid toperformpreciseanalysisdependingontheandroidversions we extract the target version of android hybrid apps specified in androidmanifest.xml by decompiling their apk archives using apktool .
the apktool is a reverse engineering tool for android apps which decompiles java class files to smali code decompiles resources to their original forms and assembles the app information into a file named apktool.yml .
sinceapktool.yml contains various information including the sdk package version compression and shared library we parse apktool.yml to extract the target android version of the app.
using the extracted target android version the analysis identifies accessible java methods from javascript code for constructing call graphs.
.hybridroid analysis framework now we demonstrate hybridroid a static analysis framework for android hybrid apps and show two sample tools usinghybridroid a bug detector and a taint analyzer.
.
architecture of hybridroid weimplemented hybridroid asanextensionofwala which is an open source static analysis framework originally developed for java bytecode and now it supports javascript programs and android java dalvik bytecode.
it provides flow insensitive and context sensitive analyses.
while it can analyze javascript and java separately it cannot analyze interaction between javascript and java.
thus we use both analysis modules for javascript and java and extend them to analyze inter communication between them.
figure presents the overall architecture of hybridroid .
for simplicity we omit basic wala modules and show only core modules of hybridroid string analyzer information extractor hybridroid scope builder andhybridroid callgraph builder.
the figure also presents two add on tools bug detectorandtaint analyzer which utilize the analysis of intercommunication between java and javascript.
bug detector finds possible programmer errors in android hybrid apps andtaint analyzer tracks flows of tainted data from sources origins of tainted data to sinks leaking points of tainted data.
we describe the tools in detail in next sections.
string analyzer takes the input apk archive and statically analyzesittoextractconcretestringvaluesusedasthearguments of the loadurlmethod as we discussed in section .
.
it first builds dependency graphs that represent how such argument values are constructed using a backward slicing technique .
then it computes string values of the load urlarguments using the dependency graph by fixpoint iterations.
to focus on analysis of user defined code we model a set of built in string operators such as appendandindexof.
information extractor retrieves necessary information of the android hybrid apps as we described in section .
.
it generates yml data which contains various information of the target android hybrid app in apktool.yml .
hybridroidscopebuilder takestheapkandthestringanalysis result as inputs and builds a target analysis scope.
using the string analysis result string information it downloads missing web pages and saves each dynamically executed javascript code.
it collects all the dynamically executed javascript code in addition to the dalvik bytecode and javascript code in local web pages and builds a hybridroidscope thatincludesallthecollectedcode.
hybridroid scopealso contains the android framework bytecode java built in bytecode and built in models provided by wala.
hybridroid callgraph builder takes both hybridroid scope andyml data as inputs and constructs a call graph for the target android hybrid app.
it extends an existing wala modulethatconstructscallgraphs andithandlesbridgeinitialization bridge communication and multiple javascript environments as we discussed in sections and .
note that it considers the target android version of the hybrid app fromymldata to reflect the different semantics of different android versions.
it constructs call graph s as the same data structure with wala so that hybridroid can use existing wala analysis modules for analyzing inter communication.
.
bug detector building android hybrid apps may be more error prone than building native apps or web apps because no developmenttoolslikeintegrateddevelopmentenvironments ides exist for hybrid apps and no documentation thoroughly specifiesthedelicatesemanticsoftheirinter communicati on.
the only possible way for developers to build high quality apps seems to be extensive testing.
moreover because android hybrid apps do not terminate abnormally when bugs happenineither javaorjavascriptcodebutonlyshowerror log messages such bugs are difficult for developers to catch.
to help developers find such bugs we implement bug detectoron top of hybridroid .
when the hybridroid callgraph builderconstructs call graphs bug detector finds possible errors and reports them.
it can detect four kinds of sample bugs methodnotfound typeoverloadedbridgemethod notcompatibletypeconversion andmethodnotexecuted .
256methodnotfound.
whenajavascriptbridgemethodcallcannotfindanytarget java method to call bug detector reports the methodnotfound error which may be due to three reasons.
the first case is when a developer makes a typo in the bridge method name or indeed calls an undefined method of an injected object.
the second case is when a target java method is inaccessible either because it is private or it does not have the javascriptinterface annotation when the target android version is or later.
finally the third case is when a bridge method call has a wrong number of arguments.
methodnotexecuted.
bug detector reports the methodnotexecuted error when the return type of a target java method is an array type.
as we discussed in section .
the android hybrid mechanism ignoressuchbridgemethodcallswithoutanywarning which is vulnerable to programmer errors.
typeoverloadedbridgemethod.
because android hybrid apps do not support overloading with different types of parameters as we discussed in section3.
bugdetector reportsthe typeoverloadedbridgemethod warning when a bridge method call invokes a java method that has multiple methods with the same name and number of parameters but different types.
while android does not signal an error but chooses a method among the overloaded methods such semantics is unintuitive and error prone.
incompatibletypeconversion.
bugdetector reportsthe incompatibletypeconversion warning when a bridge method call uses default values for java method arguments.
as we discussed in section .
when the types of javascript values are not compatible with java types the default values of the corresponding java types are used instead.
while android does not signal any error in this case the semantics is undocumented and error prone.
.
taint analyzer in addition to the security vulnerabilities in android apps and javascript apps android hybrid apps may have new kindsofsecurityvulnerabilitiesinvolvinginter languagec ommunication.
one particular example is information leakage from device features through advertising ad platforms .
because ad platforms require various user granted permissions and the android system simply enumerates required permissions without actually separating execution of hybrid app code from that of ad platforms adversaries can deploy malicious advertisement to steal private data for example.
to detect such information leaks that involve both java and javascript execution flows we implement taint analyzer which tracks data and control flows in bridge communication.
specifically it focuses on detecting information leakage via ad platforms that themselves are hybrid apps.
similarly for bug detector taint analyzer is built on top of hybridroid using the interprocedural finite distributive subset ifds framework provided by wala.
taint policy.
taint analyzer propagates taint information according to the value propagation semantics of java javascript and bridge communication.
for collection values such as arrays lists and maps we over approximate their value propaga tionbyjoiningthetaintinformationofalltheirelements.for example when an array element contains a tainted value the analysis considers the entire array as tainted.
similarly when a native method is called with a tainted argument the analysis considers all the arguments and its result tainted.
sources and sinks.
in android hybrid apps sourcesandsinksmay exist cross language boundaries.
for example when an app extracts a user s location and sends it over the network via javascript the source is in java and the sink is in javascript.
when an app receives a password from a user and saves it via java the source is in javascript and the sink is in java.
in addition because android apps provide multiple layers of information flows such as inter app flows and intercomponent flows explicitly or implicitly sources and sinks may exist cross app boundaries.
for example when an app uses anintentwith an action android.intent.action.pick to call the galleryactivity of the android default app which returns an image to the caller the source exists in the android default app.
in this case instead of the galleryactivity we consider android.intent.action.pick as the source.
android specific additional control flows.
in order to better analyze android specific flows like implicit control flows via intents and flows between sources and sinks cross app and cross component boundaries we extend the base android analysis of wala with additional flows.
more specifically taint analyzer adds two kinds of additional edges in call graphs to support more flows between components in a single app it adds edges from all the activity starting method calls like startactivity andstartactivityforresult to all the activity creating methods oncreate and to support more flows between components in different apps for each activity it adds edges from its startactivityforresult calls to its onactivityresult to represent flows passing results from different apps activities to the activity.
note that because it adds extra edges on the underlying pointer analysis results previously unreachable method call s in the pointer analysis results may become reachable due to the extra edges.
since such method calls do not have any edges to the method bodies of their corresponding callees in the pointer analysis results the analysis of taint analyzer cannot analyze their method bodies.
to add edges from such method calls to the bodies of their callees we perform the class hierarchy analysis cha from the receiver types of the calls.
traversing class extension relations from the static types of the receivers it finds corresponding method bodies and adds edges from the calls to the bodies.
.
discussion we presented a static analysis framework for android hybrid apps but there remain rooms for improvement.
string analysis precision.
whilestring analyzer is not the main contribution of this paper its analysis results affect the analysis quality of hybridroid.
because we use a simple string analyzer hybridroid may miss javascript code execution initiated by java via loadurl and it may also miss page loading via online web pages.
note that hybridroid is not tied to a specific string analyzer and it can adopt advanced string analyzers .
257table bug detection results rank hybrid app bug type fp tp bug cause time 100com.gameloft.android.anmp.gloftdmhm methodnotfound obfuscation sec.
com.creativemobile.dragracing methodnotfound sec.
com.gau.go.launcherex methodnotfound sec.
com.tripadvisor.tripadvisor methodnotfound obfuscation sec.
com.dianxinos.dxbs methodnotfound obfuscation sec.
com.magmamobile.game.lostwords methodnotfound sec.
com.daishin methodnotfound 01undeclared method sec.
100com.carezone.caredroid.careapp methodnotfound 05missing annotation sec.
com.pateam.kanomthai methodnotfound 02missing annotation sec.
com.acc5.l6 methodnotfound 06missing annotation sec.
jp.cleanup.android methodnotfound sec.
ligamexicana.futbol methodnotfound sec.
100com.sysapk.weighter methodnotfound 01missing annotation sec.
com.youmustescape3guide.free methodnotfound 06missing annotation sec.
total methodnotfound 724missing annotation obfuscation sec.
undeclared method webview callback supports.
as we discussed in section because bridge communication supports interaction between java and javascript more directly than callback communication we consider only the bridge communication mechanism in this paper.
we may want to further support callback communication.
android java and javascript analysis.
eventhough hybridroid focusesoninter languagecommunication analysis the analysis quality depends on the underlying analysis of java and javascript.
because wala supports only flow insensitive analyses and because it does not support extensive dom modeling hybridroid can further be improved by using advanced baseline analyzers.
.
ev aluation in this section we show the usefulness of hybridroid by presenting previously uncovered issues detected by bug detector section .
and taint analyzer section .
.
.
real world bug detection to evaluate the quality of android hybrid apps in terms of the bugs defined in section .
we collected real world androidappsusingplaydrone agoogleplaystorecrawler .
wedownloaded100appseachfromrankings1 and and chose hybrid apps that use bridge communicationamongthem.wecollectedall48hybridapps from the ranks to and hybrid apps each for the other ranks which amounts to hybrid apps in total.
we analyzed these target hybrid apps with bug detector and manually verified the reported bugs as summarized in table .
the first column presents the ranking groups the second column presents the apps that have reported bugs and the remaining columns present the bug types the numbers of unique bugs the numbers of false positives and true positives the causes of the bugs and the time in seconds.
among target hybrid apps the tool reports that apps may contain bugs.
we observed that apps contain true alarms and the other apps contain false alarms.
surprisingly all true alarms are methodnotfound .
we found that hybrid app developers use bridge communication carefully without manipulating bridge objects andbridge methods they simply call bridge methods.
moreover most arguments to bridge methods are javascript strings.
out of true bugs bugs are caused by the missing javascriptinterface annotation bug is because of calling an undefined method and bugs are due to wrong obfuscation.
to protect android apps from repackaging attacks developers often obfuscate their apps before deployment because obfuscation changes names of classes methods and fields to meaningless names it may make reversing of the apps difficult.
google officially supports apk obfuscation by proguard since april .
however because only java code is obfuscated javascript code still accesses bridge methods using their original names even after obfuscation in java.
in order to avoid these bugs developers should not obfuscate the accessible java methods from javascript.
we observed that all false positives are due to the imprecise string analysis.
when the string analysis fails to find concrete values for the arguments of loadurl the tool regards that all local web pages can be loaded which may be too conservative.
we believe that a better string analysis would improve the analysis precision of hybridroid .
.
private data leakage detection toinvestigatesecurityissuesinadplatforms wemanually inspected all hybrid apps in top android apps in the google play store.
we found ad platforms used by them identified among them using bridge communication and observedthat3adplatforms inmobi supersonic and millennial media require rather aggressive permissions like external storage accesses and audio recording.
among them we closely examined inmobi which exposes powerful java methods including makecall sendmail takecamerapicture andgetgalleryimage .
when a hybrid app that integrates inmobi runs inmobi fetches ads to the app.
toanalyzetheinmobiadsourcecode weextractthehtml and javascript code of the fetched ad using the chrome remote debugging tool .
the extracted javascript mraid.js contains various functions that call java methods as follows a.getgalleryimage function return sdkcontroller.getgalleryimage window.imraidv iew to evaluate whether taint analyzer detects possible privacy leaks we created a sample hybrid app that simply loads a 258local web page which in turn just calls the getgalleryimage function.
we manually inspected the inmobi sdk source codeandfoundthattheabove sdkcontroller.getgalleryimage method call leads to a galleryactivity using an intent with theandroid.intent.action.pick action.
then the gallery activity shows its image gallery.
when a user selects one image the image is sent to the javascript environment by calling another javascript function from mraid.js a.firegalleryimageselectedevent function a b c var d new image d.src data image jpeg base64 a d.width b d.height c window.imraid.broadcastevent galleryimageselected d via aloadurlmethod call.
we confirmed it by running the samplehybridappwithanew firegalleryimageselectedevent function that logs its arguments.
we analyzed the sample hybrid app that uses the inmobi platform via taint analyzer .
for a taint source we takeandroid.intent.action.pick for taint sinks we consider all javascript functions in mraid.js .
the tool detected the flow from android.intent.action.pick to javascript functions and warned the possible data leakage successfully.
.
related work in this section we discuss the literature on static analyses of android apps javascript programs and hybrid apps.
static analysis of android apps.
while android apps provide multiple layers of information flows such as inter app flows and inter component flows explicitly or implicitly no existing static analyzers for an droid apps can precisely analyze various flows in a scalable manner yet .
most android analyzers are built on top of either wala or soot .
soot is an open source java and android app analysis framework which provides call graph construction pointer analysis and data flow analysis.
scandroid is the first wala based analyzer for android apps.
it tracks data flows including inter component communication icc andinter appcommunicationtocheck consistencyofsecurityspecificationinandroidmanifestfiles .
droidel provides an extensible android analysis framework based on wala which generates app specific android framework stubs automatically.
among various soot based android analyzers epicc provides detection of icc vulnerabilities by analyzing icc via reducing icc to the inter procedural distributive environment problem.
to analyze more flows in android apps gator considers gui objects events and callback handlers to analyze inter component control flows induced by them.
flowdroid also expands the control flows by analyzing the activity life cycle precisely.
droidsafe improvesprecisionandaccuracyofandroidinformationflow analysis by accurate analysis stubs.
apposcopy proposes a new semantics based detection of private data leakage in android apps by specifying semantic characteristics of malware families.
although all the above tools focus on analysis of android apps alone their research achievements will surely be applicable to hybridroid regardless of their base analyzers.static analysis of javascript programs.
static analysis of javascript programs have focused on improving the analysis scalability.
jsai is a javascript abstractinterpreterusinganabstractmachine basedsemantics but it supports only limited modeling of built in dom and browser apis which is not usable in analysis of realworld javascript web apps.
safe supports analysis of web apps using various javascript libraries dom and browser apis and platform specific apis and it can analyze all existing versions of jquery.
tajs tracks string values passed to the evalfunction and it analyzes events by considering all possible combination of event calls.
however safe and tajs do not support java analysis.
finally wala supports both java and javascript analysis.
while it provides only sound pointer analysis for java programs it provides both sound propagation based analysis and unsound field based analysis for javascript.
even though the implementation of hybridroid is based on wala its design and the analysis between java and javascript are not tied to any specific of wala.
static analysis of hybrid apps.
recently static analyses of hybrid mobile apps built using cross platform frameworks that implement the apache cordova library have been proposed.
jin et al.
introduced javascript injection attacks via network communication in hybrid mobile apps based on the phonegap framework andproposedastaticdetectiontoolthatanalyzesonly javascript code.
shehab and aljarrah reported security issues in the app level access control mechanism used in cordova basedframeworks anddevelopedasimpletoolthat checks usage of phonegap plugins.
brucker and herzberg built a static analyzer of hybrid mobile apps developed using cordova.
unlike hybridroid that analyzes flows between javascript and java seamlessly their tool builds control flow graphs of javascript and java separately and adds edges between them using various heuristics.
.
conclusion hybrid apps have become the most preferred app development because they enjoy both platform independent user interaction via javascript and device specific functionaliti es via native code.
at the same time hybrid app developers should be extremely careful in utilizing communication between languages with different semantics and protecting private data from malicious accesses.
in this paper we present a static analysis framework for android hybrid apps hybridroid which analyzes inter communication between java and javascript.
we show that hybridroid is useful in detecting programmer errors due to misunderstanding of interlanguage communication and possible private data leakage throughadplatforms.ourexperimentalresultsrevealed previously uncovered bugs and rooms for information leakage due to powerful functionalities of ad platforms .
we believe thathybridroid will enable detection of various kinds of programmer errors and security vulnerabilities cross language boundaries in android hybrid apps.
acknowledgment this work is supported in part by national research foundation of korea grant nrf 2014r1a2a2a01003235 and samsung electronics.
.