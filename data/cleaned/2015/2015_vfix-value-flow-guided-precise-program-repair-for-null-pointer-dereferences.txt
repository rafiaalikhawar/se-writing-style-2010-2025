vfix v alue flow guided precise program repair for null pointer dereferences xuezheng xu y ulei sui hua yan and jingling xue school of computer science and engineering unsw sydney australia xuezhengxu huayan jingling cse.unsw.edu.au faculty of engineering and information technology university of technology sydney australia yulei.sui uts.edu.au abstract automated program repair apr faces a key challenge in efficiently generating correct patches from a potentially infinite solution space.
existing approaches which attempt toreason about the entire solution space can be ineffective byoften producing no plausible patches at all and imprecise byoften producing plausible but incorrect patches .
we present vf ix a new value flow guided apr approach to fix null pointer exception npe bugs by considering asubstantially reduced solution space in order to greatly increasethe number of correct patches generated.
by reasoning about thedata and control dependences in the program vf ixcan identify bug relevant repair statements more accurately and generatemore correct repairs than before.
vf ixoutperforms a set of state of the art apr tools in fixing the npe bugs in defects4j in terms of both precision by correctly fixing times as manybugs as the most precise one and more than all the bugscorrectly fixed by these tools altogether and efficiency byproducing a correct patch in minutes instead of hours .
keywords program repair static analysis null dereference i. i ntroduction to reduce the maintenance cost of large scale software automated program repair apr provides a promising solution for automatically generating software patches to fix software bugs.
existing apr approaches proceed in two phases fault localization which identifies a set of suspicious i.e.
repair statements l that may trigger a bug after exercising at least one failing test case in a test suite and patch generation which generates a repair operation o oby applying a predefined repair template e.g.
insertion anddeletion on a suspicious statement lscript land then validates the candidate patch by running the repaired program againstthe test suite.
this generate and validate process repeats untilaplausible patch i.e.
one that passes all the test cases in the test suite is found.
a plausible patch is only correct iff it results in the correct outputs for all possible program inputs.
challenges.
apr faces a key challenge in efficiently generating correct patches from a potentially infinite solution space.given a set of predefined repair templates existing search based approaches usually generate an unbounded number ofrepair operations o e.g.
via brute force mutations even for a single suspicious statement lscript l. the underlying search space explosion problem is further exacer bated when all repair templates are instantiated over all thesuspicious statements in a program.
the resulting solution1 1112boolean removedomainmarker ... ... if layer layer.foreground markers this....markers.get ... else markers this....markers.get ... removed markers.remove ... if removed notify firechangeevent return removed if markers null return false if markers null return false if markers!
null npe!
correct patch implausible patchplausible but incorrect patchexecuted statement unexecuted statement crash point fig.
an example with three patches correct plausible but incorrect and incorrect for fixing the npe at l8.
spaces l o c i xmay contain possibly infinitely many patches where the ratio of the correct patches c over the incorrect patches including implausible ones iand plausible but incorrect ones x is extremely small.
this can seriously impede the efficiency and effectiveness of existing apr approaches in finding correct patches.
prior work.
to address this problem existing efforts typically accelerate the repair process by ranking patches basedon their probabilities of being correct i.e.
exercising only thehigh priority patches that are likely to be correct.
given a user specified time budget the solution space l ois thus reduced to a subset l prime o prime wherel primeis often selected through a fault localization tool via stress testing with a limited numberof test cases and o primeis selected by adopting a variety of heuristics such as syntactic or semanticcode search statistical analysis symbolicexecution and machine learning .
limitations.
without considering the data and control dependences in a program these patch ranking approaches thatoperate on the entire solution space are still inadequate as theycan be ineffective by often producing no plausible patches atall and imprecise by often producing plausible but incorrectpatches .
in addition increasing the time budget used for fixinga bug may increase the chances for obtaining a correct patch but without any correctness guarantee in the presence of ahuge solution space .
as a result the per bug time budget ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is often set up a s3 hours for heavy testing.
most apr approaches adopt a generic process to repair bugs without distinguishing their types or categories.
thus many repair operations that are unable to repair a particular type of bugs are often generated but to no avail.
for example existing apr tools are ineffective in fixing null pointer dereference aka nullpointerexception npe one of the most common types of java bugs representing .
of all memory bugs in mozilla and apache and over of exceptions in android .
however an apr approach is expected to increase both precision and efficiency by being aware of the bug types e.g.
npe repaired during its fault localization and patch generation.
npe as a representative bug type is very difficult to fix since choosing a right repair statement with a correct repair operation is challenging.
for the npes in defects4j a well known benchmark suite often used for validating apr existing tools hdrepair acs capgen and simfix can only correctly repair and npes respectively after having tried tens of thousands of incorrect patches in hours per bug.
this is because an npe and its bug fixing location can span across multiple functions in large codebases due to a wide variety of programming mistakes including missing null pointer checks and object initialization resulting in possibly infinite many repair operations at a large number of suspicious statements .
insights .static analysis is relatively unexplored for automated program repair.
this paper aims to make one step forward in investigating how to apply static value flow analysis which resolves both the data and control flow of a program to help apr generate a precise solution space by increasing the number of correct patches generated for repairing npes.
figure gives a real npe from jfreechart to demonstrate how we can avoid a plausible but incorrect patch due to an imprecise l prime and an implausible patch due to an imprecise o prime if the data and control flow information is considered.
when obtaining l prime the spectrum based fault localization tools usually record the execution traces for successful and failed test cases and then contrast the two types of traces by ranking the frequently executed statements that trigger a bug .
due to limited test cases this coarse grained selection usually produces an imprecise l primesince some l l prime may not represent a correct repair location .
in figure markers may be null in both branches lscript4and lscript6.
however there is only one test case that triggers the bug at lscript8 with l prime lscript2 lscript3 lscript4 lscript8 containing the executed statements along theifbranch but without the unexecuted ones lscript5 lscript7 along theelse branch and lscript9 lscript12.
all the statements in l primeare given the same priority to produce a fix.
however applying a fix at any statement other than lscript8will always generate an incorrect patch since the unexecuted lscript6may also introduce an npe at lscript8.
for example placing a fix after lscript4will generate a plausible but incorrect patch as highlighted in yellow.
when obtaining o prime existing approaches which ignore data and control dependences often value flow graph step step 2step applying value flow aware repair ops selecting and ranking repair locationsa buggy program test cases selected locations candidate patches validation succeedsfails a correct patchvalue flow analysis patch generationcongestion calculationdynamic slicing candidate statements applicable operationsstep step step 3step ep 1vfix constructing a value flow graph fig.
the workflow of vf ix.
generate incorrect repair operations that either fail to pass a test case or introduce new bugs.
for example a skip operation is often applied resulting in a null pointer check added highlighted in gray in figure to bypass the crash point at lscript8.
however removed which is only initialized at lscript8 is used later at lscript9.
thus this lscript8 bypassing skip operation will cause an undefined behavior at lscript9 failing on some test cases.
by considering the static value flow information we can generate a correct fix same as the manual fix in green that never accesses such an undefined variable by also avoiding hundreds of attempts made by e.g.
dependence unaware repair .
our solution .this paper introduces vf ix a new valueflow guided apr approach to fixing npes by considering a substantially reduced solution space in order to increase the number of correct patches generated.
vf ixenhances apr by incorporating with data and control dependence information making it possible to identify bug relevant repair statements more accurately and generate more correct repairs than before.
vf ixis complementary to existing apr approaches which operate on an already reduced solution space s prime l prime o prime c prime i prime x prime v f ixwill operate on a different one svf lvf ovf cvf ivf xvfto improve precision and efficiency by including more correct patches and less incorrect ones from the entire solution space s l o such that svf lessmuch s prime cvf greatermuch c prime and ivf xvf lessmuch i prime x prime .
figure gives an overview of vf ix.
a test suite for a given npe bug contains one failing test case with several npetriggering test cases for the same bug conceptually treated as one .
for the npe triggering test case given vf ixfirst constructs an inter procedural value flow graph vfg a static value flow slice of the program to capture all the potential npe triggering sources and other related npe crash sites.
then we formulate our fault localization problem by first identifying the set of suspicious statements lvf as a portion of the static slice dynamically executed by the npe triggering test case and then rank them by solving a graph congestion calculation problem on the static slice .
given a repair location vf ixfinally produces a precise set of value flowaware repair operations ovf by filtering out repair templates or their sub templates doomed to yield incorrect repair operations based on the dependence constraints established.
in summary we make the following main contributions we propose vf ix a value flow guided apr approach to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
main ... object obj if cond1 obj this .fs.get ... else obj this .bs.get ... ... if obj!
null our fix object x obj if cond2 gtcc x if cond3 gtci x ... void gtcc object x x.bar void gtci object x x.bar executed statement unexecuted statement crash pointentry main if cond1 x obj if cond2 ... exit main1 obj this .bs.get ... 9obj this .fs.get ... gtcc x x.bar1 if cond3 gtci x x.bar2 executed statement unexecuted statementreturn callcall return4 executed value flow unexecuted value flow sliced value flow graphpath path path path congestion d congestion calculation selected repair location skipped statements a a buggy program b inter procedural cfg c v alue flow graph e repair operation fig.
a motivating example.
precisely and efficiently fixing npe bugs by considering a substantially reduced solution space in order to increase the number of correct patches made.
we formulate our fault localization problem by first identifying the suspicious problems based on static valueflow analysis and dynamic execution and then rank them by solving a graph congestion calculation problem.
we have evaluated vf ixagainst a set of eight existing apr tools in terms of their ability in fixing the npe bugs indefects4j .v f ixis more effective by correctly fixing 3x as many bugs as the most precise one s imfix bugs by vf ixvs.
bugs by s imfix and more than all the bugs correctly fixed by these eight tools altogether.
in addition vf ixis also more efficient by producing a correct patch in minutes instead of hours on average.
for out of the correctly fixed bugs vf ix fixes each bug by generating only one patch in a singlepass validation.
to further validate the effectiveness of vf ix we also evaluate vf ixusing another set of npes in four open source apache projects.
vf ixhas successfully repaired npes with the fixes that are semantically equivalent to the developers fixes.
ii.
a m otiv a ting example we use a program in figure to explain the three steps of vf ix figure .
in figure a there is an npe at lscript16 where xisnull adapted from the real npes in jfreechart .
the inter procedural cfg in figure b highlights the set of executed statements in gray ldyn lscript2 lscript3 lscript4 lscript8 lscript9 lscript10 lscript16 by a test case that triggers the npe as obj null after lscript4on retrieving a non existent element from a map.
vf ix is able to generate exactly the same bug fixing patch as the developer s fix highlighted in lscript7and lscript13 as follows step constructing a value flow graph.
for the crash site at lscript16 v f ixbuilds an inter procedural value flow graph vfg which is essentially a static value flow slice gsta lsta e sta shown in figure c where lsta lscript4 lscript6 lscript8 lscript10 lscript12 lscript16 lscript19 .
the nodes identified by line numbers in lstarepresent variables and their edges capture their def use relations.
apart from lscript4 the source for triggering the npe at lscript16 lstaalso includes another potential source lscript6 for this npe and a second potential crash point lscript19.
step selecting and ranking repair locations.
this amounts to solving a fault localization problem.
given ldyn andlsta v f ixcollects the suspicious statements on the dynamic slice lvf ldyn lsta lscript4 lscript8 lscript10 lscript16 which is a portion of the static slice executed by the bug triggering test case.
vf ixthen ranks these statements by solving a value flow congestion calculation problem on gsta.
the intuition behind is to apply a repair operation to the most likely correct location in order to avoid also some npes that are not triggered by the given test suite thus eliminating plausible but incorrect patches.
as illustrated in figure d vf ixcalculates the congestion value of each lscript lvfonlstaby enumerating all the paths from the sources in lscript4 lscript6 to the sinks in lscript16 lscript17 on the vfg figure c .
thus lscript8 which has the highest congestion value is selected as the first repair location.
step applying value flow aware repair operations.
vf ixgenerates the repair operations for a repair statement based on the value flow information to increase their success rate .
for lscript8selected vf ixconcludes that lscript10and lscript12are dependent on lscript8and thus adds a null pointer check that encompasses lscript8 lscript12 as illustrated in figure e delivering a very first patch that is identical to the manual fix.
vf ixfixes the npe bug in this example by selecting precisely a repair location and a repair operation.
without our value flow analysis either lscript4or lscript16will likely be selected as a repair location.
thus another potential npe triggering source lscript6is ignored producing a plausible but incorrect patch.
iii.
a pproach we describe vf ix s three steps for constructing static valueflow slices section iii a selecting and ranking repair loca514 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
s stmt p q p q.f p.f q p newt p null return mp p q.m r r p q ptrf field t class a a prime objm method lscript lscript prime lscript prime prime label a a tiny java like language rule statement lscript def use information null asgn p null lscript defp newasgn p newt lscript defp copy p q lscript defp lscript useq load p q.f lscript defp lscript useq a pts q lscript usea.f store p.f q lscript useq lscript defa.f a pts p lscript usep lscript usea.f call p q.m r lscript defp lscript useq ri r lscript useri mtdentry m r ri r lscript defri ret return mp lscript usep lscript defpintradu lscript lscript prime p lscript prime usep lscriptp lscript prime lscript defa.fintradu lscript lscript prime a.f lscript prime usea.f lscripta.f lscript prime m prime dispatch a m lscript p q.m r a pts q lscript prime m prime r prime lscript prime prime retm primep prime lscriptq lscript prime ri r lscriptri lscript prime lscript prime primep prime lscript lscript defa.finterdu lscript lscript prime a.f lscript prime usea.f lscripta.f lscript prime b intra procedural def use information statement wise def v use v c v alue flow edges denotes the set of definition use statements for a variable v fig.
v alue flow graph construction.
tions based on static value flow slices section iii b and determining value flow aware repair operations section iii c .
a. constructing static v alue flow slices given a buggy program with one npe crash site vf ix builds an inter procedural value flow graph vfg gsta lsta e sta a directed graph that captures all the potential npe triggering sources and other related npe crash sites wherelstais the set of nodes representing statements and esta is the set of edges representing their def use relations.
figure a gives a tiny java like language.
global variables and static methods are handled in the standard manner.
figure b lists the intra procedural def use information of a variable or field extracted directly from a statement.
for an ull asgn n ewasgn or c opy statement its def use information is directly read off.
for a l oad or s tore the def use information for the objects indirectly accessed must also be considered.
here pts v denotes the points to set of vobtained from a demand driven context sensitive pointer analysis .
at a s tore a weak update is assumed .
for a method call c all m tdentry and r et the def use information for variables is directly available.
figure c gives the rules for building the value flow edges between two statements.
to keep track of the intraprocedural value flow for variables and fields respectively and find the intraprocedural definition sites lscriptof a variable or field from its use site lscript primeviaintradu definition .
and handle the inter procedural value flow for variables and fields respectively.
in the inter procedural def use relations for variables are obtained directly via parameter return passing.
in illustrated in figure the inter procedural def use relations for fields are obtained via interdu definition .bar p.f ... zot zot foo ... foo ... q.f ... a.f ptsp a a ptsq a fig.
an inter procedural value flow for field a.f.
definition intra procedural def use .intradu lscript lscript prime v wherevis a variable or a field represents a def use relation for vfrom lscriptto lscript primeon an intra procedural control flow path pwith no redefinition of xin between i.e.
lscript prime prime p lscript prime prime defv.
definition inter procedural def use .interdu lscript lscript prime a.f represents a def use relation for a.f from lscriptto lscript prime with both in two distinct methods on an inter procedural control flow pathp which is discovered context sensitively with no redefinition of a.f in between i.e.
lscript prime prime p lscript prime prime defa.f.
example .
figure shows a value flow for a.f across bar zot andfoo via the two callsites lscript3and lscript5.
here a.f is defined at lscript2 p.f ..inbar and used at lscript7 .. q.f infoo wherep.f andq.f are aliases since pts p pts q a on the inter procedural control flow path lscript2 lscript3 lscript4 lscript5 lscript6 lscript7 with no redefinition of a.f.
letp.use be an npe crash site where pis null.
we obtain its static value flow slice gsta lsta e sta by solving gi fvfg gi iteratively starting with g0 p until a fixed point is reached where fvfgconsists of applying the rules in figure c to add first all the direct and indirect defs of the variables or fields in gitogiand then all the direct and indirect uses of the variables or fields in gitogi.i ti s understood that fvfgincludes the statement for a variable or field under consideration in gi.
b. selecting and ranking repair locations letldyn be the set of statements executed by the npetriggering test case.
to fix this bug it suffices to consider only authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
source node sink node a b c d ef g h i vfsource sink vf path a e a b c d e a h a b c h a i a b c d i f h f g c h f e f g c d e f i f g c d i a gsta lvf a b c d e b vf paths congestion value rank a b c d ecandidate locations c ranks fig.
an example for ranking repair locations.
the repair statements in the dynamic slice lvf ldyn lsta i.e.
the portion of the static slice lstadynamically executed.
vf ixthen ranks the repair statements in lvfby solving a congestion calculation definition problem on gsta.
the intuition behind is that a repair location with a higher congestion value has a better chance to avoid also the other related potential npe bugs that are not discovered by the npetriggering test case thus reducing more effectively the number of plausible but incorrect patches generated.
definition .
givengstafor a npe bug an lscripts lscripttvf path denoted vf path lscripts lscriptt is a simple path with no repeated cycles such that lscriptsis a source and lscripttis a sink in gsta.
for a fixed source sink pair lscripts lscriptt vf path set lscripts lscriptt is the set of all lscripts lscripttvf paths.
the congestion value of a node lscriptin vf path set lscripts lscriptt is given byn lscripts lscriptt lscript vf path set lscripts lscriptt wheren lscripts lscriptt lscriptis the number of lscripts lscripttvf paths that passes through lscript.
the congestion value of a node lscriptingstais given by summationtext lscripts src summationtext lscriptt snkn lscripts lscriptt lscript vf path set lscripts lscriptt .
vf ixthen ranks the statements in lvfin the non increasing order of their congestion values calculated for gstabased on the definition above.
a reverse topological order in gstais used as a tie breaker with the statements in the same strongly connected component scc being ranked arbitrarily .
ingsta a source node can be p null or return null a potential source for causing a null dereference and a sink node can be a potential point for triggering a null dereference.
example .
figure illustrates how to select and rank repair statements.
for gstagiven in figure a we assume that lvf a b c d e .
figure b displays its vf paths.
figure c ranksa b c d andebased on their congestion values.
finally algorithm is used to rank the candidate statements inlvf.
in actuality it is only necessary to compute the congestion value for a repair statement in lvfin line .
c. applying v alue flow aware repair operations we first discuss our npe bug model and then introduce the repair templates used for fixing npe bugs.algorithm ranking repair locations input gsta lsta e sta a static slice lvf a set of repair statements output a linear ordering of the repair statements in lvf 1function rankingrepairlocations gsta l vf 2g prime sta l prime sta e prime sta gstawith all sccs collapsed let src prime stabe the set of source nodes in g prime sta let snk prime stabe the set of sink nodes in g prime sta foreach lscript l prime stado foreach lscripts lscriptt src prime sta snk prime stado n lscripts lscriptt lscript number of lscripts lscripttvf paths that passes through lscripting prime sta vf path set lscripts lscriptt set of lscripts lscripttvf paths ing prime sta c lscripts lscriptt lscript n lscripts lscriptt lscript vf path set lscripts lscriptt end c lscript summationtext lscripts src prime sta summationtext lscriptt snk prime stac lscripts lscriptt lscript end 13define a linear ordering of the statements in lscript prime l prime sta greatermuchc in increasing order of their congestion values c lscript by breaking ties with a reverse topological order 14replace each scc lscript1 ... lscriptn l prime stain greatermuchcby lscript1 ... lscriptn where lscripti lsta in any arbitrary order 15return greatermuchcrestricted to the statements in lvf npe bug model the majority of the npe bugs that happen at a crash site v.use in real world programs arise in two scenarios vis not initialized on some path leading tov.use and a null check for v.use is missing e.g.
when retrieving an element that may not exist in a map as in figure .
these two sources of npes are also acknowledged elsewhere in developing repair templates .
in this paper we focus on repairing these two kinds of npe bugs by assuming call graph integrity i.e.
that api calls are invoked correctly and type integrity i.e.
that variables are typed correctly in their declarations .
in section iv f we discuss some npe bugs caused due to such integrity violations.
repair operations for the npe bugs considered we summarize all candidate repair operations based on two repair templates i.e.
initialization and skip which are also used by some existing apr tools .
the initialization template aims to initialize a null pointer by assigning a newly created object while the skip template aims to avoid executing an npe triggering statements and other related ones.
in this paper we focus on how to use these two templates efficiently and precisely under vf ix our value flow analysis framework.
vf ix as discussed in section i operates on the solution spacelvf ovf wherelvfis the set of repair statements identified in section iii b and ovfis the set of repair operations defined in figure .
there are two sets of rules.
the set of rules in figure a is responsible for extracting the candidate variables or fields from a repair statement in lscript lvf that may participate in a repair operation for lscript.
the set of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
lscript p null lscript src vf lscript p vf lscript p q lscript snk vf lscript p q vf lscript return null lscript src vf lscript vf lscript returnp lscript snk vf lscript p vf lscript p q.f lscript snk vf lscript p q vf lscript p.f q lscript snk vf lscript p vf lscript p q.m r lscript snk vf lscript p q vf lscript p q.f lscript int vf lscript p q.f vf lscript p.f q lscript int vf lscript p.f q vf lscript p q.m r lscript int vf lscript p q.m r vf a identifying the candidate variables or fields in a repair statement lscript lvffor repairing lscript lscript x y vfy negationslash c y null lscript prime y newt lscript if c lscript prime lscript lscript x vf lscript null lscript prime x newt lscript return null lscript prime return new t lscript lscript prime fsl lscript lscript lscript x y vf lscript snk vfx negationslash lscript prime prime usey lscript prime primepdom lscript c y null lscript prime x newt lscript if c lscript prime else lscript lscript x y vfy negationslash lscript negationslash return c y!
null lscript if c lscript fsl lscript lscript lscript1 lscriptn n lscript x y vfy negationslash lscript prime fsl lscript lscript prime return c y!
null lscript if c lscript lscript1 lscriptn lscript x y vfy negationslash c y null lscript prime returnrr newt null epsilon1 lscript if c lscript prime lscript b generating a repair operation for lscript lvf lscript lscript primedenotes the code transformation from lscriptto lscript primeandfsl lscript is a forward slice of lscript fig.
rules for applying value flow aware repair operations.
rules in figure b generates the repair operations in ovfby using six npe repairing templates with three refined from the initialization template and the three from the skip template.
let us first consider the rules in figure a .
as lvfis a portion of gstarestricted to those dynamically executed by the npe triggering test case denoted gvf src vf snk vfand int vfrepresent the set of source sink and intermediate nodes ingvf respectively.
in particular snk vfis a singleton containing the npe triggering statement.
for each repair statement lscript lvf we collect lscript x y vf wherexandyappear in lscript to indicate that ymay be null on entry of lscriptandx may be null or undefined when lscript snk vf on exit of lscript.
and are self explanatory where lscript srcvfand lscript snkvfare redundant.
for a load lscript p q.f store lscript p.f q or call lscript p q.m r there are two rules each depending on whether lscriptis the actual npe crash site or not.
let us now examine the six npe fixing templates given in figure b in greater detail.
due to the value flow information collected figure b we can now apply a template when some value flow constraints are satisfied thereby filtering out a particular incorrect template and consequently all the incorrect repair operations instantiated from it.
a initialization there are three templates and which serve to assign a new object to a potentially null pointer a variable or field .
currently when generating an object initialization statement v newt the public default constructor if available in class t wheretis the declared type ofvor a subtype is used as in .
in future work other non default constructors can be considered similarly.
according to the premises of these templates applies to the statements handled by and applies to the statements handled by and and applies to the statementshandled by and .
in a symay be null we perform an initialization for yguarded by a runtime null check for y. in where a repair statement is null or return null we simply add the missing initialization.
in where a repair statement lscript a load or a call suffers from a null dereference when y null causing the result in xto be undefined we add an initialization of x guarded again by a runtime null check for yand also skip lscript.
however we will only do so when lscript prime prime usey lscript prime primepdom lscript holds i.e.
when ydoes not have any post dominant use in useywith respect to lscript.
otherwise the repair operation for lscript will likely be incorrect even plausible.
if xis of a primitive typet thent returns the default value for tas in c .
b skip there are also three templates and which each insert a null check at a repair location to skip the statements affected by the null dereference.
these three rules apply to all the statements except for p null and return null which are handled by .
in both and fsl lscript represents the traditional forward slice computed at lscript.
in a symay be null at a repair statement lscript we skip lscriptwith a null check y!
null when fsl lscript lscript .
in we skip multiple statements that depend on a repair statement lscript when fsl lscript lscript lscript1 ... lscript n negationslash lscript .
if lscript lscript1 ... lscript nare not consecutive we choose to skip the smallest code region encompassing these statements.
in we skip all the statements starting from lscript in the method mcontaining lscript by returning nothing epsilon1 i fm s return type is void o r newtiftis primitive as discussed for or one in newt null iftis a class.
in the case of multiple repair operations available at a repair statement from both an initialization template and a skip template the skip template will be tried first reflecting how such templates are used in real world bug fixing scenarios.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i npes in defects4j project description kloc bug ids npes chart plotting software lang java utility math mathematics lib time calendar system total example .
let us revisit figure to select the repair operations for the statement at lscript8 the npetriggering site.
by we obtain lscript8 removed markers vf.
the skip templates are considered first.
as fsl lscript8 lscript8 lscript9 lscript10 lscript11 contains lscript11 areturn statement applies giving rise to the correct path shown in figure .
without our value flow analysis may be tried resulting in the implausible patch also shown in figure .
thus vf ixcan successfully avoid many incorrect repair operations thereby reducing the search space.
iv .
e v alua tion our objective is to show that vf ixcan significantly outperform the state of the art for repairing npe bugs in terms of both precision and efficiency i.e.
the time spent on generating a correct patch .
by comparing vf ixwith a set of eight representative apr tools in fixing all the npe bugs in defects4j version .
.
we find that vf ixcan correctly repair 3x as many npes as the most precise one s imfix bugs by vf ixvs.
bugs by s imfix and more than all the npes correctly fixed by all the eight apr tools together.
in addition we have also validated the effectiveness of vf ixusing another set of npes in open source apache projects vf ixhas successfully repaired npes by generating the fixes that are semantically equivalent to the developers fixes.
vf ixrepairs out of these npes in about minutes i.e.
under seconds per bug on average.
a. implementation we have implemented vf ixin soot in about .
kloc of java code with our value flow analysis performed in its jimple ir.
given a program with a test suite consisting of one npe triggering test case vf ixrelies on soot s builtin cfgs and call graph to construct its static value flow slice lstaby using the rules in figures b and c .
the points to information required is discovered by using a demand driven context sensitive pointer analysis .
gzoltar is used to obtain an execution trace ldynfor the program under the npe triggering test case.
lvf lsta ldynthen contains all the repair statements localized.
to generate patches we use javaparser to parse analyze and transform the source code.
b. experimental setup we use two sets of benchmarks.
table i lists the four out of the five projects in defects4j version .
.
a bug database widely used by the program repair community.
note that closure compiler is excluded due to the lack of a standard junit testing format.
there are npe bugs table ii npes in apache projects project description kloc bug ids npes pdfbox pdf library felix osgi platform collections collection handling sling web framework total with in chart 5i n lang 3i n math a n d0i n time .
we have selected this version since the experimental results from many existing tools for it are available.
table ii lists the four large open source apache applications with also a total of npes pdfbox felix collections and sling .
we have selected these npes from their bug repositories since they have npe triggering test cases with the correct patches accepted by developers.
for each of these npes we use the test suite provided for the class where the bug resides which includes one npe triggering test case.
our experiments were done on a machine with an intel core i5 .
ghz cpu and 4gb memory running ubuntu .
operating system with jdk .
.
with the maximum heap size of java virtual machine set as gb.
each program was run five times and the average is reported in our evaluation.
c. precision and efficiency following we adopt a relatively strict definition of correctness for a patch.
a patch is correct iff it passes all the test cases in the test suite and is also semantically or syntactically equivalent to a human written patch.
we compare vf ixwith eight representative apr tools seven general purpose ones jgenprog jkali n opol acs c apgen hdr epair and s imfix and one specialized for npes npef ix .
the results of the first seven tools are taken from their papers.
the time budget per bug is minutes for c apgen and hdr epair minutes for jgenprog jkali and n opol minutes for s imfix and minutes for acs.
figure compares vf ixwith these apr tools in terms of each tool s capability in generating correct patches for the npe bugs in defects4j .v f ixoutperforms these tools by correctly repairing out of the npe bugs.
vf ixvs.
general purpose apr tools among the seven general purpose apr tools s imfixis the best in terms of the number of correct patches generated repairing out of the npes with one plausible but incorrect patch and implausible patches produced.
c apgen and acs each fix two npes.
n opol and jkali produce some plausible patches which are all incorrect.
vf ixfails to generate correct patches for three npes as discussed further in section iv f. in comparison with these general purpose apr tools vf ixhas successfully repaired six out of the npe bugs exclusively.
vf ixvs.npef ix npef ix an apr tool developed to repair npe bugs can generate plausible patches but with only two being correct.
when fixing a npe bug npef ix considers only the npe triggering test case while ignoring the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
chart lang math npefix jgenprog jkali nopol acs capgen hdrepair simfix vfix correct plausible but incorrect implausible fig.
comparing the correctness of the patches generated by vf ixand eight existing representative apr tools for defects4j .
the numbers across are the bug ids corresponding to column in table i. only the applications containing npes i.e.
chart lang andmath are included here.
others in the test suite.
this renders npef ixvulnerable to over fitting with simple plausible yet incorrect patches such as randomly replacing a null pointer with a non null pointer.
thus the majority of its patches are incorrect confirmed by manual inspection because they either introduce new bugs or significantly alter the program logic.
vf ixvs.
runtime recovery tools instead of providing correct patches for bugs including npes some tools such as append rcv and ares aim to prevent crashes in order to continue program execution.
these tools seek a temporary recovery solution in a short time rather than repeatedly generating and validating patches against a test suite.
to compare with append we have written the patches for the npes in defects4j by following its recovery policy i.e.
calling a default constructor or skipping the null dereference if the default constructor is unavailable .
only two bugs lang andlang are fixed correctly.
vf ix s patch generation table iii analyzes vf ix s efficiency and precision in repairing the npes across the projects with a minute time budget per bug.
vf ixrepairs a bug in three steps steps as shown in figure .
forchart math pdfbox andmath vf ixtimes out in step marked as oob .
if these four npes are included vf ixtakes seconds .
minutes in repairing the npes with .
.
and .
in steps respectively.
otherwise vf ixtakes seconds .
minutes in repairing the remaining npes with .
.
and .
in step s1 respectively.
for the npe bugs vf ixhas successfully generated patches for npes in which are correct and two are incorrect giving a precision of .
.
the high precision confirms the effectiveness of our value flow analysis.
in addition vf ixis also efficient as the first patch is correct in out of correct fixes.
this fast and precise patch generation is attributed to the value flow aware repair operations used.
for the four npe bugs mentioned above however vf ixstill fails to generate plausible patches within the time budget.table iii analyzing vf ix s patch generation for repairing the npes across the projects with a minute time budget per bug .
oob denotes out of budget.
a breakdown of the times for its three steps figure is given.
a green red box marks a correct incorrect patch while a white box marks a bug for which no plausible patch is generated.
bug idtime secs n th patch passing testcorrectnessstep step step total chart oob oob chart chart chart chart chart chart lang lang lang lang lang math math math oob oob felix felix collections collections pdfbox pdfbox pdfbox oob oob pdfbox pdfbox oob oob pdfbox pdfbox pdfbox pdfbox sling sling total with oob w o oob fig.
the percentages of the number of repair statements inlvffound by vf ixover the total number of suspicious statements reported by the fault localization tool gzoltar for the npes in defects4j fixed by vf ix with chart lang andmath abbreviated to c l and m respectively .
d.vf ix s refined solution space we provide some insights on why and how vf ixachieves high precision and efficiency by refining its solution space lvf ovfusing value flow analysis.
we consider the npes indefects4j that are fixed by vf ix as shown in table iii.
figure shows that vf ixhas achieved an average reduction of .
by moving away from the space of suspicious statements selected by a general purpose fault localization tool gzoltar to lvf.
by leveraging the value flow information for an npe triggering site vf ixavoids many irrelevant repair authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
the number of repair templates instantiated at each bug fixing statement with and without value flow analysis for the npes in defects4j fixed by vf ix with chart lang andmath abbreviated to c l and m respectively .
locations that would otherwise be selected by such bug typeunaware spectrum based fault localization techniques.
figure shows how vf ixhas significantly reduced the number of repair operations in ovfby comparing the number of repair templates instantiated with and without our valueflow analysis at a statement where a correct fix is made.
in the absence of value flow information all six templates given in figure are used.
by exploiting the value flow information vf ixhas cut this down to .
resulting in a reduction of .
on average avoiding unnecessary repair operations tried and boosting the efficiency of patch generation.
e. case studies we conduct two cases studies in defects4j to show how vf ixrepairs intra and inter procedural npes precisely and efficiently within a reduced solution space svf lvf ovf.
figure a shows an npe bug chart and its patch generated by vf ix.
the bug happens in lscript4494 where r can be null.
vf ixadds a null check in lscript4493 and lscript4452 to encompass lscript4494 lscript4451 in an if branch by .
by manual inspection we found that this patch is identical to the one committed by developers.
the challenge here lies in determining the end of the scope for the if branch.
closing it too early e.g.
right after lscript4494 would leave some variables that are data dependent on the skipped statements to be undefined e.g.
cin lscript4495 andain lscript4499 .
closing it too late would introduce unnecessary control dependencies on the if statement added in lscript4493 potentially altering the program logic.
without value flow analysis one would have to blindly enumerate all possible mutations at a statement in order to find a correct fix which is computationally impractical.
with valueflow analysis resulting in a precise ovf v f ixcan correctly identify the scope of the inserted if branch by .
figure b illustrates another npe bug chart repaired by vf ix.
this bug happens in lscript574 as this.category is not initialized in lscript207 in the constructor defautlintervalcategorydataset ... .g i v e n lscript574 gstabuilt by vf ixcontains not only lscript574 but also lscript690 another potential npe crash site.
for the given npetriggering test case lvfcontains lscript208 and lscript574 but not lscript690 as it is not executed .
vf ixfinds the correct patch which4493 if r !
null collection c r.getannotations iterator i c.iterator while i.hasnext xyannotation a xyannotation i.next if a instanceof xyannotationboundsinfo includedannotations.add a a an npe chart correctly repaired with a precise ovf 691defaultintervalc ategorydataset ... ... this .categorykeys null this .categorykeys new comparable ... public int getcategoryindex ... for int i i this .categorykeys.length i ... ... public int getcolumncount return this .categorykeys.length b an npe chart correctly repaired with a precise lvf fig.
two case studies in defects4j with the patches generated by vf ixshown by anf .
initializes this.category in lscript208 by .
this patch can be obtained only if the inter procedural value flow information is available.
in addition our ranking algorithm which prioritizes the repair statements lvfprecisely by their congestion values is also instrumental here.
as gstacontains both lscript574 and lscript690 lscript208 is ranked ahead of lscript574 enabling vf ixto generate the correct fix in lscript208.
otherwise adding the same fix just before lscript574 is only plausible but incorrect as it fails to fix the other npe crash site in lscript690.
f .
discussions in this paper we investigate how to apply value flow analysis to boost the precision and efficiency of apr.
while we focus on fixing npes the most common type of java bugs our approach can also be effective in fixing other types of bugs such as use after free and memory leaks in c c programs.
in practice a test suite provided for a bug report may not be comprehensive enough to enable the bug to be fixed.
this paper shows that we can mitigate such deficiency by augmenting a test suite with static value flow analysis.
currently vf ixfocuses on repairing a class of commonly occurring npe bugs under the assumptions that call graph integrity and type integrity are preserved section iii c .
however an npe can occur when a wrong api is called resulting in a call graph integrity violation.
for example fixing math indefects4j would require return solve min max to be replaced by return solve min max so that fbecomes correctly initialized.
in addition an npe can also occur due to an integer overflow caused possibly by a type integrity violation.
for example fixing the npe bug math indefects4j would require the declared type of sum anddp in method distance of class mathutils to be changed from int todouble .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
going beyond our current bug model will be an interesting research topic.
v. r ela ted work a. automated program repair existing apr approaches can be broadly classified into two categories general purpose approaches which can be theoretically applied to all kinds of bugs and bug specific approaches which are designed for specific types of bugs.
general purpose approaches are based on search algorithms or driven by semantics preserving transformations.
search based approaches typically adopt a generate and validate process that generates candidate patches by exhaustively exploring the solution space using for example genetic programming or random search and then validates the patches with a test suite.
in practice the large search space hinders their efficiency and scalability.
therefore much research has been devoted to developing effective heuristics and repair templates for narrowing down the scope and guiding the search to generate correct patches efficiently.
for example ae reduces the search space by merging semantically equivalent patches.
p rophet uses machine learning techniques to guide patch generation by learning from correct patches.
capgen leverages the context information extracted from a program s ast to achieve fine grained patch prioritization.
par summarizes common fix patterns from human written patches and performs the generate and validate process within a domain confined by these patterns.
acs focuses on synthesizing branch conditions ranking patches by analyzing documents predicate statistics and dependencies relations between variables.
semantics driven approaches represent another class of program repair techniques which view a repair task as a program synthesis problem and synthesize patches via constraint solving.
as evaluated in section iv existing general purpose approaches are only marginally effective for repairing npes.
bug specific apr techniques restrict their scope to some types of bugs only.
for example f oot pat c h fixes bugs related to heap memory properties by employing separation logic to reason about pointer semantics.
m emfix considers memory deallocation errors e.g.
memory leaks doublefree and use after free bugs using static analysis.
there are also others focusing on buffer overflows integer overflows memory leaks error handling bugs and concurrency errors .
the work that is the most closely related to ours is npef ix which generates patches for npes by capturing runtime information with dynamic analysis.
in contrast vf ixrepresents a static approach for fixing npes by performing a systematic valueflow analysis to drastically reduce the search space in order to avoid implausible and plausible but incorrect patches.
as evaluated in section iv vf ixoutperforms npef ixsignificantly in terms of both effectiveness and precision.b.
v alue flow analysis understanding the flow of values in a program is fundamental in program analysis .
by explicitly modelling the definition use relations among program variables valueflow analysis enables or enhances a series of crucial tasks including compiler optimization pointer analysis bug detection software debugging and validation and verification .
in recent years for example the potential for value flow analysis has been widely explored in detecting a variety of critical bugs including memory leaks uses of uninitialized variables use after free errors and information leaks .
while many existing approaches track the flow of values iteratively at each program point along the control flow vf ixuses a fully sparse value flow analysis for both variables and fields.
this fullsparsity leads to the efficiency of vf ix.
to the best of our knowledge vf ixis the first approach that exploits value flow analysis to repair npe bugs.
c. mitigations againist null pointer dereferences the npes that cause program crashes can be detected by a variety of testing techniques such as fuzzing and symbolic execution .
to increase coverage static analysis has been investigated.
x ylem for example is a representative static detector that has been shown to be effective in the industry.
there also exist research efforts focusing on verifying the absence of npes using static analysis in both whole program and demand driven settings.
in addition fault tolerance techniques for npes has also been studied .
rcv for example processes the interrupt signals triggered by npes at runtime with its own handlers to allow a buggy program to continue execution.
vf ix as an apr approach can also benefit from a more precise static analysis for its fault localization.
vi.
c onclusion this paper presents vf ix a new value flow guided apr approach for fixing npe bugs by considering a substantially reduced solution space in order to increase the number of correct patches generated efficiently.
we have formulated our fault localiaztion problem as one of solving a congestion calculation problem based on static value flow analysis and dynamic execution trace with respect to a given npe triggering test case.
we have formulated our problem of generating repair operations as one of instantiating repair templates subject to certain value flow constraints.
vf ixis shown to generate more correct patches more efficiently than the state of the art.
in future work we plan to extend vf ixby repairing the types of npe bugs that are not currently covered by our bug model.
we also plan to generalize our value flow analysis approach to repair other non npe bugs.
vii.
a cknowledgments we would like to thank the anonymous reviewers for their valuable comments.
this research is supported by australian research grants dp180104169 and de170101081.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.