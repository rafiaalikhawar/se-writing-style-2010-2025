cimplifier automatically debloating containers vaibhav rastogi drew davidson lorenzo de carli somesh jha patrick mcdaniel university of wisconsin madison tala security colorado state university pennsylvania state university vrastogi wisc.edu drew talasecurity.io ldecarli colostate.edu jha cs.wisc.edu mcdaniel cse.psu.edu abstract application containers such as those provided by docker have recently gained popularity as a solution for agile and seamless software deployment.
these light weight virtualization environments run applications that are packed together with their resources and configuration information and thus can be deployed across various software platforms.
unfortunately the ease with which containers can be created is oftentimes a double edged sword encouraging the packaging of logically distinct applications and the inclusion of significant amount of unnecessary components within a single container.
these practices needlessly increase the container size sometimes by orders of magnitude.
they also decrease the overall security as each included component necessary or not may bring in security issues of its own and there is no isolation between multiple applications packaged within the same container image.
we propose algorithms and a tool called cimplifier which address these concerns given a container and simple user defined constraints our tool partitions it into simpler containers which i are isolated from each other only communicating as necessary and ii only include enough resources to perform their functionality.
our evaluation on real world containers demonstrates that cimplifier preserves the original functionality leads to reduction in image size of up to and processes even large containers in under thirty seconds.
ccs concepts security and privacy software security engineering software and its engineering software maintenance tools keywords containers debloating least privilege privilege separation acm reference format vaibhav rastogi drew davidson lorenzo de carli somesh jha and patrick mcdaniel.
.
cimplifier automatically debloating containers.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
introduction containers are light weight virtualization environments to contain applications and provide desirable properties like isolation resource provisioning and application specific configuration.
with recent projects such as docker containers have become the holy grail for agile system administration an easy and widelysupported specification of an application and its environment that can be deployed across various software platforms.
indeed reports indicate undeniably high rates of docker adoption .
the status quo of application containers does have limitations.
for usability container images often are built as layers upon other container images.
the underlying layers as well as the process of making the images often amasses many resources programs files etc.
unnecessary for running the container.
this not only leads to enormous space requirements a simple python application may for example need mb huge image sizes are a subject of numerous articles and blog posts but oftentimes also have security implications.
a best practice principle in security is theprinciple of least privilege plp which dictates that any module an application process etc.
should be given only privileges that are necessary to perform its functionality.
extraneous resources are available to the application and in an event of a compromise only serve to escalate the possibility of further harm.
for instance high profile vulnerabilities like shellshock cve and imagetragick cve can be mitigated to various extents by removing unnecessary files see section .
.
frequently a container also packs a complex application stack consisting of multiple application components devoted to distinct tasks which goes against the principle of privilege separation ps separating modules with different privileges so that a compromise of one module limits the attacker to only a subset of privileges.
for example in a wiki installation which includes a web server and a database server if both the web server and the database server have unrestricted access to each other s resources a compromise of one component could escalate to the compromise of the other.
placing the two in separate containers offers a way of restricting access.
ideally therefore a container should run only one simple application task and should pack only as many resources as needed to fulfill its functionality requirement .
note that this ideal fits right into current discussions such as the feast workshop organized by the us office of naval research onr at ccs on software de bloating and specialization to improve security and performance of software.
this paper presents the design and implementation of cimplifier pronounced simplifier as a step towards automatically realizing the above stated ideal property.
cimplifier accepts a container and simple succint user defined constraints specifying which executable programs should or should not be run in the same container.
1vulnerabilities with cve identifiers are described on esec fse september paderborn germany v. rastogi d. davidson l. de carli s. jha and p. mcdaniel we use dynamic analysis to understand how resources are used by the application executables in the container and based on the results partition the container while satisfying the constraints.
partitioning happens at the granularity of individual executables i.e.
currently we do not partition an executable .
our output is a set of containers each running one or more executable programs and provided with just the resources needed to execute them.
in addition leveraging the fact that containers share the same kernel space we provide techniques for an application component residing in one container to be able to transparently invoke another component residing in another container so that together these containers provide the same functionality as the original container.
cimplifier does not need application source code nor does it depend on applications using a particular language or runtime stack e.g jvm and hence can handle a wide class of containers.
we evaluated our cimplifier prototype on several real world containers ranging from simple web servers and database engines to complex applications like a wiki a blogging engine and a loganalysis stack.
our evaluation shows that cimplifier is effective in creating functional partitions guided by simple and succinct user defined policies and reducing container size by up to .
our contributions can be summarized as follows resource identification.
we develop techniques based on system call logs to analyze the usage of resources and associate them with various executables in the application container being analyzed.
container partitioning.
we devise an algorithm for partitioning a container based on a simple user defined policy and for associating resources with the components of a partition.
remote process execution.
we introduce remote process execution rpe as a mechanism for gluing components.
our mechanism allows a process running in one container to transparently execute a program in another container without relaxing the separation boundaries provided by containers.
system prototype.
we implemented the above techniques in a prototype implementation called cimplifier which is an end to end system to partition containers and resources.
our tool takes as input a container system call logs and a user policy and outputs partitioned containers each packing only resources needed for functionality.
the rest of this paper is organized as follows section provides the requisite background problem definition and an overview of our approach.
our system design is discussed in section .
we present evaluation results in section .
section discusses related work and is followed by a discussion on limitations and future work in section .
we conclude in section .
overview this section provides the relevant background the problem statement and issues specific to the container ecosystem.
we also provide a brief overview of our solution.
.
background containers are user space instances that share the same os kernel.
the linux kernel implements namespaces to provide user spaceinstantiations.
a namespace is an abstraction around a global resource giving the processes within the namespace the illusion of an isolated instance of the resource.
seven kinds of namespaces are defined in linux ipc inter process communication network mount pid process identifier user uts unix timesharing system allowing separation of hostnames and cgroup described below .
container implementations in linux such as lxc and docker employ the namespaces feature to provide a self contained isolated environment resources that do not have a name in a namespace cannot be accessed from within that namespace.
in addition container implementations use cgroups another linux kernel feature allowing for resource limiting prioritization and accounting.
finally linux capabilities and mandatory access control mac systems such as selinux or apparmor are often used to harden the basic namespace based sandboxing .
besides the implementation of a container itself using the above kernel primitives projects such as docker developed specifications and tools to implement and deploy containers.
for example the files necessary for running applications the application code libraries operating system middleware services and resources packed in one or more archives together with the necessary metadata constitute a container image .
the image metadata include various configuration parameters such as environment variables to be supplied to a running container and network ports that should be exposed to the host.
systems like docker are designed particularly to deploy applications e.g.
web servers and hence are meant to run application containers as opposed to os containers .
in this regard a container may be viewed as an application packed together with all the necessary resources such as files executing in an appropriate environment.
the focus of this work is such application containers and we demonstrate our methodology in the context of docker although our techniques would apply well to other application container systems.
.
problem statement as discussed earlier an ideal container should satisfy two requirements a minimal size it should pack no more resources than what its functionality needs b separation it should execute only one simple application.
apart from the obvious space saving benefit in the event of a vulnerability exploitation such as arbitrary code execution or information disclosure these requirements reduce the harm by limiting access to resources and by confining the exploit s impact to a compartment smaller than the whole application.
furthermore a simple application is easier to harden using systems such as selinux and apparmor and is also more auditable e.g.
using existing static analysis tools such as coverity and fortify than a complex one.
finally running one task per container aligns with the microservices philosophy whereby complex applications are composed of independently running simple applications that are easier to manage and deploy.
in line with the above principles this paper is a step towards automatically decomposing complex application containers into minimal simple containers.
next we provide a running example which will be used at various points in the paper and then state a general form of the container partitioning problem.
477cimplifier automatically debloating containers esec fse september paderborn germany figure running example.
the figure shows the original container with its application components and a desired partitioning of the components into different containers.
running example.
we consider a popular container from the docker hub the official repository for container images called appcontainers mediawiki which provides mediawiki a popular wiki application .
we will discuss its standalone mode which allows running the entire application from just this container.
the container image has apache httpd and mysql server installed.
at startup it performs configuration to set up the mediawiki php source code for use with httpd set up a tls certificate using openssl for serving https connections and start and configure mysql and httpd servers.
httpd and mysql server are separate tasks and should be isolated from each other in different containers.
the mediawiki php code also spawns imagemagick to convert uploaded images to different sizes.
since uploaded images may be maliciously crafted we would like to separate their processing by imagemagick from the rest of the application i.e.
imagemagick should run in a separate container.
the transformation we would like to achieve is depicted at the right of figure .
example vulnerability mitigation.
we present some examples to demonstrate the security benefits of using cimplifier .
in line with our running example we consider cve which is an imagemagick vulnerability that allows arbitrary code execution and information disclosure of any file readable by the current user through specially crafted images.
by limiting imagemagick in its own container and providing minimal resources information disclosure is confined to just the files that actually need to be accessed by imagemagick.
furthermore the arbitrary code execution happens through shell command injection.
if however the imagemagick container does not have a shell nor any other executables arbitrary code execution is reduced to application crash at worst.
such isolation of imagemagick can also reduce possible harm from numerous other vulnerabilities in imagemagick such as cve delete move and read arbitrary files cve buffer overflow with unspecified impact and cve arbitrary shell command execution .
note that some of the above vulnerabilities resemble arbitrary command execution herein referred to as ace whose impact can generally be reduced by minimizing the commands available to the attacker.
shellshock a family of critical vulnerabilities cve2014 and related bugs in the unix bash shell allows the execution of arbitrary shell commands encoded in environment variables.
these and similar recent vulnerabilities in other software e.g.
cve ace in apache james server cve ace in tnftp ftp server cve ace in glibc can all be mitigated to various extents by limiting the available resources.
in the original setup of our running example a compromise of httpd opens up possibilities for compromising the mysql database.
if we separate the web server and the database enginein different containers the avenues of compromising the database become limited to remote attacks only.
thus several vulnerabilities such as cve cve and cve which require a local user are mitigated.
considering another example if a user prepared a container with sudo and mistakenly made it accessible from a web facing application or if the version of sudo is vulnerable e.g.
cve and cve cimplifier can mitigate the risk by simply removing sudo if it will not be executed in a deployed container.
note that the former case is a mis configuration rather than a vulnerability in an application component.
cimplifier can thus also lower the impact of misconfiguration.
container partitioning problem.
abstractly a container cis a set of executables e e1 en .
in the context of our problem the seteis only the set of security relevant executables minor programs and simple utilities should be ignored.
a resource is an entity acted upon by a process which is a runtime instantiation of an executable.
examples of resources are files socket objects etc.
access to a resource can be seen as a privilege reducing access to resources thus means reducing the privileges of a process.
let r c be the set of resources used by the processes of container c. moreover there are two kinds of user specified constraints negative constraints uc e e which must be satisfied and uc e e which should be satisfied as much as possible.
intuitively if ei ej uc then executables eiandejshould notbe put in the same container.
similarly if ei ej uc then it is preferable if executables ei andejare put in the same container.
these constraints are akin to programmer annotations in previous work .
we further discuss specifications of these contraints in section .
.
now the container partitioning problem cpp can be defined as follows given a container cand constraints uc anduc find a set of containers c1 ck where ci e ci cj ifi j and k i 1ci e or in other words c1 ck is a partition of e .
moreover for all ei ej uc eiandejappear in different sets of the partition the number of partitions kis minimized and the number of constraints corresponding to uc is maximized.
note that uc constraints are soft and serve as hints to reduce the number of containers.
in general our problem is np hard.
we consider the decision version of cpp where we ask if there is a partition of size less than a positive integer k .
consider the chromatic number problem given a graph g v e and a positive integer l v is the graph l colorable i.e.
does there exist a function f v l such that f u f v whenever u v e. a reduction from the chromatic number problem to our problem is straight forward.
given a graph g v e letc v uc and uc e. it is easy to see that there is a partition of the set of containers c1 cl such that ei ej uc implies that eiandejappear in different sets of the partition iff the graph gisl colorable.
our problem can solved by encoding it as an integer programming problem.
however our problem sizes are small and we use a simple iterative algorithm in our implementation section .
.
we allow the user to choose the executables that should go into the same container.
while we advocate that a container run a simple application task a user is free to decide which executables possibly more than one form that simple application task.
478esec fse september paderborn germany v. rastogi d. davidson l. de carli s. jha and p. mcdaniel the task of creating partitions also requires associating the requisite resources with those partitions.
it is natural to associate only the necessary resources and so the removal of redundant resources comes for free in a reasonable algorithm.
such reduction of resources is referred to as container slimming .
.
our approach given a container our work partitions it at the level of application executables so an executable binary is one atomic unit that can be placed in a partition.
partitioning at granularities finer than executables is not within the scope of the current work but may be achieved by combining our work with previous work on program partitioning and privilege separation .
container partitioning poses three technical challenges a how do we identify which resources are necessary for a container?
b how do we determine container partitions and associate resources with them?
c how do we glue the partitions so that together they provide the same functionality as the original container?
our approach utilizes dynamic analysis to gather information about the containerized application s behavior and functionality.
we collect detailed logs from executions of a given container.
we use these logs to construct resource sets for different component executables.
based on flexible pluggable policies we determine container partitions.
the resulting containers are populated with the resources needed for correct functioning of the executables.
container mechanisms themselves provide for separation of resources.
based on the resource sets identified we relax this separation to share some resources across containers on an as needed basis.
finally we introduce a new primitive called remote process execution to glue different containers.
it relies on the availability of a shared kernel to allow a process to transparently execute a program in a different container.
our approach is depicted in figure .
while our approach uses dynamic analysis partitioning may also be possible through static analysis.
both approaches have their advantages and disadvantages.
in dynamic analysis resource set identification may not be accurate if code coverage during container executions is not complete.
static analysis does not suffer from this limitation but faces significant challenges in our context in typical containers that we studied application components are written in several languages e.g.
shell script php and compiled c and c the application is strewn across multiple shared object libraries and executables and the content of the environment variables and configuration files dictate an application s runtime behavior.
our dynamic analysis instead stays on the simple well defined system call interface and is more manageable than static analysis.
solutions combining static and dynamic analyses to incorporate the advantages of both will be interesting to investigate in the future.
system design our algorithm has three main steps.
resource identification in this step we identify the accesses of different files ipc and network objects by various processes in executions of the original container.
partitioning this step utilizes the user policies and the results of the previous step to partition the original container into several containers.
gluing finally we glue the containers together we introduce remote process execution as the mechanism to gluecontainers.
this section details these three steps and then covers the security and implementation aspects of our system.
.
resource identification resource identification is the first step in our workflow that enables association of various resources such as file ipc and network objects to the subjects i.e.
the entities that act upon them.
for collecting this information the system call interface serves our purpose well because it allows complete access to the information exchange happening between the user space processes and the kernel.
actual resource access management and so on happens inside the kernel and so a process must make system calls to the kernel to perform any action related to resources.
there are several options for performing system call logging which we discuss in section .
.
our methodology just needs system call logs and does not depend on any specific logging infrastructure.
analyzing system call logs.
let a system call event be defined as a tuple s i c where irepresents the thread id of the caller cis the name of the system call e.g.
open orrename is a sequence of parameters to the system call the last element of this sequence is the return value of the system call .
each system call has an associated type which determines how to interpret a parameter e.g.
whether a parameter should be interpreted as a path or as an integer return code .
a system call logis simply a sequence of system calls.
given a log s1 s2 sm we define jas the state of the system after the sequence of system calls s1 s2 sjis executed we assume an initial state 0 the state tracks for example the current working directory .
note that the event skis executed in the state k .
using the semantics of system calls we can define for each tuple of a system call sand state a pair r w where randware each sets of resources that system callsreads from and writes to respectively when executed in state .
we call this function rsrc i.e.
rsrc s r w .
note that this function can be lifted to a log or its subsequences via the standard collecting semantics.
for example for a log l s1 s2 sm we have that rsrc l is equal to sj lrsrc sj j sj lrsrc sj j in the equation given above jis the state reached from after executing the sequence of system calls s1 sjand rsrcifori is the i th component of the tuple.
these sets play a crucial role in deciding which resources are exclusively associated with a container and which resources are shared between containers.
next we describe how different kinds of resources such as files ipc and network are handled in this framework.
files.
files are handled through numerous system calls but all of them map neatly to the above abstractions.
intuitively a file that must exist for call sito succeed is placed in the read set ri.
creation modification and modification of metadata all result in adding the file to the write set wi.
inter process communication.
there are many inter process communication ipc options available we support an important subset of them.
any ipc that happens without naming a resource such as that through channels created by pipe orsocketpair system calls is implicitly supported in cimplifier .
such ipc typically depends on file descriptor inheritance support for which is described in section .
.
named pipes fifos and unix domain sockets exist as 479cimplifier automatically debloating containers esec fse september paderborn germany resource identificationcontainer partitioningglue insertionnegative constraints httpd mysqld convert initialconfig httpd initialconfig mysqld input containeroutput containerssystem call logsuser constraints glue figure architecture overview.
we analyze system calls from model executions of the input container to identify resources.
the application together with these resources is then partitioned across several containers guided by a user defined policy.
these containers function together through remote process execution rpe which acts as a glue among them.
named resources on the file system and are hence handled similarly to files.
there are other ipc mechanisms such as message queues semaphores and posix system v shared memory that require the participating processes to share the ipc namespace.
hence we require that such processes be placed in the same container.
network communication.
network communication is sometimes used within a container such as by a web server to connect to a backend database server.
we place the socket address specified in thebind connect recv send system calls in the write set.
.
partitioning lete e1 e2 en be the set of executables in a container.
on linux any run of an executable starts with the execve system call the other exec family functions and system andpopen functions ultimately make this system call .
using the semantics of execve we can associate an executable ei eto each system call in the execution log using this information and the result of the resource identification step on the system call log subsequence of ei we can associate a set of resources read and written by an executable.
we next describe our partitioning algorithm.
partitioning algorithm.
lete e1 enbe the set of executables in a container.
with each executable eiwe associate a tuple r ei w ei where r ei andw ei are the resources read and written by ei respectively.
note that given a subset of executables e e the tuple associated with it is e e r e e e w e .
letg e x be a directed graph whose vertices are executables eand the set of edges x e eis such that ei ej xiffei executes ej.
in other words gis the call graph at the executable level.
our partitioning algorithm takes gas an input and does not depend on how it was constructed our implementation constructs it from the execution logs .
letuc e eanduc e ebe the positive and negative constraints provided by the user.
for each executable ei letc ei be the current index of the container in the partition.
our algorithm works in two steps as follows initial partition based on user constraints each executable is in a single container i.e.
c ei i. for each constraint ek ej uc we merge the containers that have ekandei i.e.
we merge the containers c ei andc ej into one container.
note that this can be performed by using a simple re indexing .
however we do not perform a merge corresponding to a constraint in ei ej uc if it will violate any negative constraint uc i.e.
there is ei ej uc such that eiandejwill be in the same container after the merge .
we keep merging containers using this rule until we reach a fix point i.e.
the partition induced by c does not change .
our algorithmmay not result in a global optimum but suffices in practice as the number of constraints and containers are small.
updating the partition based on the call graph intuitively if ei ej x eiexecutes ej then eiandejshould be in the same partition as long as the given constraints are not violated.
for each edge ei ej xwe merge the containers c ei andc ej as long as any negative constraint in uc is not violated.
we keep merging containers based on the call graph until we reach a fix point.
in our partitioning algorithm we have experimented with three types of user defined policies which can be easily specified using our formalism.
all one context.
this policy places all executables into a single container.
thus it does not perform any container partitioning.
however since only the resources accessed during test run are placed in the container this policy is tantamount to container slimming.
this policy corresponds to uc e eanduc .
one one context.
this policy places each executable into a separate container so that no two executables share containers.
while this policy is useful for testing cimplifier it is not practical for reasonably complex containers that may involve tens or even hundreds of executables the container of our running example uses 49different executables including simple utilities like catandtail as well as related executables which together can be considered as one component like httpd.
putting each executable in a separate context is unnecessary in these cases.
moreover in some cases executables may need to remain in the same namespaces.
for example apachectl controls the main httpd process by using its pid if it is placed in a different pid namespace such control will not be possible.
this policy corresponds to uc anduc contains all pairs ei ej such that i j. disjoint subsets context.
in this policy the user specifies disjoint subsets of executables not necessarily covering all executables.
the subsets correspond to different containers.
that is a container corresponding to a given subset contains executables in that subset but in no other subset.
some executables may not have been specified and are considered don t cares they can be placed in any container.
this policy is particularly useful.
in our running example one can specify the httpd related executables in one subset mysqlrelated ones in another and imagemagick related ones in another.
more concretely the policy is specified as convert mysql mysqld init.d mysqld mysqladmin mysqld safe mysql install db httpd init.d httpd apachectl openssl path prefixes omitted for brevity .
other executables such as cat mv and chmod are not considered security sensitive and hence can be placed anywhere as needed.
currently these don t care executables are treated like any other resources and if necessary are 480esec fse september paderborn germany v. rastogi d. davidson l. de carli s. jha and p. mcdaniel duplicated as read only resources are see the following discussion in this section .
given the list of executables our tool can prepare such a list from execution logs a user can come up with the policy in seconds without any expertise the only knowledge we used to create our policy was which applications the executables belonged to and that openssl is used by the container to perform one time configuration of ssl keys for httpd.
resource placement.
to associate resources with containers we call this resource placement we begin with resources read by its executables.
there are some tricky issues that arise here.
for example before placement this read set must be extended to cover all dependencies.
in particular if a file indicated by a given path is placed in a container we must ensure that all the directory components in the path leading up to the file are also placed in the container.
in addition we ensure that the files metadata e.g.
permissions ownership and modification times are preserved.
a resource may need to be placed in multiple containers.
in such a case the nature of resource access determines the placement strategy.
a read only resource can be safely duplicated each container gets its own copy of the resource.
if a resource is modified or created by one or more of the containers it should be shared.
docker provides volumes file mounts that may be shared between containers.
for file resources as well as named pipes and unix sockets we use shared volumes for shared resources.
note that in case a resource is created by a container at runtime and is used by another container the parent directory of the resource must be shared.
this is because docker volumes may only be mounted when a container is started and linux does not allow mounting of non existent files.
sharing parent directories can result in over sharing of resources this compromise appears necessary however as volumes appear to be the only way to share such resources among containers.
for sharing network resources we match socket addresses from the write set according to the socket address specification semantics.
for example the bound listening tcp ip address .
.
.
and the connecting tcp ip address .
.
.
match.
based on such matches we determine the containers that need to communicate over the network and allow the requisite channels with linux kernel level network address translation.
.
gluing the remaining technical challenge in obtaining functional partitioned containers is to glue them together to maintain the original functionality.
our technique to handle this challenge is remote process execution rpe .
rpe transparently allows a process to execute an executable in a container different from the one in which it resides.
by transparency we mean that neither of the two executables caller and the callee need to be modified or made aware of rpe.
returning back to our running example mediawiki uses imagemagick to create thumbnails of uploaded images.
since mediawiki s php code runs in the httpd container and imagemagick corresponding to the convert executable runs in a separate container simply executing convert from php code will fail because the executable file convert does not exist in the httpd container.
we need a technique that allows the php code to execute convert and yet the actual execution of convert should happen along with its resources in the imagemagick container.
in the same figure remote process execution rpe .
the executable e1in container c1executes e2in container c2with our rpe mechanism.
dark lines indicate processes time progresses downwards.
dotted lines indicate socket communication and dashed lines indicate signal and exit code propagation.
running example the need to execute processes in other containers arises elsewhere as well the startup script invokes executables to start the httpd and mysql servers in their respective containers.
in general rpe serves as the fundamental glue primitive among partitioned containers and is crucial for preserving functionality.
our solution works as follows consider the scenario in which an executable image e1in container c1needs to execute another executable image e2that actually resides in container c2.
our solution is to place a stub e 2corresponding to the actual executable e2in container c1.
we also run a server in c2to accept rpe requests.
when e1executes e2 it is actually e 2that is executed e is on the same path as e2 .e 2marshalls the command arguments its environment and some process attributes and sends an rpe request to the server running on c2 which then executes e2on behalf of e1.
this scenario is described in figure .
the concept of rpe strongly resembles remote procedure calls rpcs where a process invokes a stub procedure which marshalls the arguments supplied and sends them to the remote server which unmarshalls the arguments and calls the actual procedure with those arguments.
the key difference in our context is that instead of shipping just the arguments we also need to ship the process environment as well as low level process attributes.
this subsequently allows for a zerooverhead communication of information for the lifetime of process e2.
our key insight is that the local and remote processes share a kernel and thus appropriate shipping of process attributes and file descriptors can make rpe transparent to the participating programs .
rpcs cannot assume a shared kernel and therefore cannot provide the rich features and transparency of rpe.
when the process ends we ship the return code of the process to the executing process.
in addition we provide for asynchronous signaling i.e.
passing posix signals between processes.
all these aspects require a detailed understanding of the specification of a process.
to highlight the difference between rpe and rpc we describe one mechanism i.e.
how attributes are replicated at command execution .
due to lack of space we will not describe other details.
attribute replication at command execution.
e 2obtains the attributes to be replicated through the relevant system calls while 481cimplifier automatically debloating containers esec fse september paderborn germany the server side sets those attributes through another set of relevant system calls just before executing e2.
some of the attributes specifically the user and group ids are security relevant and are obtained using unix domain sockets mechanisms of obtaining process credentials so that they cannot be faked.
if the user and group ids could be faked a client could escalate privileges by performing rpe.
some attributes such as the user and group ids may be set only by a privileged user.
therefore sruns as root.
the arguments and environment arrays are readily available to e and thus easily copied over and the remote side can execute e2supplying the same arrays.
the replication of file descriptors henceforth called fds needs further discussion.
although fds are ints they have a special meaning associated to them by the kernel and thus have to be transferred to other processes using the functionality provided by the kernel this highlights one of the key differences with rpc .
transferring fds is accomplished through ancillary messages feature of unix domain sockets.
some readers might legitimately wonder why replication of file descriptors is necessary.
the answer is that file descriptor inheritance is behind the functioning of numerous mundane tasks such as input output stream redirection and piping offered by shells a general replication of file descriptors makes the execution transparent in such situations.
.
security of cimplifier security is a key design goal of cimplifier .
the runtime of cimplifier is simple and small enough that the security of its runtime components can be argued for and the resultant container system is at least as secure as the original container.
the only additional code that executes during runtime is the glue code.
in our threat model the rpe server must defend itself from a compromised client which can send arbitrary messages to it and prevent a privilege escalation.
as already mentioned the rpe server uses unix sockets mechanism obtaining socket options through so peercred flag to obtain process credentials so that they cannot be faked.
as an additional line of defense we apply least privilege the unix socket of the server is made available only to containers that need to run commands through it.
as mentioned above our rpe server is small loc and is easily auditable against vulnerabilities like memory corruption.
we have also performed a static analysis based audit of both the rpe client and server programs using parasoft c c test provided through the swamp project .
it is also our goal that cimplifier remains compatible with traditional access control frameworks.
we have tested our implementation to remain interoperable with the default docker container policies of both selinux and apparmor.
among other protections these policies protect the kernel interfaces from attacks in the containers thus preventing consequences like container breakouts.
.
implementation we have implemented a prototype of cimplifier .
our implementation consists of about lines of python and c code with c being used to implement rpe.
to collect the system call logs we relied on the strace utility which depends on ptrace system call as it offers out of the box support decoding system call arguments such as flags .
other mechanisms for collecting these logs could readily replace strace in our system.
evaluation this section presents our experiments to evaluate cimplifier and the results thereof.
our evaluation seeks to answer the following questions does cimplifier work on real world containers and do its output containers preserve the functionality of the input containers?
how effective is cimplifier at slimming and partitioning realworld containers?
how much time does cimplifier take to analyze the inputs and produce the outputs?
what is the runtime overhead of the output container ensemble produced by cimplifier ?
our experiments are divided into two parts experience with realworld popular containers and experiments to measure runtime performance.
we summarize the findings from our experiments and then describe them in detail later.
cimplifier succeeded in creating functional containers in all case studies on real world containers.
cimplifier produced the desired partitions as specified by the user constraints.
as for slimming cimplifier reduces container sizes by up to in our experiments.
given input containers their system call logs and partitioning policies cimplifier produces output containers in under seconds for even the most complex containers we examined.
it is thus fast enough for real world use to partition and slim containers.
the running time overhead is negligible for realistic programs.
further the memory overhead is small at about mb per output container.
.
case studies we tested cimplifier on nine popular containers from docker hub.
six of these containers were chosen from the docker official images the docker project directly provides over hundred container images providing popular applications which are simple but highly used containers.
as each of these run one simple application only we did not expect cimplifier to partition them but only to perform slimming.
the remaining containers are popular community contributed containers and run multiple application components that should be partitioned.
cimplifier is guided by the application behavior demonstrated during test runs and captured as system call logs section .
.
this allows the user to customize their containers by only exercising the behavior they desire.
in a deployment setting cimplifier can use logs captured from pre production environment to create containers for the next stage pre production or production.
in our experiments we executed the containers normally to exercise their specific configurations.
furthermore we also ran applicationprovided tests to ensure we exercised all application functionality.
these tests are provided by the application developers and aim to provide comprehensive application code coverage.
in our experience running tests in containers requires container modification 482esec fse september paderborn germany v. rastogi d. davidson l. de carli s. jha and p. mcdaniel and amounts to additional but not large user effort.
assuming the tests are complete for the deployment scenario the created containers will preserve functionality.
unfortunately running the same tests on reduced containers in order to verify that they maintain their functionality after slimming is often not feasible as such containers lack the environment necessary to run the tests.
in order to circumvent this issue where necessary we run non trivial test cases that we created instead.
it should be noted that these checks are only for verifying that cimplifier is implemented correctly and would not be needed in a production environment.
we assume in these experiments that user data is stored in named volumes since user data can vary across deployments we do not remove any resources from named volumes.
a preprocessing run through system call logs shows the executables and their invocation graph we use this output to write our partitioning policies.
the rest of this subsection will cover several container case studies and then present a discussion highlighting noteworthy lessons.
the case studies are divided into those of simple applications and application stacks consisting of multiple tasks.
due to space limitations we provide general details in table and discuss only specific interesting details in the text.
all the experiments were conducted on a virtualbox virtual machine running fedora and configured with a single cpu core and 2gb of memory.
the base hardware was a macbook pro with .
ghz intel core i7 4850hq cpu and a solid state drive.
.
.
simple applications.
we first discuss containers that each run a single application only are slimmed by cimplifier .
in this category we considered nginx a web server redis an in memory data structure store mongodb a nosql database engine docker registry a server side application for storing and distributing docker images haproxy a load balancing proxy for http and tcp and the python runtime running a website.
all these applications are highly popular.
for all cases we used test cases provided with the application code for test runs.
test cases for registry and haproxy were not possible to run on release binaries so we used our own tests and then ensured that the prepared containers included all the resources they would ever need e.g.
the registry app needs only a configuration file libc linker and a busybox binary of course we also include the registry binary which alone is mb of the mb final size .
cimplifier could produce functional slim containers for all the applications.
the python container warrants further discussion.
this container should be used as a base for a python application.
to find our candidate web application we explored the list of websites powered by flask a popular python web application framework the list is curated by the flask project and selected the list s first opensource website.
we thus selected using logs from our tests which exhaustively crawled the website cimplifier could reduce the container size from mb to mb.
we point out that our python container from the docker hub is focused on reducing image size.
our case study shows that cimplifier can perform slimming on an already space efficient container.
.
.
application stacks.
having discussed simple containers we now discuss full stack containers which should be partitioned.
mediawiki.
this study considers appcontainers mediawiki the container of our running example.
we would like to split thiscontainer into separate apache httpd mysql and imagemagick partitions as well as an initial configuration partition as depicted in figure .
the user constraints and policy used to derive these containers are given in section .
.
for our test runs we used the mediawiki acceptance tests and unit tests.
cimplifier was able to produce a functionality preserving system of four containers as tested by executing acceptance tests and some test cases that we wrote ourselves using selenium ide our test cases include adding tables and images which the acceptance tests do not do .
as expected imagemagick is separated from httpd but shares some volumes var www html and tmp .
these directories are used for images that mediawiki asks imagemagick to process.
since only a few files are shared the attack surface for cve section .
is partially mitigated.
in fact imagemagick needs access to only an images directory in var www html .
however this directory is only dynamically created at container startup since volume mount points must be present in container images we end up sharing the whole of var www html .
we emphasize that this oversharing is purely due to the configuration of this specific container particularly the excessive files movement and setup during startup in this container.
a different configuration can use much smaller shared volumes.
for instance another popular mediawiki container nickstenning mediawiki this container requires an external mysql server has the images directory packed in the container image resulting in the sharing of just the images directory.
the imagemagick httpd sharing in this case study demonstrates that slight configuration changes could result in much better isolation.
as another example httpd and mysql partitions need to share var lib mysql this directory contains mysql database files because of mysql server s socket there.
if however the socket is created at a different location as in our next case study this sharing could be avoided.
when building their own containers system administrators can tweak the containers in simple ways to avoid excessive sharing.
it is our future work to investigate finer grained file sharing between containers.
wordpress.
eugeneware docker wordpress nginx is a container for wordpress a blog engine.
it contains nginx mysql php fpm a php engine and supervisord a process control system each of which we would like place in different partitions.
the nginx frontend server connects via a unix socket to phpfpm which runs wordpress code and communicates with mysql for storage through another unix socket.
our user constraint policy is supervisord nginx php5 fpm mysqld safe sbin mysqld libexec mysqld mysql mysqladmin mysql install db .
our test runs included unit tests and also performing actions such as creating blog posts adding comments changing user profiles and signing in and out to ensure we exercised container specific configuration.
cimplifier produced the desired partitions that would together be able to serve wordpress just like the original container did.
it is noteworthy that the configuration of this container allows for better isolation than the previous mediawiki one the mysql socket is created in a mysql specific directory which needs to be present in the mysql container only.
483cimplifier automatically debloating containers esec fse september paderborn germany table containers studied.
container downloads size languages analysis time result size size reduction nginx m mb c .
s mb redis m mb c .
s mb mongo m mb c .
s mb python m mb python .
s mb registry m mb go .
s mb haproxy m mb c .
s mb appcontainers mediawiki k mb c php shell .
s mb eugeneware docker wordpress nginx k mb c php shell python .
s mb sebp elk k mb java shell ruby javascript .
s mb each row specifies the container identifier on docker hub the number of downloads an indicator of popularity the container image size the source code language of the applications the cimplifier analysis time the combined size of output containers and the percentage reduction in size.
the languages indicate the diversity of containerized applications analyzed.
only the applications languages are listed libraries may have been written in additional languages.
the first six containers are simple and hence not partitioned but only slimmed.
the containers produced by cimplifier are functionally identical to the original containers.
elk.
the elasticsearch logstash kibana elk stack is an application stack for collecting indexing and visualizing information from logs such as those from syslog or http server.
elasticsearch is used for indexing.
logstash provides network interfaces for receiving logs.
kibana is the web frontend for searching and visualizing logs.
we use sebp elk for our elk stack.
our desired partitions would be one each of elasticsearch logstash and kibana and one of the startup script represented in the simple policy kibana elasticsearch logstash the startup script is implicit and is put in its own partition .
to exercise this container we used tests accompanying logstash and kibana.
elasticsearch tests are not feasible to be run in a deployable codebase but in our setup we could exercise it through kibana and our own test cases.
cimplifier produced four functional partitions which were tested by feeding logs from linux audit and running queries and plotting results on kibana.
except for a log file there is no file sharing among the partitions this is expected as the three main components communicate via network only.
.
.
discussion.
we note several points from our experience above.
first container configuration highly influences the degree of isolation possible among partitions.
this is aptly demonstrated by the location of mysql socket in the mediawiki and wordpress containers.
second the different container partitions sometimes have duplicated read only resources.
for example the linker and libc are required by all containers and are currently duplicated across partitions.
cimplifier could save space by sharing a layer of files common among partitions docker container images consist of read only layers that can be shared between containers .
finally as much as of the analysis time shown in table is spent in recovering a file tree from a docker image and not in actual analysis.
this time can be saved if the file tree were readily available such as when using the btrfs storage driver .
.
runtime overhead the only overhead in cimplifier is due to the rpe glue which we expect to be small for any realistic programs.
while we did not perceive any overhead in our case studies we performed systematic microbenchmarking to quantify the running time and memory overheads.
for runtime overhead we wrote a microbenchmark consisting of several iterations of fork exec calls.
cimplifier results in partitioning at these calls and adding the glue in between so we can compare the overhead of the glue over the original fork exec setup.
020040060080010001200time seconds for fork exec iterationsnumber of open file descriptorswithout rpewith rpe 05000100001500020000250003000035000time seconds for fork exec iterationsbyte length of arguments and envrionmentwithout rpewith rpefigure runtime overhead of rpe as number of open file descriptors and arguments length varies among the artifacts replicated across containers the number of open file descriptors and the number of bytes in the command arguments and environment are variable.
we show the results of our microbenchmark in figure .
the rpe overhead increases linearly with these variables.
this is intuitive because we replicate these variables in the remote process in userspace.
nevertheless programs do not use extremely long command arguments for portability reasons and even if a program opens a large number of files the files will typically be closed at the time of exec to prevent file descriptor leakage issues.
the overhead per fork exec is thus only about ms for all practical purposes and is easily amortized for programs that run for more than a few milliseconds.
developers should nonetheless be careful not to partition containers on boundaries involving a large number of process executions.
we also measured the memory overhead due to additional processes that arise from rpe by measuring the resident set size rss of those processes.
the rss of the rpe server peaks at kb while that for other processes client and controlling processes it peaks at about kb.
the overhead is thus only about mb per container which we consider low as even simple utilities like ls from coreutils reach rss of over mb.
484esec fse september paderborn germany v. rastogi d. davidson l. de carli s. jha and p. mcdaniel related work a few works in the past have used resource identification for various purposes.
in the docker ecosystem itself some blog posts and projects have developed automatic container slimming as a solution to the big size of docker images.
all these works have relied on fanotify to identify necessary file resources.
this technique is simpler than system call based identification but does not record crucial file system events like creation and moving of files.
we have observed behavior such as file moves in real world containers such as mediawiki container that we examined that would break fanotify based solutions.
our approach is more complete and goes beyond slimming to provide container partitioning.
cde is a tool developed before application containers it uses ptrace to identify file resources needed for running an application and packs them so as to provide a portable runtime for running the application on any linux host.
while our resource identification is similar we offer a more formal treatment in a new domain.
furthermore the challenges with respect to container partitioning are unique to our work.
our work draws its motivation from previous work on least privilege and privilege separation.
krohn et al.
observe that mainstream operating systems do not provide easy support for implementing least privilege in programs despite wide acceptance of the principle.
the evolving container ecosystem also faces this problem which our work helps address.
provos et al.
performed privilege separation of the ssh service manually.
cimplifier is automatic and so can scale better.
brumley and song developed automatic techniques based on static analysis for automatic privilege separation.
bittau et al.
provide operating system level primitives to allow developing applications in a privilege separated manner.
others have used specialized programming languages and compilers to ensure flow control across program parts .
because of the need to analyze real world containers running on stock linux we can assume neither specialized programming languages nor special os level primitives nor is our problem very amenable to static analysis alone i.e.
without any dynamic analysis see section .
.
blankstein and friedman perform dynamic analysis based privilege separation for python web services.
their problem is however different from ours.
they perform fine grained privilege separation on web services specifically even more specifically django applications and are able to mold their solution to the specific architecture e.g.
model view controller and specific implementation e.g.
django and database backends like postgres and sqlite .
we allow performing a more general albeit more coarsegrained privilege separation on arbitrary containers.
nonetheless these works were valuable in inspiring our approach to container partitioning and may in the future be used with our approach to offer finer partitions than what we currently achieve.
remote process execution may be compared to live migration.
live migration of processes or virtual machines includes saving all the relevant state including memory and replicating it somewhere else with kernel or hypervisor support.
in contrast rpe is a light weight technique to transfer execution right when it begins.
instead of needing kernel support it takes advantage of a shared kernel state to enable low overhead transparent remote execution.
limitations and future work cimplifier provides an important first step in container partitioning and slimming.
in this section we point out limitations of our approach and discuss directions for future research.
cimplifier inherits the usual drawbacks of dynamic analysis if test runs do not cover all relevant scenarios resource identification will be incomplete and applications may fail in unexpected and arbitrary ways at runtime.
with static analysis not appearing feasible section .
we resort to dynamic analysis.
there are several ways of addressing the coverage issue with dynamic analysis.
our evaluation used test cases curated in the program s source repositories with the expectation that they provide high coverage.
users could provide additional input generation techniques e.g.
fuzzing cimplifier is agnostic to the techniques used to drive the programs.
in practice we envision cimplifier to be integrated into the software deployment life cycle software deployment passes through multiple stages such as development testing pre production and production.
runs in the testing and pre production stages would provide cimplifier enough information for accurately performing resource identification.
slimming containers can also affect debuggability as debug tools and utilities may no longer be available.
for example to debug a misbehaving application one may wish to get a shell in the container and look at file system contents.
however utilities like shand lsmay not be present.
host based tools that switch to a container s namespace are a possible direction toward solving this problem.
existing tools already provide some support for this.
conclusion while application containers are becoming tremendously popular they often pack unnecessary resources which not only results in excessive space usage but also potential vulnerabilities.
moreover complex containers can be further partitioned into simpler containers to provide privilege separation.
we designed and implemented cimplifier which partitions a container into many simple ones enforcing privilege separation between them and eliminates the resources that are not necessary for application execution.
to achieve our goal we developed techniques for identifying resource usage for performing partitioning and for gluing the partitions together to retain original functionality.
our evaluation shows that cimplifier creates functionality preserving partitions achieves container image size reductions of up to and processes even big containers in less than thirty seconds.