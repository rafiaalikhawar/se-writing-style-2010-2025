latent patterns in activities a field study of how developers manage context souti chattopadhyay nicholas nelson yenifer ramirez gonzalez annel amelia leon rahul pandita and anita sarma oregon state university corvallis or usa phase change software golden co usa chattops nelsonni ramireye leonan oregonstate.edu rpandita phasechange.ai anita.sarma oregonstate.edu abstract in order to build efficient tools that support complex programming tasks it is imperative that we understand how developers program.
we know that developers create a context around their programming task by gathering relevant information.
we also know that developers decompose their tasks recursively into smaller units.
however important gaps exist in our knowledge about the role that context plays in supporting smaller units of tasks the relationship that exists among these smaller units and how context flows across them.
the goal of this research is to gain a better understanding of how developers structure their tasks and manage context through a field study of ten professional developers in an industrial setting.
our analysis reveals that developers decompose their tasks into smaller units with distinct goals that specific patterns exist in how they sequence these smaller units and that developers may maintain context between those smaller units with related goals.
index terms context task decomposition field study i. i ntroduction programming is a creative endeavor in which developers engage in different types of closely related activities to complete a development task.
they explore different solutions review past versions and backtrack .
we need to know how these activities relate interleave and build upon each other to truly understand how developers work.
this is essential if we wish to build tools that seamlessly support all the different programming activities.
studying developer activity has been a topic of research for decades.
as early as v orburgh et al.
studied programming environments identifying factors influencing team productivity .
more recently ko et al.
studied the information needs of developers and meyer et al.
studied how developers work habits correspond with their perceptions of productivity .
from the collected work two key observations emerge that are pertinent to the research questions explored in this paper.
first developers work in short bursts of activities.
gonzalez and mark and meyer et.
al.
found that developers organized their development tasks into smaller basic units of work.
second as developers work they create a context that drives their development activities.
this context encompasses relevant information needed to complete the development task .
for example in order to fix a bug a developer needs to know about the bug from its description in the issue tracker how to replicate the bug discussion snippet in the issue tracker what the code currently does lines of source code and so on.
all these information elements together create the context of this bug fix task.
these two observations have motivated several lines of research.
researchers have built tools to recommend the project artifacts that are relevant to a developer s task .
other work has looked further into how developers recursively decompose a development task into a hierarchy of subtasks .
additionally researchers have investigated how developers working style across subtasks correspond with their perception of productivity and how productive developers differentiate themselves based on how they decompose their testing tasks .
despite all this work important gaps still remain in our understanding of how developers go about solving complex programming tasks.
specifically while research has identified the role that context plays in supporting development tasks and that developers decompose their tasks into smaller units open questions remain.
what is the relationship among these smaller units of work?
how does context impact smaller units of tasks?
and how does context flow from one unit to another?
while it is useful to study individual smaller units of tasks it is equally useful to understand how these units relate to one another.
for instance do patterns exist in how developers structure their development tasks into smaller units?
and do these correspond to specific types of development task e.g bug fix refactoring code implementation ?
and if patterns do exist how does context evolve from one smaller task to another?
is context tossed away upon the completion of a smaller task and constructed anew for the next?
is it carried forward in time?
in this paper we aim to close this gap by observing developers in a field study.
we observed ten developers at a software company.
we recorded their development activities which included interactions with artifacts while working on their own development tasks and in their own programming environment.
we conducted a follow up survey which validated our findings on how developers decompose tasks and create context.
this study makes the following observations about development behavior different patterns emerge in how developers organize their tasks into smaller units.
ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
patterns in organization of smaller units depend on the type of the development task.
goals of smaller units are instrumental in creating con text which guides developers interactions with artifacts.
depending on the relationship between smaller units developers maintain or drop the context as they shiftbetween units.
understanding these development behaviors are fundamentalto tool builders and researchers when building developmentenvironments that better support programming activities.
ii.
d efinitions studies of developer activity require a concrete set of terminology.
in this section we define key terms through anexample scenario involving charlie a programmer .
goal the end towards which development effort is directed.
for example during a normal workday charlie has a goal to refactor a portion of the code base.
subgoal goals are composed of subgoals which represent smaller actionable objectives.
for example to refactor the code base charlie can have subgoals understand why the code has to be refactored subgoal identify the parts of the code that have to berefactored subgoal and replace old code with new code subgoal .
figure shows an example of a goal that is broken down into three subgoals.
a developer may identify the subgoalsright away or create them organically as they proceed.
action a development effort comprised of steps performed by a developer towards reaching their subgoal.
for example to replace old code with new code subgoal charlie may take the following actions open the classfile a in his editor navigate read file a read delete oldextraneous sections of code edit add new code edit andcompile the resulting code execute .
see table ii for specificdefinitions of these actions.
episode a series of loosely connected actions that are performed continuously one after the other temporally related or performed to complete a subgoal.
for example the above actions compose an episode guided by charlie s subgoal of replacing old code with new code subgoal .
this is shown in episode of figure .
hadcharlie been interrupted or taken other actions related toanother subgoal the above set of actions would be representedas two separate episodes.
context the information that is used to perform a development effort which includes the artifacts interactions with theartifacts observable and sensemaking of the artifacts notobservable .
for example charlie reads lines of code artifact to understand where to refactor incorrect pieces of code.
the codeartifact and the interaction with that artifact reading comprisethe context.
similarly charlie may delete the incorrect code before writing new code.
although the artifact remainsthe same different contexts are created based on charlie ssensemaking approach.
fig.
depiction of a goal subgoals episodes and actions.
working context the specific context that is required to complete actions in an episode.
developers may use parts or all of a working context from a prior episode when executing their actions in the currentepisode.
for example charlie reads a portion of the code anduses that working context to guide his refactoring of the code.
iii.
m ethodology we conducted a field study where we observed ten developers working on their programming tasks.
each session wasapproximately one hour long and included a minute ret rospective interview total observation time hours min utes .
we unobtrusively observed the workspace computer screens and interactions of each developer following the fly on the wall technique described by preissle and grant .
we then validated our findings through a follow up survey perguidelines by easterbrook et al.
.
a. study design study participants were recruited from a us based software startup.
this startup operates in the areas of distributed developer tools and services which includes program analysis ui infrastructure middleware support and tool r d. the varietyof topics allowed for diverse languages and working stylesamong our participants.
participants volunteered to take partin this study and were not compensated.
table i study participant demographics ptc.igender exp.iilanguage s iiieditoriv p1 m 21y 0m java eclipse p2 m 1y 11m clojure eclipse p3 m 1y 10m clojure java emacs p4 m 7y 3m clojure python emacs p5 m 2y 0m clojure java haskell emacs p6 m 2y 0m typescript java clojure vs code p7 m 5y 0m c c emacs p8 f 15y 0m javascript css vs code p9 m 0y 9m c prolog sublime p10 f 1y 0m python pycharm iptc.
participantiiexp.
years months of software development experienceiiipreferred programming language s iveditor used in session authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i presents participant demographic details including gender software development experience their preferred programming language s and preferred editor.
the average was years months of software development experience.
we observed developers performing their regular development tasks on a typical workday.
we demonstrated the thinkaloud protocol and requested participants to verbalize their thoughts and interactions during the session which we recorded using two separate microphones for redundancy.
each session was recorded using screen capture software.
additionally we video recorded participants physical workspace to capture all artifacts e.g.
paper and whiteboard media .
for each session one researcher was positioned behind the participant taking in situ field notes.
this researcher noted information about activities performed by the participant e.g.
reviewing design notes on paper before writing code in the editor .
an additional researcher was located in a separate room not visible to the participant.
this researcher monitored the screen and audio recording of the participant to take secondary field notes.
the first and second authors were responsible for the data collection and alternated between primary and secondary positions.
sessions were time boxed to minutes which allowed time to perform a retrospective interview minutes .
longer sessions were not feasible due to time restrictions at the startup.
sessions stopped when participants completed their task which resulted in some sessions being shorter than minutes in duration.
at the end of the session participants were asked to complete a brief demographic survey see table i for responses .
while participants completed the survey the researchers compared their field notes to identify portions of the session that were of interest.
clarifying questions about the session were asked in a minute retrospective interview which included replaying portions of the screen capture video in order to refresh participants memory.
b. data analysis after completing all study sessions the retrospective interviews and think aloud verbalizations were transcribed.
coding of the transcribed data was performed in three steps.
first each action was coded by multiple raters and a high inter rater reliability irr measures was maintained.
second the units of measurement subgoals and episodes were defined through negotiated agreement among the first four authors using the first half of session data collected from p4.
third the patterns were identified by analyzing the units of measurement across the entire dataset using negotiated agreement.
a detailed description and walk through of the coding scheme can be found on our companion site1.
coding of the session data screen capture video transcripts and field notes included coding the verbalized overall goal and subgoals within the session annotating the active artifacts i.e.
artifacts which participants interacted with and ii action codes action definition readexamining information from artifacts e.g.
code documentation terminal output edit any change made directly to code or related artifacts.
navigatemoving within or among artifacts e.g.
pulling files from git opening files scrolling through a file .
execute compiling and or running code.
ideate constructing mental model of future changes.
actions taken by the participant.
these actions are defined in table ii.
two five minute segments of session data collected from p4 were unitized into and actions .
the first four authors individually coded each action with the codes described in table ii.
we calculate inter rater reliability irr using fleiss kappa across all four raters.
the kappa value was .
instances 4raters p value .
and .
23instances 4raters p value .
in first and second rounds of coding respectively.
we identified the subgoals through a combination of coded actions and verbalizations.
actions were segmented to their appropriate subgoal based on the timestamp and the thematic topic of each subgoal .
for most segments the subgoal was readily discernible from the verbalizations.
for example p4 indicated i need to create a new entry into this module.
this verbalization occurred at the same time that p4 switched from the read action to the editaction which provided further evidence of the transition between subgoals.
additionally we identified the episodes of actions within the data by using the actions subgoals and relationships between them.
the transitions between episodes were identified based upon either a change in subgoal or a period of nondevelopment activity e.g.
interruptions or taking a break .
for example p6 mentioned now i am going to move node methods from the hierarchy service.
in this instance the verbalization provided a clear delineation between episodes based on the described subgoal moving node methods .
to ensure validity of episode and subgoal coding the first four authors incrementally coded the first half of session data from p4 using negotiated agreement .
negotiated agreement was used to create a standardized coding scheme and improve it to an acceptable point where there was no ambiguity in any of the data points .
after reaching agreement the first and second authors coded the episodes and subgoals for participants p1 p4 and the third and fourth authors coded the data for participants p5 p10.
c. v alidation survey to validate the patterns of episodes during data analysis we conducted a follow up survey with participants.
we were unable to contact p8 since she had left the company in between the study and start of the survey.
the survey consisted of two sets of questions and took about minutes to complete.
the full set of survey questions can be found on our companion site1.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the first set of questions introduced a brief development scenario and provided participants with a set of information elements e.g.
java compile error message indicating reference error java compile error message indicating memory out of bounds and multiple software development actions e.g.
execute code in a terminal window .
participants had to match the information elements that they thought were relevant to the actions based on the description of the scenario.
the second set of questions showed patterns in which episodes could be arranged which are described later in section iv b. these patterns were described in text as well as graphically.
participants had to rank the patterns based on how frequently they used them and then provide rationale behind their most frequently used and least frequently used pattern.
d. limitations of the study as any field study our findings are derived from a limited number of observations regarding the development efforts of our participants from a single software development company.
however our participants performed different types of development tasks including implementing core program analysis server management web interface development and analysis modeling.
they also used varied environments such as feature rich ides e.g.
eclipse to advanced code editors e.g.
emacs .
our observational study intends to identify patterns that arise in common software development tasks.
generalizability although desirable was not a primary objective of our study.
instead we aim to present findings that can be transferred to various environments providing contextual support to programmers .
while we only observed developers for minutes each our primary units of analysis are the episodes and subgoals discovered during these sessions.
the inherent nature of an observational think aloud study might cause the data to be affected by the hawthorne effect response bias or create additional cognitive load in participants needing to think aloud .
such limitations are prevalent in protocol studies and can be removed in future studies that instrument a developers workspace in the background.
as is the case in any qualitative study our findings are subjective to the researchers perceptions.
we mitigated this threat through rigor in our analysis process by using four raters maintaining inter rater reliability and using a well defined coding scheme .
we also validated our findings with the perceptions of the developers through a follow up survey.
iv .
r esults a. goal structuring rq1 how do developers structure their software development goals?
developers structure their development goals into episodes of actions each of which is driven by a particular subgoal.
we observed episodes driven by distinct subgoals.
table iii presents the individual number of episodes and subgoals per participant during the study the duration intable iii goals episodes and subgoals in field study participant goal type episodes subgoals durationi p1 debugging p2 implementing p3 refactoring p4 implementing p5 debugging p6 refactoring p7 refactoring p8 implementing p9 implementing p10 debugging totals iduration of each study session h mm ss hh mm ss format of each session and the goal type for the session as verbally indicated by the participant at the start of each session .
on average study sessions were minutes seconds long and included .
episodes driven by subgoals.
the distribution of the episodes and subgoals across goal types reveal that not all goal types use the same structure.
participants working on an implementation goal four participants had an average study duration of minutes seconds with .
episodes driven by subgoals.
the average time spent per episode was minutes seconds whereas the average time spent per subgoal was minutes seconds.
participants working on a refactoring goal three participants had an average study duration of minutes seconds with .
episodes driven by subgoals.
the average time spent per episode was minutes seconds whereas the average time spent per subgoal was minutes second.
for participants working on a debugging goal they deviated from the overall average.
there were three participants working on debugging goals and the average study duration was minutes seconds with .
episodes driven by subgoals.
the average time spent per episode was minute seconds whereas the average time spent per subgoal was minutes seconds.
we found that debugging goals require shorter more frequent episodes of actions.
although the overall session was similar participants working on a debugging goal worked in more episodes when compared to participants working on an implementation or refactoring goal with .
and .
additional episodes respectively.
the average duration of the episodes for the debugging goal was also shorter than those of implementation or refactoring goals minute seconds and minute seconds shorter respectively.
we hypothesize that debugging requires more cognitive load per episode of actions.
debugging requires locating the source of the bug comprehending the code associated with the bug and modifying the code to fix it.
whereas implementation and refactoring actions rely more on sensemaking and modifying the code than finding specific parts of faulty code.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
visual illustration of observed patterns the average subgoal duration for debugging was also the shortest minutes seconds whereas implementation and refactoring sub goals were seconds and seconds longer respectively.
this indicates that debugging goals require morefrequent context switching between subgoals.
gonzalez et al.
found that people spend about minutes on average per task which is synonymous with a subgoal in our study .
our results also show that subgoals last for minutes seconds on average.
we additionally find that theaverage time per subgoal varies according to the goal type andthat developers purposefully structure their goals in order toswitch between subgoals approximately every minutes.
in summary we find that on average developers structure their goals into .
episodes that are focused on the samesubgoal for about minutes seconds.
the duration andfrequency of these subgoals and episodes vary according tothe goal type.
b. patterns in episode structuring across subgoals rq2 what patterns do developers employ when working in and across subgoals?
developers decompose their goals into subgoals which drive episodes of actions.
we observed that these episodes occur in patterns that are formed as a developer works throughdifferent subgoals over time.
our participants structured episodes into five distinct patterns.
we observed that participants arranged their episodes insequence across different subgoals sequential pattern concurrently across two subgoals concurrent recursively into increasingly fine grained subgoals recursive by revisitingprevious subgoals to reorient grounding or by exploringtwo alternate subgoals alternating .
figure illustrates eachof these patterns.
sequential pattern developers work in sequential episodes that span different subgoals.
each subgoal helpsdefine subsequent subgoals.
figure a illustrates p3 decomposing his refactoring goal into three sequential subgoals.
towards subgoal p3 repli table iv frequency of pattern instances ptc.isequential concurrent grounding recursive alternate p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 av g.ii2.
.
.
.
.
iptc.
participantiiaverage instances per participant for a given pattern.
cated a method related to the translator property ensuring that there were no errors in the process.
after successfullycompleting this subgoal he replicated several methods relatedto the conversion property subgoal .
finally he created a query method to be used in the replicated properties subgoal3 .
throughout this sequence p3 did not return to working onany prior subgoal.
the sequential pattern was the most frequent pattern.
we observed instances of this pattern across out of 10participants .
this pattern was typically used during codeexperimentation.
table iv provides the frequency of patternoccurrences per participant.
developers perceived the sequential pattern to be useful and prevalent in their work.
.
of validation survey par ticipants out of indicated that they use the sequentialpattern either sometimes ormost of the time see table v for individual participant responses.
participants ranked thesequential pattern as the most frequently used pattern avg.
rank .
.
p2 indicated using this pattern makes it easier to decompose authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v pattern validation through member checking ptc.isequential concurrent grounding recursive alternate frequency rank frequency rank frequency rank frequency rank frequency rank p1 sometimes sometimes sometimes most of the time rarely p2 sometimes rarely sometimes sometimes sometimes p3 sometimes never most of the time rarely rarely p4 sometimes sometimes most of the time sometimes rarely p5 sometimes never rarely most of the time rarely p6 sometimes rarely sometimes sometimes rarely p7 sometimes sometimes sometimes sometimes sometimes p9 most of the time most of the time sometimes rarely rarely p10 rarely sometimes most of the time rarely sometimes av g. sometimes .
ii1.
never .
ii4.
sometimes .
ii1.
sometimes .
ii3.
rarely .
ii4.
iptc.
participantiifrequency responses converted to numerical form for calculating averages never rarely sometimes most of the time .
complex tasks because previous stages are completed before moving on to the next.
grounding pattern developers reorient themselves to their overarching goal by revisiting a prior subgoal.
grounding typically involves building and executing code running tests and checking system status which are all time intensive processes.
figure b illustrates p9 evaluating the data format of a query subgoal .
he then edited the query subgoal and created a method to wrap the output data subgoal .
in order to ensure that the query was returning data in the correct format he grounded himself by revisiting the original query return to subgoal .
p9 had to recall the previous format of the query episode to evaluate whether his implementation was successful.
the frequency with which participants grounded themselves varied across participants.
eight participants grounded themselves after a single episode.
for example p9 explored different syntax to implement a sorting algorithm.
he built and executed the code at several points to verify his solution.
these executions represent instances of the grounding pattern which typically occurred when participants iterated through experimental solutions.
we also observed four participants working through several episodes before grounding themselves.
in these cases participants typically grounded to evaluate their progress reorient to the overarching goal and transition to the next subgoal.
for example p1 grounded himself after six episodes and said what i wanna try getting next is just to implement another minor feature .
validation survey responses of indicated that participants use the grounding pattern either sometimes or most of the time .
participants ranked the grounding pattern as the second most frequently used pattern avg.
rank .
.
we conclude that when developers work on exploratory subgoals they evaluate their progress by grounding .
p4 said allows me to see the results of each step like stepping through in a debugger ... concurrent pattern developers occasionally work concurrently towards one subgoal while waiting on a process relating to a different subgoal e.g.
builds tests code reviews .
based on the relationships between subgoals we observed two variations of the concurrent pattern independent and dependent concurrency.
concurrent independent pattern instances emerge when the two concurrent subgoals are independent of each other i.e.
the completion of one subgoal is not required in order to complete the other subgoal .
concurrent dependent pattern instances emerge when the two concurrent subgoals are dependent upon each other i.e.
a deviation in the expected behavior of processes in one subgoal require attention in the other subgoal .
figure c illustrates p5 triggering a build subgoal .
while waiting for the build to finish he began searching and reading documentation about a specific query api subgoal .
when the build finished with an error notification he switched back to the build configuration and made additional changes and triggered a new build subgoal .
instead of waiting for the build p5 again returned to reading documentation about the query api subgoal .
this is an occurrence of the concurrent independent pattern.
during the study p5 described this sequence of episodes by saying while this is running i am going look for the query slice ...i haven t interacted with the query interface in a couple months so i am going to familiarize myself with the code.
by contrast the concurrent dependent pattern is illustrated in figure d which shows p1 running the tests subgoal and starting to commit all modified files subgoal prior to seeing the test results.
since he was working concurrently p1 had already committed several files before some of the tests failed.
this forced p1 to halt committing fix the broken code and restart the tests.
p1 then had to revert his previous commits subgoal and exclaimed now i gotta get rid of those !
committing the modified files subgoal was dependent upon the tests passing subgoal .
we observed nine instances of this pattern across participants out authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of .
.
survey participants out of stated that they use the concurrent pattern either sometimes ormost of the time .
however two participants indicated that they never use this pattern.
participants ranked the concurrent pattern as the least frequently used avg.
rank .
.
the episodes directed towards one of the subgoals in the concurrent pattern are off loadable either to computer processes or other personnel which might explain the low frequency with which participants use this pattern.
as p6 said if one of my tasks involves a lot of waiting or downtime.
additionally a blocked subgoal can be attributed to coordination issues such as waiting for a code review as indicated by p3 when i have two subtasks completely unrelated and i m waiting for code review in some of them.
past work has shown that developers pursue two subgoals concurrently to increase productivity .
we similarly find that working concurrently on independent subgoals can be beneficial to a developers productivity.
however we see that working concurrently on dependent subgoals can actually inhibit productivity and force unwanted context switches.
recursive pattern developers decompose their current subgoal into recursively nested subgoals.
in this pattern each subgoal is dependent upon successive subgoal s .
figure e illustrates p4 attempting to create a query function.
he initially started to debug the existing query code subgoal .
after realizing that a helper function was needed subgoal he devised that an appropriate filter function was needed during implementation.
after successfully implementing the filter subgoal he retraced back and completed the helper function subgoal and query subgoal .
of participants of used the recursive pattern.
this pattern typically emerged when developers were working on a relatively unexplored problem space.
.
of validation survey participants out of stated that they sometimes ormost of the time recursively structure their subgoals.
recursive pattern was perceived as the third most frequently used pattern avg.
rank .
.
the variation in the participants ranking of the recursive pattern suggest that the situations in which this pattern can be used are infrequent or complex.
p9 stated ...i would use it if i was facing a problem that i anticipate to be very large and complex.
alternating pattern developers occasionally work simultaneously on two or more subgoals that represent alternative solutions to a larger goal.
developers frequently switch between episodes towards different subgoals.
unlike the concurrent pattern in an alternating pattern developers maintain some part of their context toward the active subgoal at all times.
figure f illustrates p5 exploring two alternate solutions to a missing dependency error.
p5 started implementing the solution from a forum posting subgoal followed by implementing a different solution from another posting subgoal .p5 continued switching between the two subgoals iteratively completing portions of both solutions and comparing.
we observed two instances of this pattern from one participant thus making this pattern the least frequent in our study.
.
of validation survey participants of indicated that they rarely use the alternating pattern.
participants also ranked the alternating pattern as the least frequently used pattern avg.
rank .
.
the alternating and concurrent patterns share the position of least frequent.
alternately exploring solutions requires maintaining different contexts as pointed out by p7 i use this pattern as a way to consider the context of a problem across different solutions.
the alternating pattern occurred rarely in our study partially due to the sessions being limited to one overarching goal but also likely due to the high perceived costs of maintaining multiple simultaneous contexts.
to summarize we observed that developers organize episodes in different patterns.
these patterns have specific characteristics that enable specific kinds of subgoals.
in our study we found five distinct patterns used by real world developers.
these developers structured their individual episodes into sequential grounded concurrent alternating and recursive patterns for a variety of subgoals.
c. maintaining context across episodes rq3 how do developers maintain context across episodes?
the five distinct patterns observed in section iv b enable different types of subgoals.
each pattern was associated with unique artifacts and interaction with these artifacts.
these interaction patterns contribute towards the working context of the developer.
a working context is comprised of episodes which are formed as developers gather information and interact with specific artifacts.
to understand how developers manage working context throughout their goal we need to understand how developers interact with artifacts and how information flows across episodes.
developers likely gain relevant information through their interactions with artifacts creating unique information flows for each pattern.
to confirm our understanding of information flow across working contexts we asked validation survey participants to examine several different scenarios and identify the relevant information that contributes to individual actions episodes and subgoals.
the survey can be accessed from our companion site.
figure represents responses to the five survey questions related to information relevancy and information flow for specific development patterns.
we asked one question per pattern using neutral language that avoids biasing responses towards any particular pattern.
information elements are shown as colored curved lines the vertical heights correspond to the number of participants that perceived that element to be relevant to a particular action.
actions are shown in time sequence order along the horizontal axis denoted as a 1through authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a8.
actions are divided into episodes and the borders between episodes are denoted by grey vertical lines.
sequential pattern when developers structure episodes in the sequential pattern consecutive episodes share at least one artifact.
these episodes also involve artifacts that are unique to an individual episode.
for example during his session p3 decomposed a goal of creating a query interface into three sequential episodes each towards a different subgoal.
across these three episodes p3 interacted with the query interface file.
all other artifacts were used in exactly one episode.
such observations suggest that participants maintain related information across sequential episodes.
the sequential pattern see figure 3a shows a gradual shift in the relevancy of information i.e.
information flows across episodes.
examining the figure further we see that participants perceived the information from element green line to be relevant across all four episodes.
other than element every episode had unique information elements perceived to be relevant to that episode.
the peaks of element red line element purple line element blue line and element orange line all show only one rise in relevancy indicating that these had fairly localized relevancy that did not span across the episodes.
thus in the sequential pattern the working context overlaps between subsequent episodes .
since each subsequent episode is towards a new subgoal some information and artifacts lose relevancy and are no longer part of the working context.
however there are also cases where some information remains in the working context over a longer period e.g.
element in figure 3a .
grounding pattern when developers work through many episodes towards multiple subgoals they require grounding in order to reorient themselves to the larger goal.
the grounding pattern occurs when developers interact with a different set of artifacts than what is required for their current subgoal.
figure 3b shows information that participants found relevant in three episodes that adhere to the grounding pattern.
the first a1and a and last a a8 episodes are instances of grounding .
the second episode a a5 denotes an implementation which is then evaluated in the third episode.
we found that in this case information is relevant to individual episodes.
the information about the implementation from the second episode a a5 is no longer relevant once grounded as shown in the figure 3b.
in conclusion in a grounding pattern a working context exists temporarily.
once grounded the elements in the working context are no longer relevant .
concurrent pattern instances of the concurrent pattern occur when developers switch between subgoals before completing processes intended to address earlier subgoal s .
the concurrent pattern involves two consecutive episodes that do not share artifacts i.e.
developers work with two distinct sets of artifacts .in the concurrent pattern example described in section iv b3 p5 triggered a build subgoal and before the build could complete he began examining the code structure of a particular query command subgoal .
in this example the artifacts required for each subgoal are distinct and thus can be concurrently managed between episodes.
the concurrent pattern indicates that information from one subgoal is irrelevant to the other subgoal.
to verify this observation we asked participants to identify relevant information for actions taken across two concurrent subgoals.
the example for the concurrent pattern provided in the validation survey had four episodes across two subgoals shown in figure 3c .
the first a and third a a5 episodes share the same subgoal while the second a and fourth a 6and a episodes share a different subgoal.
figure 3c shows element red line and element purple line to be relevant for the episodes sharing the first subgoal.
whereas information for element blue line element green line and element orange line was relevant for the episodes sharing the second subgoal.
the separation between these distinct sets of information arising from their particular subgoals provides evidence that information flows between episodes with shared subgoals and not across episodes with separate subgoals.
from our observations two separate working contexts exist when a developer concurrently works on two distinct subgoals .
recursive pattern developers decompose their subgoals recursively into other subgoals.
in the recursive pattern each subgoal is associated with the next subgoal and thus a subgoal is likely to tangentially share artifacts across these subgoals.
for example p3 structured his task into three recursive subgoals.
however he interacted with three distinct sets of artifacts when working towards these subgoals.
figure 3d shows the five episodes structured into three recursive subgoals for a scenario with a recursive pattern.
the first a and the last a episodes share subgoal the second a and fourth a 4and a episodes share subgoal and the third a 3and a episode was directed towards subgoal .
participants indicated that information element blue line to be highly relevant in subgoal element red line to be relevant for subgoal and element blue line to be the most relevant for subgoal .
the figure indicates that information flows symmetrically around the lowest level of recursive subgoals.
in figure 3d the axis of symmetry resides at the a 4action with the first two episodes comprising a 1and a and the last two episodes comprising a 6and a residing within their respective halves of the recursive scenario.
additionally we see that information relevancy mirrors across the axis of symmetry with element red line and element blue line peaking in both halves and element purple line peaking around the axis.
based on survey responses we can conclude that for recursive subgoals developers manage distinct working contexts for each subgoal .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a sequential pattern b grounding pattern c concurrent pattern d recursive pattern e alternating pattern fig.
information relevancy and flow for episode patterns alternating pattern in this pattern developers switch between two subgoals of alternate solutions.
alternating subgoals have two distinct sets of artifacts which combinetogether as time moves forward.
this suggests that as devel opers progress with comparing alternate solutions informationgained from episodes targeting one subgoal can be used in future episodes targeting another subgoal.
for example p5 tried two alternate solutions to debug a missing dependency error.
for the first few episodes p5 interacted with separate artifacts for each subgoal.
however after the fourth episode p5 used a combined set of all artifactswhen working towards both subgoals.
figure 3e shows the information our participants perceived to be relevant across these five episodes that represent thealternating pattern.
for the first a a2 and third a a5 episodes information element red line and element blue line were considered more relevant.
for the second a and fourth a episodes information element purple line and element orange line were considered relevant.
in the last episode a participants indicated that a combination of information elements previously used separately were now relevant together.
this confirms our observation that in an alternating pattern information from episodes towards one subgoal will eventually be used towards another subgoal.thus in an alternating pattern developers start with two separate contexts that eventually combine into a single context.
v. r elated work a. task management perry et al.
conducted two empirical studies on the social and organizational processes of developers and foundthat developers work in two hour chunks spending most oftheir time on writing code and having unplanned interactionswith colleagues.
perlow conducted a qualitative study ofhow software engineers optimally use their time at work.
gon zalez and mark found work fragmentation is a common phenomena.
our observations also show work fragmentation among developers with total distinct work episodes.
meyer et al.
conducted two separate studies to investigate developers daily activities and observed that devel opers spend their time on a wide variety of activities switch ing regularly between them and that they perceive contextswitches to be generally harmful to productivity.
however o conaill and frohlich and hudson et al.
report that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in many cases interruptions can be beneficial and bring relevant information.
we find that developers don t just switch context they maintain context to various degrees across these switches based on their current subgoal.
information from both interactions and interruptions that developers perceive as important flow across related episodes.
b. information needs flow many researchers found that developers perceive questions about the rationale and intent of code was difficult to answer.
the majority of questions developers ask relate to the aggregation of information into and across context.
their findings show that developers have significant information needs which bolsters our research into understanding how developers manage context in their daily activities.
sillito et al.
conducted two qualitative studies of programmers information needs when performing change tasks.
they found that participants asked lower level questions as part of answering higher level questions.
they further noted that participants sometimes asked linear questions and other times branched out questions about the same entity.
we observed similar patterns in how developers structure their subgoals.
c. context management kersten and murphy introduce mylar a tool which captures the task context of program elements by monitoring the programmer s activity.
gasparic et al.
present a context model that includes thirteen contextual factors in four main categories who what where and when captured in various situations to enhance interactions within an ide.
fritz et al.
introduce a model that capture context through developers authorship and interaction information.
petcharat and murphy introduce spyglass which suggests tools to aid program navigation based on the context of their work.
sedigheh and murphy captures context through three factors discovery patterns recent command usage and elapsed time since last activity.
in this paper we investigate the effect of developer s intention of what they want to work on on how they maintain context.
we hypothesize that intention and interaction plays equally important roles when modelling context.
vi.
c onclusion and discussions our results show that individuals organize their development efforts into a series of episodes which form different patterns.
we found five such patterns sequential grounding concurrent recursive and alternating .
studying context at a smaller granularity the subgoal level is important as development efforts typically occurred at the episode level.
furthermore work thus far typically addresses how and when developers perform context switches when working across tasks and their associated cognitive loads .
we are the first to observe how context and portions thereof is maintained when developers move from one episode to another.
implications for researchers we found that patterns in episodes are associated with the type of development task.
for example debugging tasks were fast and furious involved shorter episodes and more switching across subgoals.
in contrast developers were much more deliberate when implementing or refactoring resulting in longer episodes and less frequent switches between subgoals.
further research is needed to understand the role of the environment or programming language in task decomposition.
while this was not our focus our survey alludes to this p1 working in java stated that he often performs recursive tasks and ranked recursive as his most frequent pattern.
task decomposition may also depend on individual differences in problem solving styles .
for example tinkerers who typically operate in small increments are likely to leverage the grounding pattern whereas planners are more likely to leverage the sequential pattern where they comprehensively process all information needed to solve a task and then decompose it methodically into smaltler organized subgoals.
further studies will allow us to better understand these differences and design tools that are inclusive to all problem solving styles.
we used the participants verbalizations to identify when subgoals changed.
while this worked well for our qualitative analysis an automated approach that identifies such boundaries will help in larger studies as well as building developer tools.
we plan to experiment with machine learning and natural language processing techniques to automatically identify subgoal boundaries.
implications for t ool builders modern recommendation tools typically leverage the relationships between artifacts to recommend other relevant artifacts.
our results indicate that episode patterns impact which artifacts are considered relevant for the current subgoal.
for instance in the sequential pattern an artifact was consistently used across all episodes.
in contrast in the recursive pattern artifacts lost and then gained relevance when developers switched between subgoals.
leveraging this correspondence between patterns and artifact relevancy can help improve context aware artifact recommendations.
another area of tool improvement is interruption management.
development of tools like flowlight operationalizes the notion of interruptibility of a developer by using a physical indicator to signal when they are busy.
however such tools either encode interruptibility as a function of time or some physical aspect of developer interaction such as typing speed.
in contrast the end of an episode or a subgoal is likely a better indicator of interruptibility.
this nuanced understanding of episode patterns and subgoal structures provide further opportunities to improve interruption notification.
acknowledgement we thank our participants for their time andr e van der hoek for his timely suggestions and the reviewers for their feedback.
we also thank phase change for their cooperation.
this work was funded by nsf and .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.