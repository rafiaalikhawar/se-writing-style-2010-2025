specifying event based systems with a counting fluent temporal logic germ an regis renzo degiovanni z nicolas d ippolitoyz nazareno aguirre z departamento de computaci on fcefqyn universidad nacional de r o cuarto argentina ydepartamento de computaci on fceyn universidad de buenos aires argentina zconsejo nacional de investigaciones cient ficas y t ecnicas conicet argentina abstract fluent linear temporal logic is a formalism for specifying properties of event based systems based on propositions called fluents defined in terms of activating and deactivating events.
in this paper we propose complementing the notion of fluent by the related concept of counting fluent .
as opposed to the boolean nature of fluents counting fluents are numerical values that enumerate event occurrences and allow us to specify naturally some properties of reactive systems.
although by extending fluent linear temporal logic with counting fluents we obtain an undecidable strictly more expressive formalism we develop a sound but incomplete model checking approach for the logic that reduces to traditional temporal logic model checking and allows us to automatically analyse properties involving counting fluents on finite event based systems.
our experiments based on relevant models taken from the literature show that i counting fluent temporal logic is better suited than traditional temporal logic for expressing properties in which the number of occurrences of certain events is relevant and ii our model checking approach on counting fluent specifications is more efficient and scales better than model checking equivalent fluent temporal logic specifications.
i. i ntroduction the increasingly rich set of tools and techniques for software analysis offers unprecedented opportunities for helping software developers in finding program bugs and discovering flaws in software models.
an essential part of these tools and techniques is the formal specification of software properties.
various formalisms and approaches have been proposed to specify properties of different kinds of systems.
in particular temporal logic has gained significant acceptance as a vehicle for specifying properties of various kinds of software systems most notably parallel and concurrent systems.
moreover temporal logic has also been employed in other domains to formally specify software requirements to express properties of hardware systems and other applications.
temporal logics are more directly applicable to system property specification when using a state based specification approach i.e.
when one is able to refer to state properties .
given the importance of event based formalisms such as csp ccs and fsp which are convenient in various specification settings in software engineering and have influenced a number of modelling languages including this work was partially supported by anpcyt pict and ubacyt and conicet pip 11220110100596co and by the meals project eu fp7 meals .concurrent system specification and architecture description languages some mechanisms have been proposed to capture state properties in event based systems.
a particular case which we use as a basis in this paper is that of fluents introduced in in order to ease the use of temporal logic for specifying properties of event based systems.
event based formalisms center specification around the notion of event which is used as a means to represent components behaviour and interaction e.g.
by expressing sending or receiving messages invoking component services etc fluents allow one to capture state propositions in these systems in terms of activating and deactivating events.
despite the success of temporal logic as a mechanism for specifying system properties and in particular properties of event based systems correctly capturing software properties is still an obstacle for many developers.
even though specification patterns help in this respect by proposing patterns for properties commonly arising in practice in many cases the inherent expressiveness of the logic makes it difficult or even impossible to express certain properties.
in this paper we deal with this issue by proposing counting fluent temporal logic an extension of fluent linear temporal logic which allows one to specify more naturally properties of reactive systems in which the number of occurrences of certain events is relevant.
counting fluent temporal logic complements the previously described notion of fluent by the related concept of counting fluent which as opposed to the boolean nature of a fluent which is a proposition represents a numerical value that enumerates event occurrences.
as we will show later on counting fluents enable one to capture more easily some properties that often arise in reactive system specification.
for instance counting fluents allow us to easily capture system properties referring to the difference between send and receive events or the number of clock ticks since the last sent message in communicating systems.
they also allow us to naturally capture bounded liveness and related properties of discretetime event systems.
such properties typically require complex nestings of temporal operators in linear temporal logic while we conveniently capture them using counting fluents.
it is generally accepted that a convenient language for specifying system properties is not enough such a language must be accompanied by powerful analysis mechanisms.
so appropriate automated tool support for our logic is a concern.
we show that although the introduced logic is an undecidable strictlymore expressive extension of fluent linear time temporal logic we can develop a sound but incomplete model checking approach for the logic that reduces to fluent temporal logic model checking enabling one to automatically verify counting fluent temporal logic properties of finite event based systems under user defined bounds for counting fluents.
thanks to our proposed model checking approach that is implemented in a tool extending ltsa the above described convenience of our introduced formalism for property specification is achieved without having to fully sacrifice automated analysability.
in order to evaluate our proposed formalism and model checking approach we performed various experiments based on relevant models taken from the literature.
our experiments show that i counting fluent temporal logic is better suited than traditional fluent temporal logic for expressing properties in which the number of occurrences of certain events is relevant and ii our model checking approach on counting fluent specifications is more efficient and scales better than model checking equivalent fluent temporal logic specifications.
the remainder of this article is organised as follows.
section ii introduces preliminary concepts necessary in the paper.
section iii presents some motivating examples that evidence the difficulties in expressing properties such as those mentioned before and the suitability of counting fluents to ease these properties specification.
section iv describes counting fluent temporal logic in detail.
we present the model checking approach in section v. in section vi we evaluate our proposed formalism and model checking approach.
finally we discuss related work in section vii and present our conclusions in section viii.
ii.
b ackground labelled transition systems lts are typically used to model the behaviour of interacting components characterised by states and transitions between them .
formally a lts pis a quadruplehq a q 0i whereqis a finite set of states ais the alphabet ofp a subset of the universe actof events q a f g qis a labelled transition relation and q02qis the initial state.
the semantics of a lts pcan be defined in terms of its executions i.e.
the set of sequences of events that pcan perform starting in the initial state and followingp s transition relation.
finite state processes fsp is a process algebra whose expressions can be automatically mapped into finite lts and vice versa.
in fsp specifications denotes event prefix denotes choice and conditional choices can be expressed by means of when clauses.
processes may be indexed and parameterised and can be composed in a sequential or parallel way .
fluent linear time temporal logic fltl is a variant of ltl well suited for describing state properties of event based discrete systems e.g.
lts .
fltl extends ltl by incorporating the possibility of describing certain abstract states called fluents characterised by events of the system.
miller and shanahan informally define propositional fluents as time varying properties of the world .
formally fl hi t bidefines a fluent fl wherei t a i t andb2 ftrue falseg.bindicates the initial value of fl.
when any event in ioccurs the fluent starts to be true and it becomes false again when any event in toccurs.
if the term bis omitted then flis initially false .
it is possible to combine fluents and events in fltl formulas.
specifically every event ehas a fluent fleassociated whose initial set of actions is the singletonfegand whose terminating set is anfeg.
a fltl formula is a ltl formula where propositions are fluents.
given a set of fluents well formed fltl formulas are defined inductively using the standard boolean operators and the temporal operators next andu strong until in the following way i everyfl2 is a formula and ii if and are formulas then so are u .
we consider the usual definition for the operators always eventually andw weak until in terms of andu and boolean connectives.
iii.
m otivating example we will start to motivate our work in this paper with the single lane bridge problem slb a modelling problem introduced in cf.
section .
therein .
the problem consists of a narrow bridge which only allows for a single lane of traffic which must be appropriately controlled to avoid safety violations.
as one may expect a safety violation occurs if two cars moving in different directions are on the bridge at the same time.
in order to simplify the presentation of the problem cars moving in different directions are represented by different colours red and blue cars.
const n number of each type of car range t ..n type of car count range id ..n car identities bridge bridge initially empty bridge nr nb is the red blue counter when nb red .enter bridge red .exit bridge when nr blue .enter bridge blue .exit bridge .
nopass1 c c .enter c .
nopass2 c c .exit c .
car enter exit car .
car definition convoy car nopass1 nopass2 .
cars red convoy blue convoy .
singlelanebridge cars bridge .
in this model the car process specifies a simplified behaviour of a car with respect to the bridge.
process bridge is essentially what controls the access to the bridge it prevents cars in one direction entering the bridge when cars in the opposite direction are already on the bridge.
the nopass processes strengthen the model avoiding cars to pass over on the bridge.
finally the system is modelled as the composition of the bridge process with the instances of cars specified by means of processes convoy andcars .
the safety property associated with this model requires expressing that it should never be the case that red and blue cars are on the bridge at the same time.
to specify this property as put forward in we need to express whether there is at least one car of each colour on the bridge.
following the solution presented in we take advantage of the cars identifiers id and define one fluent per car namelyred andblue to indicate whether the corresponding car is on the bridge or not.
that is for instance for red cars we have red red .enter red .exit .
then the required safety property is specified as follows oneway red red red blue blue blue notice how in this case we are capturing the fact that there is more than one car of a given colour on the bridge through a parameterised disjunction whose size depends on the number of cars allowed in each direction often a parameter of a bounded model abstraction of a real world situation .
we will come back to this property below.
to continue our motivating example let us suppose that we have to impose an additional constraint on the bridge model.
besides the fact that due to the bridge s width cars circulating in different directions must be forbidden assume that the bridge has a maximum weight capacity.
exceeding this capacity is dangerous so the maximum number of cars on the bridge must also be controlled.
notice that although this restriction was not part of the original model such a constraint is common in this kind of models see for instance the ornamental garden bounded buffers producers consumers and readers and writers from .
the controller for the bridge must now forbid new cars entering the bridge when the maximum capacity is met which can be achieved as follows const c maximum capacity of the bridge bridge bridge initially empty bridge nr nb is the red blue counter when nb nr c red .enter bridge red .exit bridge when nr nb c blue .enter bridge blue .exit bridge .
... now we would like to express the fact that this controller ensures the bridge s safety i.e.
that the number of cars on the bridge never exceeds the bridge s capacity.
we may take advantage of the previously introduced fluents that capture the fact that a particular car is on the bridge to attempt to capture this property.
but as the reader may realise this property is more difficult to specify since the number of possible scenarios to consider taking into account that all interleavings of entering and leaving events have to be considered is in principle infinite.
nevertheless assuming that the previously specified oneway property holds we can specify the bridge s weight safety as the following property capacity safe red red red red red red red red red red red red blue blue blue blue blue blue blue blue blue blue blue blue as the reader may notice this formula grows quickly as the number of cars and the bridge capacity are increased.
more precisely the number of disjunctions in this formula is in this case the sum of the combinatorial numbers between the size of each convoy and the bridge s capacity.
notice that even for small models this kind of property clearly related to the need of counting cars on the bridge in this case in fltl can become tricky and complicated.to address these problems we propose to introduce the concept of counting fluent .
suppose that we have the possibility of defining numerical values that enumerate event occurrences.
for instance cars on bridge may be a numerical value that keeps count of the number of cars red or blue on the bridge.
this value is initially is incremented at each occurrence of an enter event and is decremented at each occurrence of an exit event.
using cars on bridge we can express the weight safety property of the bridge in a more natural way as follows capacity safe cars on bridge capacity let us now go back to the oneway property.
assuming the definition of numerical values red cars on bridge and blue cars on bridge that keep count of the red and blue cars on the bridge respectively this property can be specified as follows red cars on bridge blue cars on bridge our motivating example illustrates two issues.
first it shows that situations in which counting events is useful are common.
second although some properties related to the number of times certain events occur or are allowed to occur may be expressed in ltl or fltl their specification can be cumbersome.
the reader familiar with the formalisms used in this section may be aware that in some cases one can simplify the specification of a property by introducing in the model some property related elements e.g.
events that are only enabled when a safety property is violated and resorting to these elements in the expression of the property.
this is a common workaround that we believe should be avoided whenever possible since it mixes the actual model with property related elements making it harder to understand and is less declarative i.e.
reasoning about the property s meaning requires dealing both with an operational part that incorporated in the model and a declarative part that expressed in the logic .
as we will discuss later on incorporating counting fluents is not a mere syntactic sugar on fluent linear temporal logic.
in fact the resulting logic is strictly more expressive than fltl.
its associated advantages are to ease the specification of properties that involve counting events in some way as we have shown in this section even enabling us to express some properties not expressible in fltl and allowing for a cleaner separation of concerns between models and properties as we will discuss in section vi.
this has a potentially positive impact on understandability especially taking into account some modern approaches to system description that involve operational component specifications and constraints on their concurrent interactions.
iv.
c ounting fluent ltl to describe more naturally properties of reactive systems in which enumerating the occurrences of certain events is relevant we introduce counting fluent temporal logic cfltl an extension of fluent linear temporal logic which complements the notion of fluent by the related concept ofcounting fluent .
similarly to fluents counting fluents represent abstract states in event based systems whose values depend on the execution of events.
but as opposed to fluents which are logical propositions counting fluents are numerical values associated with event occurrences.
formally a counting fluent cflis a tuple defined by three sets pairwise disjoint of events and an initial numerical value as follows cfl hi d riinitiallyn setiis the incrementing set ofcfl i.e.
when an event of this set is executed the value of cfl is incremented by one.
on the other hand drepresents the decrementing set ofcfl and in this case the value of cfl is decremented when one of these events occurs.
finally ris the resetting events set whose execution changes the value of cflto its initial value .
counting expressions are logical expressions that relate counting fluents necessary to deal with their numerical nature.
they can be combined with logical and temporal operators to specify cfltl formulas.
for instance a counting expression can compare the values of two of counting fluents or query for the value of a particular counting fluent.
formally given a set of counting fluents and cfl1 cfl a valid counting expression is defined as follows cfl1 cjcfl1 cfl2jcfl1 cfl2 c wherec2nand 2f g. expressions that involve just one counting fluent are called unary expressions while the others are called binary expressions.
notice that counting expressions are boolean valued they predicate on the values of counting fluents at some point.
thus counting expressions can be used as base cases for formulas.
we define the set of well formed cfltl formulas as follows every counting expression is a cfltl formula every propositional fluent fis a cfltl formula and if 1and 2are cfltl formulas then so are 1 1u and the usual derived definitions for 1and 1w .
in order to interpret cfltl formulas first we introduce an interpretation for counting fluents.
let be a set of counting fluents.
an interpretation for is an infinite sequence over n that for each instant of time assigns a value for each counting fluent.
given an infinite trace w a1 a2 we define the function vi w cfl that denotes the value of the counting fluent cfl2 at positioni2n as follows vi w cfl nifi n r k iai2i r k iai2d ifi whereris the maximum l with l i such thatal2r or0 if8l l i al62r.
functionvi wassigns to each fluent cfl its initial value at the beginning of the execution and the value at any other instant of time is obtained by adding to its initial value the number of occurrences from its last resetting event occurrence of its incrementing events and subtracting the number of decrementing events.
notice that similar to propositional fluents our counting fluents areclose on the left and open on the right since their values are updated immediately when a relevant event is executed.
we consider the usual fltl interpretation for propositional fluents logical and temporal operators .
then to obtain a complete interpretation of cfltl formulas we define the semantics for the counting expressions as follows w ij cfl c vi w cfl c w ij cfl1 cfl2 c vi w cfl1 vi w cfl2 c wherec2n 2f gand the symbols and of the right hand side represent the corresponding relation or operation on natural numbers.
notice that the expression cfl1 cfl2can be defined as a particular instance of the expressioncfl1 cfl2 .
a. cfltl vs. ltl let us compare cfltl and ltl in terms of expressiveness and decidability.
it is well known that the expressive power of ltl is equivalent to that of counter free b uchi automata .
intuitively an automaton is counter free if it cannot express for instance if a symbol a is repeated ntimes in an infinite sequence.
cfltl then results to be strictly more expressive than ltl since such counting property can straightforwardly be specified in cfltl by using a counting fluent that counts the number of a s. regarding decidability in it is proven that if ltl is extended with diagonal constraints i.e.
expressions of the form k then it becomes undecidable.
this kind of properties are also directly expressible in cfltl turning it into an undecidable logic.
in the next section we develop a sound but incomplete model checking approach for cfltl which shows that our greater expressive power does not make us fully sacrifice automated analysability.
v. a m odel checking approach cfltl may be suitable to express properties of reactive systems.
however its adoption would be seriously affected by the lack of analysis mechanisms for the logic.
model checking provides an automated method for determining whether or not a property holds on the system s state graph that is available for fltl.
we study in this section how to perform model checking of cfltl properties over systems described via lts as is the case of fltl model checking .
at this point the undecidability of cfltl leaves us with two choices.
we can search for a decidable fragment of cfltl or we can keep the full expressive power of cfltl and try to define an inherently incomplete due to the logic s undecidability model checking mechanism for the logic.
we follow the latter in this section.
in order to be able to define a model checking procedure it is important to guarantee finiteness of the model and properties being analysed.
compared to fltl our only potential source of unboundness may come from counting fluents.
in order to keep counting fluents bounded we propose restricting them with bounds and scopes two kinds of numerical limits to counting fluents which we describe in detail below.given the limits to the counting fluents our approach is based on the definition of a process that monitors the occurrence of the events that update the states of the counting fluents present in the property being analysed.
a monitor process activates propositional fluents that capture the truth value of the fluent expressions of the properties formulas when relevant events occur.
finally cfltl formulas are encoded as fltl formulas by replacing the counting expressions with corresponding propositional fluents and considering states in which monitors are updating fluent values as unobservable.
the described approach to cfltl model checking allows us to verify properties containing counting expressions using ltsa .
labelled transition system analyser ltsa is a verification tool for concurrent systems models.
a system in ltsa is modelled as a set of interacting finite state machines.
ltsa supports finite state process notation fsp for concise description of component behaviour and directly supports fltl verification by model checking.
syntactically we propose counting fluents to be defined via the following syntax extending ltsa s syntax for propositional fluents hcfluentdef i cfluent hfluent name i hfluent bounds i hincremental events seti hdecremental events set i hreset events set i initially hinitial value i hfluent bounds i j where brackets andparentheses are used to indicate the kind of limit bound andscope respectively on the corresponding counting fluent.
a. bounds and scopes abound is a limit that arises as part of modelling and comes from an actual constraint on the system being specified.
for instance suppose that we are modelling a mobile phone whose volume is restricted to be at most max .
relating this value to events clearly once max is reached further presses on the increase volume button have no effect on the volume and therefore can be ignored at least regarding what concerns the behaviour of the mobile phone .
a counting fluent associated with increasing the volume can then be restricted bymax as its largest possible value.
unbounded counting fluents on the other hand must be limited by scopes to maintain the analysis being fully automated.
as an example of an unbounded counting fluent that will have to be limited by a scope consider an ack in a model of a tcp protocol see the example presented in section vi .
as opposed to the case of bounds which are part of the model scopes are necessary due to analysis reasons .
when a lower resp.
upper bound is reached decrementing resp.
incrementing events are ignored i.e.
the value of the counting fluent remains the same.
when a lower resp.
upper scope is reached analysis becomes inconclusive .
that is exceeding a scope during analysis corresponds to reaching fluent overflow states and thus from models with reachable overflowed states nothing can be inferred neither the validity of the property nor the construction of a counterexample.b.
model checking letsys and be a fsp specification of a system and a cfltl property respectively and suppose that contains fluent expressions.
in order to perform the verification process using ltsa our approach generates a new fsp process sys and a fltl formula such that sys incorporates the monitor process that updates the values of the counting fluents and 0encodes the propositional fluents associated to each counting expression.
the construction of sys and 0ensures that every counterexample for 0insys is a counterexample for insys.
formally sys06j fltl sys6j cfltl .
below we describe our approach consisting of constructing the monitor and the encoding formula .
monitors for counting fluents intuitively a monitor keeps track of the values of the counting fluents within its bounds scopes that appear in a counting expression.
for instance in the case of a unary expression cfl c the monitor records the value of counting fluent cfl.
sys is obtained by the parallel composition of the system sys the monitor process cfmon and a synchroniser process synch .synch is a scheduler process that avoids the interleaving between the events of the system and the updating monitor events as depicted in the fig.
.
the specification of synch is shown in fig.
where evs is the set of all system events monevs is the set of all events ofsys which are monitored cfevs is the set of updating events of the cfmon process and ko ok are events of the monitor indicating that the update process is being carried out.
system monitorevse kocfevseokevse fig.
.
behavioural view of sys .
synch evs monevs synch monevs ko cfsynch cfsynch cfevs cfsynch ok synch .
fig.
.
fsp spec.
for synch .
basically the monitor considers the system s events involved in the formula being verified.
the monitor process contains one parameter for each counting fluent appearing in .
the process body is composed of cases choices considering monitored events of the system and as guards conditions regarding values of the corresponding counting fluents.
each case triggers a sequence of updating events ending with the okevent indicating that the updating process was completed.
the new values for the counting fluents parameters of the monitor are calculated in terms of the membership of the event to the incrementing decrementing or resetting event sets of the corresponding counting fluent definitions.
in case some parameter is in a boundary situation i.e.
when the counting fluent value reaches its lower upper limit the process case has one of two possibilities depending on the kind of limit.
if the limit is a scope we trigger the fluent overflowevent otherwise i.e.
the limit is a bound we maintain the expression value on its lower upper bound.
note that for every event of the original system the monitor process has cases whose condition guards disjunction is always true i.e.
we consider all their possibilities.
by extending the alphabet with the events not considered for fluent value update this situation ensures that the process is non blocking with respect to the original system behaviour sys.
the additional cost introduced by the monitoring task in sys depends on the formula to be analysed.
in terms of state space it is in the worst case the product between the number of monitored system events monevs and the size of the monitor process cfmon all possible combinations of the counting fluent values.
encoding cfltl formulas due to unbounded counting fluents cfltl model checking may return one of the following answers i false when a counterexample is found within the provided scopes ii true when the property has been proven to hold within the scopes and no fluent overflow was reached and iii maybe no counterexample was found within the scopes and a fluent overflow state was reached.
in order to verify a cfltl formula using ltsa we encode it as a fltl formula 0which captures the truth values of the counting fluent expressions with propositional fluents.
thus for each counting fluent expression we define a propositional fluent which is activated by the event update value of the monitor that satisfies the expression.
as an example if an expression has the form cfl c then its corresponding propositional fluent is defined by h i. notice that there exist some states in sys in which must not be evaluated namely when the monitor is updating the counting expression values or a fluent overflow state has been reached.
to avoid the analysis on these states we define the notion of observable states as those that satisfy obs ok f overflow where the fluent f overflow indicates that a counting fluent has overflowed.
with this notion the last step of the construction of 0is based on the translation introduced in to guarantee the exclusion of the non observable states in the analysis of the validity of in a model.
for instance if then obs!
.
in order to illustrate our model checking process let us consider the specification of the slb problem presented in section iii and the safe capacity property to be verified.
we define the counting fluent cars on bridge as follows cfluent cars on bridge ..c red .enter blue .enter red .exit blue .exit initially where cis the constant representing the capacity of the bridge.
the monitor process generated for the formula is cfmon cfmon b cfmon b when i c red .enter blue .enter carsonbridge ok cfmon b when i c red .enter blue .enter fluent overflow ok cfmon b when i red .exit blue .exit carsonbridge ok cfmon b when i red .exit blue .exit carsonbridge ok cfmon b .finally the encoding formula c instantiated with value and the propositional fluents capturing the values of the corresponding counting expression are the following fluent cars on bridge less 3 carsonbridge carsonbridge initially true fluent ok ok ko initially true assert safe capacity ok !f overflow cars on bridge less 3 verification suppose that the encoding formula 0was successfully verified over system sys i.e.
no counterexample was found within the user provided limits for counting fluents.
then our approach proceeds to check if sys can reach an overflowed state analysing the formula foverflow .
if it is verified over sys i.e.
the event fluent overflow is never executed then the scopes are big enough to cover the whole state space of the system so no counterexample of 0exists.
that is our approach guarantees in this case the validity of property insys and returns yes to the verification problem.
on the other hand if an overflowed state is reached our approach answers maybe indicating that no counterexamples were found in the state space explored but such space is not the whole state space of the system a fluent overflow is reachable .
this situation may be solved by increasing the scope.
our model checking approach is supported by the following lemmas.
given a set of events evs anda evs let us denote byjathereduction function such that given a trace overevs jareturns the trace obtained by ignoring the occurrences of events e2ain .
moreover let sys and sys be the sets of execution traces of the lts of processes sys andsys respectively.
consider that set cfset contains all events performed by the monitor cfmon .
then the following lemmas hold.
lemma .
for every sys there is a sys such that jcfset.
lemma .
let sys and be a counting fluent expression.
then for every position i ij obs fl ij .
lemma .
expresses that within the bounded situations described earlier in this section the truth value of a counting fluent expression is captured by the corresponding propositional fluent generated over the monitored system.
due to space restrictions these lemmas proofs are not reported here.
for a more detailed description of the model checking process we refer the reader to the technical report available at .
an extension of ltsa that supports cfltl and implements our model checking approach is available at .
vi.
e valuation in this section we evaluate our proposal answering these two main research questions rq1 is counting fluent temporal logic better suited than traditional fluent temporal logic for expressing properties in which the number of occurrences of certain events is relevant?
rq2 how efficient is our model checking approach with respect to model checking equivalent fluent temporal logic specifications?in order to answer these questions first we present several examples from the software engineering literature where the need of counting events arises and is addressed in our opinion unsatisfactorily.
we show for each one that counting fluents are well suited to formalise properties in which the occurrences of certain events must be measured and allows for a cleaner separation between the behavioural models and the required properties that otherwise would be tangled together to support verification.
we evaluate the quality of cfltl specifications with respect to two metrics succinctness and modifiability .
to assess succinctness and modifiability we consider properties taken from the case studies and evaluate how concise cfltl formulas are with respect to their original fltl counterparts and evaluating the complexity of introducing reasonable changes into the original specification and the one developed by us in cfltl.
finally we evaluate our model checking approach on several case studies that involve counting fluent specifications under different configurations and compare its efficiency against model checking equivalent fluent temporal logic specifications.
elevator in the following informal requirement for an elevator controller is mentioned between the time an elevator is called at a floor and the time it opens its doors at that floor the elevator can arrive at that floor at most twice.
this property was formalised using ltl as follows noignore twice call 3open !
atfloor open u open atfloor open u open atfloor open u open atfloor open u open atflooruopen dwyer et al.
argued that it is really difficult to convince oneself that this property captures exactly what is wanted.
in order to capture this property we define the counting fluent atfloor that counts the occurrences of the atfloor signal after a user called the elevator and specify the property through a cfltl formula atfloor hfatfloorg fg fcallgiinitially noignore twice call open !
atfloor 2uopen timed light let us consider another simple example a timed light system presented in where a light turns off automatically after time units.
usually in discrete time eventbased systems the progress of time is modelled with a tick event.
then using the counting fluent t htick fg oni we are able to capture some interesting timed properties for this system eventuallyofforpush on!
t off push intuitively counting fluent tcounts the occurrences of tick after the light is turned on.
property eventuallyofforpush expresses that when the light is turned on it will be eventually turned off within time units except if a push event occurs during that time.
using the translation rules from boundedfltl into fltl presented in the above timed property can be specified in fltl as follows eventuallyofforpush on!
tick tick tick tick tickw off push w off push w off push w off push w off push atm consider the model of an atm machine depicted in figure taken from .
10enterpwdbadpwdenterpwdbadpwd 8insertcardenterpwdbadpwdlockacctunlockacctcorrectpwdcorrectpwdcorrectpwdmoneytakecard fig.
.
lts that models the atm s behaviour.
initially the atm requests the user to insert a card and enter the password pwd .
the validity of the password is verified and if this verification succeeds the user can extract money and remove the card from the atm.
otherwise when the password is incorrect the atm system starts counting the number of successive mistakes made by the user.
a typical security mechanism that atms implement consists of blocking account access when the user makes three consecutive mistakes at entering his password.
in order to check whether the atm correctly implements this security mechanism we may specify the following cfltl property errors hfbadpwdg fg fcorrectpwd unlockacctgiinitially nowrongextraction errors money intuitively property nowrongextraction expresses that it cannot be the case that after three consecutive wrong password insertions the user extracts money.
this property can be specified in fltl in the following way badpass hfbadpwdg fcorrectpwd unlockacctgi nowrongextraction badpwd badpassu badpwd badpassu badpwd badpassumoney notice that despite the fact that fltl is expressive enough to specify this property the encoding is not straightforward.
the main problem lies in the complex nesting of logical and temporal operators needed to represent the number of times thatbadpwd was executed.
tcp sliding window consider the tcp network protocol a protocol that provides reliable in order delivery of packets in packet based data transmission.
figure shows a lts that models the behaviour of a single packet along a tcp network communication with its usual semantics.
we represent the traffic in a network combining the behaviour of various packets packs .
the tcp protocol has been improved many times to optimize network transfer.
in particular the tcp sliding window protocol dynamically modifies the window size depending on the channel s reliability.
the term window refers to the number of packets that can be sent without receiving their corresponding