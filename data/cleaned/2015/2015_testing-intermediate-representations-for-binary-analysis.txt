testing intermediate representations for binary analysis soomin kim markus faerevaag minkyu jung seungil jung dongyeop oh jonghyup lee sang kil cha kaist republic of korea soomink mfaerevaag hestati sijung oh51dy sangkilc kaist.ac.kr gachon university republic of korea jonghyup gachon.ac.kr abstract binary lifting which is to translate a binary executable to a high level intermediate representation is a primary step in binary analysis.
despite its importance there are only few existing approaches to testing the correctness of binary lifters.furthermore the existing approaches suffer from low test coverage because they largely depend on random test case generation.
in this paper we present the design and implementation ofthe first systematic approach to testing binary lifters.
we have evaluated the proposed system on state of the art binary lifters and found previously unknown semantic bugs.
our resultdemonstrates that writing a precise binary lifter is extremely difficult even for those heavily tested projects.
i. i ntroduction understanding binary code is crucial in software engineering and security research.
source code is not available when it comes to commercial off the shelf cots software malware or legacy code.
even if we have access to the sourcecode we cannot trust it when the compiler is not in the trustedcomputing base .
last but not least even a trusted compilercan produce binary code that is semantically different from thesource code .
in the past few decades there has been much research on binary code analysis and its applications including binaryinstrumentation binary translation software hardening software testing cpu emulation malware detection automated reverse engineering and automatic exploit generation .
the very first step in binary analysis is to convert a binary executable into an intermediate representation ir whichprecisely represents the operational semantics of the binarycode.
such a process is often referred to as binary lifting and nearly all of the above approaches involve binary liftingeither explicitly or implicitly.
the converted ir is the basisfor any binary analysis techniques.
therefore any bug in theresulting ir can immediately invalidate the binary analysisresults.
a taint based malware detection system can reportfalse alarms.
instrumented programs can fail or even crash.
forexample a single ir bug in qemu indeed resulted in a failureof the entire system emulation .unfortunately engineering a precise binary lifter is notoriously difficult.
first the volume of an instruction set manualis too large to comprehend.
for example the manuals forintel and arm currently consist of and 354pages respectively at the time of writing.
even worse thenumber keeps increasing as new cpu features are introduced.furthermore the semantics of cpu instructions are ofteninformally and vaguely defined in natural language.
finally there are undefined or undocumented semantics that are im plemented on a real cpu.
thus developers often write irson a trial and error basis which is error prone.
despite these issues there has been surprisingly little effort on testing the correctness of binary lifters.
the most relevantwork to date is that of martignoni et al.
which attempted to leverage differential testing on qemu andbochs .
particularly they compared the state between aphysical and an emulated cpu after executing randomly cho sen instructions on both to discover any semantic deviations.
although their technique can be applied to testing binary lifters it is fundamentally limited because its effectivenesslargely depends on randomly generated test cases.
typically semantic bugs in binary lifters are triggered only with specificoperand values.
therefore a random test case generation doesnot help much in finding such bugs.
for example the bsf instruction of x86 searches the source operand for a leastsignificant set bit within a while loop that checks one bit at a time.
there are different numbers of loop iterationspossible but it is unlikely that randomly generated test caseswould cover all such cases.
let us suppose there exists asemantic bug in an ir of bsf instruction when the maximum number of iterations is reached.
this condition canoccur only when the source value is and the probability of generating the buggy operand value at random is .
the key question that motivated our research is can we test binary lifters without relying on randomly generated testcases?
one potential approach is to use traditional formalverification .
particularly we can build a symbolic formulathat encodes all execution paths of an ir instance lifted froma single machine instruction.
we then check if the symbolicformula matches the formal specification of the instruction.
.
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research353 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
although this is a totally plausible approach there is no such formal specification available for modern cpus.
in this paper we propose a novel approach to finding semantic bugs in binary lifters called n version ir testing.
our approach is inspired by n version disassembly where the outputs of independently developed disassemblers are compared to each other for a given input binary inan attempt to find bugs in disassemblers.
unlike n version disassembly however we do not syntactically compare theoutputs of the lifters under test.
instead we formally check thesemantic equivalence between ndistinct irs obtained from a single binary instruction.
therefore any semantic discrepancy means that there is at least one semantic bug on the liftersunder test.
furthermore our approach does not rely on randomtest cases as in the previous approaches.
meandiff implements this idea to find semantic bugs on existing binary lifters.
applying it to existing binary lifters found previously unknown semantic bugs which wereall manually confirmed and reported to the developers.
ourexperience shows that buggy irs are widely used in existingbinary analysis techniques and tools and can affect theirprecision.
although our current implementation is specific to x86 and x86 the proposed technique is general and can beapplied to other instruction set architectures.
overall this paper makes the following contributions we systematically study the characteristics of existing intermediate representations generated from opensourced binary lifters.
we propose n version ir testing the first systematic approach to finding semantic bugs on binary lifters.
we design and implement a fully automated system called meandiff which can evaluate the correctness ofbinary lifters.
we make our source code public at .
we test state of the art binary lifters and demonstrate the effectiveness of our system in terms of finding newsemantic bugs.
ii.
b inary analysis and ir this section presents the motivation behind our research by discussing why ir is essential in binary analysis.
we first start by defining several terminologies.
we then describe the characteristics of irs and summarize the current state of the art binary analysis tools.
a. notation we let l isabe an instruction set architecture isa and lirbe an intermediate representation ir .
we use a superscript to specify the name of an isa or an ir.
for example lx86 isameans x86 assembly language and lvex ir is vex ir.
an instance of an ir is a sequence of statements defined in the semantics of the ir.
we also call each statement in an ir instance as an ir statement.
we denote a symbolic execution context by .
a symbolic execution context is a map from a variable name to a symbolicexpression e.g.
denotes the symbolic expression that corresponds to a key k. in our model we also consider amemory cell as a variable.
we denote by prime an operation over two execution contexts which returns a map that includesbindings in prime but excludes bindings in .
a set of keys in can be accessed by keys function keys .
the number of bindings in an execution context is .
a symbolic evaluation function erevaluates an ir statement generated by a tool r under a specific execution context.
for example er s is a function application that evaluates an ir statement s lr irunder the given execution context which returns an updated execution context.
b. representing the semantics of binary code understanding binary code is difficult.
although cpu manuals describe the meanings of machine instructions in natural language there exists no formal specification for them.furthermore descriptions vary depending on the version of the manual and binary instructions typically have implicit semantics that are not obvious from their syntax.
as an example consider the following x86 instruction that increments the value of the ecx register by one inc ecx.
although it is not obvious from the machine code the instruction can directly affect the value of the eflags register.
specifically there are six status flags in the eflags zf cf pf af sf andof which can change their values based on the computational result of the instruction.
notice aprogram can change its control flow depending on the valuesof the status flags.
in addition the number of affected statusflags can also differ depending on the operation.
from theexample instruction only five status flags excluding cfcan change after executing the inc instruction.
binary lifting denoted by is an action that describes the whole semantics of low level binary code in a high levelintermediate representation ir .
we define the term moreformally as follows.
definition binary lifting .
binary lifting is a function r s ls isa lr ir where sis the name of an isa and ris the name of a target ir.
for example vex x86 is a function that takes in x86 binary code as input and returns a translated vex instance.
vex x86 0x41 returns a lifted ir instance shown in figure 1b from a binary instruction 0x41 which is inc ecx when decoded.
we call a tool that performs binary lifting as a binary lifter.
since the seminal work by cifuentes et al.
various binary lifters have been proposed to date.
in this paper we define a term called binary based ir bbir to distinguish two kinds of irs one from binary lifters and another from compilers.
the distinction betweenbbirs and classic irs from compiler theory is mainly fromtheir expressiveness.
irs derived from source code representhigh level language abstractions such as functions and loops.
however bbirs do not need to consider such language constructs in their abstract syntax tree.
most binary analysistools such as bap and valgrind indeed define their own bbirsin order to express the low level semantics of binary code.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table open sourced binary based irs.
ir name tool name explicit self containeddisasm dependency x86 x86 64fp supportsimd supportprogramming languageintroduction y ear bil bap leftcircle circle ocaml dba binsec ocaml esil radare2 circle c llvm remill leftcircle circle circle c microcode insight c reil binnavi java sage iii rose ida pro leftcircle circle leftcircle circle c sslboomerang c jakstab circle circle java tcg qemu circle circle c vexpyvex circle circle python valgrind circle circle c vine bitblaze leftcircle circle c ocaml the earliest release we found is binnavi .
in .
this is when tcg was first introduced in qemu .
the binary support of the rose is first presented in .
the initial version of valgrind uses an ir called ucode.
1v1 low 2ecx low 0x1 3of high high high high 5af 0x10 0x10 low v1 0x1 7pf low 0x4 low in let v3 v3 0x2 v3 in v3 0x1 v3 11sf high 12zf 0x0 low a a lifted ir instance of bap .
1t2 get i32 ecx 2t1 add32 t2 0x00000001 3t3 get i32 cc op 4t4 get i32 cc dep1 5t5 get i32 cc dep2 6t6 get i32 cc ndep 7t7 x86g calculate eflags c t3 t4 t5 t6 ity i32 8put cc ndep t 9put cc op 0x00000012 10put cc dep1 t 11put cc dep2 0x00000000 12put ecx t 13put eip 0x00000001 ijk boring b a lifted ir instance of valgrind .
fig.
.
bbir instances lifted from an x86 instruction inc ecx.
in a low means taking low bit value from x and hex integers are represented with their bit width.
definition binary based ir .
a bbir is an ir that is used to represent lifted ir instances from binary code.
c. current state of the art binary lifters we survey the existing binary lifters that are open sourced and characterize them based on several criteria.
as such we define two notions to describe bbirs explicitness andself containment.
both characteristics play an important rolein binary analysis.
the explicitness helps in performingcontrol and data flow analyses and the self containmentallows analyzing binaries without having an undesirable over approximation.
first the explicitness of a bbir instance indicates whether each ir statement updates only a single variable in theexecution context .
recall from ii a that an execution context is a set of variables in our model.
figure 1a showsa bil instance lifted from an x86 instruction inc ecx by bap.
each statement of the instance can only update a singlevariable in the execution context.
we say the ir instance isexplicit.
we now formally define the explicitness of an irstatement as follows.
definition ir explicitness .
given a binary instruction i l s isaof an isa s an instance of an ir rlifted from iis explicit iff.
s r s i er s .
being explicit is not always beneficial in terms of expressiveness.
for example vex has a compare and swap cas statement which guarantees an atomic swap operation.specifically cas checks if the target memory has a specific old value and only if the value matches swap the memory value with a given new value.
by definition compare andswap operations e.g.
xchg instruction of x86 are not explicit because they change both the source and the destination.valgrind can easily support such an instruction with a singleir statement because it uses an implicit ir.
but bap requiresmultiple ir statements to express such an operation.
another important criterion we consider is self containment which essentially shows whether a lifted ir instance com pletely explains the semantics of the corresponding binarycode.
for example qemu often relies on external functionsto express the semantics of a binary instruction.
consider alogical and instruction of x86 pand xmm0 xmm1.
when authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we lift the instruction to tcg the bbir of qemu the ir instance simply passes both register values to an externalfunction called pand xmm instead of articulating its operation within the semantics of the ir.
in this case we say that the ir instance is notself contained because it has a side effect.
definition ir self containment .
given a binary instruction i l s isaof an isa s an instance of an ir ris selfcontained iff.for all ir statement s r s i er s is determined without any side effect.
since tcg is designed for cpu emulation it does not need to be self contained for its own purpose external functions in a tcg instance can simply be evaluated at runtime.
the same design decision appears in other irs such as vex.
however if an ir is not self contained analysts need to implement arule for every external function in the lifter in order to writean analyzer which requires a significant engineering effort.
figure shows two bbir instances lifted from an x86 instruction inc ecx.
first the ir instance from bap figure 1a has seven assignment statements in total including the ones for the status flags of the eflags.
the ir instance is explicit because every ir statement affects only a single value of the cpu state at a time.
the ir instance is self contained because the ir instance completely contains thewhole semantics of the instruction.
on the other hand the vex instance obtained from the same instruction figure 1b using valgrind is neither explicitnor self contained.
in line there is a call to an externalfunctionx86g calculate eflags c which computes all the status flags and returns the result in a single integer.
since it uses an external function it is not self contained.
furthermore valgrind does not directly refer to the status flags.instead it uses variables cc op cc dep1 cc dep2 andcc ndep that store abstract information about the machine status such as what is the most recently used operation.this is to efficiently compute the eflags only when it is needed.
however such an abstract variable represents multiplevalues e.g.
values of status flags in the context of a real cpu.therefore the ir is implicit.
table summarizes the current state of the art binary lifters and their bbirs.
the first and the second column of the tableshow the names of bbirs and binary lifters respectively.
thethird column indicates whether a binary lifter emits explicitir instances.
if there is at least one implicit operation in theirsemantics we mark them with and otherwise.
the fourth column shows whether a binary lifter produces self containedir instances.
if a binary lifter can generate an ir instancethat has one or more external function calls we mark it with and otherwise.
when considering explicitness and selfcontainment of bbirs we exclude operations that cannot bemodeled without the help of external environments such assystem calls.
the fifth column shows whether a binary lifter isdependent on ida pro a commercial disassembler.
there is a lifter rose that uses the cots disassembler but we includeit because its ir implementation is open sourced.
the sixthand seventh column specify whether a binary lifter can liftx86 and x86 instructions respectively.
finally the eighth and ninth column indicates whether a binary lifter supportsfloating point and simd operations respectively the circlemeans a full support and the leftcircle circlemeans a partial support.
iii.
nversion ir t esting given the difficulty of writing the semantics for binary instructions it is not surprising to see numerous semantic bugson binary lifters.
even a heavily tested tool such as qemuhas about bug fixes on their binary lifter every year.
this is indeed the primary motivation of our research we want tobuild a system that can systematically test the correctness ofbinary lifters.
most of the binary analysis tools in table were introduced in the 2000s and have been used in various areasof research.
therefore any semantic bugs on binary lifters canhave a huge impact on the existing techniques and tools.
we propose a novel testing approach called n version ir testing which leverages a symbolic analysis to check thesemantic difference between bbir instances .
if one of the ir instances is semantically different from the others thenit means we found a semantic bug in at least one of the binary lifters.
once we found a semantic discrepancy we canmanually verify which ir instance is buggy.
to describe our approach we first define the notion of symbolic equivalence which is mainly based on that of person et al.
.
let sbe the name of an isa and rbe the name of a self contained bbir.
suppose a lifted ir instance r s i consists of nstatements rs i s1 s2 ... s n .
then we can evaluate each statement in the ir instance with the evaluation function erfor an initial execution context to obtain the final execution context prime prime er sn er ... e r s2 er s1 ... .
a symbolic summary of an ir instance shows what the irinstance computes.
intuitively it can be expressed as a set ofupdated variable mappings from the execution context after evaluating the ir instance prime .
definition symbolic summary .
given an isa ls isa and an ir lr ir a symbolic summary for a binary instruction i lriris parenleftbig r s i parenrightbig prime where primeand are defined as above.
finally we say two bbir instances are semantically equivalent when the output variables of their symbolic summaries have one to one correspondence and each corresponding sym bolic summary pair is equivalent to each other.
definition semantic equivalence of bbirs .
given two bbirs randr prime and a binary instruction iof an isa s the lifted ir instances r s i and r prime s i are semantically equivalent when 1in this paper we only test bbirs generated from a single machine instruction but the notion of n version ir testing is general enough to be applied to bbirs lifted from multiple instructions.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
keys r s i keys r prime s i .
k keys r s i r s i r prime s i .
the algorithm.
with the above definitions we present the algorithm of n version ir testing a technique to test the correctness of binary lifters.
at a high level n version ir testing consists of five major steps s tream gen l ift translate summarize and t riage .
each component behaves as follows.
stream gen takes in an isa ls isaas input and returns a sequence of instructions.
since there are too many instructions to consider we systematically select a setof instructions based on their syntactic structure iv a .
lift performs binary lifting r s. specifically it takes in an instruction i ls isagenerated from s tream genas input and outputs the corresponding bbir instance.
the target bbir r depends on the lifter we use iv b .
translate translates a bbir instance to a uir instance which is a unified intermediate representation that we use in our analysis.
the reason we employ this stepis mainly due to the different characteristics of bbirs.
summarize takes in a uir instance as input and returns the corresponding symbolic summary for it.
thisstep includes an input output variable identification iv c and a symbolic analysis iv d .
triage takes in a set of bugs found a target instruction andndistinct symbolic summaries as input.
if there is no semantic discrepancy between the symbolic summaries it simply returns the unmodified set.
otherwise it returnsan updated set that includes the current target instruction because it is the buggy instruction we found iv e .
the crux of the n version ir testing algorithm is shown in algorithm .
the main function testfn for n version ir testing takes in as input a target architecture and a listof binary lifters to test.
it outputs a list of semantic bugsfound.
we note that our algorithm is sound in that we do not report false alarms.
however the algorithm is not complete because it may miss bugs on the binary lifters under test.
forexample when both binary lifters under test have the samebuggy implementation then we may miss the bug.
example.
we now describe the steps in algorithm with a concrete example.
suppose we are testing two binary lifters on x86 bap and valgrind .
we let one of the x86instructions returned from s tream genin line is inc ecx.
then the algorithm in the for loop from line to line 9in algorithm works as follows.
we set summaries with an empty list line .
since we assume two binary lifters the inner for loop line will iterate two times for each binary lifter.
in line we lift the binary instruction to a bil instance figure 1a .
we then translate the ir instance to a uirinstance line .
if the source ir is implicit or notself contained the translation becomes challenging.
weaddress this issue in iv b. we then compute the symbolic summary which maps output variables to symbolic expressions from the trans algorithm n version ir testing 1function testfn ls isa lifters 2bugs for iinstreamgen lsisa do summaries an empty list for r sinlifters do bbir rs i lift uir translate bbir s uir summarize summaries summaries s bugs triage bugs i summaries returnbugs lated ir instance which consists of two major steps a variable identification and b symbolic execution.
a from the ir instance we identify the ecx register as both an input and an output variable and statusflags of af pf sf andzf as output variables.
to achieve this we perform a simple data flowanalysis see iv c. b once we identify the output variables we run symbolic execution on the ir instance to obtainsymbolic summaries for each of the output vari ables.
in this case the only input variable is ecx so we let the variable as symbolic and evaluate their instance.
for example in line of figure 1a the output variable ecx has a symbolic expression e c x .
in this way each output variable has the corresponding symbolic expression of the inputvariable s e.g.
ecx mapsto e c x .
in line we add the obtained symbolic summary to summaries and repeat this process for each lifter.
in line we check the semantic equivalence between symbolic summaries obtained from the previous steps.for simplicity let us assume that each bbir instancehas only a single output variable ecx i.e.
we do not consider the eflags register.
then the final symbolic summaries from both bap and valgrind for ecx would bee c x .
recall from definition we consider two conditions to decide whether the symbolic summariesare semantically equivalent.
first we check whether theset of output variable names are equivalent.
second we check for each output variable whether the corresponding symbolic summaries are equivalent e c x e c x .
in this example we conclude that both bap and valgrind emits semantically equivalent ir instancesfrom the given instruction.
iv .
d esign in this section we describe the design of meandiff an automated system that implements the n version ir testing.
following the focus of meandiff at a higher level we providea detailed review of the challenges this research project hasovercome.
using the pipeline illustrated in figure thesechallenges will be described in a chronological order follow ing the process from input to output.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a. instruction stream generation meandiff checks the semantic equivalence per each instruction returned from s tream gen. ideally one can generate every possible instruction of a given architecture in order to completely test bbirs.
however this is infeasible due to thehuge number of possible instructions to consider.
for example there are more than 32add instructions on x86 even though we only consider the ones that have eax as the destination operand add eax 0x0 add eax 0x1 ... add eax 0xffffffff add eax eax add eax ebx and so forth.
notice this na ve approach already requires radically few test cases compared to existing differential testing ap proaches because n version ir testing does not require employing test cases for all possible states of eachinstruction.
particularly a symbolic summary for a given irinstance encapsulates the semantics of the instance for allpossible input values.
however we can further reduce the number of test cases to consider by exploiting the nature of symbolic evaluation.specifically instructions with the same opcode but withdifferent register names will end up having the symbolicsummaries that are syntactically similar only the name ofthe symbols are different.
for example both add eax ebx andadd ecx edx will produce two symbolic summaries that produce the same result when applied to n version ir testing.
with this intuition meandiff generates test casesfor every combination of available operand types of a givenopcode as follows.
for operand type reg reg we generate two test cases one with the same register another with different registers for each operand.
for operand type reg mem andmem reg w e generate single test case for every possible addressing mode.
that is we consider reg reg reg reg displacement and so forth.
we use an arbitraryvalue for the displacement.
for operand type reg imm andmem imm we pick three constant values for the immediate operand togenerate test cases and the maximum unsigned value based on the bit width of the immediate.
for ex ample we consider the following three cases add al 0x0 add al 0x42 and add al 0xff.
this is to cover semantic errors that are triggered only when the immediate has a specific value.
while generating test instructions s tream genremoves redundant instructions as different opcodes may be decodedto the same instruction on x86.
for example 0x0118 and0x011c20 are bothadd ebx on x86.
in our s tream genimplementation it generates and valid instructions on x86 and x86 respectively.
b. ir lifting and translation obtaining bbir instances from binary lifters requires varying amounts of manual effort.
some systems such as bap stream genarchinsnlift translatebbir lift translatebbir lift translatebbir...insn insnbap vex binsecsummarize summarize summarizeuir uir uirtriagesymbolic summary bugslifters generating filtering test instructions fig.
.
meandiff architecture.
and binsec provide apis to lift binary code to their own bbir instance as well as to access the abstract syntaxtree ast nodes of bbir instances.
however other systemssuch as valgrind do not provide such functionalities.pyvex ships with the manually extracted vex modulefrom the valgrind project which provides a python api toaccess the asts.
our l iftimplementation uses pyvex.
as discussed in ii c the spectrum of semantics supported by the bbirs differs.
specifically we consider the explicitness and the self containment of bbirs.
first the explicitness ofeach ir varies.
in bbirs such as bil and dba the eflags register is represented by explicitly declaring each flag as an output variable.
vex from pyvex on the other hand uses acondition code register which is used through lazy evaluation.to handle this the eflags has to be manually computed for each instruction.
this makes the semantics conform withthat of bap and binsec.
similarly there are some implicitoperations such as compare and swap cas that are onlysupported by some bbirs.
there is also the question whether the bbir at hand is self contained following definition in ii c. an ir that is not self contained may call an external function within the irinstance.
recall from the example in figure 1b the externalfunction call to x86g calculate eflags c within the ir instance makes it difficult for us to compare the semanticsof it with other ir instances.
to handle these challenges we define a unified intermediate representation uir used for unifying every bbir into asingle form.
uir is a simple but turing complete language which consists of a few primitive arithmetic and logicaloperations.
it is also designed to be explicit and self contained.due to the page limit we do not show the detailed syntax of uir.
interested readers should refer to our web page .
we note that employing a unified representation benefits the restof our analysis as well we do not need to write the sameanalysis routine for every bbir under test.
translating bbir to uir is challenging and requires significant engineering efforts.
for example we replaced theexternal functions of vex that compute the eflags.i n our experiment we employed a conservative approach insteadof fully implementing the conversion from bbirs to uir.
particularly whenever we encounter a bbir instance that isnot explicit or not self contained during the analysis we omit authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
such an instruction from our testing set unless it is specifically handled by our translators t ranslate .
we leave it as future work to shrink the semantic gaps between different bbirsby implementing more conversion rules.
we note however that omitting such instructions do not affect the soundnessguarantee of our analysis.
c. data flow analysis the first step of s ummarize is to identify input output variables from a translated uir instance.
to determine input variables from an ir instance we apply a classic use defanalysis.
every node in the use def ud chain that has outgoing edges but no incoming edges is classified as aninput variable.
in other words variables that are used but never defined are input variables.
on the other hand we cannot simply identify output variables with a data flow analysis.
one may think that all variables that are declared but never read must be outputvariables.
however this is not the case for many irs.
for ex ample in figure ecx is an output variable while also being used in the assignment of of.
to overcome this challenge we use the knowledge of the given isa.
specifically we check forevery statement sin the given ir instance whether sassigns a value to a variable that has the name of known registers and status flags.
if so we make all such variables to be an output.
d. symbolic execution recall from iii the second step of s ummarize is to symbolically execute each of the lifted ir instances in order to generate symbolic summaries.
we address two challengesin this phase loop handling challenge and symbolicmemory challenge.
the first challenge is simply handled by unrolling loops once.
although we can only see a limited number of execution paths our analysis is still sound it doesnot produce false alarms.
in this subsection we focus on howwe handle the second challenge.
symbolic memory is a traditional problem in symbolic execution where a symbolic address is used to access amemory value.
one may represent a symbolic memory accesswith an if then else chain accounting for every possible valuesin the memory but this may result in too complex symbolicexpressions to be solved in practice.
there are several existingsymbolic access policies in dynamic symbolic executionsuch as pointer concretization but this is not an option for ourapproach since we rely on static symbolic execution.
in our implementation however the symbolic memory challenge is not really an issue because meandiff only focuseson bbirs generated from a single machine instruction recall iii .
notice it is extremely unlikely to have a machineinstruction that uses a non memory operand to access memory.
furthermore the address of a memory operand is typically not used for other purposes than for accessing the memory.
therefore we can simply let a memory access be a symbolic variable if it is used as input.
when lifting an x86 instruction mov ebx for example meandiff replaces the operand with a symbolic variable mem eax.
however simply replacing memory expressions into a symbolic variablecan be problematic when two different lifters express thesame memory operand in a totally different manner.
forexample the address of a memory operand can be represented either as eax ebx or asebx eax.
furthermore a single instruction may access more than one memory cells.
this means we need to be able to distinguishmemory expressions and give a unique symbolic name for the same memory expressions.
to determine if two memory expressions are the same we apply a series of simple transformation rules such asexpression reordering e e2 e2 e1 strength reduction e n e n and arithmetic simplification e e to both and check if the expressions are exactly the same.
e. triage the final step of n version ir testing is t riage which checks the semantic equivalence between symbolic summaries obtained from s ummarize .g i v e n nsymbolic summaries meandiff first checks if they have the same set of output variables.
if not we add the corresponding instruction to ourbug database.
otherwise meandiff constructs a final formula by combining symbolic expressions for each of the outputvariables.
it solves the formula using the z3 smt solver .if we found any counter example that gives two or moredistinct values when evaluating symbolic expressions of the same output variable it means we found a bug.
the intel manual specifies that register values can be marked as undefined after executing an instruction.
for example theafflag is undefined after executing logical operations.
some lifters such as bap explicitly marks the afas undefined in this case but others such as binsec would simply let theafunchanged.
in order to handle such a case we do not compare undefined output variables in our implementation.
f .
implementation we applied n version ir testing on existing binary analysis tools in table bap pyvex a wrapper for valgrind s vex and binsec.
we have implemented translators t ranslate for each of the tools lines of ocaml for a bil to uir translator lines of ocaml for a dba to uir translator and .0k lines of python for a vex to uirtranslator.
we have also implemented our s ummarize and triage module with about .0k lines of f code.
we made the source code public at .
v. e v aluation to evaluate meandiff we focus on the following questions how many binary instructions can s tream gengenerate?
and how many of them can be handled by thestate of the art binary lifters?
can meandiff find semantic bugs in the binary lifters?
how do the bugs look like?
and how difficult it is to write precise binary lifters?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a. environment setup we ran our experiments on bit ubuntu .
.
system with core cpus intel xeon e5 family with 256gb ram.
we downloaded three binary analysis tools i.e.
binarylifters bap .
.
released feb. 10th pyvex6.
.
.
released apr.
12th and binsec .
re leased mar.
1st .
all the numbers reported in this paperis based on the experimental results on these binary lifters.
wetested the lifters on both x86 and x86 instructions with theexception of binsec that does not support an x86 isa.
thetotal experiments took approximately days.
b. binary lifting recall from iv a our s tream gengenerated and instructions on x86 and x86 respectively.
firstly we recorded the numbers of successfully lifted bbirsfor each binary lifter under test to later use them in theevaluation of meandiff.
table shows the result.
each row represents the number of lifted instructions that could only be successfully lifted fromthe specified set of lifters.
from these results it is apparent thatbinsec could lift the smallest number of instructions.
there is also a noticeable clustering of instructions which only bapand binsec could lift.
this is due to the instruction prefix f3 rep which is used for expressing the instruction levelloop.
from the intel developer s manual if the rep prefix is used with an inappropriate opcode the prefix should beignored.
however pyvex simply refuses to interpret suchinstructions.
that is why such a huge number of instructionswas lifted with bap and binsec in comparison with pyvex.
the none row of the table indicates the number of instructions that are notsuccessfully lifted from any one of the binary lifters under test.
almost and of the instructions on x86 and x86 respectively could not belifted by the binary lifters.
this result signifies two points only a small subset of available instructions are used inbinary executable in practice and the current state of the art lifters are yet to be perfect.
c. bugs f ound can meandiff find realistic semantic bugs?
to answer the question we checked the semantic equivalence on every lifted bbirs under test.
in total meandiff found semantic bugs from distinct binary instructions.
since two or more instructions can causethe same semantic bug we manually verified all the bugs wefound and obtained unique bugs in total.
more specifically we found unique bugs on x86 and unique bugs on x86 .
out of unique x86 bugs bugs were overlappingwith x86 bugs.
thus we did not count them.
table showsthe list of bugs that we found with meandiff.
the examplecolumn shows a sample instruction that you can trigger thebug.
in the table there are some cases that the same type ofbug occurs in different lifters.
we treat them as a separate bugsince the implementations of lifters are different.table the number of successfully lifted binary instructions .
lifter s x86 x86 pyvex bap binsec pyvex bap pyvex binsec bap binsec pyvex bap binsec none d. case studies in this subsection we examine three interesting cases of semantic bugs found by meandiff.
case study push .
stack operations such as push andpop are used in various execution contexts local and temporary variables for functions are stored on the stack function arguments are passed through the stack and returnaddresses are saved on the stack.
given that stack operations are so common the semantics of the push instruction should be correct?
the intel developer s manual describes the semantics ofpush but most of the description is written in natural language while only the operation segment is expressed inpseudo code.
although the manual does its best to describeevery possible semantic it is often not possible to understandall possible corner cases by just looking at the pseudo code.
the binary sequence 6aff is translated into push 0xff.
since the stack pointer never decreases by the size of source operand is smaller than the size of the operation.
if one triesto look up how the cpu deals with this situation one may fail to locate the pseudo code.
instead it is indicated in thedescription written in english.
the manual indicates in this situation that the source operand must be sign extended beforeit is pushed to the stack.
figure describes the result of each target binary lifter which shows how each lifter handles the situation describedabove.
both bap and binsec produce bbir instances with semantics that move the bit value 0xff into memory.
pyvex on the other hand produces an instance whichmoves the bit value 0xffffffff into memory.
this is an obvious semantic discrepancy which symbolizes the difficulty to implement binary based tools that have the precise meaning.
case study bt .
meandiff is even able to find bugs in pyvex which has been extensively tested and appliedin the state of the art research the instruction bt which stands for bit test has two operands.
it tests the bit in the first operand at the index specified in the second operand and puts the result in the cf status flag.
the target binaryinstruction is 0fa3d8 which is translated to bt eax ebx.
unfortunately meandiff is not able to test all three binarylifters as binsec does not understand this instruction.
thus it only compares the bbir instances from bap and pyvex.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table bugs found lifter bug description example opcode bap confusion of operands 0fc100 xadd bap operand address changed 0fc100 xadd bap not taking mod size c000ff rol bap missing signed extension 6aff push bap invalid cfcalculation 0fc1c0 xadd bap invalid ofcalculation 28c0 sub pyvex missing arithmetic operation 0fc1c0 xadd pyvex useless memory access 0fa3c0 bt pyvex invalid push pop operation 0e push pyvex not storing segment register 488c00 mov binsec confusion of operands 0f3a0f0042 palingr binsec operand address changed 0fc000 xaddlifter bug description example opcode binsec missing signed extension 6b08ff add binsec invalid padding 678cc0 mov binsec invalid order of calculation 0fb100 cmpxchg binsec invalid memory addr.
calculation 0fa300 bt binsec not taking part of value 0fa300 bt binsec unable to recognize prefix 64668d08 lea binsec invalid pop operation 5c pop binsec invalid pushad behavior pushad binsec invalid store load afbehavior 9e sahf binsec invalid cfcalculation 1cff sbb binsec invalid ofcalculation 1cff sbb binsec operand address changed 0fc000 xadd 1v1 0x80 2esp esp 0x4 3mem32 mem32 with u32 v1 a lifted ir from bap .
1t3 get i32 esp 2t2 sub32 t3 0x00000004 3put esp t 4stle t2 0xffffff80 b lifted ir from pyvex .
l4 2esp esp c lifted ir from binsec .
fig.
.
bug case study push 0xff.
1o1 low 2cf low 3of unknown u1 4sf unknown u15zf unknown u1 6af unknown u1 7pf unknown u1 a lifted ir from bap .
1t2 get i32 ebx 2t9 get i32 esp 3t8 sub32 t9 0x00000080 4put esp t 5t10 get i32 eax 6stle t8 t10 7t3 and32 t2 0x0000001f 8t12 sar32 t3 0x03 9t11 add32 t8 t12 10t14 and32 t3 0x00000007 11t13 32to8 t14 12t0 ldle i8 t11 13put cc op 0x00000000 14put cc dep2 0x00000000 15t17 8uto32 t0 16t16 shr32 t17 t13 17t15 and32 t16 0x00000001 19put cc dep1 t15 20put cc ndep 0x00000000 21t18 ldle i32 t8 22put eax t18 23t19 add32 t8 0x00000080 24put esp t19 b lifted ir from pyvex .
fig.
.
bug case study bt eax ebx.
figure shows the lifted bbir instances.
by comparing the difference in the output size one may begin to realize the difference in semantics.
bap clearly bit shifts eax to right by the number specified in ebx followed by storing the lowest bit in cf.
this is indeed the semantics defined in intel developer s manual however the vex ir instance starts by decrementing the stack pointer by 0x80 and storing the value of eax at the resulting address.
further it computes the actual bit test which is stored in cc dep1.
lastly it restores the stack pointer by incrementing but without restoring the value it previouslymodified at 0x80 esp .
in other words the cpu state has been altered in a way not defined in the x86 instruction definition.
the discrepancy may seem obvious when directly comparing it to another bbir but due to the sheer amountof instructions in modern architectures bugs of this nature aredifficult to detect.
case study xadd .
the last case introduced in this paper is the xadd exchange and add.
this case is interesting as both bap and binsec confuse the semantics regardingthe operands in a similar but different fashion.
first let us introduce the binary instruction 0fc100.i ti s a combination of the opcode 0fc1 and operand which representseax as source and as destination operand.
the semantics of this instruction listed in the manual is as follows exchange the value of destination and source operand and then load the sum of the two values into the destinationoperand.
now let us see how each binary lifter represents thissemantics in their own bbir.
figure shows that each of the lifted bbir instances represents different semantics.
starting with the last i.e.
thedba instance in figure 5c it calculates the correct valueand corresponding flags but somehow changes the destinationaddress before writing the result to it.
the bil instance infigure 5a correctly calculates the result but switches theoperands such that the result is written to the source operand.
interestingly enough there is another bug present in the core of calculating status flags.
for example ofis calculated based on the memory operand which has already been changed.
theonly correct instance is from pyvex in figure 5b whichcorrectly writes the result to the correct operand.
the lesson.
from the above examples we have shown that even the heavily tested binary lifters have semantic bugs.
it isextremely difficult to consider every possible semantic details authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1v1 low mem32 el u32 3mem32 mem32 with el u32 low 5eax v1 ... 7of high high el u32 high high 10af 0x10 0x10 low v1 mem32 el u32 ... a lifted ir from bap .
1t3 get i32 eax 2t0 ldle i32 t3 3t2 add32 t0 t3 4stle t3 t2 5put cc op 0x000000036put cc dep1 t 7put cc dep2 t 8put cc ndep 90x00000000 10put eax t b lifted ir from pyvex .
1res32 eax 2of l4 eax l4 !
res32 ... 5eax res32 c lifted ir from binsec .
fig.
.
bug case study xadd eax.
by simply reading the manual.
vi.
d iscussion and limitation in this paper we tested three of the binary lifters listed in table .
recall from iv b extracting a binary lifter from existing binary analysis tools can require significant manual effort.
we handle this issue by making meandiff as an opensource project.
binary analysts who have their own lifter orborrow a famous lifter from another project will be able toadd their lifter to meandiff and test the correctness of it.
meandiff currently does not test instructions performing floating point operations.
as shown in table many lifters including bap and binsec do not support floating pointoperations.
as such we currently do not take floating pointoperations into account.
however it is straightforward tomodify uir to handle floating point operations by using atheory of floating point numbers in smt solving .
weleave it as future work to support such functionality.
meandiff currently supports only x86 and x86 .
to add support for another isa one needs to build a new streamgenerator for the isa by manually analyzing the syntacticstructure of every instruction in the isa.
indeed one of the reasons why we make our source code public is to encourage the community to adapt this technique to test the correctnessof various bbirs.
our current focus is on bbir instances generated from a single instruction but we can potentially extend mean diff to handle bbir instances from multiple instructions.since some lifters such as pyvex performs intra basic blockoptimizations we may be able to find interesting semanticbugs by extending our scope.
however by considering bbir instances from multiple instructions we may face severalchallenges.
first s tream genneeds to consider all possible combinations of instructions.
second the classic symbolic memory challenge may occur frequently recall from iv d .
we believe this is a promising direction for future research.
vii.
r elated work the idea of a symbolic equivalence check itself is not new but our work is the first attemptto applying the idea to testing the correctness of bbirs.luo et al.
recently extended the idea of a symbolic equivalence check to perform similarity comparison on obfuscated binary code.
we believe that n version ir testing can contribute to solving the addressed challenges by providing more accurate semantics of binary code.
hasabnis et al.
attempt to test irs generated by compilers.
the key difference between their work and ours isthat they rely on the cpu to test the correctness.
they comparethe result from cpu with the result from an ir emulator.
thereare several pieces of work in this line of research .all the existing techniques rely on the actual cpu state andrandomly generated test cases.
one remarkable attempt in the area of binary lifting is automatically generating bbirs.
godefroid et al.
made this problem into the program synthesis problem with a black box oracle.
they divided alu operations into groups made templates for each group and synthesized irs fromthose templates.
the automatic bbir generation problem wasturned into a problem in the area of machine learning by hasabnis et al.. they used the problem of learning a parameterized translation on trees to automatically synthesize bbirs.
these approaches do not guarantee the semanticcorrectness of the generated bbirs.
thus our approach isorthogonal and complementary to their techniques.
viii.
c onclusion in this paper we proposed n version ir testing a novel technique to find semantic bugs in binary lifters.
we systemat ically studied existing binary lifters to motivate our research and addressed several challenges in applying our technique to binary based irs.
we implemented the proposed technique in meandiff and evaluated the system on state of the artbinary lifters.
we found unique semantic bugs which wereall manually confirmed.
furthermore we have reported all ofour findings to the developers of the tested binary lifters.
ourresults indicate that any binary analysis can go wrong even with a well founded theory when the semantics of binarybased irs is wrong.
a cknowledgments this work was supported by institute for information communications technology promotion iitp grant funded by the korea government msit no.b0717 build ing a platform for automated reverse engineering and vulnerability detection with binary code analysis .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.