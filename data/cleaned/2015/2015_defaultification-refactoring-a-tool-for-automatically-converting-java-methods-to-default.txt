defaultification refactoring a tool for automatically converting java methods to default raffi khatchadourian city university of new york usa raffi.khatchadourian hunter.cuny.eduhidehiko masuhara tokyo institute of technology japan masuhara acm.org abstract enabling interfaces to declare instance method implementations java default methods can be used as a substitute for the ubiquitous skeletal implementation software design pattern.
performing this transformation on legacy software manually though may be non trivial.
the refactoring requiresanalyzing complex type hierarchies resolving multiple implementation inheritance issues reconciling differences between class and interface methods and analyzing tie breakers dispatchprecedence with overriding class methods.
all of this is necessary to preserve type correctness and confirm semantics preservation.
we demonstrate an automated refactoring tool called m igrate skeletal implementation to interface for transforming legacy java code to use the new default construct.
the tool implemented as an eclipse plug in is driven by an efficient fully automated type constraint based refactoring approach.
it features an extensive rule set covering various corner caseswhere default methods cannot be used.
the resulting code is semantically equivalent to the original more succinct easier to comprehend less complex and exhibits increased modularity.
ademonstration can be found at index t erms refactoring java interfaces default methods type constraints eclipse i. i ntroduction java enhanced interfaces enable developers to write default instance methods that include an implementation that implementers will inherit if one is not provided .
although originally intended to facilitate the addition of newfunctionality to existing interfaces without breaking clients default methods can also be used to substitute the skeletal implementation pattern which is ubiquitous in many software projects .
the pattern involves creating an abstract skeletal implementation class that implementers canextend.
this class provides a partial interface implementationand thus results in an interface that is easier to implement.
advantages in migrating legacy code from using the skeletal implementation pattern to default methods include foregoing the need for subclassing having classes inherit behavior butnot state from multiple interfaces and facilitating local reasoning .
although advantageous such a migration re quires significant manual effort particularly in large projects as there are subtle language and semantic restrictions that mustbe considered.
one such restriction is that interfaces cannotdeclare instance fields.
the migration requires preserving type correctness by analyzing complex type hierarchies resolving issues arising from multiple implementation inheritance reconciling differences between class and interface methods and ensuring tie breakers with overriding class methods i.e.
rules governing dispatch precedence between class and defaultmethods with the same signature preserve semantics.
we demonstrate an automated refactoring tool named m igrate skeletal implementation to interface for transforming legacy java code to use default methods.
the toolassists developers in taking advantage of enhanced interfacesin an efficient fully automated and semantics preserving fash ion.
the approach is based on type constraints and workson large scale projects with minimal intervention.
featuring anextensive rule set that covers diverse corner cases where de fault methods are prohibited the approach identifies instancesof the skeletal implementation pattern and safely migratesmethods to corresponding interfaces as default methods.
the related p ull upmethod refactoring tool manipulates a type hierarchy by safely moving methods froma subclass up into a super class so that all subclasses mayinherit from it.
this refactoring is fundamentally differentfrom migrating method definitions from skeletal implemen tations to interfaces as default methods in terms of its goalsand the targeted design pattern.
namely its sole goal isto reduce redundant code whereas ours includes openingclasses to inheritance allowing classes to inherit multipleinterface definitions etc.
moreover while the two refactoringsshare some preconditions i.e.
conditions that must be met toguarantee refactoring correctness in terms of type constraintsviolations our approach deals with multiple inheritance amore complicated type hierarchy involving interfaces sinceclasses may implement multiple interfaces while extending aclass semantic differences due to class tie breaking furtherconstraints on interfaces as they cannot declare fields anddifferences between class method headers and correspondinginterface method declarations.
lastly while methods to bepulled up typically are declared in a common class in our case default methods may be migrated from multiple classes intoa single interface pressing the need for a more widespread batch processing approach across classes and packages.
our refactoring tool available at is implemented as an open source eclipse built atop of the java development tools jdt refactoring infrastructure .
our toolcan process projects in batch mining for occurrences ofthe skeletal implementation pattern than can be converted to .
c circlecopyrt2017 ieeease urbana champaign il usa t ool demonstrations984 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
default methods.
a refactoring preview pane is provided along with detailed information of code that fails preconditions.
for the tool evaluation an extensive refactoring test suite was created featuring refactoring regression tests trig gered via continuous integration.
each tests verifies that i both the input and output code versions compile successfullyand ii the actual refactored version matches that of theexpected refactored version given the initial version of theinput source code.
the usefulness of the tool was assess via theanalysis of java projects of varying size and domain with atotal of .
million lines of code.
additionally pull requests patches of the refactoring results were submitted to popular github repositories as a preliminary study.
the details of the underlying approach as well as thorough experimental results can be found in our previous work .
beyond we make the following specific contributions implementation details a thorough treatment of the novel aspects of the tool implementation is presented in detail.
this includes the tool s architecture api usage data representa tions algorithms and implementation issues and limitations.furthermore the tool s relationship to the p ull upmember refactoring implementation is thoroughly explored.
user perspective a broad overview of how our tool is used to perform large scale refactorings is given.
this includes screenshots of the tool s usage and a video demonstration.
our hope is to receive valuable feedback on the improvementof the user interface as well as promote its usage.
ii.
e nvisioned users the users we envision our tool attracting are especially those who are tasked with maintaining and or improving legacy currently java systems.
our tool is most advantageous insituations where legacy systems are using java and areactively maintained.
in this way using our tool on thesesystems would result in code that is more succinct and easierto maintain e.g.
skeletal implementation classes may be eliminated as will be discussed in the following sections.
since our tool takes advantage of the built in user friendly eclipse refactoring infrastructure developers with even little refactoring experience may use our tool.
users may be thosethat are tasked with refactoring an entire project or writingnew code in only portions of a large system.
since our tool will identify possible instances of the skeletal implementation pattern and that the resulting program will be semanticallyequivalent to the original users do not necessarily have topossess a thorough knowledge of the pattern.
iii.
s oftware engineering challenges in this section we discuss the software engineering challenges our tool is made to address.
fig.
portrays a screenshotof the refactoring preview pane that a user is presented withprior to executing the refactoring on a simplified example.in order for such a pane to be displayed the user developer selects java elements of the eclipse ide e.g.
thepackage explorer.
m igrate skeletal implementation tointerface supports a wide range of element granularity from multiple methods up to multiple projects within an eclipse workspace.
for example if the user context clicks right clicks a java class in the eclipse ui and selects ourrefactoring option the tool will traverse the entire class forinstance method definitions implementations that implementan interface method in an interface explicitly specified as beingimplemented by either the enclosing class or one of its parents.
background and motivation.
fig.
consists of two panes namely the original source and the refactored source with the former being in input to the tool and the latter theproposed output.
users may select finish if they agree with the refactoring and may revise the input parameters e.g.
files by unchecking them from the top section.
in the each pane there are two types namely interface iand an abstract class c. on the left ideclares a simple single abstract method m line .
class cimplements iand thus provides a basic implementation of m .
since it is not meant to be directly instantiated but rather to be used as a skeletal implementation ofi ci is declared as abstract.
instead of implementing i directly prospective implementers can subclass cand thereby inherit default implementations of some or all of the in terface methods.
often times such skeletal implementationsprovide default method implementations that clients caninherit from rather than providing their own if the implemen tation is applicable to them.
other times such abstract skeletalimplementers provide complete implementations comprised ofmore primitive interface methods that subclasses override.
although useful there are several drawbacks to the skeletal implementation pattern especially w.r.t.
inheritance modularity and bloat .
classes extending c for example to benefit from the provided skeletal implementations will not be able to extend other classes.
this could be problematic in situationswhere classes implement multiple interfaces with each one have its own corresponding skeletal implementer.
moreover there is no syntactic path between an interface and a skeletalimplementer clients looking to take advantage of a skeletalimplementation must rely on either a global project analysisand or documentation.
lastly skeletal implementers requirean additional separate type which could make already highlycomplicated libraries more complicated.
many of the aforementioned problems can be solved with default methods that are part of the enhanced interface feature of java .
the right pane of fig.
portraysthe refactored version of the left with m removed from class cand its body appended in the formerly abstract method m in interface i. furthermore in i m is now prefixed with the default keyword.
after the refactoring class cis now empty whether it can be completely removed is explored below.
now implementers of ican simultaneously benefit from the default implementation of m and extend a different class.
implementers also do not need to discover skeletalimplementers of ias default implementations are coupled with the interface method declaration.
lastly a new type is notneeded to represent the default method.
although fig.
portrays a scenario where the refactoring succeeds cases exist where executing the refactoring would authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
screenshot of the refactoring preview pane for the m igrate skeletal implementation to interface refactoring.
produce either type incorrect or semantically inequivalent results.
for example consider the following snippet interface i void m interface j default void m ... abstract class c implements i j void m ... here migrating method c.m to interface ias a default method would cause a compilation error due to class cnow inheriting ambiguous method definitions of method m .
default methods have many advantageous over the skeletal implementation pattern however there are some potential trade offs.
for example placing implementations directly ininterfaces can violate some of the fundamental benefits ofinterfaces acting as abstract data types adts where imple mentation details should not be included.
particular to defaultmethods in java there has been some reported performancedegradation in certain cases when using default methods .however this has been seen as a temporary jdk jre problem that affects only a small number of cases .
analysis challenges.
although fig.
is a simple example there are many other situations where determining whether it is safe to convert a method to default may not be obvious a particular skeletal implementer may provide a singleskeletal implementation for multiple interfaces complicating the processes of determining the target interface of where the source class method shall be migrated to as a default method.
our current implementation rejects input methods with ambiguous target interfaces.
a given interface may have multiple skeletal implementers which of these should be migrated to the interface as a default method?
our current implementation performsequivalence set merging to find the largest set of equivalent source methods for migration and fails the others.
a skeletal implementer may declare instance fields that areused in the source method.
since instance fields cannot be declared interfaces is it possible to convert such methods todefault?
our current implementation does not allow methods directly accessing fields to be refactored but if the developeris willing to make accessors and mutators part of theinterface they are free to perform the e ncapsulate field and e xtract interface refactorings prior to ours.
lambda expressions require interfaces with a single abstract method.
converting a method to default may invalidate this requirement.
our approaches rejects methods that are partof functional interfaces used in lambda expressions.
in cases where a class inherits the same method from both a class and an interface where the interface method is default the interface method will lose a tie to the class.
assuch we must ensure that the dispatch semantics remainintact after the refactoring.
otherwise calls to the sourcemethod will not dispatch to the target in the refactoredversion but rather a method in a different class.
our currentimplementation rejects methods in this situation.
other issues include those related to empty skeletal implementers i.e.
cases where all source methods have beenmigrated to their targets.
after the refactoring further analysisis required to safely remove them.
for example the class maynot be able to be removed if it is instantiated somewhere in thecode base.
other