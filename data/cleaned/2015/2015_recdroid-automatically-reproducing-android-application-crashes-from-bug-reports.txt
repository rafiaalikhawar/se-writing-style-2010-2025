recdroid automatically reproducing android application crashes from bug reports y u zhao tingting y u ting su yang liu wei zheng jingzhi zhang william g.j.
halfond university of kentucky usa nanyang technological university singapore northwestern polytechnical university china university of southern california usa abstract the large demand of mobile devices creates significant concerns about the quality of mobile applications apps .
developers heavily rely on bug reports in issue tracking systemsto reproduce failures e.g.
crashes .
however the process ofcrash reproduction is often manually done by developers makingthe resolution of bugs inefficient especially that bug reports areoften written in natural language.
to improve the productivity ofdevelopers in resolving bug reports in this paper we introducea novel approach called recdroid that can automaticallyreproduce crashes from bug reports for android apps.
recdroiduses a combination of natural language processing nlp anddynamic gui exploration to synthesize event sequences withthe goal of reproducing the reported crash.
we have evaluatedrecdroid on original bug reports from android apps.
theresults show that recdroid successfully reproduced crashes .
success rate directly from the textual description of bugreports.
a user study involving participants demonstratesthat recdroid can improve the productivity of developers whenresolving crash bug reports.
i. i ntroduction mobile applications apps have become extremely popular in there were over .
million apps in google play s app store .
as developers add more features andcapabilities to their apps to make them more competitive thecorresponding increase in app complexity has made testing andmaintenance activities more challenging.
the competitive appmarketplace has also made these activities more important foran app s success.
a recent study found that of app userswould abandon an app if they were to repeatedly encountera functionality issue .
this motivates developers to rapidlyidentify and resolve issues or risk losing users.
to track and expedite the process of resolving app issues many modern software projects use bug tracking systems e.g.
bugzilla google code issue tracker and githubissue tracker .
these systems allow testers and users toreport issues they have identified in an app.
reports involvingapp crashes are of particular concern to developers becauseit directly impacts an app s usability .
once developersreceive a crash bug report one of the first steps to debuggingthe issue is to reproduce the issue in the app.
however thisstep is challenging because the provided information is writtenin natural language.
natural language is inherently impreciseand incomplete .
even assuming the developers can per fectly understand the bug report the actual reproduction canbe challenging since apps can have complex event driven andgui related behaviors and there could be many gui basedactions required to reproduce the crash.
the goal of our approach is to help developers reproduce issues reported for mobile apps.
we propose a new technique recdroid targeted at android apps that can automatically analyze bug reports and generate test scripts that will repro duce app crashes.
recdroid leverages several natural languageprocessing nlp techniques to analyze the text of the reportsand automatically identify gui components and related infor mation e.g.
input values that are necessary to reproduce thecrashes.
recdroid then employs a novel dynamic explorationguided by the information extracted from bug reports to fullyreproduce the crashes.
recdroid takes as input a bug reportand an apk and outputs a script containing a sequence of guievents leading to the crash which can be replayed directly onan execution engine e.g.
ui automator .
recdroid differs from prior work for analyzing the reproducibility of bug reports because most existingtechniques focus on improving the quality of bug reports.none of them have considered using information from bugreports to automatically guide bug reproduction.
in contrast recdroid takes crash description of the report as input regardless of its quality and extracts the information necessaryto reproduce crashes.
recdroid also differs from techniqueson synthesizing information from bug reports because they focus extracting useful information e.g.
testcases without directly targeting at reproducing crashes.
recdroid has been implemented as a software tool on top of two execution engines robotium and uiautomator .
to determine the effectiveness of our approach we ran recdroid on bug reports from popular androidapps.
recdroid was able to successfully reproduce .
of the crashes.
furthermore out of the crashes couldhave been reproduced by recdroid if limitations in theimplementation of the execution engines were to be removed.
to determine the usefulness of our tool we conducted a light weighted user study that showed that recdroid canreproduce crashes not reproduced by at least one devel oper and was highly preferred by developers in comparisonto a manual process.
we also found that recdroid washighly robust in handling situations where reduced amountsof information were provided in the reports.
overall weconsider these results to be very strong and they indicate thatrecdroid could be a useful approach for helping developersto automatically reproduce bug crashes.
in summary our paper makes the following contributions the design and development of a novel approach toautomatically reproduce crash failures for android appsdirectly from the textual description of bug reports.
an empirical study showing that recdroid is effectiveat reproducing android crashes and likely to improve the ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a b c d e f fig.
the steps of reproducing the crash described in fig.
.
productivity of bug resolution.
the implementation of our approach as a publicly available tool recdroid along with all experiment data e.g.
datasets user study .
ii.
o verview a. observations as the first step we spent a month studying a large number of android bug reports to understand their characteristics for guiding the design and implementation of recdroid.
we collected android apps from both google code archive and github .
we crawled the bug reports from the first pages in google code resulting in bug reports.
we then searched android apps from github by using the keyworld android resulting in bug reports.
among all bug reports we used keywords such as crash and exception to search for reports involving app crashes.
this yielded a total number of bug reports.
the result indicates that a non negligible number .
of bug reports involve app crashes .
recdroid focuses on reproducing app crashes from bug reports containing textual description of reproducing steps so we analyze the crash bug reports and summarize the following findings bug reports .
contain reproducing steps the maximum is steps the minimum is step and the average is .
steps only out of crashes are related to rotate action they all occur steps right after the rotate of the crash bug reports require specific user inputs on the editable gui components to manifest the crashes .
of them involve special symbols e.g.
apostrophe hyphen crashes .
involve generic click actions including ok done andcancel .
b. design challenges an example bug report is shown in fig.
.
in this example the reporter describes the steps to reproduce the crash in five sentences.
the goal of recdroid is to translate this sort of description to the event sequence shown in fig.
for triggering the crash.
to achieve this goal our approach must address four main challenges.
first what types of information need to be extracted from a bug report?
second how can such information be extracted from reports written in natural language?
third how can this information which may vary fig.
bug report for librenews issue in specificity and completeness be used to reproduce the crash?
fourth how can this process be done efficiently in terms of a minimal reproduction sequence and the time to find this sequence?
in the remainder of this section we provide an overview of how our approach s design addresses these challenges.
details and algorithms of our approach are presented in section iii.
what type of information to extract?
from the examination of the bug reports containing reproducing steps our insight was that events that trigger new activities interact with gui controls or provide values are the key parts of the steps provided by bug reporters.
more broadly these actions involve performing a type of user action on a particular gui component with specific values if the component is editable .
therefore action target gui component and input values are the main elements to be extracted from bug reports.
to illustrate consider the fourth step in fig.
.
here change is the user action server is the target gui component and xxyyzz is the input value.
how to map bug report into semantic representations of events?
the second design challenge is the extraction of the semantic representation of the reproducing steps from the bug reports defined by a tuple action gui component input .
a seemingly straightforward solution to this challenge is to use a simple keyword search to match each sentence in the bug report against the name i.e.
the displayed text of the gui components from the app.
however keyword search cannot reliably detect input values or the multitude of syntactical relationships that may exist among user actions gui components and inputs.
for example consider a sentence authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
!
!
!
!
!
!
fig.
overview of the recdroid framework.
i click the help button to show the word.
if both help and show happen to be the names of app buttons a keyword search could identify both help andshow to be the target gui components whereas only help has a relationship with the action click .
moreover reporters may use new words that do not match the name of the gui component of the app.
for example a reporter may use play the film to describe the movie button.
our insight is that the extraction process can be formulated as a slot filling problem in natural language processing nlp .
with this formulation each element of the event tuple is represented as a semantic slot and the goal of the approach then becomes to fill the slots with concrete values from the bug report.
our approach uses a mixture of nlp techniques and heuristics to carry out the slot filling.
specifically we use the spacy dependency parser to identify typical grammatical structures that were used in bug reports to describe the relevant user action target gui component and input values.
these were codified into typical patterns which we summarize and describe in section iii.
the patterns are used to detect event tuples of a new bug report and fill their slots with values.
to help bridge the lexical gap between the terminology in the bug report and the actual gui components our approach uses word embeddings computed from a word2vec model to determine whether two words are semantically related.
for example the words movie and film have a fairly high similarity.
how to create complete and correct sequences for bug reproduction?
a key challenge for our approach is that even good bug reports may be incomplete or inaccurate.
for example steps that are considered obvious may be omitted or forgotten by the reporter.
therefore our approach must be able to fill in these missing steps.
ideally information already extracted from the report can be used to provide hints to identify and fill in the missing actions.
existing gui crawling tools are not a good fit for this particular need.
for example many existing tools e.g.
a3e use a depth first search dfs to systematically explore the gui components of an app.
that is the procedure executes the full sequence of events until there are no more to click before searching for the next sequence.
in our experience this is sub optimal because if an interaction with an incorrect gui component is chosen due to a missing step then the subsequent exploration of sub paths following that step will be wasted.
for our problem domain a guided dfs with backtrackingis more appropriate.
using this strategy our approach can check at each search level whether gui components that are more relevant i.e.
match the bug report to the target step are appearing and use this information to identify the next component to explore.
if none of the components are relevant to the bug report instead of deepening the exploration recdroid can backtrack to a relevant component in a previous search level.
this process continues until all relevant components in previous levels are explored before navigating to the subsequent levels.
how to make the reproduction efficient?
efficiency in the reproduction process is important for developer acceptance.
an approach that takes too long may not seem worth the wait to developers and an approach that generates a needlessly long sequence of actions may be overwhelming to developers.
these two goals represent a tradeoff for our approach identifying the minimal set of actions necessary to reproduce a crash can require more analysis time.
to achieve a reasonable balance between these two efficiency goals we designed a set of optimization strategies and heuristics for our approach.
for the guided crawl we utilized strategies that included checking the equivalence of screens and detecting loops to avoid redundant backtracking and prioritizing gui components to be explored based on their likelihood of causing bugs.
for minimizing the size of the sequence of gui actions whenever a backtrack was needed our approach restarted the search from the home screen of the app and reset the state of the app.
this avoids a common source of inefficiency present in other approaches e.g.
that add backtracking steps to their crawling sequence which results in an overall much longer sequence of reproducing actions.
iii.
r ecd roid approach the architecture of recdroid is shown in fig.
.
recdroid consists of two major phases bug report analysis and dynamic exploration.
to carry out the bug report analysis recdroid employs nlp techniques to extract gui event representations from bug reports.
to complete the sequence of extracted steps the second phase employs a novel dynamic exploration of an app s gui.
this exploration is performed based on a dynamic ordered event tree doet representation of the gui s events and searches for sequences of events that fill in missing steps and lead to the reported crash.
recdroid saves the event sequences into a script that can be automatically replayed on the execution engine.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i summary of grammar patterns category id pct.
grammar pattern example event tuple clickcr1 .
action dobj np click easy level click easy level cr2 .
action nsubjapss np easy level is clicked click easy level cr3 .
action pobj np i made a click on easy level click easy level edittr1 .
action dobj obj attr prep pobj np input xxyyzz to server address input server address xxyyzz prep on in to tr2 .
action dobj obj attr np prep pobjinput server address np with xxyyzz input server address xxyyzz prep with by tr3 .
action dobj obj attr np prep pobjchange server address np to xxyyzz change server address xxyyzz prep to with action change tr4 .
tr1 tr2 input a number to kilometer input kilometer km eg noun num unit str e.g.
km eg gesture nr1 .
action rotate the screen rotate a b fig.
examples of dependency trees a. phase analyzing bug reports recdroid uses grammar patterns to extract the the semantic representations of events i.e.
the tuple action gui component input described in a bug report.
grammar patterns the grammar patterns were derived from the corpus of android bug reports described in section ii a. these patterns are broadly applicable and can be reused e.g.
by compiling them into a library for new android bug reports.
specifically for each bug report we analyzed the dependencies among words and phrases in the sentences describing reproducing steps.
specifically we use spacy s grammar dependency analysis to identify the part ofspeech pos tag e.g.
noun v erb of each word within a sentence parse the sentence into clauses e.g.
noun phrase and label semantic roles such as direct objects.
fig.
shows an example of the results of the spacy dependency analysis on two sentences with different structures.
broadly the grammar patterns could be grouped intro three types of interactions with an app click events e.g.
click buttons check checkboxes edit events e.g.
enter a text box with a number and gesture events e.g.
rotate .
table i lists the eight typical grammar patterns the full list can be found in our artifacts .
column shows the percentage of the bug reports in which each grammar pattern applies.
we next describe these patterns.
click events.
recdroid uses seven grammar patterns to extract the click event tuple.
the input element in the tuple is not applicable to click events.
in table i cr1 specifies that the direct object i.e.
dobj of the click action is the target gui component.
also the noun phase np of the direct object corresponds to the target gui component.
the second pattern cr2 identifies the gui component that has an nsubjpass i.e.
passive nominal subject relation with the action word.
the third pattern cr3 specifies that the object of a preposition pobj of the click action is the target gui component.edit events.
we identified grammar patterns for extracting edit events.
in table i the first grammar pattern tr1 specifies that if the preposition is a word in on in to the direct object dobj is the input value and the preposition object pobj is the target gui component.
on the other hand in the second pattern tr2 if the preposition is with or by the direct object dobj is the gui component and the preposition object pobj is the input value.
the change action requires a special grammar pattern to handle tr3 because the preposition object is often preceded by a target gui component and followed by an input value.
as for the fourth grammar pattern tr4 we observe that words happening after the phrase eg containing an introducing example e.g.
e.g.
example say especially noun often involve input values.
therefore tr4 specifies that if the sentence prior to eg contains a user action and a gui component detected by a grammar pattern tr1 tr2 ortr3 then egcontains an input value associated with the gui component.
to extract the input value recdroid first extracts the noun fromegand if the noun is a number num it is identified as an input value.
recdroid then searches for the word right after the number and if the word is a unit unit kg cm litter it is added as a target gui component.
otherwise if no numbers are found in eg the whole phrase egis identified as a regular string input str .
gesture events.
the grammar patterns for gesture events involve only the action element in the event tuple.
the current implementation of recdroid supports only the rotate event.
nevertheless our grammar patterns can be extended by incorporating other events such as zoom and swipe.
extracting event representations given a bug report recdroid uses the grammar patterns to extract event representations i.e.
event tuples relevant for reproducing bugs.
recdroid first splits the crash description into sentences where sentence boundaries are detected by syntactic dependency parsing from spacy .
it then applies stemming to the words in each sentence with each word assigned a sentence id used for the guided exploration .
next recdroid determines if a sentence describes a specific type of event.
to do this we construct a vocabulary containing words that are commonly used to describe the three types of actions e.g.
click enter rotate .
this vocabulary was manually constructed by manually analyzing the corpus of bug reports.
the frequency distribution of the words in the vocabulary can be found in our artifacts .
1stemming is the process of removing the ending of a derived word to get its root form.
for example clicked becomes click .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
recdroid then matches each sentence using the stemmed words against the vocabulary and if any match is found the grammar patterns associated with the event type are applied to the sentence for extracting the target gui components and or input values.
for example the 4th step in fig.
contains a word change so the grammar pattern tr3 is applied.
limitations of using grammar patterns the grammar patterns can be used to extract event tuples from wellstructured sentences.
however in the case of complicated or ambiguous sentences nlp techniques are likely to render incorrect part of speech pos dependency tags or sentence segmentation.
while this problem can be mitigated by training the tags it comes with an additional cost.
moreover the extracted target gui components from the bug report may not match their actual names in the app.
such inaccuracy and incompleteness may negatively impact the efficiency of the dynamic exploration.
section iii b2 illustrates how recdroid obtains additional information from unstructured texts to address the mismatch between bug reports and target apps.
b. phase guided exploration for reproducing crashes the goal of the second phase is to identify short sequences of events that complete the sequence identified in the first phase and allow it to fully and automatically reproduce the reported crash.
to do this recdroid builds and uses a dynamic ordered event tree t v e to guide an exploration of the app s gui.
the set of nodes v represents the app s gui components and the set of edges e represents event transitions i.e.
from one screen to another by exercising the component observed at runtime.
the tree nodes of each level i.e.
screen are ordered shown as left to right according to the descending order of their relevance to the bug report.
during the exploration recdroid iteratively selects for each screen the most relevant component to execute.
if none of the gui components match the bug report recdroid traverses the tree leaves to select another matching but unexplored gui component to execute.
this process continues until all matching components in previous levels i.e.
screens are explored before navigating to the subsequent screens to expand tree levels.
compared to conventional dfs our search strategy can avoid potential traps.
the advantage of using the doet is that by prioritizing the gui components the leaf traversal would always select the leftmost relevant tree leaf to explore without iterating through all components on the screen.
recdroid guided exploration algorithm algorithm outlines the algorithm of recdroid s dynamic exploration.
the algorithm begins by launching the app line and then enters a loop to iteratively construct a dynamic ordered event tree doet lines .
at each iteration recdroid uses the tree to compute an event sequence s line to be executed in the next iteration line .
the algorithm terminates when the reported crash is successfully reproduced lines all paths in the tree are executed lines or a timeout occurs line .
during the exploration recdroid may accidentally trigger crashes different from the one described in the bug report.
recdroid prompts the user when a crash is detected and lets the user decide if it is the correct crash for the purpose of terminating the search.algorithm guided dynamic exploration require app stemmed words from bug report w eg ensure scriptr sequence of events leading to the reported crash s launch t.root launch while time limit do p execute s app ifptriggers br s crash then r save s return ifisaddleafnodes t s.last is true then u getallelem p for each gui element u udo current screen ifismatch u eg w is true then u.status ready can be explored end for t addorderednodes u ordercriteria iffor allleafnodes t is explored then return iffor allleafnodes t is notready then leafnodes ready need backtrack s findsequence t select a gui component to explore after exercising the last gui component from the event sequence s recdroid determines whether the doet should be expanded line .
if a loop or an equivalent screen is detected discussed in section iii b4 recdroid stops exploring the gui components in the current screen.
otherwise recdroid obtains all gui components from the current screen and matches them against the bug report algorithm .
it then orders these components and adds them as the leaf nodes of the last exercised gui component lines .
a gui component is considered to be relevant to the bug report and ordered on the left of the tree level when the following conditions are met it matches the bug report and was not explored in previous levels upon meeting the first condition it appears earlier in the bug report according to its associated sentence id it is a clickable component and does not meet the first condition but its associated editable component matches the bug report because only by exercising the clickable component can the exploration bring the app to a new screen upon meeting any of the above conditions it is naturally more dangerous.
our current implementation considers okanddone as naturally more dangerous components finding because the former component is more likely to bring the app to a new screen.
the routine findsequence line determines which gui component to explore next to find an event sequence to execute in the next iteration.
if any components in the current tree level are relevant to the bug report it selects the leftmost leaf and appends it to s. if none of these components are relevant recdroid traverses the tree leaves from left to right until finding a leaf node that is relevant to the bug report.
instead of adding backtracking steps to s recdroid finds the suffix path from the leaf to root to be executed in the next iteration.
the goal of this is to minimize the size of the event sequence.
if the algorithm detects that none of the leaf nodes are relevant to the bug report it means that we may need to deepen the exploration to discover more matching gui components.
therefore recdroid resets all leaf nodes toready in order to continue the search line .
doet does not capture the rotate action because it is not a gui component.
therefore we need to find the right locations in an event sequence to insert the rotate action line .
we use a threshold rto specify the maximum authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm ismatch require gui component in app u events detected by grammar patterns eg a set of bug report sentences s ensure a boolean value for each event g egdo ifu.similar g.u .
then use word2vec ife.action is edit then u.settext g.input returntrue end for wb generatengram s eg.s wu generatengram u for eachwu wudo for eachwb wbdo ifwu.similar wb .
then ife.action is edit then u.settext d returntrue end for end for returnfalse number of steps to the last event at which rotate was exercised.
finding shows that a crash often occurs steps after the rotate.
therefore by default r .
dynamic matching to determine whether a gui component matches a bug report line recdroid utilizesword2vec a word embedding technique to check if the name i.e.
the displayed text of a gui component issemantically similar with any of the gui components fromthe extracted event representations or the words from sentencesin which grammar patterns cannot be used.
the word2vec model is trained from a public dataset text8 containing million words and is provided along with the source code ofword2vec .
the model uses a score in the range of to indicate the degree of semantic similarity between words indicates an exact match .
recdroid uses a relatively highscore .
as the threshold.
we observed that using a lowthreshold may misguide the search toward an incorrect guicomponent.
for example the similarity score of start and stop is .
but the two words are not synonymous.
algorithm outlines the process of matching a gui component observed at runtime.
recdroid first compares theobserved gui component u with the event tuples e g t o detect if there is a match.
if uis an editable component the corresponding input values from eare filled into the text field lines .
if no matches are found from the previous step recdroid analyzes the sentences in which grammar patternsdo not apply lines .
it generates n grams from both the bug report description and the gui component u lines .
recdroid then compares the content of the guicomponent against the bug report based their generated grams lines .
we consider unigrams single word tokens and bigrams two consecutive word tokens that are commonlyused in existing work .
if an editable gui component does not match any events extracted from grammar patterns recdroid associates thecomponent with the following values d in line input values for other editable components extracted by grammarpatterns that match the data type e.g.
digit string of theeditable component and special symbols appearing in thebug report such as apostrophe comma quote because 2ann gram is a contiguous sequence of nitems from a given sequence of text which has been widely used in information retrieval and natural language processing .
fig.
dynamic ordered event tree doet for figure we observed that such symbols are likely to cause problems finding .
if neither of the two types of values can be foundin the bug report recdroid randomly generates one.
a running example fig.
shows a partial doet for the example in fig.
.
the shaded nodes indicate thegui components leading to the reported crash.
recdroidfirst launches the app and brings the app to the screen infig.
1a.
there is one clickable gui component gin the screen which is not relevant to the bug report.
since bytraversing the leaf nodes only g recdroid does not find any relevant component it sets the status of component g toready and continues the search lines .
in the 2nd iteration recdroid clicks component gand brings the app to fig.
1b.
recdroid ranks the gui components in the currentscreen and adds them to the tree lines .
specifically the first four components i.e.
a s r rr match the bug report description and are ordered on the left of the tree level.internally the four components are ranked in terms of theorders of their appearance in the bug report.
recdroid thenchecks all nodes in the current level and selectsthe leftmost leaf a to execute which brings the app tothe screen of fig.
1c.
at this tree level ais placed on the right because it has been explored before.
in the 4th iteration exercising the leftmost leaf node sbrings the app to fig.
1d since the editable component server matches the bug report description its corresponding input value is filled in and theassociated clickable components are considered to be relevant.because ok is more likely to bring the app to a new screen it is ordered before cancel.
in the last iteration bothaandsare placed on the right because they have been explored.
lastly ris executed and the crash is triggered.
we next illustrate how recdroid backtracks.
suppose in fig.
1c none of the components are relevant to the bug report recdroid would traverse the leaf nodes of the whole doetfrom left to right until finding a matching and unexplored guicomponent.
therefore component sin the screen of fig.
1b would be selected.
so in the next iteration recdroid restartsthe search and executes the sequence l g s. optimization strategies recdroid employs several optimization strategies to improve the efficiency of the algorithmby avoiding exploring irrelevant gui components line .
forexample recdroid checks if the current screen is the same authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
as the previous screen.
a same screen may suggest either an invalid gui component was clicked e.g.
a broken button or the component always brings the app to the same screen e.g.
refresh .
in this case creating children nodes for the current screen can potentially cause the algorithm to explore the same screen again and again.
to address this problem recdroid sets the status of the last exercised gui component gtodead to avoid expanding the tree level from g. we also develop an algorithm to detect loops in each tree path.
for example in a pathdabcabcabc the subsequence abc is visited three times in a row.
in this case recdroid keeps only one subsequence and the leaf node is set to dead so the loop will not be explored in the future.
we omit the details of the loop detection algorithm due to space limitations.
iv .
e mpirical study to evaluate recdroid we consider four research questions rq1 how effective and efficient is recdroid at reproducing crashes in bug reports?
rq2 to what extent do the nlp techniques in recdroid affect its effectiveness and efficiency?
rq3 does recdroid benefit developers compared to manual reproduction?
rq4 can recdroid reproduce crashes from different levels of low quality bug reports?
a. datasets we need to prepare datasets for evaluating our approach.
to avoid overfitting we do not consider the android bug reports that we used to identify the grammar patterns.
instead we randomly crawled an additional bug reports containing the keywords crash and exception from github.
we next included all bug reports from the fusion paper and bug reports from a recent paper on translating android bug reports into test cases .
fusion considers the quality of these bug reports as low so we aim to evaluate whether recdroid is capable of handling low quality bug reports.
we then manually filtered the collected bug reports to get the final set that can be used in our experiments.
this filtering was performed independently by three graduate students who have years of industrial software development experience.
we first filtered bug reports involving actual app crashes because recdroid focuses on crash failures.
this yielded bug reports.
we then filtered bug reports that could be reproduced manually by at least one inspector because some bugs could not be reproduced due to lack of apks failed to compile apks environment issues and other unknown issues.
these bug reports cannot assess recdroid itself and thus was excluded from the dataset.
in total we evaluated recdroid on bug reports from apks.
the cost of the manual process is quite high the preparation of the dataset required around hours of researcher time.
b. implementation we conducted our experiment on a physical x86 machine running with ubuntu .
.
the nlp techniques of recdroidwas implemented based on the spacy dependency parser .
the dynamic exploration component was implemented on top of two execution engines robotium and ui automator for handling apps compiled by a wide range of android sdk versions.
an apk compiled by a lower version android sdk .
can be handled by robotium and that by a higher version sdk .
can be handled by ui automator.
c. experiment design rq1 effectiveness and efficiency of recdroid we measure the effectiveness and efficiency of recdroid in terms of whether it can successfully reproduce crashes described in the bug reports within a time limit i.e.
two hours and efficiency in terms of the time it took to reproduce each crash.
rq2 the role of nlp in recdroid within recdroid we assess whether the use of the nlp techniques can affect recdroid s effectiveness and efficiency.
we consider two vanilla versions of recdroid.
the first version recdroid n is used to evaluate the effects of using grammar patterns.
recdroid ndoes not apply grammar patterns but only enables the second phase on dynamic matching.
the second version is recdroid d which evaluates the effects of applying both grammar patterns and dynamic matching.
the comparison between recdroid dand recdroid ncan assess the effects of using dynamic matching.
recdroid dis a non guided systematic gui exploration technique discussed in section vi .
the time limits for running recdroid nand recdroid dwere also set to two hours.
rq3 usefulness of recdroid the goal of rq3 is to evaluate the experience developer had using recdroid to reproduce bugs compared to using manual reproduction.
we recruited graduate students as the participants.
all had at least month android development experience and three were real android developers working in companies for years before entering graduate school.
each participant read the bug reports and tried to manually reproduce the crashes.
all apps were preinstalled.
for each bug report the participants timed how long it took for them to understand the bug report and reproduce the bug.
if a participant was not able to reproduce a bug after minutes that bug was marked as not reproduced.
after the participants attempted to reproduce all bugs they were asked to use recdroid on the bug reports.
this was followed by a survey question would you prefer to use recdroid to reproduce bugs from bug reports over manual reproduction?
note that to avoid bias the participants were not aware of the purpose of this user study.
rq4 handling low quality bug reports the goal of rq4 is to assess the ability of recdroid to handle different levels of low quality bug reports.
since judging the quality of a bug report is often subjective we created low quality bug reports by randomly removing a set of words from the original bug reports.
we focused on removing words from texts containing reproducing steps.
specifically we considered three variations for each of the bug report reports reproduced by recdroid in order to mimic different levels of quality removing of the words in the report removing of the words in the report and removing of the words in the report.
due to the randomization of removing words from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii rq1 rq3 different techniques and user study br.
steps ptn reproduce success events in sequence time seconds user rd rdn rdd rd rdn rdd rd rdn rdd newsblur check check check .
.
.
markor check n n .
birthdroid check check check .
.
.
car report check check check .
.
opensudoku check n n .
acv check check check .
.
.
anymemo check check check .
.
.
anymemo check check n .
.
notepad check check check .
.
olam check n n .
olam check n n .
fastadapter check check check .
.
.
librenews check check check .
.
.
librenews check n n .
librenews check check check .
.
.
smssync check check check .
.
transistor check check check .
.
.
zom check check check .
.
.
pixart check check check .
.
.
pixart check check check .
.
.
screencam check check n .
.
ventriloid check n n .
nextcloud check check check .
.
obdreader check check n .
.
dagger check check check .
.
.
odk check check check .
.
k9 check n n .
k9 check check check .
.
k9 check check check .
.
.
anki check check n .
tagmo check check check .
.
.
openmf check check check .
.
.
flashcards check check check .
.
.
fastadaptor n n n memento n n n screencam n n n odk n n n aimsicd n n n materialistic n n n total rd.
recdroid.
check crash reproduced.
n crash not reproduced.
not applicable.
exceeded time limit hours .
bug reports we repeated the removal operation five times for each bug report across the three quality levels.
we evaluate the effectiveness and efficiency of recdroid in reproducing crashes in the bug reports.
again the time limit was set to hours.
v. r esults and analysis table ii summarizes the results of applying recdroid recdroid n and recdroid din out of the bug reports.
we did not include the remaining crashes because they failed to be reproduced due to the technical limitations of the two execution engines rather than recdroid.
for example robotium failed to click certain buttons e.g.
.
columns show the number of reproducing steps in each bug report and the number of unique grammar patterns applicable to each bug report.
the numbers in the parenthesis of column indicate the number of false positives left and false negatives right when applied the grammar patterns.
a false positive means that a grammar pattern is applied but the identified text is irrelevant to bug reproduction.
a false negative means that a relevant reproducing step is not identified by any grammar patterns.
columns show whether the technique successfully reproduced the crash the size of the event sequence and the time each technique took.
rq1 effectiveness and efficiency of recdroid as table ii shows recdroid reproduced out of crashes a success rate of .
.
the time required to reproduce the crashes ranged from to seconds with an average time of .
seconds.
all four crash bug reports marked with from the fusion paper and nine bug reports marked with from yakusu were successfully reproduced.
theresults indicate that recdroid is effective in reproducing crashes from bug reports .
the six cases where recdroid failed will be discussed in section vi.
rq2 the role of nlp in recdroid when compared recdroid to recdroid nand recdroid d recdroid successfully reproduced .
and more crashes than recdroid nand recdroid d. for the crashes successfully reproduced by all three techniques the size of event sequence generated by recdroid was smaller than recdroid n and bigger than recdroid d. both recdroid nand recdroid dgenerated short event sequences because like recdroid they do not backtrack.
instead whenever a backtrack was needed they restarted the search from the home screen of the app algorithm .
with regards to efficiency recdroid required .
less time than recdroid nand .
less than recdroid d. overall these results indicate that the use of nlp techniques including both the grammar patterns and the dynamic word matching contributed to enhancing the effectiveness and efficiency of recdroid.
we also examined the effects of false positives and false negatives reported when applying the grammar patterns to each bug report column since false positives may misguide the search and false negatives may jeopardize the search efficiency certain useful information is missing .
in the crashes successfully reproduced by recdroid we found that all false positives were discarded during the dynamic exploration because the identified false gui components did not match with the actual gui components of the apps.
with regards to false negatives we found that they were all captured by the dynamic word matching.
therefore the false negatives and false positives of the grammar patterns did not negatively affect the performance of recdroid although our results may not generalize to other apps.
rq3 usefulness of recdroid the last column of table ii shows the number of participants out of that successfully reproduced the crashes.
while all crashes were reproduced by the participants among all crashes reproduced by recdroid of them failed to be reproduced by at least one participant.
for the seven bug reports that recdroid failed to reproduce the success rate of human reproduction is also low.
these results suggest that recdroid is able to reproduce crashes that cannot be reproduced by the developers.
one reason for the failures was that developers need to manually search for the missing steps which can be difficult due to the large number of gui components.
as columns and in table ii indicate in bug reports the number of described steps is smaller than the number of events actually needed for reproducing the crashes.
another reason was because of the misunderstanding of reproducing steps.
we also compute the time required for each participant to successfully reproduce all bug reports.
the results show that the time for successful manual reproduction ranged from seconds to seconds with an average .
seconds .
less than the time required for recdroid on the successfully reproduced crashes.
such results are expected as recdroid needs to explore a number of events during the reproduction.
however recdroid is fully automated and can thus reduce the painstaking effort of developers in reproduc135 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ing crashes.
among all crashes successfully reproduced by recdroid the reproduction time required by individual participants ranged from to seconds.
in fact two out of the participants spent a little more time on average than recdroid.
it is worth noting that while it is possible the actual app developers could reproduce bugs faster than recdroid recdroid can still be useful in many cases.
first recdroid is fully automated so developers can simply push a button and work on other tasks instead of waiting for the results or manually reproducing crashes.
second recdroid can be used with a continuous integration server to enable automated and fast feedback such that whenever a new issue is submitted recdroid will automatically provide a reproducing sequence for developers.
third users can use recdroid to assess the quality of bug reports a bug report may need improvement if the crash cannot be reproduced by recdroid.
the participants were then asked to use recdroid and indicate their preferences for the manual vs tool based approach.
we used the scale very useful useful and not useful .
our results indicated that out of participants found recdroid very useful and would always prefer recdroid to manual reproduction participants indicated recdroid is useful and one participant indicated that recdroid is not useful.
the participant who thought recdroid is not useful explained that for some simple crashes manual reproduction is more convenient.
on the other hand the participate agreed that recdroid is useful for handling complex apps e.g.
k .
the participants also suggested that recdroid is useful in the following cases bugs that require many steps to reproduce bugs that require entering specific inputs to reproduce and bug reports that contain too much information.
the above results suggest that developers generally feel recdroid is useful for reproducing crashes from bug reports and they prefer to use recdroid over manual reproduction.
rq4 handling low quality bug reports columns of table iii reports the reproducibility of recdroid for the bug reports at the three different quality levels.
the column success indicates the number of mutated bug reports out of that were successfully reproduced at each quality level.
the column time indicates the average time and the standard deviation required for reproducing the crash.
the results show that among all mutated bug reports for the three quality levels recdroid was able to reproduce and of the bug crashes respectively.
even when of the words were removed recdroid could still successfully reproduce crashes.
the slowdowns caused by the missing information with respect to the original bug reports were only .7x .2x and .9x respectively.
these results suggest that recdroid can be used to effectively handle low quality bug reports with different levels of missing information.
vi.
d iscussion limitations.
the current implementation in recdroid does not support item list swipe or scroll actions.
in our experiment three fail to be reproduced bug reports fastadaptor113 materialistic aimsicd were due to the lack of support on these actions.
we believe that recdroid can betable iii rq4 different quality levels br.
ql ql ql success time sec success time sec success time sec newsblur markor birthdroid car report opensudoku acv anymemo anymemo notepad olam olam fastadapter librenews librenews librenews smssync transistor zom pixart pixart screencam ventriloid nextcloud obdreader dagger odk k9 k9 k9 anki tagmo openmf flashcards extended to incorporate these actions with additional engineering effort.
second recdroid cannot handle concurrency bugs or nondeterministic bugs .
in our experiment three fail to be reproduced bug reports memento screencam32 were due to non determinism and one odk was due to a concurrency bug.
for example to trigger the crash in odk it requires waiting on one screen for seconds and then clicking the next screen at a very fast speed.
in some cases heuristics can be added to handle timing issues such as allowing specific actions to wait for a certain time period before exploration.
third recdroid focuses on reproducing crashes.
it does not generate automated test oracles from bug reports so it is not able to reproduce non crash bugs.
nevertheless recdroid can still be useful in this case with certain human interventions.
for example during the automated dynamic exploration a developer can observe if a non crashed bug e.g.
an error message is reproduced.
fourth recdroid does not support highly specialized text inputs if the input is not specified in the bug report.
recent approaches in symbolic executions may prove useful in overcoming this limitation .
finally recdroid is targeted at bug reports containing natural language description of reproducing steps.
in the absence of reproducing steps recdroid would act as a generic gui exploration and testing tool i.e.
rddin the experiment .
android testing tools.
as a generic gui exploration and testing tool recdroid dis similar to existing android testing tools which detect crashes in an unguided manner.
recdroid dwas shown to be competitive with monkey sapienz and the recent work stoat on our experiment subjects.
specifically recdroid dreproduced more crashes than stoat more crashes than sapienz authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and more crashes than monkey.
for the crashes successfully reproduced by all three techniques the size of event sequence generated by recdroid dwas .
smaller than stoat .
smaller than sapienz and .
smaller than monkey.
with regards to efficiency recdroid drequired .
more time than stoat .
less time than sapienz and .
less time than monkey.
the details can be found in our released artifacts .
threats to v alidity.
the primary threat to external validity for this study involves the representativeness of our apps and bug reports.
however we do reduce this threat to some extent by crawling bug reports from open source apps to avoid introducing biases.
we cannot claim that our results can be generalized to all bug reports of all domains though.
the primary threat to internal validity involves the confounding effects of participants.
we assumed that the students participating in the study for rq3 were substitutes for developers.
we believe the assumption is reasonable given that all participants indicated that they had experience in android programming.
recent work has also shown that students can represent professionals in software engineering experiments.
vii.
r ela ted work related work has focused on augmenting bug reports for android apps .
specifically fusion leverages dynamic analysis to obtain gui events of android apps and uses these events to help users auto complete reproduction steps in bug reports.
this approach helps end users to produce more comprehensive reports that will ease bug reproduction.
however this technique does not reproduce crashes from the original bug reports.
we see our approach and fusion as complementary if users were to utilize fusion this would improve the overall quality of the bug reports and increase the success rate of our technique even further.
a tool called yakusu on translating executable test cases from bug reports presented in a recent paper is probably most related to our approach.
however the goal of yakusu is translating test cases from bug reports instead of reproducing bugs e.g.
crashes described in the bug report.
therefore event sequences generated by yakusu may not reproduce all relevant crashes.
in addition yakusu does not extract input values for editable events.
instead it will randomly send an input.
in contrast recdroid defines a family of grammar rules that can systematically extract the relevant inputs from bug reports.
as our study finding shows a non trivial portion of crashes involve specific user inputs.
moreover we conducted a more thorough empirical study to show how nlp uncovered bugs that would not be discovered otherwise.
moreover we conducted a user study although light weighted to show usefulness of recdroid.
furthermore in terms of generality the family of grammar rules derived by recdroid is from a large number of bug reports.
we also provided empirical evidence to explain the assumption and the heuristics employed in recdroid.
there has been considerable work on using nlp to summarize and classify bug reports .
for example chaparro et al.
use several techniques to detect missing informationfrom bug reports.
perflearner extracts execution commands and input parameters from descriptions of performance bug reports and use them to generate test frames for guiding actual performance test case generation.
zhang et al.
employ nlp to process bug reports and use search based algorithm to infer models which can be used to generate new test cases.
while these techniques apply nlp techniques to analyze bug reports they cannot synthesize gui events from bug reports to help bug reproduction.
there are several techniques on using nlp to facilitate dynamic analysis .
for example dase to extract input constraints from user manuals and uses the constraints to guide symbolic execution to avoid generating too many invalid inputs.
however these techniques make assumptions on the format of the textual description and none of them automatically reproduces bugs from bug reports.
there are tools for automatically reproducing in field failures from various sources including core dumps function call sequences call stack and runtime logs .
however none of these techniques can reproduce bugs from bug descriptions written in natural language.
on the other hand these techniques are orthogonal to recdroid and developers may decide which technique to use based on the information available in the bug report.
there has been a great deal of work on detecting bugs or achieving high coverage for android applications using gui testing .
these techniques systematically explore the gui events of the target app guided by various advanced algorithms.
however none of these techniques reproduce issues directly from bug reports.
viii.
c onclusions and future work we have presented recdroid an automated approach to reproducing crashes from bug reports for android applications.
recdroid leverages natural language processing techniques and heuristics to analyze bug reports and identify gui events that are necessary for crash reproduction.
it then directs the exploration of the corresponding app toward the extracted events to reproduce the crash.
we have evaluated recdroid on bug reports from android apps and showed that it successfully reproduced crashes fail to be reproduced bug reports were due to the limitations of the execution engines rather than recdroid.
a user study suggests that recdroid reproduced crashes not reproduced by at least one developer and was preferred by developers over manual reproduction.
additional evaluation also indicates that recdroid is robust in handling low quality bug reports.
as future work we intend to leverage the user reviews from app store to extract additional information for helping bug reproduction.
we also intend to develop techniques to automatically extract grammar patterns from bug reports.