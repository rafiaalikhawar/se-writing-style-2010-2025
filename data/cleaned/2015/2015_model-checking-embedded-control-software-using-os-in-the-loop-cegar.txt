model checking embedded control software using os in the loop cegar dongwoo kim school of computer science and engineering kyungpook national university daegu south korea kdw9242 gmail.comy unja choi school of computer science and engineering kyungpook national university daegu south korea yuchoi76 knu.ac.kr abstract v erification of multitasking embedded software requires taking into account its underlying operating system w.r .t.
its scheduling policy and handling of task priorities in order to achieve a higher degree of accuracy.
however such comprehensive verification of multitasking embedded software together with its underlying operating system is very costly and impractical.
to reduce the verification cost while achieving the desired accuracy we propose a variant of cegar named oilcegar os in the loop counterexample guided abstraction refinement where a composition of a formal os model and an abstracted application program is used for comprehensive verification and is successively refined using the counterexamples generated from the composition model.
the refinement process utilizes the scheduling information in the counterexample which acts as a mini os to check the executability of the counterexample trace on the concrete program.
our experiments using a prototype implementation of oil cegar show that oilcegar greatly improves the accuracy and efficiency of property checking in this domain.
it automatically removed all false alarms and accomplished property checking within an average of seconds over a set of multitasking programs whereas model checking using existing approaches over the same set of programs either showed an accuracy of under .
or was unable to finish the verification due to timeout.
index t erms cegar embedded os multitasking i. i ntroduction an embedded system consists of a number of devices controlled by software programs.
such control software is typically multitasking and runs on top of an operating system designed for controlling small scale embedded devices such as sensors actuators brake pedals engines etc.
which are mostly used in safety critical domains.
the control program in particular is tightly coupled with its underlying operating system as they are compiled together to generate a piece of embedded control software and the behavior of the control program can therefore not be analyzed accurately without taking into account the behavior of the operating system.
however research and practice in this domain have focused either on the verification of the control program or on the verification of the operating system independent of each other due to the huge verification cost when trying to comprehensively verify application software together with the implementation of the operating system.
v erifying embedded control software without considering the underlying os often results in a high rate of false alarms as such verification is highly likely to refute a given verification property based on incorrect execution sequences among tasks.
for example a low priority task may be preempted by higher priority tasks in a control program.
such behavior is determined by the system configuration and the scheduling policy of the os used.
most existing approaches that do not consider the underlying os use sound abstraction of the scheduling behavior such as non deterministic scheduling of tasks .
our experiments showed that these approaches had an accuracy of only .
verifying only two of the applications within the time bound.
this work sets out to find an efficient verification method for multitasking embedded control software that reduces false alarm rates as well as verification cost.
to this end we adapted the cegar approach where abstraction verificationrefinement iterations are successively performed until a real problem is identified or the given property is verified to the domain of embedded software by taking the operating system into the loop.
our approach named oil cegar os in theloop cegar is unique in that it utilizes models of the operating system which are assumed to be correct w.r.t.
the requirements specifications and we take advantage of two different types of model checkers a symbolic model checker nusmv for property checking and the c code model checker cbmc for code based false alarm identification.
for a given property oil cegar first tries to verify the property on the composition of the operating system model and the application model abstracted from the program source code.
if the property is refuted the model checker nusmv generates a counterexample trace including task scheduling information and the control flow of the application program.
this task scheduling information is used to construct a minios for the application source code so that cbmc can be used to check the executability of the given trace in the concrete application program.
if the trace is executable then the counterexample is a real alarm.
otherwise the composition of the os model and the application model is refined using the trace so that the next iteration of oil cegar can be performed.
oil cegar is efficient in identifying real property violations with moderate verification cost even though more complexity is introduced by taking the os model into ac5652019 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
task t2 priority event e1 ...application program system con figuration run t1 sus runrdy witrun runrdy run sus sussus run sus t2at t2 we e1 se t2 e1 tt at t2 tt expected simulation int wait sw off task t1 int local var int p p local var local var on activatetask t2 if wait sw on wait sw on local var off p local var setevent t2 e1 activatetask t2 terminatetask task t2 int t2 sw t2 sw off if wait sw!
on wait sw on waitevent e1 terminatetask runrdy tt task t1 autostart true priority fig.
.
a multitasking program and its expected execution sequence count.
this is possible through two way abstractions code abstraction for the property checking and os abstraction for the executability checking and by utilizing two different model checking approaches suited best for the verification of statemachine based models and the verification of program source code respectively.
a prototype implementation of oil cegar was applied to three sets of experiments.
it showed verification accuracy automatically removed all false alarms and accomplished property checking within seconds on average whereas existing verification approaches using cbmc and y ogarcbmc showed a verification accuracy of and .
respectively over the same set of programs.
the remainder of this paper is organized as follows.
after a brief introduction of the research background in section ii we formally define the basic terminology used throughout this paper in section iii.
section iv introduces the oilcegar process section v explains the abstraction techniques applied to the program source code and section vi describes the methods used for constructing models for oil cegar.
an experimental result of oil cegar is explained in section vii.
we conclude with a brief discussion in section ix after summarizing related work in section viii.
ii.
b ackground a multitasking application program consists of a set of tasks.
each task has its own priority so that a task with higher priority is scheduled earlier than tasks with lower priority.
it is also possible for a task with lower priority to run prior to a task with higher priority if it accesses a critical section by occupying resources.
a running task may be in a waiting state by voluntarily waiting for an event.
an application program interacts with its underlying operating system through api functions provided by the os.
figure shows an example of the embedded application program that will be used throughout this paper.
given the system configuration the two tasks are expected to be executeda counterexample satis fiable yesno m m m m refine m unsatis fiable m m does feasible?
fig.
.
counterexample guided abstraction refinement as shown in the lower part of the figure the autostart task t1 runs first and activates task t2 which has higher priority.
task t2 preempts t1 runs to set wait swto on and goes to the waiting state by calling waitevent e1 giving another execution round to task t1.
t1 calls setevent for task t2 as the branch condition in line evaluates to true which preempts t1 again and wakes t2.
after t2 terminates t1 activates t2 again but t2 terminates immediately as wait swevaluates to on.
a. v erification of embedded control software the behavior of an embedded application program is determined by its system configuration task logic and os behavior which typically produce a unique deterministic trace unless an interrupt occurs.
if we abstract the operating system e.g.
by using non deterministic scheduling we need to consider multiple execution traces for the same program as context switching may occur at any instruction of each task.
for example there can be up to 15c5 execution sequences to check for the program in figure if we assume that a context switch may occur in every line of the program.
it is extremely expensive to perform comprehensive verification in this case both in terms of performing model checking for property checking and in terms of identifying false alarms produced by incorrect task execution sequences.
we note that even software level dynamic testing of an embedded control program is difficult because embedded software requires a specific hardware platform platform specific library functions and other peripherals such as sensors and event generators.
software level testing often requires specific simulation environments which are not always available in the development process.
b. counterexample guided abstraction refinement cegar is an effective verification method for alleviating verification complexity through successive abstractionverification refinement iterations.
figure shows the overall process of cegar.
it starts with an initial abstraction of a given application tildewiderm.
if the abstract model is verified for a given property then we can safely conclude that the concrete application is verified as the model is a sound abstraction of the application.
otherwise the counterexample generated from checking is tested on the concrete application to determine whether it is an actual execution trace as it may be the case that the trace is possible only on the abstract model false alarm .
if it is executable on a concrete application it shows a property violation of the system true alarm .
otherwise is used to refine tildewiderm which is verified w.r.t.
in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
..n ..n idkernelobject parameter use alarm state held released priority intresourceinvoke state suspended ready running waiting mode standard extended priority inttask isr api namesystem call1os kernel1provide belong to state cleared set eventinvoke ..n10.. .. set0.. triggers1 allocates fig.
.
structure of an embedded operating system osek vdx the next iteration.
this process is repeated until a real alarm is identified or until the property is verified.
cegar has been successfully applied in various application domains .
however it has not been clear whether it can be effectively applied to multitasking embedded software taking into account the os behavior.
c. f ormal models of embedded operating system a number of approaches for formally modeling and verifying embedded operating systems have been proposed.
most notably the construction of sel4 is based on successive refinements of a formal os model written in haskell which is thoroughly verified for correctness w.r.t.
the functional requirements of a real time embedded operating system.
the other notable example is the formal modeling of embedded operating systems that are compliant with the osek vdx international standard .
approaches include for example modeling in promela csp nusmv uppaal and the k framework .
oil cegar is independent of formal models and modeling approaches but this work adopts the pattern based automatic model construction approach suggested in to facilitate automation of the oilcegar process.
figure shows the internal structure of the embedded operating system used in modeled by referring to the osek vdx international standard.
an os kernel consists of a set of kernel objects which can be tasks events resources or alarms.
a task or thread is the basic building block of embedded software.
an embedded os maintains the internal states of each task which typically consists of running ready waiting suspended as in the osek vdx os zephyr freertos etc.
with minor variations.
the internal state of each task changes according to the task management and scheduling mechanism in the os kernel which is triggered by requests from the application program through api function calls.
a task may set a periodic alarm to activate another task or to set an event.
an external event triggers a corresponding isr interrupt service routine which may call api functions.
the osek os adopts priority based fifo scheduling with dynamically changing ceiling priorities for resource allocation in order to avoid the priority inversion problem.
reference formally modeled the behavior of each kernel object as a parameterized statemachine called patterns and defined an os model as a synchronized parallel compo sition of multiple kernel objects whose types and numbers are determined by the system configuration.
in addition an os generator was defined as a function from configuration vectors to formal os models.
this approach is implemented as a prototype tool for automated model construction by composing the formal patterns specified in the input language of nusmv or spin .
the generated os models are validated through property verification using a set of functional requirements identified from the osek vdx international standard.
for more details on the osek os and pattern based os model construction please refer to .
our work utilized the prototype tool with a minor extension to the os model.
to enable a focused discussion of oil cegar however throughout this paper an os model is assumed to be a black box component where transitions among internal states of tasks are the only externally visible behaviors.
iii.
b asic definitions this section defines the terminologies required to explain oil cegar.
definition .
a control flow graph cfg for a task tcfg n e n nt is a directed graph where nis a set of statement blocks n0 nis a unique entry block nt nis a unique exit block and e n nis a set of directed control flow edges.
a statement block is a sequence of statements.
it is also a unit of atomic execution.
each statement block consists of the maximal number of statements that can be executed in a single control thread.
to formally define a statement block we use the notion of visible variable and visible statement similar to the notion introduced in .
definition .
visible variables and visible statements a visible variable is a variable that is globally accessible or that uses other visible variables.
visible variables include global variables pointer variables and variables in shared memory a visible statement is a simple statement that either defines uses a visible variable or calls an api function.
definition .
a statement block is the maximal sequence of statements a1 ... anin a task where only the first statement in the block is visible and there is no statement that uses any variables defined in previous statements i.e.
def ai use aj for alli j n. each statement block contains at most one visible statement and is a unit of context switching i.e.
the control flow may be switched to other tasks after the statement block has been executed.
definition .
m s s r is a statemachine where sis a set of states s0is a set of initial states and r s g s is a set of transition relations triggered by a set of events including a null event and guarded by a set of guarding conditions g. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a counterexample satis fiable yesno m mapp m m a unsatis fiable mos mapp mos mapp mos mapp n rm mos mapp fig.
.
os in the loop cegar a transition r ris represented as sie sj wheresiand sjare the source and target states respectively.
we sometimes abbreviate a sequence of transitions s0e1 s1e2 s2e3 en snass0s1s2...snto save space.
we use two composition operators on statemachines and which are defined as follows definition .
m1 m2 s s r is a synchronous parallel composition of two statemachines m1 s1 s1 r1 and m2 s2 s2 r2 synchronized over a set of events in where s s1 s2 s0 s1 s2 and r r1 r2such that s1 ie s1 j r1ands2 pe prime s2 q r2implies s1 i s2 p e s1 j s2 q rife e prime s1 i s2 p e s1 j s2 p r and s1 i s2 p e prime s1 i s2 q r. a synchronous parallel composition of two statemachines allows each statemachine to perform its own transition while the other stays in the same state.
definition .
m1 m2 s s r is a trace composition of two statemachines m1 s1 s1 r1 andm2 s2 s2 r2 w.r.t.
the set of error states s2 einm2and a labeling function lovers1 s2 where s s1 s0 s1 and r r1 wherer s1 ie s1 j riffr r1and r prime s2 pe s2 q r2such that s2 q negationslash s2 e l s1 i l s2 p l s1 j l s2 q andg g prime.
a trace composition only allows a transition of a statemachine when the other statemachine has an equivalent transition w.r.t.
the state labels and transition conditions that does not lead to an error state.
iv .
o il cegar oil cegar takes advantage of both cegar and the use of the os in the model checking process with a two way reciprocal abstraction scheme.
it is a variation of cegar in that a verified os model is used to enhance theaccuracy of the property checking and the scheduling information in the counterexample generated from the property checking is used to construct a mini os instead of the fullscale os implementation for checking the executability of the counterexample on the program source code.
this section provides an intuitive introduction to oilcegar.
technical details will be provided in later sections.
a. overview of oil cegar figure illustrates the oil cegar process.
it starts with the composition of a verified os model mosand an initial sound abstraction tildewidemapp of a given application program mapp.
for a given property if the composition model m mos tildewidemapp respects the property i.e.
m then we conclude that the concrete embedded software os mapp also respects the property.
otherwise a counterexample showing a property violation in the form of a sequence of states in m is generated.
as can be a false alarm due to the use of the abstract model tildewidemapp in the verification so we need to check its executability on the concrete system os mapp.
however as it is difficult to construct an execution environment for the actual implementation of the os and the application program we instead check the reachability of the composition tildewidermos mapp where tildewidermos is a mini os constructed from so that if it terminates in a final state we can conclude that is an executable execution sequence in the concrete program i.e.
a true alarm.
otherwise a trace prime a subsequence of from the initial state to the first unreachable state of is generated and is used to refine m which is used in the next iteration of oil cegar.
this process is repeated until either an actual property violation is found or the property is proved.
two well known model checkers are used in oil cegar the symbolic model checker nusmv for ltl property checking of mos tildewidemapp and the sa t based c code model checker cbmc for checking the reachability of tildewidermos mapp.
b. construction of tildewidemapp an application program is a parallel composition of multiple tasks i.e.
mapp p1 p2 ... pn.
we construct an abstraction of mapp tildewidemapp by abstracting each task i.e.
tildewidemapp mp1 mp2 ... mpn where each mpiis a statemachine representation of each task pi.
figure illustrates how each task piis modeled as a statemachine using the example code shown in figure .
we first construct a control flow graph cfg of each task abstract the cfg by eliminating statements involving visible variables and then transform the abstract cfg into a statemachine model by adding transitions from the exit node to the entry node as a task can be reactivated after its termination and guarding conditions to each transition to check the internal state of the task.
details of the conversion process will be explained in section vi.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
activatetask t2 p local var local var on a control abstracted cfg c task modelwait sw on local var off p local var setevent t2 e1 activatetask t2 terminatetask task t1 initial terminal mtt2 sw off wait sw on waitevent e1 terminatetask task t2 initial terminal b1 b1 b1 3b1 b1 b1 b1 b1 8b2 b2 b2 b2 b2 activatetask t2 local var on local var off setevent t2 e1 activatetask t2 terminatetask task t1 initial terminalt2 sw off waitevent e1 terminatetask task t2 initial terminalb1 b1 b1 3b1 b1 b1 b1 b1 8b2 b2 b2 b2 b2 b data abstracted cfg activatetask t2 local var onlocal var off setevent t2 e1 activatetask t2 terminatetask task t1 initial terminalt2 sw off waitevent e1 terminatetask task t2 initial terminal ... ...... ... ... ... ... ... ............... b1 b1 b1 3b1 b1 b1 b1 b1 8b2 b2 b2 b2 b2 fig.
.
construction of the task model rdyrun sus init run run rdy run wit run wit init wit susrun witrun rdy run init sus run rdy run rdy init sus init init susrdy run run init sus run init sus run rdy sus runrun witrun sus initrdy run rdy run run wit run witrun init sus run init sus run rdy run rdys0 s2s3 s5 s7 s11s8 s16 s12s14s17 s18 s21 s23 s24 s13s25s1 s4 s6 s9 s10s19 s20 s22 s15 s26 b1 b1 2b1 b1 b1 b1 2b1 b1 3b1 b1 4b1 b1 5b1 b1 6b1 b1 b1 7b1 b1 7b1 b1 b1 b1 b1 b1 8b2 b2 1b2 b2 2b2 b2 3b2 4b2 b2 b2 b2 b2 b2 4b2 4b2 b2 b2 4b2 fig.
.
composition of the os model and the application model of the program in figure tildewidemapp is composed with the os model.
figure 61illustrates a simplified mos tildewidemapp for the example in figure where each state consists of the internal state of task t1 the internal state of task t2 the block number of task t1 and the block number of task t2 respectively.
the transition finishes either ats13 indicating that task t2 is in the waiting state or at s26 indicating that all the tasks have terminated.
let us assume that we are checking the following property p1.
a call to waitevent shall be followed by a matching call tosetevent .
model checking this property would generate a counterexample say s0s1s2s4s5s6s7s11s12s13s13s13... wheret2 would go to the waiting state and stay there forever.
is a finite maximal subsequence of a counterexample trace that does not end with a cycle.
c. executability checking using whether the counterexample is a realistic execution trace or not is tested in the concrete application program mapp.
as the counterexample trace contains information on task execution sequences we use this information to guide the execution sequence of the tasks in the actual program code.
the task execution sequence is a sequence of states in projected to the states of the os.
for example os s0 oss1 os...s oss13 os run sus run sus rdy run rdy run rdy run rdy run run wit ru n wit run wit sus wit and its corresponding task execution sequence is t1t1t2t2t2t2t1t1t1 where the unit of an execution is a block in the control flow graph as shown in figure a .
in other words b1 1b1 2b2 1b2 2b2 3b2 4b1 3b1 7b1 is the actual sequence of blocks to be executed according to this counterexample trace.
however it is impossible to execute b1 7afterb1 i.e.
s7 s11is a non executable transition in because if wait sw on it must execute b1 .
we use the c code model checker cbmc to identify the first non executable transition in the counterexample trace using the information on the task execution sequence extracted from the trace called mini os which acts like a test driver.
if the counterexample trace has an unreachable transition in the actual application program we use the same trace up to the first unreachable state named prime to refine mos tildewidemapp.
d. refinements using prime once primeis identified we refine mos tildewidemapp so that prime can be eliminated from its possible execution traces.
to this end we first construct a statemachine a prime s s t se wheres s prime.s su is the set of states in prime plus one additional special state surepresenting the universal state s0is the initial state in prime seis the final state of prime representing the error state and t prime.t s su s negationslash se su su se se is a set of transitions in prime plus new transitions from each non error state to the universal state plus self transitions of suandse.
figure illustrates a prime for our example for each iteration of oil cegar.
1run rdy wit and sus are abbreviations for running ready waiting and suspended authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a 1 a a 2 b a 3 c sus0s1s2 s4 s5 s6 s7s0 s1 s2 s4s0 s1s2 s4s5 s6 s7 s8 s9 s10s14s21s22 se seses23susu fig.
.
refinement bases tildewidemapp is refined by constructing mos tildewidemapp a prime where represents the trace composition of the two statemachines.
the trace composition a ballows transitions of aonly when aandbshare the equivalent source target states and satisfy both transition conditions and when the target state is not the error state.
for example the trace composition of mos tildewidemapp shown in figure and a 1 in figure a results in removing the trace s0s1s2s4s5s6s7s11 from mos tildewidemapp .
the oil cegar process is repeated from the property checking of mos tildewidemapp a 1 producing refinement bases as shown in figure b and figure c and thus removing traces s0s1s2s4s3and s0s1s2s4...s 10s14s21s22s23s15in order before it concludes that the property is satisfied.
v. a bstraction oil cegar starts by constructing an application model tildewidemapp as a synchronous parallel composition of statemachines each representing a task in the application program.
this section explains two major abstractions applied to the source code of each task before the application model was composed with the operating system model.
a. pre processing due to the limited expressive power allowed in the input language of nusmv compared to that of the implementation language c we performed two types of pre processing on the source code.
first user defined functions were replaced with inline functions assuming that the program did not contain any infinite recursive calls.
second composite structures such as arrays and user defined structures were flattened so that all variables were typed as primitives assuming that there were no dynamic allocations and that they were thus of fixed size.
these assumptions are valid for embedded systems in critical domains as recommended by the misra c international standard .
b. control abstraction multitask programs have multiple threads of control that interleave with each other.
this context switching may happen as low as at the instruction level but it is infeasible as well as uninteresting to consider all possible context switchingbehaviors in multitasking programs.
in this work we applied control abstraction to the cfg of each task based on the notion of partial order reduction by defining the statement block as a maximal sequence of statements to be executed without interrupts.
the statement block in definition is a unit of such a context switch whose execution is independent of concurrently executed transitions of other tasks.
the cfg of each task in the application source code was constructed using the statement block as a unit of execution.
the rationale behind this was non visible variables would not be affected by context switching but visible variables may be and a call to an api function certainly causes an intervention of the operating system that may require context switching among tasks.
in addition we refined the statement block to separate statements with def use relations into different blocks due to the execution semantics of nusmv which executes all statements in a block at the same time.
figure a shows the control abstracted cfg of figure .
blocksb1 1andb1 4in figure a are the abstraction of lines and lines of figure respectively.
line is not blocked together with lines because it is a visible statement and also