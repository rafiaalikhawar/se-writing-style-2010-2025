runtimesearch ctrl f for a running program mat u s sul r jaroslav porub an technical university of ko sice slovakia email fmatus.sulir jaroslav.porubang tuke.sk abstract developers often try to find occurrences of a certain term in a software system.
traditionally a text search is limited to static source code files.
in this paper we introduce a simple approach runtimesearch where the given term is searched in the values of all string expressions in a running program.
when a match is found the program is paused and its runtime properties can be explored with a traditional debugger.
the feasibility and usefulness of runtimesearch is demonstrated on a medium sized java project.
index terms program comprehension dynamic analysis debugger text search concept location i. i ntroduction currently the programmers use the debugger available in their ide integrated development environment to execute and step a program and inspect its state.
on the other hand searching is typically performed on static source code and it does not utilize dynamic information.
a. motivation suppose a developer needs to answer a common question where in the source code is the label displayed in the ui user interface of a running program located?
static source code search for the given term often does not produce desired results since only a portion of the strings is located in the source code in a form of string constants.
dynamically generated and localized strings user input data obtained from other systems and many other strings may not present in the static source code of the application .
instead the developer should ask which expression contains the given string in its value at runtime?
a question like this could be possibly answered by writing custom scripts and queries in automated and scriptable debuggers such as coca frtime or e xpositor .
however we should take the reality of developers into account the cost of learning to use a tool must be lower than the expected benefit of its application.
ideally the developer should use a tool immediately or only after minimal training.
even when using existing tools like a textual search developers prefer simple queries compared to complicated sophisticated ones .
considering the developer already found the source code location related to the ui element she will probably want to examine it from the dynamic viewpoint inspect the concrete values of variables at a specific moment view the stack frame etc.
currently searching and debugging are considered separate actions accomplished with different tools.
however according to multiple empirical studies these two activities are often interleaved.
for example based on the results ofa field study with professional developers damevski et al.
argue there should be better integration between code search navigation and debugging.
wang et al.
studied developers locating relevant parts of source code two of three search patterns the developers used encompassed running and debugging the program.
after finding and inspecting an initial point of investigation developers often aim to find other occurrences relevant to this point.
for instance they try to determine where the data from a certain variable flow .
in theory this is easy to accomplish using approaches such as dynamic program slicing .
in practice the data can flow through multiple thirdparty systems and return back to the inspected application.
for example a user input can be saved to a database then retrieved and displayed in another part of the application.
classical program slicing approaches could fail to find such a connection.
although cross system slicing approaches emerge they suffer from performance issues or are technologydependent .
b. objective with the mentioned considerations in mind we designed runtimesearch.
it is a variation of a traditional textual search in source code but in this case we are searching in the values of expressions at runtime.
a programmer enters a string which she wants to locate.
it can be for instance a ui label visible in a running program for which she wants to find the source code part displaying it or a string which she hypothesizes is a value of some unknown variable or expression.
if the program is not already running it is launched.
during the runtime all evaluated string expression values are being compared with the searched term.
when a match is found the program execution is paused and a traditional ide debugger is opened.
the programmer can explore runtime properties of the program like the call stack and current variable values.
then she can continue with debugging running or search some string again.
in essence runtimesearch is an extension of a traditional debugging process.
in addition to standard debugging operations like step in or continue a find in runtime action is available.
this runtime search action provides a user interface resembling a simple textual search dialog which practically all developers are familiar with.
therefore the tool should require almost no training.
a preliminary implementation is available and a case study was performed to show the feasibility and usefulness of the .
c ieeease urbana champaign il usa technical research new ideas388 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
technique.
the source code of runtimesearch is available online1.
ii.
s earching in the runtime first we will describe runtimesearch from the user s programmer s point of view.
next we will look at its design and implementation.
a. user s view the interaction and user interface of runtimesearch was modeled with two principles in mind to look similar to a traditional textual search in source code whenever it is possible.
since code searching is a familiar operation for practically every programmer this should make learning the tool easy.
to integrate the approach with the debugging infrastructure already present in ides and used by developers.
each runtime searching begins by triggering the action find in runtime in an ide which shows a query prompt where the developer enters the searched text.
subsequently the searching process is started in one of three ways if no program is currently being debugged a new instance is launched.
if a debugged program is paused it is resumed.
if a debugged program is running it is left running.
the string is searched from the moment it was entered into a prompt until a match is found.
when this happens the program is immediately paused using a programmatically invoked breakpoint.
this causes the ide to highlight the currently executed line and show current variable values.
furthermore all debugging features of the given ide are available including the stack frames view expression evaluation advanced object state inspections etc.
when the programmer considers the current search result irrelevant or wants to find the next occurrence she triggers the action find next in runtime .
in case she wants to change the search string she chooses the action find in runtime .
the process continues as already described.
if the developer does not want to search a string anymore she can continue debugging with traditional operations like step in and step over or resume the program.
at any moment it is possible to search the string in the runtime if desirable.
one of many possible examples of the developer s interaction with runtimesearch is displayed in fig.
.
however the process is not prescriptive and can be adapted to developer s specific needs.
in section iii we will describe multiple usage scenarios.
b. principle we look at a running program as a series of expression evaluations.
consider the following java source code excerpt string var text var var.touppercase start searching a string in runtime a match is found the program is pausedput the program into some state interact with the program inspect the state and call stack step the program ... continue debugging terminate the program...need next occurrence relevant code foundfig.
.
a possible example of runtimeseach utilization.
it produces the following expression values in the given order text a string constant text the value of the variable var read on the second line and text the return value of the method touppercase .
the program is instrumented so the result of every string expression is captured and compared to the searched text.
currently only expressions of type string are captured it makes the most sense to compare the searched text only to strings.
however the approach is not limited to this behavior and in the future we could convert all objects to their string representations using a tostring like method.
namely we capture the following string expressions constants local variables member variables constructor calls and method calls returning values.
in our early implementation the evaluated strings are matched against the query using a simple string containment if the evaluated string contains the searched text a match is found.
again this is not an inherent limitation of the approach.
it can be easily extended with standard text search options like match case whole words only regular expression matching or advanced features like approximate fuzzy string matching.
c. implementation details our runtimesearch implementation consists of a java agent a piece of instrumentation code which can be attached to any authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
java program and a plugin for the intellij idea ide.
the agent is configurable through an argument a pattern specifying what packages or classes should be instrumented.
this way it is possible to specify e.g.
whether to include only application or also system classes.
instrumentation is performed at the bytecode level.
in stackbased virtual machines like the java virtual machine each expression evaluation is represented by an instruction pushing a value on the operand stack which can be used with advantage.
the ide plugin is very lightweight and consists mainly of a simple form and a module for communication with the agent.
iii.
c ase study now we will show how searching in the runtime can be useful to perform navigation and debugging tasks.
the demonstration will be performed on weka2 an open source java machine learning software.
it is a swing gui graphical user interface application with approximately lines of code.
a short video with parts of the case study is available online3.
a. finding an initial point one of the questions programmers ask during program maintenance tasks is where in the code is the text in this error message or ui element?
weka includes a package manager which displays a list of additional packages.
suppose we want to find the code which retrieves package names such as affectivetweets .
searching the static source code for the term affectivetweets does not give any results since this string was generated at runtime.
therefore we run the application in a debug mode and wait until the main window appears.
then we trigger the find in runtime menu in the ide enter the query affectivetweets and press find.
after choosing the menu package manager in weka the program automatically pauses and the ide shows us the currently executed line containing the searched string expression.
we see the first runtime occurrence of the string affectivetweets i.e.
its origin.
not only can we notice it was read from a file input stream it is obvious by reading the source code but thanks to the ide showing a string representation of the stream object at runtime we also see its path in the file system the name of the package list file from which the string affectivetweets was read.
b. searching for occurrences after quickly finding the initial point of investigation it is up to us how to continue.
we can explore the source code find static