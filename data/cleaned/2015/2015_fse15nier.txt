detecting semantic merge conflicts with variability aware execution hung viet nguyen ecpe department iowa state university usamy huu nguyen ho chi minh city university of science vietnamson cuu dang university of technology sydney australia christian k stner school of computer science carnegie mellon university usatien n. nguyen ecpe department iowa state university usa abstract in collaborative software development changes made in parallel by multiple developers may conflict.
previous research has shown that conflicts are common and occur as textual conflicts or semantic conflicts which manifest as build or test failures.
with many parallel changes it is desirable to identify conflicts early and pinpoint the minimum set of changes involved.
however the costs of identifying semantic conflicts can be high because tests need to be executed on many merge scenarios.
we propose semex a novel approach to detect semantic conflicts using variability aware execution.
we encode all parallel changes into a single program in which ifstatements guard the alternative code fragments.
then we run the test cases using variability aware execution exploring all possible concrete executions of the combined program with regard to all possible merge scenarios while exploiting similarities among the executions to speed up the process.
variability aware execution returns a formula describing all failing merge scenarios.
in our preliminary experimental study on seven php programs with a total of test cases and semantic conflicts semex correctly detected all conflicts.
categories and subject descriptors d. testing and debugging general terms algorithms reliability keywords variability aware execution semantic merge conflicts n way merge .
introduction in collaborative software development developers make changes to their local copy of the project files retrieve changes from teammembers and share the changes with them.
when two or more developers simultaneously make incompatible changes a merge conflict arises.
such conflicts put the codebase in an inconsistent state and may delay the project.
due to the fear of merge conflicts developers tend to postpone merging and this very behavior can lead to real conflicts at a later time .
previous research has shown that conflicts are common and occur as textual conflicts or semantic conflicts i.e.
build and test failures .
whereas textual conflicts are easy to detect by analyzing changes in overlapping lines of code semantic conflicts are more difficult to identify and resolve as it requires to compile the code and run the test suite.
brun et al.
reported that of the merges that a vcs reported as clean merges actually contained semantic conflicts.
thus given a set of parallel changes it is desirable to identify early the if any change subset contains a semantic conflict facilitating in quick accountability and corrective actions .
several researchers have proposed mechanisms to raise awareness of parallel changes to detect conflicts already during development .
an easy way to detect conflicts is to merge changes and execute the test suite.
in this context speculative merging actually performs merges among changes before they are requested by developers to identify conflicts during parallel development .
unfortunately the costs of speculative merging and other approaches of conflict avoidance and conflict detection becomes increasingly expensive as the number of changes and branches grows because tests need to be executed on more and more potential merge results.
as any combination of changes may conflict the search space for finding a minimal set of conflicting changes is exponential.
even ignoring potential conflicts or fixes among more than two changes e.g.
when a third change resolves a conflict among two conflicting changes comparing all pairs of changes causes quadratic effort which is expensive with branchmaniabecoming a common phenomenon in many projects .
delta debugging could identify a minimal solution but might not find a global minimum.
we propose semex a novel approach to detect semantic conflicts using variability aware execution .
semex exploits the fact that many test executions are similar and rarely affected by the various changes.
first we encode all parallel changes into a single program with variability via n way merging in which we use a boolean patch variable to represent whether a given change is applied to the original program.
second we use variability aware execution to run the test cases.
variability aware execution explores all possible concrete executions of the combined program in parallel with regard to all patch combinations and returns a propositional this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication esec fse august september bergamo italy c acm.
... ?php function a array ret foreach array as value ret ret value return ret function b array avg a array count array variance foreach array as value variance value avg value avg variance variance count array return variance function c idx array sum foreach array as value sum value return array sum ?
return ret count array p1 avg a array p1 sum a array p2p3 ?php include sequence .php class sequencetest extends phpunit framework testcase public function testsequence array array assertequals a array assertequals b array .
assertequals c array .
?
if idx idx count array error log index out of bounds !
a sequence .php b sequencetest .php ?php function a array ret foreach array as value ret ret value if p1 return ret count array else return ret function b array if p1 avg a array else avg a array count array variance foreach array as value variance value avg value avg variance variance count array return variance function c idx array if p3 if idx idx count array error log index out of bound !
if p2 sum a array else sum foreach array as value sum value return array sum ?
c sequence .php after variability aware merging 9assertequals a array p1 this assertion fails after the merge .figure a semantic merge conflict parts a b and the resulting variability aware merge by our approach in section part c table assertion results on different combinations of the incorporated changes by three developers p1 p2 and p3 p1 p2 p3 c array assertequals c array .
yes yes yes fail yes yes no fail all other cases .
pass formula describing all subsets of those changes for which a test case fails .
the formula describes exactly which changes conflict including the minimum set.
in our preliminary experimental study on seven example php applications with a total of test cases and semantic conflicts semex correctly detected all conflicts in which the set of conflicting parallel changes reported are the actual minimum conflicting changes.
in this paper we contribute .
a novel approach to detect semantic merge conflicts of parallel changes using variability aware execution .
a preliminary experimental study showing the potential benefit of our approach for detecting semantic conflicts .
motiv ation consider a scenario of three developers collaborating on the same simple php program in figure 1a which computes several statistics for a sequence of numbers.
specifically function ainitially com putes the sum of the sequence function bcomputes its variance and function creturns the ratio of a number in the sequence at a given index over the sum of all numbers in the sequence.
suppose that three developers p1 p2 and p3branch the current copy of the program and make simultaneous changes in their local branches.
developer p1changes the implementation of method aso that it now returns the average of the numbers in the sequence instead of the sum.
developer p1also updates a call site of ain method b and its test code figure 1b to reflect this change.
at the same time developer p2recognizes that part of the code in method c to compute the sum of the sequence has already been provided by method a without being aware that the implementation of ahas been modified by developer p1.
thus p2replaces that piece of code with a function call to a. finally developer p3adds an error message for the case that the given array index in method cis out of bounds.
if the three developers committed their changes to the main branch the changes would be merged without textual conflicts.
however the merged version would contain a semantic error the assertion on line of figure 1b would fail if run on the merged version since the code in function cis intended to use the previous version of function a. note that the test case fails if and only if the changes from developer p1andp2are both incorporated into the main branch see table .
given multiple simultaneous changes it is nontrivial to identify a set of changes that directly cause a semantic merge conflict since there could exist an exponential number of subsets of the changes.
927files in branch files in branch files in branch n1.
encoding parallel changesvariability aware merged files2.
variability aware execution semantically conflicting filesfigure approach overview program with variability result for one concrete programresult for all concrete programsconcrete program without variabilityconfigure program variability aware executionnormal execution extract results aggregate results figure variability aware vs. brute force execution .
approach we propose semex a novel approach to detect semantic conflicts using variability aware execution figure assuming textual conflicts are already resolved.
the key ideas are as follows.
first we encode all parallel changes by using special boolean variables called patch variables torepresent whether a given change is applied to the original program .
the result of this step is an encoded program with variability.
to illustrate we show the encoded program for our motivating example in figure 1c in which the added ifconstructs and the patch variables p1 p2 and p3are used to encode the changes made by the three developers.
then to identify a semantic conflict a naive brute force approach could execute the encoded program with all possible values of the patch variables and identify the sets of values that cause a test case to fail.
to avoid the combinatorial explosion faced by such a brute force approach we instead use variability aware execution to run the test cases.
our tool explores all possible concrete executions of the encoded program with regard to all possible values of the patch variables and produces results equivalent to brute force runs on all versions corresponding to all combinations of the changes figure .
when executed on a test case for the encoded program our variability aware execution engine returns a propositional formula describing all subsets of those changes for which a test case fails.
for instance in our example the formula p1 p2 describes all subsets containing changes from p1andp2 which include the two sets fp1 p2 gandfp1 p2 p3 g. such a formula allows us to identify the minimum set of changes that lead to the conflict.
let us detail these steps.
.
encoding parallel changes the goal of this step is to encode simultaneous changes by different developers into a single program with variability.
we assume that textual conflicts are detected first by other merging tools.
our algorithm proceeds next as follows.
first we perform n way comparison of nparallel versions made by parallel changes by incrementally comparing pairs of versions two way comparison is widely supported by advanced text edit tools and version control systems .
the result is the alignment of code fragments in parallel versions in which the common code fragments are aligned and code fragments specific to a branch are shown as differences.
second given the aligned code fragments we transform the original pro gram into a new program with variability in which the shared code fragments remain intact and the differences are surrounded by if else constructs with newly introduced patch variables representing the changes made by developers.
for example on line of figure 1a developer p1changes return ret intoreturn ret count array we model this change with the corresponding ifstatement on lines of figure 1c.
we encode the changes such that they form valid statements.
for a change that cannot be wrapped around with an if statement we use evalwith the change being used as the argument ofeval.
note that for simplicity in our example the patch variables represent the change made by different developers .
however we can also use such variables to guard finer grained changes to detect the conflicts among them.
.
variability aware execution we next use variability aware execution to detect semantic conflicts.
variability aware execution explores all possible concrete runs of the encoded program with regard to all possible values of the patch variables.
that is it efficiently runs all possible versions of the original program corresponding to all combinations of changes taking advantage of the shared code among all versions.
when the condition at an ifstatement is patch variable it runs both branches and maintains the values of variables in the branches separately.
after that it merges alternative values of the same variable into a choice representation containing multiple concrete values depending on a condition.
note that the values of potentially many other variables remain unchanged after the ifstatement is execute which enables variability aware execution to scale.
to illustrate let us describe the run of the assertion on line of figure 1b function call c array is invoked line figure 1b .
in function c it runs the first ifstatement with both values true false of the patch variable p3 lines figure 1c .
next it explores different branches of the second ifstatement.
it starts by executing the then clause i.e.
calling a array under the condition p2 true line figure 1c .
in function a it executes the forloop and then explores both branches of the ifstatement at line .
the returned value is a choice representation of two alternative values choice p1 i.e.
the value is when p1 true the change by developer p1is incorporated and otherwise.
returning to line of figure 1c sum is assigned with the returned value choice p1 under p2 true .
the engine continues to explore the elsebranch the ifstatement at lines and computes the value of sum as under condition p2 false .
after running the ifstatement at lines our engine computes the value of sum aschoice p2 choice p1 which it then simplifies as choice p2 p1 .
therefore the returned value of function cischoice p2 p1 .
line figure 1c .
returning to the assertion on line of figure 1b the assertion compares the returned value choice p2 p1 .
with value .
and our engine reports an assertion error under condition p2 p1 which indicates that the test case would fail if those changes from both p1andp2were incorporated.
the result of the above execution process successfully identifies a set of changes that directly cause a semantic merge conflict.
variability aware execution is similar to dynamic symbolic execution in that they both aim to explore all possible paths in a program.
however variability aware execution takes advantage of the sharing of variables values and does not backtrack after executing both branches of a conditional statement.
it operates on conditional concrete values instead of symbolic values i.e.
a variable may have different values in different conditions but all values are concrete .
details on variability aware execution can be found in our prior work .
limitations .
our encoding algorithm currently works for changes to regular program statements which can be encoded into a valid piece of code within an introduced ifstatement .
we have not addressed the general cases where a change to a field method declaration is made.
in addition our n way merging algorithm uses a greedy approach based on two way comparison.
alternatively we could explore advanced techniques for n way merging .
.
preliminary study table subject programs for evaluation example test cases branches semantic conflicts mathhelper queue1 queue2 product dog1 dog2 chess total we performed a preliminary experimental study on seven example php applications with a total of test cases and semantic conflicts .
they are small programs each with less than lines of code.
we constructed these conflicts based on the categorized scenarios of semantic merge conflicts described by fan and sun .
out of conflicts involve branches the other involve branches.
then we manually created the test cases for those programs.
our results showed that semex was able to correctly detect all conflicts the set of conflicting parallel changes reported by semex are the actual minimum conflicting changes .
.
conclusion in collaborative software development semantic merge conflicts may occur even when the parallel changes contain no textual conflicts.
therefore it is desirable to identify early the actual minimum set of changes that directly cause a semantic merge conflict.
we proposed semex a novel approach to detect semantic conflictsusing variability aware execution.
first we encode all parallel changes into a single program with variability in which special boolean variables represent the presence of the changes.
next we use variability aware execution to run test cases on this merged program.
semex then reports the condition indicating the set of minimum changes that cause a conflict.
our preliminary study showed that our approach can achieve promising results.
.