patdroid permission aware gui testing of android alireza sadeghi department of informatics university of california irvine usa alirezs1 uci.edureyhaneh jabbarvand department of informatics university of california irvine usa jabbarvr uci.edusam malek department of informatics university of california irvine usa malek uci.edu abstract recent introduction of a dynamic permission system in android allowing the users to grant and revoke permissions after the installation of an app has made it harder to properly test apps.
since an app s behavior may change depending on the granted permissions it needs to be tested under a wide range of permission combinations.
at the state of the art in the absence of any automated tool support a developer needs to either manually determine the interaction of tests and app permissions or exhaustively re execute tests for all possible permission combinations thereby increasing the time and resources required to test apps.
this paper presents an automated approach called patdroid for efficiently testing an android app while taking the impact of permissions on its behavior into account.
patdroid performs a hybrid program analysis on both an app under test and its test suite to determine which tests should be executed on what permission combinations.
our experimental results show that patdroid significantly reduces the testing effort yet achieves comparable code coverage and fault detection capability as exhaustively testing an app under all permission combinations.
ccs concepts software and its engineering software testing and debugging security and privacy access control mobile platform security keywords android software testing access control permission acm reference format alireza sadeghi reyhaneh jabbarvand and sam malek.
.
patdroid permission aware gui testing of android.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction access control is one of the key pillars of software security .
many access control models exist for selectively restricting access to a software system s security sensitive resources and capabilities.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
such models permission based access control has gained prominenace in recent years partly due to its wide adoption in several popular platforms including android.
in andriod permissions are granted to apps.
the android runtime environment prevents an app lacking the proper permissions from accessing both sensitive system resources e.g.
sensors as well as other protected applications.
initially android employed a static permission system meaning that the users were prompted to consent to all the permissions requested by an app prior to its installation and the granted permissions could not be revoked afterwards.
to provide the users more control over their device in starting with api level android switched to a dynamic permission system allowing users to change the permissions granted to an app at run time .
the introduction of a dynamic permission system however poses an important challenge for testing android apps.
a test executed on an app may pass under one combination of granted permissions yet fail under a different combination.
as recommended by android s best practices beginning with android .
api level users grant and revoke app permissions at run time instead of so when they install the app.
as a result you ll have to test your app under a wider range of conditions.
.
at the state of the art properly testing an android app with respect to its permission protected behavior entails re execution of each test on all possible combination of permissions requested by an app as there are no tools available to assist the developers with determining the interplay between tests and permissions.
such anexhaustive approach is time consuming and often impractical particularly in the case of regression testing where the execution of an entire test suite needs to be repeated for an exponential number of permission combinations.
to mitigate this challenge we have developed patdroid short forpermission aware gui testing of an droid .
the insight guiding our research is that a given test may not interact with all the permissions requested by an app meaning that some permissions regardless of whether they are granted or revoked may not affect the app s behavior under a particular test.
by excluding the permissions that do not interact with tests we can achieve a significant reduction in testing effort yet achieve a comparable coverage and fault detection capability as exhaustive testing.
patdroid leverages a hybrid program analysis approach to determine the interactions between an app s gui tests and its permissions.
it first dynamically pinpoints the entry points of the app exercised by each test case.
it then statically examines the parts of code that are reachable from the identified entry points to find the permission protected code fragments.
afterwards it statically determines the app inputs i.e.
gui widgets that control the execution of permission protected code fragments.
finally it statically identifies usages of the app inputs in the test scripts.
employing esec fse september paderborn germany alireza sadeghi reyhaneh jabbarvand and sam malek a sufficiently precise yet scalable technique patdroid is able to effectively determine which tests should be executed under what permission combinations for an app.
our experiments indicate that patdroid is able to reduce both number of tests and their execution time by on average while maintaining a similar coverage as exhaustive execution of tests on all permission combinations.
in addition using patdroid we were able to identify several defects in real world apps as confirmed by their developers that can only be exposed under certain permission settings further demonstrating the usefulness of patdroid in practice.
the paper makes the following contributions theory to the best of our knowledge the first approach that considers the dependencies between a program its test suite and access control model for the reduction of testing effort tool a fully automated environment that realizes the approach for android programs and made available publicly experiments empirical evaluation of the approach on a large number of real world android apps demonstrating its efficacy.
the remainder of this paper is organized as follows.
section introduces an illustrative example to motivate the research.
section provides an overview of patdroid while more details are presented in sections .
section provides the implementation information associated with the tool realizes our approach.
section presents the experimental evaluation of the research.
finally the paper outlines the related research and concludes with a discussion of future work.
illustrative example we use a simplified version of an android app called suntimes to motivate the research and illustrate our approach.
suntimes calculates and displays sunrise sunset and twilight times for a particular location.
it is developed to target android version .
sample screen shots of this app are captured in figure .
figure screenshots of suntimes app a initially asking user for the location permission b main activity with available menu options where the first option i.e.
location setting is selected by the user c adding a new location to the app using gps datasince the app requires access to gps data it asks for location permission once launched for the first time figure 1a .
if a user grants the location permission the app periodically calculates and updates sunrise sunset and twilight times based on the current user location.
alternatively the user can update her current location on demand from the option menu figure 1b either by manually providing specific latitude and longitude or using gps to obtain location data figure 1c .
however suntimes crashes when a user who has previously denied the requested location permission tries to update the current location using gps as the app at that point is neither granted the required permission i.e.
location to accomplish this task nor it asks for it again.
to validate its behavior suntimes comes with a gui test suite a subset of which is shown in figure .
in contrast to unit tests these tests run on a hardware device or emulator and commonly referred to as instrumented tests .
regardless of the testing framework e.g.
espresso robotium instrumented tests are compiled and packed as a separate apkfile and installed together with the apk of the main app.
to distinguish these two software artifacts throughout the paper we call the apk containing the test suit and testing libraries as test harness app tha and the apk of the main app as app under test aut .
in the test cases shown in figure testsuntimesnavigation test verifies the smooth navigation between different suntimes and dates testsettinglocationtouserdefined test validates adding a new user defined location based on gps data and testexportlocations test ensures the correctness of exporting retrieved location information to storage.
since android version it is recommended to test an app with various combinations of granted and revoked permissions to ensure correct behavior of the app under different conditions .
for example testsettinglocationtouserdefined can reveal the aforementioned crash only when the developer has revoked the location permission before running the test.
test test public void testsuntimesnavigation onview withid r.id.
info note flipper .
perform click onview withid r.id.
info note flipper .
perform click onview withid r.id.
info time nextbtn .
perform click onview withid r.id.
info time prevbtn .
perform click check the navigation between suntimes is correct ... test test public void testsettinglocationtouserdefined onview withid r.id.
action location add .
perform click onview withid r.id.
appwidget location edit .
perform click onview withid r.id.
appwidget location getfix .
perform click onview withid r.id.
appwidget location name .
perform replacetext my location onview withid r.id.
appwidget location save .
perform click onview withid android .r.id.
button1 .
perform click check the newly added location is shown properly ... test test public void testexportlocations opencontextualactionmodeoverflowmenu onview withid r.id.
action settings .
perform click ondata withkey configlabel places .
perform click ondata withkey configlabel places export .
perform click check the locations are saved correctly ... figure a subset of espresso tests embedded in the tha to verify the behavior of suntimes app.
the test assertions are not shown here 221patdroid permission aware gui testing of android esec fse september paderborn germany as another example consider test of figure which requires location andstorage permissions to save user s location.
depending on the permissions granted to suntimes test can exhibit different behaviors both required permissions are already granted and suntimes is able to successfully save the user s location on the external storage.
only the location permission is already granted.
hence suntimes asks for the storage permission.
in case of denial suntimes saves the location information in the app s internal storage which does not require storage permission.
only the storage permission is already granted.
hence suntimes asks for the location permission.
in case of denial the app takes no action.
neither of the required permissions have been previously granted.
hence suntimes asks for both of them.
in case of denial the app takes no action.
in any case if the user denies any of the requested permissions suntimes should not crash.
the problem of testing an app s behavior under different permission settings becomes more complicated as the number of permissions defined in the app configuration file a.k.a.
manifest increases.
one approach is to randomly grant and revoke permissions and run the test suite.
though simple this approach fails to thoroughly test the app s behavior and is prone to miss important defects.
alternatively a developer could manually review the test scripts and source code of an app to determine which tests should be executed under what app permissions.
such an approach however is quite cumbersome especially considering that every time the app s source code changes the developer needs to manually establish the relationships between the app s tests and its permissions.
another approach is to exhaustively run the test suite under all possible combinations of requested permissions.
in this approach if an application requires ppermissions each test should be executed 2ptimes since each permission takes two values of ranted revoked .1for instance suntimes requests four permissions in its manifest file i.e.
location storage alarm and internet .
considering the three tests in figure exhaustive approach runs each test 16times.
for only the 3test shown in figure we would need a total of 48test runs.
clearly such an approach does not scale as the number of requested permissions and the size of test suite increase.
the insight guiding our research is that exhaustive execution of tests for all permission combinations is overly conservative.
for instance we found that test requires only location permission as the code executed by this test does not require access to capabilities guarded by other permissions.
as a result this test can only be executed twice with and without the location permission rather than the 16times required under the exhaustive scenario.
app under test aut dynamic static static tw app analyzer tha analyzer aut analyzer interaction detector instrument test widget te test entrypoint ewp entrypoint widget permission tp test harness app tha figure overview of the approach approach overview as mentioned in the previous section in all popular android testing frameworks e.g.
a test suite is compiled and packed to produce the test harness app tha which is installed together with the app under test aut .
given a pair of tha and aut patdroid identifies the minimum number of permission combinations foraut that should be tested for each of the test cases embedded intha.
figure depicts an overview of patdroid consisting of four major components.
patdroid first identifies those parts of aut that could be exercised by the test cases embedded in tha.
however this is a challenging task as the test suite and test subject are realized in the form of two separate software artifacts apk files .
moreover tha is composed of instrumented test cases that require more involved analysis compared to for example unit tests.
in contrast to unit tests that have no android framework dependencies and directly invoke aut s methods instrumented tests run on a hardware device or emulator and indirectly trigger a sequence of actions via gui events.2the triggered gui events are handled initially by the testing framework then android run time environment and eventually delegated to certain methods in aut called entry points .
due to such implicit dependency static analysis cannot resolve the parts of the aut executed by tha.
to mitigate the difficulties of resolving the relationships between aut and tha statically patdroid leverages a hybrid static and dynamic approach that traces the dependencies between aut and tha at two levels of granularity.
first at the method level dynamic analysis identifies the entry point methods of aut that are exercised as a result of running the tests embedded in tha represented as the set tein figure .
second at the sub method level static analysis components narrow the entry points discovered by dynamic analysis down to the blocks executable by a particular test case.
the selected blocks of the entry point methods are the targets for further static analysis.
to appreciate the need for restricting the scope of analysis recall suntimes app and the test suite shown in figure .
the second test testsettinglocationtouserdefined triggers an event by selecting the location option from the main menu line which is eventually handled by an entry point method shown in figure .
this method is among the entry point methods identified by dynamic 1in android only the dangerous permissions are configurable at run time while normal permissions are automatically granted at installation time.
without loss of generality we consider all the permissions can be granted revoked at run time.
for the evaluation however we distinguish between dangerous and normal permissions.
2instrumented tests can also trigger other events such as sending intents .
those events however are outside the scope of this research which focuses on gui testing.
222esec fse september paderborn germany alireza sadeghi reyhaneh jabbarvand and sam malek override public boolean onoptionsitemselected menuitem item switch item .
getitemid case r.id.
action alarm schedulealarm return true case r.id.
action settings showsettings return true case r.id.
action location add configlocation return true case r.id.
action location refresh refreshlocation return false case r.id.
action timezone configtimezone return true other options default return super .
onoptionsitemselected item figure an entry point of suntimes app that handles the event corresponding to the selection of menu items shown in figure 1b a subset of options are shown here analyzer for test .
however inspecting onoptionsitemselected method more carefully it is clear that only the third case of the switch statement i.e.
lines in figure is executable by test since other cases are intended to handle the other options never triggered by this test.
including the entire method instead of focusing on lines in the search for relevant permissions would increase the false positive rate of our analysis.
the above example demonstrates that the execution flow of the gui event handlers is controlled by the widgets triggering those events.
hence a precise analysis should also take the gui widgets affecting the control flow of the app into account otherwise it would over approximate the code segments that could be exercised by each test.
to that end tha analyzer determines the widgets used in each test case represented as the set twin figure while aut analyzer determines the permissions needed for executing each block of code in aut if any along with the widgets affecting the reachability of those blocks represented as the set ewp in figure .
finally interaction detector integrates the outputs of the static and dynamic components and generates the relevant permissions for each test case represented as the map tpin figure .
the following sections describe the four components of patdroid in more details.
dynamic analysis unlike the conventional java program with a single main method android apps comprise several methods that are implicitly called by the framework usually referred to as entry points .
entry points are responsible for handling various events including gui events e.g.
onoptionsitemselected shown in figure that handles the selection of a menu option as well as changing the status of the application a.k.a.
life cycle events e.g.
onresume to activate a paused app .
as a result of running a test an app s entry points are invoked by the android framework.
these are identified by the dynamic appanalyzer component.
for this purpose patdroid first automatically instruments the given aut and injects loggers at the beginning of every possible entry point of the app which are distinguishable by the virtue of implementing specific interfaces of the android framework e.g.
onoptionsitemselected onresume etc.
.
for a comprehensive list of android s entry point interfaces we have relied on the results of prior research .
patdroid subsequently runs the entire test suite on the instrumented app with an arbitrary permission setting.
since the invocation of entry points are independent of the permission settings our approach effectively finds the tha dependent entry points in the aut.
unlike the test script the code covered inside the entry points depends on the permission settings during the test execution.
thus we use static analysis technique described in section to further explore the logic inside the entry point methods.
finally the log obtained through the instrumentation of app s entry points is processed to capture the executed entry points for each test case.
the generated output of this phase called te is a set of tuples test entrypoint where the first element is the test identifier and the second element is an exposed entry point during the test execution.
figure provides a subset of generated output for test of figure .
static analysis of test harness app as briefly discussed in section patdroid traces the dependencies between aut and tha at two levels of granularity.
at a high level of granularity the dependencies at the method level are identified by dynamic analysis as described in the previous section.
at a low level of granularity within the entry point methods the dependencies are refined through static analysis.
to statically trace the dependencies between aut and tha patdroid resolves the app inputs namely gui widgets that are the target of actions performed by test scripts.
in the running example action location add is a widget identifier used in both tha and aut artifacts lines and in figures and respectively .
for this purpose patdroid s static analysis component extracts the widget information from both aut and tha.
the extracted information should uniquely identify the widget throughout the entire app s implementation and thus usually includes a widget identifier or a key.
while this section focuses on extracting widgets from tha section .
describes how our approach applies to aut.
each android testing framework e.g.
espresso robotium etc.
encodes the widget interactions in its own unique way based on the framework s apis and patterns.
to generalize the problem of finding the used widgets and make test testsettinglocationtouserdefined entrypoint sunactivity boolean onoptionsitemselected menu test testsettinglocationtouserdefined entrypoint locationconfigdialog void onclick view test testsettinglocationtouserdefined entrypoint locationconfigdialog void onresume figure a subset of suntimes app s entry points exercised by test of figure 223patdroid permission aware gui testing of android esec fse september paderborn germany our approach test framework agnostic we define this problem as a general data flow analysis .
accordingly our goal is to find the flow of data within the test programs from certain source s tosinks.
for this purpose data sources are defined as the set of testing framework apis for retrieving a widget by a specific property e.g.
finding widgets based on id using viewmatcher.withid int and solo.findviewbyid string apis in espresso and robotium frameworks respectively.
similarly data sinks are defined as the set of testing framework apis for performing an action on the widgets e.g.
a click action defined by viewactions.click and solo.clickonbutton apis.
defining the problem in this way allows us to perform the static analysis independent of the testing framework.
to support a new testing framework it is only needed to provide the list of framework s apis for retrieving and performing actions on widgets.
a slightly faster yet less precise approach to find the widgets is to only look for widget retrieval apis i.e.
source set only and simply return the extracted information.
this approach however can increase the false positive rate since some widgets might be retrieved for purposes other than performing an action e.g.
making an assertion .
for this reason we opted for a precise analysis.
to solve the data flow problem we employed an androidcompatible data flow analysis framework flowdroid but with a significant modification that allows us to perform the analysis on a tha.
by default flowdroid is intended to analyze apps that comply with the conventional structure expected by the android framework e.g.
to be composed of android components.
in contrast to aut tha does not follow such conventional structure and thus is not supported by flowdroid.
therefore we replaced flowdroid s default entry point creator with a customized creator specifically tailored for tha analysis.
for each tha patdroid creates a dummy main method which is responsible for preparing the test environment encoded in before methods and then invoking the test methods embedded in tha.
recall the use of such annotations in the test script example shown in figure .
solving the data flow problem tha analyzer generates the output tw which is a set of tuples test wid et where the first element is the test identifier and the second element is a widget that is the target of an action performed by the test.
figure provides a subset of the analysis output generated for test of figure .
static analysis of app under test running under an arbitrary permission settings dynamic app analyzer partially explores the aut code executable by each test.
subsequently patdroid leverages aut analyzer to statically examine all parts of the code that could be exercised by each test.
test testsettinglocationtouserdefined widget action location add test testsettinglocationtouserdefined widget appwidget location getfix figure a subset of widgets extracted from test of figure 2algorithm aut analysis input aut app under test te tests to entry points set output ewp entrypoint widget perm 1ewp permission analysis see section .
2permsummaries permissionanalysis aut t e widget analysis see section .
3widgetsummaries widgetanalysis aut 4foreach entrypoint t edo foreach stmt entrypoint .statements do ifstmt .type ismethod invocation then perms permsummaries foreach perm perms do widgets widgetsummaries ifwidget then ewp ewp entrypoint perm else foreach widget widgets do if entrypoint widget perm ew p then ewp ewp entrypoint widget perm end end end 19end as depicted in figure the aut analyzer receives the aut and teas input and generates ewp as output.
the generated output is a set of tuples each containing three elements entrypoint wid et permission indicating an entry point method invoked during the execution of a test a widget that can affect the reachability of permission protected code within that entry point and the corresponding permission.
aut analyzer s main procedure is summarized in algorithm .
the analysis procedure performs several steps to generate the output.
initially permissionanalysis sub procedure line identifies the required permissions for executing each statement if any for all of the app s entry point methods exercised by the test suite.
the details of this sub procedure are described in section .
.
subsequently widgetanalysis procedure is invoked in line to determine the statements that are controlled by each widget the details of which are described in section .
.
for each entry point method line and each statement within it line the algorithm determines whether it is a method invocation statement line that is permission protected lines .
these could be either android api calls or user defined methods.
for each permission protected method invocation statement all the widgets that control the execution of this statement are retrieved line .
finally the algorithm adds tuples consisting of method widget and permission information to set ewp unless they already exist in this set lines .
if a permission protected statement is not controlled by any widget the widget element is set to null in the corresponding generated tuple lines .
.
permission analysis for each method defined in a given aut permission analysis procedure captures all permissions required for executing that method 224esec fse september paderborn germany alireza sadeghi reyhaneh jabbarvand and sam malek suntimesactivity.
onoptionsitemselected ... getfixhelper.
getfix locationconfigdialog.
oncreatedialog suntimesactivity.
configlocation ... getfixtask.
location gpslastlocation locationmanager .getlastknownlocation gps provider location permission legend execute show call graph node method w perm summary control flow graph node statement explicit call implicit call caller class.
method ... ... ... loc add alarm settings default ... location location location location perm getfixui.
showprogress ... figure a sub graph of inter procedural control flow graph for suntimes app.
the collapsed parts of the sub graph are denoted by ... .
the method call in node line of the control flow graph for suntimesactivity.onoptionsitemselected method eventually leads to calling an android framework api that requires location permission i.e.
getlastknownlocation .
since this permission is used under the branch with widget id location add it is inferred that location is a relevant permission for a gui test that exercises this entry point method onoptionsitemselected by performing an action on location add widget called permission summaries ps through performing an interprocedural fixed point analysis summarized in algorithm .
in the first step permission analysis constructs a call graph cg of the entire application line .
however due to the event driven structure of the android platform the traditional cg generation methods do not connect the call sites corresponding to implicit invocations.
the challenges of generating call graph for android apps are widely discussed in the prior research and several techniques are suggested for this purpose which are employed by patdroid .
figure depicts a subset of the call graph for the suntimes app.
in this graph the implicit calls are denoted by dashed lines.
for instance the method getfixhelper.getfix starts an asynctask namely getfixtask by invoking the execute interface.
consequently the method of the task class is invoked indirectly by the android framework.
permission analysis iterates over all android framework apis that are called throughout the given app lines and adds the required permission for the api to the permission summaries ps of the methods where that api is called.3we have relied on permissionapi mappings produced in the prior work to determine the required permission for android apis.
finally permission analysis traverses the constructed call graph cg using breadth first search bfs method lines .
starting from the given entry point methods ee it propagates the permission in the graph.
in each iteration the algorithm updates the permission summaries ps of all methods calling the current method by augmenting their ps with the ps of the callee method line .
this procedure is repeated until a fixed point is reached for the permission summaries line meaning that psdoes not change in further iterations.
in figure the permission summaries are shown at the top left corner of each call graph node.
3in addition to the android framework apis certain intents and queris on content providers need specific permissions.
for brevity however only the iteration over the apis is shown in algorithm .algorithm permission analysis input aut app under test te tests to entry points set output ps permission summaries 1ps psis a map with method signature as its key and the corresponding set of required permissions as its value 2cg constructcg aut 3foreach api aut .androidapicalls do method caller api perm perm api ps perm 7end 8repeat foreach method bfs.next cg te do callermethods g.edgesto method foreach callermethod callermethods do perms ps ps ps perms end end 16until psreaches a fixed point .
widget analysis recall the entry point method presented in figure .
to handle a selected menu option this method onoptionsitemselected invokes several other methods each one under a case corresponding to the menu option.
for instance set alarm third option in figure 1b is handled by the first case statement shown in figure where schedulealarm method is called consequently line .
therefore if a gui test only clicks on set alarm option it does not execute the methods called in other cases and thereby the summarized permissions for other methods e.g.
showsetting configlocation etc.
are irrelevant to this test.
to exclude the irrelevant permissions we need to determine which widgets affect the control flow of which program statements particularly the statements that invoke 225patdroid permission aware gui testing of android esec fse september paderborn germany methods with non empty permission summaries.
widget analysis procedure summarized in algorithm provides this capability.
for a given method widget analysis procedure performs a branch sensitive partial inter procedural data flow analysis and generates the widget summaries ws as the output.
for this purpose a trimmed version of inter procedural control flow graph icfg is constructed first line .
an icfg is a collection of controlflow graphs connected to each other at all call sites.
our analysis however targets app widgets exclusively and thus only the call sites that pass a widget object are included in the trimmed icfg denoted as icfgt.
performing the analysis over icfgt instead of icfg significantly improves the scalability of our approach yet keeps the precision acceptable.
afterwards the genset is populated through iterating over every statement of each method lines .
we are only interested in the conditional statements that affect the control flow of the program namely if lines and switch lines statements with the widget as the condition.
for instance the switch statement in figure could be a target of our analysis as it is a conditional statement controlling the flow of the program and a widget i.e.
menuitem is used as the statement s condition.
finally the algorithm traverses the icfgtin a breadth first search manner and propagates the widget information through the graph.
by this at each statement we have the information of all widgets that can affect the control flow of the program from the beginning to that statement.
for example as highlighted in the control flow graph of onoptionsitemselected method depicted in figure with location add as the selected menu option the algorithm widget analysis input aut app under test output ws widget summaries 1ws 2gen in out ws gen in and out are maps with program statement as its key and set of related widgets as its value.
3icfgt constructtrimmedicfg aut 4foreach stmt aut .methods .statements do ifstmt .type isif stmt .condition .type iswidget then gen stmt .condition else if stmt .type isswitch stmt .condition .type iswidget then foreach case stmt .cases do gen case .condition end 11end 12repeat foreach stmt bfs.next icfgt do foreach stmt pred stmt do in in out end foreach stmt succ stmt do out in gen end end ws out 22until wsreaches a fixed point entrypoint suntimesactivity boolean onoptionsitemselected menuitem widget action location add permission location figure a subset of ewp generated for suntimes app control flow of the program will reach to lines and .
hence location add is added to the widget summaries of the statements at nodes and .
the widget analysis terminates upon reaching a fixed point for the widget summaries ws .
it is essential to note the difference between the precision and scope of two sub procedures described in sections .
and .
namely permission analysis andwidget analysis .
due to flow and branch sensitivity widget analysis is more costly than permission analysis.
on the other hand while permission analysis is performed on every method in the app through traversing its call graph the scope of widget analysis is limited to a few entry point methods exercised by running the tests.
this distinction lets patdroid keep the app analysis precise and yet scalable.
combining the outputs of permission analysis andwidget analysissub procedures the main procedure algorithm generates the final output of aut analyzer component i.e.
ewp .
a subset of generated ewp for suntimes app is provided in figure .
building permission combinations as shown in figure interaction detector generates the final output tp which is a map from tests to the set of relevant permissions.
it does so by correlating the outputs of the other components namely te tw and ewp as follows.
interaction detector procedure summarized in algorithm iterates over the three input sets te tw ewp and matches the tuple algorithm interaction detector input te test entrypoint tw test widget ewp entrypoint widget permission tha test harness app output tp a map with tests as the key and the set of relevant permissions as the value.
1t p 2testwithperm 3foreach ewp ew p do foreach tw tw do ifewp .widget orewp .widget tw .widget then foreach te t edo ifewp .entrypoint te.entrypoint then ifte.test tw .testthen t p t p ewp .perm testwithperm testwithperm te.test end end 13end 14foreach test tha .testsdo iftest testwithperm then t p 17end 226esec fse september paderborn germany alireza sadeghi reyhaneh jabbarvand and sam malek testsuntimesnavigation testsettinglocationtouserdefined location testexportlocations location storage figure relevant permissions for a subset of the tests listed in figure members of these sets based on the shared elements i.e.
entrypoint test and widget .4the only exception occurs when no widget is found for an ewp i.e.
no widget is used to control access to permission protected code in an entry point in which case it is conservatively assumed that the entire entry point method could be executed by a single test and hence the algorithm does not attempt to match ew p .wid etandtw .wid et line .
based on the matched tuples relevant permissions for a test are added to the output tp line .
finally an empty set is assigned to those tests that have no relevant permissions lines .
the generated output tp for the test set of suntimes app is provided in figure .
the output of this algorithm enables efficient permission aware testing of the given app.
in total for an app consisting of ttests and ppermissions the number of test runs by patdroid are calculated as follows tx t t p .perms where tp .perms denotes the relevant permissions for test tidentified by patdroid .
as our experiments will show this number turns out to be significantly smaller than t p tests required for execution under the exhaustive approach.
implementation patdroid is realized with over lines of java code and lines of python script.
it also relies on a few third party libraries most notably soot for static analysis of android apps ic3 to resolve icc communications and xposed for run time instrumentation of the root android process.
patdroid runs in two modes developers mode and testers mode.
the first mode is applicable when the source code of subject apps aut and their gui tests tha are available.
the second mode can be used when only apk files aut are available.
patdroid currently supports the major android s gui test frameworks namely espresso robotium and monkey.
the artifacts associated with patdroid including the executable tool and its user manual are available for download from patdroid s web page accessible via this link evaluation our evaluation of patdroid addresses the following questions rq1.
efficiency how does patdroid compare against alternative approaches with respect to test run size and testexecution time?
4matching elements are distinguished by the same colors in figures and .rq2.
coverage how does patdroid compare against alternative approaches with respect to code coverage?
rq3.
effectiveness ispatdroid able to reveal defects in realworld apps particularly those that are only exposed under certain permission settings?
rq4.
performance how does patdroid scale in relation to the size of app?
.
experiment setup to evaluate our approach on realistic subjects we crawled google play and github repositories and searched for android apps with the following criteria i should target android api level otherwise the app does not support run time permission modification and thereby does not suffer from the problems that are the focus of our work.
ii should define at least two dangerous permissions in the manifest file because other types of permissions are not adjustable at run time and solving the problem with less than two adjustable permissions is trivial.
in accordance with the above criteria we collected apps popular apps from google play and open source apps from github listed in table since investigating rq2 i.e.
measuring code coverage requires the availability of source code.
for the open source apps we manually created or extended the existing gui tests using espresso or robotium frameworks to achieve at least appriximately statement coverage.
for google play apps we used monkey to generate black box gui tests.
we have compared patdroid against three alternative strategies as follows exhaustive exhaustively includes all permission combinations.
pairwise generated according to pairwise technique that is for any two permissions all possible pairs of permission settings i.e.
granted revoked should be in the output set.
all and none includes two combinations one with all permissions granted the other with all permissions revoked.
as we will discuss in section none of the existing test suite reduction tools support android framework nor consider its access control model therefore are not included in our evaluation.
table a subset those with available source code of subject apps.
appsize of permissions test suite kloc all dangerous size a2dp volume .
alwayson .
budget watch .
dumbphone assistant .
notes .
radiobeacon .
riot .
sms scheduler .
suntimes .
syslog .
227patdroid permission aware gui testing of android esec fse september paderborn germany table test size and time reduction achieved by patdroid compared to other approaches.
indicate that the reduction achieved by the the alternative approach is greater or less than patdroid respectively.
apptest run size of difference compared to patdroid testing time in sec.
of difference compared to patdroid patdroid exhaustive pairwise all nonepatdroid exhaustive pairwise all none p t t t p .perms t p t a2dp volume .
.
.
.
.
.
always on .
.
.
.
.
.
budget watch .
.
.
.
.
.
dumbphone assist .
.
.
.
notes .
.
.
.
.
.
radiobeacon .
.
.
.
.
.
riot .
.
.
.
.
.
sms scheduler .
.
.
.
.
.
suntimes .
.
.
.
.
.
syslog .
.
.
.
.
.
in the presented formulas used for calculating the size of the test runs tis the set of tests pis the set of app s permission and t p .perms is the set of relevant permissions for the test tgenerated by patdroid .
table test coverage achieved by patdroid compared to other approaches.
indicate that the coverage of the alternative approach is greater or less than patdroid respectively.
appstatement coverage of difference compared to patdroid branch coverage of difference compared to patdroid patdroid exhaustive pairwise all none patdroid exhaustive pairwise all none a2dp volume .
.
.
.
.
.
.
.
always on .
.
.
.
.
.
.
.
budget watch .
.
.
.
.
.
.
.
dumbphone assist .
.
.
.
.
.
.
.
notes .
.
.
.
.
.
.
.
radiobeacon .
.
.
.
.
.
.
.
riot .
.
.
.
.
.
.
.
sms scheduler .
.
.
.
.
.
.
.
suntimes .
.
.
.
.
.
.
.
syslog .
.
.
.
.
.
.
.
.
efficiency to answer rq1 we compare the test run size and test execution time of patdroid with exhaustive pairwise andall and none as shown in table .
test run size indicates the cumulative number of tests required to run for each technique.
this number is calculated by the formulas shown in table under the corresponding columns.
in addition the table shows the percentage of decrease or increase for each reported metric in comparison to patdroid .
the results in table confirm that patdroid can significantly reduce the number of test runs and test execution time.
on average patdroid requires .
and .
fewer test executions than exhaustive andpairwise respectively.
similarly on average patdroid takes .
and .
less execution time than exhaustive andpairwise respectively.
in comparison to all and none however the results are mixed where in some cases patdroid achieves a higher reduction e.g.
budget watch while in other cases patdroid achieves a lower reduction e.g.
radiobeacon .
although all and none achieves a higher reduction in some cases the next section shows that it does not maintain the same coverage as other approaches.
figure plots the test execution time for all of the subject apps.
as illustrated in the figure test execution time grows exponentially with respect to the number of permissions in exhaustive approach.
therefore the reduction rates compared to exhaustive approach are higher in apps with more permissions.
for example the reduction in the case of a2dp vol app with permissions is above while the reduction in the case of budget watch app with permissions is close to .
.
coverage to answer rq2 we compare the statement and branch coverage achieved by patdroid against that of achieved by the alternative techniques.
as shown in table patdroid achieves the same exact e p figure test execution time based on the number of permissions.
eand prepresent the reduction in test execution time achieved by patdroid compared to exhaustive and pairwise approaches respectively 228esec fse september paderborn germany alireza sadeghi reyhaneh jabbarvand and sam malek coverage as exhaustive in all subject apps.
the fact that patdroid achieves the same coverage as exhaustive is particularly important as it shows that patdroid does not produce many false negatives i.e.
failing to execute a test with a relevant permission combination for an app.
moreover on average patdroid achieves and higher coverage than pairwise andall and none techniques respectively.
it is worth noting that while in apps pairwise achieves the same coverage as patdroid in apps it achieves significantly lower coverage.
a closer look at the apps where patdroid outperformed pairwise showed that these situations occur when certain capabilities provided by an app depend on more than two permissions.
for instance alwayson app asks for four permissions and if any of those permissions are not granted the app s functionally is significantly downgraded.
since the pairwise technique does not include a combination with all four permissions granted it achieves lower statement coverage and lower branch coverage than patdroid .
in summary the results of rq1 and rq2 confirm that patdroid is able to significantly reduce the number of tests without tradingoff code coverage.
.
effectiveness to answer rq3 we investigate the power of our approach in identifying permission related defects in real world apps.
to that end we carefully analyzed android log and the output of the tests executed under the permission combinations generated by patdroid .
particularly we were interested in crashes or unexpected behaviors that could only be verified by running the tests under certain permission combinations.
running patdroid on the set of apps we found apps i.e.
with defects that are due to inappropriate handling of dynamic permissions.
we reported the identified defects for the open source apps to their developers through github issue tracker along with information to reproduce the faults and suggestions for fixing the defects.
table provides a summary of the reported defects and the current status of each issue for the apps that provide a public issue tracker.
as of the date of this paper submission most of the defects are verified and fixed by the app developers.
note that exhaustive and pairwise approaches are also able to identify the reported defects except they take significantly longer time to execute as shown in section .
.
all and none on the other hand is not able to reveal these issues.
for instance in open note scanner app which asks required permissions initially revoking thestorage permission while granting camera permission would make the application crash.
such behavior is not reproducible using all and none technique.
furthermore exhaustive approach was not able to find a defect that patdroid missed further demonstrating the efficacy of patdroid in revealing permission related defects.
.
performance to answer rq4 we measured the performance of running patdroid over the subject apps.
the experiments are run on a pc with 5in our experiments patdroid did not produce any false negatives but in principle it could due to limitations of static analysis upon which patdroid relies.table a subset those with public issue tracker of defects in realworld android apps identified for the first time by patdroid .
app reported issue link defect type status open food crash fixed budget watch unexpected behavior fixed a2dp volume unexpected behavior fixed radiobeacon crash verified riot unexpected behavior fixed opennotescanner crash reported an intel core i7 .
ghz cpu processor and gb of main memory.
according to the experimental results the average time spent on identifying the relevant permissions is seconds which is negligible compared to the time saved due to reducing the test run size see section .
.
figure shows the performance measurements of running patdroid .
the analysis times for each phase of patdroid i.e.
static and dynamic analyses are plotted separately in the figure.
on average static and dynamic analyses take and seconds respectively.
according to the figure the static analysis time increases as the app size increases while there is no correlation between the dynamic analysis time and the app size.
dynamic analysis time depends on the logic and workload of the subject app.
for instance the size of the data that an app downloads from the internet can affect the execution time of the app s system tests.
related work test reduction has been the goal of research efforts in several domains.
in this section we provide a discussion of such efforts in light of our research.
combinatorial interaction testing cit .
combinatorial interaction testing proposes a set of techniques to reduce the test space of a software system while maintaining the effectiveness of the whole test space .
cit approaches can be categorized as greedy heuristic based genetic and search based algorithms .
another thrust of research in cit includes identifying and removing constraints from configuration.
while the main body of research has focused on the hard constraints those making the configuration infeasible or not permitted the problem of soft constraints valid yet undesirable or irrelevant configuration is unexplored by the prior research.
to the best of our knowledge figure performance measurements of patdroid 229patdroid permission aware gui testing of android esec fse september paderborn germany patdroid is the first attempt at reducing the test space by addressing soft constraints in the context of access control i.e.
excluding app permissions that are irrelevant to the test cases.
testing software product lines spl .
systematic testing of programs constituting software product lines spl is expensive as it requires examining combinations of the features for testing.
therefore several prior works have attempted to reduce the test space of spl.
for instance splat and its predecessor leverage dynamic and static program analysis techniques to identify and exclude irrelevant features from each test case.
despite having similar objectives the proposed techniques for spl test reduction are not applicable to permission aware gui testing of android apps for several reasons.
in contrast to the spl features that are explicitly specified in the code app permissions are not embedded in the app code.
moreover the target of spl test reduction techniques is unit tests.
while unit tests are traceable from the program there is no explicit dependency between the source code and the gui test suite in the case of android programs as discussed in section .
regression test selection rts .
a large body of prior research has focused on speeding up the regression testing in continuous integration processes .
in contrast to these rts techniques that track dependency at the file class or method level patdroid captures the dependency at the control flow level.
applying a precise yet scalable analysis patdroid is able to significantly reduce the testing time.
despite the similarity of the techniques applied for tracking the dependencies between tests and system under test the goal of our approach is rather different from rts.
while rts techniques aim to identify the tests relevant to the changes introduced in the codebase due to software revisions the goal of patdroid is to find the relevant permissions for gui testing.
none of the aforementioned three categories of related research are applicable to android.
we next briefly provide an overview of the related work in android gui testing.
android gui testing.
android gui testing has received substantial attention in recent years .
proposed approaches employ a variety of techniques including random hueristicbased model based and search based approaches.
nonetheless only a few research approaches have applied combinatorial test reduction techniques to android testing domain.
most notably trimdroid extracts dependencies among the widgets to reduce the number of combinations in guitesting.
trimdroid however differs from our approach in several ways.
first trimdroid performs static analysis over the app code to generate new test cases while patdroid employs hybrid analysis on both app under test and test harness app to determine a subset of permission combinations for running the existing tests.
second trimdroid captures dependencies among the widgets while patdroid tracks dependencies among app widgets and permissions.
to the best of our knowledge access control models particularly permissions are not considered in any of the prior research for test generation or reduction.
conclusion and future work recent introduction of a dynamic permission system in android has made it necessary to test the behavior of android apps under a variety of permission settings.
without an automated solution to reason about which tests should be executed under what permission combinations the developers have to either manually make such determinations or exhaustively re run each test under an exponential number of permission combinations.
both approaches are impractical time consuming and cumbersome.
to overcome this problem and help developers efficiently test android apps under various permission settings we presented patdroid .
through a hybrid program analysis of android app and its test suite patdroid is able to identify relevant permissions for each test case.
by excluding the irrelevant permissions patdroid is able to significantly reduce the number of test runs and execution time of tests without trading off coverage and fault detection ability of tests.
our experimental results show that patdroid can achieve reduction in execution time of tests compared to the exhaustive approach without any degradation in code coverage.
moreover using patdroid we were able to identify several previously unknown permission related defects in real world apps.
our current implementation of patdroid has two limitations that will be the subject of our future work.
first it is assumed that guiwidgets are retrieved by a single unique identifier such as id or key.
though this assumption is true in the vast majority of cases widgets are occasionally retrieved by a combination of multiple properties such as position and parent s id.
second it is assumed that the gui dependent flow of the program is controlled directly using the widgets.
meaning that if the execution of a program block depends on a specific gui event developers specify a conditional guard on the widget triggering that event.
however another less common yet plausible scenario is that a developer indirectly uses the widget.
for example by saving a reference to the widget in a global variable and using this reference to control the flow of program.
addressing the aforementioned limitations is possible through the construction of more advanced static analyses.
however the additional precision is likely to reduce the scalability and performance of our approach for little gain in the overall efficacy.
studying such tradeoffs will be a focus of our future research.
we plan to extend our approach to include other configurable parameters in android that can affect the behavior of programs such as the settings for network and battery usage.
generalizing patdroid beyond permissions would require replacing the permissionto api mapping algorithm with an input that maps apis to other android configurations such as network setting.
finally since the theoretical contribution of patdroid is applicable to any software with a permission based access control model we intend to investigate the applicability of our approach to other platforms that use permission based security model.
acknowledgement this work was supported in part by awards ccf cns1629771 and ccf from the national science foundation hshqdc c b0040 from the department of homeland security and fa95501610030 from the air force office of scientific research.
230esec fse september paderborn germany alireza sadeghi reyhaneh jabbarvand and sam malek