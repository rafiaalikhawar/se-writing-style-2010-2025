battery aware transformations in mobile applications j rgen cito university of zurich zurich switzerland cito ifi.uzh.chjulia rubin mit cambridge ma usa mjulia mit.eduphillip stanley marbell mit cambridge ma usa psm mit.edumartin rinard mit cambridge ma usa rinard mit.edu abstract we present an adaptive binary transformation system for reducing the energy impact of advertisements and analytics in mobile applications.
our approach accommodates both the needs of mobile app developers to obtain income from advertisements and the desire of mobile device users for longer battery life.
our technique automatically identi es recurrent advertisement and analytics requests and throttles these requests based on a mobile device s battery status.
of the android applications we analyzed have at least one connection that exhibits such recurrent requests.
our automated detection scheme classi es these requests with precision and .
recall.
applying the proposed batteryaware transformations to a representative mobile application reduces the power consumption of the mobile device by .
without the negative e ect of completely removing advertisements.
ccs concepts software and its engineering !software performance general and reference !metrics keywords energy e ciency battery lifetime mobile advertisements program analysis.
.
introduction mobile devices have limited battery capacity which restricts their utility for users.
prior research has identi ed mobile advertisement and analytics a a services as a signi cant contributor to battery drain .
removing a a services completely can reduce the energy usage of a mobile device by up to .
however a a services are an important part of the app ecosystem they are a popular way for mobile app developers to earn revenue advertisements and to gain insight into user behavior analytics .
thus existing approaches whichremove ads altogether are insu cient.
to balance the desire of developers to include numerous a a requests in their apps with the desire of the users to maximize the battery lifetimes of their devices we propose an approach that dynamically adapts the rate of a a requests according to the state of a mobile device s battery.
battery aware transformations.
we present an approach to balance the interests of mobile app developers with the interests of mobile device users.
the main idea behind our approach is to automatically identify recurrent a a requests in existing applications detect their frequency and modify application binaries so that applications can adapt the a a frequency to the current battery state.
our initial results show that at least of the a a requests in android applications are recurrent.
these recurrent requests can be detected in an automated manner the detection scheme proposed in this work classi es the recurrent requests with precision and .
recall.
our preliminary experiments applying the battery aware transformation to a representative android application from the google play store reduce the average whole system power dissipation on a nexus mobile phone by .
without the e ect of removing ads completely which is undesirable for developers.
looking forward there are several possible models of applying the proposed approach.
one option is to decrease the rate of recurrent requests in a linear manner as the battery discharges.
another option is to activate the rate reduction when the phone enters a low power mode in most modern mobile operating systems such as android and ios lowpower modes are activated when the battery status reaches a prescribed level say .
these modes are designed to reduce energy consumption in exchange for reduced functionality .
for example on ios the low power mode user interface states that when active mail fetch background app refresh automatic downloads and some visual e ects are reduced or disabled.
.
our approach is thus aligned with the vision and intentions of mobile operating system designers.
contributions.
this paper introduces a technique for improving energy consumption in apps that use a a services.
the proposed techniques balance the interests of both the mobile app developer ads and analytics and the mobile device user longer battery life .
our initial implementation and results make four contributions to the state of the art .empirical evidence for recurrent requests in android apps our analysis shows that of the apps we studied have at least one recurrent request.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
.an algorithm for detecting recurrent requests in android apps through dynamic analysis our algorithm determines the period of recurrent requests and achieves precision and .
recall.
.a battery aware transformation for dynamically transforming android binaries to throttle recurrent requests based on the current battery status.
.initial evaluation for savings achieved by the batteryaware transformation our experiments show that applying the proposed transformation on a single application can reduce the power consumption of a device by .
.
these contributions demonstrate the feasibility and usefulness of this novel type of approach unlike earlier work it is designed to strike the balance between the needs of mobile application users and the nancial incentives of mobile application developers.
structure of the paper.
the rest of the paper is organized as follows.
section presents an empirical study to determine the prevalence of recurrent a a requests in android apps.
section elaborates our proposed approach divided into pro ling frequency analysis and battery aware transformation.
in section we apply our approach to a use case application and report on the energy savings.
section positions this paper within the related work.
section describes the limitations of our work with an outlook to the future.
we conclude with a summary in section .
.
frequency of requests we rst conduct an empirical study to investigate the frequency of recurrent a a requests in android applications.
.
study design as the subjects of our study we downloaded the mostpopular applications available on the google play store as of february .
we instrumented application binaries to log information about a a connection statements that these applications make.
we used the dex2jar1toolsuite to extract the jar le from the apps apks and soot as implemented in flowdroid to create instrumented versions of the original applications.
our study considered as a connection any statement listed in table .
table connection statements.
class interface method java.net.url openconnection java.net.urlconnection connect org.apache.http.client.httpclient execute org.jsoup.helper.httpconnection connect java.net.httpurlconnection getoutputstream java.net.socket getoutputstream we also included all sub classes of those listed in the table.
we further analyzed package names of each class that issues a connection statement to identify those that belong to the known a a libraries.
for each of the identi ed a a connection statements we inserted a corresponding print statement whose output is by the android system logging facilities.
we logged the outgoing request s type and time of occurrence.
we then transformed the jar le back into an apkusing the dex2jar toolsuite and signed this apkusing the standard jarsigner tool from the java jdk.
we installed the instrumented applications on a nexus mobile device running android .
.
excluding applications where the soot based binary transformations failed.
we believe that these failures occur because the apps in question might use language constructs that are not supported by the current version of soot.
we also excluded applications that required user speci c input such as login credentials and chat partners.
the remaining eight applications are listed in the rst column of table .
we ran each application for minutes while connected to wifi with the device stationary.
we did not interact with the applications.
at the end of the run we obtained a le which logs all connection issued by the application.
we refer to that le as a connection log .
.
study results we manually analyzed the produced connection logs for each application to classify requests as recurrent or nonrecurrent.
the results of this analysis are summarized in columns and of table .
our study shows that of the analyzed applications have at least one recurrent a a connection that is activated without the user interacting with the application.
we also observed that one application has six such connections.
on average applications have .
a a connections out of which .
are recurrently activated without any user interaction.
additionally we manually extracted the intervals between recurrent requests by carefully inspecting the connection log for each request.
on average recurrent requests occur every .
seconds column in table .
summary our empirical study shows that of applications have at least one recurrent request that is activated without any user interaction with an application.
on average applications have .
such requests which occur every .
seconds.
.
proposed approach inspired by the study described in section we propose an automated approach for modifying application binaries to adjust the frequency of recurrent a a request according to the battery state.
our approach consists of three main steps shown in figure pro ling frequency analysis and battery aware transformation.
these steps are described in sections .
.
and .
.
before that we give a more formal de nition of recurrent requests.
.
recurrent requests we denote outgoing connection statements in an app s bytecode with c1 c n. table lists the types of connection statement we consider.
whenever one of the connection statements cause a request at runtime the identity of the connection statement along with a timestamp tis recorded.
we assume that there is an observation at every possible timestamp t2n.
as such there is a binary sequence 703table recurrent a a requests in android applications.
manual analysis automated analysis apk name size aa rec.
precision recall com.amazon.mshop.android.shopping 27m com.vlcforandroid.vlcdirectprofree .8m com.socialping.lifequotes .9m com.surpax.led ashlight.panel .8m net.zedge.android .4m com.lionmobi.powerclean .4m com.cynomusic.mp3downloader .2m com.vysionapps.faceswap .5m average .6m .
.
.
.
xci f t x t t2ngfor every connection statement ci.
for a given connection statement ci x t if the connection issued a request at some point in time t andx t if the connection statement issued no request at time t. de nition .
recurrent request a time series xci fx t gfor a connection statement ciis said to be recurrent if there exists some 2nsuch thatx t x t for allt ofxci.
is called the period of xci.
we de ne a subset t ci ft x t 1gas the collection of timestamps of positive events i.e.
when connections have issued requests in xci.
given two consecutive timestamps ti andti 1in the sett ci we consider a series to be recurrent with a period with respect to a threshold if j ti ti j .
profiling for the pro ling step we follow the procedure described in detail in section .
.
the input for this step is an apk le.
we instrument the bytecode and annotate all connection statements listed in table including its sub classes .
we exercise the application for minutes without any interaction.
the output is a connection log that speci es type and time stamps of the a a connection statements made by the application.
.
frequency analysis for frequency analysis we develop an automated algorithm that identi es recurrent requests by analyzing connection logs.
we detect recurrent requests using the procedure outlined in algorithm .
the algorithm takes as input the series of timestamps when a request has been issued for a connection ti t nint ci.
from this series the algorithm computes a new series of deltas between each timestamp ci fti tij0 i ng.
the algorithm rst generates the request series by computing a moving average of request timestamps using a window sizew to group subsequent requests together.
next the algorithm calculates the deltas ci between subsequent requests.
from this distribution of civalues the algorithm uses a maximum likelihood estimator mle to estimate the distribution s parameters.
the algorithm then computes the relative standard deviation rsddeltas and compares it against a threshold .
if thersddeltas is below the threshold the algorithm considers the series as containing recurrent requests and return the estimated mean deltas.
deltasfrequency .
.
.
.
20figure distribution of deltas di erences between two consecutive timestamps between requests.
the line is a tted normal distribution parameterized by values retrieved through maximum likelihoodestimation mle in r package fitdist .
figure shows a real life example of such a series of deltas between requests of the connection statements residing in the package com.google.android.gms.b.os in the vlc direct android app.
we observed that the distribution of deltas associated with connections having recurrent requests in many of our subject applications was similar to the distribution observed in figure .
algorithm detecting recurrent requests.
procedure detectrecurrentrequest series w series movingaverage series w deltas calculatedeltas series deltas deltas mle deltas rsddeltas deltas deltas ifrsddeltas then return deltas else return .
.
evaluation we assess the quality of our frequency analysis by applying the procedure of algorithm to all connection logs from our subject applications using a moving average window of w seconds and a threshold .
we compare the results against the ground truth established in the manual analysis described in section .
columns and in table present the resulting precision and recall for the comparison.
precision refers to the fraction of connections correctly identi ed as recurrent among those 704bytecode instrumentationrun apk for minutes1.
profilingapk fileannotated apk .
frequency analysis connectionlogsautomated detection parameter u1d70c period .
battery aware transformationtransformed apk a a request rate throttling based on f b u1d70c figure approach overview illustrating all stages from original apk to battery aware transformed version of the apk reported by the automated analysis.
recall refers to the fraction of connections correctly identi ed as recurrent from the expected ground truth set.
on average the algorithm achieves precision and .
recall.
there were only a small number of cases where the algorithm could not correctly classify connections.
manual inspection of request traces led us to believe that these cases were the result of more than one process in an app executing the same statement e.g.
a statement in a library and as a result generating requests.
the resulting time series from such a process does not correspond to our current notion of recurrent requests.
more in depth analysis is required to either adjust the de nition or detection mechanism for recurrent requests.
summary our automated mechanism for detecting recurrent a a requests was able to achieve precision and .
recall with respect to the ground truth established in manual analysis.
.
battery aware transformation the idea behind our battery aware transformation is to transparently modify apps to limit the rate at which they perform recurrent a a requests.
our goal in performing these modi cations is to reduce the number of times a mobile device s network interface is activated.
because the network interface is an important contributor to power dissipation in mobile devices reducing communication should improve whole system energy e ciency.
as we want to balance the interests of app developers against those of mobile device users we modulate the fraction of recurrent requests that we remove based on the device s battery level.
we modify apps so that at full battery charge the code we insert into app bytecode permits all recurrent requests.
near complete battery depletion the inserted code permits no recurrent requests.
.
.
transformation models we consider a series of recurrent requests rci t fri rngin connection ciwithin a time span t. the series rc0 i tof a transformed connection c0 iis a subsetrc0 i t rci tof the recurrent requests in the original connection over the same time span t. there are two ways one could achieve this request rate limiting.
the rst option would be to skip every n requests to achieve a lower number of requests over the time span t. the other option is to inserta delay before or after every connection.
we investigate the delay option as it allows for more ne grained control over controlling the rate of requests.
we introduce a delay that is a function f b of battery statusband the period of the recurrent request .
we use a transformation model that linearly increases the delay as battery status decreases equation .
we include the constant factor cto allow for adjustment in linear increase or decrease of the delay flinear b c b following the notion of a low power mode we discussed in the introduction a possible transformation model would be to throttle resource consumption when hitting a speci c lower battery status e.g.
see equation cagain is a constant factor applied to the period .
flowpowermode b c ifb otherwise .
.
application transformation we again use soot to instrument the application binaries and insert a delay following a transformation model.
in the following we outline the method batteryawaretransformer the transformation is implemented through a bodytransformer in soot in which all methods in a binary are iterated.
the method provides a collection of units which roughly correspond to a line of bytecode i.e.
invocations assignments etc.
.
given a map of detected connections paired with their periods as parameters the transformer checks whether a the unit contains an invocation that is a connection and b it is contained in the map of detected connections.
if a given unit is identi ed as one of the detected connections we inject a thread.sleep invocation2with a chosen transformation model f b as its parameter.
since thread.sleep may cause a interruptedexception we also inject a trap with this exception that does nothing.
2more speci cally java.lang.thread void sleep long .
case study energy sa vings we apply the battery aware transformation on the use case application vlc direct to demonstrate potential energy savings.
since energy models on mobile devices su er from limited accuracy we assume a constant delay at a particular lower battery level.
we thus apply equation as our battery saving transformation model.
to determine the di erence in consumed energy we measured the energy consumption of the application before and after battery aware transformation.
we ran each experiment for minutes.
we repeated the measurement ve times for each version to minimize the possible impact of background noise.
for this initial evaluation we sampled energy consumption information from the device s fuel gauge at 1hz.
that is we polled the sys class power supply battery uevent interface fuel gauge for the voltage and current which was su cient for an initial investigation of the energy consumption.
we intent to look into more sophisticated measures of energy as part of future work.
table energy consumption average power dissipation of vlc direct before and after transformation before approach after approach mw milli watts run mw .
mw run .
mw .
mw run .
mw .
mw run mw .
mw run .
mw .
mw average mw .
mw stddev .
.
rsd .
.
energy absolute savings savings in saving .
mw .
the results of the energy evaluation case study are presented in table .
the values shown for each run represent the average power dissipation total power consumption divided by time of measurement .
we can see that the application after the battery aware transformation was able to decrease energy consumption by .
.
this result has to be seen relative to the potential power savings removing ads completely yields of average power savings while our approach strikes the balance between the needs of mobile application developers and users.
furthermore in lower power mode i.e.
low battery status around even smaller savings in energy consumption can make a difference.
we thus view this initial result as promising and expect even larger saving when the approach is applied to allapplications running on the same device.
summary applying the battery aware transformation to a use case application yielded .
of savings in energy consumption.
.
related work there has been a multitude of work researching energy consumption in mobile applications.
in the following we focus on work that has investigated the impact of advertisement on mobile applications and approaches of program analysis and transformation to reduce energy consumption.impact of advertisment on mobile applications work by gui et al.
investigated the impact of ads on di erent resources including energy consumption .
in a study considering similar aspects pathak et al.
examined where the energy is consumed in di erent apps and found that third party advertisement apis is a large factor .
work by prochkova et al.
speci cally explores the impact of ads in mobile games and found that applications that request information on ad servers more frequently consume more energy .
work by chen et al.
investigates the upper bound of energy savings by prefetching ads .
previous work by rubin et al.
studied the occurrence of requests that have no e ect on user observable functionality and found that ads are a substantial part of these covert communications .
program analysis and transformation to reduce energy consumption li et al.
use static analysis to reduce the energy consumption of apps by automatically bundling subsequent http requests .
recent work by gui et al.
explores methods for measuring and predicting ad related energy consumption based on static analysis .
while these approaches remove ads completely to analyze the impact of ads on mobile resources in this paper we propose to throttle the rate at which the ads are retrieved based on the current battery status.
other works in the area of program analysis and transformation have looked at improving display energy consumed by apps .
in contrast the focus of our work is on recurrent requests regardless of whether they are manifested in display updates or not.
.
limitations and future work empirical study using only eight subject applications might limit the generalizability of our study if the selected applications are not representative.
we try to mitigate this problem by choosing an unbiased sample.
we selected our subject applications from the most popular applications from the app store.
we did not interact with applications when investigating connection patterns during the dynamic analysis.
this limits the potential ndings of further recurrent request patterns.
furthermore we did not include apps that require any kind of user interaction especially logins to become fully usable.
thus if anything we are likely underreporting the prevalence of recurrent requests.
as a follow up to these explorations we plan to investigate how the phenomenon of recurrent requests manifests in more diverse types of applications and possible sequence of user interactions.
energy analysis we chose one use case application to demonstrate the potential energy savings of the novel approach.
the result of this early investigation is the basis for further exploration in this area.
in a future study we plan to evaluate the approach with more applications to see how much energy can possibly be saved for applications from different categories e.g.
games and utility apps di erent adframeworks e.g.
google admob3or unity ads4 di erent ad types just text photos or animations and connection types phone connected via 3g 4g or wi fi .
706modifying the binaries to introduce print statements might a ect the energy footprint of the studied application.
however these modi ed statements were present in both versions before and after transformation of the application.
if anything we are underestimating the potential energy savings.
to avoid unexpected results we performed all experiments of dynamic nature on the same device nexus with android .
.
and at the same location.
to demonstrate energy savings we also ran the experiment ve times to reduce possible background noise.
we use the fuel gauge of the phone to retrieve the necessary energy information at 1hz.
since our energy analysis is comparative we believe the accuracy provided by this method su ces.
however for future explorations of this space we intend to use a more ne grained and accurate approach such as the monsoon power meter5.
future explorations in general we want to continue studying the compromise between the usage of advertisement and analytics and energy consumption more in depth.
one possible route of investigation is gami cation for instance assigning energy badges to motivate developers to enable our approach.
another possible route of study would be to investigate game theoretical considerations with mobile developers and users as actors within the mobile market space.
furthermore the study of this compromise in itself could inform the design of future battery aware apis.
.
conclusion we presented early work on an automated approach that addresses the trade o of using advertisement and analytics services in mobile applications to increase the revenue of developers and provide them with insights into user behavior and reducing energy consumption to increase the usability of the device .
our approach identi es advertisement and analytics connections that contain recurrent requests to outgoing servers and throttles the number of requests over time based on the current battery state.
the results presented in this paper show potential for further research.
our proposed approach is intended to start a conversation about the con ict between the objectives of mobile developers and mobile users.
the next steps in this exploration will include a more ne grained view on the energy saving potential as well as game theoretical considerations to nd a pareto optimal solution of our aforementioned multiobjective optimization problem.
we could imagine the end result of our investigation to be implemented by controlling authorities e.g.
application stores in the form of gami cation energy badge or to inform ecosystem developers to build battery aware apis.
.