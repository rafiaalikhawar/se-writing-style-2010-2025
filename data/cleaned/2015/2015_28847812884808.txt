swim synthesizing what i mean code search and idiomatic snippet synthesis mukund raghothaman university of pennsylvania rmukund seas.upenn.eduyi wei microsoft research cambridge jasonweiyi gmail.comy oussef hamadi laboratoire d informatique cole polytechnique palaiseau youssefh lix.polytechnique.fr abstract modern programming frameworks come with large libraries with diverse applications such as for matching regular expressions parsing xml les and sending email.
programmers often use search engines such as google and bing to learn about existing apis.
in this paper we describe swim a tool which suggests code snippets given api related natural language queries such as generate md5 hash code .
the query does not need to contain framework speci c trivia such as the type names or methods of interest.
we translate user queries into the apis of interest using clickthrough data from the bing search engine.
then based on patterns learned from open source code repositories we synthesize idiomatic code describing the use of these apis.
we introduce structured call sequences to capture api usage patterns.
structured call sequences are a generalized form of method call sequences with if branches and while loops to represent conditional and repeated api usage patterns and are simple to extract and amenable to synthesis.
we evaluated swim with 30common c api related queries received by bing.
for of the queries the rst suggested snippet was a relevant solution and a relevant solution was present in the top 10results for all benchmarked queries.
the online portion of the work ow is also very responsive at an average of seconds per snippet.
.
introduction modern software engineering is reliant on large standard libraries such as the .net framework class library the java sdk and the android sdk.
these libraries provide a large variety of pre implemented functionality such as for matching regular expressions parsing xml les sending email and platform speci c features such as accessing the gps sensors and the phone camera.
when faced with an api related task this work was done when mukund raghothaman was an intern in yi wei and youssef hamadi s group at microsoft research cambridge.
the authors gratefully thank abhishek udupa for suggesting the name swim .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
programmers rely on search engines such as google and bing.
they seek answers to two main questions a what apis to use to solve their speci c problem and b how to write the code involving those apis.
developers will often read a few returned web pages to see if their code must follow certain programming idioms or common usage practices.
for example good practice dictates that les be closed after i o is complete and data may be transmitted via a socket only after a connection is successfully established.
in many cases developers search for api usage examples on online code repositories such as github and bitbucket or directly in their company s proprietary code bases.
this learning process is possible due to widely available information related to programming.
however a developer still needs to read multiple web pages and many programs written by others to learn about these apis and their usage patterns.
this paper introduces swim a tool to automate some of this discovery process.
swim is a code generator whose input is a natural language query in english such as match regular expression or read text le i.e.
the usual queries that a developer would enter in a search engine.
in response swim outputs snippets of c code such as that shown in gure which hopefully implement the task described in the query.
the query and the synthesized code snippets are api related meaning that they require the use of apis in the solution.
given that most programmers heavily use api libraries in their daily development activities this is an important class of queries submitted to search engines.
in this paper the word api refers to a eld or method from a class in the framework.
swim consists of two components the rst component the natural language to api mapper suggests a set of apis given a user query in english.
the second component the synthesizer generates code snippets using the suggested apis.
to suggest a set of apis from a user query the natural language to api mapper builds a model of the form pr tjq wheretis an api name and qis a user query.
this is the probability of the api tappearing in a snippet that solves the task described by q. this model pr tjq is learned from clickthrough data collected by bing.
the clickthrough data is a log of query url pairs which is recorded by most search engines.
each query url pair indicates that the user clicked on the result url when presented with a list of results for query .
for programming related queries the returned web pages often mention api names or contain code snippets which invoke apis.
the clickthrough data thus establishes a connection between english words in user queries and api names in our target programming language ieee acm 38th ieee international conference on software engineering o ine analysisu ser query a pi lookup r anked apis s tructured call sequence selection co de synthesis s olution snippetsqu ery to api modelclickthrough data s tructured call sequence indexs tructured call sequence extractiongithub code corpus v ariable name model figure architecture of the swim tool.
c .
note that the natural language to api name mapper only suggests which api names should be used.
there is often more detail to the use of an api than just the method to be invoked or the eld to be queried.
this includes contracts such as t.foo may only be called after a call to t.bar returned true and best practices such as ushing a stream after writing to it.
this data and control ow information along with other code artifacts such as variable names is not provided by the natural language to api mapper.
this is a deliberate design decision because a we want to make use of most of the clickthrough data.
many clicked web pages may only mention the api name without giving code snippets so no program analysis can be performed.
in such cases we still want to record the fact that a particular api name is mentioned.
b the insight is that to solve a task if a few key api names are given the rest of the program is quite predictable so a simpler model which is consequently easier to implement and train may su ce.
to synthesize code snippets from a set of suggested api names the synthesizer decides how to combine some of the apis together to form a valid and human readable snippet.
there are several parts to code synthesis a deciding how the object is to be constructed b deciding the sequence of methods to be invoked and elds to be queried and set in this object before the target api method may be invoked c the control ow between these object actions and d choosing appropriate variable names.
the synthesizer relies on another model structured call sequences to generate code with control and dataows.
structured call sequences describe typical usage patterns for api classes.
these usage patterns reveal how api classes are used for example which method calls precede other method invocations and how control ows between these statements.
using structured call sequences allows the synthesizer to generate code which covers the suggested apis from the natural language to api mapper and at the same time obeys common coding conventions.
structured call sequences are extracted from open sourceprojects on github.
this is because for most classes tin the api framework github contains many more usage samples than can be extracted from web pages.
for each supported type swim extracts structured call sequences from the source les in the code corpus.
in general there may be multiple ways of using any given type and so multiple structured call sequences may be extracted for each type.
they are grouped by syntactic equality and their occurrence frequencies are recorded for later use in ranking the generated solutions.
figure shows the overall architecture of swim .
the rst thread builds the natural language to api mapper using clickthrough data from bing.
the second thread analyses the github code corpus and builds an index of structured call sequences and a dictionary of variable names to be used during code generation.
both threads are run o ine.
finally on receiving the user query we consult the natural language model to suggest a ranked list of apis and nd relevant structured call sequences from the index using those apis as search keys.
these structured call sequences are synthesized into solution snippets.
this last thread is what is run online in response to a user query.
to evaluate swim we trained the natural language model with days of clickthrough data from bing and learned structured call sequences from a corpus of open source projects from github.
for each type we extracted structured call sequences from source les using the type.
we then asked swim commonly occurring api related queries from the bing query logs.
a professional developer graded the results for of the queries the rst solution snippet was marked relevant and for all the queries a relevant snippet was present in the top generated solutions.
of the chosen variable names were marked appropriate and our response time was very fast averaging about seconds per produced snippet.
contributions.
in summary the main contributions of this paper are .a technique to map natural language queries to api 358string pattern regexoptions options var regex new regex pattern options string input var match regex .
match input if match .
success var groups match .
groups figure example code to match a string against a regular expression.
names .the concept of structured call sequences to express common api usage patterns and an algorithm to extract structured call sequences from c code .a synthesis algorithm to generate code snippets from structured call sequences and .a prototype implementation of these ideas in the tool swim with experiments showing that relevant code snippets are generated for frequently asked api related queries.
paper outline.
the rest of this paper is organized as follows.
we introduce structured call sequences describe their extraction from the code corpus and describe the synthesis of code snippets in section .
next in section we introduce the natural language to api model explain how the model is trained from the search engine clickthrough data and how user queries are translated into structured call sequences for the synthesizer.
we then present a preliminary evaluation of swim in section and conclude with a summary of related work in section .
.
structured call sequences .
motivation in gure we present c code to match a string against a regular expression.
focus on the object referred to by the variable match .
it has type system.text.regularexpressions.
match and is created by the method regex.match string which accepts a single argument input of type string .
next thegroups property of the object is accessed depending on the value of success .
observe that this pattern of object creation method invocation and eld accesses summarized as regex.match string if get match.success get match.groups is a common way to use the match type the match.groups eld is only relevant if the input string matched the regular expression given by the eld match.success .
as another example in gure we present code to read the contents of a text le using the system.io.streamreader class.
it is usual practice to release the associated system resources by calling streamreader.close after i o is complete.
in this case the pattern of object usage may be summarized as new streamreader string streamreader.readtoend streamreader.close .string path var reader new streamreader path reader .
readtoend reader .
close figure example code to read a text le using the streamreader class.
we introduce the term structured call sequences to refer to these patterns of object creation method invocation and eld accesses.
a structured call sequence describes the object creation technique and a permissible sequence of methods invoked and elds accessed with control ow blocks such asifand while to describe conditional and repeated usage patterns.
they can express more complicated object usage patterns than just the construction technique or even speci c sequences of invoked methods but can still be extracted easily and can be readily synthesized into code snippets.
the thesis of this paper is that when grouped by syntactic equality commonly occurring structured call sequences largely describe idiomatic api usage.
we will formally de ne structured call sequences in subsection .
and then describe their extraction from the code corpus in subsection .
.
finally in subsection .
we will describe how structured call sequences are used in synthesizing code snippets to be presented to the user.
.
formal definition swim works with a simple subset of the c programming language.
we assume a nite set types of types.
each type thas a nite set of constructors methods and elds and some methods and elds may be marked static .
methods are uniquely identi ed by their signature the containing type method name and the list of argument types.
each method optionally has a return type and is otherwise marked void.
notably the language model disallows generic types anonymous classes rst class functions downcasts and exceptions.
given an object of type t an individual program statement might either a invoke a method t.method a1 a2 with arguments a1 a2 .
.
.
or b get or set the value of a eld t.field .
following the terminology of we term these atomic constructs actions action t get t.field jset t.field jt.method a1 a2 if the member is static such as console.writeline then the action can be performed without actually possessing an object of type t. if the type of the queried eld is u or if the return type of the invoked method is u we write action t u. as notational convenience we also treat constructors of the classtas static methods named newwith return type t. a structured call sequence chtfor a classtbegins with the creation of an object with type t and is a nite sequence of actions together with conditional statements and loops to represent repeated method invocations.
formally structured 1this limitation is because synthesizing a term with a given type is computationally hard in languages with generics and rst class functions .
extending our techniques to these language features is an important direction of future work.
359call sequences are productions of the following grammar cht creation tjaction tjunknown jcht1 cht2 chtk jif cht1 cht2 else cht3 jwhile cht1 cht2 creation t action u t the special construct unknown indicates unknown object usage for example when objects are passed to or returned by methods with unknown bodies.
for ease of presentation we omit control structures such as for loops and do while loops even though these are also handled by swim .
.
extracting structured call sequences our rst problem is to scan the code corpus and extract for each typetin the framework all structured call sequences corresponding to t. we use the recently developed microsoft roslyn compiler framework to analyze source les from the code corpus.
informally roslyn exports the compiler services and associated parsing and analysis algorithms as a c library.
it is a convenient framework because of two reasons a it gracefully handles errors in source les and performs best e ort parsing type resolution and variable binding in the presence of syntax errors and missing libraries.
because of its nature we cannot expect all projects in the corpus to be free of compile time errors and diverse build systems make building or even identifying library dependencies infeasible.
furthermore b roslyn transforms the source les into an ast representation with simple visitors and this makes structured call sequence extraction straightforward.
the extraction algorithm works at the level of individual methods in the code corpus.
let vbe a local variable of typetwhich is not aliased by other variables.
we extract the structured call sequence chvdescribing its lifetime by traversing the ast of the method body .for each assignment statement of the form v u. member if we can resolve the referenced member to a possibly static member u.method of the framework we produce the creation action u.method .
.for each method call v.method or eld access v. field orvar f v.field we emit the corresponding action set t.field orget t.field respectively.
.given a sequence of statements stmt stmt stmt k we extract the structured call sequence chifor the variablevfrom each statement stmt i and produce the structured call sequence ch1 ch2 chk.
.for the conditional statement if stmt stmt else stmt we produce the structured call sequence if ch1 ch2 else ch3 where ch1 ch2andch3are the structured call sequences obtained from stmt stmt 2andstmt 3respectively.
while loops are similarly handled.
.whenevervis passed as an argument to another method we insert a unknown inchv.
finally we simplify the structured call sequences thus obtained by a few straightforward rules.
for example ch1 if empty ch2 else empty where empty is the empty sequence is transformed into ch1 ch2.algorithm code gen cht v .
given the type t linear call sequence cht and variable name v the algorithm synthesizes the corresponding code snippet.
.ifcht creation torcht action t the synthesis procedure is described in subsections .
.
and .
.
respectively.
.ifcht cht1 cht2 chtkis a sequence then the code snippet stmt iis synthesized for each element chti.
the concatenated snippet stmt stmt stmt kis produced as output.
.ifcht if cht1 cht2 else cht3 then a boolean expression boolexpr is synthesized from cht1 as described in subsection .
.
.
if cht2and cht3are synthesized into stmt 2andstmt 3respectively then we emit the snippet if boolexpr stmt else stmt .
a similar procedure is used for while loops.
by not performing inter procedural analysis or considering aliased variables our structured call sequence extraction technique is admittedly conservative.
in our anecdotal experience while individual structured call sequences may be ignored during extraction because of the large number of source les used pervasive idioms are not missed.
we postpone the development of more sophisticated extraction techniques to future work.
.
synthesis from structured call sequences we now consider the problem of transforming a linear call sequence chtinto a code snippet given the user query and the chosen variable name v. we will discuss the choice of variable names later in subsection .
.
and section is devoted to obtaining the structured call sequence chtfrom the user query.
the overall snippet synthesis procedure is described in algorithm .
there are three important details corresponding to object creation the synthesis of method arguments and the synthesis of boolean expressions described in subsections .
.
.
.
and .
.
respectively.
.
.
object creation and tracer methods recall that a linear call sequence chthas a single creation action creation t which is also the rst element in cht.
if creation tis of the form u.method where method is a static member of the class u then we can simply declare the variable vasvarv u.method .
however in the case that method is an instance variable we rst need an objectuof typeu.
for example constructing the object match in gure requires that we already have an object of type regex .
furthermore it is conceivable that objects of type uthemselves maintain state and it is therefore insu cient to blindly construct objects of type uand invoke method .
constructing the object uis therefore similar to the original snippet synthesis problem except for the additional constraint that it contain an invocation of method .
we call method the tracer of interest.
we now describe the return value of code gen cht v where cht creation t usagetandcreation t u.method .
letstmt tbe the snippet synthesized by code gen usaget v .
360given the user query let chube the top ranked structured call sequence over uwhich also contains an invocation of u.method andube the chosen name for the object of typeu.
then code gen creation t usaget v returns the output of code gen tracer .
the procedure code gen tracer is similar to code gen except that it inserts the snippet stmt t immediately after the rst invocation of u.method .
for example for the snippet in gure we start with the structured call sequence regex.match string if get match.success get match.groups .
we rst synthesize the snippet if match .
success var groups match .
groups to construct the regex object we then pick the structured call sequence new regex string regexoptions regex.
match string and merge the two snippets to produce the nal synthesized code.
while it is possible that the recursive object construction procedure may not terminate we have not observed this problem in practice.
if necessary we can force termination after a pre determined recursive depth with the default snippet default u .method .
.
.
synthesizing method arguments a second di culty is in synthesizing method arguments.
given a method t.method v1 v2 vk swim currently chooses the default value for each argument null for reference types and zero for value types varv1 default t1 varv2 default t2 varvk default tk t. method v1 v2 vk wheret1 t2 .
.
.
tkare the types of the respective arguments.
more involved schemes can be used to generate argument values but would require much greater computational resources and are therefore not used.
.
.
boolean conditions the nal interesting detail is in the synthesis of boolean expressions for conditional statements and loop bodies.
synthesizing meaningful conditions would require deep semantic knowledge consider for example distinguishing between the pair of code snippets in gures and .
deciding which of these code snippets is more standard requires understanding the semantics of the ienumerator.movenext method and that a return value of true indicates that the iterator was successfully advanced to the next position.
we instead use the following simple procedure to obtain condition expressions.
recall that every conditional in a linear call sequence has a single action.
we can readily convert every non void methodt.method into the boolean expression t.method default u and every eld access get t.field into the boolean expression t.field default u whereuis the return type of the method or the type of the eld respectively.
while we generally generate non standard code accessing the correct elds in the conditions is usually valuable guidance to the programmer.list list var enumerator list .
getenumerator while enumerator .
movenext var current enumerator .
current figure idiomatic conversion of the return value to a boolean.
list list var enumerator list .
getenumerator while !
enumerator .
movenext var current enumerator .
current figure non standard conversion of the return value to a boolean.
.
.
picking variable names consider the solution snippet from gure where the variables pattern andinput were instead called var1 andvar2 respectively.
this hypothetical solution snippet is clearly inferior as it obscures the role of the variables pattern and input .
therefore an important part of a good solution snippet is the choice of descriptive variable names.
a similar problem has been considered by raychev et al in the context of deobfuscating javascript programs.
however the statically typed setting and the fact that we are synthesizing target code rather than analyzing it means that simpler techniques su ce in our setting.
at each step during synthesis we maintain a set of forbidden identi ers f. this includes identi er names which have already been used and the set of reserved c keywords.
whenever we declare a new variable we accumulate a list of candidate names c sorted by preference and pick the rst name in cwhich does not appear in the forbidden set f. if all candidate names are unviable we use the following simple fallback naming convention the variable name is the rst non forbidden identi er in the in nite list var1 var2 var3 .
.
.
.
we will now describe the procedure to assemble the list of candidate names c. for each method t.m in the api framework we scan the code corpus and construct a list l of name frequency pairs name n1 name n2 where niis the number of times the result of the invocation t.m was assigned to a variable named name i. now consider an object vdescribed by the structured call sequence var v t.m .
for this object we choose the candidate names cto be the list of names name name inl arranged in descending order of frequency.
a similar algorithm is used to choose the candidate names for each eld assignment t.f.
thus for example we observed that objects constructed using the new regex string regexoptions constructor are most frequently assigned to a variable named regex and objects returned by the regex.match string method are most frequently stored in a variable named match .
note that the construction of the name frequency lists is performed ofine and the online variable naming algorithm simply chooses 361the rst non forbidden name in this list.
for objects intended as method arguments the candidate name listcis the singleton list where name is the formal name of the argument in the method declaration.
.
mapping user queries to structured call sequences structured call sequences represent empirically observed api usage idioms but do not directly tell us which high level problems they solve.
since the swim synthesizer accepts a natural language query as input we rst need to nd a mapping from natural language queries to the c api.
in this section we describe how we use query expansion to model this mapping and explains how we train the model from clickthrough data.
.
query expansion the mapping from a natural language query to api names can be modeled as pr tjq the probability of a c api tappearing in the solution snippet given the user query q. the higher the probability the more likely it is that t appears in the code to solve the task described in q. the synthesizer applies this model to the query q nds the most likely apis that should appear in the synthesized snippet and uses the structured call sequences extracted from the code corpus to output the appropriate snippets.
the key idea is to view the computation of pr tjq as a query expansion problem.
query expansion is a commonly used technique in search engines where the user input is usually vague.
experience and research have shown that adding one or more words to the queries can enhance the precision of the search result.
this process is called query expansion.
usual candidates for word expansion include synonyms of the words appearing in the user queries.
in our case we want to nd the api names that are relevant to the user query i.e.
expand the user query with api names.
people have proposed many ways to formulate the query expansion problem.
in this paper we follow the method proposed by gao et al.
which uses clickthrough data to nd relevant words for expansion.
when a user types a query in a search engine and the engine returns a list of results the user may click on one or more links.
search engines typically record a lot of information about this click but in the present paper we only consider the set of pairs query url indicating the url url the user clicked on in response to the search term query .
for a programming related query the clicked web page will possibly contain one or more program fragments.
to nd candidate api names tfor the expansion we look at code fragments appearing on those web pages.
we examine text contained within html tags such as pre code and p which are likely to contain code fragments.
we then use the c parser from roslyn to parse the text the text has been preprocessed before parsing to correct obvious syntax errors and determine whether it is a fragment of c code.
finally api names are extracted from the parsed code fragments.
besides code fragments we also collect api names that are mentioned in the text.
letpbe the list of api names in the code fragment in their appearance order.
then a single clickthrough pair query url can be represented as a set of q p pairs because there may be multiple fragments on a web page .the mapping from the user query qto an api name t or the probability of tbeing the expansion term given q is given by pr tjq pr tjq1 q2 q n nx i 1pr tjqi pr q ijq whereq represents the user query containing the words q1 q2 .
.
.
qn pr tjqi is the probability of the apitgiven a single query word qi pr qijq is the unsmoothed unigram probability of the query word qiin the queryq.
equation decomposes the calculation of pr tjq into the calculation of two simpler probabilities pr tjqi and pr qijq .
the former quanti es the connection between an api and a single word in the user query.
the latter quanti es how likely the query term qiappears in queries it serves as normalization.
we now describe how we estimate these two probabilities from data.
.
estimating pr tjq pr tjq represents the probability of the api element t appearing in the solution snippet given the occurrence of the wordqin the user query.
it establishes the connection from english words to c api elements.
we estimate this model using clickthrough data which also links user queries to web pages containing api names.
as described above clickthrough data contains q p pairs where qis the user query and pis the list of api names appearing in code fragments on the clicked web page.
note however that this still does not relate individual query words q2qto api elements t2p.
to solve the problem we use a standard procedure for training statistical word alignment models by applying an expectation maximization em algorithm.
the em algorithm rst initializes pr tjq to random values for each tandq and then iteratively updates the probabilities to maximize the likelihood of generating the training data.
as an example if the user query is match regular expression then q .
if the clicked web page contains the snippet shown in gure then the api sequence is p .
given enough data the em algorithm will eventually assign values to pr tjq such that pr regexj regular pr groupsj regular .
.
estimating pr qjq this probability quanti es how likely the query term qis to appear in a query and is calculated as follows pr qjq qp q02q q0 where qis the appearance frequency of qin all possible queries.
to estimate q we use the same clickthrough data focussing on just the queries q of times qoccurs in query log total term count in query log .
retrieving structured call sequences from user queries given a user query q the pr tjq model o ers a list of possible api elements ranked by their probabilities.
each 362api element tmay be a member of a di erent type tin the framework.
however to generate code the swim synthesizer needs to start with a single structured call sequence.
this section describes how we use document similarity to choose the structured call sequence from a ranked list of api names.
leta be the list of all api names that the system supports where nis the number of apis.
then a real valued vector of length nwith each element chosen from the range can represent the weight of each api.
note that conceptually this vector is very long its length is equal to the number of api names that are supported in the system.
for example the current implementation of swim includes types in common .net libraries and over methods from those types.
the vector is sparse most of its elements are zeros or very small probability values if we perform smoothing while training the pr tjq model .
from a ranked list of probabilities pr tjq we create thequery vector by setting the corresponding element to the values of those probabilities.
for example if pr regexj regular and pr matchj regular then we set the elements corresponding to the apis regex andmatch in the query vector to and respectively.
we can also similarly represent each structured call sequence chby a vector vchof lengthn for each api tthat appears in ch we set the corresponding element in vchto and all other elements are set to .
we call this the structured call sequence vector ofch.
the synthesizer maintains a repository of vectors for all structured call sequences mined from the code corpus.
with query vectors and structured call sequence vectors de ned the synthesizer uses cosine similarity among those vectors to nd the most relevant ones.
the cosine similarity function is widely used in information retrieval.
it is de ned by the following formula similarity a b pn i 1ai biqpn i 1a2 i qpn i 1b2 i whereaandbare two vectors of length n. given two documents the higher the similarity the more relevant the documents are to each other.
we use the implementation provided by the open source information retrieval package lucene which compares the query vector against all structured call sequence vectors and returns a ranked list of structured call sequences.
these structured call sequences are then fed to the synthesis algorithm of section .
.
.
ev aluation in this section we present some initial results from the swim synthesizer.
the tool is currently implemented as a c library we are working on the design of an intuitive interface so that more comprehensive user studies and measurements of programmer productivity can be performed.
.
setup swim needs large amount of c code to extract structured call sequences and clickthrough data to train the natural language to api mapper.
to prepare the data we downloaded c projects from github.
these projects together contain about million les.
we extracted structured call sequences for common .net types.
for each type we located c les where that type appears and used those les for extraction.to train the natural language to api mapping model we used days of clickthrough data from the bing search engine.
we ltered the data to only focus on queries that contain the keyword c .
the training is done through a standard implementation of expectation maximization algorithm.
to evaluate the synthesis process we selected apirelated queries from the bing search log.
these queries are frequently asked and they cover various api usages from simple to more involved.
the column labeled query in table lists the chosen queries.
the typical apis column of the table lists some apis that are commonly used to implement tasks described in the queries as suggested by the nlp model of section .
note that the listed apis are not exhaustive because the same task can be implemented by many di erent apis in di erent ways.
only the most likely apis are listed in the table.
the full list of generated solutions may be downloaded from .08497v2 anc .
.
experiment results we asked a professional developer to grade the top swim solutions for each benchmark query.
the snippets were marked relevant irrelevant indicating whether the developer thought that it implements the task described in the query.
we also asked the developer to annotate all the chosen variable names as appropriate or inappropriate.
a variable name was annotated as appropriate if it adequately conveyed the purpose of the variable.
.
.
snippet relevance the frank column of table reports the rank of the rst generated solution that is relevant to the query.
this metric is important because most users will scan through the results from top to bottom.
for the benchmark queries in of the cases the rst generated snippet is relevant.
this shows the synthesizer is able to locate the correct apis and further choose the likely control ow structures to generate snippets.
also observe that in all cases at least one of the top solutions was marked relevant.
the top5 and top10 columns of table report the percentage of relevant snippets in the top and generated solutions.
observe that the user queries are vague and there are usually many ways to implement a given task using di erent apis and so there is no single correct solution to a query.
by exploring di erent apis and di erent usage patterns the synthesizer generates variations of the same topic so the users can browse through and understand di erences among them.
these two metrics quantify how relevant a list of suggestions are to a query.
on average of the synthesized snippets from the top generated solutions and from the top solutions are observed to be relevant.
this suggests that the overall list of presented solutions is itself relevant to the user.
.
.
variable name choices the proper choice of variable names is an important part of program comprehensibility and particularly so in program synthesis.
the column marked var in table lists the number of variable names that the synthesizer chose for the most relevant snippets.
the numbers outside the parentheses are the number of variable names and the numbers inside the parentheses are the fraction of meaningful names as annotated by the professional developer.
the 363table benchmark queries.
the columns are described in section .
.
query typical apis frank top5 top10 var time in s append strings stringbuilder.append tostring append text le file.appendtext appendalltext binaryformatter binaryformatter.serialize deserialize connect to database sqlconnection.open convert int to string convert.tostring convert string to int convert.toint32 copy le file.copy create le file.create writealltext current time datetime.now download le from url webclient.downloadfile execute sql statement sqlcommand.executenonquery executereader generate md5 hash code md5.computehash get current directory directory.getcurrentdirectory get les in folder directory.getfiles launch process process.start waitforexit processstartinfo load bitmap image bitmap.fromimage fromfile load dll assembly.load match regular expression regex.match match.success open le dialog openfiledialog.showdialog filename parse datetime from string datetime.parse parse xml xmltextreader.create read play sound soundplayer.play playsync random number random.next nextbytes nextdouble read binary le file.openread read filestream.read read text le file.readalltext streamreader.readline send mail smtpclient.send mailmessage.from mailaddress serialize xml xmlserializer.serialize string split string.split regex.split substring string.substring test le exists file.exists average .
numbers reveal that in majority of cases on average the synthesizer is able to nd meaningful variable names.
it also shows that for very speci c tasks such as random number serialize xml the chosen variable names are more likely to be meaningful while for more general tasks such as substring the variable names contain more noise.
this is because the synthesizer chooses the variable names according to their appearance frequency in github repositories.
for speci c tasks the distribution of variable names given by programmers are more focused on a small range of names while for general tasks the variable name distribution tends to be more uniform.
.
.
synthesis time finally responsiveness was an important requirement while creating swim .
the column marked time in table shows the time required by the synthesizer to generate the top solutions.
the experiments were run on a desktop workstation with a .6ghz processor and gb of ram.
observe that we require an average of .
seconds to produce each solution snippet and believe that this is responsive enough for practical use.
also note that the current prototype synthesizer is not optimized and contains many redundant calls to roslyn and the re ection apis.
better engineering is likely to further reduce the response time by a large fraction.
.
examples of synthesized snippets we now provide concrete examples of synthesized snippets and discuss the behavior of swim .
we will also describe the limitations of the current tool and ideas for future improvements.
figure shows the top snippet for the query convert int to string .
this is an incorrect snippet because the snippet converts a string to an integer by using the convert.toint32var value default string system .
convert .
toint32 value figure incorrect solution snippet for query convert int to string .
var dlg new openfiledialog dlg.
title null dlg.
initialdirectory null dlg.
filter null dlg.
filterindex if dlg.
showdialog var fname dlg.
filename figure snippet for query open le dialog .
method instead of converting an integer to a string.
the third solution not shown here generated by swim actually chooses the right method convert.tostring .
in this case the natural language to api mapper favors toint32 since it happens much more often.
in future work natural language processing techniques such as pattern detection can be used to disambiguate apis.
for example if the query contains patternt1tot2 wheret1andt2are types we then require the input and output type of the synthesized snippets to be t1andt2.
figure shows the top snippet for the query open le dialog .
the snippet rst initializes a fileopendialog object and then sets a few properties such as title of the dialog 364var startinfo new processstartinfo startinfo .
filename null var process process .
start startinfo process .
waitforexit figure snippet for query launch process complete .
initial directory of the le explorer location when the dialog starts the le pattern lters and the lter index.
then the snippet shows the dialog and gets the user selected le if any when the dialog is closed.
notice that all the properties are initialized to the default value of the corresponding types.
in c the default value for string isnull and for intis0.
this is the default behavior of the synthesizer.
while this is appropriate for properties such as initialdirectory it is incorrect for properties such as filter .
the fileopendialog .filter property expects strings in a certain format.
for example a lter to select text les and all les looks like text files .txt .txt all files .
.
.
such properties are common in api libraries.
other examples include database connection strings which is needed in the query open database connection and the datetime format strings such as yyyy mm dd in the query parse datetime from string .
ideally for properties required to be in a certain format the synthesizer should provide some common patterns instead of just generating the type wise default values.
the di culty is in automatically determining which properties require formats.
potential solutions include a scanning the documentation of class properties to detect the mention of particular formats and b scanning code repositories to nd properties which are frequently assigned constants and use heuristics to decide if those constants have some structure.
figure shows the 8th solution snippet for the query launch process .
this snippet rst creates a processstartinfo object and sets the filename property to null actually the user will set the property to the proper le name to launch and then uses the static method process.start from the process class to start the process.
the return value of the start method is an object of type process .
calling waitforexit on the object waits for the launched process to nish.
to come up with this snippet the synthesizer chooses the root type process to rst generate the third and the fourth line.
and then since the start method requires an object of type processstartinfo the synthesizer nds a structured call sequence of type processstartinfo to come up with the rst and second line.
however if the synthesizer starts with the type processstartinfo then the result will not be a complete snippet.
figure shows this case.
this snippet is the top snippet for the query launch process .
it only includes the statements to initialize a processstartinfo object but misses the statements on the process class to start and terminate the process.
thus the snippet is incomplete.
the reason for the incompleteness is that after the part for processstartinfo is generated the synthesizer stops because the generated statements for processstartinfo do not rely on any other objects.
however the synthesizer does not know processstartinfo alone does not fully implement the user query.
to solve this problem future work will allow the synthesizer to focus on more than one root types by modeling the jointvar startinfo new processstartinfo startinfo .
filename null startinfo .
createnowindow false startinfo .
redirectstandardoutput false startinfo .
redirectstandarderror false startinfo .
useshellexecute false figure snippet for query launch process incomplete .
probability pr t1 t2 representing the probability of t1and t2appearing together.
if two types are more likely to appear together the synthesizer will generate fragments for both types and combine them together.
to estimate such joint probability we may need to do inter procedure analysis when extracting structured call sequences.
.
related work there is a large body of work on programmer assistance and snippet synthesis tools.
with the wide availability of open source software there is a growing realization that existing code corpuses can be used in program analysis and code synthesis including contemporary initiatives such as the darpa muse program .
in this section we summarize existing work and contrast it with the present paper.
snippet synthesis as type inhabitation.
traditional ide tools such as intellisense are derived from early systems such as project marvel .
these tools typically provide interactive feedback listing the methods and elds in the highlighted object and expressions of appropriate type available for use in the highlighted context.
the prospector tool considered the problem of synthesizing jungloids snippets of code which construct an object of typetout given an input object of type tin.
prospector works with a very simple type system where the set of types is nite and a set of pre determined functions convert objects of one type into another.
unfortunately in languages with richer type systems such as with generics and rst class functions type inhabitation is computationally intractable.
more recent work focusses on developing practical heuristics and techniques to rank completions so that short natural code snippets are ranked higher than longer snippets of code.
synthesis of partial expressions has also been considered as a way to generalize intellisense where the tool automatically suggests expressions with holes that consume one or more objects with known types and emit an object whose type is optionally known.
lastly tools such as codehint are very interesting because they perform type inhabitation at runtime.
at a very high level codehint is a debugger plugin which can be queried for expressions of a given type or whose values satisfy some assertion.
one major limitation of these techniques is that the developer is required to have some prior knowledge of the api framework such as the names of types .
expressing queries in natural language allows developers who are new to the development environment to easily nd their way around.
typestate aware code completion.
another shortcoming of type inhabitation based code completion techniques is their ignorance of object state which is 365central to the imperative programming method.
the notion of typestate was rst considered by strom and yemini .
while the original proposal required syntactic extensions for api designers to describe typestate there have been e orts to automatically learn typestate by program analysis and from code corpuses .
e orts to describe api usage by n grams and method call sequences can be seen as typestate aware code synthesis.
slang similarly analyses method call sequences from a code corpus and uses statistical techniques to insert method calls at designated holes in the user program.
there are several challenges with these approaches including a sensitivity to algorithm parameters such as n which are di cult to set accurately and b di culty with api usage idioms which are inexpressible as nite state machines such as library provided stack data structures and where the next permissible methods depend on previous return values for example where ienumerator.current contains a meaningful value only if the last call to ienumerator.movenext returned true .
furthermore given two method call sequencess1ands2from di erent les in the code corpus merging these into a single suggested call sequence sis di cult.
in our work we do not try to merge structured call sequences and instead group them by syntactic equality and suggest multiple solution snippets.
groums are similar to structured call sequences but while structured call sequences deal with the lifetime of a single object groums relate data ows between multiple objects.
groums were initially proposed to perform anomaly detection but more recently gralan has been proposed as a similar statistical model for code completion.
because swim synthesizes snippets from scratch rather than attempting to ll holes in existing programs the simpler model o ered by structured call sequences su ces for our purposes.
answering free form queries.
a major component of our problem setting is the use of free form natural language queries while most existing work on snippet synthesis requires prior knowledge of relevant types such as processstartinfo orxmltextreader .
the sniff system attempts to solve the same problem as us but di ers in technical details.
in sniff each method call in the codebase is annotated with the text of the associated api documentation while indexing.
on receiving an input query all annotated source les matching the query are retrieved and a type based intersection of these is returned as the synthesized code.
the main di erences from this system are two fold.
first the use of search engine clickthrough data rather than relying on documentation text allows us to use a larger body of text and more reliably convert natural language queries into the apis of interest.
second because structured call sequences are extracted o ine rather than by online codebase analysis we can respond quickly to input queries currently at an average of seconds per synthesized snippet even in our unoptimized implementation.
in keivanloo et al propose a method to spot code examples from free form user queries.
the idea is to rst group code fragments together according to their structural similarity using clone detection and then a set of associative keywords such as identi er names are extracted from each group of code.
these keywords are matched against the user query to retrieve and rank the code.
the method is similar to sniff where the code is represented by the documentationof the apis that are used in it.
gvero et al developed the anycode tool to synthesize snippet expressions from free form queries.
given a query the tool is able to synthesize an expression invoking a single api that implements the desired task.
anycode locates which api method to use by string matching.
to handle the problem of api name and search query term mismatch anycode includes words with similar meanings to api names by using wordnet.
anycode also uses parse tree from a natural language processing toolkit to nd relations among variable names and constant expressions mentioned in the query to put them in the synthesized expression.
anycode is similar to what we built in bing developer assistant in which we also use nlp parse trees to handle variable generation in code synthesis.
the main di erence between anycode and our current work is that anycode is only able to synthesize an expression swim can synthesize snippets with multiple statements and control ows.
to synthesize such snippets we face a much larger search space than anycode does hence a code model describing popular usage patterns is key to making the tool practical.
le et al introduced the smartsynth tool which synthesizes mobile applications from free form user descriptions.
smartsynth focuses on a prede ned set of apis to use and builds a model to map words in user queries to the set of apis.
it also uses data ow analysis to nd missing statements to synthesize.
smartsynth can generate larger snippets than swim but a user needs to provide a longer description to the tool.
another di erence is that smartsynth focuses a prede ned set of apis while our tool handles all possible apis in the open domain.
in allamanis et al developed a bimodal model to map natural language queries to snippets.
the work builds a separate model for each query type and is able to synthesize snippets for variations of the type of query.
for example for the query type create array the method can synthesize snippets for di erent ways to create arrays such as create a 2d array make int array .
the model for each query type is built manually by ning all possible ways that people might ask for a query type and this manual process is expensive.
in contrast the work presented in current paper is fully automated but cannot understand subtle di erences in the phrasing of a query.
.
conclusion in this paper we described swim a tool to synthesize api related code snippets given natural language queries.
we mined api usage patterns in the form of structured call sequences from open source c projects and used clickthrough data from bing to map queries to the types and methods of interest.
we believe that structured call sequences are a fundamental empirical artifact of api design and that they can be used in numerous applications such as code anomaly detection.
there are several potential directions of future work.
first better nlp techniques would help to distinguish between similar apis such as convert.toint32 and convert.tostring .
second better structured call sequence extraction algorithms and handling of language features such as exceptions would expand the range of expressible api usage idioms.
finally modeling joint probability distributions would help to solve the incomplete snippet problem of gure .
.