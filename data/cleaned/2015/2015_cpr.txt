copy and paste redeemed krishna narasimhan institut f ur informatik goethe university frankfurt krishna.nm86 gmail.comchristoph reichenbach institut f ur informatik goethe university frankfurt reichenbach cs.uni frankfurt.de abstract modern software development relies on code reuse which software engineers typically realise through handwritten abstractions such as functions methods or classes.
however such abstractions can be challenging to develop and maintain.
one alternative form of re use is copy paste modify a methodology in which developers explicitly duplicate source code to adapt the duplicate for a new purpose.
we observe that copy paste modify can be substantially faster to use than manual abstraction and past research strongly suggests that it is a popular technique among software developers.
we therefore propose that software engineers should forego hand written abstractions in favour of copying and pasting.
however empirical evidence also shows that copy paste modify complicates software maintenance and increases the frequency of bugs.
to address this concern we propose a software tool that merges together similar pieces of code and automatically creates suitable abstractions.
this allows software developers to get the best of both worlds custom abstraction together with easy re use.
to demonstrate the feasibility of our approach we have implemented and evaluated a prototype merging tool for c on a number of near miss clones clones with some modifications in popular open source packages.
we found that maintainers find our algorithmically created abstractions to be largely preferable to existing duplicated code.
i. i ntroduction as software developers add new features to their programs they often find that they must modify existing code.
the developers now face a choice they can either introduce a possibly complex abstraction into the existing working code or copy paste and modify that code.
introducing the abstraction produces a smaller more maintainable piece of code but alters existing functionality on the operational level carrying the risk of introducing inadvertent semantic changes.
copying pasting and modifying introduces duplication in the form of near miss clones which tend to decrease maintainability but avoid the risk of damaging existing functionality .
duplication is wide spread especially if we count near miss clones type clones in the terminology of koschke et al.
i.e.
clones with nontrivial modifications.
however duplication is unpopular in practitioner literature and can be a substantial problem during development and maintenance as inconsistent clones constitute a source of faults .
similarly we found evidence in an informal poll among c developers that practitioners prefer abstraction over duplication.
this suggests that there is a re use discrepancy between what developers want and what they do.
kapser and godfrey offer one possible explanation they claim that code cloning can be used as a effectiveand beneficial design practice in a number of situations but observe that existing code bases include many clones that do not fit their criteria for a good clone .
we suggest an alternative explanation namely that developers view cloning as an implementation technique rather than a design practice they would prefer abstraction but find copy paste modify faster or easier to use.
in our informal poll among c developers we found evidence that supports this idea section ii a .
in this paper we propose a novel solution to the re use discrepancy that offers all the speed and simplicity of copypaste modify together with the design benefits offered by abstraction by using a refactoring algorithm to merge similar code semi automatically.
with our approach developers reuse code by copying pasting and modifying it producing near clones equivalent to near miss clones1 .
developers then invoke our tool to merge two or more near clones back into a single abstraction.
since there may be multiple ways to introduce an abstraction e.g.
function parameters or template parameters our tool may ask the developer to choose which abstractions they prefer during the merge.
our tool is easily extensible so that developers may add support for their own abstractions e.g.
project specific design patterns .
we find that our approach is not only effective at solving the aforementioned re use discrepancy but also produces code that meets the qualitative standards of existing open source projects.
moreover our approach can improve over manual abstraction in terms of correctness as with other automatic refactoring approaches ensuring correctness only requires validating the small number of constituents of the automatic transformation mechanism as opposed to the unbounded number of hand written instances of manual abstractions that we see without our tool.
our contributions are as follows we describe an algorithm that can automatically or semi automatically merge near clones and introduces user selected abstractions.
we describe common abstraction patterns for c supported by our implementation.
we report on initial experiences with our algorithm on popular c projects drawn from open source repositories.
we find that code merged by our approach is of sufficiently high quality to be accepted as replacement to unmerged code in the majority of cases.
1we prefer the term near clones over near miss clones as the notion of a miss is only natural in clone detection but not in clone generation .c os t t costfunction1 coord s t a r t end f c os t t dx s t a r t .
ne end .
ne c os t t dy s t a r t .
se end .
se return std max dx dy g c os t t costfunction2 coord s t a r t end f c os t t dx s t a r t .
ne end .
ne c os t t dy s t a r t .
se end .
se return std hypot dx dy gc os t t costfunctionm coord s t a r t end bool chebyshev f c os t t dx s t a r t .
ne end .
ne c os t t dy s t a r t .
se end .
se i f chebyshev f return std max dx dy ge l s ef return std hypot dx dy g g fig.
.
an example of merging two functions by introducing a boolean parameter and an ifstatement.
we describe the results of an informal poll among c programmers that involved a number of coding tasks.
while the poll has only a small sample size its findings show that copy paste modify can substantially outperform manual abstraction in practice.
section ii further motivates our approach and briefly sketches our algorithm.
section iii describes our merge algorithm.
section iv then discusses our implementation.
section v presents our evaluation on open source software.
section vi discusses related work and section vii concludes.
ii.
t owards principled software development with copy paste modify past work in clone detection has found that clones are widespread .
we hypothesise that a key cause for this prevalence of clones is that copy paste modify makes software developers more productive at least in the short term.
to explore this hypothesis we conducted a preliminary exploratory experiment with a group of graduate student volunteers.
a. benefits of copy paste modify for our exploratory experiment we selected five pairs of c methods from the google protobuf2 facebook hhvm3 and facebook rocksdb4open source repositories randomly choosing from a set of near clones reported by a simple clone detector section iii a .
we then removed one of the methods and asked five graduate students with 2months 3months and and 10years of c programming experience respectively to implement the missing functionality.
we asked the students with 3months and 4years of experience to modify the existing method to support both the existing and the new functionality i.e.
to perform manual abstraction and the remaining three students to use copy paste modify .
we found that the students using copy paste modify were almost universally faster in completing their objectives minutes than the students who performed manual abstraction minutes with three tasks left incomplete .
we found only one exception where the best performing student on manual abstraction completed the task in the same time as worst performing student using copy paste modify.
since the three students using copy paste modify finished first we asked them to also perform manual abstraction on a total of five of the problems they had just solved but despite their familiarity with the code they consistently performed worse taking more than twice as long as before when completing the exact same task again with manual abstraction.
however developers showed a preference for having abstractions as a result in cases vs. for copy paste modify out of responses cf.
appendix viii .
while our numbers are too small to be statistically significant they are evidence that copy paste modify can be more effective than manual abstraction at accomplishing re use at the method level.
b. copy paste modify versus manual abstraction to understand why copy paste modify might be easier consider function costfunction1 from figure .
this function adapted like the rest of the example from the openage5project computes the chebyshev distance of two twodimensional coordinates.
the implementation consists of a function header with formal parameters a computation for the intermediate values dxand dy and finally a computation of the actual chebyshev distance from dxand dy.
at some point a developer decides that they need a different distance function describing the beeline distance between two points i.e.
q dx2 dy2 .
computing this distance requires almost exactly the same steps as implemented in costfunction1 except for calling the standard library function std hypot instead of std max .
at this point the developer faces a choice they can copy and paste the existing code into a new function requiring only a copy paste and rename action and modify the call from std max tostd hypot a trivial one word edit or they can manually alter function costfunction1 into costfunctionm depicted on the right in figure or a similar function.
this migration requires introducing a new parameter introducing an ifstatement adding a new line to handle the new case and updating all call sites with the new parameter perhaps using a suitable automated refactoring .
intellectually programmer must reason about altering the function s control flow formal parameters and any callers that expect the old functionality whereas with copy paste modify they only needed to concern themselves with the exact differences between what already existed and what they now needed.
we observe that it is possible to devise an algorithm that takes costfunction1 and costfunction2 and abstracts them into a common costfunctionm taking care that any callers still continue to work correctly.
note that there are other possible solutions for costfunctionm .
the one illustrated here is straightforward but different code and different requirements may call for different solutions.
for example we could pass std hypot orstd max as function parameters wrap them into delegates or pass an enumeration parameter to support additional metrics within this one function.
the best abstraction mechanism may depend on style preferences performance considerations and plans for future extension we thus opt to rely on user interaction to choose the most appropriate abstraction mechanism for a given situation.
iii.
m erging algorithm to merge two or more such functions or analogously methods we examine and transform their abstract syntax trees asts .
we refer to the sets of asts for multiple functions as clone groups .
our merge algorithm first computes the pairwise differences between each of the asts in one clone group then collects differences that are shared among multiple clones and finally merges the differences by resolving them through one of several resolution patterns .
a. linking near clones through robust tree edit distance we detect differences between asts through the robust tree edit distance rted algorithm .
rted computes the nodes that we need to add to or remove from one ast to obtain another its output is an edit list i.e.
a list of delete insert orrename operations delete a node and connect its children to its parent maintaining the order.
insert a node between two adjacent sibling nodes.
rename the label of a node essentially replacing one node by another.
b. identifying common differences we consider any node that occurs in an edit list to not be shared between the two asts.
to illustrate how we use this information we will use the code from figure as a running example.
this somewhat synthetic example presents three unlikely merge candidates the functions are both sufficiently small and sufficiently dissimilar that users might not be inclined to merge them.
however the example showcases special cases in our algorithm and illustrates that our approach works even for code with a large degree of variation.
our algorithm now considers the asts of the three functions upper half of figure and determines the following the set of nodes that are common to all the asts i.e.
which do not occur in any edit lists which thealgorithm will place in the merged tree unaltered.
in the example in figure this set contains the nodes fa x y zg.
all other nodes together with a the alternative choices for such nodes that we must merge.
these alternatives must have matching node types e.g.
statement expression .
.
.
or our algorithm will abort.
b the asts that each of the alternatives belongs to.
consider the nodes b from asts and and the node b2 from ast in figure .
these nodes are competing for the same place in the target ast but they are not identical we refer to such nodes as merge candidates .
node b is an example of a node that appears in multiple asts without occurring in all of them.
we first identify such partially shared nodes from our edit lists these nodes show up in some edit lists but not in all of them.
we use the notion of a unique set uin the figure to describe the nodes that are uniquely shared among a particular subset of asts.
consider the example in figure .
the nodes b and c are present only inast 1andast .
we write u ast ast to describe nodes that are present precisely in the two specified asts but in none of the other asts that we are considering.
since there are no further nodes that are unique to ast 1andast u ast ast fb cg.
whenever we have merge candidates competing for an ast node we introduce a special operator into the output ast to facilitate the merge.
however we only need those operators in places where there is actual disagreement between what node should be there.
these places are precisely the roots of the subtrees that are not shared between all asts.
for this purpose we further filter the unique sets into rootsets.
the rootset of a set of nodes nis the minimal set rootset n nsuch that all nodes n2nhave an ancestor in rootset n .
we consider n to be an ancestor of itself for our purposes.
the minimal rootset is unique because otherwise there would be at least one node with two parents which is not possible in an ast.
the rootset consists of all the nodes in the set that have no parent nodes that are also in the set.
figure illustrates an example computation of these sets for the asts in figure .
figure summarises at a high level how our algorithm identifies the various sets in figure .
we observe precisely one unique set that is different from its rootset.
this is because the node b the a parent of the node c and so the rootset of that subset fast ast 2gcan be reduced to just b .
we assume that there are mechanisms to retrieve the information about the position of every node apart from its label.
with that information we gather that node b from the setfast ast 2gand node b2 from the set fast 3gare merge candidates.
c. merge algorithm given the unique sets and rootsets we first construct an intersection tree which is simply the intersection of all asts i.e.
the common nodes and tree edges .
consider the common nodes generated from figure fa x y zg.
the algorithm adds these nodes as is as illustrated in figure .our algorithmoverview of the steps in the identifying common differences phase we begin with a set of all asts in our clone group ast all.
for each set of asts s ast all we compute the unique set u s .
unique sets describe the nodes that are present in all asts in s but not in any asts in ast allns.
we compute the rootset of each computed unique set.
rootset ndset of a set of nodes is the minimal set of nodes belonging to ndset such that every node in ndset has an ancestor in rootset ndset .
fig.
.
overview of the preliminary phase.
ast all fast ast ast 3g u ast fd f1g rootset fd f1g u ast fe f2g rootset fe f2g u ast fb2 f3 ngrootset fb2 f3 ng u ast ast fb cg rootset fbg fig.
.
example sets generated by the common difference identification phase assumes that every node in the rootsets presents an opportunity to merge.
for each such node the algorithm gathers the nodes that need to be merged at the same child position with the same parent node and introduces a merge point .
in our example node b from the rootset for fast 1ast 2gand node b2 from the rootset for fast 3gwould be candidates for merging as both are competing for the position of the first child of node a .
we introduce a merge point mp at that position and attach b and b2 as children.
another example is the conditional introduction of node n .
this introduction is unique to ast but it moves node 1void f u n c t i o n 2f b c d y f1 x z 6g1void f u n c t i o n 2f b c e y f2 x z 6g1void f u n c t i o n 2f b2 n y f3 x z 7g 1void fnmerged i n t f u n c t i o n i d i n t fvalue i n t bparam 2f i f f u n c t i o n i d jjf u n c t i o n i d 4f b c bparam 6g i f f u n c t i o n i d 8f b2 n 11g y fvalue x z 14g fig.
.
example of a three way merge supported by our tool.
a b cdyf1x z2 a b ceyf2x z3 a b2 nyf3x z merge a mp b cmp deb2mp ny mp f1f2f3x z fig.
.
example merge y to child position of node a .
our algorithm automatically compensates to ensure that f1 f2 and f3 are now merged at child position even though they appear as the third child of a in ast 1andast .
finally we eliminate merge points by applying resolution patterns .
a resolution pattern is a code transformation pattern to resolve the merging of certain types of nodes at given merge points.
a resolution pattern will return a node to be inserted at the merge point under consideration.
additionally it can transform other parts of the ast.
the merging algorithm is therefore not a fully automatic process.
it identifies merge points and for each merge point the user picks a resolution pattern that effects the merge at that point.
the algorithm identifies the merge points separately from the resolution patterns because some resolution patterns may apply to multiple merge points.
table i lists the resolution patterns that our prototype system supports together with the node types they are applicable to.
consider the example of replacing the same integer constant in multiple points.
the algorithm offers resolution patterns based on the node type for each merge point.
for example if the nodes under consideration in a particular position are all constants we can introduce introduce an extra parameter of the type of the constant and pass the constant as the parameter value.
another possibility would be to introduce a global field that could be assigned the constant.
we split resolution patterns into a merge substitution part and a fixup part.
the merge substitution part contains the merged node that is to be inserted into the merged method.
this mergesubstitution part replaces the merge point in the ast.
the fixup part handles other modifications that need to be performed.
these modifications could involve handling call sites or introducing parameters to the merged method or even changing other classes and introducing super classes.
while we could only use a single transformation for each resolution pattern table i. a vailable resolution patterns as options presented to the user type of node possible resolution patterns caller w callee statement switch conditional branch with extra parameter field literal extra parameter field type of an argument template parameter identifier template parameter extra parameter we find that discussing the merge substitution part separately is helpful in understanding each pattern.
consider again our example in figure .
when we merge the asts generated for function1 through function3 we obtain a merged ast as in the lower half of figure .
if we then pick suitable resolution patterns we obtain the function fnmerged from figure .
in the following subsections we discuss resolution patterns that we implemented to evaluate our approach.
although our approach is generic and theoretically can be applied to any ast chunks we merged method definitions and replaced the existing definitions with calls to the merged method.
since the merging process involves creating a new merged method and introducing sensible calls to the merged method we generate a merged version of the parameters.
a merged version of the parameters is simply a combined list of the parameters of the individual methods.
two parameters are equal if their types names and type qualifiers specifiers are equal.
we maintain a map of the individual parameters to their positions in the merged parameters to generate appropriate calls.
for each of the following resolution patterns we describe the merge resolution and the fix up part.
we illustrate our resolution patterns with examples taken from open source projects hosted at github.
we picked these four patterns by studying clone groups containing various nearclone methods and selecting the four patterns that we found to cover the largest subset of the cases that we considered.
we found them to be fully sufficient for the examples that we had randomly selected for evaluation.
the examples presented here are abbreviated for space reasons.
in the examples the nodes highlighted in red indicate the unique nodes in each function and the nodes highlighted in blue indicate the nodes emerging from the merge resolution.
pattern switch statement with extra parameter this resolution can be applied if the nodes to be merged are all statements.
we then construct the following switch statement merge resolution switch choicef case stmt break .
.
.
case k stmt k break g where choice is a fresh function method parameter stmt i is one statement alternative taken from a unique set and iis a unique number identifying the unique set.
fix up we add choice as an additional formal parameterto the surrounding method or function and modify the corresponding call sites to supply their own ast ids as actual parameters.
consider the function snippets 1j o b j e c t function openronly jljava jnienv env j o b j e c t jdb .
.
f rocksdb db db n u l l p t r rocksdb status s about l i n e s of common code s rocksdb db openforreadonly opt db path column families handles db return n u l l 10g 12j o b j e c t function open jljava jnienv env j o b j e c t jdb .
.
f return rocksdb db db n u l l p t r rocksdb status s about l i n e s of common code s rocksdb db open opt db path column families handles db return n u l l 22g our pattern merges these snippets by introducing a switch statement to choose between the two options.
modulo variable renaming and indentation this produces the following output with the generated switch statement in lines 1j o b j e c t function openronly jljava jnienv env j o b j e c t jdb .
.
f return function open ronly jljava env jdb .
.
7g 9j o b j e c t function open jljava jnienv env j o b j e c t jdb .
.
f return function open ronly jljava env jdb .
.
15g 17j o b j e c t function open ronly jljava jnienv env j o b j e c t jdb .
.
i n t opentype f rocksdb db db n u l l p t r rocksdb status s about l i n e s of common code switch opentype f case s rocksdb db openforreadonly opt dbpath column families handles db break case s rocksdb db open opt dbpath column families handles db break g32 return n u l l 33g pattern pass extra parameter for literal expressions this resolution can be applied if the nodes to be merged are all literal expressions.
literal expressions are nodes that have a constant value and type.
we require that each of these constants are of the same type.
the merge resolution is a simple identifier expression that switches between the corresponding constants based on the values passed to value a fresh parameter.
we resolve this pattern with an identifier expression which is a node that contains a name of a field or a variable.
merge resolution value fix up we add value as additional formal parameter to the surrounding method or function and modify existing call sites to supply their own constants as actual parameters input.
consider the following function snippets taken from the oracle s node oracledb project6 1handle value 2connection g e t c l i e n t i d local string property 4c o n s t accessorinfo i n f o 5f .
.
.
i f !
njsconn i s v a l i d .
.
.
e l s e msg njsmessages geterrormsg errwriteonly clientid njs set exception msg .
c s t r i n t msg .
length return undefined 16g 18handle value 19connection getmodule l 20local string property c o n s t accessorinfo i n f o 22f .
.
.
i f !
njsconn i s v a l i d .
.
.
e l s e msg njsmessages geterrormsg errwriteonly module njs set exception msg .
c s t r i n t msg .
length return undefined 33g 35handle value 36connection getaction local string property 38c o n s t accessorinfo i n f o 39f .
.
.
i f !
njsconn i s v a l i d .
.
.
e l s e msg njsmessages geterrormsg errwriteonly action njs set exception msg .
c s t r i n t msg .
length return undefined 50g our tool would identify that the calls to getclientid getmodule and getaction are resolvable using an extra parameter.
modulo variable renaming and indentation this produces the following output the id expression errormsg produced in line 1handle value 2connection getproperty local string property 4c o n s t accessorinfo info 5s t r i n g errormsg 6f .
.
.
i f !
njsconn i s v a l i d .
.
.
e l s e msg njsmessages geterrormsg errwriteonly errormsg njs set exception msg .
c s t r i n t msg .
length return undefined 17g 19handle value 20connection g e t c l i e n t i d local string property 22c o n s t accessorinfo i n f o 23f return connection getproperty property info c l i e n t i d 27g the methods getmodule and getaction 30are constructed to be s i m i l a r to g e t c l i e n t pattern templates for type expressions we can apply this resolution if the nodes to be merged all represent types.
we again introduce a fresh identifier expression type .
merge resolution type fix up the fix up introduces a new formal template type parameter to the function definition for type parameter type .
consider the function snippets taken from the rethinkdb project7 1cjson cjson createintarray int numbers i n t count f .
.
.
f o r i n t i a i count i f .
.
.
6g a t a i l p return a 9g 11cjson cjson createdoublearray double numbers i n t count f .
.
.
f o r i n t i a i count i f .
.
.
16g a t a i l p return a 19g our tool would identify that we can merge the calls to createintarray and createdoublearray by introducing a template type parameter.
modulo variable renaming and indentation this produces the following output 1template typename t 2cjson cjson createnumarray tnumbers i n t count f .
.
.
f o r i n t i a i count i f .
.
.
8g a t a i l p return a 11g 13cjson cjson createintarray i n t numbers i n t count f return cjson createnumarray numbers count 17g 19cjson cjson createdoublearray double numbers i n t count f return cjson createnumarray numbers count 23g pattern pass extra parameter for identifiers this resolution can be applied if the nodes to be merged are all variable identifiers identifier expression nodes i.e.
hold the name of a field or a variable.
we require that each of these variables is of the same type.the merge resolution is a simple id expression that switches between the corresponding variable names based on the values passed to the value a fresh parameter.
merge resolution value the resolution here is very similar to the pattern except that our algorithm promotes lvalues to pointer type parameters whenever needed.
passing identifiers is more challenging than passing literals.
an interesting scenario in this pattern is when the variable is assigned before reference.
consider the following example 1void fn1 2f i n t x i n t y x 5g 6void fn1 7f i n t z i n t y z 10gour algorithm handles this case by identifying two different merge points each for the identifiers x and z and performing a post processing step to link the definition and reference of the variable.
fix up we add value as additional formal parameter of the type of the identifiers being merged and modify the corresponding call sites to supply their own identifiers as actual parameters.
consider the function snippets taken from facebook s hhvm project8 2type typediv type t1 type t2 3fi f auto t eval const divmod t1 t2 celldiv return t return t i n i t p r i m g 7type typemod type t1 type t2 8fi f auto t eval const divmod t1 t2 cellmod return t return t i n i t p r i m g our tool would identify that the calls typediv andtypemod can be merged by introducing an extra parameter.
modulo variable renaming and indentation this produces the following output 2template class cellop 3type typemoddiv type t1 type t2 cellop fun f i f auto t eval const divmod t1 t2 fun return t return t i n i t p r i m 9g 11type typediv type t1 type t2 12freturn typemoddiv t1 t2 c e l l d i v g 13type typemod type t1 type t2 14freturn typemoddiv t1 t2 cellmod g iv.
i mplementation we implemented the distance calculator the algorithms and the framework on top of eclipse cdt9.
we adapted an existing implementation of rted10and modified it to fit our cdt ast representation.
the existing implementation worked on inorder representations of trees with string nodes.
we replaced the nodes to contain information about ast node types and content.
we supplied the source file with the clone groups as input to an eclipse environment setup to include the merging as a refactoring menu option.
we marked the potential candidates using pragma annotations.
the result was a new file with the marked functions merged and the original functions calling the new merged function with the common functionality.
we copied the result file back to the repository overwriting the original version of the file and the repository was built tested and run.
we also identified potential candidates for merging our modified edit distance calculator.
we explain the details of the actual identification and the merges in the evaluation sectionv.
we have made prototype publicly available11.
v. e valuation we evaluated our approach by exploring the following research question rq are the abstractions performed by our algorithm of sufficient quality for production level code?
in order to evaluate this question we first looked for clone group candidates to merge.
we explored popular github repositories identified potential candidates for merging and abstracted the identified candidates using our approach.
we finally submitted the abstracted code back to the developers through pull requests to see how many of them were of sufficient quality to be introduced back in their production code.
we then performed a total of abstractions of clone groups and sent them as pull requests to trending github repositories.
table ii lists the repositories that we looked at for our evaluation the urls of the pull requests the number of clone groups abstracted per repository and the status of the pull requests.
a. identifying and merging clone groups the most promising clone group candidates for our approach are those with near clones.
unfortunately these are are particularly difficult to find for traditional clone detectors.
we therefore used edit distance as a metric for identifying potential clone groups.
edit distance is a metric that we can compute with the rted algorithm section iii a by simply measuring the length of an edit list.
we started with the repositories in table ii and collected all function method pairs belonging to the same source file.
we then calculated the edit distance of each pair.
for each function pair we first determined the bigger function by ast node count .
we then marked the function pair as a potential clone group code if the number of nodes in the bigger function fnbigger was greater than a customisable threshold nand if the ratio of the edit distance to fnbigger was less than a customisable threshold r. we then randomly picked function pairs potential clone groups out of the candidates.
for each function pair we manually explored other related functions that we also found listed as near clones.
whenever our developer intuition suggested that these additional functions were similar enough in behaviour and structure we added them to the clone group as a developer would do when using our tool in practice.
each clone group contained functions.
note that this process was purely for evaluation purposes as the focus of our work is on merging and not on clone detection.
we then merged the clone groups used a predetermined resolution pattern for each node type before submitting the pull requests we resolved differences in statements using switch statements and an extra parameter specifying the ast statement to branch to pattern we resolved differences in literal expressions constants by passing additional parameters pattern we resolved differences in type expressions using templates pattern we resolved differences in identifier expressions using additional parameters promoted to pointers for lvalues and formal parameters specifying the name or the address of the variable pattern we also performed minor manual changes.
these include providing meaningful names to parameters.
our tool generated random fresh names based on the position of the merge points.
adding function prototypes to header files.
the manual changes are standard refactorings that are not central to our approach.
b. results we performed our initial evaluation phase using an early version of our merging tool that could perform only merges of pairs of functions and did not support multiple resolution patterns for the same pair.
during phase we ran our distance calculator on the top trending c repositories in github during the month of december and selected potential clone groups after setting threshold rto .
and threshold nto infinity meaning that we accepted functions of all sizes.
we submitted abstractions as pull requests and all but one of the clone group abstractions were rejected or pending.
the results of the pull requests highlighted areas of improvement in our first prototype.
table iii.
p hase 1results submitted accepted rejected pending we performed our second evaluation phase using a complete version of the our merging tool capable of merging an arbitrary number of functions methods at the same time.
this version also supported resolving multiple merge points with different node types.
during phase we ran our distance calculator on the top trending repositories during the month of february .
we set threshold rto .
and threshold nto .
we changed the thresholds building on experience from phase in order to focus on clone groups that would save more lines of code when abstracted.
the thresholds were thus set to very strict numbers meaning the clones were very similar to each other and tied to methods of substantial sizes.
we then submitted abstractions as pull requests summarised in the table below and found that all of them were accepted except for one table iv .
p hase 2results submitted accepted rejected pending 0table ii.
r epositories with their pull request url s. each clone group represents one abstraction .
w e encourage readers who choose to look at the pull requests to go through the comments .
w hile some of the pull requests don t explicitly have their status listed as merged as with the oracle db and the mongo db repositories the codes have actually been merged as indicated by maintainer comments .
repository phase clone groupsstatus url oracle node oracledb accepted mongodb mongo accepted rethinkdb rethinkdb accepted cocos2d cocos2d x accepted ideawu ssdb rejected facebook rocksdb pending openexr openexr pending facebook hhvm rejected google protobuf accepted rejected sfttech openage rejected we conclude that the repository maintainers found our code to be of sufficient quality including readability and maintainability for inclusion.
specifically we observed no negative comments regarding readability in any of the comments that we received.
c.analysis of rejected and pending results we present the results of the pending and rejected pull requests summarised in table ii and provide our analysis on the same.
pending results below we note feedback to pull requests that were neither accepted nor rejected.
let us first discuss the pending pull request from rocksdb.
the exact comment from the head maintainer of the project was great stuff now its only one commit after the squash !
waiting for ok from anon1 or anon2 since they maintain this code before merging.
we interpret that the pull request was met with positive review.
we did check with the maintainers of the repository to no avail.
we suspect that developers have many tasks and only one of them is attending to pull requests our patch may not be their top priority.
the other pending pull request was from the openexr repository.
the request merged clone groups at once and received a mixture of responses.
one maintainer requested an explanation of the advantages.
another maintainer expressed scepticism over the performance overhead of such an abstraction as it was a low level function.
a third maintainer requested a unit test of the introduced abstraction before a merge.
we could not satisfy these requests due to a lack of understanding of the semantics of the functions we had merged.
all these activities took place over a month period.
rejected results of the five rejected clone group abstractions four were rejected because the maintainers felt thatnot enough lines were saved.
we did not receive an explanation for the remaining rejected clone group abstraction for the ideawu ssdb repository.
vi.
r elated work our work is inspired by existing work on clone detection lagu e et al.
find that between .
and .
of the source code in different versions of a large mature code base are clones.
they only count clones that are exact copies type clones in the terminology of koschke et al.
or copies modulo alpha renaming type clones .
baxter et al.
report even higher numbers sometimes exceeding on different code bases and with a different technique for clone detection that also counts near miss clones or type clones which are substantially related pieces of software in which small parts of the ast subtree may differ.
we consider the prevalence of such near miss clones to be strong indicators that copy paste modify is a wide spread development methodology.
other related work on clone detection focuses on detecting clones and near clones to identify faults and enable refactoring .
similar to ccfinder gemini our tool specifically looks for near clones to merge however our focus is not on detecting near clones in unknown code but rather on merging deliberate and known clones.
as our evaluation shows our approach is effective on general clones.
the other closely related work is refactoring .
as in prior work we break our transformations into individual atomic components namely merges which may be nested and require individual interaction and fixups for existing code to use the refactored code.
other work on clone management include tracking tools like cloneboard and clone tracker .
while cloneboard provides the ability to organise clones and to some extentsuggest the types of clones and possible resolution mechanisms clone board lacks the ability to actually perform an abstraction and merge clones into a common functionality.
another approach to handling clones is linked editing .
linked editing unlike our approach maintains the clones as they are but allows editing of multiple clones simultaneously.
this has the advantage of preserving code as is but the disadvantage of requiring continued tool usage for future evolution.
linked editing shares our view that copy pastemodify is an effective way to evolve software but disagrees on how clones should be managed it is an open question which of the two approaches is more effective for long term software maintenance.
perhaps the most closely related clone management approach to our algorithm is cedar which targets java and relies on eclipse refactorings for abstraction.
unlike our approach cedar is limited to type clones.
to the best of our knowledge ours is the only work to support merging the common type clones inexact clones in a wide variety of cases.
as roy et al.
note type clones are particularly common and frequently evolve out of type and clones.
while our work ignores the c preprocessor in c there is prior work on supporting the c preprocessor in c .
this work could be adapted to c to enable our system to support preprocessor based abstraction patterns.
vii.
c onclusions managing code clones is a significant problem given the amount of copied and pasted production level code.
this suggests that developers find re use through code clones useful in practice even when they know that re use through manual abstraction would yield superior and more maintainable code we find this confirmed both by prior work and by an informal poll that we conducted among c developers.
we propose to close the gap between re use through copy paste based clones and abstraction through semi automatic refactoring.
we have implemented a prototype of a suitable refactoring tool that identifies parts of clones that can be merged and proposes suitable resolution patterns to merge them to the user.
the user then makes the design decision of how to merge.
we have evaluated this approach by implementing a prototype merging tool and applying a select set of resolution patterns to near clones in popular github repositories.
we submitted the merged code back to the developers via pull requests and observed that the original developers found more than with the most recent version of our tool of our changes to be desirable merging them back into their code bases.
viii.
a ppendix programmer poll this appendix summarises our informal poll.
we asked five students table v to perform re use tasks with copy pastemodify and with manual abstraction table vi summarises the amount of time taken to complete the tasks.
whenever one student performed both copy paste modify and manual abstraction the student first completed the copy paste modify tasks.
we later polled students whether they would prefer for the outcome to have been copy paste modified code or abstracted code.
four students responded we summarise their responses for each task in figure .table v .
s tudent experience levels .
student experience 10yr 3mo 4yr 1yr 2mo table vi.
a mount of time used for extending functionality .
task a c a c a c a c a c dnf dns dns dnf did not finish dns did not start a abstraction c copy paste task task task task task responses favour abstraction favour copy paste undecided fig.
.
preferred results after extending functionality.
out of the answers we received were undetermined preferred copy pasted code and preferred abstracted code.