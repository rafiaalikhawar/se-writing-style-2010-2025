time to clean your test objectives micha l marcozzi imperial college london department of computing london united kingdom m.marcozzi imperial.ac.uks bastien bardin cea list software safety and security lab gif sur yvette france sebastien.bardin cea.frnikolai kosmatov cea list software safety and security lab gif sur yvette france nikolai.kosmatov cea.fr mike papadakis snt university of luxembourg luxembourg michail.papadakis uni.luvirgile prevosto cea list software safety and security lab gif sur yvette france virgile.prevosto cea.frlo c correnson cea list software safety and security lab gif sur yvette france loic.correnson cea.fr abstract testingistheprimaryapproachfordetectingsoftwaredefects.a major challenge faced by testers lies in crafting efficient test suites able to detect a maximum number of bugs with manageable effort.
to do so they rely on coverage criteria which define some precise testobjectivestobecovered.however manycommoncriteriaspecify a significant number of objectives that occur to be infeasible orredundantinpractice likecoveringdeadcodeorsemantically equalmutants.suchobjectivesarewell knowntobeharmfultothe design of test suites impacting both the efficiency and precision of the tester s effort.
this work introduces a sound and scalable techniquetopruneoutasignificantpartoftheinfeasibleandredundant objectives produced by a panel of white box criteria.
in a nutshell wereducethistasktoprovingthevalidityoflogicalassertionsin thecodeundertest.thetechniqueisimplementedinatoolthatreliesonweakest preconditioncalculus andsmtsolvingforproving the assertions.
the tool is built on top of the frama c verification platform which we carefully tune for our specific scalability needs.
theexperimentsrevealthatthepruningcapabilitiesofthetoolcan reducethenumberoftargetedtestobjectivesinaprogrambyup to and scale to real programs of 200k lines making it possible to automate a painstaking part of their current testing process.
ccs concepts software and its engineering software testing and debugging theory of computation program analysis keywords coverage criteria infeasible objectives redundant objectives a major part of this work has been performed as a cea list employee.
this work has been partially funded by the french anr grant anr inse .
this work has been partially funded by the eu h2020 programme grant .
permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrightsforthird partycomponentsofthisworkmustbehonored.
for all other uses contact the owner author s .
icse may june gothenburg sweden copyright held by the owner author s .
acm isbn .
reference format micha l marcozzi s bastien bardin nikolai kosmatov mike papadakis virgile prevosto and lo c correnson.
.
time to clean your test objectives.inproceedingsoficse 40thinternationalconferenceonsoftware engineering gothenburg sweden may june icse pages.
introduction context.
heretofore softwaretestingistheprimarymethodfor detecting software defects .
it is performed by executing the programs under analysis with some inputs and aims at finding some unintended defective behaviors.
in practice asthe number of possible test inputs is typically enormous testersdo limit their tests to a manageable but carefully crafted set of inputs calleda testsuite.tobuildsuchsuites theyrelyonso called coverage criteria also known as adequacy or test criteria which definetheobjectivesoftesting .inparticular many white box criteria have been proposed so far where the test objectives are syntacticelementsof thecodethatshouldbecoveredbyrunning thetestsuite.forexample the conditioncoverage criterionimposes to cover all possible outcomes of the boolean conditions appearing in program decisions while the mutant coverage criterion requires to differentiate the program from a set of its syntactic variants.
testers need then to design their suite of inputs to cover the correspondingtestobjectives suchas forthetwoaforementioned cases condition outcomes or mutants to kill.
problem.
white box testing criteria are purely syntactic and thus totallyblind tothesemanticsof theprogramunderanalysis.
asa consequence many of the test objectives that they define may turn out to be either a infeasible no input can satisfy them such as dead code or equivalent mutants or b duplicate versionsofanotherobjective satisfiedbyexactlythe same inputs such as semantically equal mutants or c subsumed by another objective satisfied by every input coveringtheotherobjective suchasvalidityofacondition logically implied by another one in condition coverage.
we refer to these three situations as polluting test objectives which arewell knowntobeharmfultothetestingtask for two main reasons acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. marcozzi s. bardin n. kosmatov m. papadakis et al.
while early software testing theory requires all the criterion objectives to be covered this seldom reflects the actual practice which usually relies on test suites covering onlya part ofthem .thisisduetothedifficultyofgeneratingtheappropriate test inputs but also to infeasible test objectives.
indeed testers often cannot know whether they fail to cover them be cause their test suites are weak or because they are infeasible possibly wasting a significant amount of their test budget trying to satisfy them.
as full objective coverage is rarely reached in practice testersrelyontheratioofcoveredobjectivestomeasurethestrengthof their test suites.
however the working assumption of this practice is that all objectives are of equal value.
testing research demonstratedthatthisisnottrue asduplicationand subsumption can make a large number of feasible test objectives redundant.
such coverable redundant objectives may artificially deflateorinflatethecoverageratio.thisskewsthemeasurement which may misestimate test thoroughness and fail to evaluate correctly the remaining cost to full coverage.
goalandchallenges.
whiledetectingallpollutingtestobjectives is undecidable our goal is to provide a technique capable to identifyasignificantpartofthem.thisisachallengingtaskasit requires one to perform complex program analyses over large sets ofobjectivesproducedbyvariouscriteria.moreover duplication andsubsumptionshouldbecheckedforeachpairofobjectives a priori putting a quadratic penalty over the necessary analyses.
althoughmanystudieshavedemonstratedtheharmfuleffectsof pollutingobjectives todatethereisnoscalabletechniquetodiscard them.mostrelatedresearchworks seetables1 2andsection8 focusontheequivalentmutantproblem i.e.theparticularinstanceofinfeasibletestobjectivesforthemutantcoveragecriterion.these operateeitherin dynamicmode i.e.mutant classification or in static mode i.e.
trivial compiler equivalence tce .
unfortunately the dynamic methods are unsound and producemany false positives while the static one does not deal with all forms of mutation and cannot detect subsumed mutants whereasithandlesduplicatesinadditiontoinfeasibleones .the luncov technique combines two static analyses to prune out infeasible objectives from a panel of white box criteria in a generic way but faces scalability issues.
sound scalekind of pollution criterion inf.
dupl.
subs.
genericity mutant class.
check check tce check check check check luncov check check check lclean this work check check check check check check table comparison with closest research techniques analyses scope acuteness tce built in compilerinterprocedural optimizations luncov value analysis andinterprocedural weakest precondition lclean this work weakest precondition local function table static analyses available in closest techniques proposal.
ourintentistoprovidea unified soundandscalablesolutiontopruneoutasignificantpartof pollutingobjectives includinginfeasible butalsoduplicate andsubsumed ones whilehandlinga largepanelofwhite boxcriteriaina genericmanner.toachievethis we propose reducing the problem of finding polluting objectives forawiderangeofcriteriatotheproblemofprovingthevalidity of logical assertions inside the code under test.
these assertions can then be verified using known verification techniques.
ourapproach called lclean isthefirstonethatscalestoprogramscomposedof 200klinesofc code whilehandlingall types ofpollutingtestrequirements.itisalsogeneric inthesensethat it covers most of the common code based test criteria described in software testing textbooks and it is capable of using almost any state of the art verification technique.
in this study we use weakest preconditioncalculus withsmtsolving andidentify 25k polluting test objectives in fourteen c programs.
lclean introduces two acute code analyses that enable focusing thedetectionofduplicateandsubsumedobjectivesoveralimited amount of high hit rate pairs of objectives.
this makes it possible to detect a significant number of redundant objectives while avoiding a quadratic penalty in computation time.
the lclean tool is implemented on top of the frama c ltest platform which featuresstrongconceptual and technical foundations section .
wespecificallyextendtheframa cmodulededicatedtoproving code assertions to make the proposed solution scalable and robust.
contributions.
tosum up wemake the followingcontributions thelcleanapproach a scalable sound and unified formal technique sections and capable to detect the three kinds of polluting test objectives i.e.
infeasible duplicate and subsumed for a wide panel of white box criteria ranging from condition coverage to variants of mcdc and weak mutation.
anopen source prototype tool lclean section enacting the proposed approach.
it relies on an industrial proof formal verifi cation platform which we tune for the specific scalability needs of lclean yielding a robust multi core assertion proving kernel.
a thorough evaluation sections and assessing a thescalabilityanddetectionpoweroflcleanforthreetypes of polluting objectives and four test criteria pruning out up to of the objectives in c files up to 200k lines b theimpactofusingamulti corekernelandtailoredverificationlibrariesontherequiredcomputationtime yieldingaspeedup of approximately and c that comparedtotheexistingmethods lcleanprunesoutfour timesmoreobjectivesthanluncov inabouthalfasmuch time itcanbeoneorderofmagnitudefasterthan unsound dynamicidentificationof likely pollutingobjectives andit detectshalfmoreduplicateobjectivesthantce whilebeing complementary to it.
potential impact.
infeasible test objectives have been recognized as a main cost factor of the testing process .
by pruning outasignificantnumberofthemwithlclean testerscouldreinvestthesparedcostintargetingfullcoverageoftheremainingobjectives.
this would make testing more efficient as most faults are found within high levels of coverage .
pruning out infeasible test objectives could also make the most meticulous testing criteria e.g.
mutation testing less expensive and thus more acceptable inindustry .furthermore gettingridofredundantobjectives should provide testers with more accurate quality evaluations of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time to clean your test objectives icse may june gothenburg sweden given three sides x y z of a valid triangle computes its type as scalene isosceles equilateral 3int type l1 x y y z dc l2 x !
y y !
z dc l3 x y cc l4 x !
y cc 6if x y y z type type l5 x y y z x z dc l6 x!
y y!
z x!
z dc l7 x y cc l8 x !
y cc l9 x!
y y z x z mcc l10 x y y!
z x z mcc 12if x y y z x z l11 type !
type wm l12 type !
type wm l13 type !
type wm l14 type !
w m type type figure1 exampleofasmallcprogramwithtestobjectives their test suites and also result in sounder comparisons of test generation techniques .
motivating example figure1showsasmallcprograminspiredbytheclassictriangle example .
given three integers x y zsupposed to be the sides of a valid triangle it sets variable typeaccording to the type of thetriangle equilateral type isosceles type orscalene type .
figure also illustrates fourteen test objectives from common test criteria labelled from l1tol14.l1andl2require the test suite to cover both possible decisions or branches of the conditional at line .
for example covering l2means to find test datasuchthat duringtestexecution thelocationof l2isreached and the condition x!
y y!
z is true at this location whichensurestoexecutetheelsebranch.similarly l5andl6require theteststocoverbothdecisionsatline12.thesefourobjectivesarespecified by the decision coverage dc criterion for this program.
l3andl4 resp.
l7andl8 requiretheteststocoverbothtruthvalues ofthefirstconditioninthecompoundconditiononline6 resp.
line .theyareimposedbyconditioncoverage cc thesimilartest objectivesimposedbyccfortheotherconditionsarenotshown to improve readability.
l9andl10provide examples of objectives frommultipleconditioncoverage mcc forconditionalatline12.
mcc requires the tests to cover all combinations of truth values of conditions.finally objectives l11tol14encodesomeweakmutants wm oftheassignmentonline15 seebardinetal.
for more detail .
we can easily notice that l9andl10put unsatisfiable constraints overx yandz.
they are thus infeasible objectives and trying to coverthemwouldbeawasteoftime.otherobjectivesare duplicates denotedby theyare alwayscovered i.e.reached andsatisfied simultaneously.
we obviously have l3 l7andl4 l8since the valuesofxandydonotchangein between.althoughsyntactically different l13andl14are also duplicates as they are always reached together we call them co reached objectives and satisfied if and only iftype nequal0.
finally we refer to objectives like l11andl12as beingtrivialduplicates theyareco reached andalwayssatisfied as soon as reached.
while we do not have l1 l5 covering l1 necessarily implies covering l5 that is l1subsumes l5 denoted l1 l5.
other examples of subsumed objectives can be found likel6 l2.
duplicate and subsumed objectives are redundant objectives that can skew the measurement of test suite strength as it should be provided by the test coverage ratio.
for example considering the objectives from the dc criterion the test suite composedofthesingletest x y z coversl2andl5but notl1andl6 whichimpliesamediumcoverageratioof50 .the tester may be interested to know the achieved level of coverage without counting duplicate or subsumed objectives.
here l2andl5 are actually subsumed by l1andl6.
if the subsumed objectives are removed thecoverageratiofallsdownto0 .discardingredundant objectives provides a better measurement of how far testers are from building an efficient test suite only with the necessary inputs for covering the non redundant objectives l1andl6in this case .
themainpurposeofthispaperistoprovidealightweightyet powerfultechniqueforpruningoutinfeasible duplicateandsubsumed test objectives.
to do so our approach first focuses on in feasible objectives.
in figure one can notice for instance thatthe problem of proving l9to be infeasible can be reduced to the problem of proving that a code assertion !
x!
y y z x z at line will never be violated.
our approach then delegatesthisproofforeachobjectivetoadedicatedverification tool.whileinfeasibilityshouldbecheckedonceperobjective duplicationandsubsumptionrequireonetoanalyseallthepossiblepairs .
to avoid quadratic complexity we focus on detecting duplicate andsubsumedpairsonly amongtheobjectivesthatbelongtothe same sequential block of code with no possible interruption of the control flow with goto break ... in between.
by construction theobjectivesinthesegroupsarealwaysco reached.infigure1 l1 l10andl11 l14are two examples of such groups.
examples of duplicate and subsumed objectives within these groups include l3 l7 l4 l8 l11 l12 l13 l14 l1 l5andl6 l2.
we call themblock duplicate andblock subsumed objectives.ontheother hand l1andl13are duplicate at line typeis nonzero if and onlyif x y and zareequal butthiswillnotbedetectedbyour approach since those labels are not in the same block.
background .
test objective specification with labels given a program pover a vector vofminput variables taking values in a domain d definesd1 dm atest datum tforpis a valuation of v i.e.t d.atest suite ts dis a finite set of test data.a finite executionof poversome t denoted p t isa finite run defines angbracketleft loc0 s0 ... locn sn angbracketrightwherethe locidenotesuccessive control locationsof p statementsoftheprogramminglanguage inwhich piswritten loc0referstotheinitialprogramstateand thesidenotethesuccessiveinternalstatesof p valuationofall globalandlocal variablesandofallmemory allocatedstructures after the execution of each loci.
a testdatum treachesa location locat stepkwith internal state s denoted t leadstok p loc s i fp t has the form loc s where is a partial run of length k. when focusing on reachability we omitkand write t leadstop loc s .
givenatestobjective c wewrite t leadstopciftestdatum tcoversc.
weextendthenotationforatestsuite tsandasetoftestobjectives c writing ts leadstopcwhenforany c c thereexists t tssuch thatt leadstopc.a source codebased coveragecriterion cisdefinedas asystematicwayofderivingasetoftestobjectives c definesc p for anyprogramundertest p.atestsuite tssatisfies orachieves a coverage criterion ciftscovers c p .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. marcozzi s. bardin n. kosmatov m. papadakis et al.
labels.labelshave been introduced in as a code annotation languagetoencodeconcretetestobjectives.severalcommoncoveragecriteriacanbesimulatedbylabelcoverage inthesensethatfor a given program pand a criterion c every concrete test objective from c definesc p can always be encoded using a corresponding label.
given a program p alabel lscript labspis a pair loc whereloc isalocationofpand isapredicateovertheinternalstateat loc.
there can be several labels defined at asingle location which can possiblysharethesamepredicate.moreconcretely thenotionof labels can be compared to labels in the c language decorated with a pure i.e.
side effect free boolean c expression.
wesaythatatestdatum tcoversalabel lscript defines loc inp denoted tl leadstop lscript if there is a state ssuch that treaches loc s i.e.t leadstop loc s andssatisfies .a nannotated program is a pair angbracketleftp l angbracketright wherepis a program and l labspis a set of labels for p. given an annotated program angbracketleftp l angbracketright we say that a test suite tssatisfies thelabelcoveragecriterion lc for angbracketleftp l angbracketright denoted tsl leadsto angbracketleftp l angbracketrightlc iftscovers every label of l i.e.
lscript l t ts tl leadstop lscript .
criterionencoding.
labelcoverage simulatesacoveragecriterion cif any program pcan beautomatically annotated with a set of corresponding labelslin such a way that any test suite tssatisfies lcfor angbracketleftp l angbracketrightifandonlyif tscoversalltheconcretetestobjectives instantiated from cforp.
the main benefit of labels is to unify the treatment of test requirements belonging to different classes ofcoveragecriteriainatransparentway thankstothe automatic insertionof labels in the program under test.
indeed it is shown in thatlabelcoveragecannotablysimulatebasic blockcoverage bbc branch coverage bc decision coverage dc function coverage fc condition coverage cc decision condition coverage dcc multiple condition coverage mcc as well as the side effect free fragment of weak mutations wm .
the encoding ofgacccomes from .
some examples are given in figure .
co reached labels.
we say that location locisalways preceded bylocationloc primeif for any test datum t whenever the execution p t defines angbracketleft loc0 s0 ... locn sn angbracketrightpasses through location locat stepk i.e.loc lock thenp t also passes through loc primeat some earlier step k prime k i.e.loc prime lock prime without passing through locor loc primein between i.e.
at some intermediate step iwithk prime i k .
similarly loc primeis said to be always followed by locationlocif for anyt whenevertheexecution p t passesthrough loc primeatstepk prime thenp t also passes through locat some later step k k primewithout passingthrough locorloc primein between.twolocationsare co reached if one of them is always preceded by the other while the second oneisalwaysfollowedbythefirstone.notethatweexcludethe case when one of locations is traversed several times e.g.
due to a loop beforebeingfinallyfollowedbytheotherone.inasequential block of code with no possible interruption of the control flow inbetween nogoto break ... alllocationsareco reached.wefinally say that two labels are co reached if their locations are co reached.
.
polluting labels intheremainderofthepaper testobjectiveswilloftenbeexpressed in terms of labels.
this work addresses three kinds of polluting labels infeasible duplicateandsubsumed.alabel lscriptinpiscalled infeasible if there is no test datum tsuch that tl leadstop lscript.
in other words itisnotpossibletoreachitslocationandsatisfyitspredicate.wesaythatalabel lscriptsubsumes anotherlabel lscript prime or lscript primeissubsumed by lscript inp denoted lscript lscript prime ifforanytestdatum t iftl leadstop lscriptthen tl leadstop lscript primeas well.
finally two labels lscriptand lscript primeare called duplicate1 denoted lscript lscript prime if each of them subsumes the other one.
for the specificcasewherebothlabels lscriptand lscript primebelongtothesamegroup ofco reachedlabelsinablock wecalladuplicate resp.
subsumed labelblock duplicate resp.
block subsumed .
noticethatifalabel lscriptisinfeasible itsubsumesbydefinitionany other label lscript prime.
we call this phenomenon degenerate subsumption.i f lscript primeisfeasible itshouldbekeptandcovered.inthiscase thetruly polluting objective is lscriptrather than lscript prime.
that is the reason why it is necessary to eliminate as many infeasible labels as possible before pruning out subsumed labels.
.
the frama c ltest platform frama c isanopen sourceindustrial strengthframeworkdedicatedtotheformalanalysisofcprograms.ithasbeensuccessfully used in several safety and security critical contexts.
the tool is writteninocaml andrepresentsaverysignificantdevelopment around 150k lines for the kernel and the main plug ins alone .
frama c is based on a small kernel that takes care of providing anabstractrepresentationoftheprogramunderanalysisandmain tainingthesetofpropertiesthatareknownabouttheprogramstate ateachpossibleexecutionstep.thesepropertiesareexpressedas acsl annotations.
on top of the kernel many plug ins can perform various kinds of analysis and can interact with the kernel eitherby indicatingthata property holds or byaskingwhether someotherproperty istrue inthehopethatanotherplug inwill be able to validate later on .
in the context of this paper we are mainly interested in the four following open source plug ins.
lannotate luncovandlreplayare part of frama c ltest .
lannotate annotates the program with labels according to the selected criterion.
luncov combines weakest precondition and value analysis to detect infeasible test objectives.
lreplay executes a test suite and computes its coverageratio.
wpisaplug inimplementingweakest precondition calculus in order to prove that an acsl assertion holds.
the lclean approach thelcleantechniqueinvolvesthreemainsteps cf.figure2 preceded by a preprocessing phase.
the first step aims at detecting infeasible label encoded objectives.
the second step targets trivial block duplicate labels while the third step focuses more generally on block subsumed and block duplicate labels.
given a program pand a coverage criterion cthat can be simulated by labels the preprocessing consists in generating the correspondinglabels l.forcprograms thisisdonebythelannotate plug in of frama c. the lclean approach itself operates on the annotatedprogram angbracketleftp l angbracketrightandmarkspollutinglabelssothatthey can be pruned out.
.
step infeasible labels lclean systematicallyexplores angbracketleftp l angbracketrightand replacesevery label lscript defines loc byanassertion assert !
whosepredicateisthenegation of the label condition.
the resulting assertion laden code is 1the term equivalent label is not used here to avoid any confusion with the notion of equivalent mutant which in mutation testing means infeasible objective.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time to clean your test objectives icse may june gothenburg sweden figure process view of the lclean approach with main steps and substeps senttoadeductiveverificationtooldesignedforprovingthatthe received program is correct w.r.t.
the defined assertions i.e.
that none of them can be violated during a possible run of the program.
in practice the verification tool returns the list of the assertions thatitwasabletoprovecorrect.sinceeachassertionisbyconstruction the negation of a label condition the corresponding labels are formallyproventobeinfeasible andaremarkedasso.thesemarks willbebothusedasafinalresultoftheapproachandasinternal informationtransmittedtothenexttwostepsoflclean.regarding figure lclean indeed detects that l9andl10are infeasible.
.
detection of co reached labels 1void calledonce l1 1 code1 5int main int i l2 2 7if i l3 3 if i i l4 4 calledonce if i exit l5 5 i l6 6 else l7 7 code2 20return i figure coreached locationspriortosteps2and3 lcleanperforms the detection of blocks of co reached locations.weillustrateitusingthesample program of figure .
first a basic syntactic analysis detects six blocks in the program the global block of each of the two functions the two branches oftheouterconditional line7 andthe then branches of the two nested conditionals.
second a call graph analysis discovers that the first function is only called once in the whole program so that its outer block can be seen as executed as a part of the block containing the function call.
the two blocks can thenbemerged.finally aconservative control flow interruption analysis detects that the exit statement at line may interrupt the control flow withinthethenbranchoftheouterconditional.thecorrespondingblockisthussplitintotwoblocks gatheringrespectivelythe statements before and after the exit statement.
the identified blocks enabling us to conclude that there are four groups of mutually co reached labels l2 l3 l4 l1 l5 l6 and l7 .
.
step trivial block duplicate labels as in step lclean systematically explores angbracketleftp l angbracketrightand replaces labelsbyassertions.exceptforthelabelsmarkedasinfeasibleinstep which are simply dropped out each label lscript defines loc is replaced byanassertion assert .thistime thepredicateisdirectlythe labelcondition.theresultingassertion ladencodeissenttotheverification tool.
the proven assertions correspond to labels that will be always satisfied as soon as their location is reached.
afterwards lcleanidentifiesamongthesealways satisfied when reachedthe groups of co reached labels cf.
section .
.
the labels within each ofthegroupsaretrivialblock duplicates andtheyaremarkedasbeingclonesofasinglelabelchosenamongthem.again thesemarkswill be both final results and internal information transmitted to thenextstep.fortheexampleoffigure1 lcleanwillidentifythat l11andl12aretrivial block duplicate labels.similarly ifwe assume that all predicates iare always satisified for the code of figure step2detectsthat l3 l4andl1aretrivialduplicates and l5andl6 areaswell.asasubtleoptimization lcleancandetectthatlabel l2is always executedsimultaneouslywith the outer conditional so thatl2will be covered if and only if at least one of the labels l3and l6is covered.
l2can thus be seen as duplicate with the pair l3 l6 and is marked as so.
.
step block subsumed labels within each group of co reached labels the labels previously detected as infeasible by step are removed and those detected astrivial block duplicates by step are merged into a single label.
afterwards every label lscripti loci i remaining in the group is replaced by a new statement int vli i which assigns thevalueofthelabelconditiontoafreshvariable vli.then for each pair lscripti lscriptj i nequaljof co reached labels in the group the assertion assert vl i vlj isinsertedattheendofthecorresponding block of co reached locations.
if this assertion is proven by theverificationtool thenlabel lscriptisubsumeslabel lscriptj.indeed their locationsareco reached andtheprovenassertionshowsthatevery input satisfying iwill also satisfy j. as a consequence every input that covers lscriptialso covers lscriptj.
the graph of subsumption relations detected in a group of coreachedlabelsisthensearchedforcycles.alllabelsinacycleare actuallyduplicatesandcanbemarkedasmergeableintoasingle label.amongthelabelsthatsurvivesuchamergingphase those thatarepointedtobyatleastonesubsumptionrelationaremarkedassubsumedlabels.fortheexampleoffigure1 lcleanwillidentify for instance l1 l5 l6 l2 l3 l7andl13 l14.
.
discussion of lclean design once the third and final step finished lclean returns a list of polluting labels composed of the infeasible ones returned by step and of the duplicate and subsumed ones returned by steps and3.
it should be noted that the approach is incremental and thateach of the three main steps can even be run independently of the others.
however removing infeasible objectives before steps and3 isimportant asitreduces therisk ofreturning degeneratesubsumption relations.
similarly step detects duplicate labels that would be identified by step anyway but step finds them atmuchlowercost.indeed thenumberofproofsrequiredbystep2is linear in the number of labels as it does not have to consider pairs oflabels.theincrementalnatureoftheapproach coupledwiththe fact that assertion proving has become reasonably fast c.f.
section andthatitcanbeparallelised aswellasperformedindependently over stand alone code units e.g.
c functions makes a continuous computationofpollutingobjectivesconceivableduringsoftware authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. marcozzi s. bardin n. kosmatov m. papadakis et al.
criterion labels block pairs function pairs program pairs cc mcc gacc wm total222 figure number of pairs of labels in c programs development.
this could be used for continuous integration to enforce test suites of specific coverage levels.
thelcleanapproachmightbeextendedtodetectduplicateor subsumedlabelsthatarenotinthesamebasicblock bygenerating more complex assertions that would be flow sensitive.
however limiting the analysis to block duplicate and block subsumed labels turns out to be a sweet spot between detection power and computation time.
indeed figure details the total number of pairsof labels for four common criteria in the c programs used in the evaluation in section cf.
figure .
figure also presents the totalnumber ofpairsof labelstakeninsidethe sameblock inside the same function or over the whole program.
we can see that focusing the analysis on block pairs enables reducing the number of necessary proofs by one to four orders of magnitude.
at the sametime itseemsreasonabletothinkthatasignificantpartofthe duplicate or subsumed labels reside within the same basic block as those labels are always executed together and typically describe test objectives related to closely interconnected syntactic elements of the program.
implementation thethreestepsofthelcleanapproachareimplementedin three independent open source frama c plug ins2 locs in ocaml .
theseplug insshareacommonarchitecturedepictedinfigure5.
itreliesontheframa ckernel inblack andfeaturesfourmodules in color performing the different substeps of an lclean step.
it receives as input an annotated program angbracketleftp l angbracketright in which labels havealreadybeengeneratedwithplug inlannotate inor der tosimulatethecoveragecriterionofinterest.asastartingpoint the program is parsed by the frama c kernel which makes its abstractsyntaxtree ast availableforallthecomponentsofthe architecture.
we now present the four modules performing the analysis.
assertiongenerator.
theassertiongeneratorreplacesthelabels inthecodebyassertionsaccordingtothecorrespondingstep cf.
section .
frama c primitives are used to explore the ast locate thenodescorrespondingtolabelsandreplacethembytherequired assertions written in acsl.
2available from figure frama c plug in implementing one lclean steprobustmulticoreassertionprover.
theassertionproverdeals withprovingtheassertionsintroducedintheastbytheassertion generator and relies on the wp plug in.
it is not a simple wrapperforwp theassertionproverintroduces crucialoptimizations ensuring its scalability and robustness first it embeds a version of wp that we carefully optimized for our specific needs making it capable to prove severaldifferent assertions independently in a single run of the tool.
this version factors out a common part of the analysis related to the program semantics that would have to be repeated uselessly if wp was called once per assertion.
second its multi core implementation ensures a significant speedup.
the assertions to be proved are shared among several parallel wp instances running on different cores.
third the assertionproveralsoguarantees robustnessand adaptabilityoftheprocess.indeed thewptoolcanconsume a high amount of memory and computation time when analyzingalargeandcomplexcfunction.theassertionprover can smoothly interrupt a wp session when a threshold w.r.t.
the used memory or elapsed time has been reached.
alltheseimprovements toframa c wphavebeenprovencrucial for large scale experiments cf.
section .
a technical descriptionofhowtheywereactuallyimplemented comparingtheoptimised and non optimised source code of the tool can be found on the companion website2of this paper.
label statusmanager.
thelabel statusmanager maintainsand givesaccesstoasetoffilesstoringastatusforeachlabel.eachlabelisidentifiedbyauniqueintegeridusedbothintheastandinthe status files.
the status of a label can be a infeasible b duplicateto another id or a pair of ids c subsumed by other ids or d unknown.thestatusfilesareupdatedbytheplug inswhenthey detect that some labels can be marked as polluting.
the plug ins for steps and also check the files in order to drop out the labels marked as polluting during the previous steps.
blockdetector.
thedetectorofblocksofco reachedlabelsisonly used before steps and .
it relies on the frama c primitives to exploretheastandperformtheanalysesdetailedinsection4.
.
foreachblockfound itreturnsthelabelidsofco reachedlabels belonging to the block.
experimental evaluation toevaluateexperimentallylclean weconsiderthefollowingthree research questions researchquestion1 rq1 istheapproacheffectiveanduseful?especially a doesitidentifyasignificantnumberofobjectives from common criteria all being real polluting objectives?
b can it scaletoreal worldapplications involvingmanylinesofcodeand complex language constructs?
research question rq2 do the optimizations section improve the time performance in a significant way impacting lclean acceptability in practice?
researchquestion3 rq3 howdoesourapproachcompare with the closest approaches like luncov mutant classification and tce especially in terms of pruning power and time performance?
theexperimentalartefactsusedtoanswerthesequestionsand the fully detailed results that we obtained are available on the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time to clean your test objectives icse may june gothenburg sweden companion website2of the paper.
the tool and artefacts have also been installed in a linux virtual machine provided on the website and enabling an easy reproduction of the experiments described in thenext subsections.
allthese experiments were performedon a debian linux workstation equipped with two intel xeon e52660v3 processors for a total of cores running at .6ghz and taking advantage of 25mb cache per processor and 264gb ram.
.
rq1 effectiveness and scalability weconsiderfourteencprogramsofvarioustypesandsizes min 153locs mean 166locs max 888locs extractedfromfive projects thesevensiemensprogramsfrom fourlibrariestaken from the cryptographic openssl toolkit the full gnu zip compression program the complete sjeng chess playing ia application and the entire sqlite relational database managementsystem .everyprogramisannotatedsuccessivelywiththe labels encoding the test objectives of four common coverage criteria conditioncoverage cc multiple conditioncoverage mcc generalactiveclausecoverage gacc andweakmutations wm with sufficient mutation operators .
the lclean tool is then run to detect polluting objectives for each program criterion pair.
for each step of the lclean process the number of marked objectives and the computation time are reported in figure .
of the labels were marked as polluting in total min for cc mcc with sqlite max for wm in siemens printokens.c .
theglobalratioofmarkedpollutingobjectivesis5 forcc for mcc for gacc and for wm.
in total of the detected polluting objectives were infeasible were duplicate about one halfweremarkedduringstep2andtheotherduringstep3 and41 weresubsumed.thecomputationtimerangesfrom10sformccin siemens schedule.c locs and objectives to 69h for wm in sqlite 197k locs and 90k objectives .
globally computation time is split into for step for step and for step .
while the computation time is acceptable for a very large majority of theexperiments step 3becomesparticularlycostlywhen applied on thelargest programswith themost meticulous criteria.this is ofcourseduetothefactthatthisstepisquadraticinthenumber of labels.
while we limit our analysis to block pairs the number ofresultingproofattemptsstillgetslargeforbiggerapplications reaching1.8mproofsforsqliteandwm whichremainstractable .
yet limiting lclean to steps still marked many labels and is muchmoretractable onsqlite itdetects4566pollutingobjectives in only 9h objectives in 69h for full lclean .
moreover this shouldbecomparedtothefactthatrunningthesqliteth3test suite3andcomputingthemutationscoretakesmanydaysandthat identifyingpollutingobjectivesisatime consumingmanualtask authors of report minutes per instance .
as the sqllite developers report3that they work hard to obtain test suites with a coverage score for different criteria they should immediately benefit from our tool.
conclusion theseresultsindicatethatlcleanisausefulapproach able to detect that a significant proportion of the test objectives from variouscommoncriteriaarepollutingones evenforlargeandcomplexreal wordapplications.
inpractice forverylarge programsand demandingcriteria lcleancanbelimitedtosteps1 keepinga significant detection power at a much lower expense.
rq2 impact of optimizations werepeattheexperimentsperformedin rq1forthewmcriterion over the seven siemens programs but we deactivate the optimizations that we implemented in the assertion prover of our tool namelytailoredwptoolandmulti coreimplementation section .
figure details the obtained computation times in logarithmic scale forthethreestepsofthelcleanprocess consideringthree levelsofoptimizations.atlevel0 oblique linedblue theassertion prover uses a single instance of the classical frama c wp running on a single core.
at level horizontal lined red the assertion prover uses instances of the classical version wp running on20 cores.
level plain beige corresponds to the actual version ofthetoolusedin rq1 whenalltheoptimizationsareactivated the assertion prover uses instances of our tailored version wp running on cores.
weobservethatthetotalcomputationtimeisreducedbya factor of .4when switching from level to level and that it is reduced byafactorof45 whenswitchingfromlevel0tolevel2.thesefactors areverysimilarforallthestepsofthelcleanprocess.theanalysis results remained unchanged across the optimization levels.
conclusion these results show that our optimizations have a very significant impact over the time performance of our tool makingthe experiments on large programs intractable without them.
the measuredspeedupof45xhasasensibleinfluenceovertheperceived speedoftheto ol improving its acceptability in practice.
.
rq3 lclean vs. closest related works .
.
luncov.
we apply both luncov and lclean on the same benchmarks .
the measured computation time and detection power for luncov and lclean are compared in figure .
as luncov is limited to infeasibility we also provide results for step oflclean.itappearsthatlcleandetects4.
morepollutinglabels than luncov in .
less time.
when lclean is limited to step it detects .
less polluting labels than luncov but in less time.
conclusion lcleanprovidesamoreextensivedetectionofpolluting objectivesthanluncov especiallyasitgoesbeyondinfeasibility at cheaper cost thanks to modularity and optimized implementation.
.
.
mutant classification.
thecoreprincipleofmutantclassification is to rely on dynamic coverage data to identify in anapproximatedway pollutingmutants.asacomparisonbetweenlcleanandsuchadynamicpruningprinciple figure9revealsthat the time necessary torun a high coverage test suite siemens test suite savecoverage dataandfindlikely pollutingobjectivescan be one order of magnitude higher than running lclean over the sametestobjectives.inthesametime itappearedthatmanyoftheobjectivesdetectedinthiswaywerefalsepositives leadingtoa89 rateoflabelstobeconsideredaslikelypolluting mainlybecause ofduplicationandsubsumption .actually whilethesiemenstest suiteachieveshighcoverageofstandardmetrics itisnotbuiltto reveal different coverage behaviours between feasible test objectives.
crafting new test cases to do so would reduce the number of false positives but even more penalize the computation time.
conclusion by relying on lightweight static analyses lclean provides a sound and quick detection of a significant number of both infeasibleandredundanttestobjectives whiledynamicdetectionis expensiveandunsound yieldingmanyfalsepositivesevenbasedon high quality test suites.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. marcozzi s. bardin n. kosmatov m. papadakis et al.
benchmark labelsstep step step total criterion marked astimemarked astimemarked as marked astimemarked as pollutingtimeinfeasible duplicate duplicate subsumed ratio siemens 35s 38s 83s 156s cc agg.
programs 36s 40s 78s 154s mcc locs 37s 39s 77s 153s gacc 114s 126s 723s 963s wm openssl 67s 67s 391s 525s cc agg.
programs 77s 83s 294s 454s mcc locs 70s 81s 324s 475s gacc 356s 372s 4214s 5122s wm gzip 149s 152s 578s 879s cc locs 170s 171s 628s 969s mcc1670 154s 156s 555s 865s gacc 1038s 1210s 10029s 12277s wm sjeng 351s 354s 798s 1503s cc locs 417s 436s 1912s 2765s mcc4090 349s 353s 751s 1453s gacc 5950s 4791s 19586s 31478s wm sqlite 1907s 1416s 4646s cc locs 2295s 1902s 11958s mcc 2065s 1613s 4773s gacc 18104s 13571s 216140s 247815s wm total 2509s 2027s 6496s 3h3m52 cc locs 2995s 2632s 14870s 5h41m37 mcc 2675s 2242s 6480s 3h9m57 gacc 25562s 20070s 250692s 82h18m44 wm 9h22m21 7h29m31 77h22m18 94h14m10 total figure pruning power and computation time of lclean over various real world c programs step step step total101103105computation time s in log.
scale1 core classic wp cores classic wp cores tailored wp figure tool optimization impact siemens wm criterionluncov lclean step lclean all steps marked time marked time marked time cc 97s 12s 46s mcc 125s 15s 53s wm 801s 75s 463s total9 17m3s 1m42s 9m22s .
.
.
figure luncov vs lclean benchmarks from .
.
trivial compiler equivalence tce .
a direct comparison with tce is not possible as tce aims at identifying strong mutantequivalences whicharefundamentallydifferentfromthe structuraloneswe handle.killingstrongmutantsrequiresindeed the propagation of the mutated program states to the program outputs which is more complex to formalize .
thus the only way to compare the two approaches is to assume that weakly polluting mutantsarealsostronglypollutingones.thisassumptionistrue for the case of equivalent mutants but not entirely true for the caseoftheduplicatedmutants.weaklyduplicatesmutantsmight not be strongly duplicates due to failed mutated state propagation.
however this is usually quite rare as most weakly killed mutants propagate to the program outputs .
nevertheless we reporttheseresultsfordemonstratingthecapabilitiesoftheapproaches and not for suggesting a way to detect redundant strong mutants.
to perform the comparison we generated some strong mutants as well as our corresponding weak ones for the replace program.
we selected only the replace program as our purpose here is to demonstratetherelativedifferencesoftheapproaches replaceis one of the largest program from the siemens suite for which tce performsbestwithrespecttoequivalentmutantdetection .our results show that among the mutants involved our approach detected as infeasible while tce detected .
among these are shared which means that of the infeasible mutants were only found by our approach and only by tce.
regarding duplicated mutants our approach detected duplicates and tce detected .
were shared which means that both techniques together identify duplicated mutants.
conclusion overall the results show that our approach outperforms tce in terms of detection power and form a relatively good complementofit.moreover lcleanisabletodetectsubsumption.yet tce is much more efficient relying on compiler optimizations.
discussion .
threats to validity common to all studies relying on empirical data this one may beoflimitedgeneralizability.todiminishthisthreatweused in additiontothesiemensbenchmarkprograms fourlargereal world applications composed of more than kloc in total like sqlite and showed that our approach is capable of dealing with many types of polluting objectives which no other approach can handle.
ourresultsmightalsohavebeenaffectedbythechoiceofthe chosentestcriteriaandinparticularthespecificmutationoperators we employ.
to reduce this threat we used popular test criteria cc mcc gacc and wm included in software testing standards andemployedcommonlyusedmutationoperatorsincluded in recent work .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time to clean your test objectives icse may june gothenburg sweden criteriondynamic detection lclean possibly possibly possibly total ratio fortimemarked as marked as marked as total ratio fortimeinfeasible duplicate subsumed possibly polluting infeasible duplicate subsumed marked as polluting cc 3132s 156s mcc 3142s 154s gacc 3134s 153s wm 8399s 963s total 4h56m4758 23m46s figure dynamic detection of likely polluting objectives vs. lclean siemens thevalidityofourexperimentalresultshavebeencrosschecked in several ways.
first we compared our results on the siemens benchmarkwiththoseofothertools namelyluncovandtce.we knewbydesignthatinfeasibleobjectivesdetectedbylcleanshould bedetectedbyluncovaswell andwecheckedmanuallythestatusof each duplicate objective reported by lclean and not by tce.
noissuewasreported.second weusedtheexistingtestssuitesforthesiemensprogramsasaredundantsanitycheck byverifyingthatev ery objective reported as infeasible resp.
duplicated subsumed by lcleanwasindeedseenasinfeasible resp.duplicated subsumed whenrunningthetestsuite.thesetestsuitesareextremelythorough andare thuslikely todetect errorsin lclean.third forlargerprograms wepickedarandomselectionofahundredtestobjectivesreportedasinfeasible duplicatedorsubsumedbylclean andmanuallycheckedthem thiswasoftenstraightforwarddue to the local reasoning of lclean.
all these sanity checks succeeded.
anotherclassofthreatsmayarisebecauseofthetoolsthatwe used asitislikelythatframa corourimplementationaredefective.
however frama c is a mature tool with industrial applications in highlydemandingfields e.g.
aeronautics andthus itisunlikely tocauseimportantproblems.moreover oursanitycheckswould have likely spotted such issues.
finally otherthreatsmaybeduetothepollutingnatureofthe objectives that we target.
however infeasible objectives are a wellknownissue usuallyacknowledgedintheliteratureasoneofthe mosttimeconsumingtasksofthesoftwaretestingprocess and redundant objectives have been stated as a major problem in both past and recent literature .
.
limitations labels cannot address all white box criteria.
for example dataflow criteria or full mcdc require additional expressive power .
currently parts of the infeasibility results from lclean could be lifted to these classes of objectives.
on the other hand it is unclear how it could be done for redundancy.
extending the present work to these criteria is an interesting future work direction.
from a more technical point of view the detection of subsumptionislimitedmoreorlesstobasicblocks.whileitalreadyenables catching many cases it might be possible to slightly extend the searchwhile retainingscalability.inthe samevein theproofs are performedinlcleanona perfunctionbasis.thisisaproblemas it is often the case that a given function is always called within thesamecontext reducingitspossiblebehaviors.allowingalimited degree of contextual analysis e.g.
inlining function callers and or callees should allow to detect more polluting objectives while retaining scalability.
finally as we arefacing an undecidable problem our approach issound butnotcomplete smtsolversmightanswer unknown.in that case we may miss polluting objectives.
related work .
infeasible structural objectives early research studies set the basis for identifying infeasible test objectives using constraint based techniques .
offutt and pan suggestedtransformingtheprogramsundertestasaset of constraints that encode the test objectives.
then by solving theseconstraints itispossibletoidentifyinfeasibleobjectives con straintswithnosolution andtestinputs.otherattemptsusemodel checking to prove that specific structural test objectives givenasproperties areinfeasible.unfortunately constraint based techniques as they require a complete program analysis have the usual problems of the large possibly infinite numbers of involved paths imprecise handling of program aliases and the handling of non linear constraints .
model checking faces precision problems because of the system modelling and scalability issues due tothelargestatespaceinvolved.ontheotherhand werelyona modular hence not too expensive form of weakest precondition calculus to ensure scalability.
perhaps the closest works to ours are the ones by beckman et al.
baluda etal.
andbardin etal.
thatrelyonweakest precondition.
beckman et al.proves infeasible program statements baludaetal.infeasibleprogrambranchesandbardin etal.infeasible structural test objectives.
apart from the side differences beck manet al.targets formal verification baluda et al.applies model refinementincombinationtoweakestpreconditionandbardin et al.combines weakest precondition with abstract interpretation with these works our main objective here is to identify all types of polluting test objectives not only infeasible ones for real worldprograms in a generic way i.e.
for most of the test criteria in cluding advanced ones such as multiple condition coverage and weak mutation.
another concern regards the scalability of the previousmethods whichremainsunknownunderthecombinatorial explosion of test objectives that mutation criteria introduce.
othertechniquesattempttocombineinfeasibletestobjectives detectiontechniquesasameanstospeed uptestgenerationand refine the coverage metric.
su et al.
combines symbolic execution with model checking to generate data flow test inputs.
baluda et al.
combines backward using weakest precondition and forward symbolic analysis to support branch testing and bardin et al.
combinesweakestpreconditionwithdynamicsymbolicexecution to support the coverage of structural test objectives.
although integrating such approaches with ours may result in additional benefits ourmainobjectivehereistodemonstratethatlightweightsymbolicanalysistechniques suchasweakestprecondition canbeusedtoeffectivelytacklethegeneralproblemofpollutingobjectives for almost all structural test criteria in real world settings.
anotherlineofresearchattemptsdiminishingtheundesirable effects of infeasible paths in order to speed up test generation.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden m. marcozzi s. bardin n. kosmatov m. papadakis et al.
woodward etal.
suggested usingsomestatic rulescalledallegationstoidentifyinfeasiblepaths.papadakisandmalevris and lapierreetal.
usedaheuristicbasedonthek shortestpaths in order to select likely feasible paths.
ngo and tan proposed someexecutiontracepatterns thatwitnesslikelyinfeasiblepaths.
delahaye et al.
showed that infeasibility is caused by the same reason for many paths and thus devised a technique that given an infeasiblepathcanidentifyother potentiallyunexploredpaths.all thesemethodsindirectlysupporttestgenerationandcontraryto ours do not detect polluting test objectives.
.
equivalent mutants automaticallydeterminingmutantequivalenceisaninstanceofthe infeasibility problem and is undecidable .
there are numerous propositionsonhowtohandlethis problem ho wevermost ofthem have only been evaluated on example programs and thus their applicability and effectiveness remains unexplored .
due to space constraints we discuss the most recent and relevant approaches.
detailsregardingtheolderstudiescanbefoundintherecentpaper by kintis et al.
which extensively covers the topic.
one of the most recent methods is the trivial compiler optimization tce .
the method assumes that equivalent mutantinstancescanbeidentifiedbycomparingtheobjectcode of the mutants.
the approach works well it can identify of the equivalent mutants as the compiler optimisations turn mutant equivalenciesintothesameobjectcode.incontrastourapproach usesstate of the artverificationtechnologies insteadofcompilers and targets all types of polluting objectives.
alternative to static heuristics are the dynamic ones.
grun et al.
and schuler et al.
suggested measuring the impact of mutants on the program execution and program invariants in order to identify likely killable mutants.
schuler and zeller investigate alargenumberofcandidateimpactmeasuresandfoundthatcoveragewasthemostappropriate.alongthesamelineskintis etal.
foundthathigherordermutantsprovidemoreaccuratepredictions thancoverage.overall theseapproachesareunsound theyprovidemanyfalsepositives andtheydependontheunderlyingtestsuites.
in contrast our approach is sound and static.
.
duplicate and subsumed test objectives the problems caused by subsumed objectives have been identified a long time ago.
chusho introduced essential branches or non dominated branches as a way to prevent the inflation of the branch coverage score causedby redundant branches.
he also introduced a technique devising graph dominator analysis in order to identify the essential branches.
bertolino and marr also usedgraph dominatoranalysis toreduce thenumber oftest cases needed to cover test objectives and to help estimate the remaining testingcost.althoughtheseapproachesidentifytheharmfuleffects of redundant objectives they rely on graph analysis which results in a large number of false positives.
additionally they cannot deal with infeasible objectives.
in the context of mutation testing kintis et al.
identified the problem and showed that mutant cost reduction techniquesperform well when using all mutants but not when using nonredundantones.amman etal.
introducedminimalmutantsanddynamic mutant subsumption and showed that mutation testing tools generate a large number of subsumed mutants.
althoughmutantredundancieswereknownfromtheearlydays ofmutationtesting theirharmfuleffectswereonlyrecently realised.
papadakis et al.
performed a large scale study and demonstrated that subsumed mutants inflate the mutation score measurement.
overall papadakis et al.
showed that arbitrary experiments can result in different conclusions when they account forthecofoundingeffectsofsubsumedmutants.similarly kurtz et al.
compared selective mutation testing strategies and found that they perform poorly when the mutation score is free of redundant mutants.
overall most of the studies identify the problem but fail to deal with it.
one attempt to reduce mutant redundancies uses tce to removeduplicate mutants.
other attemptsare due to kurtz etal.
whodeviseddifferentialsymbolicexecutiontoidentify subsumedmutants.gong etal.
useddominatoranalysis inthe contextofweakmutation inordertoreducethenumberofmutants.
unfortunately bothstudieshavelimitedscopeastheyhavebeen evaluated only on example programs and their applicability andscalability remain unknown.
conversely tce is applicable andscalable but it only targets specific kinds of subsumed mutants duplicatedones andcannotbeappliedonstructuraltestobjectives.
conclusion softwaretesting istheprimary methodfordetecting softwaredefects.inthatcontext pollutingtestobjectivesarewell knownto beharmfultothetestingprocess potentiallywastingthetester s effortsandmisleadingthemonthequalityoftheirtestsuites.we have presented lclean the only approach to date that handles in a unifiedwaythedetectionof thethreekindsof pollutingobjectives for a large set of common criteria together with a dedicated opensource tool able to prune out such polluting objectives.
lclean reducestheproblemofdetectingpollutingobjectivestotheproblemofprovingassertionsinthetestedcode.thetoolreliesonweakest precondition calculusand smt solving toprove theseassertions.
it is built on top of the industry proof frama c verification platform specificallytuned toour scalabilityneeds.
experimentsshowthat lclean provides a useful sound scalable and adaptable means for helping testers to target high levels of coverage where most faults are detected and to evaluate more accurately the strength of their testsuites aswellasofthetoolspossiblyusedtogeneratethem .
it could immediately benefit to all application developers that aim atspecifictestsuitecoveragelevelsintheircurrenttestingprocess likeforexampleinthewell knownsqlitedatabasemanagement system.apromisingdirectionforfutureworkistheextensionof lcleanto thefewremainingunsupportedclasses oftestobjectives like data flow criteria.