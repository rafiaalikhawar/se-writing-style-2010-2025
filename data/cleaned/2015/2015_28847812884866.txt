vdtest an automated framework to support testing for virtual devices tingting yu dept.
of comp.
sci.
university of kentucky lexington ky usa tyu cs.uky.eduxiao qu abb corporate research raleigh nc usa xiao.qu us.abb.commyra b. cohen dept.
of comp.
sci.
eng.
univ.
of nebraska lincoln lincoln ne usa myra cse.unl.edu abstract the use of virtual devices in place of physical hardware is increasing in activities such as design testing and debugging.yet virtual devices are simply software applications and like all software they are prone to faults.
a full system simulator fss is a class of virtual machine that includes a large setof virtual devices enough to run the full target softwarestack.
defects in an fss virtual device may have cascading effects as the incorrect behavior can be propagated forward to many different platforms as well as to guest programs.
inthis work we present vdtest a novel framework for testing virtual devices within an fss.
vdtest begins by generating a test specification obtained through static analysis.
it then employs a two phase testing approach to test virtual components both individually and in combination.
it lever ages a differential oracle strategy taking advantage of theexistence of a physical or golden device to eliminate the need for manually generating test oracles.
in an empirical study using both open source and commercial fsss we found 64faults more than random testing.
ccs concepts software and its engineering software defect analysis computer systems organization embedded software keywords testing virtual devices device drivers test oracles .
introduction a full system simulator fss is a virtual machine vm or software implementation of the complete environmentthat executes target software on a physical machine .
unlike process vms or hypervisor based systems such as vmware that rely on the host architecture to run thetarget machines an fss encompasses a variety of virtualdevices that can simulate not only the processor cores and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full cita tion on the first page.
copyrights for components of this work owned by others thanacm must be honored.
abstracting with credit is permitted.
to copy otherwise or re publish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c circlecopyrt2016 acm.
isbn .
.
.
.
but also the entire hardware platform including the network buses and peripheral devices e.g.
keyboards usbs video adaptors .
usually different devices can becombined to provide a large number of unique platforms.
fsss are becoming widely used for many purposes in embedded and mobile domains where hardware is diverse andnew platforms are being released at a rapid pace.
fsss areusedfortasksincludingsystemdesign development testing debugging and security analysis.
this relieves the engineer from having to own many different physical devices and allows them to adapt quickly during hardware and softwareevolution.
developers can also interact with the fss to im plement customized tools for their target device such as test casegenerators or theycanuseadditionalfssfeaturessuch as profiling and provisioning.
developing a virtual device can be a challenging task.
the official documentation of hardware devices often contain in accuracies and ambiguities and thus the corresponding software implementation is unlikely to be fault free.
yet defects in an fss can have cascading effects.
one of theearlier versions v4.
of the android emulator did not ro tate screens preventing developers from testing or debugging any application that rotated .
several studies have shown that software faults in virtual devices can cause secu rity vulnerabilities .
for example a critical vulnerabil ity called venom exists in the virtual floppy disk controller fdc codeinthequickemulator qemu fss.
1thefault stems from the fifo buffer that the virtual fdc simulatesto store commands from the cpu.
the fifo fails to resetthe index allowing writes by the fdc to overflow.
this se curity fault can propagate to the programs operating on the host platform .
despite the existence of many automated software testing techniques applying these directly to virtual devices is not straightforward.
first execution environments re quirespecialtestdrivers.
second failuresareoftentriggered by interactions between components.
third failures often do not lead to crashes making oracles difficult to obtain.fourth output states can be masked by input and outputdata points that are shared.
to overcome these challenges we propose an automated framework vdtest that allows engineers to effectively test virtual devices within an fss.
first vdtest provides a test template generator that extracts basic device proper ties with little manual effort and uses these to generate test cases.
second it utilizes a two phase testing approach.
the first phase tests the behavior of individual components e.g.
1qemu has both a hypervisor and fss version.
ieee acm 38th ieee international conference on software engineering registers and data buffers and the second phase integrates components testing for interactions among them.
third to address the oracle problem vdtest employs a physical device or a gold standard virtual device also called the oracle device which leverages differential testing .
finally to avoid masking effects vdtest manipulates only necessary input parameters in a test case leaving inert parameters unchanged.
it uses a feedback driven testing process to identify invalid ineffective parameters thatdo not impact the hardware state e.g.
read only registers and then enforces constraints to omit these parameters in further iterations.
to evaluate vdtest we conducted an empirical study using pairs of devices obtained from one physical machine two open source fsss and one commercial fss.
the resultsshow that vdtest is effective at revealing faults .
more faults were detected than random testing.
when com pared with a traditional combinatorial interaction testingtechnique it reveals more faults given the sametesting budget.
the contributions of this work are vdtest a framework for testing virtual devices in an fss and an empirical study that shows vdtest can find new faults in existing fss virtual devices many of which have been confirmed by developers.
in the next section we present a motivating example and background.
we then describe vdtest in section .
our empirical study follows in sections and followed by dis cussion in section .
we present related work in section and end with conclusions in section .
.
motiv ation and background an fss sits on top of host operating system emulating all of the hardware for each supported device.
it also can run guest operating systems and applications both of which arenormal versions of their respective programs .
figure isa snippet of code extracted from a real virtual device the pl031timer device in the qemu fss.
it contains a bug at line .
the interrupt mask bit s imis incorrectly set.
the interrupt status register s isshould be set instead.
the result is that interrupt alarms are not fired as expected.
thefirstchallengeisthattestingthiscoderequiresspecial test drivers the execution environment must be properly modeled.
for instance i o interface functions i.e.
entryfunctions such as pl031 write on line are invoked by the fss to pass inputs to the virtual device.
and the device transaction functions such as pl031 set alarm line are invoked to perform i o commands that may fire interrupts by calling qemu set irq line .
second the function line containing the faulty statement can not be executed unless certain bits are set in both the data load register rtc lr and interrupt mask rtc mr register.
as such interactions between device components must be considered when testing a virtual device.
third faults often fail to propagate their effects to program outputs e.g.
crash .
in such cases output based testoracles are inadequate.
thus internal oracles are needed that allow engineers to inspect internal device states e.g.
register values for correctness.
such states are referred toasobservable output points .
in figure the results of rtc lrand rtc mrregisters are observable output points.
.
static void pl031 write ... .
.
case rtc mr .
pl031 set alarm s .
case rtc lr .
ticks value pl031 get count s value is register content .
s mr value change rtc mr .
... .
.
static void pl031 set alarm ... .
.
if ticks .
pl031 interrupt s .
... .
.
static void pl031 interrupt ... .
.
pl031state s pl031state state .
s im should be s is .
qemu set irq s irq s is s im .
figure example virtual device code finally the observable output points are often the same as the input points so they can be masked by an input value written to the same point.
the input register components rtc lr and rtc mr are also used to observe device state.
setting the inputs of rtc lrmay affect the output of rtc mr line .
if both registers are set with input values the output effect of rtc mrmay be masked by its input.
these issues motivate our need for a special testing framework for virtual devices.
.
virtual devices figure illustrates a typical i o system with peripheral devices the gray area reflects the devices and their i o memory .
a peripheral device is a device that is connectedto a computer but is not part of the core computer architecture e.g.
cpu motherboard and memory .
it is controlled by reading and writing to its registers either withinthe memory address space memory mapped i o or thei o address space port mapped i o .
for memory mappedi o the device registers are mapped into the cpu s address space.
thus the device is accessed in the same way as a regular memory access.
for port mapped i o i o device reg isters have a separate address space from the cpu addressspace.
thus the device is often accessed through a special class of cpu instructions e.g.
inband outbin x86 .
most devices have at least two types of registers.
the first type is the data register through which the input output data is read from or written to the device.
the second type is a control register which selects and shows the mode of operations of the device.
certain bits in the registers arewrite only or read only.
a device can also have data buffersthat temporarily store the data from the cpu or its periph eral devices.
other devices interact with it for example the uart device use a fifo buffer to transmit and receivedata from the cpu.
in this work we are concerned with virtual peripheral devices hence when we use the term virtual device we are referring to those which are peripheral.
.
device modeling werepresentagenericdevice dasa5 tuple base mmap regs bufs deps where the value within each bracket indicates the typeof the property.
for example baseis the base address of the device of the word cpu peripheral device memory i o port mapped memory i o memory mapped peripheral device peripheral device read data write data figure system with peripheral devices type.
the mmapis abooltype that describes if the device is memory mapped true or port mapped false .
the regs describes the register set in the device which includes varieties of registers.
the type r register is modeled by offset size value d e s c r i b i n gt h e offsetfrom the base address the sizeof the register e.g.
bit and the contentvaluein the register where value 2size.t h e bufs describes the set of buffers in the device.
this property is optional as not all devices have buffers.
the type b buffer is modeled as addr value whereaddris the memory address of the buffer and valueis the content in the buffer.
the registers and buffers are device components that compose the basic structure of the device under test dut .
the last element deps represents other hardware devices whose states can be affected by this device i.e.
dependent devices dd .
for example an interrupt controller can change the state when a dutsets its interrupt bit.
we next model the state of a device which will be later used in the vdtest s algorithm.
a state sof a device dis denoted as sd regs bufs where regs r1 ... ri ... andbufs b1 ... bi ... .
ridenotes the value contained in the ithregister and bispecifies the content in the ithdata buffer.
there are two types of actions that can trigger state transitions readand write commands issued by the cpu.
last we model the behav i o ro fad e v i c ed using a state transition system s d d where d sd s prime dis the state transition function which changes a device state sd regs bufs i n t oan e ws t a t e s prime d regs prime bufs prime driven by the readand or writeactions.
in the case where a duthas dependent devices e.g.
deps negationslash null the transition system is extended to sdut sdd1... sdd i ... dut dd1... dd i ... where dd i deps.
.
test case modeling the behavior of a device is often changed by flagging register bits and or manipulating buffer contents.
thus atest case is defined as tc r ...r i j b0...b k where ri jindicates that the jthbit in the ithregister is flagged andbkindicates contents in the kthbuffer are changed.
test cases for testing hardware device can be classified as beingstateless orstateful.
a stateless test case does not depend on the previous test case the device state depends onlyon new values written by the test case.
on the other hand a stateful test case is a sequence of ordered test cases test sequence where the j thtest case in a sequence depends on the state resulting from the execution of the ithtest case whereihappens before j. for example a test case flagging an interrupt clear bit takes effect only when the interruptenable bit is set by its earlier test case.
in this case tc ti tj forms a stateful test case.
a stateless stateful test case execution is guided by a state transition on the dut.
vdtest models three state transitions .read dut s s prime.
this describes the device state changed from stos primeafter reading the registers of thedut where no test inputs are supplied.
while it might seem counter intuitive a state change can occurby just reading from a register.
such a transition of ten applies to the registers with self clearing bits.
forexample the modem status register msr i nt h e uart device is reset each time when it is read after a write operation.
.write dut tc s s prime.
this describes the device state change from stos primeafter flipping the bits specified in a test case tc i nt h edut.
.writes dut tc1 ...tc l s s prime.
this describes the device state changed from stos primeafter executing a stateful test case test sequence composed of tc1 ...tc lin the dut where li st h el e n g t ho ft h et e s t sequence.
.
test oracle modeling an expected device state can be used as a test oracle .t h e most accurate way to obtain this state is to use a hardware oracleand to compare the output i.e.
state of the dutto the state of its corresponding physical device.
in the case of non existing physical devices an alternative approach isto use a well developed virtual device from another fss to conduct differential testing .
it is also possible thatno readily available oracles exist when a device is newly de signed for example.
vdtest can still work in this context presumably the device specifications can be converted intotest oracles.
in any of the above cases the artifact i.e.
aphysical device a device model from other fsss or a devicespecification that can produce an expected output state is considered a golden device denoted by d oin this paper.
.
vdtest weintroduce vdtest whosearchitectureisshowninfigure .
the dark gray boxes contain the major components astatic analyzer a test case generator a n da n output differ .
vdtest first employs static analysis sa to generate test specifications.
the static analyzer takes as input the devicesource code a pre defined test template skeleton that specifies device properties e.g.
register address offset and a user provided annotation plugin.
next vdtest runs the test generator to translate the test specification into two test driver s o n ef o rt h eo r a c l ed e v i c e s h o w na sp a r to ft h e golden system and the other for the virtual device under test shown as part of the target system .
the test generator uses combinatorial testing to create test cases.
after test cases are generated vdtest executes each test case both on the oracle device i.e.
d o and the dut i.e.
dt using the three types of state transitions described in section .
.
last the output differ detects and shows the differences between the output of each test case from doand thedut.
a difference indicates a possible fault in the dut.
both the static analyzer and test generator modules are configurable so that we can for example use a variant ofcombinatorial test generation or perhaps random test gen eration instead.
we can also completely disable the static 585annotation plugin test generator static analyzer test specification test driver tdg test driver tdt test cases output differ virtual device target system execution engine execution observer cases constraints golden system golden device execution engine execution observer t etest cases output output test template skeleton siuser figure vdtest architecture analyzer and generate test specifications manually in situations when the source code of dutis unavailable.
we describe each component of vdtest in more detail next.
figure left provides a code snippet for the pl050 device from qemu.t h epl050 is a keyboard interface device that directs communications between the cpu and external keyboards.
we will use this example throughout therest of this section.
.
test specification vdtest utilizes a test specification skeleton which specifies a list of device properties needed to generate test driversand test cases.
the specification skeleton is defined only once and generic to all duts so engineers do not need to manually write it for each dut.
a specification skeleton models the basic properties for adut including both mandatory and optional properties.
figure middle is an example that presents an overviewof the test specification.
the device properties are defined as elements e.g.
name .
the value of each mandatory property indicated by and optional property indicated by is initially set to nullby default in the skeleton and can then be instantiated by the static analysis.
the root elementdevicerefers to the dut.
there are three properties defined for this element name base a n d io.t h e nameproperty defines the device s name baseproperty specifies the base address of the dut and the property ioindicates the i o mapping policy.
the elements at the second level refer to the device components i.e.
registers and data buffers .
the children el ements under each component specify the properties of the component.
in this example the offsetand sizeelements undertheregistercomponent andthe address andsizeunderthebuffercomponentaremandatoryproperties whereas the other elements are optional properties.
here specifying inputenables vdtest to limit input space to specific values rather than an entire range of the input domain e.g .
the read only indicates that the register is a readonly register.
the interrupt indicates that writing to the register may affect interrupt status and thereby the state of interrupt should be checked at the output differ component.
the dependspecifies components that may have combinatorial effects with the current component.
the output indicates that reading writing the current component mayaffect other components such that the current component must be tested individually first.
.
.
static analysis the specification skeleton can be instantiated by sa with the mandatory property values and possible optional prop erty values analyzed and specified.
the only manual step is the annotation plugin which specifies a list of device entry points.
the information is provided by users who are sup posed to be domain experts.
this annotation strategy hasbeen widely adopted by existing static analysis techniques for device drivers .
figure right illustrates a sample of annotation plugin for the pl050code snippet.
the sa module first identifies the base address of the dut in the system specific source files which are specified by thefileelement under pluginsconfig.system.
here the base address is found in arm versatilepb.c inqemufor arm versatile platform.
the two properties for the root elementdeviceare instantiated in the same way.
the register entry points are identified by pluginsconfig.entrywrreg andpluginsconfig.entryrdreg annotations indicating register write and read points.
the function specifies the name of the entry function for all registers theaddress indicates the variable used for a register address offset and the valuedefines the actual data written to a register.
the buffer entry points are specified by thepluginsconfig.entrybuf annotations.
the optional buffer property address is often defined by a data structure which is obtained by analyzing disassembling files.
toidentifypropertyvaluesforregistersandbuffers vdtest constructs a system dependency graph starting fromthe entry point of registers and buffers as shown in figure .the offsetvalue for a register can be obtained by its definition.
kmidata is control dependent on offsetand its value is0x008defined in the header file.
the sizeof input can be obtained by examining the size of value i.e.
sizeof uint64 t .
to obtain input values vdtest tracks valuepropagation from the entry point to the constant values assigned.
in figure left the possible input values of kmidata can be traced to the function ps2 write keyboard and to the constants 0x00and 0x05 line and line .
the constants are mapped into the inputelement in the test specification.
if the constant value can not be located the range ofthe input value is n where nis the register bit size.
since kmicris control dependent on kmidata the two components are considered to have combinatorial effects on the device state.
kmimris control dependent on kmicr but is written by a value.
this implies that change of kmicrmay affect the output of kmimr.
.
define kmidata 0x008 .
... .
void pl050 write addr offset uint64 t value ... .
switch offset .
case kmidata .
ps2 write keyboard s dev value .
if kmicr 0x3 .
... .
case kmicr .
kmimr val11 ... .
.
.
void ps2 write keyboard void opaque int val .
switch val .
case 0x00 .
ps2 queue s common kbd reply ack .
break .
case 0x05 .
ps2 queue s common kbd reply resend .
break .
... .
.
.
void ps2 queue void opaque int b .
... .
qemu set irq s irq raise .
device name pl050 keyboard base 0x10006000 io memory mapped register1 offset 0x008 offset size size input input read only false read only interrupt true interrupt depend depend affect affect ... register1 buffer1 address 0x168 address size size buffer1 device pluginsconfig.system name pl050 keyboard file arm versatilepb.c io memory mapped interrupt qemu set irq pluginsconfig.entrywrreg function pl050 write address offset value value pluginsconfig.entryrdreg ... pluginsconfig.entrybuf function ps2 read data address value ps2queue.data figure code snippet from gem5 left test specification middle and sample annotation plugin right ifaregisterisincludedinthereadentryfunction pluginsconfig.entryrdreg but is not included in the write entry function pluginsconfig.entrywrreg it is a read only register.
since read only registers are independent from otherregisters changing them does not affect the device state.thus a test case involving interactions between read only registers and other components can be eliminated.
in thisexample kmidata is writable so its read only property is false.
writing to a device may lead to changing status of interrupts.
to determine whether an entry point is associatedwith the interrupt we track the data and control flow fromthe entry point of a register buffer to the function that canset interrupt status.
in this example writing to registerkmidata causes pl050to raise interrupts line .
as such interrupt status is considered as an observable point whichis included in the oracles.
if optional property values cannot be obtained by static analysis developers can choose to manually add these values.
for example the inputproperty may not be always presentedasconstantsintheprogram soengineerscanmanually select range or specific values as inputs.
.
test driver vdtest converts the test specification into a test driver td .
vdtest considers two classes of test drivers which can be applied to both physical and virtual devices.
thefirst class handles applications running on a machine withoperating systems.
since such systems do not allow user level programs to access hardware or memory the td wasimplemented as a kernel module used to communicate with the device.
specifically vdtest maintains an operation table that maps the elements of the test specification e.g.
elements in figure middle into kernel level system calls.these system calls are used to communicate with hardware e.g.
ioremap inb outb inl outl .
vdtest then parses the test specification and replaces its elements with the cor pl050 write ... offset value kmidata kmicr kmimr 0x008 ps2 write keyboard ... value 0x00 0x05 ... input address ps2 queue qemu set irq interrupt r kmimr midata kmicr micr depend affect figure static analysis respondingsystemcallsbyqueryingtheoperationtable.
forexample the attribute iois replaced with ioremap and request mem region to allocate i o port region.
finally a c file is generated and compiled into the test driver kernel module .
as an example we refer to the test specification in figure middle which generates the following c snippet ... ret ioremap io base io size outl input io base ifls ... thesecondclassoftdhandlesa bare metal machine i.e.
a computer on which an application is running without the operating system .
we distinguish it from the first classbecause executing test cases does not require calling kernelapis.
in this case vdtest converts the read and write operations with respect to specific memory addresses fromthe test specification into a td source file.
.
testing approach vdtests testing approach is guided by the test generatorandoutput differ and works both with test cases and test oracles.
we show its main algorithm in figure .
thealgorithm vdtest takes a dut d t and an oracle device do as its inputs and outputs the faults denoted as f d e tected in the dut.t h echeckresult function is called by theoutput differ component to compare the output states of dtanddo lines .
the algorithm begins by checking the initial state s0ofdtanddoby thereadstate transition 587algorithm vdtest inputs dt do outputs f begin s prime 0t s prime 0o read s 0t s0o f f checkresult s prime 0t s prime 0o st so s0o7 foreach read only register rindt verify ragainstdo endfor foreach non read only register r primeindt unittest r prime t e s ta tu n i t l e v e l endfor integrationtest r test at integration level end function unittest inputs r single registers begin tc computetc r strength tests foreach test tc tc s prime t s prime o write tc tc f f checkresult s prime t s prime o s prime prime t s prime prime o read s prime t s prime o f f checkresult s prime prime t s prime prime o endif endfor whilet 1a n dt n tc t computetc r t foreach test tcintc t s prime t s prime o write tc tc f f checkresult s prime t s prime o endfor endwhile end function integrationtest inputs r begin whilet 1a n dt n tc t computetc r t foreach test tc tc t s prime t s prime o write tc tc f f checkresult s prime t s prime o ifcompare s prime o s prime 0o i sfalse tc prime t tc prime t tc endif endfor endwhile seq testsequence tc prime t tc p1 l whileeach test sequence ts seq s prime prime t s prime prime o writes ts ts f f checkresult s prime prime t s prime prime o endwhile end function checkresult inputs s s prime begin ifcompare s s prime i strue print a fault is detected reset to s0 endif end figure vdtest algorithm lines .
a fault is reported if the initial states of the two devices are different.
next the states of both dtanddoare reset line .
the reset operation is performed throughout the testing process upon the completion of a test execution.
this is important as test cases are not independent.
a testcase can change the state of the hardware so two test casesmay yield different hardware states even if both are identical.
after setting the initial state the algorithm verifies the read only registers specified in the test specification line .to do this for each such register in the oracle device thealgorithm flips all its bits.
if the state remains unchanged the register is truly read only otherwise a fault is reported.
next the algorithm begins with unit level phase testing for each non read only register lines .
it thenproceeds to integration level phase testing for the wholedevice taking inputs as a set of registers that have potential combinatorial effects line .
both phases use a combinatorial testing approach.
.
unit level testing the phase testing tests individual components of dut lines .
the components that are not tested are left intheir original state.
as such this is analogous to unit testing.
since the data buffer does not contain parameters like registers its content is randomly generated at this level.
as fortheregisters each t bitcombinationinaregisterisflippedat least once where tis the strength of testing.
the test cases generated by flipping bits are done by computetc.
this is related to fault injection but applied in a different con text.
the algorithm begins with testing using strength line .
a strength test case for register iis defined as tc i s0 j w h e r e i st h ee x c l u s i v eo ro p e r a t i o n andjis the position of the bit to be flipped while other bits in the register stay unchanged.
this is important becausethe input and observable output points on a hardware deviceare the same so writing values to any of these points mayprevent errors contained in such points from being observed at the output.
for example on a register stat with initial state is 0x4 there are four test cases generated forstrength coverage by flipping each single bit one at a time tc1 tc2 tc3 a n d tc4 where indicates the bit is untouched.
each test case is executed on both d tanddousing the writestate transition line .
the algorithm then compares the resulting states of dtanddo line .
note that the change of one device component may affect the states of other components so the state comparison is done at the entire device level including interrupt controller if theinterrupt property is set to true in the test specification.
for example flagging bits in ierregister changes the value ofiirregister in the same device as well as the interrupt controller.
after the writestate transition is done the algorithm performs a readstate transition from s primetos prime primeto check whether dutcorrectly simulates the self clearance registers line .
if an observable difference is found a fault is reported line .
vdtest nextenablesincrementalstrength ttesting where tis increased up to n the maximum strength determined by the testing budget allocated for phase lines .
.
integration level testing the objective of the phase testing is to test interactions among registers and data buffers lines .
we focus onregisters that have potential combinatorial effects denoted byr which are specified in the test specification under theregister elementandits dependproperty.
likephase1 the data buffer values are randomly generated.
a strength t combinatorial testing at the integration level aims to test 588value combinations of each tregisters in r .
here the test cases generated for each register at the phase are its values.
for example the statregister example used in phase has four values.
similar to the phase algorithm the registers not contained in the new combination remainin their original states.
suppose we have a strength testsuite created for a dutthat contains four registers r1 r2 r3 and r4 where r2 is read only i.e.
no need tobe combined with others and the dependproperty of r3 is .
thus r r3 r1 r4 .
there are three combinations to be covered r1 r3 r1 r4 and r3 r4 in phase .
the algorithm separates out the test cases that can yield device state change and adds them into tc prime t tc prime tis further used to generate stateful test cases.
next the algorithm generates stateful test cases test sequences to test consecutive state transitions.
given a test lengthland stateless test cases from phase tc p1 a n d phase tc prime t the algorithm iteratively selects ltest cases to form a stateful test case tsand adds it into seq line .
thisisdonebyselectingonlystatelesscasesthatinduce changesinthefirsttwophasesratherthantheexhaustivesetof permutations of all stateless tests line .
note that a testsequenceisanorderedeventsequence becausechangingthe order of the state transitions may bring the device intoa different state.
suppose r1 0xband r1 0xa r3 0xb are two test cases generated from phase and phase re spectively and both yield state changes.
the two statelesstest cases form two test sequences with length r1 0xb r1 0xa r3 0xb and r1 0xa r3 0xb r1 0xb.
.
empirical study to assess vdtest we explore three research questions.
rq1 how effective is vdtest at detecting faults in realworld virtual devices?
rq2 towhatextentdoestheuseoforacledevicein vdtest affect its effectiveness?
rq3 what types of faults can vdtest detect?
thefirstresearchquestionevaluateswhetherthe vdtest approach is cost effective in terms of fault detection.
thesecond research question lets us further investigate whetherthe use of an oracle device can improve vdtest s effectiveness.
the third research question allows us to study thefaults and classify them into different categories.
.
objects of analysis to obtain objects of analysis we used virtual devices from three fsss that are widely used in both industry and academia simics qemu and gem5 .simicsis a commercial virtual platform.
with no source code provided.
in this case the test specifications were written according to the specification manuals by a graduatestudent who has three years experience in embedded system development.
qemuandgem5are two open source fsss containing 30k and 287k non comment lines of code in the device codebases respectively.
to evaluate vdtest we need both duts and oracle devices.
we searched virtual devices that are contained in at least two fsss with respectto their device models.
eight virtual devices matched thiscriteria.
all are based on the arm architecture.
we usedthe eight vds in gem5asduts and the vds in qemuas oracle devices because qemu is more widely used.
each dutis paired with an oracle device resulting in eight pairstable objects of analysis r b e u vd g f nd td nc1 nc2 nr1 nr2 uart8250 s p .
uart8250 g p .
dec21143 s p .
pl011 g q pl031 g q .
pl050 g q .
sp804 g q .
a9scu g q .
pl110 g q .
i8254 g q .
mcrtc g q .
of objects.
additionally given the availability of physicalhardware we also selected two vds from simicsand one from gem5asduts for which we had hardware and use their corresponding physical devices as oracle devices.
to gether there are eleven pairs of analysis objects selected ass h o w ni nt a b l e1 c o l u m n1 v d .
table provides the characteristics of each device and pair the notation x yin parentheses indicates a pair of dut x and its oracle device y where p indicates a physical machine s indicates simics g indicates gem5 and q indicates qemu.
we give the number of registers reg column and buffers buf column .
other columns are described in section .
.
uart8250 is an integrated circuit implementing the interface for serialcommunications.
dec21143 is a fast ethernet lan controllerprovidingadirectinterfacetothepcibus.
dec21143 has configuration registers command and status registers csrs and cardbus status changed registers we consideronlycsrsbecausetheotherregistersarefilledwithpre defined values.
pl011i sau a r td e v i c ef o rt h ea r m architecture.
pl031is a real time clock device used to provide a basic alarm function or as a long term base counter.pl050is a keyboard mouse interface.
sp804is a dualtimer module that can generate interrupts on reaching zero.a9scu is a snoopy control unit that connects processors to thememory.
pl110isacolorlcdcontrollerthatprovides control signals to interface directly via a variety of color andmonochrome lcd panels.
i8254i sa ni n t e li n t e r v a lt i m e r device designed to solve the common timing control prob lems in microcomputer system design.
it is used to bring down the timing frequency to customized levels.
mcrtc short for mc146818rtc is a real time clock with alarm and one hundred year calendar a programmable periodic interrupt and square wave generator and a static ram.
.
variables and measures independent variable.
our independent variable involves the testing techniques used.
in addition to vdtest t oa d dress rq1 we enable two testing techniques a combina torial interaction testing approach cit and a random testing approach random .
test suites generated by cit contain every combination of tinput parameters at least once in the test suites.
in our context the input parametersin phase are bits and those in phase are register andbuffers.
while citmay be less expensive than the vdtest engine it generates fewer test cases by maximizing inputparameter coverage in each test case it neither eliminatesmaskingeffectsnorprunesindependentoptions.
inaddition citdoes not generate stateful test cases without additional modeling.
likevdtest citwasappliedintwophases togenerate 589tests for both individual registers and for the whole device.
we generated two different sets of cittest cases.
for the first denoted as cit we used the same testing strengths as used in the vdtest t h i sl e t su se x a m i n et h er e l a t i v e effectiveness of the two approaches on equivalent strengths.for the second set cit we used the same testing time required by vdtest and generated multiple test suites this lets us examine the relative effectiveness of the approacheswhen each is given the same amount of testing time.
we also use a random testing technique random .randomhas been well studied as a baseline approach for traditional cit techniques .
test cases are generated byrandomly changing the bit values of registers and buffers.like cit we generated two sets of random test cases.
the first denoted as random used the same amount of testing time required by vdtest.
the second denoted as random used the number of test cases in the first set multiplied by to give random a higher chance of success .this lets us examine how the effectiveness of the vdtest test generator compares to that of a more robust random testing process.
to address rq2 we disabled the oracle devices and used only observable outputs as oracles i.e.
output based oracles .
this includes exceptional behavior that results inprogram crashes and error messages e.g.
missing functionality invalid memory access .
we compared vdtest with oracle devices to those with only output based oracles denoted by vdtest no.
to address rq3 we manually classified fault types.
we classified the faults into five categories.
the first category c1 areinitializationfaults inwhichdeviceregisters buffersare initialized with incorrect values.
the second category c2 is when we have an incorrect property of single reg ister bits.
for example we use c2 when a read only bit is writable and a reserved bit changes its status during testing.
the third category c3 was used when incorrect function ality of a device component bit was affected by the compo nent bit actually being written.
for example when writing to register a leads to an incorrect state of register b. the fourth category c4 is used for missing functionality cer tain features in the device are not implemented.
the fifthcategory c5 are faults that are interaction faults theyare triggered by at least two device components bits.
dependent variables.
as dependent variables we measure the effectiveness in terms of the fault detection .w e compare the numbers of uniquefaults determined by inspecting source code detected by test cases for each technique vdtest cit cit a n d random 1andrandom .
.
study operation we conducted our experiment on a physical x86 machine the physical devices used in our study and three fsss thatcan simulate both x86 and arm machines the virtual devices used in our study .
each x86 physical virtual machine runs a preemptive linux kernel version of fedora core2.
.
.
the arm machine is bare mental which means itdoesnotcomewithanoperatingsystem.
wechoselinuxbecause it runs on a wide range of known architectures which makes it possible to with small modifications extend thevdtest to the hardware on other architectures.
in addition the popularity and complexity of the x86 and armarchitectures make it easier to port vdtest to other architectures.
on the simulated machine we used the pro gramming interfaces that fsss provide which allow us todirectly control and observe the hardware states.
however othervirtualplatformssuchas ovpsim canalsobeused to instantiate the framework.
the static analyser is built on codesurfer using the system dependence graph sdg .we implemented a plugin module that takes as input theannotation plugin andtest template skeleton along with the sdg to generate test specifications.
we enabled both data dependencies and control dependencies to track data and control flow from device entry points.
on the fsss the execution engine is a built in module which takes the test driver to exercise test cases by writing and reading registers and hardware buffers.
we implemented the execution observer as external modules attached to fsss.
the apis provided by fsss allow us to observesystem states at arbitrary point.
on the x86 physical ma chine the execution engine is the operating system which executesthetestdriverasakernelmodule.
weimplemented theexecution observer by using source code instrumentation i.e.
printk t ol o gd e v i c es t a t e si n t oafi l e .
to implement the testing process of vdtest the maximum testing strength in the first phase is set to and that in the second phase is left at .
the length of the test sequencelis set to .
the insight behind choosing the strengths is the observation that in most cases the appearance of a failuredepends on the combination of a small number of parameter values of the dut .
returning to table we show the details of our test generation.
column n d lists the number of test cases generated by vdtest.
columns t d reports the time required for running these test cases in minutes.
columns and nc1andnc2 list the number of test cases generated by cit 1andcit 2respectively.
we used the acts t o o lt o generatecittestcases.
foreachofthetwo cittechniques we set the same strengths as used in vdtest i.e.
for the first phase and for the second phase .
column n r1 a n d column nr2 list the number of test cases generated by random 1andrandom .
all four techniques involve randomization therefore we ran each ten times.
in addition as the buffer value is ran domly set the effectiveness of the tests depends not only onthe registers but also on the actual content of the buffers.as such for each test register configuration we run it tentimes with different random buffer values.
in total then we conducted runs for each of the four techniques.
.
threats to validity the primary threat to external validity involves the representativeness of our programs.
other programs may exhibit different behaviors and cost benefit tradeoffs.
the programs we investigate are from several popular fsss and the faults we aim to detect are real.
another threat is when choosinga virtual device as the oracle it does not always guaranteethat the oracle device is correct.
this threat can be controlled by selecting more robust fsss as oracles.
the primary threat to internal validity is possible faults in the implementation of our approach.
we controlled for this threat by extensively testing our tools and verifying theirresults against a smaller program for which we can manually determine the correct results.
a second source of potential threats involves test oracles used.
any deviations from theoracle devices are reported as failures.
it is possible thatthe oracle devices may contain faults that may lead to the 590report of false positives.
we controlled for this threat by using robust fsss.
we also confirmed the deviations with developers on both sides.
it is possible that the deviation between dutand physical device does not mean a real fault but it is just because that the testing on the physical deviceresult in nondeterministic results due to irregular state ofother hardware components e.g.
cache scheduling lack of memory etc .
we controlled this threat by running each technique multiple times.
where construct validity is concerned numbers of faults detected are just two variables of interest.
other metrics such as the cost of manual effort could be valuable.
.
results table reports the results observed the cumulative faults detected in our study we use this table to address our first two research questions.2the numbers in parentheses indicate the number of faults detected in phase .
the numbers in brackets are the standard deviations across runs.
rq1 effectiveness of vdtest.
column of table reportsthenumberoffaultsdetectedby vdtest.
vdtest detected real faults.
we reported the deviations between gem5andqemuto the gem5developers and the faults were confirmed although priorities and fixes have not yet been implemented.
we also reported the faults in simics but because we are using an academic version there is limited support and were not able to get a confirmation.
columns in table report the numbers of faults detected by the two sets of cittechniques cit cit .
as the data shows cit 1detected faults and cit 2detected t h r e em o r ef a u l t s .a l l4 5f a u l t sd e t e c t e db ycit techniques were also detected by vdtest.
vdtest detected additional faults.
on eight pairs out of eleven vdtest detected more faults than cits with improvements ranging from .
to .
these results show that the vdtest is more effective at detecting faults than traditional cit.
as shown in column and column of table the two random test suites together detected only faults.
compared to vdtest vdtest w a sm o r ee ff e c t i v ei nn i n eo u t ofelevensubjectpairs allexcept a9scu g q andi8254 gq with fault detection improvement ranging from to .
.
these results show that the vdtest is substantially more effective than random .
rq2 effectiveness of device based oracles.
column in table reports the numbers of faults detected without an internal oracle vdtest no.
of the faults detectedby vdtest vdtest norevealedonly23faults.
clearly device based oracles substantially improved the fault detection effectiveness compared to observable output based oracles.
we further examined the data and discovered that all23 faults were related to missing features that led to outputerrors or crashes i.e.
observable faults .
for example when the test case tried to write to an unimplemented register in gem5 an error writing to invalid memory was generated followed by program termination.
rq3 fault categorization.
faults belong to the initialization c1 initcategory .
for example the initial values of two registers ris andfr i nt h epl011 are inconsistent with those in golden devices.
six out of 2artifacts and experimental data are available at tyu research vdtestfaults belong to the c2 bits error these stem from incorrect implementations of specific bits i.e.
read only write only and reserved bits .
for example on uart8250 in simics the values of two read only registers iirand msr w e r e changed unexpectedly by some test cases.
the write only register thris expected to return zero whereas the device returnsanon zerovalue.
afewreservedbits3indec21143 do not respond when they are written.
the writes to the re served bits changed the register values while these bits werenot modified in the physical device.
faults belong to the c3 incorrect functionality category and are caused by incorrect implementation in thevirtual devices.
for example the writes to the ierregister of the uart8250 returned different values than the phys ical device did.
the reason is that the iirregister in the uart8250 did not react to the change of the interrupt bits.
the reason is because the automatic self clearance mechanism was not implemented for the iirandlsrregisters.
on the device pl031 when lrregister is written mrregister is updated to the same value as lras but the golden device did not update mr.o nd e v i c edec21143 in a few cases the device failed to enable interrupt bits when the receiving andtransmitting processes were stopped but the golden devicedid.
on device sp804 when the thbit is set to the cd register was not changed but the golden device did.
nine faults are caused by c4 missing functionality.
for example the fifo buffer in the uart8250 ongem5 is missing.
three registers rsr ecr dmacr a n dlpr i n pl011are not implemented.
finally there are faults that we classified as interaction faults c5 interaction category of which faults were detected at the register level and at the devicelevel.
for example on simics uart8250 the interaction fault occurred in the fifo data buffer.
this buffer was not enabled when the associated registers iir and fcr w e r e set.
a few interesting faults occurred due to interactions among registers and interrupts.
on dec21143 the device can raise early interrupts right after a frame has been put to the internal transmit fifo buffer.
the device failed to trigger the interrupt on these early interrupts.
of the interaction faults ten faults were detected by the test sequences i.e.
stateful test cases from vdtest and only faults were detected by cit also detected by vdtest .
this indicates that exercising consecutive state transitionscontributestoenhancingtheeffectivenessfortest ing virtual devices.
we also observed the differences whenchanging the order of stateless test cases in a test sequence.
for example a fault occurred in pl011when executing a statefultestcase dr 0x40 imsc 0x20 icr 0x20.t h e first stateless test case dr 0x40 imsc 0x20 changed the values of the risand misregisters and the status of the interrupt controller pic.
a fault occurred because executing second stateless test case icr 0x20 did not revert the bit values in misand picto their original values as the golden device did.
this fault was not detected when the order of the two stateless test cases were flipped in the sequence.
in fact interrupts are sensitive to the order of state transitions.
.
discussion inthissection weexaminetheinfluenceofseveraltunable 3reserved bits or registers are reserved for future special use and do not perform any function.
591table fault detection effectiveness.
total cumulative faults phase faults and virtual device vd cit cit ran ran vd test test no uart8250 s p uart8250 g p dec21143 s p pl011 g q pl031 g q pl050 g q sp804 g q a9scu g q pl110 g q i8254 g q mcrtc g q total parameters on the effectiveness of vdtest.
combinatorial testing strength.
we further examined ourdatatoassesstheeffectsofcombinatorialtestingstrengths.
for each dut we increased the strength of phase testing to and that of phase to .
with the new testing strengths one more interaction fault was revealed at phase for de vices of pl110anddec21143.
specifically on pl110 t h e bgpregister was not updated but the golden device did when certain values in three registers were set.
on dec21143 the transmit process did not function correctly when three registers were set at the same time.
an implication of thisdiscovery is that strength matters more to programs with larger number of registers.
thus higher testing strength may be recommended to test such programs.
test sequence length.
to investigate whether the length of a test sequence can affect the effectiveness we increased the length lfrom to .
no additional faults were detected.
we further examined the data and discovered that all ten faults detected by the test sequences involve less than threestateless test cases.
while additional studies may be needed to generalize the results based on our current discovery length is sufficient.
false identification of register properties.
there are two registers in the simicsfss one in each of uart8250 anddec21143 devices that were incorrectly specified as read only registers.
because we did not have source code we were unable to identify the read only registers staticallyand during testing we prematurely assumed these registers were read only in the oracle device line in the algorithm of figure .
for example when multiple registers share thesame i o port e.g.
uart chip the read only register canbecome writable when certain bits are set in other controlregisters.
without exhaustively permuting register bits it is impossible to precisely determine read only registers.
.
related work there has been work on testing embedded systems using simulators .
however these techniques take advantage of fsss rather than test fsss.
while specificationbased testing techniques can be used to find cases in which the virtual device does not behave consistently withwhat has been defined in its hardware specifications obtain ing well documented reusable and accurate specifications can be difficult.
by using the golden oracle our approach does not rely on hardware specifications.
cong et al.
presented a technique to analyze behaviors of virtual device models and detect the differences between virtual and physical devices.
in later work they extend the technique to a commercial software tool .
their ap proach leverages symbolic execution to explore states of vir tual devices in qemu.
however their approach is limited as all symbolic execution engines are and does not generate integration test cases or stateful test cases.
as shown in ourstudy a large portion of faults are interaction faults that can only be detected by combinatorial test cases.
in addition their technique does not generate test specifications.engineers need to annotate and instrument source code foreach virtual device.
ormandy et al.
use random testingto detect security vulnerabilities in the implementation of virtual machines.
the author also shows several interesting examples on security faults caused by incorrect implementa tion of virtual machines.
however this work does not havea systematic testing approach for virtual devices such as test drivers unit and integration testing and test oracles.
the idea of differential testing has been used in a variety of contexts including flash file systems and cpu emulators .
martignoni et al.
utilize the physicalcputoanalyzecpuemulators virtualizestofinddefectsin their implementation however their work focus on the cpu virtualization.
in the hypervisor based vms they do nottake into account the peripheral virtual devices which areessential to an fss.
our work instead considers the distinct characteristics of peripheral devices.
in this paper we use ideas and language from combinatorial interaction testing such as the strength of testing and incremental testing .
however we are per forming integration testing rather than system testing and only manipulate tparameters at a time.
.
conclusions and future work in this paper we presented vdtest a framework for testing virtual devices within an fss.
vdtest solves two essential aspects of software testing test case and test or acle generation while also handling unique characteristics of real hardware devices.
the approach is mostly auto mated and requires little knowledge of hardware specifica tions.
our study shows that vdtest is effective in detecting real faults.
it found more faults than the best variant of cit and doubled fault detection over random testing.
we also found that using stateful testing as well as testingfor interactions improved our results.
in future work we willdevelop oracles that detect timing faults as well as experiment with different levels of granularity in our oracles.
in addition we will perform more extensive experiments.
.