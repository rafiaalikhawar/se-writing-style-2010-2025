fixing deadlocks via lock pre acquisitions yan cai and lingwei cao state key laboratory of computer science institute of software chinese academy of sciences beijing china ycai.mail lingweicao gmail.com abstract manual deadlock fixing is error prone and time consuming.
existing generic approach ga simply inserts gate locks to fix deadlocks by serializing executions which could introduce various new deadlocks and incur high runtime overhead.
we propose a novel approach dfixer to fix deadlocks without introducing any new deadlocks by design.
dfixer only selects one thread of a deadlock to pre acquire a lock w together with another lock h where before fixing the deadlock occurs when the thread holds lock h and waits for lock w. as such dfixer eliminates a holdand wait necessary condition preventi ng the deadlock from occurring .
the thread performing pre acquisition is carefully selected such that no other synchronization exists in between the two original acquisitions.
otherwise dfixer further introduces a context aware condition al protected by above lock w to guarantee the correctness of dfixer .
the evaluation is on deadlocks including from widely used real world c c programs.
it shows that dfixer successfully fixed all deadlocks.
whereas ga introduced new deadlocks a late st work grail failed to fix deadlocks and introduced new deadlocks on others.
on average dfixer incurred only .
overhead where ga and grail incurred .
and .
overhead respectively.
ccs concepts software and its engineering deadlocks software and its engineering software testing and debugging.
keywords deadlock fixing multithreaded program lock order .
introduction deadlock occurrence prevents a program execution from making further progress.
in general there are two kinds of deadlocks resource deadlock and communication deadlock .
a resource deadlock occurs when a set of threads are holding some locks and are waiting for the other locks held by the threads in the same set.
a communication deadlock occurs when some threads wait for some messages but they never receive these messages.
in this paper we focus on fixing resource deadlocks as two kinds of deadlocks are caused by different mechanisms and cannot be handled by the same technique .
manual bug fixing not only takes a long time but is also error prone .
recently automated bug fixing become popular .
however almost all existing techniques on concurrency bugs fixing insert new locks known as gate locks statically or dynamically to serialize all executions of thread s involved in a concurrency bug including afix axis grail gadara and .
by introducing new locks new deadlocks may also be introduced .
even manual fixing may also introduce deadlocks e.g.
.
incorrect fixing indeed introduced new deadlocks .
axis further iteratively fixes introduced deadlocks by adding more new gate locks.
grail adopts petri net analysis to eliminate such introduced deadlocks which however is only applicable to deadlocks with two threads .
introducing gate locks might be necessary to fix other concurrency bugs except deadlocks as fixing the former requires serialization of memory accesses from all threads of such bugs.
however deadlock is a kind of high level concurrency bugs caused by incorrect synchronization orders whereas others e.g.
atomicity violations are usually caused by missing synchronizations to protect the involved memory accesses from occurring in wrong orders.
for example many techniques differentiate concurrency bugs as deadlock bugs and non deadlock bugs as they require different techniques to detect and fix.
concbugassist focuses on data races atomicity violations and order violations.
even among above listed fixing techniques afix cannot fix deadlocks and grail only targets to fix deadlocks of two threads which further uses petri net analysis to avoid introducing new deadlocks .
in this paper we propose a novel strategy known as dfixer toward deadlock fixing .
the key insight of dfixer is that a deadlock can be fixed by breaking a necessary condition for this deadlock to occur the hold and wait condition of one thread involved in this deadlock.
suppose that if a deadlock d occurs one of its thread t is waiting for a lock denoted by wlock of thread t while holding another lock denoted by hlock of thread t and this hlock is waited by another thread in the same deadlock d. our fixing is for the thread t of the deadlock d its wlock should be acquired i.e.
pre acquired together with its acquisition on the hlock .
this fixing strategy exactly breaks the hold and wait condition of a thread e.g.
holding a hlock and waiting for a wlock by above thread t in a deadlock.
hence dfixer is able to fix the deadlock.
the advantages of this strategy are that it does not introduce any new lock by its design if a thread is properly selected see section to perform its pre acquisition on its wlock no new deadlock is introduced and it exactly fixes a deadlock without serializing the executions from other threads that execute the same program code but do not participate in the deadlock avoiding performance downgrade.
we have implemented dfixer for c c programs and evaluated it on deadlocks including real world deadlocks and of them are from three versions of widely used large scale mysql database.
we compared dfixer with the generic approach denot corresponding author.
permission to make digital or hard copies of all or part of this work for personal or class room use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm mu st be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa acm.
isbn ... .
ieee acm 38th ieee international conference on software engineering ed by ga that fixes a deadlock by inserting gate locks and a latest concurrency bug fixing technique grail that is based on ga but inserts context aware gate locks .
the experiment result shows that dfixer was able to fix all these deadlocks without introducing any new deadlock whereas ga fixed all deadlocks but also introduced new deadlocks and grai l not only failed to fix deadlocks but also introduced deadlocks on fixing other deadlocks .
after fixing dfixer incurred the least overhead i.e.
about on average while both ga and grail incurred a significantly larger overhead i.e.
.
and .
respectively .
the main contributions of this paper are as follows it proposes a novel deadlock fixing strategy dfixer that introduces neither new locks nor new deadlocks.
dfixer fixes a deadlock by selecting only one thread to preacquire a lock.
this allows parallel executions of threads not from the deadlocks avoiding performance downgrade .
we implemented dfixer as a prototype tool see to evaluate dfixer with comparison to the generic approach ga and a latest technique grail.
the experiment results demonstrate the effectiveness and efficiency of dfixer compared to ga and grail.
.
background and motivations .
preliminaries a deadlock occurrence involves a subset of the following events acq t m a thread t acquires a lock m. tryacq t m a thread t tries to acquire a lock m and it returns true if this try succeeds or false otherwise.
rel t m a thread t releases a lock m. wait t m a thread t firstly releases a lock m and then waits to acquire it again on a notification i.e.
a communication message from a different thread see below .
notify t m a thread t sends a notification to a different thread t that is blocked on wait t m .
if there is no such a thread t the notification is discarded.
in the rest of this paper we may not mention thread t or even lock m when we discuss above kinds of events if they are implied by the context e.g.
we may refer to acq t m as acq m or acq .
if a thread firstly acquires a lock m and then acquires another lock n before releasing lock m we say there is a lock order from lock m to lock n denoted by m n. if there exists another lock order n m or n ... m for multiple threads we say it is a reversed lock order of the lock order m n. existence of a lock order and its reversed lock order indicates a potential deadlock depending on whether they can be formed at the same time in an execution however the absence of a lock order and its reversed lock order indicates the absence of any deadlock on these two locks.
to simply our analysis on lock orders we assume that a thread can only release the lock that it acquired last .
or at least we assume this kind of lock acquisitions within deadlocks .
formally we adopt the lock dependency relation to define deadlocks .
a lock dependency t w h l denotes that a thread t acquires a lock w while holding lock h and all locks in set l. besides each event occurs at a program location which is referred to as a site.
a sequence of k k dependencies d ... k where i ti wi hi li forms a resource deadlock if for i k wi li wi hi wk h1 and for i j k ti tj wi wj and li lj .
the above definition describes that a set of threads wait mutually for a set of locks that are held by other threads in the same set.
that is each lock dependency i is a necessary condition for a deadlock d to occur.
for example the deadlock shown in figure a is described as d1 t1 n m t2 m n .
for a lock dependency t w h l of a deadlock d we refer to lock w as a wlock of thread t and lock h as a hlock of thread t as when deadlock d occurs thread t is waiting on lock w while holding lock h. for example on above deadlock d1 in figure a for thread t1 its hlock and wlock are lock m and lock n respectively and for thread t2 its hlock and wlock are lock n and lock m respectively.
.
generic approach a generic approach ga to deadlock fixing serializes the executions of all threads in the deadlock by inserting a gate lock .
ga is widely adopted by existing works and is also adopted to fix other concurrency bugs .
as discussed in section ga could fix a deadlock but it may easily introduce various new resource or communication deadlocks and may further reduce the parallelism of executions from different threads due to over synchronization i.e.
introducing performance bugs .
we firstly illustrate ga on three deadlocks d1 to d3 as well as how it introduces various new deadlocks.
for simplicity we may not show lock releases if they are not related to our discussion.
deadlock d1 figure a shows a program p1 with a deadlock d1 on two threads t1 and t2 as they acquire two locks m and n in reversing lock orders denoted by two dotted arrows .
to fix deadlock d1 ga inserts a gate lock g to prevent two threads from acquiring two locks m and n concurrently as shown in figure b .
ga correctly fixes d1.
deadlock d2 figure c shows a program p2 with three threads t1 to t3 executing lock acquisitions and releases on locks m and n in three functions f1 to f3 respectively.
program p2 contains a deadlock d2 between threads t1 and t2 if the value of need m at site s22 is true.
the variable need m is used to prevent a second lock acquisition by thread t3 via its call to f2 at site s33 .
figure d shows the program fixed by ga on deadlock d2.
after fixing deadlock d2 never occurs due to the insertion of a gate lock g. however considering three threads together we could observe that a new deadlock is introduced between threads t1 and t3 right after thread t1 acquires lock g and thread t3 acquires lock m at site s31 thread t1 cannot further acquire lock m at site s11 as which is held by thread t3 next thread t3 cannot acquire lock g at site sga2 on its call to function f2 at site s33 as lock g is held by thread t1.
as a result ga fixes deadlock d2 but introduces a new resource deadlock on locks g and m. deadlock d3 figure e shows a program p3 with two threads t1 and t2 to acquire locks m and n. similar to program p1 program p3 contains a deadlock d3.
the difference is that program p3 contains a pair of events wait n and notify n at sites s22 and s13 respectively.
however the deadlock d3 is not related to this pair of events.
it occurs if thread t1 acquires lock m and is about to acquire lock n at site s12 and thread t2 acquires lock n and i s about to acquire lock m at site s23 without executing wait n at site s22 i.e.
the value of v is a false .
figure f shows the program fix ed by ga on deadlock d3.
after fixing deadlock d3 never occurs.
however a new communication deadlock is introduced if thread t2 acquires both locks g and n and then executes wait n i.e.
the value of v is true then the corresponding notification message will never be received by thread t2.
it is because thread t1 is prevented from sending out the message at site s13 by executing notify n at site sga1 as loc k g is already held by thread t2.
as a result ga fixes deadlock d3 but introduces a new communication deadlock.
besides introducing new deadlocks ga also introduces performance bugs because it inserts a global lock as a gate lock.
for example on d1 if the two locks m and n of thread t1 are different from the locks m and n of thread t2 no deadlock occurs hence the two thread could execute in parallel.
however after fixing by ga the two threads always execute sequentially due to a global gate lo ck incurring runtime overhead .
the latest work grail follows ga approach but inserts a context aware gate lock determined by both locks m and n .
thus grail does not reduce parallelism if no deadlock may occur.
however as grail still adopts the gate lock strategy it cannot avoid introducing new deadlocks like ga e.g.
on fixing deadlock d2 and d3 hence grail has to rely on other analyses e.g.
petri net model to further prevent newly introduced deadlocks.
besides as grail needs to compute a context aware lock involving all locks of a deadlock it may fail on complex programs as some locks cannot be determined before some statements are executed.
due to these reasons grail failed to fix out of deadlocks in our experiment in section .
.
our approach .
rationales and overview of dfixer ga fixes a deadlock by inserting new gate locks to serialize executions of the targeted deadlocks.
introducing new locks must introduce new lock orders from the introduced gate locks to the locks involved in targeted deadlocks .
these newly introduced lock orders may form new deadlocks if the ir reversed lock orders are also introduced.
for example on fixing deadlock d2 in figure c the two newly introduced lock orders g m and m g form a new deadlock.
besides the introduced new global locks are inserted to prevent all threads of a deadlock from executing concurrently which may block communication messages from sending out e.g.
on fixing deadlock d3 or introduce performance bugs by preventing other threads from executing the same program code concurrently .
therefore the key insights of deadlock fixing strategy are to avoid introducing new lock orders and to fix the executions exactly involved in the targeted deadlocks but not to globally serialize all the involved program code.
based on above insights we propose a novel strategy to fix deadlocks known as dfixer .
we note that a necessary condition for a deadlock d to occur is that each thread of d has to hold a hlock and then waits for a wlock i.e.
the hold and wait condition .
dfixer exactly breaks such a necessary condition of one thread by fixing this thread to acquire its wlock together with its hlock denoted by acq hlock wlock which is formally defined in section .
.
.
that is the selected thread by dfixer should either acquire the two locks at the same time or not acquire any one of them breaking a hold and wait condition of the thread.
we refer to this early acquisition by a selected thread on its wlock together with the acquisition on its hlock as a lock pre acquisition .
for example figure shows program p1 see figure with deadlock d1 fixed by dfixer.
there are two ways for dfixer to fix deadlock d1 thread t1 pre acquires its wlock n i.e.
acq m n and thread t2 pre acquires its wlock m i.e.
acq n m where the two pre acquisitions are highlighted and also depicted by from the original acquisition on the corresponding wlock to its pre acquisition.
however not all deadlocks could be fixed like the way to fix d1.
for example if there is another lock acquisition acq p in between acq m and acq n of thread t1 in p1 pre acquisition on lock n also introduces a new lock order n q. hence such other synchronization events may also introduce various new deadlocks.
to address such challenge we carefully analyze the se cases and further propose context aware conditionals to guarantee the fixing correctness of dfixer via pre acquisition .
overall the novelties of dfixer are neither new lock nor new lock order is introduced introducing no resource deadlocks.
thread t1thread t2 s11 s12 s13 s14acq m n acq n rel n rel m s21 s22 s23 s24acq n acq m rel m rel n b fixing b pre acquisition on mbyt2.fixed program p1 thread t1thread t2 s11 s12 s13 s14acq m acq n rel n rel m s21 s22 s23 s24acq n m acq m rel m rel n a fixing a pre acquisition on nbyt1.
figure .
two ways to fix deadlock d1 in program p1 by dfixer .
thread t1 thread t2 s11 s12 s13acq m acq n notify n s21 s22 s23acq n if v wait n acq m e a deadlock d3.
thread t1 thread t2 sga1 s11 s12 s13 sgr1acq g acq m acq n notify n rel g sga2 s21 s22 s23 sgr2acq g acq n if v wait n acq m rel g f a fix to d3by ga that introduces a new communication deadlock.
program p3thread t1 thread t2 s11 s12acq m acq n s21 s22acq n acq m thread t1 thread t2 sga1 s11 s12 sgr1acq g acq m acq n rel g sga2 s21 s22 sgr2acq g acq n acq m rel g a a deadlock d1.
b a correct fix to d1by ga.program p1 thread t1 thread t2 thread t3 s11 s12funcf1 acq m acq n s21 s22funcf2 acq n if need m acq m s31 s32 s33 s34 s35funcf3 acq m need m false call f2 need m true rel m c a deadlock d2.
d a fix to d2by gathat introduces a new resource deadlock.thread t1 thread t2 thread t3 sga1 s11 s12 sgr1funcf1 acq g acq m acq n rel g sga2 s21 s22 sgr2funcf2 acq g acq n if need m acq m rel g s31 s32 s33 s34 s35funcf3 acq m need m false call f2 need m true rel m program p2 simplified from a mysql deadlock with bugid .simplified from a mysql deadlock with bug id .
figure .
three deadlocks d1 to d3 and their fixing by ga. dfixer only selects one thread to pre acquire a lock and if any condition als are also introduced they are made to be contextaware i.e.
specified by both hlock and wlock .
this allows all other threads to execute concurrently if they are not involved in deadlock and to execute without preventing communications from sending out introducing no communication deadlocks.
.
lock pre acquisitions and context aware conditionals in this subsection suppose that for each thread in a deadlock the acquisition on its hlock dominates its acquisition on wlock i.e.
if acq hlock is executed acq wlock must be executed and if not the latter is not executed .
section .
discusses how to handle the opposite cases .
.
.
implement lock pre acquisition dfixer requires that the two locks wlock w for short and hlock h for short of a selected thread should be acquired at the same time.
however if the two statements are simply placed together i.e.
acq h acq w or acq w acq h there always exists a lock order between two acquisitions i.e.
h w or w h respectively which either is the same as that before fixing i.e.
h w or may introduce a new deadlock as a new lock order is introduced i.e.
w h .
to eliminate both lock orders the two acquisitions must be performed at the same time.
this could be implemented by re writing locking mechanism.
however we propose to use the existing locking primitive tryacq e.g.
pthread mutex trylock from pthread to implement acq h w as follows acq h w while tryacq h tryacq w false rel h rel w that is if a thread cannot acquire both locks it immediately releases the acquired one if any.
although this implementation still introduces a lock order h w which however does not introduce any new deadlocks even if there exists a reversed lock order i.e.
w h .
the reason is that the thread involved in above preacquisition immediately releases its lock h which never results in a hold and wait condition on locks h and w. from this viewpoint by not introducing any deadlock we regard that this implementation does not introduce a lock order h w. in the rest of this paper we direct ly use acq h w to denote the pre acquisition on a wlock w together with a hlock h. note that tryacq may introduce livelocks .
in theory such a livelock cannot be eliminated.
in practice it can be easily resolved by inserting a random sleep e.g.
from to milliseconds as adopted in our experiment right after two release operations .
.
.
avoid introducing resource deadlocks simply let a thread to pre acquire its wlock may also introduce new resource deadlocks as it may introduce new lock orders.
let us consider a general case .
suppose for a deadlock d shown in figure a thread t1 is selected to pre acquire its lock w together with its lock h i.e.
acq h w as shown in figure b .
after pre acquisition a challenge is that if there exists other lock acquisitions say on a lock p between the original two acquisitions a new lock order w p is then introduced as denoted in a dotted arrow in figure b .
for such a lock order w p if its reversed lock order p w also exists e.g.
figure c a new deadlock is introduced.
therefore a straightforward approach for dfixer is to only select a thread of a deadlock such that in between its acq h and acq w no other lock acquisition exists.
for such a thread its preacquisition on w not only fix es the deadlock but also introduces no new lock orders hence introducing no new deadlocks .
however above approach may fail on fixing some deadlocks as for a deadlock all its threads may acquire other locks in between their two acquisitions.
we further propose context aware conditionals specified by both hlock and wlock to handle such cases where a thread of a deadlock acquires other locks in between its two acquisitions together with lock pre acquisition .
this fixing is shown in figure d where the original deadlock is the one in figure a .
our proposal is after pre acquisition if there is any other lock acquisition say acq p dfixer firstly releases the pre acquired lock w right before the acquisition on lock p and then re acquires lock w together with the acquisition on lock p i.e.
from acq p to rel w acq p w .
dfixer further guarantees that the second thread of the deadlock could not acquire lock w if the thread in has released its pre acquired lock w but not re acquired it together with lock p. the first step guarantees no new lock order w p is introduced.
however the re acquisition on lock w of acq p w recovers the lock order h w formed by acq h w ... rel w acq p w failing to fix the deadlock considering its reversed lock order w h from the second thread of the deadlock or w ... h if the deadlock contains more than two threads .
therefore dfixer has to guarantee that such a lock order h w does not form a deadlock from the other thread that forms the lock order w h. this is guaranteed in that prevents two lock orders forming at the same time.
this guarantee could be implemented by adding new locking mechanism or even communications e.g.
a pair of wait and notify primitives .
however this makes dfixer much more complex.
we then introduce a context aware condition al vhw specified by both hlock h and wlock w to provide the guarantee.
specifically as shown in figure d thread t1 sets a vhw to be true right before it releases its pre acquired lock w and recovers it to be false after it re acquires lock w. for thread t2 after it acquires lock w i.e.
th e hlock of thread t2 it checks whether thread t1 requires to re acquire lock w i.e.
vhw true?
if so it does not actually acquire lock w but waits until vhw becomes false .
as such although thread t1 forms a lock order h w it cannot be formed with the lock order w h by thread t2 at the same time.
besides this condition al does not prevent either thread t2 acquiring lock w at other sites or other threads acquiring lock w. note that this condition al is different from an ad lock synchronization as accesses to vhw are always protected by the same lock w. the cases where more than one other lock acquisitions exist in between acq h and acq w are handled in the same way.
threadt1 acq h acq p acq w threadt1 acq h w acq p acq w a b pre acquisition on lock w threadt2 acq w acq h threadt acq p acq w a new deadlock is introduced.
c d thread t1 acq h w vhw true rel w acq p w vhw false acq w thread t2 while acq w if vhw rel w else break acq h vhw false figure .
fixing via lock pre acquisition fails above and a conditional is required below .
discussion.
to avoid introducing new deadlocks dfixer fixes a given thread via lock pre acquisitions and context aware conditionals.
a question is that without any pre acquisition could a deadlock be fixed directly by any condition als alone ?
we believe a deadlock could be fixed by conditionals only.
however it may involve complex control logic among two threads e.g.
considering protections on conditionals two cases considering which thread firstly acquire their first lock otherwise hangs like deadlock may occur prevent the threads from making any progress .
for example figure shows that a conditional vhw is used to allow only one thread of a deadlock e.g.
deadlock d2 in figure c to execute acquisitions on two locks at a time.
then a hang occurs as follows after thread t1 changes vhw to be true and thread t3 acquires lock m t1 cannot acquire m at site s11 and thread t3 always executes while vhw after it calls f2 at site s33.
for deadlock d3 if a condition al is applied to fix it the result is similar as a gate lock is applied i.e.
a communication deadlock is introduced .
besides the conditional has to be protected by a common lock.
introducing such a lock further brings a potential to introduce deadlocks whereas our conditional is rightly protected by the e xisting wlock of a selected thread.
.
.
avoid introducing communication deadlocks although dfixer aims to fix resource deadlocks it should introduce neither resource deadlocks nor communication deadlocks.
if dfixer fixes a deadlock without considering communications among all threads a communication deadlock may also be introduced as shown in figure .
figure a shows a general case a thread t2 we use the symbol t2 not t1 to be consistent with deadlock d3 in figure of a deadlock executes a wait k between its two acquisitions where lock k is acquired before wait k and may be the same as lock h .
after pre acquisition as shown in figure b a communication deadlock occurs if thread t2 is blocked on executing wait k while it is holding lock w and a thread t that should execute notify k is then blocked as it cannot acquire lock w as shown in figure c .
the cases where a notify eixsts is similar we only discuss wait below as its solution also applies to cases of notify .
fortunately our solution in the last subsection to address other lock acquisitions acq p also applies to the existence of above wait k in figure a .
this is because an event wait k consists of three setps release lock k denoted by relw k wait for a message related to lock k and re acquire lock k denoted by acqw k .
as relw k does not produce lock orders we do not consider it.
however the wait requires that p re acquisition on lock w should not prevent other threads sending a message via notify k and acqw k requires that no new lock order from the pre acquired lock w is introduced.
hence in both cases the preacquired lock w should be released which is similar with the case on avoiding introducing resource deadlocks and our above solution also applies to this case .
the only difference betwee n acq k and acqw k of a wait k is that the latter is implicitly included in the wait k .
that is right after wait k the re acquisition on lock k i.e.
acqw k has been done .
hence we insert a rel k right after a wait k and then let the thread acquire both locks together wait k and acq w wait k rel k acq k w however as we mentioned before the lock k in wait k might be the lock h. this does not affect the fixing correctness of dfix er except one special case the corresponding notify k i.e.
notify h is expected to be executed by thread t1 i.e.
thread t1 is the same as thread t in between its acquisition and release on lock w i.e.
hlock of thread t1 .
this case is actually the deadlock d3 in figure .
for this case above fixing fails as three threads if they are likely to form a deadlock are expected to execute by following the below orders according to our solution resulting a controdiction thread t2 pre acquires lock w together with lock h and then releases lock h right before wait k .
thread t firstly acquires lock w acq w and then executes notify k .
thread t2 re acquires lock w together with lock k acq w k .
thread t1 i.e.
thread t should acquire lock w acq w .
when thread t is actually the thread t1 and the lock k is the lock h their acquisitions on lock w highlighted in and are the same one making above execution order infeasible.
actually after executing the first three steps there is no fourth step as it is included in step .
as the step is forced by our context aware condition al we then remove this condition al.
that is to fix deadlocks of this special case the pre acquisition alone is enough on the thread where a wait k exists and lock k is its hlock .
figure shows fixing of deadlock d3 on program p3 if thread t2 is selected.
this fixing only involves pre acquisition of wlock m. .
.
fix multiple deadlocks a program may contain multiple deadlocks.
these deadlocks could be incrementally i.e.
one by one fixed by dfixer .
however dfixer could also be optimized to fix multiple deadlocks by selecting a shared thread if these deadlocks share the thread as well as its two acquisitions i.e.
share a lock dependency .
.
handle program control flows in section .
we assume that acq h dominates its acq w for a thread selected by dfixer .
however this is not always the case due to the complexity of program controls e.g.
an early return may exist in between acq h and acq w .
there are five basic cases according to whether the code lines between two acquisitions on hlock and wlock of a thread involve single or multiple entries and single or multiple exits and loop structures as shown in figure .
to ease our following thread t2 acq h wait k acq w thread t2 acq h w wait k acq w a b thread t acq k acq w notify k c pre acq .
on lock w a new deadlock is introduced.
figure .
a communication deadlock introduced after pre acquisition.
thread t1 thread t2 thread t3 s11 s12funcf1 while vhw vhw true acq m acq n vhw false s21 s22funcf2 while vhw vhw true acq n if need m acq m vhw false s31 s32 s33 s34 s35funcf3 acq m need m false call f2 need m true rel m figure .
deadlock fixing via a condition al without pre acquisitions .
thread t1 thread t2 s11 s12 s15acq m acq n notify n s21 s22 s23acq n m if v wait n acq m fixed program p3 figure .
fixing on deadlock d3 by dfixer .
presentation we suppose that the two locks h and w are the hlock and the wlock of a selected thread respectively.
single entry and single exit.
in this case dfixer directly inserts an acq w into the pre acquisition block as the execution of acq h always results in the execution of the original acq w and the original acq w should be removed.
single entry and multiple exits.
if there are more than one branch between the two lock acquisitions dfixer has to insert a lock release statement i.e.
rel w at the beginning of all other branches that do not contain the original acq w .
multiple entries and single exit.
if there are multiple entries between the two lock acquisitions e.g.
acq w and acq h are in two different functions dfixer adds a lock w specifi ed condition al i.e.
vw in figure c to indicate whether the lock w is previously acquired at its pre acquisition site.
multiple entries and multiple exits.
this case is a combination of the last two cases.
therefore dfixe r not only inserts release statements on lock w to all other branches not containing the original acq w but also inserts a lock w specifi ed condition al.
for this case the inserted release statements should also be executed conditionally.
loop structure.
we firstly note that if the original acq w is within a loop its corresponding rel w should also be in the same loop otherwise a self deadlock exists.
as dfixer requires that the lock w should be pre acquired it has to take the acquisition on lock w out of the loop body .
otherwise the originally protected executions become unprotected during the second and later executions of the loop.
among our example deadlocks only deadlock d2 involves multiple exits on thread t2.
if thread t2 is selected the program control flow is fixed as shown in figure according to figure b .
.
dfixer algorithm algorithm outlines dfixer .
given a program p and a deadlock d from program p dfixer firstly step analyzes the program statements1 involved in each thread of d. this analysis is based on a depth first search for each thread t to explore all possible paths from the statement of its hlock i.e.
site h to the statement of its wlock i.e.
site w .
within this search dfixer keeps all other locks p of acq p in lp t and all locks k of wait k or notify k in wnk t .
these statements should be extracted when the deadlock occurs as it is difficult for object oriented programs e.g.
c to statically extract the concrete calls between the two sites site h and site w for a thread.
next step dfixer tries to select a thread t such that the size of lp t and wnk t is the smallest one among all not selected see step threads of d. if the size of lp t and wnk t is dfixer directly applies pre acquisition fixing alone otherwise it applies both pre acquisition and a context aware condition al to fix d. it then handles program control follows as said in section .
.
after applying fixing dfixer step compiles the fixed program.
if the compilation fails dfixer returns to step to select another thread to fix deadlock d again .
this compilation failure is usually caused as some wlocks cannot be pre acquired .
if no thread is selected in step dfixer fails to fix the deadlock d. .
guarantee of dfixer dfixer guarantees to fix a given deadlock d without introducing new resource or new communication deadlocks as theorem .
theorem .
given a deadlock d from a program p after fixing deadlock d by dfixer according to algorithm the events in d do not form any deadlock occurrence and no other resource or communication deadlock is introduced.
proof sketch .
suppose that the deadlock d ... ti wi hi li ... and dfixer selects the thread ti to pre acquire its wlock wi.
case lp ti wnk ti .
this case is straightforward.
before fixing there are two lock orders hi wi for thread ti and wi ... hi for other threads in d. after fixing the lock order hi wi is removed due to pre acquisition of wi i.e.
acq hi wi .
therefore the events in d cannot form a deadlock occurrence.
on the other hand as lp ti wnk ti no other lock acquisitions or wait notify exist in between the original acq hi and acq wi .
therefore after pre acquisition of the lock wi no new lock order is introduced and the pre acquisition does not prevent any wait or notify from occurring.
hence no new resource deadlock or communication deadlock is introduced.
case lp ti wnk ti .
in this case as the original lock order hi wi is eliminated after fixing the events in d cannot form a deadlock occurrence.
after fixing no other lock order is acq h acq w acq w rel w acq h acq w rel w b single entry and multiple exits e loop structurepre acquisitions and handling of control flowsremoved statementsacq h acq w acq h w acq w a single entry and single exit c multiple entries and single exit d multiple entries and multiple exitsoriginal statements if !vw acq w acq h w vw true vw false rel w acq h acq w rel w acq h acq w rel w acq h w if !vw acq w vw false rel w if vw vw false rel w acq h w vw true rel w acq w rel w acq h w figure .
five basic cases of control flows .
thread t1 thread t2 thread t3 s11 s12funcf1 acq m acq n s21 s22funcf2 acq n m if need m acq m else rel m s31 s32 s33 s34 s35funcf3 acq m need m flase call f2 need m true rel m fixed program p2 figure .
fixing on deadlock d2 by dfixer if thread t2 is selected.
introduced except one for each lock p hi wi due to the three fixing statements i.e.
acq hi wi rel wi acq p wi from thread ti.
however there is a context aware conditional vhw is introduced see line of algorithm to determine whether the lock order hi wi is formed.
the lock order only occurs when vhw true see thread t1 in figure d .
but the original lock order wi ... hi only occurs when vhw false see thread t2 in figure d .
hence the two lock orders cannot be formed at the same time.
therefore after fixing the events in d as well as the introduced lock orders cannot form a deadlock occurrence.
besides in this case right before any other acq or wait notify the pre acquired lock wi is released introducing no new lock order and does not prevent thread ti from executing notify .
hence neither new resource deadlock nor communication deadlock is introduced.
based on the above two cases theorem is proved.
.
discussions and limitations in practice some wlocks depend on data structures which cannot appear together with the acquisition of their hlocks .
of course dfixer is able to fix a deadlock via multiple ways.
if a thread could not perform its pre acquisition another thread is then selected.
however the worst case is that no thread of a deadlock could perform a pre acquisition on its wlock .
in theory this case does exist.
note that this challenge is also suffered by grail however grail fails on fixing deadlocks with at least one such thread.
the reason is that grail requires exactly all hlocks and wlocks to abstract a context aware gate locks.
in our experiment it failed on deadlocks from mysql due to this reason.
dfixer may also introduce more runtime overhead than grail and ga. for example after pre acquisition of a wlock the thread may take a long time before reaching the original acquisition and release of the wlock and this may prevent other threads not from the deadlock acquiring the wlock .
however grail and ga do not suffer this limitation as their inserted new locks only affect the executions of threads from the deadlock.
.
experiment .
benchmarks we collected a set of nine benchmarks db maintain bank trans.
dining philo.
hawknl sqlite openldap and three different versions of large scale mysql database server.
the first three are used for deadlock research purpose and the rest are widely used real world programs.
they totally include deadlocks and each involves two or three threads covering most of deadlocks cases .
all these benchmarks have been used in previous works multiple times and are available either online or from the previous works .
these benchmarks including their test cases are also available at table shows the statistics of all benchmarks including benchmark names with version numbers if available bug ids if available program size sloc the number of threads of each benchmark prog the number of threads involved in each deadlock dlk the number of deadlocks of dlks in each benchmark.
the next five columns show the statistics related to dfixer including the number of other lock acquisitions lq and the number of wait notify event wnk of each thread in each deadlock respectively whether there are multi entries multi exits and loops structures.
we show the five metrics for each thread of each deadlock where a single value or symbol is shown if they are same for all threads of a deadlock.
the eleventh column shows the depth from acq hlock to acq wlock of each thread in each deadlock in terms of the number of functions and the code lines sloc .
for example the first such value is indicating that the two acquisitions of both threads are within the same function and there are and code lines between them respectively.
note that some benchmarks include multiple deadlocks.
these deadlocks from the same benchmark involve the same set of locks but occur in different scenarios i.e.
from different set of threads and in different functions we treat them as different deadlocks as each of them should be fixed.
however due to page limit the statistics only show the data of one deadlock for each benchmark and the full statistics are also available at our online benchmark page .
the last column shows whether deadlocks from a benchmarks could be fixed by lock pre acquisition only i.e.
without a context aware conditional .
.
implementation and experimental setup we implemented dfixer as well as ga and grail on top of llvm framework .
dfixer extends the modulepass class table .
statistics of benchmarks and deadlocks.
benchmark bug id sloc of threads prog dlk of dlks lp wnk multi entries ?
multi exits ?
any loops ?
depth func.
sloc pre acq only?
db maintain n a .1k bank trans.
n a .1k dining philo.
n a .1k hawknl .6b3 n a .3k sqlite .
.
.0k openldap .
.
.3k mysql .
.4a .6k mysql .
.4a .6k mysql .
.
.7k mysql .
.
.7k algorithm dfixer .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
input p and d t1 w1 h1 t1 w2 h2 ... step identify program information for each t w h d let lp t wnk t other acq q and wait k in between analyze p from site h to site w and update lp t wnk t this analysis is based on dfs exploring step select a thread and apply fixing let t d be a thread with smallest lp t wnk t from all threads in d except those threads previously selected.
if no such a thread t print dfixer failed to fix deadlock d from program p. halt.
if lp t wnk t apply pre acquisition on thread t. else apply pre acquisition and context aware condition al on thread t. handle program control flow according to section .
.
step verify fixing let the fix ed program p as program p .
compile p if failed goto step .
of llvm to perform a depth first search as shown in algorithm on bitcode files.
it firstly extracts synchronizations and controls i.e.
control flow graphs and call graphs for each thread in between its acq hlock and acq wlock .
next based on extracted information it applies pre acquisition or and context aware conditionals.
however dfixer does not direct ly modify any bitcode files instead it generates a fixing guide file e.g.
where and what should be inserted .
we built a small program to translate this file into a linux patch file.
the patch file can be patched into the source code of the given program to fix a deadlock.
for the dfixer and grail some wlocks were not visible at the acquisition of their hlocks .
trying to solve the visibility issue might be difficult as which requires c c source file inclusion and could easily introduce compilation errors .
therefore we set a pointer and assign the value of the wlock to the pointer.
this pointer is used for pre acquisition by dfixer or for computation of context aware gate locks by grail .
we implemented contextaware conditiona ls for dfixer via a map structure from two given locks hlock and wlock to a boolean value.
grail is based on context aware gate locks.
it firstly generates a string by concatenating the addresses of hlock and wlock.
next a second constant string mapped in java string pool in java see string.intern with same values is return ed as a gatelock object.
this constant string is unique in each java execution.
we implemented this via a map structure in c which maps a concatenation of two lock addresses to a gate lock .
there is no essential difference between our implementation in c and the grail original implementation in java.
after applying three techniques to all benchmarks we ran each fixed program by each technique for times and collected the cases where deadlock occurred.
during this runs we inserted a set of random sleep before and after each original and fixing lock acquisition of each deadlock to amplify deadlock occurrence probabilities.
note without the random sleep the runs were not enough.
we also ran them for additional times without sleep to collect their execution time.
as all versions of mysql are servers we only collected their processing time on sql queries i.e.
test cases but not the whole program execution time.
we conducted the experiment on a thinkpad workstation w540 with a .
ghz up to .4ghz i7 4710mq processor installed with ubuntu .
and gcc .
.
.
result analysis .
.
overall effectiveness table shows the detailed fixing results.
the second major column shows that before native and after fixing by each technique how many deadlocks occurred in runs with random sleep .
the third major column shows after fixing whether any new deadlock was introduced.
we adopted manual inspection into the fixed source code firstly potential and then ran each fixed program to see whether any new deadlocks could be triggered triggered .
the mark indicates that no data was collected e.g.
a technique failed to fix a deadlock or a new deadlock always occurred after fixing .
the last major column shows the average fixing overhead of the additional runs no sleep .
from the second major column of table we see that all deadlocks were likely to occur with random sleep.
after fixing no deadlocks occurred except on two benchmarks where new deadlocks were introduced.
however no deadlock occurrences did not indicate that no new deadlocks were introduced by three techniques.
the second major column of table then shows that after fixing many potential deadlocks were introduced by both ga and grail and these potential deadlock were also triggered .
however dfixer did not introduce any potential deadlocks and no deadlock was triggered.
we further summarized the fixing results of three techniques on deadlocks from real world benchmarks in table summarized from table including the number of deadlocks successfully fixed by each technique and whether there is any significant performance downgrade e.g.
more than overhead .
from the table we observe that grail and ga only successfully fixed and deadlocks out of deadlocks respectively on other deadlocks they either failed or and introduced new deadlocks.
however dfixer fixed all deadlocks correctly.
besides both grail and ga incurred larger than overheads on average whereas dfixer did not incur such a large overhead across all benchmarks.
.
.
overall efficiency the last major column of table shows the fixing overhead.
averagely on real world deadlocks ga incurred .
overhead grail incurred .
overhead but dfixer only incurred .
overhead.
we note the following grail fixes a deadlock by inserting a context aware gate lock which could reduce fixing overhead compared to ga that inserts a global gate lock.
previous experiments also verified this point.
in our experiment grail incurred the largest overhead on four of six benchmarks.
this however does not contradict the previous results .
the reason is that our table .
detailed comparisons of ga grail and dfixer the avg.
overhead i n last row is on real world deadlocks only .
benchmark of deadlocks occurrences with random sleep of new deadlocks average o verhead potential triggered native ga grail dfixer ga grail dfixer ga grail dfixer ga grail dfixer db maintain .
.
.
bank trans.
.
.
.
dining philo.
.
.
hawknl .
.
.
sqlite .
openldap .
.
.
mysql .
.
.
mysql .
.
mysql .
.
.
mysql .
.
sum avg.
.
.
.
table .
summary of fixing on real world deadlocks.
of total real deadlocks of fixed with overhead ?
ga grail dfixer ga grail dfixer experiments focus ed on scenarios where deadlocks were likely to occur before fixing while the previous experiments focused on scenarios where deadlocks and atomicity violations were not likely to occur see the deadlock benchmark log4j bugid .
therefore for our cases all three techniques have to serialize part or all executions in each deadlock as our test cases are designed to trigger deadlock occurrences .
as both ga and grail completely serialized the executi ons in our cases they incurred more overhead than that by dfixer which not only serialized part of executions via per acquisitions but also released pre acquired locks if no deadlocks may occur i.e.
by fixing program control flows .
on the other hand ga simply insert ed gate locks whereas grail had to compute context aware gate locks by matching context in a map structure even in its original implementation in java see section .
.
as a result grail may incur a larger overhead than ga on some benchmarks.
.
.
detailed discussion db maintain and bank trans .
these two benchmarks are simple ones like our example deadlock d1.
all three techniques correctly fixed them.
on db maintain no additional overhead was incurred by all techniques.
however on bank trans the two threads acquire their first locks twice before they acquire their second lock i.e.
acq m acq m acq n here no self deadlock exists as two threads use recursive locking of pthread .
besides the two threads only acquire their second lock in less than half of all cases.
as a result the deadlock seldom occurs before fixing without sleep .
however ga and grail completely serialized two threads from their first acquisitions resulting in heavy overhead .
by ga and by grail .
dfixer only selected one thread to pre acquire its second lock together with its first acquisition and if the thread takes another branch it immediately releases the pre acquired locks only incurred .
overhead.
dining philo .
this benchmark includes five threads t1 to t5 to simulate five philosophers and each thread ti acquires two locks li and li l6 l0 .
the deadlock occurs when each thread ti acquires lock li and waits for lock li .
both ga and dfixer were able to fix it.
however grail only targets to fix deadlocks with two threads.
therefore it was unable to fix this deadlock.
note that for deadlocks involving more than two threads grail might generate a gate lock based on all these locks which is feasible on dining philo .
but may fail on other deadlocks e.g.
mysql discussed later .
after fixing ga incurred .
overhead as it completely serialized all executions of five threads whereas dfixer only incurred .
overhead as it serializ ed only two threads by selecting only one thread to pre acquire a lock.
hawknl and openldap .
on these two real world benchmarks all three techniques were able to fix them correctly.
note that although one thread from openldap involves a lock acquisition on a third lock as shown in table dfixer fixed it by selecting the second thread to perform a pre acquisition only.
actually by selecting the first thread dfixer was also able to fix it.
on the performance on hawknl grail incurred the largest overhead i.e.
.
followed by ga incurring .
overhead dfixer incurred only .
overhead.
on openldap both grail and ga incurred larger overheads i.e.
.
and .
respectively than that by dfixer i.e.
.
.
sqlite .
the two deadlocks from this benchmark occur when a data race occurs on a variable inmutex .
dfixer correctly fixed both deadlocks.
however both ga and grail failed to fix them .
on their runs there were exactly occurrences of a new deadlock .
the original deadlock is like our example deadlock d2.
in the original program two threads of each deadlock acquire two locks mutex1 and mutex2 in a reversed order however a thread sometimes does not release lock mutex2 controlled by the variable inmutex .
after fixing by ga and grail a gate lock g was inserted resulting in two lock orders g mutex1 and g mutex2 .
however when one of two threads does not release lock mutex2 and if it later re acquires lock mutex1 it has to acquire the inserted gate lock g resulting in a lock order mutex2 g. this lock order together with the lock order g mutex2 from another thread forms a new deadlock.
dfixer successfully fixed two deadlocks via pre acquisition.
of course it had to fix the control flows as its fixing on deadlock d2 shown in figure .
mysql and mysql .
there are totally deadlocks within mysql .
.4a .
all three techniques correctly fix ed the first four.
however for the last one bugid both dfixer and ga fixed it but grail failed.
we simplified th is deadlock in figure a .
the thread t2 firstly acquires a lock from a table table syncobj and then acquires a global lock syncsec.
the thread t1 acquires the two locks in a reversed order.
however for thread t1 after it acquires the global lock syncsec it has to iteratively explore a linked structure data via a pointer p in a for loop underlined .
from the pointer p a dbb pointer dbb is fetched via function getdbb then a section pointer sec is fetched via function findsec .
the pointer sec points to a memory containing a table pointer table and its lock table syncobj.
as a result before executing findsec the table is unknown and hence the lock syncobj is also unknown.
therefore grail failed to compute a gate lock from both locks syncsec and syncobj which is unknown .
however for dfixer although the loc k syncobj cannot be pre acquired with lock syncsec by thread t1 the lock syncsec can be pre acquired with lock table syncobj by thread t2.
hence dfixer fixed this deadlock.
mysql .
the two deadlocks from this benchmark are actually our example deadlock d2.
there are two locks thread count and index.
one of two threads acquires lock index if the value of the variable need mutex is true in a function purge logs .
however this function may also be called from another function srv printf innodb monitor ... lock print info summary acq kernel thd security contex acq thddata thread t3 mysql rm table part2 acq open ... trx allocate for mysql acq kernel wait for locked table names wait open thread t2 b deadlock on mysql bugid srlupdaterecords commit acq syncsec for uchar p data p end p len dbb dbb log getdbb getint p dbb updaterecord secid ... table treefetch acq syncobj dbb updaterecord secid section sec findsec secid sec updaterecord ... thread t1 a deadlock on mysql bugid truncatetable table table acq table syncobj ... srldroptable append acq syncsec thread t2 kill one thread acq thddata ... awake acq open notify open thread t1 figure .
two deadlocks simplified from mysql and mysql .
purge first log .
in this case the lock index is acquired in purge first log .
therefore although grail and ga fixed the original deadlock they introduced a new deadlock if function purge logs is called in purge first log .
this produces a lock order index gatelock.
together with its reversed lock order gatelock index formed by another thread a new resource deadlock is introduced .
dfixe r fixed this deadlock like its fixing to deadlock d2 without introducing new deadlocks.
on this benchmark ga incurred the largest overhead i.e.
.
followed by grail i.e.
.
.
dfixer only incurred .
overhead.
mysql .
the deadlocks from this benchmark are complex.
figure b shows one of them.
this deadlock involves three threads and three locks as highlighted.
however like our deadlock d3 there is a pair of wait and notify on lock open.
grail failed to fix this deadlock as locks open and thddata are specified by a database grail failed to compute a gate lock.
for ga like its fix on d3 it introduced a communication deadlock as after fixing once thread t2 executes wait open it holds the gate lock which prevents thread t1 from executing both acq open and notify open .
this newly introduced communication deadlock was identified by our manual inspection and was also triggered.
for dfixer like its fixing on d3 it fixed this deadlock by selecting thread t2 to perform its pre acquisition on lock kernel.
note dfixer could not select thread t1 or thread t3 to perform a preacquisition as both locks thddata and open are specified by a database.
ga by serializing all three threads incurred .
overhead whereas dfixer incurred only .
overhead.
on mysql we manually identified potential deadlocks introduced by ga which were also triggered.
we suspect that more deadlocks were introduced by ga as there were many other parallel executions like threads t1 and t2 which could result in deadlock occurrences with the gate locks inserted by ga. however these potential deadlocks were not triggered in our experiment as they may require different test cases.
we use symbol to indicate this case in table .
.
related work .
deadlock detection detection of deadlocks is mainly based on detection of either cycles in lock order graphs or cyclic lock dependencies on lock dependency relation statically or dynamically .
static ones may report many false positives compared to dynamic ones even with various filters .
although dynamic one are relatively precise they also report false positives.
kahlon et al.
theoretically analyze whether two threads may form a deadlock occurrence through reachability checking.
other works recently focus on how to actually trigger occurrences of realworld deadlocks by searching for possible scheduling .
dfixer focuses on how to fix deadlocks.
it could be integrated with these techniques to fix their detected and triggered deadlocks as a subsequent action.
there are also many works on synthesizing concurrency bugs once observed.
esd synthesizes an execution from a core dump file of an execution with a deadlock occurrence.
penelope also synthesizes part of execution to replay an observed atomicity violations or deadlocks.
these techniques may fail due to the lack of thread interleaving and test cases.
contege targets to generate concurrent test cases so as to trigger an expected concurrency bug.
omen further synthesizes executions for deadlock triggering based on contege .
sher lock actively infers test cases based on interleaving constraints of threads involved in a targeted deadlock via concolic executions .
synthesis of executions and concurrent test cases may also help to verify the existence of a potential deadlock introduced by deadlock fixing approaches.
however unlike existing approaches dfixer avoids introducing any new deadlocks by its design no matter what test cases are given.
deadlocks may easily exist in database applications e.g.
most of deadlocks in our benchmarks were taken from mysql database servers .
these deadlocks could also be detected and prevented by analyzing hold and wait relations i.e.
cycles among threads and locks .
dfixer also breaks such a hole and wait relation to fix a deadlock.
.
concurrency bug fixing and recovery many techniques have been proposed to fix concurrency bugs .
however almost a ll these techniques insert gate locks dynamically or statically to serialize executions of threads in a dea dlock which could introduce new deadlocks as discussed in this paper .
dfixer distinguishes itself from all these works by its design to avoid introducing any new deadlocks.
among above techniques both gadara and dimmunity aim to prevent previous ly detected deadlocks occurring.
they adopt a strategy like ga except that they may not always invoke acquisitions on the inserted gate lock via context matching.
however context matching may introduce false positives which fails to prevent a deadlock occurring.
recovery techniques could be integrated with deadlock detection and fixing.
sammati aims to provide deadlock recovery by rolling back the executed operations once a deadlock is detected.
conair tries to recover most concurrency bugs including deadlock.
lin et al.
propose to change lock acquisition primitives i.e.
from acq to tryacq or from tryacq to acq to partially fix a deadlock .
they further propose to recover program executions once a deadlock occurs which may incur high runtime overhead.
besides recovery from deadlock occurrence might be infeasible as discussed in e.g.
when a thread involves file io operations or accesses shared variables .
once dfixer fixes a deadlock the deadlock never occurs.
therefore there is no need for dfixer to adopt any recovery techniques.
.
conclusion existing deadlock fixing strategies may easily introduce new deadlocks and may also incur high runtime overhead.
we propose dfixer toward deadlock fixing without introducing any new deadlocks via lock pre acquisition.
we have evaluated dfixer on a set of widely used benchmarks including deadlocks and also compared it with existing approach es.
the experiment al result shows that compared to existing ones dfixer not only fixed all deadlocks but also introduced no new deadlocks besides dfixer only incurred about overhead on average which is significantly lower than that of compared approaches .
.
acknowledgement we thank anonymous reviewers for their invaluable comments and suggestions on improving this work.
we also thank dr. chao wang and dr. lingming zhang for their suggestions on this work.
this work is supported in part by national program of china 2014cb340702 and national natural science foundation of china nsfc grant no.
.
.