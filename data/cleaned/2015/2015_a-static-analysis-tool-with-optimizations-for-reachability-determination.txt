a static analysis tool with optimizations for reachability determination yuexing wang yz min zhou yz yu jiang yz xiaoyu songx ming gu yz jiaguang sun yz key laboratory for information system security ministry of education china ytsinghua national laboratory for information science and technology tnlist china zschool of software tsinghua university china xelectrical and computer engineering portland state university usa abstract to reduce the false positives of static analysis many tools collect path constraints and integrate smt solvers to filter unreachable execution paths.
however the accumulated calling and computing of smt solvers are time and resource consuming.
this paper presents tsmartlw an alternate static analysis tool in which we implement a path constraint solving engine to speed up reachability determination.
within the engine typical types of constraint patterns are firstly defined based on an empirical study of a large number of code repositories.
for each pattern a constraint solving algorithm is designed and implemented.
for each program the engine predicts the most suitable strategy and then applies the strategy to solve path constraints.
the experimental results on some well known benchmarks and realworld applications show that tsmartlw is faster than some state of the art static analysis tools.
for example it is .32x faster than cpachecker and our engine is 369x faster than smt solvers in solving path constraints.
the demo video is available at index terms reachability determination constraint pattern path constraint solving i. i ntroduction static program analysis spa can determine run time properties of programs automatically.
the results of the technique may have errors that actually can not be reached.
these errors are called false positives and they are generated because of the approximation nature of spa .
many static analysis tools filter false positives by collecting path constraints and using smt solvers to get their satisfiability.
unreachable paths are dropped and false positives can be eliminated.
for example if we use a static analysis tool to analyze function fin fig.
a and the analyzed path is !
!
!
!
!
!
the tool can collect path constraints a b b a and use smt solvers to check their satisfiability.
they are unsatisfiable and the error will not be reported.
false positive is then eliminated and the path is dropped.
the error in fig.
b is verified reachable.
although smt solvers can be used to filter false positives the accumulated calling and computing time of smt solvers can be long if smt solvers are used too many times.
cpachecker and cbmc are two widely used open source verification tools for c and c programs that integrate smt solvers such as mathsat5 z3 yices2.
if the program to be analyzed has many branches every branch contributes a set of path constraints and the calling and computing time of smt solvers can occupy a large proportion of the execution time of cpachecker or cbmc.1i n t f i n t a i n t b i n t c a b i f c c b i f c a error e l s e c a return c a 1i n t g i n t a i n t b f i f a b f i f a b f error 5g 6g i n t c a b return c 9g b fig.
.
examples of using smt in this paper we present tsmartlw an optimized static analysis tool.
a constraint solving engine cse is designed and implemented for reachability determination.
we define four constraint patterns according to a preliminary empirical study.
for each pattern an especially designed constraint solving algorithm is presented and implemented.
during the analysis process the engine first predicts the most suitable strategy based on statistics.
then the strategy is applied to solve path constraints.
for evaluation tsmartlw and cpachecker are used to detect divide by zero errors in some commonly used benchmarks and real world applications.
the experimental results show that tsmartlw is faster than cpachecker and the cse is more efficient in solving path constraints compared with smt solvers.
on average tsmartlw is .32x faster than cpachecker and the cse is 369x faster than smt solvers in solving path constraints.
the rest of this paper is organized as follows.
section introduces some static analysis tools and existing work on filtering false positives.
the core components and algorithms of our tool are shown in section .
section presents the experimental results and section comes with conclusions.
ii.
r elated work to ensure the quality of the code there are two directions one is the qualified code generation techniques from the highlevel model and another is the code analysis and verification techniques.
for the former there are lots of tools for generating hardware and software codes from formal verified model .
for the latter there are static analysis and dynamic analysis methods in this paper we mainly focus on the static analysis tools for c code such as cpachecker and cbmc .
cpachecker integrates some smt solvers.
.
c ieeease urbana champaign il usa tool demonstrations925 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we can choose whether to perform a constraint analysis to drop unsatisfiable paths using smt solvers.
cbmc can use smt solvers to check the reachability of each error at the end of the analysis process.
many works have been proposed for eliminating false positives of static analysis by implementing more precise context analysis by smt solvers and so on.
huang et al and chess et al believe the scope of the analysis is important because it determines the amount of context the tools consider.
kim et al junker et al and cordeiro et al use smt solvers like cvc3 boolector z3 to drop unreachable paths and filter false positives.
moreover we can also use some techniques to enhance smt solvers .
different from those works we implement a static analysis tool tsmartlw and design a constraint solving engine for reachability determination to drop unreachable paths and filter false positives.
tsmartlw c programbuilder error pathsgcc.i filessyntax treecdtanalyzer result cfa csevisualizer xml report fig.
.
architecture and workflow of tsmartlw iii.
d esign of the tool as presented in fig.
tsmartlw contains three kernel components builder analyzer and visualizer.
the input of tsmartlw is the analyzed c program and the output is the error paths of the program.
builder is used to preprocess the program to be analyzed.
it parses a single .c file to a .i file using gcc.
for real world applications builder requires them to contain makefiles.
for each executable module of an application builder can capture the files that the module needs and parse them to .i files using gcc.
if an application consists of many executable modules each of them is captured to generate a task and each task will be analyzed separately by analyzer.
after the program is transformed to .i files cdt is used to generate syntax tree.
analyzer analyzes programs and outputs the results.
it constructs control flow automatons cfa of programs first using syntax trees.
then it analyzes programs based on cfas.
going through all the possible edges from a node to another to simulate an operation iteratively it can check all the possible execution paths of programs.
the analyzer can find dividedby zero errors.
during the analysis process we propose an optimized method for reachability determination.
we use a cse instead of smt solvers to solve path constraints.
visualizer shows all the errors to users.
it transforms the result of analyzer to xml format and generates a report.
then fig.
.
the resulting interface of tsmartlw the report is displayed in web form.
all the errors and their paths in the source code are presented.
the builder and visualizer are implemented by ourselves and the analyzer is implemented based on cpachecker.
the resulting interface of tsmartlw is shown in figure.
.
all the errors and their paths are presented.
in the next two parts we present constraint patterns and their corresponding constraint solving algorithms first and then show how our cse utilizes the patterns and algorithms.
a. definitions of patterns and algorithms this section gives the definitions of patterns and algorithms.
the results of an empirical study are also presented.
we define four kinds of constraint patterns and the reasonableness of the four patterns can be seen from the empirical study.
for each pattern an especially designed constraint solving algorithm is presented.
before these concepts are introduced we explain some basic definitions in table i. patterns and their corresponding algorithms we define four kinds of constraint patterns singlesymbolicequality sse singlesymbolicinequality ssi multisymbolicsinglefunction mss and multisymblicmultifunction msm .
we also design four corresponding algorithms substitution linear localframe and fullpath.
these patterns and algorithms are defined below.
sse pattern and substitution algorithm the constraints which have sse pattern should satisfy the two properties.
.jsymv ar c j .
op c 2f g the corresponding constraint solving algorithm is substitution.
suppose cis a set of constraints and its pattern is sse.
there is at most one variable in each constraint and the operator is equal or not equal.
thus we can solve every constraint easily and record the variable value tuples.
if we meet a new constraint variables in it can be substituted by values and we can get its satisfiability easily.
ssi pattern and linear algorithm constraints of pattern ssi should also satisfy some requirements.
.jsymv ar c j .
op c 2f g authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i basic definitions .
definition explanation constraint constraint is an assumption statement with all its variables whose real values can be obtained from context substituted by their values.
pattern pattern describes the structural information about a constraint or a set of constraints.
priority priority denotes the complexity of a pattern.
the pattern of a set of constraints is determined by the constraint which has the highest priority.
global global is the set which contains all the global variables appearing in the program to be analyzed.
param param fis the set of all parameters of function f. ret retfis the set of variables that are assigned returned values in function f. returned values are the return values of other functions that are called inf.
for example if fcontains a statement like int a g then ais included in retf.
symvar symv ar c is the set that contains all the symbolic variables in constraint c. op op c represents the relational operator in c type type c represents the type of constraint c equal less lessorequal .
the corresponding algorithm is linear.
if the pattern of c is ssi it means all the constraints in care of pattern sse or ssi.
each constraint has one variable and the operator is equal not equal less or lessorequal.
the relations between variables in different constraints are linear.
it is easy to get their satisfiability using their relations.
there are two reasons that make substitution andlinear efficient in solving path constraints.
.
smt solvers are integrated as external tools.
the calling time for smt solvers can be long if smt solvers are called too many times.
substitution andlinear can be implemented inside these tools and the calling time can be saved.
.substitution andlinear are more targeted.
mss pattern and localframe algorithm let fcbe the function from which the constraint c is extracted.
to verify if c is of pattern mss we should check if csatisfies the following requirements.
.jsymv ar c j .8v2symv ar c v 2global v 2param fc v 2retfc localframe is used to solve constraints of pattern mss.
if the pattern of cis mss smt solvers should be used with some optimizations.
if the function fis being analyzed the pattern of cis mss if there is no symbolic value that belongs to global variables parameters of fand variables that are assigned returned values in f. in this case we can use only constraints in fto determine the satisfiability of all the constraints.
it is obvious that if we drop some constraints which are not in f we can speed up smt solvers.
msm pattern and fullpath algorithm constraints of the pattern msm should satisfy the following two properties.
.jsymv ar c j .9v2symv ar c table ii the number of constraints for different patterns .
program sse ssi mss msm total array1 array2 unreach1 unreach2 point1 point2 driver1 driver2 main1 main2 grep gzip searcher vim total proportion .
.
.
.
v2global v2param fc v2retfc fullpath is chosen if we can not use any other algorithm or even adapt some optimizations.
we have to collect all path constraints and use an smt solver to get their satisfiability.
note that pr is the priority function and pr sse pr ssi pr mss pr msm .
empirical study to state the reasonableness of the four patterns some benchmarks and real world applications were analyzed and the number of constraints for each pattern is recorded.
we select ten programs from five directories of svbenchmarks the benchmark of sv comp randomly and each directory contributes two programs.
they have 233k lines of c code in total.
for real world applications we choose grep gzip the silver searcher and vim.
the results are shown in table ii.
the first column shows the programs and the next four columns present the number of constraints for each pattern.
the last column is the total number of constraints that appear in the program.
as we can see .
of all the constraints in these programs are of pattern sse.
ssi .
and mss .
also occupy a large proportion.
only .
of all the constraints have pattern msm.
the results prove the reasonableness of the four patterns and mean that most of the constraints can be solved by easier ways.
thus our cse is worth being applied.
b. constraint solving engine we implement the four algorithms in our cse which is used in analyzer to solve path constraints and show how our cse applies the algorithms based on constraint patterns.
tsmartlw can perform a static analysis on c programs.
source files of the program to be analyzed are transformed to cfa first.
then the analysis process begins and our cse is used to replace smt solvers.
during the analysis process the engine predicts the most suitable strategy first based on statistics.
then the strategy is applied to solve path constraints.
algorithm shows how our cse applies the algorithms.
source files are transformed to cfa.
the predict function authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
stis used to predict the most suitable transfer function f and initial constraint solving algorithm a. during the analysis process if we meet an assumption edge we can get a new constraint c.cis added to path constraints cand its pattern is used to update the current pattern and algorithm.
then the updated algorithm is used to check the satisfiability of c. if the constraints are unsatisfiable the path is dropped.
more details about the transfer function and predict function are listed below.
algorithm apply constraint solving algorithms procedure apply algorithms cfa source files f a st cfa while analysis process continues do e2cfa is being analyzed ife is an assumptionedge then c get constraint from e add c c p0 pa c ifhp ai pa c hp0 a0i fthen hp ai h p0 a0i a!satisfiability checking end if ifc!unsat then current path!drop end if end if end while end procedure transfer function fbelongs to transfer function set t. for each 2t assigns each tuple hp aia new tuplehp0 a0iand each transfer is labeled with pa c .
pa can get the pattern of a constraint or a set of constraints andcis a constraint.
if hp ai pa c hp0 a0i the relation is denoted as hp aipa c hp0 a0i.
the relation means pa c p0and the current pattern and algorithm are changed top0and a0.
we implement two transfer functions single and standard in our tool.
single means we should use just one constraint solving algorithm during the analysis process while standard means we should adjust the constraint solving algorithm according to the pattern of current path constraints.
if single is chosen we should use just one constraint solving algorithm during the analysis process.
suppose ais the initial algorithm it should be used until the analysis process ends.
we may treat unreachable paths as reachable and we may get some false positives because acan not solve constraints whose pattern s priority is higher than a corresponding pattern s priority.
to solve this problem we can mark all the errors and collect their path constraints.
then false positives can be filtered using smt solvers at the end of the analysis process.
if standard is chosen we should use different algorithms for different path constraints based on their patterns.
thus we can always get the right answer and we do not need to filter false positives at the end of the analysis process.
the workflow of standard method is presented in figure.
.
p ssepush p then p sse enter new function ?yesassume edge?funccall edge?funcret edge?p pop noanalyzingbegin t edge patternyes update p using t apply algorithmyes unsat?no drop path yesstack empty?end yesfig.
.
how the pattern changes along the path.
we enter main function and set the pattern pof current path constraints to sse.
for each path these steps are performed.
the analysis process continues until we meet a function return edge an assumption edge or a function call edge.
if we meet a function call edge it means that we enter a new function.
so we store the current pand reset pto sse.
then we goto the first step.
if an assumption edge is met we can get a constraint from the edge and we add the constraint to path constraints.
if the constraint s pattern is t. we use tto update p. the algorithm should also be updated.
after adding the constraint if the new path constraints are unsatisfiable we drop this path.
otherwise we goto the first step.
if a function return edge is met it means that we leave the current function.
we restore pfrom stack and goto the first step.
the analysis process of current path ends as soon as the return edge of main is met.
predict function the function st in algorithm determines which transfer function should be used and st cfa t. before the analysis process begins we do not know which function is the most suitable.
since constraints can only be produced in the analysis process we can not make a decision using constraints.
thus we propose a strategy to predict the most suitable function based on cfa and statistics.
machine learning techniques are promising in predicting and these techniques can also be applied.
after we get the most suitable transfer function we can use it in the analysis process.
in our implementation we use a simple method to predict the most suitable transfer function.
we analyze many programs first and collect data that can influence our choice as statistics.
based on statistics when analyzing new programs we can predict the most suitable function.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to get statistics we should analyze lots of programs first and record the number of each kind of constraint equal less lessorequal for different patterns sse ssi mss msm .
for example the number of equal constraints that has sse pattern is esse the number of other three patterns are essi emss andemsm.
for less constraints the numbers are lsse lssi... and for lessorequal constraints the numbers are lesse lessi... the data is treated as statistics for further use.
when a new program is analyzed we can choose transfer function based on cfa and statistics.
for equal constraints if we get esse essi emss emsm then we believe that a new equal constraint has a possibility of pequal sse esse esse essi emss emsm to has pattern sse.
the possibility of other patterns are also calculated in that way.
the general formula is p ptype ptype sse ssi mss msm is the type of constraints equal less lessorequal while ptype is a kind of pattern.
for constraint of type we can use formula to get its possibility to has pattern ptype.
scores ssescore ssiscore mssscore msmscore corresponding to the four patterns are defined.
we should traverse the program s cfa first.
if an assumptionedge is met we identify its type equal less lessorequal .
if its type is equal.
then the edge has a probability of pequal sse to has pattern sse.
thus we believe that this edge increases ssescore by pequal sse .pless sse and plessorequal sse do the same.
so we can use to get ssescore.
ssescore cfax e assumptionedgeptype e sse others are calculated the same way.
the general formula is ptypescore cfax e assumptionedgeptype e ptype ptype denotes the pattern which you want to get its score.
we normalize the scores first and set four bounds empirically.
then the most suitable function st s is defined below.
note that if single is chosen the initial algorithm is determined by the pattern whose score crosses the threshold.
otherwise we use substitution as the initial algorithm.
st s single if one score crosses threshold standard otherwise iv.
e xperimental results in this section the benchmarks and the real world applications mentioned in section iii.a are analyzed by tsmartlw and cpachecker and the results are compared in table iii and table iv.
tsmartlw and cpachecker are used to perform an inter procedural analysis on benchmarks and an intra procedural analysis on real world applications.
duringthe analysis process tsmartlw uses our cse to solve path constraints while cpachecker uses smt solvers.
the time used for satisfiability checking and the total execution time of tsmartlw and cpachecker are recorded.
table iii shows the time used for satisfiability checking of the two tools.
column m5 means cpachecker uses mathsat5 to solve path constraints and z3 means cpachecker uses z3 solver.
in the third to the ninth columns tsmartlw is used to analyze the program and our cse is applied to solve path constraints.
substitution linear localframe m5 and localframe z3 mean single is applied and the initial constraint solving algorithm is substitution linear localframe with mathsat5 localframe and standard need smt solvers and localframe with z3.
standard m5 and standard z3 mean standard is used and mathsat5 and z3 are chosen.
in the last column we use our cse to predict transfer function first and then apply the function in the analysis process.
as we can see substitution linear and standard z3 need the least time for satisfiability checking.
on average our cse is .8x faster than smt solvers.
for example z3 needs .4s for vim and our cse costs only .1s.
there are two reasons that make our cse more efficient than smt solvers in solving path constraints.
the four algorithms in cse are more targeted.
besides smt solvers are usually integrated as external tools.
the calling time for smt solvers can be very long if smt solvers are called many times.
cse can be implemented inside these tools and the calling time can be saved.
table iv shows the execution time of the two tools.
tsmartlw using substitution linear or standard z3 has the least execution time and cpachecker needs much more time for most programs except program main1 we do not lose much .
on average tsmartlw is .3167x faster than cpachecker.
for example cpachecker needs 7938s to analyze vim and tsmartlw only costs .5s.
tsmartlw is faster because it saves much time in satisfiability checking.
moreover our cse can always predict the best or near best strategies transfer function and initial algorithm .
v. c onclusion this paper proposes tsmartlw an optimized static analysis tool.
tsmartlw can perform inter procedural or intraprocedural analysis on programs to find divide by zero errors.
during the analysis process our cse is applied for satisfiability checking.
tsmartlw is compared with cpachecker a state of the art static analysis tool.
we use the two tools to perform an inter procedural analysis on benchmarks and an intra procedural analysis on real world applications.
the results reveal that tsmartlw is faster than cpachecker.
acknowledgment this research is sponsored in part by nsfc program no.
no.
national science and technology major project no.
2016zx01038101 miit it funds research and application of tcn key technologies of china and the national key technology r d program no.
2015bag14b01 .
the authors would like to thank zuxing gu for his advice.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii the time used for satisfiability checking by cpa checker and tsmart lw.
program m5 z3 substitution linear localframe m5 localframe z3 standard m5 standard z3 predict array1 .1s .9s 129ms 164ms .7s .4s 227ms 189ms 129ms array2 .5s .3s 151ms 167ms .7s .3s 256ms 199ms 151ms unreach1 .7s .6s 153ms 188ms .2s .9s .5s .4s 153ms unreach2 .7s .8s 149ms 179ms .4s .6s .6s .3s 179ms point1 .9s .3s 81ms 74ms .4s .9s 142ms 100ms 81ms point2 .2s .6s 234ms 192ms .6s .8s 263ms 192ms 192ms driver1 .4s .4s 25ms 26ms .5s .4s 41ms 30ms 25ms driver2 .3s .8s 66ms 64ms .4s .0s 116ms 99ms 66ms main1 .9s .6s 187ms 199ms .1s .8s .0s .6s 187ms main2 oom1103.
229ms 214ms .4s .4s .1s .9s 229ms grep .3s .7s 435ms 205ms .4s .2s 205ms gzip .2s .6s 172ms 131ms .8s .9s 131ms seracher .8s .0s 52ms 82ms .2s .7s 82ms vim oom .4s .2s .1s .6s .3s .1s 1oom means out of memory.
2an intra procedural analysis is performed on real world applications and there is no need to apply algorithm localframe.
3we set four bounds .
.
.
.
for sse ssi mss msm as we have said in the last paragraph of iii.c.a and they are used for prediction.
table iv the execution time of cpa checker and tsmart lw seconds .
program m5 z3 substitution linear localframe m5 localframe z3 standard m5 standard z3 predict array1 .
.
.
.
.
.
.
.
.
array2 .
.
.
.
.
.
.
.
.
unreach1 .
.
.
.
.
.
.
.
.
unreach2 .
.
.
.
.
.
.
.
.
point1 .
.
.
.
.
.
.
.
.
point2 .
.
.
.
.
.
.
.
.
driver1 .
.
.
.
.
.
.
.
.
driver2 .
.
.
.
.
.
.
.
.
main1 .
.
.
.
.
.
.
.
.
main2 oom .
.
.
.
.
.
.
.
grep .
.
.
.
.
.
.
gzip .
.
.
.
.
.
.
seracher .
.
.
.
.
.
.
vim oom .
.
.
.
.
.
1the time used for verifying marked errors generated by applying single algorithms is included in execution time.