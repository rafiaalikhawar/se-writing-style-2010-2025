symbolic repairs for gr specifications shahar maoz tel aviv university tel aviv israeljan oliver ringert university of leicester leicester ukrafi shalom tel aviv university tel aviv israel abstract unrealizability is a major challenge for gr an expressive assume guarantee fragment of ltl that enables efficient synthesis.
some works attempt to help engineers deal withunrealizability by generating counter strategies or computing anunrealizable core.
other works propose to repair the unrealizablespecification by suggesting repairs in the form of automaticallygenerated assumptions.
in this work we present two novel symbolic algorithms for repairing unrealizable gr specifications.
the first algorithminfers new assumptions based on the recently introduced jvts.
the second algorithm infers new assumptions directly from the specification.
both algorithms are sound.
the first is incompletebut can be used to suggest many different repairs.
the secondis complete but suggests a single repair.
both are symbolic andtherefore efficient.
we implemented our work validated its correctness and evaluated it on benchmarks from the literature.
the evaluationshows the strength of our algorithms in their ability to suggestrepairs and in their performance and scalability compared toprevious solutions.
i. i ntroduction reactive synthesis is an automated procedure to obtain a correct by construction reactive system from its temporal logic specification .
instead of using model checking to verify a manually constructed implementation synthesisoffers an approach where a correct implementation of thesystem is automatically obtained for a given specification if such an implementation exists.
in reactive synthesis animplementation is given as a controller i.e.
an automatonthat accepts input from the environment and produces thesystem s output to always satisfy the specification inputfrom the environment may come from sensors system s output includes commands for actuators .
if such a controller exists the specification is considered realizable.
otherwise the specification is unrealizable i.e.
there exists an environment that can satisfy all the assumptions while forcing the system to violate some of its guarantees.
while synthesis from linear temporal logic ltl specifications is generally considered impractical due its high computational complexity double exponential in the length of the formula in this work we focus on gr an assume guarantee fragment of ltl that has an efficient symbolicsynthesis algorithm and whose expressive power covers most of the well known ltl specification patterns of dwyer et al.
.
gr specifications include assumptions and guarantees about what needs to hold on initial states on all states safety and infinitely often on every run justice .one of the main challenges of reactive synthesis in general and of gr synthesis in particular is to deal with unrealizable specifications .
one way to deal with unrealizability is repairing it by automatically generating a repair in the form of new additional assumptions which would make the specification realizable.
some existing repair techniques for gr use concrete counter strategies css as a starting point.
a concrete csshows how an environment can satisfy all the assumptions while forcing the system to violate some of its guarantees.
since generating a concrete cs is costly due to the need to enumerate all its states the efficiency of these repair techniques is limited.
other repair techniques are defined over the more general ltl.
as such they may suggest repairs that are outside the gr fragment and hence cannot be applied in a gr setting.
these limitations hinder the use of existing repair approaches by engineers.
in this work we present two novel symbolic repair techniques that aim to address these limitations.
first jvts repair .
the jvts is a symbolic representation of css for gr which is computed symbolically without the expensive enumeration of concrete states.
given a jvts we generate candidate assumptions that eliminate the cs it represents.
by construction the nodes of a jvts represent symbolically how a cs prevents an implementation.
based on these nodes jvts repair creates assumptions that prevent the cs.
by iterating this approach jvts repair finds candidates for repairs.
second glass which does not rely on css but addresses unrealizability in a global way directly analyzing assumptions and guarantees.
glass computes a safety assumption that ensures the safety guarantees can be satisfied a justice assumption for each justice guarantee and finally an initial assumption to prevent losing initial states.
one strength of jvts repair is its efficiency thanks to its symbolic nature.
it is also typically capable of generating many different repairs.
it is however incomplete for someunrealizable gr specifications it cannot suggest a repair although such a repair exists.
one strength of glass is that it is not only very efficient but also complete.
we proveits completeness in the paper as well as demonstrate it in our evaluation see below .
unlike jvts repair glass is however limited to generating only one repair and typically generates a repair that involves more variables than the ones suggested by jvts repair.
we further extend the two techniques with size minimization using the notion of repair core roughly a locally minimal ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1env boolean r request 2env boolean c clear 4sys boolean g grant 5sys boolean v valid sys responds with grant for every request 8gar respond prespondstos r next g if cleared or granted no immediate next grant 11gar ungrant g c g next !g cleared request means not valid 14gar exclude g c !v infinitely often give valid grants 17gar just gf g v listing unrealizable request grant rg1 specification adopted from subset of a repair that is already a repair and with support for auxiliary variables which are common in specifications that use patterns.
we describe these extensions in sect.
vii.
we have implemented all the above ideas in spectra tools .
we present an evaluation of our work over benchmarks taken from the literature in terms of ability to repair computation time and scalability.
the evaluation shows not only that our symbolic repairs are able to repair many specifications that could not be repaired by previous works but also that their computation is significantly faster.
see sect.
viii.
program repair is an active research area .
while we are partly inspired by works on program repair we do not deal with repairing imperative programs but rather with repairing gr specifications which are temporal declarative specifications for reactive systems.
most previous works on repairing unrealizable gr specifications e.g.
have relied on a concrete cs.
our algorithms are symbolic.
we discuss related work in sect.
ix.
ii.
r unning example we adopt the request grant running example rg1 used in previous gr repair papers .
the environment has two variables rfor requests and cfor clearing requests.
the system has two variables gfor grants and vfor marking grants valid.
four guarantees express the system s requirements.
the first states that a request is answered by a grant within a positive finite number of steps2.
the second prohibits a grant immediately following a grant or a clear.
the third states that clear and valid are always mutually exclusive.
the last guarantee requires a valid grant infinitely often.
the specification in lst.
is unrealizable i.e.
there exists no implementation of the system that satisfies all guarantees.
a simple cs demonstrates this if the environment cancels c all 1although gr specifications typically contain assumptions this example contains only guarantees.
nevertheless we chose to use this example here because it is simple for presentation in a paper format and has been used in previous closely related works.
note that our repairs handle general gr specifications which indeed typically include assumptions.
2note that the first guarantee is equivalent to the ltl formula g r fxg which is not a pure gr guarantee.
it is implemented with a response pattern following which introduces a boolean auxiliary variable that is implicit in the specification see also for explicitly introducing the variable .
we discuss patterns and auxiliary variables in sect.
vii b.requests r it prevents vfrom becoming true to satisfy the third guarantee and thus a valid grant which violates the last guarantee .
how can this unrealizable specification be repaired i.e.
can one add assumptions that will make it realizable?
our symbolic repair algorithms aim at generating such assumptions.
consider the following two assumptions never cancel a request immediately in the next state g r !
next c and always eventually issue requests that are not immediately canceled gf r !c .
these two assumptions constitute a repair of the specification i.e.
adding them makes the specification realizable.
such a repair is an example for the output automatically generated by our repair algorithms.
iii.
p reliminaries a. linear temporal logic ltl we will use one of the standard definitions of linear temporal logic ltl e.g.
as found in over present future temporal operators x next u until f finally and g globally and past temporal operator h historically .
for a finite set of boolean variables v acomputation s0s1.. 2v is an infinite sequence of states i.e.
of truth assignments sitov.w eu s e i to denote that the ltl formula holds at position i 0of as defined e.g.
in .
we denote by and say that satisfies .
b. gr realizability ltl formulas can be used as specifications of reactive systems where atomic propositions are interpreted as environment input and system output variables.
an assignment to all variables is called a state.
a strategy for an ltl specification prescribes the outputs of a system that from its winning states for all environment choices lead to computations that satisfy .
a specification is called realizable if a strategy exists such that for all initial environment choices the initial states are winning states.
the goal of ltl synthesis is given an ltl specification to find a strategy that realizes it if one exists.
gr synthesis handles a fragment of ltl where specifications contain initial assumptions and guarantees over initial states safety assumptions and guarantees relating the current and next state and justice assumptions and guarantees requiring that an assertion holds infinitely many times during a computation.
a gr specification sconsists of the following elements xinput variables controlled by the environment youtput variables controlled by the system x primeandy primecopies of input and output variables at next step eassertion over xcharacterizing initial environment states sassertion over x y characterizing initial system states e x y x prime transition relation of the environment s x y x prime y prime transition relation of the system je i ..njustice goals of the environment js j ..mjustice goals of the system.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a gr specification is strictly realizable iff the following ltl formula is realizable sr e s e g h e s e g e logicalanddisplay i ..ngfje i logicalanddisplay j ..mgfjs j .
specifications for gr synthesis have to be expressible in the above structure and thus do not cover the complete ltl.
efficient symbolic algorithms for gr realizability checking and controller synthesis have been presented in .
the algorithm of piterman et al.
computes winning states for the system i.e.
states from which the system can realize sr. note that the problem of satisfiability i.e.
the existence of a computation that satisfies an ltl formula is usually easier than the problem of realizability .
c. counter strategies and the jvts a specification is unrealizable if the environment can force the system to violate one of its guarantees while satisfying all the environment assumptions i.e.
the environment has a cs.
a cs can be given by an lts that for every state prescribes inputs from the environment that from its winning states for all system choices lead to computations that satisfy sr.ac s can ensure srby either forcing the system to a deadlock violation of an initial guarantee or a safety guarantee or by satisfying all justice assumptions je iand preventing at least one justice guarantee js jforever.
a justice violations transition system jvts i s an acyclic lts consisting of two types of symbolic states abstracting the cs attractor states forcing to initial or safety guarantee violations or to other symbolic states and cyclestates locally preventing at least one justice guarantee .
each state in the jvts represents a set of states in some cs and each transition in the jvts represents a set of transitions in that cs.
the jvts is acyclic e.g.
every play will end in a deadlock or stay in some cycle state forever.
definition justice violations ts jvts structure see for a complete definition .given an unrealizable gr specification a jvts is an acyclic lts angbracketleftq t i l angbracketright where qis a set of symbolic states where each q qis either a cycle state or an attractor state t q qis an acyclic transition relation iis a set of symbolic initial states and lis a labeling function that labels all states in qwith assertions over x y characterizing the corresponding sets of concrete states in a cs.
kuvent et al.
showed how to compute the jvts symbolically and thus efficiently without the expensive enumeration of concrete states of a cs.
d. symbolic algorithm notation symbolic synthesis algorithms in our context operate on sets of states and transitions instead of on their explicit representations.
in our algorithms we use assertions forsymbolic representation of sets of states over variables x y and sets of transitions over variables x y x prime andy prime .
we operate on assertions using the usual boolean operators e.g.
for an assertion overx y the expression echaracterizes all states in that are also initial environment states.
in addition to standard boolean operators we also use prime which translates an assertion overx y to an equivalent assertion overx prime y prime and quantification where for v x y x prime y prime existential quantification vyields an assertion without v that holds iff there exists an assignment to variables in vs.t.
holds analogous for universal quantification v .
all operations used in our algorithms have direct implementations using binary decision diagrams with cudd .
iv .
p roblem definition intuitively the repair problem takes as input an unrealizable gr specification sand produces a set of assumptions that makesrealizable.
a closer look reveals that some repaired specifications do not allow assumptions and guarantees to be satisfied together and realizability implies that the system forces the environment to violate assumptions a case of non well separation .
we say a specification sis sat iff all existing assumptions and guarantees can be satisfied together i.e.
when e s g e s logicalandtext i ..ngf je i logicalandtext j ..mgf js j is satisfiable.
example .
the specification from lst.
is sat.
consider adding the assumption g !g next c to always cancel requests if no grant is given.
this specification is still unrealizable but not sat guarantee ungrant requires that gbecomes false and together with gstays false forever and guarantee just cannot be satisfied.
interestingly assumption gf r !c from sect.
ii makes the specification realizable.
however after adding this assumption a valid system implementation never grants requests the environment has to always cancel and is forced to violate the new assumption.
we consider repairs leading to unsat specifications not useful.3adding assumptions to a unsat specification preserves unsatisfiability and we thus consider it as unrepairable indeed we have found several unrealizable and unsat specifications in our evaluation see sect.
viii .
formally we define the repair problem as follows given an unrealizable and sat specification s find additional assumptions that will make srealizable and sat.
we call such a set of assumptions a repair.
v .
jvts b ased symbolic repair we now present our first main contribution namely a symbolic repair based on the jvts.
we first describe an algorithm to generate candidate repair assumptions from a jvts and then describe the main repair algorithm which uses the first algorithm as a building block.
finally we discuss termination and complexity.
3alur et al.
and cavezza and alrajeh consider weaker formulas for satisfiability of their repairs and allow some repairs we consider not useful.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
u f j f y u f y u f y fig.
.
two jvtss representing css for the running example rg1.
a. generating assumptions from a jvts given a jvts we generate candidate repair assumptions based on its cycle nodes attractor nodes and edges.
we build the assumptions from the symbolic representation of the jvts with the goal of eliminating the cs and additional similar ones that the jvts represents.
we present this in alg.
.
the first loop lines infers justice assumptions from the cycle nodes of the jvts by negating the symbolic representation of the label of the node.
the generated justice assumption eliminates the ability of the environment to violate the justice of the system represented by the specific jvts cycle node.
with the new assumptions the system can avoid losing in the scenario of the cs represented by the jvts by forcing the environment into the cycle.
example .
fig.
left shows a jvts computed for our running example specification rg1 see sect.
ii .
the jvts has a cycle node in which the justice guarantee just fails.
negating its label creates the candidate repair justice assumption 1 gf r !
c g c v the second loop lines infers safety assumptions from attractor nodes of the jvts that have no outgoing edges by negating the symbolic representation of the label of the node.
the system can avoid losing by forcing the environment into such attractor nodes.
we ignore attractor nodes thathave outgoing edges because they must produce strongerassumptions than the ones generated next from outgoingedges in lines and stronger assumptions are removed byremovestrong in line see bellow .
example .
the jvts in fig left has an attractor without outgoing edges.
negating its label creates the candidate repair safety assumption 2 g r !
c !
v the third loop lines infers safety assumptions from each edge v1 v2 of the jvts.
these assumptions prevent the transition from node v1tov2by negating the conjunction of the symbolic representation of v1with the primed representation of v2 i.e.
the equivalent assertion on successor states that has the system variables quantified out using existential quantification.
the system can avoid the cs by forcing the environment into node v1 and choosing an action that would make the environment respond by trying to enter into node v2.
note that bothv1andv2can be either cycle or attractor nodes.
example .
the jvts in fig left has an edge from the cycle node to the attractor .
this results in the generation ofalgorithm inferassumptionsfromjvts infers candidate repair assumptions from a given jvts.
require a jvts angbracketleftq t i l angbracketright ensure a set of gr assumptions each of which eliminate the cs foreach cycle node v qdo add gf l v tocand end for foreach attractor node v qsuch that v prime q t v v prime do add g l v tocand end for foreach two nodes v1 v2 qsuch that t v1 v2 do add g l v1 prime l v2 y tocand end for return removestrong cand the candidate repair transition assumption 3 g r !c g c v !next c next r finally to avoid redundancy we return only the weaker assumptions in the set cand .
specifically the method removestrong eliminates an assumption from the set iff it implies one of the other assumptions in the set.
since we onlyhave justice and safety assumptions assumption asm 1implies assumption asm 2when the propositional formula of asm implies that of asm and either both asm 1andasm 2are of the same type or asm 1is a safety assumption and asm 2is a justice assumption.
note that by construction all the generated candidate repair assumptions are safety or justice assumptions and in the safety assumptions for transitions only environment variables areprimed since the system variables of v2are quantified out .
thus importantly the candidate repair assumptions we generate respect the restricted structure of individual assumptions in a gr specification.
b. the jvts repair algorithm the assumptions inferred from a single jvts are typically not enough to ensure realizability since they only ensure the elimination of a single cs.
on the other hand adding assumptions may render a satisfiable specification unsat.
algorithm uses the algorithm inferassumptionsfromjvts depicted in alg.
for repair generation.
it is a breadth first search on assumptions generated from jvts css.
for a given unrealizable and sat specification it searches for a set of assumptions that makes the specification realizable while keeping it sat by adding assumption as long as the specification remains unrealizable and sat.
queue is a queue of sets of assumptions which represent repair candidates.
we begin by inserting an empty set tothe queue.
while queue is not empty we remove a repair candidate from it and add the candidate to the specification.
if the refined specification is sat and realizable the candidate is a repair thus it is returned and the search ends.
if the refined specification is sat and not realizable we generate a jvts for the refined specification generate assumptions from it using inferassumptionsfromjvts and add the unions of the candidate with each of them to queue.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm jvts repair computes a repair or fails.
require an unrealizable and satgr specification s ensure gr assumptions that make srealizable and sat if found queue.enqueue whilequeue is not empty do candidate queue.dequeue refined addassumptions s candidate if issatisfiable refined then if isrealizable refined then returncandidate else jvts computejvts refined assumptions inferassumptionsfromjvts jvts forasm assumptions do queue.enqueue candidate asm end for end if end if end while as adding assumptions to a unsat specification cannot make it sat we avoid these search paths.
thus we never return repair candidates that make the specification unsat.
example .
when we run jvts repair on our sat and unrealizable example specification in lst.
it first creates the left hand jvts in fig .
from this jvts it generates the three assumptions 1 2 3. with any of these assumptions the specification remains unrealizable and sat.
the search continues and generates repairs in different ways.
f or example after adding the assumption 2 alg.
line generates the right hand jvts in fig .
from the attractor at the bottom of this jvts it generates the assumption 4 g !
r !
c !
v .
the set 2 4 is a valid repair thus alg.
returns both assumptions to the engineer .
c. termination complexity and soundness algorithm always terminates.
the while loop in line must terminate because queue elements increase in the number of assumptions they contain each additional assumption causes the refined specification in line to be semantically different from the specification without it because it eliminates at least one cs that existed before the assumption was introduced and there is a finite number of specifications for a given set of variables.
this forms a bound on the size of queue elements double exponential in the number of variables as common to all cs based repair approaches and for each size of queue elements there is only a finite number of such elements because the number of assumptions inferred from a jvts line is always finite.
the computation time for each iteration is composed from a sat check a realizability check a jvts computation and a call to inferassumptionsfromjvts .
all these computations are done symbolically.
we performed sat and realizability checks via fixed point algorithms polynomial in the number of assumptions guarantees and state space .
note in particular that the computation of a jvts does not require the costly computation of a concrete cs.
the jvts is usually very small as the number of its cycle nodes is bounded by the number of justice guarantees and there are at most two attractor nodes per cycle node.
accordingly the time and spacealgorithm glass computes a repair.
require an unrealizable and satgr specification s ensure gr assumptions that make srealizable and sat collsat collwinstates g e s logicalandtext i ..ngfje i logicalandtext j ..mgfjs j badenvtrans collsat e s prime collsat y prime prime g badenvtrans if isrealizable addassumptions s prime then return prime end if forjs j jsdo j envwinstates f h e s logicalandtext i ..ngfje i g js j addgf jtoj primeunlessj f end for if isrealizable addassumptions s prime j prime then return prime j prime end if win syswinstates addassumptions s prime j prime prime e s win y return prime prime j prime needed for its computation are usually significantly lower than those of concrete css .
the jvts based repair is sound see check in alg.
l. but incomplete it does not guarantee that a repair would be found.
we evaluate its performance in sect.
viii.
vi.
glass r epair we now present our second main contribution namely a symbolic global assumption glass repair that computes repairs in a global way considering all causes of unrealizability instead of a local way considering the causes exhibited by a cs.
glass addresses reasons for unrealizability on the levels of safety guarantees justice guarantees and initial states by computing respective assumptions that ensure realizability.
glass is sound and complete i.e.
it computes a repair for all sat specifications.
in addition glass does not suffer from the double exponential complexity of cs based approaches see sect.
v c and .
a. algorithm algorithm symbolically computes up to three kinds of assumptions in this order a safety assumption prime a setj primeof up to js justice assumptions and an initial assumption prime.
first alg.
symbolically computes all states collsat from which the system and environment player can collaboratively satisfy all safety and justice assumptions and guarantees.
then it computes all transitions badenvtrans that start from collsat and are legal for the environment e but force all legal system choices e to leave the states collsat .
the removal of these bad environment transitions is the safety assumption prime.
this part is a symbolic version of safety assumption computation from adapted for satisfying all assumptions and guarantees.
example .
no safety assumption is necessary for the specification in lst.
collsat is the set of all states and primein l. introduces no restriction .
consider adding the guarantee g r next v which contradicts guarantee exclude when the system grants and the environment cancels in the next step.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
now alg.
would generate the assumption g g c v next !c which prevents a cancel in the next step after a guarantee.
if the assumption primedoes not make the specification realizable alg.
computes for every justice guarantee js j the states jfrom which the environment can prevent js jwhile satisfying all justice assumptions.
the negations of these states are the justice assumptions j prime.
the new justice assumptions inj primeforce the environment to always eventually leave the states where each js jcan be prevented.
technically the ltl formula in alg.
l. is a sub formula of the negation of sr evaluated inside algorithms for computing gr cs.
also the setjcontains all states from leaf cycle nodes in a jvts.
example .
algorithm computes the justice assumptiongf !c g v c v .
this assumption alone is a repair for the specification from lst.
.
finally if the assumptions primeandj primeare not enough to make the specification realizable alg.
l. restricts the initial environment states to primewhere a legal system choice exists to reach a system winning state i.e.
a state to realize the repaired specification.
all computed assumptions are in gr .
example .
no initial assumption is necessary for the specification in lst.
.
consider adding the initial guarantee v.i n this case alg.
computes the initial assumption !c to avoid violating guarantee exclude in the initial state.
b. soundness completeness and minimality algorithm is sound and complete as stated in thm.
.
theorem .
given an unrealizable and satgr specifications alg.
computes a repair that keeps s sat and makes it realizable.
proof.
the proof shows that each section of alg.
allows the system to realize safety justice and initial guarantees respectively and that each new assumption preserves satisfiability.
see supporting materials for details of the proof .
the time complexity of alg.
is the same as checking gr realizability the evaluations of ltl formulas in l. and l. require at most three nested fixed point iterations with at most x y steps each.
although the assumptions prime prime and each j j prime are minimal see supporting materials already the combination of somej j primemight not be minimal as these sets of states might not be independent.
importantly minimality for the assumptions of glass is defined with respect to realizability from all possible states whereas minimality for repairs can also be seen in a local way as minimal assumptions that allow for realizability from at least one state see sect.
vii a and weakness measures in sect.
ix .
vii.
i mportant extensions and variants a. repair core both jvts repair andglass may yield repairs that are not minimal in terms of the set of assumptions requiredfor realizability i.e.
where the set of suggested assumptions includes a strict subset that is already a repair.
in general we would like to reduce the number of assumptions consisting the suggested repair if possible.
example .
as an example for the specification from sect.
ii the jvts based repair suggested the repair consisting on the set of assumptions 1 2 3 where 2is g !next r r !c v !
r c g and 3is gf c g !
c v which it obtained by first taking the justice assumption 1at level of the search see example and then taking assumptions 2and 3at levels and of the search respectively.
to try to reduce the number of assumptions in the repair we apply the delta debugging algorithm ddmin t o heuristically compute what we call a repair core a locally minimal subset of the assumptions in the suggested repair that suffices to make the specification realizable.
this involves multiple calls to check realizability each with a different subset of additional assumptions.
the correctness of applying delta debugging relies on the following monotonicity adding an assumption to a realizable specification preserves realizability.
example .
back to our last example above when we apply ddmin to 1 2 3 we find that the subset of assumptions 3 is a repair core it is sufficient for realizability and any strict subset of it in this case no assumption at all will not make the specification realizable.
finally although given the suggested repair some assumptions that appear already in the original specification may become unnecessary for realizability we choose not to remove any assumptions but only to suggest new ones to add.
suggesting to remove such redundant assumptions is independent of the repair problem.
in sect.
viii as part of our evaluation we report empirical results on the effectiveness of using the repair core to reduce the size of the repairs we found.
b. dealing with auxiliary v ariables some reactive synthesis tools allow writing specifications that are not pure gr yet reducible to gr specifications e.g.
ones that use ltl specification patterns .
in this case the translation to gr may introduce auxiliary variables which were not explicitly declared in the original specification.
though technically one could use assumptions that include auxiliary variables in a repair such assumptions may not be desirable because the auxiliary variables do not explicitly appear in the original specification and thus are unknown to the engineer who wrote it.
to ensure that we do not generate assumptions with auxiliary variables we quantify them out from all symbolic representations.
4note that we consider a syntactic notion of minimality here related to the number of assumptions in the repair not a semantic one based on implication or weakness see related work discussion in sect.
ix.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
this quantification is performed as follows.
in the jvtsbased repair we existentially quantify auxiliary variables from all node labels before they are used.
in glass we existentially quantify auxiliary variables from any suggested assumption when adding it to the specification.
it is important to note that when auxiliary variables are quantified out some solutions may be lost.
this means in particular that in this case the completeness results in sect.
vi b will not hold.
however the correctness of repairs that are found is not affected in this case i.e.
glass remains sound.
in sect.
viii as part of our evaluation we report empirical results on the effect of quantifying out the auxiliary variables on the ability of glass to suggest a repair.
viii.
e v aluation we have implemented jvts repair andglass in spectra tools based on cudd as a bdd library.
our implementation includes also the computation of concrete cs based on the computation of the jvts based on an implementation of the approach by alur et al.
and the extensions described in sect.
vii.
means to run our implementation all specifications used in our evaluation and all data we report on below are available in supporting materials for inspection and reproduction .
we encourage the interested reader to try them out.
we consider the following two research questions.
how do jvts repair andglass perform and compare to previous repair work in terms of r1.
.
.
the ability to repair?
r2.
.
.
a computation time and b scalability?
below we report on the experiments we have conducted in order to answer the above questions and on additional observations from the results of these experiments.
a. corpus of specifications previous works on repairing unrealizable gr specifications have only used a handful of benchmark specifications for evaluation from which we used the following in our evaluation the request grant specification we used as a running example rg1 taken from a similar smaller request grant specification rg2 taken from and the lift specification lift used in .
we further used different sizes of amba to masters each in the variants of unrealizability described in with a justice assumption removed with a justice guarantee added and with a safety guarantee added i.e.
a total of amba specifications we label amba cimatti .
we have used all these in our evaluation.
on top of these importantly we used the benchmark syntech15 which includes a total of specifications of autonomous lego robots written by 3rd year undergraduate computer science students in a project class taught by the authors of .
out of the specifications in syntech15 are unrealizable but of the are unsat and thus cannot be repaired by adding assumptions .
therefore below we report on the remaining specifications.
we label them syntech15 unreal .from the realizable specifications of syntech15 we produced unrealizable specifications as follows.
for each specification we first found a core of the assumptions that maintains realizability .
recall that removing any assumption from the core makes the specification unrealizable.
from each specification with a core of nassumptions we created n unrealizable variants each of which missing one of the core assumptions.
some specifications had an empty assumption core and thus produced no unrealizable variants.
in this way we produced a total of unrealizable specifications.
out of these specifications were unsat because the original specification was not sat leaving unrealizable repairable specifications.
we label them syntech15 1unreal .
b. v alidation we have systematically and automatically validated the correctness of our implementation by actually adding the computed additional assumptions to the unrealizable specifications they are supposed to repair and by independently checking that the repaired specification is indeed satisfiable and realizable for all the specifications mentioned in this paper.
this validation includes not only our two symbolic repair techniques but also our implementation of the algorithm of alur et al.
.
the validation increases our confidence in the correctness of our ideas and their implementation.
c. experiments setup in all cases we run the three algorithms amt13 our implementation of the algorithm in jvts repair and glass until termination or timeout regardless of repairs found or not.
using amt13 requires setting several parameters see alur et al.
.
since we run until termination or timeout we ignored the parameter.
we chose the parameter according to the heuristic suggested in .
the algorithm also requires the engineer to choose environment variables that appear in repairs we always chose all of them.
using jvts repair andglass requires a decision regarding auxiliary variables.
we chose to quantify them out taking the risk of loosing some solutions see sect.
vii b .
we run all experiments on an ordinary pc intel xeon w2133 cpu .6ghz 32gb ram with windows bit os java 64bit and cudd compiled for 64bit using only a single core of the cpu.
we measured the running time to finding first repair.
we excluded the first check of satisfiability and unrealizability from the measurements as they are common and necessary in all approaches .
we used a fixed timeout of minutes.
we mark timeouts byto.
times we report are average values of runs per specification per algorithm measured by java in milliseconds.
even though the algorithms we deal with are deterministic we performed runs since jvm garbage collection and bdd dynamic reordering add variance to running times.
5note we count repairs by amt13 although they might not be sat.
6since bdd based implementations performance is sensitive to variable order we note that in all our experiments we used cudd s automatic variable reordering.
this is common practice in the literature.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sd z dd z zed hez sd z dd z zed hez fig.
.
total numbers of repaired specifications per algorithm from syntech15 unreal left and syntech15 1unreal right .
sd z dd h fig.
.
computation time to suggesting first repair per algorithm for all syntech15 unreal and syntech15 1unreal specifications broken down into ranges.
d. results ability to repair figure presents the results on syntech15 unreal and syntech15 1unreal .
for each of the three algorithms we show the number of specifications for which at least one repair was found.
the results show that glass is able to repair almost all specifications in syntech15 unreal and syntech15 1unreal .
the cases where it fails to suggest a repair are due only to the introduction of auxiliary variables.
we verified that glass always finds a repair when auxiliary variables are not quantified out.
regarding the two other algorithms we observe that jvts repair is able to repair more specifications than amt13 .
for the amba cimatti specifications glass repaired all but jvts repair andamt13 repaired none.
for all other specifications rg1 rg2 andlift all three algorithms found a repair.
to answer r1 glass repairs all syntech15 unreal and over of syntech15 1unreal .jvts repair repairs while amt13 repairs only of the above specifications.
similar observations hold for the other specifications in the corpus.
e. results computation time and scalability figure shows the computation time of all syntech15 unreal and syntech15 1unreal specifications broken down into several ranges up to .
seconds second seconds seconds more than seconds before timeout and unrepaired either because the search terminated with no repair or because timeout wastable i computation times to first repair in ms per algorithm for selected specifications with growing number of additional system and environment v ariables specification varsadded environment variables added system variables glass jvts amt13 glass jvts amt13 rg1 paper example to to to to to to to to to to to to to lift0 to to to to to to humanoidl tl4580 gyro var17100 to to to to to to to to to to to reached.
evidently glass repairs most of the specifications very quickly while jvts repair does less well which is still significantly better than the amt13 algorithm both in the number of specifications repaired and in the computation time.
to examine scalability we conducted the following experiment.
given a specification we created additional variants with to additional boolean system variables and additional variants with to additional boolean environment variables.
we did not constrain the additional variables in any way.
this results in an exponential inflation of the state space while having no effect on the unrealizability and the correctness of suggested repairs.
we measured the time required to find the first repair.
table i shows the running times for rg1 lift and two syntech15 unreal specifications humanoidltl 458 andgyro var1 710 and their variants.
the lines in the table with a zero value for number of added variables refer to the original specification.
the results show that the glass repair computation time is almost unchanged.
similarly jvts repair computation time is almost oblivious to additional system variables but in most cases goes up rather fast with the addition of environment variables.
finally they show that the computation time of amt13 which is based on a concrete cs scales rather poorly with the addition of either system or environment variables.
finally we performed another experiment for scalability using specifications we call gfcomplete n. these specifications have an integer variable kval in the range ..n andn guarantees of the form gf kval i for i n. the state space in these specifications grows linearly in nrather than exponentially.
figure shows computation time to first repair log scale ofgfcomplete nspecifications for n .
both glass andjvts repair scale well while amt13 grows quickly authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sd z dd fig.
.
computation times to first repair for instances of the gfcomplete n specifications.
note that the graph is in logarithmic scale.
missing graph points foramt13 are due to the algorithm reaching the timeout.
and fails to find a repair within the timeout for the last two specifications.
to answer r2 glass is able to repair almost all specifications within 1s.
jvts repair andamt13 are slower.
glass scales well and seems to be indifferent to additional variables.
jvts repair scales well only for additional system variables.
amt13 does not scale well.
f .
results additional observations number of variables.
in general one may prefer repairs that are simpler to understand.
as a proxy for simplicity we report the number of variables in the repairs we found.
we consider repairs for which all assumptions have up to variables to be small .
we count a variable vif it appears in an assumption.
the algorithms differ significantly in this regard.
glass has small repairs only for of repaired specifications jvts repair has small repairs for of and amt13 has small repairs for all of corpus specifications it repairs.
effectiveness of repair core.
we found that the repair core see sect.
vii a is effective in reducing the size of the repairs.
forglass the repair core is strictly smaller than the initially suggested repair for of the repaired specifications.
for jvts repair the repair core is strictly smaller than the initially suggested repair for of the repaired specifications.
interestingly without repair core computation glass offered small repairs only for of the repaired specifications as opposed to reported above while for jvts repair the difference is insignificant.
additional observations appear in .
g. threats to v alidity we briefly discuss threats to the validity of our results.
internal.
the symbolic computations are not trivial and our implementation may have bugs.
to mitigate this we performed a thorough validation using all specifications available to us see sect.
viii b.external.
first one of the main threats is the fit of the generated assumptions to the real world.
note that this threat equally applies to the previous solutions by alur et al.
and by cavezza and alrajeh .
second we did not perform a user study with engineers to examine whether users will find the repairs useful understand their meaning and indeed add them to their specifications.
third we have based most of our evaluation on specifications from the syntech15 set which were created by 3rd year undergraduate computer science students with no prior experience in writing ltl specifications.
due to the lack of other real world unrealizable specification examples the specifications we used were all unrealizable specifications available to us and ones we have systematically created from the realizable ones.
still note that the scope of our evaluation is much larger than that of similar and competing works on reactive synthesis in general and on repair in particular.
ix.
r elated work a. automatic program repair program repair is an active research area with two main classes of approaches both of which start with a faulty program and a test suite that reveals a defect.
generate and validate approaches explore candidate programs in a search space until a program that passes all tests is found see e.g.
.
semantics driven approaches infer program specifications translate the repair problem into constraints and use solvers to find patches see e.g.
.
a recent tse survey discusses program repair papers more than of which published between and .
almost all focus on imperative languages such as java and c. we are partly inspired by this body of work.
however we do not deal with repairing imperative programs but rather with repairing gr specifications which are temporal declarative specifications for reactive systems.
we focus on repair of unrealizability based on the symbolic generation of new assumptions.
both our jvts based and glass techniques can be viewed as semantics driven repairs as they rely on dedicated symbolic algorithms to solve what can be viewed as a set of constraints.
the iterative nature of the jvts based technique is somewhat similar to a generate and validate approach.
b. repair of gr specifications gr synthesis was introduced in .
it has since been used and investigated by many including e.g.
kressgazit et al.
who used gr in robotics maoz and ringert who showed gr synthesis for specification patterns d ippolito et al.
who used gr to deal with fallible domains and non anomalous event based behavior models and gritzner and greenyer who used scenariobased gr specifications to synthesize executable plc code.
several tools support gr synthesis .
some works deal with unrealizable gr specifications using css and cores but do not consider repair .
below we discuss other works that are most closely related to ours.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
li et al.
suggested mining assumptions from concrete cs of unrealizable gr specifications.
strengthening the specification with these assumptions may make the specification realizable.
their algorithm enumerates constraints following three patterns for gr safety and justice assumptions.
if the cs satisfies the enumerated constraint its negation is added as an assumption that rules out the cs.
li et al.
also suggest using traces of correct behaviors if available to validate candidates.
the generation of constraints is unguided and each requires model checking against an automaton of the cs.
alur et al.
proposed another method for semi automatic strengthening of assumptions.
again they analyze a concrete cs but their instantiation of template based candidate assumptions is guided by the cs.
the work provides limited evaluation over three specifications.
in contrast to and ourjvts repair uses a symbolic cs representation.
we have re implemented the approach from in order to be able to compare it to ours.
our evaluation showed that our symbolic repairs are able to repair many more specifications that cannot and that they are typically much faster.
cavezza and alrajeh proposed the generation of interpolants as a means to compute new assumptions.
similar to this work uses a concrete cs.
the work provides evaluation over two benchmarks lift and amba.
unfortunately we were unable to compile and run an implementation of this approach that we can use to directly compare with our symbolic repairs as we have done with .
however our evaluation includes a comparison of results against the same benchmark specifications reported on in lift and amba .
kuvent et al.
presented the jvts a symbolic representation of css for gr .
the jvts is computed symbolically without the expensive enumeration of concrete states it is much smaller and simpler than its corresponding concrete cs and it is annotated with invariants that explain how the cs forces the system to violate the specification.
using the jvts for repair was suggested as future work in .
our jvts based repair follows this suggestion.
chatterjee et al.
presented algorithms for computing minimal assumptions that repair ltl specifications.
the safety assumption generation of glass repair is inspired by their algorithm but is adapted for the sat specifications and is formulated and implemented symbolically.
unfortunately first the computation of minimal liveness assumptions of i s np hard and second even if provided with these assumptions they cannot be expressed in gr .
most recently cavezza et al.
presented a weakness measure for gr formulas which is based on the hausdorff dimension a concept that captures the notion of size of the omega language satisfying an ltl formula.
the measure provides a means to quantify the quality of a gr specification by measuring how permissive are its assumptions.
as such it may be useful in evaluating and selecting between suggested repairs.
we leave the evaluation and selection between suggested repairs of our symbolic repairs based on this measure and on other criteria see sect.
x to future work.x.
c onclusion and future work we presented two symbolic repair techniques for unrealizable gr specifications.
the first algorithm infers new assumptions based on the recently introduced jvts.
the second algorithm infers new assumptions directly from the specification.
we further extended our work with repair core and with support for specifications that have auxiliary variables.
we implemented our work validated its correctness and evaluated it on benchmarks from the literature including unrealizable specifications of autonomous lego robots syntech15 .
the evaluation shows not only that our symbolic repairs are able to repair many specifications that could not be repaired by previous works but also that their computation is significantly faster and scales better against growing number of variables.
both algorithms are sound.
glass is also complete but generates a single repair.
jvts repair typically generates many suggested repairs.
we consider the following future research.
the fast computation time allows our jvts based repair to effectively generate many rather than only one candidate repairs.
this is a strength of the jvts based approach that is not available in glass and creates an opportunity to select between or prioritize the different candidate repairs based on some criteria.
such criteria may include semantic criteria e.g.
implication or weakness and other criteria that may affect the readability and usefulness of the suggested repairs e.g.
size in terms of number of assumptions and number of variables used in them arguably an engineer will hesitate to use a repair she cannot understand .
above all a suggested repair will not be used if it does not correctly characterize the behavior of the real environment in which the system should run and thus the theoretically weakest or the smallest repairs may not be the best in practice.
we leave this interesting investigation of multiple repairs presentation and criteria for selection and prioritization to future work.
the work is part of a larger project7on bridging the gap between the theory and algorithms of reactive synthesis on the one hand and software engineering practice on the other.
as part of this project we are building engineer friendly tools for writing and understanding temporal specifications for reactive synthesis see e.g.
.