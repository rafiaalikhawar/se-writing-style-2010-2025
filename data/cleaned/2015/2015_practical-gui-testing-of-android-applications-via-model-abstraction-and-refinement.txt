practical gui testing of android applications via model abstraction and refinement 1tianxiao gu1chengnian sun2xiaoxing ma2chun cao 2chang xu2y uan y ao3qirun zhang2jian lu1 4zhendong su 1university of california davis usa3georgia institute of technology usa4eth zurich switzerland 2state key laboratory for novel software technology nanjing university china txgu cnsun ucdavis.edu xxm caochun changxu y.yao lj nju.edu.cn qrzhang gatech.edu zhendong.su inf.ethz.ch abstract this paper introduces a new fully automated modelbased approach for effective testing of android apps.
different from existing model based approaches that guide testing with a static gui model i.e.
the model does not evolve its abstraction during testing and is thus often imprecise our approach dynamically optimizes the model by leveraging the runtime information during testing.
this capability of model evolution significantly improves model precision and thus dramatically enhances the testing effectiveness compared to existing approaches which our evaluation confirms.
we have realized our technique in a practical tool a pe.
on large widely used apps from the google play store a peoutperforms the state of the art android gui testing tools in terms of both testing coverage and the number of detected unique crashes.
to further demonstrate a pe s effectiveness and usability we conduct another evaluation of a peon popular apps where it found unique crashes.
out of the reported crashes have been fixed and have been confirmed.
index t erms gui testing mobile app testing cegar i. i ntroduction mobile application app testing heavily involves human effort .
for example a human tester writes code to simulate gui actions e.g.
clicking a button to drive the execution of android apps .
this process is not only time consuming but also error prone.
moreover when the gui changes the tester has to make nontrivial modifications to their existing test scripts .
to mitigate these problems many automated gui testing techniques have recently been proposed .
automated gui testing for android apps.
monkey a gui fuzzing tool developed by google generates purely random events as test input without any guidance.
thus it does not guarantee steering test exploration to uniformly traverse the guis i.e.
low activity coverage and cannot incorporate user defined rules such as inputting a password or prohibiting logging out.
additionally the generated events are low level with hard coded coordinates and usually excessively long which complicates reproduction and debugging .
to overcome monkey s limitations techniques such as evolutionary algorithms and symbolic execution have been adapted to guide input generation.
however such approaches are computationally expensive and do not yet scale in practice .
an alternative approach for performing android gui testing is model based .
a model is usually a finite state machine where each state has a set of model actions andeach transition between states is labeled with a model action of the source state.
in practice almost no app comes with a model.
existing testing tools thus build a gui based model by abstracting mapping gui actions to model actions and gui views to states respectively.
a model offers at least three types of benefits to gui testing.
first a model can be used to guide the exploitation of an app.
a testing tool can traverse the model using specific guidance to systematically generate action sequences and then replay the action sequences to test the app .
second a model based testing tool generates input sequences composed of high level model actions rather than low level events which can facilitate replaying .
third a proper abstraction can be applied to the model which in turn can help mitigate the explosion of gui actions.
through abstraction many gui actions with the same behavior can be mapped to the same model action.
since these gui actions behave the same the testing tool does not need to exercise each of them and can instead select a representative gui action among them when executing the model action.
state abstraction.
mapping each gui action to a model action is the most critical step in state abstraction.
a state is usually identified by the set of its model actions since states with the same set of model actions can be merged .
all existing model based approaches apply a static abstraction based on certain heuristics throughout the testing of an app.
designing a proper abstraction is challenging.
first if the model is overly fine grained the testing tool cannot systematically explore the model due to state explosion .
second if the model is overly coarse grained the testing tool cannot gather sufficiently accurate knowledge on model actions to realize effective guidance i.e.
difficult to replay model action sequences on the tested app .
in particular an ineffective abstraction may map multiple gui actions with different behaviors e.g.
leading to different target states to the same model action.
therefore a model action cannot be replayed as expected if the testing tool chooses a gui action behaving differently from the one chosen during model construction.
accordingly all subsequent actions in the sequence depending on the model action can neither be successfully replayed.
our approach.
this paper proposes a pe a new practical model based automated gui testing technique for android apps via effective dynamic model abstraction.
at the beginning a default abstraction is used to initiate the testing ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
process.
this initial abstraction may be ineffective.
based on the runtime information observed during testing a pe gradually refines the model by searching for a more suitable abstraction an abstraction that effectively balances the size and precision of the model.
this dynamic nature distinguishes our approach from all existing state of the art techniques as they rely solely on static abstractions.
instead of operating on a fixed abstraction granularity our approach dynamically adjusts the granularity as needed.
specifically a perepresents the dynamic abstraction with a decision tree and tunes it on the fly with the feedback obtained during testing.
this decision treebased representation of model abstractions greatly improves testing effectiveness as demonstrated in our comprehensive evaluation section iv .
we compared a pe with the state of art testing tools i.e.
monkey s apienz and s toa t on large widely used apps from the google play store.
a pe complements the state of art tools see section iv c .
a peachieved higher code coverage and detected more unique crashes i.e.
unique stack traces defined in section iv c than the other tools on the benchmark apps.
specifically a peconsistently resulted in and relative improvements over the three tools in terms of average activity coverage method coverage and instruction coverage respectively.
though these apps have been well tested within one hour apemanaged to find unique crashes by testing their guis whereas monkey found s apienz and s toa t .
to further demonstrate the usability and effectiveness of a pe w e conducted another large scale evaluation on apps from the google play store.
a pefound crashes from apps in total.
we reported crashes to developers with detailed steps to reliably reproduce these crashes where crashes have already been fixed and crashes have been confirmed fixes pending .
contributions.
this paper makes the following contributions we propose a novel fully automated model based technique for android gui testing.
the major difference of our approach from existing techniques is the ability to dynamically evolve gui models toward ones that discard all irrelevant gui details while faithfully reflect the runtime states of the app under test.
we realize dynamic model abstraction via a novel type of decision trees which can expressively represent a wide range of abstractions and thus enables a peto effectively dynamically refine and coarsen abstractions to balance model precision and size.
our extensive evaluation demonstrates that a pe outperforms the state of the art tools.
it can automatically explore many more guis i.e.
activities than the other tools.
therefore according to our evaluation results it not only increased code coverage but also found more unique crashes.
we implement the proposed technique into a practical tool a pe and make it publicly available.
organization.
the remainder of this paper is organized as follows.
section ii introduces necessary background.
section iii presents the approach.
section iv details our extensive evaluation.
section v surveys related work and section vi concludes.
ii.
b ackground this section introduces relevant background on model based android gui testing and its challenges.
a. gui of android apps in an android app an activity is a composition of widgets .
these widgets are organized into a tree like structure named gui tree in this paper .
a widget can be a button a text box or a container with a layout.
it supports various gui actions such as clicking and swiping.
a widget has four categories of attributes describing its type e.g.
class appearance e.g.
text functionalities e.g.
clickable and scrollable and the designated order among sibling widgets i.e.
index .
each attribute is a key value pair.
we use i c andtto denote the key of an index class and text attribute respectively.
for example an index attribute whose value is can be denoted by i .
a b ... ... listview textview xlsx textview pptx textview docx ...ti wi wi wi wi c ... ... listview textview docx textview xlsx textview pptx ...tj wj wj wj wj d fig.
figs.
1a and 1b are two gui snapshots of google drive.
figs.
1c and 1d are their corresponding gui trees.
a gui tree tis a rooted ordered tree where each node wis a gui widget that has a set of attributes denoted by attributes w .
the android sdk has provided a tool to obtain the gui tree of an activity.
figs.
1c and 1d show authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the corresponding simplified gui trees for figs.
1a and 1b respectively.
since only bold parts are of interest in this paper we assumed that tiandtjare rooted at wi 0andwj respectively.
b. attribute path a testing tool needs to properly identify widgets to accumulate testing knowledge on them.
the memory address of the runtime object representing the widget cannot be used to identify the widget because the same gui may be created and disposed many times.
in a gui tree t given a widget wn anode path angbracketleftw1 w2 wn angbracketrightis a sequence of tree nodes i.e.
widgets that are on the traversal path from one of its ancestors w1town.
this node path is referred to as anabsolute node path if the first node w1is the root of the tree and otherwise a relative node path which is similar to the concept of absolute and relative file paths in file systems.
an absolute node path uniquely identifies a widget in the tree.
for example wi s unique node path in fig.
1c is angbracketleftwi wi angbracketright.
definition attribute path given a widget wnand one of its node paths angbracketleftw1 w2 wn angbracketright an attribute path angbracketlefta1 a2 an angbracketrightis a projection of such that n i 1ai attributes wi .
that is each aiis a subset of the attributes of the corresponding widget wi.
definition full attribute path an attribute path angbracketlefta1 a2 an angbracketrightis a full attribute path if its angbracketleftw1 w2 wn angbracketrightis an absolute node path and n i 1ai attributes wi .
to distinguish from an arbitrary attribute path we use to denote a full attribute path.
in this paper a widget can be uniquely identified in the tree by its full attribute path because the order of the widgets on the full attribute path resembles the hierarchy of widgets in the tree and the index attribute of each widget determines the unique location of the widget among its siblings.
therefore a gui tree tcan essentially be represented with and is equivalent to the set of full attribute paths of all its widgets.
table i shows the full attribute path for each widget in fig.
.
definition attribute path reduction an attribute path reducer is a function rthat takes as input an attribute path angbracketlefta1 a2 an angbracketright and returns a new attribute path prime angbracketleftbm bn angbracketright such that m n n i mbi ai.
in other words primeis a suffix of and each element of primeis a subset of the corresponding element of .
widget assumption.
a gui action is identified by its widget and action type i.e.
angbracketleft angbracketright.
for a simpler presentation we assume that every widget supports only one gui action and omit action types and functionality attributes throughout the paper.
the relation between widgets and gui actions becomes bijective and we use them i.e.
and angbracketleft angbracketright interchangeably.
note that this assumption is for illustration only our technique also supports widgets with multiple actions by using functionality attributes see section iii b .gui model abstractionexploration strategy model based t esting t oolappinject events dump a gui tree fig.
the typical workflow of model based gui testing.
c. model based android gui testing fig.
depicts the typical workflow of a model based testing tool .
such a tool interacts iteratively with the app under test.
initially the testing tool starts with an empty state machine as the model.
during each iteration the testing tool obtains the current gui tree of the app identifies an existing corresponding state or creates a new state for this gui tree and picks a model action and determines a concrete gui action to interact with the app.
a model based testing tool aims at exploring the app to discover new widgets and exploiting the app to exercise interactions among the discovered widgets.
in practice modern android apps usually have a large number of widgets.
to mitigate this scalability challenge a model based testing tool further attempts to identify equivalent gui actions and abstract them to a same model action to reduce the search space.
however it is nontrivial to determine whether two widgets are equivalent.
a full attribute path usually contains irrelevant information which prevents two semantically equivalent widgets from being discovered.
for example wi 1in fig.
1c andwj 2in fig.
1d are essentially equivalent but have different full attribute paths as shown in table i. relying solely on full attribute paths a testing tool will view the two widgets differently and the model size is consequently increased.
state abstraction.
state abstraction refers to the procedure that identifies equivalent gui trees and actions and maps them to the same state and the same model action respectively.
in general state abstraction is realized based on the similarity of full attribute paths of gui actions .
specifically state abstraction determines two gui actions as equivalent if they have the same action type and their full attribute paths can be reduced to the same attribute path by removing irrelevant attributes under certain reduction rules.
the corresponding model action is denoted as angbracketleft angbracketright when action type is considered .
similarly state abstraction determines two gui trees as equivalent if all of their gui actions can be reduced to the same set of attribute paths.
the corresponding model state is denoted as the set of all model actions i.e.
the set of attribute paths .
however an automated testing tool has no prior knowledge of the apps under test and can only define reduction rules heuristically.
note that a testing tool can apply different reductions to different widgets to achieve a proper abstraction granularity.
for example s toa t assumes that child widgets of listview behave equivalently and realizes this heuristic in its state abstraction.
specifically s toa t removes all attributes from child widgets of listview and removes only types and texts from other widgets.
for the examples in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able i model actions i.e.
reduced attribute paths by different abstractions.
tree widget full attribute path stoa t amola c lv4 amola c lv5 text only tiwi angbracketleft i c lv t angbracketright angbracketleft i angbracketright angbracketleft i angbracketright angbracketleft i t angbracketright angbracketleft i angbracketright wi angbracketleft i c lv t i c tv t xlsx angbracketright angbracketleft i angbracketright angbracketleft i i angbracketright angbracketleft i t i t xlsx angbracketright angbracketleft i t xlsx angbracketright wi angbracketleft i c lv t i c tv t pptx angbracketright angbracketleft i angbracketright angbracketleft i i angbracketright angbracketleft i t i t pptx angbracketright angbracketleft i t pptx angbracketright wi angbracketleft i c lv t i c tv t docx angbracketright angbracketleft i angbracketright angbracketleft i i angbracketright angbracketleft i t i t docx angbracketright angbracketleft i t docx angbracketright tjwj angbracketleft i c lv t angbracketright angbracketleft i angbracketright angbracketleft i angbracketright angbracketleft i t angbracketright angbracketleft i angbracketright wj angbracketleft i c lv t i c tv t docx angbracketright angbracketleft i angbracketright angbracketleft i i angbracketright angbracketleft i t i t docx angbracketright angbracketleft i t docx angbracketright wj angbracketleft i c lv t i c tv t xlsx angbracketright angbracketleft i angbracketright angbracketleft i i angbracketright angbracketleft i t i t xlsx angbracketright angbracketleft i t xlsx angbracketright wj angbracketleft i c lv t i c tv t pptx angbracketright angbracketleft i angbracketright angbracketleft i i angbracketright angbracketleft i t i t pptx angbracketright angbracketleft i t pptx angbracketright lv andtv are abbreviations for listview andtextview respectively.
fig.
s toa t maps all child widgets of listview to the same model action i.e.
angbracketleft i angbracketright .
as shown in table i and fig.
3a s toa t assigns both figs.
1a and 1b to the same state i.e.
since they have the same set of model actions.
in contrast amola supports five static abstractions and its c lv5 criterion takes into account both the indices and text content and identifies a model action for each widget.
as shown in table i and fig.
3c amola assigns figs.
1a and 1b to two states i.e.
3and respectively.
1wp x angbracketleft i angbracketright 2wp x angbracketleft i i angbracketright angbracketleft i i angbracketright angbracketleft i i angbracketright 5wp x angbracketleft i t docx angbracketright angbracketleft i t pptx angbracketright angbracketleft i t xlsx angbracketright x pw angbracketleft i t i t xlsx angbracketright angbracketleft i t i t pptx angbracketright angbracketleft i t i t docx angbracketright angbracketleft i t i t docx angbracketright angbracketleft i t i t xlsx angbracketright angbracketleft i t i t pptx angbracketright a s toa t b amola c lv4 c amola c lv5 d text only fig.
partial models.
each circle is a state and each edge is a state transition labeled with a model action.
states w xand pare w.r .t.
gui trees of file viewers for docx xlsx and pptx respectively.
other states are w.r .t.
gui trees in fig.
.
model actions of listview i.e.
wi 0andwj are omitted.
a good state abstraction should balance trade offs between the model size and model precision.
on one hand the state abstraction should be coarse to avoid state explosion by tolerating differences of guis that are irrelevant to testing.
for example amola builds very fine grained models but the models can quickly explode in size as they incorporate much testing irrelevant gui information.
in constrast s toa t does not have this problem as it builds a coarse grained model.
on the other hand the state abstraction should precisely model the runtime states of an app in order to interact with the app.
for example amola c lv4 keeps indices only and thus can distinguish different file items in the same gui but not among different guis.
s toa t cannot distinguish different file items even in the same gui.
as shown in fig.
3a the model action angbracketleft i angbracketrightactually represents a set of inequivalent widgets and leads to three different target states i.e.
w xand p .
when the guidance in s toa t prompts it to open a docx file i.e.
reach the state w the actuallyopened file may be pptx or xlsx i.e.
the actual target states may be xor p .
this divergent behavior will misguide the testing tool.
a proper way to identify model actions here is to include the file name text only.
this state abstraction identifies three actions and a single state i.e.
5in fig.
3d for guis in figs.
1a and 1b and also avoids mapping inequivalent widgets to the same model action.
unfortunately none of the existing techniques supports such a proper abstraction.
to address these difficulties we propose a technique that can dynamically optimize the abstraction during testing.
specifically we start the testing from a default abstraction.
during the testing we systematically and efficiently improve the abstraction toward the one that balances the size and precision of the model.
iii.
a pproach a. model definition model a model m in a pe is a tuple s a t l where s the set of states.
s s is a set of attribute paths.
a the set of model actions.
each model action a is an attribute path and a uniontext s ss.
t s a s the set of state transitions.
each transition s s prime has a source state s a target state s prime and a transition label that is a model action .
l the abstraction function which reduces a full attribute path to an attribute path i.e.
l .
we also record every gui transition between iterations.
each gui transition is a tuple of t t prime wheretandt primeare gui trees and is the chosen gui action for simulation.
to facilitate presentation we derive two variants from l llandll to process a gui tree and a gui transition respectively.
given a gui tree t i.e.
a set of full attribute paths llcan be used to find its corresponding state s s ll t l t .
and given a gui transition t t prime llcan be used to find its corresponding state transition s s prime s s prime ll t t prime ll t l ll t prime .
algorithm sketches the workflow of model based testing shown in fig.
.
initially the model m is empty.
at the beginning of each iteration sand refer to the state and the chosen model action in the previous iteration.
next authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm model construction.
input testing budget b initial abstraction function l. output the model m. m s l initialization.
2whileb 0do 3b b decrease the testing budget.
4t prime captureguitree useuiautomator .
5m uptandoptmodel m s t prime see algorithm .
6s ll t prime get the current state.
7 selectandsimulateaction s see section iii d. 8returnm function uptandoptmodel adds the state ll t prime and the state transition s ll t prime to the model and also attempts to optimize the model as needed.
finally we update s with the current state ll t prime and determine a new model action onll t prime .
the model action is determined with the function selectandsimulateaction which will be informally described in section iii d. when executing w e first determine a set of gui actions that map to i.e.
t l and then randomly choose one of them to simulate.
b. dynamic abstraction functions as aforementioned in section i the key novelty of a peis its dynamic abstraction function that can dynamically adapt change the model abstraction to balance model precision and size based on runtime information.
however realizing dynamic abstraction functions is nontrivial.
first a dynamic abstraction function should be adaptable at runtime.
all previous approaches use a statically crafted abstraction function with a fixed abstraction granularity.
hence adapting the abstraction needs to change the source code implementing the static abstraction function.
second a dynamic abstraction function should be generalizable .
for the examples in fig.
an abstraction function should apply to not only tiandtj but also any gui trees after reordering files.
we cannot simply use a hash map between full attribute paths and attribute paths as the abstraction function because new gui trees and new attribute paths are continuously being discovered when the testing progresses and they are not in the hash map of such an abstraction function.
third a dynamic abstraction should also behuman interpretable so that users can incorporate critical rules to further improve the dynamic abstraction.
different from existing approaches we represent an abstraction function as a decision tree that determines a reducer for a given .
a decision tree is a rooted tree where each node is a reducerrand each edge branch is labeled with an attribute path .
here is called the selector of the branch.
selector.
a branch selects a full attribute path if can be reduced to the selector of the branch.
given a gui tree t selects a set of full attribute paths in tthat can be reduced to i.e.
t r r .
decision procedure.
to determine the reducer for the given we start from the root node of the decision tree and check whether can be selected by any branch of the current node.
if yes we move to the target node nof the branch and continueto recursively check the branches of n. otherwise the reducer ofnis used as the output to reduce .
andnis referred as output node in later discussions.
as a function an important property of the decision tree is that it should determine one and only one reducer for .
to guarantee this property we enforce that any must be selected by at most one branch.
reducer.
a reducer is the aggregation of a set of primitive reducers .
we first define two types of primitive reducers.
definition local reducer letadenote a set of attribute keys.
given a full attribute path angbracketlefta1 a2 ... a n angbracketright a local reducer raremoves a1 a2 ... a n 1and retains attributes in aforan.
ra angbracketleft k v k v an k a angbracketright in this paper we use four types of local reducers rcto select the type attributes rtto select the appearance attributes ri to select the index attribute and r to select no attribute.
definition parent reducer given a full attribute path angbracketlefta1 a2 ... a n angbracketright a parent reducer rpreuses the output of the parent full attribute path angbracketlefta1 a2 ... a n angbracketrightand retains nothing for an.
rp l angbracketlefta1 a2 ... a n angbracketright r where is the concatenation of sequences.
definition reducer aggregation given a full attribute path angbracketlefta1 a2 ... a n angbracketrightand two reducers randr prime suppose thatr angbracketleftbm bm ... b n angbracketright r prime angbracketleftck ck ... c n angbracketright andm k. the aggregation r multicloseright multicloseleftr prime is the reverse elementwise union of r andr prime r multicloseright multicloseleftr prime angbracketleftbm bm ... b k ck bk ck ... b n cn angbracketright.
we have defined five primitive reducers in this paper and obtain 24reducers in total denoted by r sincer multicloseright multicloseleftr r. we also define a partial order over all reducers in r.w es a y that a reducer r primeis finer than another reducer r i.e.
r prime r ifr primeconsists of more primitive reducers than r. multiple action types.
recall that we have assumed that a widget supports only one action type in section ii a. to support multiple action types we can represent a gui action as angbracketleft angbracketrightand a model action as angbracketleft angbracketright.
a selector selects all angbracketleft angbracketrightin which can be reduced to .
the decision tree can still be used to realize l angbracketleft angbracketright angbracketleft angbracketright.
ri multicloseright multicloseleftrp rp angbracketleft c lv angbracketright fig.
the decision tree of s toa t s abstraction function ls .
example.
the decision tree in fig.
implements s toa t s abstraction function denoted by ls which we will use as the starting abstraction function to illustrate dynamic optimization of our approach in section iii c. take widgets wi 0andwi 1in fig.
1c as examples.
lsassignsri multicloseright multicloseleftrptowi 0becausewi isnot a child of a listview and cannot be selected by angbracketleft c lv angbracketright.lsassignsrptowi 1becausewi 1is a child of alistview and can be selected by angbracketleft c lv angbracketright.
since wi 0is the root and has no parent rpselects nothing for it.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the attributes path of wi 0is actually created by ri which is angbracketleft i angbracketright.
sincewi 1is a child of wi rpreuses angbracketleft i angbracketrightfor wi .
the final attribute path of wi 1is angbracketleft i angbracketright.
c. optimizing abstraction functions ape starts with an initial abstraction function and continuously refines and coarsens the abstraction function toward a proper model precision.
specifically refinement either replaces the reducer rof certain leaf output node in the decision tree with a not coarser reducer r prime i.e.
r prime negationslash r or inserts a new branch with a finer reducer r prime i.e.
r prime r to certain output node while coarsening reverts the current abstraction function lto the previous one l primethatlis refined from.
hence the initial abstraction function represents the lower bound of abstraction and should be coarse enough.
an extremely coarse abstraction function would map all gui actions to the same model action and all gui trees to the same state.
such a function builds a very simple model and this model does not have non deterministic transitions because every gui tree is mapped to the same state.
to avoid this trivial case we first refine the abstraction function until no model action abstracts more than gui actions.
second a state transition s s prime isnon deterministic if there is another transition s s prime prime wheres prime negationslash s prime prime.
such a pair of nondeterministic transitions usually indicates that the abstraction of the source state sor the model action is overly coarse and needs to be refined.
hence we refine the abstraction function aiming at eliminating every non deterministic transition.
third the previous refinement monotonically increases the model size and may eventually lead to a state explosion.
thereby we revert the abstraction function lto the previous one l primeif lrefines a state created by l primeinto new states.
here and are two configurable threshold values.
ri multicloseright multicloseleftrpls rp angbracketleft c lv angbracketrightri multicloseright multicloseleftrpl1 rp ri multicloseright multicloseleftrp angbracketleft c lv angbracketright angbracketleft i angbracketrightri multicloseright multicloseleftrpl2 rp ri multicloseright multicloseleftrt multicloseright multicloseleftrp angbracketleft c lv angbracketright angbracketleft i angbracketrightri multicloseright multicloseleftrpl3 rp rt multicloseright multicloseleftrp angbracketleft c lv angbracketright angbracketleft i angbracketright1 fig.
example of the optimization of abstraction functions.
example.
fig.
depicts the evolution from stoat s abstraction function lsto the text only abstraction function i.e.
l3 discussed in section ii c. as shown in table i and fig.
3a suppose that a pe visits the model action angbracketleft i angbracketrightonly twice on tiandtj and simulates two gui actions to click widgetswi 2andwj respectively.
since clicking wi 2andwj leads to two different target states i.e.
pand w a pecan detect that angbracketleft i angbracketrightis non deterministic.
suppose that a pe prefers to use ri multicloseright multicloseleftrpto refine angbracketleft i angbracketrightand mapwi 2andwj to angbracketleft i i angbracketrightand angbracketleft i i angbracketright respectively.
since the initial decision tree may incorporate user defined rules a pe does not modify its nodes i.e.
rectangle nodes and inserts a new branch into lsto createl1.l1only temporally eliminate the non deterministic transitions because a pe cannot detectthat angbracketleft i i angbracketrightor angbracketleft i i angbracketrightis non deterministic when both angbracketleft i i angbracketrightand angbracketleft i i angbracketrighthave a single transition each i.e.
by clicking wi 2andwj respectively.
a pe will detect the non determinism see fig.
3b when there are more transitions.
suppose that a pe further refines l1tol2 with a finer reducer ri multicloseright multicloseleftrt multicloseright multicloseleftrp.
similar to amola clv5 l2cannot tolerate file reordering and leads to the state explosion.
then a pe revertsl2tol1and blacklists l2.a later refinement will refine l1tol3 the text only abstraction discussed in section ii c. algorithm update and optimize the model.
1function uptandoptmodel m s a t l s t prime input the new gui tree t prime the model m s a t l the previous state s and the previous action .
output the new model.
2s prime ll t prime 3m s s prime a s prime t s s prime l repeatm actionrefinement m t prime untilm is not updated 5m statecoarsening m t prime return staterefinement m s s prime 7function actionrefinement m s a t l t prime foreach prime ll t prime do if l prime t prime then r getreducer prime foreachr prime r prime r prime r r negationslash r prime do l prime l r r prime l r prime r prime l prime l prime t prime if 1then return rebuildmodel m ll t prime l prime returnm 17function statecoarsening m s a t l t prime 18l prime getprev l 19s ll t t ll prime ll prime t prime if s then return rebuildmodel m s l prime else return m 21function staterefinement m s a t l s s prime foreach s s prime prime s s prime prime s s prime prime t s prime prime negationslash s prime do foreach prime sdo r getreducer prime foreachr prime r prime r prime r r negationslash r prime do l prime l r r prime l r prime r prime s1 ll prime t t t prime ll prime s s prime s2 ll prime t t t prime prime ll prime s s prime prime ifs1 s2 then return rebuildmodel m s l prime returnm we use three requirements with threshold and to measure the balance between model precision and model size.
no model action abstracts more than gui actions in a gui tree meaning that we should refine each model action until it abstracts fewer than gui actions.
non deterministic transitions should be as few as possible meaning that we should keep optimizing the abstraction function until no non deterministic transition can be eliminated.
no model state created by a previous lis refined into new states by the refined version of l. algorithm aims at balancing the model precision and size.
we first introduce inverse mappings to facilitate explaining it.
l is the set of gui actions that are abstracted to .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ll s is the set of gui trees that are abstracted to s. ll s s prime is the set of gui transitions that are abstracted to s s prime .
function uptandoptmodel first adds the new state s prime and transition s s prime into the model.
then it checks whethers primeand s s prime violates any requirements and if yes further attempts to optimize s primeand s s prime to incrementally optimize the model via function actionrefinement staterefinement andstatecoarsening .a pekeeps using the model if it fails to optimize s primeor s s prime .
action refinement.
function actionrefinement refines each model action that abstracts more than gui actions in the gui tree t prime i.e.
l prime t prime .
for such a prime the function tries to find a new abstraction function that refines prime into multiple model actions.
function getreducer returns the reducer rthat creates prime.
since any reducer r primethat is not coarser than r i.e.
r prime negationslash r may refine prime a new abstraction function is created by either replacing rwith a not coarser r prime denoted by l r r prime or appending a new branch with a finerr primeto the output node of r denoted by l r prime r prime .
ifl primerefines primeinto multiple model actions we replace l byl primeand rebuild the model accordingly.
since we only do replace on leaf nodes and append at most one branch a time no node can be selected by multiple branches.
the refined decision tree still guarantees to be a valid function.
function rebuildmodel takes the current model the set of affected states and the new abstraction function as input removes all affected model actions states and transitions and applies the new abstraction function to re add states and transitions for all affected gui trees and gui transitions.
since the model may be rebuilt s primeat line may be stale.
hence function actionrefinement repeats until m is not updated i.e.
no model action needs refinement.
state coarsening.
function statecoarsening applies a previous ll primetot primeto obtain the old state ll prime t prime retrieves all gui trees that can be abstracted to the old state i.e.
ll prime ll prime t prime obtains the current states sof these gui trees and reverts ltol primeif s which means l is much finer than l prime.
state refinement.
to eliminate non deterministic transitions s s prime and s s prime prime function staterefinement tries to refine each model action of sfollowing the same steps asactionrefinement except that l primemust refine sto different states or refine to different model actions.
we have implemented the latter case but omit its details in algorithm since it is just a variant of actionrefinement .
parameter selection.
a model action will be refined if it leads to non deterministic transitions no matter what is.
the threshold is set to which is good in practice.
if is too large the exploration strategy should sample each model action more times.
if is too small the testing tool cannot tolerate minor differences.
the threshold is calculated based on the number of primitive reducers of the finest reducer in the decision tree.
the largest value of is by default.
algorithm decisions.
when two refinements can both eliminate the non deterministic transitions we prefer the refinementthat creates fewer states and then fewer model actions in the new model at first e.g.
prefer l1tol2in fig.
.
since refinement may conflict with coarsening the strictly balanced model under and may not even exist.
when the conflict arises we prefer coarsening to suppress the state explosion because the corresponding guis have been explored sufficiently when the explosion is detected.
d. exploration strategy we propose to combine random and greedy into the depth first search.
first we found that some non determinism can be tolerated by keeping the locality of the exploration.
for example a pecan tolerate non determinism caused by access time via keeping clicking the same file in fig.
.
hence we discover connected sub graphs and try to explore all model actions in a connected sub graph before jumping to other states.
next we only greedily visit every newly added unvisited model action where model actions are matched by their attribute paths.
third we randomly visit other model actions and give a higher priority to model actions that are not visited or abstract more gui actions.
when failing to replay a transition a pedetaches the target states to avoid unnecessary replaying attempts.
when reaching the state again by random actions a peattaches the state to the model again.
hence a pe evolves not only state abstraction but also state connectivity.
e. implementation apeis built on top of monkey and runs on both emulators and real devices.
it is designed to be a drop in replacement of monkey and requires no customization of both the app under test and android devices.
we have tested a pe s compatibility on android and devices because they dominate the market share when we started to develop a pe .
gui trees are dumped with the accessibility api the same one used in .
the initial decision tree uses rcfor every widget.
initially there is only one decision tree for all states.
if a state needs refinement we build a new decision tree for it in a copyon write manner.
hence we can apply different abstractions to widgets with the same full attribute paths when necessary.
iv .
e v alua tion we evaluate a peon widely used apps from the google play store and compare it with three state of art testing tools i.e.
monkey s apienz and s toa t .
on average a pe achieved higher code coverage and detected more crashes than all the others.
specifically a pe consistently resulted in and relative improvements over the other three tools in terms of average activity coverage method coverage and instruction coverage respectively.
moreover apedetected crashes while monkey detected s apienz and s toa t .
to further demonstrate a pe s usability and effectiveness we applied a pe to test apps in the google play store for minutes each.
a pe detected unique crashes in error types from of apps.
we reported crashes to developers with steps to reproduce the crashes where have been already fixed and have been accepted fixes pending .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a. experimental setup setup.
all tools can test apps directly without any modification to the apps and android.
however the publicly available version of s apienz only supports android .
emulators and therefore we ran all comparative experiments on emulators.
we ran s apienz and s toa t on the same version of android i.e.
android .
as described in respectively and ran a pe and monkey on android .
all emulators were run on a macbook pro intel core i7 .
ghz 16gb mac os .
.
we ran all tools with their default configurations.
for monkey and s apienz we additionally followed previous work to set a milliseconds delay.
we reused artifacts released by s toa t and pushed them to emulators before testing each app.
we followed previous work to give all testing tools except s toa t an hour to test each app.
we gave s toa t an hour for model construction and two additional hours for model based fuzzing to assess its full capability.
each experiment was repeated five times.
we report the average coverage and total crashes in five runs.
the method and instruction coverages were collected every minute using our vm based tracing tool.
benchmark collection.
we selected widely used apps that are compatible with x86 emulators as shown in table ii.
specifically we first randomly selected apps from the editor s choice collection of the google play store 2where four apps were also used by .
second we randomly selected another four well maintained i.e.
updated since opensource benchmark apps used by s apienz and s toa t .
t able ii statistics of benchmark apps.
application activity method instruction install citymapper duolingo flowx google drive google translate nuzzel day fitness zillow flipboard vlc tunein radio amaze book catalogue any memo my expenses b. coverage of benchmark apps as shown in table iii a pe is clearly the most effective tool among the four in terms of coverage.
specifically a pe achieved the best per app coverage on almost all apps and consistently resulted in and relative improvements over the other three tools in terms of average activity coverage method coverage and instruction coverage respectively.
moreover the coverage of a pealso grows much faster than the other three tools as shown in fig.
.
for s toa t we reported data in both model construction and the entire choicet able iii results on benchmark apps.
activity method instruction crashes ape mo sa st1ape mo sa st1st3ape mo sa st1st3ape mo sa st1st3 mo sa and st are abbreviations for monkey s apienz and s toa t respectively.
st1 and st3represent data in the model construction and the entire testing respectively.
testing.
s toa t did not report covered activities during modelbased fuzzing because s toa t has an internal null intent fuzzer which directly starts activities with empty intents.
in practice stoa t can achieve activity coverage on emulators.
due to the intrusive null intent fuzzing s toa t always resulted in not responding on three apps and .
hence the average coverage of s toa t counted apps.
all tools obtained relatively low coverage on some apps e.g.
app and .
the reason is that a proper environment is needed to further improve the coverage.
for example app requires premium user accounts to unlock certain functionalities.
editor s choices open source allape monkey sapienz stoa t fig.
progressive instruction coverage.
x axis is time in minutes and y axis is instruction coverage.
c. detected crashes of benchmark apps we counted only fatal errors that crashed app processes during gui exploration.
this is different from the evaluation method of s toa t .
first s toa t counted as crashes many exceptions that do not terminate app processes e.g.
window leaked exceptions .
second s toa t also targeted to detect crashes that were triggered by null intent fuzzing in addition to gui testing.
we believe that the class of crashes found by gui testing is more important than that found by null intent fuzzing because the former class can usually be triggered with legitimate user interactions whereas the latter class has been largely prohibited by certain security mechanisms on real devices and is mostly reproducible on emulators only.
moreover the results of our evaluation method are also consistent with their latest study .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able iv crashes detected by gui testing.
tooljava exceptions native crashes all br uc ba br uc ba br uc ba ape monkey sapienz stoa t14 stoa t3315 br uc and ba are abbreviations for bug reports unique crashes and buggy apps respectively.
we show statistics of crashes detected by gui testing in table iv.
a pedetected the most unique crashes by gui testing.
to identify unique crashes we followed s toa t to use the full normalized stack traces i.e.
stack traces without irrelevant information such as messages of exceptions or pid of processes .
since benchmark apps were developed in java native crashes were mostly triggered by defects of the framework rather then the apps.
for example almost a half of native crashes detected by a pe monkey and s apienz were caused by some defect of the webview .
ape monkey a android .0sapienz stoat b android .
fig.
pairwise comparison of unique crashes stack traces .
nullpointerexceptionnative indexoutofboundsexceptionillegalstateexception numberformatexceptionillegalargumentexceptionsqliteexception notserializableexception010203033 1crashes nullpointerexceptionnative classcastexception outofmemoryerror indexoutofboundsexception concurrentmodificationexceptionruntimeexception numberformatexception illegalargumentexceptionsqliteexception051013 nullpointerexceptionnative classcastexception xmlpullparserexception concurrentmodificationexceptionarrayindexoutofboundsexceptionsecurityexception noclassdeffounderror indexoutofboundsexceptionillegalstateexception05101517 2221111crashes nullpointerexception illegalargumentexception numberformatexceptionrx.b.j securityexception illegalstateexception notserializableexception0510152022 321111ape monkey sapienz stoa t fig.
distribution of crashes types by gui testing.
fig.
depicts the pairwise comparison of unique normalized stack traces for tools on the same version of android.
we do not compare crashes detected by tools on different versions of android via normalized stack traces because different versions of android have different android framework code.
particularly android .
employs the dalvik vm while android .
employs the art runtime .
the two runtime environments have different thread entry methods.
based on data in figs.
and each of the compared tools complements the others in crash detection and has its own advantages.
ape.apecan exhaustively exercise parts of the app locally and also discover more activities than the other tools with adynamic gui model.
for app a pedetected more crashes than others because to trigger these crashes it needs to navigate in the file system thoroughly to search for some particular files and then make some complicated interactions on the files.
this requires that the model should be fine enough otherwise the searching of the file may terminate prematurely.
for app ape detected a crash on an activity that was not discovered by all other tools in five runs.
stoat .stoa t supports the most types of events and can find deep crashes via model based fuzzing .
we plan to incorporate the powerful fuzzing strategy of s toa t into a pein future work.
due to the limitation of its implementation s toa t did not detect crashes triggered via out of order events as the other three tools.
monkey.
monkey spent almost all testing budgets to generate events e.g.
no restart and no model construction.
hence monkey detected some crashes that can only be triggered under certain stress.
as shown in fig.
only monkey has detected six outofmemoryerror .
sapienz .sapienz inherits from monkey the same ability to trigger some particular types of crashes .
for example monkey and s apienz found many classcastexception andconcurrentmodificationexception where all of them were triggered via trackball and directional pad events.
however these crashes are not important because trackballs and directional pads are generally not available on modern android phones.
moreover s apienz aims at minimizing event sequences at the testing time and thereby missed deep crashes that can only be detected via long meaningful interactions .
actually we can reduce sequences of interest afterwards without sacrificing the ability to detect deep crashes.
d. comparative analysis of results on benchmark apps model based vs. model free a model enables a pe to effectively generate events e.g.
avoid clicking non interactive widgets in terms of higher activity coverage with fewer events in comparison with other tools.
on average a pe s apienz and monkey generated and events in an hour respectively.
s toa t is built on top of a high level testing framework and thus did not report such events.
a model enables a pe to tolerate non determinism related to coordinate changes while model free tools such as monkey and s apienz rarely can.
to reduce non determinism sapienz additionally cleared the local app data before replaying every test script.
however non determinism caused by data in file systems or from server is still a potential threat to replaying.
besides s apienz can be easily misguided due to the lack of connectivity information between guis.
for example app has a welcome activity that requires users to customize the app.
since local app data were cleared this activity always appeared during replaying every test script.
events that skip or finish all customizations should always be included in every test script which is difficult to guarantee without connectivity information.
in contrast a pecan easily overcome this limitation by traversing the model.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able v statistics of models built by a peand s toa t .
ape stoa t min median max min median max state action transition dynamic model vs. static model ape can first try fine states and actions to explore the apps thoroughly and coarsen states to avoid unnecessarily repeated exploration of the same gui and produced finer models than s toa t a s shown in table v. note that a pecan detach model states to mitigate state explosions caused by certain non determinism during systematic exploration see section iii d .
our results are consistent with previous work .
that is fine models are generally better than coarse models see table iii .
e. large scale evaluation on apps from google play store we additionally ran a pe on real nexus phones to test apps from the google play store for minutes each.
the results are quite encouraging.
a pe detected unique crashes in error types from of apps.
we reported crashes to developers with steps to reproduce the crashes where have already been fixed and have been accepted fixes pending .
the results show that a pe is an industrystrength practical tool in testing real world apps.
t able vi distribution of major crash types.
error type nullpointerexception illegalstateexception illegalargumentexception numberformatexception native crash runtimeexception arrayindexoutofboundsexception indexoutofboundsexception table vi presents the major crash types i.e.
those with more than crashes each.
since we conducted the evaluation on real nexus phones the results excluded trivial or spurious crashes that can only be detected on emulators or by null intent fuzzing and also excluded crashes that can only be detected on third party android builds e.g.
on samsung phones due to defects in third party framework or library code.
v. r ela ted work we survey representative related work in this section.
ensuring the quality of mobile apps is challenging and involves manual work in practice .
many pieces of existing work address specific problems of android apps such as context concurrent and asynchronous features fragmentation adverse conditions and energy .
android apps generally comprise of various foreground and background components which require different testing techniques.
hence some testing tools focus on background services where the majority aims at testing the gui and many of them also have limited support for both .
many tools attempt to improve back box tools by ripping the gui .
moreover traditional model based symbolic execution based and search based approaches are more guided but face scalability issues on large apps .
recently s apienz a novel search based approach has significantly advanced the state ofthe art and practice .
the success of s apienz makes us plan to leverage search based techniques to improve ape s exploration strategy.
many efforts have been devoted to mitigating the scalability issues e.g.
hacking the app or framework to optimize performance .
for model based testing we can also apply a coarse grained model or a probabilistic model but a finer model is generally more effective .
a pe applies a novel technique to adaptively refine and coarsen the model which is inspired by counterexample guided abstraction refinement .
currently a pe uses basic properties i.e.
the number of model actions and states to check counterexamples.
we plan to incorporate gui model checking in future work e.g.
checking counterexamples with temporal logic.
with fine models a pemay identify overly many actions.
this problem can be mitigated by some action summary techniques .
vi.
c onclusion this paper presents a pe a practical fully automated modelbased tool for effective testing of android apps.
a pe has a general decision tree based representation of abstraction functions in order to build a good testing model.
it also has a novel evolution mechanism to dynamically continuously update the model toward a good balance between the model size and model precision.
compared to the state of the art techniques that are either modelless or based on static testing models a peconsistently outperforms them on widely used benchmark apps in terms of code coverage relative improvements and the number of detected bugs unique crashes v.s.
ones .
we have also applied a peto test apps from the google play store resulting in crashes.
crashes were reported to developers with steps for reproducing them have been fixed and have been confirmed.
all our evaluations demonstrate that a peis effective practical and promising.
currently a pehas been adopted by our industry partner and integrated into their testing process.