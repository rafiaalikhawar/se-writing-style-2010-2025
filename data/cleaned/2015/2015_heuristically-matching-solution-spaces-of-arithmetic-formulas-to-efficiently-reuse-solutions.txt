heuristically matching solution spaces of arithmetic formulas to efficiently reuse solutions andrea aquino giovanni denaro sharp mauro pezz e sharp universit a della svizzera italiana usi sharpuniversity of milano bicocca via giuseppe buffi viale sarca lugano switzerland milano italy andrea.aquino mauro.pezze usi.ch denaro disco.unimib.it abstract many symbolic program analysis techniques rely on smt solvers to verify properties of programs.
despite the remarkable progress made in the development of such tools smt solvers still represent a main bottleneck to the scalability of these techniques.
recent approaches tackle this bottleneck by reusing solutions of formulas that recur during program analysis thus reducing the number of queries to smt solvers.
current approaches only reuse solutions across formulas that are equivalent to contained in or implied by other formulas as identified through a set of predefined rules and cannot reuse solutions across formulas that differ in their structure even if they share some potentially reusable solutions.
in this paper we propose a novel approach that can reuse solutions across formulas that share at least one solution regardless of their structural resemblance.
our approach exploits a novel heuristic to efficiently identify solutions computed for previously solved formulas and most likely shared by new formulas.
the results of an empirical evaluation of our approach on two different logics show that our approach can identify on average more reuse opportunities and is markedly faster than competing approaches.
keywords smt based program analysis symbolic execution smt solvers solutions reuse i. i ntroduction program analysis techniques automatically determine whether properties hold on programs and find important industrial applications in many relevant domains such as wireless sensor networks and distributed systems drivers of popular operating systems firmware of medical devices and mission critical software applications .
many program analysis techniques use satisfiability modulo theories smt solvers to determine the satisfiability of formulas generated during the analysis.
for example symbolic execution a popular program analysis technique associates the execution paths of a program with formulas path conditions that represent the constraints that must hold on the inputs of that program to execute those paths.
symbolic execution relies on smt solvers to determine the satisfiability of the path conditions and uses this information to identify feasible and infeasible paths.
despite the remarkable progress in the theory and the maturity of modern solvers smt solvers still represent a mainbottleneck to the scalability of smt based program analysis techniques since the problem of determining the satisfiability of a formula is very hard in general for instance np complete for propositional logic and undecidable for nonlinear integer arithmetic.
recently cadar et al.
visser et al.
jia et al.
and aquino et al.
have proposed techniques to reduce the number of queries issued by smt based program analysis techniques to smt solvers.
these techniques store and reuse solutions1of formulas to infer the satisfiability of other formulas.
these techniques exploit equivalence preserving simplifications and syntactical matching rules to identify formulas that are equivalent to contained in or implied by other formulas and reuse their solutions.
if two formulas can be transformed into exactly the same formula by applying a predefined set of equivalence preserving simplifications then the two formulas are equivalent and the satisfiability of one of them can be inferred from the satisfiability of the other one.
if all clauses of a formula in conjunctive normal form are contained in another formula known to be satisfiable then the former formula is also satisfiable.
similarly if all clauses of a formula in conjunctive normal form known to be unsatisfiable are contained in another formula then the latter formula is also unsatisfiable.
yet if two formulas contain inequalities that differ only in the free coefficient and the comparison operator then their comparison may lead to infer that one formula implies the other one and this information can be exploited to infer the satisfiability of formulas implied by formulas known to be satisfiable or the unsatisfiability of formulas that imply formulas known to be unsatisfiable.
these techniques open new horizons towards the scalability of smt based program analysis techniques but are limited to reuse solutions only across formulas that can be transformed into structurally similar forms and thus miss many reuse opportunities related to formulas that share solutions but have dissimilar structures.
for instance the formulas x y x y andx y 1in this paper we use the term solution to refer to either a model of a satisfiable formula or a possibly minimal unsatisfiable core of an unsatisfiable formula as discussed in detail in section ii.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
belonging to the quantifier free linear integer arithmetics share exactly the same set of solutions that is the singleton solution but no current approach can transform them to the same form and thus reuse the solution of one formula to infer the satisfiability of the other one.
this paper presents a novel approach utopia use that proof again based on the core idea of identifying reusable solutions by comparing the solution spaces of the formulas rather than their syntactical structure the more the solution spaces of two formulas are similar the higher the probability that a solution computed for one of the formulas can be reused as a solution of the other one.
utopia heuristically approximates the similarity between the solution spaces of two formulas by i measuring the behaviour of each formula with respect to a predefined set of models assignments of values to variables a metric that we refer to as the sat delta value of a formula and ii estimating the similarity of the solution spaces of two formulas as inversely proportional to the distance of their sat delta values.
given a target formula whose satisfiability has to be determined utopia computes the sat delta value of the target formula and tests the target formula against the solutions of a small set of already solved formulas with sat delta values closest to the sat delta value of the target formula.
in this paper we define sat delta for the integer and real arithmetic logics.
the experimental results obtained on formulas from two different logics which are discussed in section iii support the hypothesis that sat delta well approximates the similarity of the solution spaces of most formulas generated by smt based program analysis techniques including symbolic execution and symbolic model checking.
this paper contributes to the state of the art by i proposing a new approach to efficiently reuse solutions of formulas by exploiting their behavioural rather than their structural similarity and ii discussing a set of experimental results that confirm the effectiveness of our approach both in absolute terms and with respect to competing approaches.
the remainder of this paper is organised as follows.
section ii describes the utopia approach and introduces the satdelta heuristic.
section iii describes the experimental results that assess the effectiveness and the efficiency of utopia .
section iv describes the main threats to the validity of the results presented in this paper.
section v compares utopia with the main approaches to mitigate the impact of smt solvers on smt based program analysis techniques.
section vi concludes summarising the main results presented in this paper and outlining our research plans.
ii.
a n ovel approach to reuse solutions in this section we present utopia our novel approach to reuse the solutions of some formulas to infer the satisfiability of other formulas.
we introduce the terminology the approach and the sat delta heuristic at the core of utopia .a.
terminology in this paper we use the term solution to refer to either the model of a satisfiable formula or the possibly minimal unsatisfiable core of an unsatisfiable formula.
the model of a satisfiable formula is an assignment of values from a given domain set to the variables of a formula that makes the formula hold true.
an unsatisfiable core in short unsat core of an unsatisfiable formula in conjunctive normal form is a subset of the clauses of that formula whose conjunction is unsatisfiable.
aminimal unsatisfiable core of an unsatisfiable formula is an unsat core of that formula that becomes satisfiable if any of its clauses is removed.
for instance x x negationslash x x and x x negationslash x are the three unsat cores of the formula x x negationslash x the first two of which are minimal.
b. the utopia approach differently from current approaches that reuse solutions across formulas with similar syntactical structure utopia reuses solutions across formulas with similar solution spaces thus widening the reuse opportunities.
utopia measures the similarity of the solution spaces of two formulas by introducing a novel heuristic sat delta that quantifies the behaviour of a formula with respect to a predefined set of models.
utopia takes as input a formula in conjunctive normal form and identifies either a model that satisfies it or an unsat core that proves that it is unsatisfiable by searching in two repositories containing solutions of formulas solved in the past.
specifically these repositories contain satisfiable formulas paired with their models and unsatisfiable formulas paired with their unsat cores respectively.
the formulas in both repositories are sorted according to their sat delta value.
sat delta quantifies the behaviour of a formula with respect to a predefined set of models and is based on the intuition that formulas with similar behaviours are likely to have similar solutions spaces.
being sorted according to their sat delta value the formulas in the repositories are thus sorted according to the similarity of their solutions spaces allowing for the efficient retrieval of candidates solutions for a target formula.
in the remainder of this section we describe utopia referring to the sat delta heuristic as a black box.
we define sat delta in the next section.
algorithm presents the core algorithm of utopia .utopia is parametric with respect to a set a of models to tune the sat delta heuristic an integer number ksrepresenting the maximum number of candidate models our approach tries to reuse to solve each formula and an integer number kurepresenting the maximum number of candidate unsat cores our approach tries to reuse to solve each formula.
utopia relies on an smt solver solver and two repositories sat repo and unsat repo containing formulas paired with their corresponding solutions sorted by their satdelta value to solve a target formula formula as follows authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm the utopia algorithm require a a set of models to tune the sat delta heuristic.
ksandku two integers.
solver an smt solver.
sat repo and unsat repo two repositories containing formulas paired with their corresponding solutions sorted by sat delta .
rename vars formula sat delta formula a models closest sat repo k s formodel models do ifshares model formula model then returnmodel end if end for unsat cores closest unsat repo k u forcore unsat cores do ifshares unsat core formula core then return core end if end for status check solver formula ifstatus sat then model getmodel solver store sat repo formula model return model else if status unsat then core getunsat core solver store unsat repo formula core return core end if solver cannot produce a solution.
return none utopia preprocesses formula by renaming its variables according to their lexicographical order line of algorithm .
then utopia calculates the sat delta value of the resulting formula line as discussed in the next section.
then it queries the sat repo and the unsat repo repositories to extract the ksmodels and kuunsat cores of the formulas whose sat delta values are the closest to the satdelta value of formula lines and .
since the formulas in both repositories are sorted according to their sat delta values this operation can be performed in logarithmic time by means of a k nearest neighbours search.
finally it checks whether any of these models or unsatcores is a solution of formula lines and .
if this is the case cache hit utopia returns the solution and terminates.if this is not the case cache miss utopia solves formula by means of the smt solver solver line stores formula and its solution in the relevant repository lines and returns the solution and terminates.
utopia checks whether the model of a formula is a solution offormula by evaluating formula on the model 2and whether the unsat core of a formula is a solution of formula by checking whether all the clauses in the unsat core are syntactically contained in formula .
both checks can be performed in linear time with respect to the size of formula and the size of the considered models or unsat cores.
c. the sat delta heuristic the sat delta heuristic at the core of our approach is a function that quantifies the behaviour of a formula with respect to a set of models.
intuitively given a model utopia calculates the sat delta value of a formula by substituting the variables of that formula with the corresponding values specified in the model and measuring by how much the model fails in satisfying the formula.
it follows that the sat delta value of a formula with respect to a model is zero if that model satisfies the formula and is a positive number proportional to the distance of the model from the solution space of the formula if the formula is not satisfied by that model the further a model is from satisfying a formula the larger is the corresponding sat delta value.
figure presents the sat delta heuristic and shows how it is calculated on formulas in conjunctive normal form with no negation operators3.
the sat delta heuristic quantifies by how much on average a given set of models fails in satisfying that formula.
as shown in figure 1a the sat delta heuristic is a function that takes as input a formula fand a set aof models and returns the average distance from satisfiability offfrom the models in a. both the accuracy of sat delta in describing the behaviour of a formula and its cost are directly proportional to the number of models in a. as shown in figure 1b sat delta calculates the distance from satisfiability of a formula with respect to a single model sat delta formula as the sum of the individual distances from satisfiability of the clauses of that formula from that model.
since to satisfy a formula a specific model must satisfy all its clauses and the distance from satisfiability of each clause with respect to a model represents the amount by which that model does not satisfy that clause their sum is a realistic estimate of the distance of the model from the solution space of the formula as a whole.
as shown in figure 1c sat delta calculates the distance from satisfiability of the clause of a formula with respect to a 2if a formula contains variables than do not occur in the model we extend the model with assignments to default values.
3the negation operators of a formula belonging to the quantifier free linear integer arithmetic logic in conjunctive normal form can be removed by substituting the comparison operators of the negated inequalities with their opposite comparison operators.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sat delta f a avg sat delta formula f a a a the sat delta heuristic computes the average distance from satisfiability of a formula fin conjunctive normal form containing no negation operators from a set aof models.
the formula fis a conjunction of clauses of the form f logicalandtext c each clause c fis a disjunction of inequalities of the form c logicalortext iand each inequality i cis in the form e1 e2wheree1ande2 are algebraic expressions and is a comparison operator in the set negationslash .
a the sat delta heuristic.
sat delta formula f a summationdisplay c clauses f sat delta clause c a b sat delta formula computes the distance from satisfiability of a formula fwith respect to a single model a. sat delta clause c a m i n sat delta ineq i a i inequalities c c sat delta clause computes the distance from satisfiability of a clause cwith respect to a single model a. sat delta ineq e1 e2 a ifa e1 a e2 a e1 a e2 if a e1 a e2 if negationslash d sat delta ineq computes the distance from satisfiability of an inequality of the form e1 e2with respect to a single model a. fig.
the sat delta heuristic single model sat delta clause as the minimal distance from satisfiability of the inequalities of that clause from that model.
since to satisfy a clause a model must satisfy at least one of its inequalities a realistic estimate of the amount by which a model does not satisfy a clause is the smallest amount by which it does not satisfy any of its inequalities.
as shown in figure 1d sat delta calculates the distance from satisfiability of an inequality with respect to a single model sat delta ineq as the smallest non negative number that must be added or subtracted to the left hand side of the inequality to make the model satisfy it.
if the given model satisfies the inequality the sat delta value is zero.
if the given model does not satisfy the inequality and the comparison operator of the inequality allows it to be satisfied when both sides are set to the same value then the resulting sat delta value is the difference of the values obtained by evaluating both sides of the inequality on that model because by adding that amount to one side the value of the other side is obtained.
in case the comparison operator of the inequality does not allow the inequality to be satisfied when both sides are set to the same value then the resulting sat delta value is the same of the latter case incremented by one because once the two sides of the inequality are made equal one must still add or subtract something to the left hand side of the inequality to make the model satisfy it.
we increment by one because it is the smallest positive integer value that fits our purpose.
let us consider for instance the inequality adding one to the left hand side would make both sides equal but would not satisfy the inequality.
to make the inequality hold true it is necessary to add more than one to the left hand side andaccording to our definition we would add two.
d.sat delta a proxy to solution space similarity to test our hypothesis that formulas with similar sat delta values may have similar solution spaces we performed an experiment on a large amount of randomly generated pairs of formulas that include pairs of formulas with identical solution spaces pairs of formulas with overlapping solution spaces pairs of formulas with disjoint solution spaces.
if our hypothesis holds we expect to measure a very small distance between the sat delta values of pairs of formulas with identical solution spaces a larger distance for pairs of formulas that share some though not all solutions that is formulas with overlapping solution spaces and an even larger distance for pairs of formulas that share no solutions that is formulas with disjoint solution spaces .
we generated pairs of formulas for all possible combinations of formula pair type identical overlapping and disjoint solutions spaces and number of variables of the formulas and resulting in datasets composed of formula pairs each.
each formula is generated by constraining each variable in an interval whose extremes are random numbers thus the solution space of each random formula can be interpreted as a box in a hyperspace.
for instance the solution spaces of the formulas with a single variable can be interpreted as segments on an oriented axis the solution spaces of the formulas with two variables can be interpreted as rectangles on the cartesian plane and so on.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we generated the formula pairs with identical solution spaces by producing a random formula and applying to it a set of equivalence preserving rewriting rules to sensibly change its structure without altering its meaning.
we generated the formula pairs with overlapping solution spaces by producing a random formula and randomly altering its free coefficients in a way that the solution space of the resulting formula partially overlaps the solution space of the original formula any possible overlap is equally likely .
we generated the formula pairs with disjoint solution spaces by selecting a random formula and randomly altering its free coefficients in a way that the solution space of the resulting formula is completely disjoint from the solution space of the original formula but still close to it in the hyperspace.
for each pair of formulas in each dataset we calculated the distance between the sat delta values of the formulas.
for consistency with the experiments reported in the following section we calculated sat delta with respect to the following set of models i the model that sets all variables to ii the model that sets all variables to and iii the model that sets all variables to .
table i reports the average distance we measured for each of our datasets.
table i average distance between the sat delta values of the formulas in each pair in each dataset vars identical overlapping disjoint in line with our expectations no matter the number of variables in the formulas the distance between the sat delta value of two formulas is always extremely small if the formulas have identical solution spaces much larger if the formulas have partially overlapping solution spaces or solution spaces included in one another and extremely large if the formulas have completely non overlapping solution spaces.
these results provide some preliminary evidence of the accuracy of sat delta in distinguishing formulas with similar solution spaces.
in the next section we describe a set of experiments in which we apply the utopia approach instantiated with the sat delta heuristic on datasets of formulas generated by smtbased program analysis techniques during the analysis of real programs.
iii.
e v aluation in this section we discuss the results of a set of experiments to assess the effectiveness and the efficiency of our approach.
we performed our experiments on two benchmarks composed of formulas belonging to two logics the quantifier free linear integer arithmetic logic and the quantifier free non linear real arithmetic logic.
our experiments address the following research questions rq effectiveness does utopia identify more reuse opportunities than competing approaches?
rq efficiency does utopia outperform modern smt solvers and competing approaches?
a. prototype to evaluate the effectiveness and the efficiency of utopia we implemented a prototype in c .
our prototype takes as input a formula and separates it into its mutually independent sub formulas.
two sub formulas are mutually independent if they do not have variables in common.
the satisfiability of each sub formula is determined individually and the results are aggregated to produce a solution of the original formula.
this process is known as formula slicing and is currently exploited by all competing approaches.
to determine the satisfiability of each individual subformula our prototype calculates its sat delta value with respect to the following three models the model that sets all variables to the model that sets all variables to and the model that sets all variables to .
we experimented with many different sets of models to tune sat delta in particular with sets composed of one three five and ten models but we did not notice significative differences in the results.
we chose this group because it produces the best trade off between reuse opportunities identified by our approach and its efficiency on our benchmarks.
once our prototype computes the sat delta value of a target formula it selects from the two repositories the ten satisfiable and the ten unsatisfiable formulas whose sat delta values are the closest to the target formula in other words our prototype instantiates the algorithm discussed in section ii setting both ksandkuto10 .
finally our prototype checks whether any of the solutions of the selected formulas is also a solution of the target formula.
if it is the case our prototype reports a cache hit .
if not our prototype reports a cache miss calls the microsoft z3 smt solver to produce a solution for the target formula and stores the target formula paired with its solution in the relevant repository.
our prototype uses microsoft z3 version .
.
the latest version available at the time of our experiments with no timeouts.
all formulas considered in our experiments can be solved by z3 in no more than a few seconds.
in the experiments we invoke z3 from scratch on every formula due to technical limitations of our current prototype.
our approach can be easily adapted to use the underlying solver incrementally.
b. experimental setting we collected approximately formulas belonging to the quantifier free linear integer arithmetic logic and approximately formulas belonging to the quantifier free nonlinear real arithmetic logic in two benchmarks.
we produced the first benchmark running the symbolic executors crest authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and jbse on c and java programs.
we produced the second benchmark running the model checker gk tail on java classes belonging to the graphstream and google guava libraries.
we will refer to these two benchmarks as the crest benchmark and gk tail benchmark respectively.
in all our experiments our prototype starts with empty repositories and considers the target formulas one by one.
it incrementally populates the repositories with the formulas and their corresponding solutions that it does not manage to solve reusing solutions of other formulas considered in the past.
in detail when utopia does not manage to reuse the solutions in the repositories to solve a formula it solves that formula with the microsoft z3 smt solver and stores the formula and its solution in the relevant repository depending on the satisfiability of the formula.
the reader should notice that this experimental procedure may produce different reuse results when formulas are considered in different orders.
in our experiments we considered the formulas in our benchmarks in the order they were produced by the crest and jbse symbolic executors and by the gktail model checker to match a realistic scenario for the application of utopia .
to control for possible biases related to considering the formulas in this specific order we ran our experiments reversing the order of formulas in our benchmarks and rearranging them randomly and in all cases we did not reveal significant differences in the results.
we treat each program dataset in our benchmarks as a single experiment clearing the cache between any two experiments.
we performed all the experiments on a macbook pro equipped with a .
ghz intel core i7 processor and gb of ram.
c.rq effectiveness we address the effectiveness of utopia by calculating the amount of formulas in the crest and gk tail benchmarks that utopia can solve by reusing the solutions of other formulas in the same benchmark.
we compare utopia with green greentrie recal and recal .
we executed our prototype on both benchmarks and measured its reuse rate calculated as the number of the cache hits reported by our prototype on a dataset divided by the total number of formulas in that dataset.
the reuse rate effectively represents the percentage of formulas in a dataset that can be solved by our prototype reusing solutions of formulas solved in the past that is without calling the smt solver.
columns utopia in table ii and iii report the reuse rates of our prototype for the crest and gk tail benchmarks respectively.
columns green greentrie recal and recal in table ii report the reuse rate of the competing approaches on the crest benchmark.
we could not execute the competing approaches on the gk tail benchmark since these approaches target formulas belonging to the quantifier free linear integer arithmetic logic and do not handle the formulas belonging to the quantifier free non linear real arithmetic logic in the gktailbenchmark.as a baseline for the evaluation we use a random selection strategy which draws ten satisfiable formulas and ten unsatisfiable formulas at random from the repositories and tries to reuse their solutions to determine the satisfiability of each formula.
this random selection strategy can be trivially implemented and is extremely fast thus if the reuse rate of an approach is less than the reuse rate of the random selection strategy the approach is arguably useless in practice.
columns random in table ii and iii report the reuse rates of the random selection strategy for the crest and gk tail benchmarks respectively.
we executed an exhaustive search to compute the optimal reuse rates that is the best reuse rates that can be achieved by all techniques considering all the solutions available in our benchmarks to identify the upper bound to the effectiveness of all techniques.
columns maximum in table ii and iii report the best achievable reuse rates for the crest and gktailbenchmarks respectively.
in table ii we highlight in red the reuse rates worse than the random selection strategy and in green the reuse rates better than or equal to all approaches which are the closest to the maximum achievable value.
utopia is the only approach that is never worse than the random selection strategy on all datasets and largely outperforms it on three datasets i the avldataset by ii the cdaudio dataset by and iii the treemap dataset by .
in absolute terms this corresponds to more than solutions that can be reused with utopia and not with a random selection strategy.
the results reported in columns utopia and maximum of table ii show that utopia is nearly optimal on the crest benchmark.
in fact the reuse rates of utopia are very close to the theoretical maximum.
they only differ for a few datasets i the avldataset by ii the block dataset by iii the dijkstra dataset by iv the kbfiltr dataset by v the new tax dataset by and vi the old tax dataset by .
the results reported in columns utopia random and maximum of table iii show that utopia is nearly optimal also on the gk tail benchmark and often largely better than the random selection strategy for all datasets.
the reuse rates ofutopia are more than lower than the optimal reuse rates it could have possibly achieved only for three datasets i the guava.arraylistmultimap dataset by ii the guava.immutablemultiset dataset by and iii the guava.treemultimap dataset by .utopia is always at least as good as the random selection strategy on all datasets in the gk tail benchmark and largely outperforms it on most of them.
in the best case that is the graphstream.multigraph dataset the reuse rate produced by utopia outperforms the one produced by the random selection strategy by .i n particular in the three cases of reuse rate lower than the optimal by more than utopia largely outperforms the random strategy.
the reuse rates of green greentrie recal and recal reported in table ii show that i the green approach is not particularly effective on this benchmark being able to reuse on average only of the formulas in a dataset ii the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii reuse rates of solutions in the crest benchmark program formulas sat unsat green greentrie recal recal utopia random maximum afs avl ball block cdaudio collision dijkstra diskperf division floppy grep kbfiltr knapsack list multiplication new tax old tax reverseword swapwords tcas treemap wbs min average max legend better than or equal to all competing approaches worse than random table iii reuse rates of solutions in the gk tail benchmark program formulas sat unsat utopia random maximum graphstream.multigraph graphstream.singlegraph guava.arraylistmultimap guava.concurrenthashmultiset guava.duration guava.hashbimap guava.hashmultimap guava.hashmultiset guava.immutablebimap guava.immutablelistmultimap guava.immutablemultiset guava.linkedhashmultimap guava.linkedhashmultiset guava.linkedlistmultimap guava.treemultimap guava.treemultiset min average max authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
recal approach is consistently better than green being able to reuse on average of the formulas in a dataset but is still sensibly outperformed by the other approaches iii the greentrie approach is extremely effective on this benchmark being able to reuse on average of the formulas in a dataset and is only slightly outperformed by the recal approach for which the average is i v utopia achives the best average reuse rate being able to reuse on average of the formulas in a dataset.
it is worth to recall that all approaches except utopia perform worse than the random selection strategy on some datasets.
in particular the green approach performs worse than the random selection strategy on datasets recal on datasets greentrie on datasets and recal on datasets.
in summary the experiments discussed in this section indicate that the reuse opportunities identified by utopia are on average higher than the ones identified by the state of the art approaches based on reusing solutions of formulas.
d.rq efficiency we address the efficiency of utopia by comparing the computation time of utopia with its competing approaches to solve the formulas in our benchmarks.
we logged the execution time of utopia and all the competing approaches for all the experiments described in the previous section.
we also calculated the execution time of the microsoft z3 smt solver to solve the formulas in each dataset to provide a baseline for the evaluation of the efficiency of utopia .
to minimise the bias due to the execution environment we performed all measurements on a freshly rebooted machine running no other user level programs repeated each measurement ten times and averaged the results.
the differences in the results we measured across these ten runs were negligible they differed by no more than of the average value we measured .
table iv and table v report the result of this experiment for the crest and gk tail benchmarks respectively.
in table iv we highlight in red the execution times worse than z3 and in green the best execution times.
in the first case the approach to reuse solutions is useless in the second case it is the best out of the considered approaches.
the data reported in table iv show that utopia is consistently faster than the competing approaches and always faster than z3 on the crest benchmark.
as shown in row total utopia can solve all formulas in the crest benchmark in633 seconds approximately twelve times faster than z3 and almost twice faster than the second best the greentrie approach that solves all formulas in seconds.
all other approaches are consistently slower green solves all formulas in3650 seconds recal in5992 seconds and recal in7254 .
interestingly the recal approach which is one of the best approaches in terms of reuse rate is also the slowest merely saving 500seconds with respect to z3 on this benchmark.
the data reported in table v show that utopia is consistently faster than z3 on the gk tail benchmark.
as shown in row total utopia solves all formulas in this benchmark in 66seconds approximately six times faster than z3 which needs 387seconds to solve all formulas.
in summary the experiments discussed in this section indicate that utopia outperforms z3 and all the competing approaches being approximately twelve times faster than z3 in the best case and almost twice faster the second best competing approach greentrie .
iv .
t hreats to validity our results may be biased by faults in our prototype implementation.
we extensively tested our prototype and verified the correctness of the solutions identified with it for a large set of formulas.
to do so we determined the satisfiability value of these formulas with the microsoft z3 smt solver and checked the consistency of the outcome of our prototype.
we also validated a large portion of the solutions identified by our prototype by hand.
our results may also be biased by the structure of the formulas in our benchmarks.
these formulas were produced by analysing c and java programs with the crest and jbse symbolic executors and by producing dynamic software behavioural models with the gk tail model checker from java classes.
the formulas in the crest benchmark are large conjunctions of linear inequalities over integer variables while the formulas in the gk tail benchmark are implications between disjunctions of inequalities over real variables.
these formulas have very similar structures this might not hold for formulas generated by other smt based program analysis techniques.
our results may be biased by the order in which we considered the formulas in our benchmarks.
as reported in section iii we considered the formulas in our benchmarks in the order they were produced by crest jbse and gk tail to match a realistic scenario for the application of our approach.
we also reversed the order of formulas in our benchmarks and rearranged them randomly without revealing any significative difference in the results.
finally in the experimental evaluation of our approach we did not compare our approach with the caching frameworks implemented in klee.
we could not compare utopia with klee because the caching frameworks implemented in klee target formulas belonging to the quantifier free theory of bit vectors and bit vector arrays and thus cannot handle the formulas in any of our benchmarks and our prototype cannot currently handle formulas containing bit vectors and bit vector arrays.
v. r elated work the problem of mitigating the impact of smt solvers on the cost of smt based program analysis techniques has been addressed in many different ways including i using multiple solvers to mitigate the weaknesses of individual solvers ii complementing smt solvers with external optimisations and more recently iii reducing the number of queries issued by smt based program analysis techniques to smt solvers.
a first thread of work has focused on using multiple smt solvers at the same time to mitigate the weaknesses authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv running times in seconds on the crest benchmark program z3 green greentrie recal recal utopia afs .
.
.
.
.
.
avl .
.
.
.
.
.
ball .
.
.
.
.
.
block .
.
.
.
.
.
cdaudio .
.
.
.
.
.
collision .
.
.
.
.
.
dijkstra .
.
.
.
.
.
diskperf .
.
.
.
.
.
division .
.
.
.
.
.
floppy .
.
.
.
.
.
grep .
.
.
.
.
.
kbfiltr .
.
.
.
.
.
knapsack .
.
.
.
.
.
list .
.
.
.
.
.
multiplication .
.
.
.
.
.
new tax .
.
.
.
.
.
old tax .
.
.
.
.
.
reverseword .
.
.
.
.
.
swapwords .
.
.
.
.
.
tcas .
.
.
.
.
.
treemap .
.
.
.
.
.
wbs .
.
.
.
.
.
min .
.
.
.
.
.
average .
.
.
.
.
.
max .
.
.
.
.
.
total .
.
.
.
.
.
legend better than or equal to all competing approaches worse than z3 table v running times in seconds on the gk tail benchmark program z3 utopia graphstream.multigraph .
.
graphstream.singlegraph .
.
guava.arraylistmultimap .
.
guava.concurrenthashmultiset .
.
guava.duration .
.
guava.hashbimap .
.
guava.hashmultimap .
.
guava.hashmultiset .
.
guava.immutablebimap .
.
guava.immutablelistmultimap .
.
guava.immutablemultiset .
.
guava.linkedhashmultimap .
.
guava.linkedhashmultiset .
.
guava.linkedlistmultimap .
.
guava.treemultimap .
.
guava.treemultiset .
.
min .
.
average .
.
max .
.
total .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of individual solvers.
palikareva et al.
have observed that modern smt solvers have different strengths and that for most queries it is impossible to tell in advance which solver will perform better .
they have proposed a framework which runs many solvers in parallel on a given formula and returns the solution produced by the first terminating solver.
since converting formulas to strings shipping these strings to smt solvers and having the solvers parse them back produces an unacceptable overhead palikareva et al.
suggest to use macros to concurrently assert a formula to many solvers by means of their apis.
this framework has been integrated in the klee symbolic executor largely improving its scalability.
a different thread of work has focused on complementing smt solvers with external optimisations.
erete and orso have proposed a technique that exploits contextual information to restricts the domain of formulas generated during the dynamic symbolic execution of a program to eliminate potentially irrelevant constraints .
li et al.
exploit machine learning approaches to satisfy complex formulas that cannot be solved with modern solvers .
they drive the machine learning process with a measure of formula dissatisfaction which is closely related to our heuristic sat delta although used differently.
a more recent thread of work has focused on reducing the number of queries issued by smt based program analysis techniques to smt solvers by storing and reusing solutions of formulas.
this thread of work has led to the design of four techniques that are closely related to our work and that we survey in further detail in the remainder of this section.
cadar et al.
have designed klee a symbolic executor that includes two caching frameworks that target formulas belonging to the quantifier free theory of bit vectors and bitvector arrays.
these two caching frameworks are called the branch cache and the counterexample cache .
the branch cache simply remembers formulas and their solutions.
the counterexample cache is used to determine whether a target formula contains or is contained in other formulas solved in the past.
if the target formula is contained in a satisfiable resp.
unsatisfiable formula then it is also satisfiable resp.
unsatisfiable .
if the target formula contains a satisfiable formula the solution of such formula is also checked on the target formula potentially proving it satisfiable.
visser et al.
have designed green a caching framework that targets formulas belonging to the quantifier free linear integer arithmetic logic.
given a target formula this framework simplifies it exploiting a predefined set of simplification rules.
then it checks whether the resulting formula is contained in a database of other formulas solved in the past.
if the target formula matches a satisfiable resp.
unsatisfiable formula in the database then it is also satisfiable resp.
unsatisfiable .
jia et al.
have designed greentrie an extension of the green caching framework that also targets formulas belonging to the quantifier free linear integer arithmetic logic.
greentrie can identify some particular cases of logical implication between two formulas.
given a target formula this framework checks whether it implies or is implied by other formulassolved in the past.
if the target formula is implied by a satisfiable formula then it is also satisfiable.
if the target formula implies an unsatisfiable formula the it is also unsatisfiable.
aquino et al.
have designed recal a caching framework that targets formulas belonging to the quantifier free linear integer arithmetic logic.
given a target formula this framework simplifies it exploiting a predefined set of simplification rules transforms it into a matrix and applies to it a canonicalisation algorithm to make the order of its variables and clauses irrelevant.
then it checks whether the resulting formula is contained in a database of other formulas solved in the past.
similarly to greentrie another version of this framework recal developed by the same authors can also identify some particular cases of logical implication between two formulas.
the utopia approach described in this paper is substantially different from all these approaches.
instead of trying to identify formulas that are equivalent to contained in or implied by other formulas by exploiting a predefined set of syntactical rules our approach exploits the sat delta heuristic to identify the formulas that more likely share solutions with a given target formula.
the counterexample cache implemented in klee is the only existing framework that includes a component that checks whether the solution of a formula is shared by one of its super formulas by effectively evaluating such solution.
our approach generalises this idea reusing solutions even across formulas with little or no structural resemblance that may or may not be contained in one another.
vi.
c onclusion in this paper we presented utopia a new approach to reduce the impact of smt solvers on the cost of smtbased program analysis techniques.
utopia stores and reuses the solutions of formulas generated by these techniques to determine the satisfiability value of new formulas without relying on possibly expensive calls to smt solvers.
differently from state of the art approaches which reuse solutions across formulas that can be shown to be equivalent to contained in or implied by other formulas by exploiting a predefined sets of syntactical rules utopia reuses solutions across formulas that share at least one solution regardless of their structural similarity and thus strongly widens reuse opportunities.
the main contribution of utopia is the introduction of satdelta a heuristics that approximates the distance of a model from the solution space of a formula.
sat delta enables the fast identification of formulas with similar solution spaces.
in this way utopia quickly identifies a set of likely reusable solutions for a target formula and improves solution reusability.
the experimental results reported in the paper show that utopia can identify on average more reuse opportunities and is considerably faster than competing approaches.
acknowledgment this work is partially supported by the swiss snf project close and by the italian prin project ideas 2012e47tm2 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.