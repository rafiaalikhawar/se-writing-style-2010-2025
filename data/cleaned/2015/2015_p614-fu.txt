automatically deriving pointer reference expressions from binary code for memory dump analysis y angchun fu zhiqiang lin anddavid brumley the university of texas at dallas dallas usa carnegie mellon university pittsburgh usa abstract given a crash dump or a kernel memory snapshot it is often desirable to have a capability that can traverse its pointers to locate the root cause of the crash or check their integrity to detect the control flow hijacks.
to achieve this one key challenge lies in how to locate where the pointers are.
while locating a pointer usually requires the data structure knowledge of the corresponding program an important advance made by this work is that we show a technique of extracting address independent data reference expressions for pointers through dynamic binary analysis.
this novel pointer reference expression encodes how a pointer is accessed through the combination of a base address usually a global variable with certain offset and further pointer dereferences.
we have applied our techniques to os kernels and our experimental results with a number of real world kernel malware show that we can correctly identify the hijacked kernel function pointers by locating them using the extracted pointer reference expressions when only given a memory snapshot.
categories and subject descriptors d. .
security and protection general terms security keywords kernel integrity taint analysis memory forensics .
introduction a pointer whose value is a memory address is ubiquitous in a large body of software especially those written in c c .
recognizing and locating pointers in a memory crash dump is valuable in many applications.
in program debugging pointers are the root cause of segmentation fault .
given a crash dump if we can locate where the crashed pointer is it will significantly help the bug reporting.
in security pointers especially the ones pointing toprogram code i.e.
function pointers are often the direct targets for control flow hijacks .
for instance over of kernel rootkits hijack kernel function pointers to subvert normal control flow of the os kernel .
given a running program or an os kernel if we can locate its function pointers we would have been able to check their integrity and detect the control flow violations.
however current practice to locate a pointer in memory requires the data structure knowledge of the corresponding program.
unfortunately there are scenarios where data structures are not always available.
for instance for closed source software such as microsoft windows kernel it is very unusual to have the complete kernel data structure definitions.
second even with data structure definitions if there is any ambiguous type e.g.
void pointer or union type it will stop traversing the target type unless with further analysis to resolve the target type as in kop and mas and may not be able to locate all pointers e.g.
the pointers stored in the void target type .
therefore if we can directly locate pointers without any data structure definitions such a technique would be of great practicality.
to advance the state of the art in this paper we introduce a new concept called pointer reference expression ptr rexp for short and we show such an expression can be extracted from binary code and used to locate pointers in memory.
more specifically ptr rexp encodes how a pointer is accessed through the combination of a base address usually a global variable with certain offset and further pointer dereferences.
with ptr rexp we can then traverse a memory dump by following from the root of the pointer e.g .
a global variable that is static to reach the target locations.
to derive ptr rexp we present a new dynamic binary analysis that tracks the dependences of how a memory address is computed.
this analysis starts from a pointer data use point e.g.
an indirect function call and backward resolves the dependences until reaching the root of the pointer namely a global variable address.
such a resolution process can directly produce a run time address independent ptr rexp since global address is usually static which can be used for cross checking.
as an application of our techniques we demonstrate how to use it for kernel memory dump analysis especially for the checking of kernel function pointer integrity.
to this end we have to solve another challenge how to determine whether a pointer is hijacked.
we propose a pointer integrity checking technique.
we base our technique on the observation that after a program is compiled the instructions i.e.
the code are usually static and the difference between the same program on two machines is the program data.
as such with our address independent ptr rexp we can simultaneously traverse two memory snapshots one is from a trusted kernel and the other is from the untrusted one.
while the identified function pointers could be located in the dynamically allocated program addresses which permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
614can differ simply due to the behavior of the program heap allocators fortunately our ptr rexp is exactly designed to enable appropriate pointer integrity comparison between an untrusted kernel and the trusted one and we can compare either their values or their targeted code to determine whether it has been hijacked.
we have implemented our proposed techniques in a prototype called fpck.
in addition to kernel dump analysis fpckwill be useful in many other applications especially in security.
for instance it can be used to regularly inspect the integrity of kernel function pointers.
in addition it can also be used by infrastructure as a service iaas cloud providers to manage the guest oses with kernel integrity check as a service .
meanwhile it can also be used in memory forensics to investigate the intrusions and estimate the damages caused by kernel malware.
in short the main contributions of this paper are we present a set of novel techniques to automatically locate function pointers in a memory snapshot.
the pointer location is encoded by a static pointer reference expression that is derived by a dynamic data dependence analysis.
we apply our techniques and develop a binary exclusive outof vm approach to automatically check the integrity of kernel function pointers hijacked by kernel malware.
we have implemented these techniques in our prototype fpck.
our experimental results with linux kernel show that with respect to the tested malware fpcksuccessfully identifies all of the hijacked kernel pointers within just a few seconds.
.
background and overview objective.
intuitively when given a memory dump it often requires the corresponding data structure definitions to traverse the memory and reach the data of interest.
however data structure knowledge is not always available.
the goal of this paper is to demonstrate the practicality of traversing a memory dump to reach data of interest without accessing the program source code or data structure definitions.
more specifically we show there exists techniques that can automatically derive ptr rexp from program executions and such expressions can be used for cross checking the integrity of kernel function pointers.
the reason to focus on kernel function pointer is because kernel rootkit a piece of malware designed to tamper with kernel behavior often hijacks kernel function pointers to subvert normal control flow of the os kernel .
hijacking kernel function pointer allows kernel malware to conceal the presence of malicious behavior open back doors for future intrusion steal private data such as the keystrokes elevate privileges of other malicious processes and disable defenses as those discussed in .
therefore it is often used by many cyber attacks due to its root level privilege and high stealthiness including stuxnet duqu and the recent rsa securid compromise.
several prior works such as kop and osck have demonstrated that we can periodically take the snapshot of the guest os running atop virtual machines vm and then traverse its memory snapshot to perform the integrity check.
however kop and osck require the access of kernel source code to build a data structure graph from which to traverse the kernel function pointers.
unfortunately in many cases end users including cloud providers only have the binary code of an os kernel.
thus it is imperative to have a binary exclusive technique that can pinpoint kernel function pointers in memory snapshot such that we can check their integrity correspondingly.
ptr rex pextractortrusted computer trusted physical memory snapshotkernel function ptrrexppcomputer pointer integrity checkerptr rexp diagnosing computeruntrusted physical memory snapshot untrusted computer figure an overview of fpck.
all the involved computers could be the real physical machines virtual machines or their combinations.
challenges.
locating the hijacked kernel function pointers given only a physical memory snapshot is challenging for two reasons where to locate the kernel function pointers .
kernel function pointers can be located in many places such as in kernel global data regions and kernel heap regions.
it might be possible to identify the hijacks of kernel global function pointers by aligning the virtual address of the memory snapshot of a untrusted machine denoted mu and a trusted machine denoted mt .
however it is challenging to locate the function pointers in other memory regions such as those in the kernel heap.
how to determine whether they are hijacked .
assume we are able to locate the memory addresses of the corresponding kernel function pointers we cannot merely compare their values in the memory cell between muandmtto check the hijacks as the value of a function pointer could be different since a kernel function can be loaded into different memory addresses in different running instances of the same kernel which is especially true for kernel modules.
of course for the core kernel code that is not loaded as kernel modules the values of their function pointers should be identical e.g.
the values in system call table and we can compare their values to identify the hijacks.
overview.
to address the above challenges we have designed an array of binary exclusive techniques in our prototype fpck.
as illustrated in fig.
there are two key components inside fpck a ptr rexp extractor and a pointer value comparer .
given a trusted machine t our extractor analyzes its execution and derives a static data reference expression namely ptr rexp for each observed kernel function pointer.
this expression reflects how it should be accessed starting from the kernel global locations.
next whenever we want 615to check the integrity of the kernel function pointers of an untrusted computer we first take a snapshot of its physical memory mu.
then we run the pointer integrity checker on our diagnosing machine which will scan whether u s kernel function pointers have been hijacked.
the checker detects hijacks by performing a low level pointer value or pointer target comparison between uandt.
each mismatch between muandmtindicates a potential hijack.
in the next two sections we present the detailed design of the two key components of f pck.
scope and assumptions.
we assume we are able to take the memory snapshot of the running vms which are running atop x86 architectures.
along with the snapshot we also assume we can acquire the value of the page table base register i.e.
cr3 in x86 through which to perform the virtual to physical address translation.
in addition we assume the kernel code pages are not writable and the code itself is identical across different vms for the same version.
this is reasonable given that public private cloud providers often offer users with pre installed vms.
it is highly likely that these vms tend to have the same kernel version.
in addition to check mu we assume that we have the corresponding trusted kernel copies including the corresponding kernel modules of the running guest oses.
note that the specific kernel version of the guest os can be determined by other approaches e.g.
.
regarding the workloads running on the trusted or untrusted machines there is no constraint and they can be different.
also similar to all other snapshot based approaches e.g .
we are only interested in the persistent function pointers continuing to exist over the entire life span and will exclude these temporary pointers.
the reason is that snapshot based approach is context less a memory snapshot can be taken at arbitrary time and we cannot reliably check the integrity of these temporary ones.
while this is a limitation in general for all these snapshot based approaches fortunately over kernel rootkits tamper with persistent function pointers according to the survey by petroni et al.
.
meanwhile many kernel function pointers are actually persistent e.g.
of function pointers in microsoft windows does not change over their entire life span according to the result from hookscout .
.
ptr rexp extractor the goal of ptr rexp extractor is to i derive the memory addresses into static expressions for the exercised kernel function pointers .
and ii prune non persistent function pointers and merge multiple values for the same pointer if there is any .
.
in the following we present the detailed design of each of these techniques.
.
deriving ptr rexp overview .being one of the key techniques of fpck ptr rexp derivation aims to to produce an address independent expression of each function pointer used in an executed control path.
then during the integrity checking phase this expression allows us to traverse and compare the function pointers between trusted kernel memory mt and untrusted kernel memory mu.
if they differ then we say that kernel malware has changed the value of the function pointer.
for example the following code shows how the read operation is calculated from a data structure in linux kernel .
.
.
mov 0xc034bc78 eax move proc root fs to eax .
mov 0x20 eax eax proc root fs f ops .
... irrelevant instrs ... .
call 0x8 eax proc root fs f ops read the example shows that the final call address at line is derived from the memory value stored at 0xc034bc78 which is a kernel type operand reg ofname mem ofaddr type shadow operand pc hashtbl type instmap pc instrecord hashtbl type instrecord i semantics taintop taintop type i semantics move binary call mem ... type regtaint v pcp type taintop memoptaint ofregtaint regtaint scale disp regoptaint ofregtaint nooptaintfigure the data structure types used in fpck.
global variable .
a typical approach used by kernel malware is to tamper with the value at 0xc034bc78 or 0xc034bc78 0x20 or 0xc034bc78 0x20 0x8 note that represents the pointer dereference such that the malicious code is called at line .
unfortunately the value stored at these memory addresses may change between different instances of the kernel.
thus we cannot simply compare the absolute memory address calculated at line .
our main idea is to use a ptr rexp of an indirect jump or call to uniquely represent the intended target.
our ptr rexp encompasses all calculations used to determine an indirect jump or call target.
in the above example the ptr rexp is 0xc034bc78 0x20 0x8 .
the intuition why the ptr rexp works is that while the data stored at addresses may differ between muandmt the code to calculate the location will be the same recall that we assume kernel code cannot be tampered by malware and hypervisor can often enforce this .
detailed algorithm .at a high level given an indirect call or jump to an address a we present an algorithm to recursively walk the list of instructions used to calculate ato build up our ptr rexp .
the main intuition behind our algorithm is that the roots of data dependence are pre determined addresses.
while the value of a memory cell used to calculate a jump call target may change the location does not.
we recognize the potential locations by looking for literal values that fall within the kernel address space.
we taint such values and perform dynamic data dependence tracking on any instruction derived from a tainted value.
this is different compared to other techniques such as hookscout where it taints the known values of kernel function pointers and tracks how these values propagates whereas we track how a pointer is computed as described below.
we also keep a data structure that maintains the semantics of each instruction that operates on tainted data which we call tainted instructions .
the algorithm walks the data structure to generate the final expression on the fly when an indirect call or jump target is tainted.
the type signatures used by our algorithm are presented in figure .
the first data structure is of type operand that can be either a register or a memory address.
note that the literal value operand will be recognized and taken special care.
the second data structure is of type shadow that maps an operand to a program counter pc .
we use sto denote an instance of shadow .
for brevity we write s ands to mean s and s respectively.
sis used to maintain two invariants in our algorithm tainted invariant for efficiency we only track instructions dependent upon literal values or the so called immediate values that fall within kernel address space.
such literal values can be bases in the data dependence calculation for kernel function pointers.
specifically given an instruction pc l e where pcis the program counter lis the assigned memory 616table example code for the shadow record creation and propagation.
pc machine code assembly code partial program states registers memory shadow s pc 0xc0106bc0 4d c0 push 0xc0114d10 esp 0xcf581004 m 0xcf581004 0xc0114d10 s 0xc0106bc0 ... push do page fault 0xc0106a02 8b 7c mov 0x20 esp edi esp 0xcf580fe4 edi 0xc0114d10 s s ... 0xc0106bc0 0xc0106a1b ff d7 call edi esp 0xcf580fe0 edi 0xc0114d10 s 0xc0106bc0 ... call do page fault 0x0c015f94 ff 3c c0 call 0xc028863c eax eax m 0xc0144d8a s 0x0c015f94 call sys write 0xd894e007 a1 bc c0 mov 0xc034bc78 eax eax 0xd7fee2e0 s 0xd894e007 proc root fs 0xd894e00c 8b mov 0x20 eax eax eax 0xc028ea80 s 0xd894e00c proc root fs f ops 0xd894e013 ff call 0x8 eax eax 0xc028ea80 m 0xc015ed7e s 0xd894e013 proc root fs f ops read cell or register and eis derived from a literal falling in kernel space then s is defined.
this is a type of taint tracking where s is defined iff eis tainted.
pc invariant during the ptr rexp extraction we walk a log of tainted instructions to compute the jump call target expression.
given pc l e we maintain the overall invariant with two minor invariants on tainted values e. first if eis a memory loadm for value v then s s .
this invariant ensures that each tainted memory load maps to the definition site where the memory cell was initialized with a tainted value.
second when eis not a memory load s points to the definition site for each e including such as the definition site for a tainted register.
overall these two invariants ensure that i spoints to the definition site for a tainted memory cell and ii spoints to the definition site for tainted registers.
note that while the above invariants can be generalized to any expression currently we implement the data structures for x86.
in particular each ecan have at most one memory reference.
the memory reference is based upon at most two registers of the form r1 r2 scale disp.
the above invariants allow us to recursively determine the pc for all instructions used to calculate a tainted indirect jump or call target.
we associate pc values to specific instruction semantics via theinstmap record as illustrated in figure .
each pc value defined insis also mapped to a record in an instmap .
the records of type instrecord consist of a semantic type i semantics for the operation move binary operation call etc.
and two taint records for the two operands of type taintop .
for simplicity we only describe at most two source expressions regoptaint ormemoptaint for an executing instruction.
note that an instruction could have only one operand instead of two or no operand that is why we introduce nooptaint .
in addition for the regtaint ofregoptaint we use a tuple v pcp which denotes the taint dependency of the register operand for an instruction where vis the concrete value if there is no dependency otherwise vis and pcptracks the previous pc that generates the propagated taint record.
we provide detailed examples to illustrate why we define our data structure in this way in the following based on how a general taint analysis works.
taint sources our shadow record including type shadow and instrecord as well as the mapping instmap is generated using two rules either an instruction which generates a data definition such as memory or register write or an instruction which has a memory operand that involves a global memory address or its propagation.rule i. similar to all other taint analyses a data definition for an operand reg ormem is generated by i a data movement instruction such as mov push pop etc.
or ii a data arithmetic instruction such as add shl and etc.
based on the instruction semantics we accordingly generate our taint record for the corresponding operand .
example.
as shown in the first row of table for instruction 0xc0106bc0 push 0xc0114d10 it pushes a literal value 0xc0114d10 which falling within the kernel address space we hence classify this value is a reference to a global variable to memory address 0xcf581004 pointed by esp then we generate a shadow record for memory address 0xcf581004 with pc 0xc0106bc0 i.e.
s 0xc0106bc0 and an instrecord for the source operand as 0xc0114d10 which is indexed by pc 0xc0106bc0 as shown in the first row of table .
the destination operand pointed by register esp under current taint context does not have a global address dependency whose memoptaint is hence or nooptaint .
rule ii.
this is a special rule in our data dependence tracking.
specifically we will also generate an instrecord whenever an instruction has a mem operand whose address is directly or transitively derived from a kernel global memory address.
in particular in the x86 architecture a memory address for a mem operand is computed using the following formula displacement baseaddr index scale baseaddr index scale displacement where baseaddr is the reg that has the starting address or base address of the accessed memory index is the reg used to determine the offset from the base address scale is the data size based multiplier for the index and displacement often an immediate value is the additional offset adjustment from the baseaddr .
if the reg of the baseaddr is tainted i.e.
the address is transitively derived from a global variable or the displacement is a global address we will generate a new instrecord which captures the dependences on how an address is computed.
example.
consider call 0xc028863c eax in the second code snippet in table .
this instruction is interesting because it calls a system call routine sys write .
the mem operand for this instruction is computed from an empty baseaddr reg thus no taint an index regeax with a value thus no global address dependency a scale with and the displacement value 0xc028863c that is a kernel global memory address.
therefore from the instruction semantics call mem we can infer that the memory address generated from this instruction is a global mem617table exampes of our instrecord for executed instructions in table .
1stoperand memoptaint regtaint regtaint scale disp 2ndoperand memoptaint regtaint regtaint scale disp pc i semantics v pcp v pcp scale disp v pcp v pcp scale disp 0xc0106bc0 push imm 0xc0114d10 0x0c015f94 call mem 0x4 0x4 0xc028863c 0xd894e007 mov m2r 0xc034bc78 0xd894e00c mov m2r 0xd894e007 0x20 0xd894e013 call mem 0xd894e00c 0x8 ory address reference which refers to 0xc028863c 0xc028864c and we will consequently generate a shadow record as s pc call 0x0c015f94 and an instrecord withinstmap as 0x0c015f94!
call mem 0x4 0x4 0xc028863c nooptaint as presented in the second row of table and table respectively.
taint propagation theshadow record will be flowed to the destination shadow of the corresponding reg ormem operand.
the instrecord will not but it will be mapped to the shadow byinstmap .
such a design saves the shadow memory space and improves the performance of our data dependence tracking because of the indirection we introduced compared to the normal method that also propagates the instrecord .
also when propagating the shadow record if the source operand generates a new instrecord ruleii we will not propagate the original shadow record but rather propagate the newly generated one.
example.
for instance as shown in the third example code snippet in table for 0xd894e00c mov 0x20 eax eax we will not directly propagate the shadow of the baseaddr regeax which is s 0xd894e007 !
mov m2r 0xc034bc78 and instead we will first create a new instrecord withinstmap as 0xd894e00c!
mov m2r 0xd894e007 0x20 and propagate its shadow toeax s 0xd894e00c .
taint sinks we build the ptr rexp on demand from the data dependency and the instruction semantics maintained in our data structures namely shadow instrecord and instmap .
at a high level we generate the ptr rexp by walking back through our instrecord hashtbl guided by instmap the walk recursively resolves each expression eused in the right hand side of an assignment to the original tainted data definition.
the detailed algorithm is presented in algorithm .
in particular the ptr rexp generation algorithm takes in an instruction address p a value vfor a tainted operand and a global instmap t. as a base case line when the address is pcp null our resolution is complete and we return v. note that the base case is reached when taint is first introduced.
to see this we only add to theinstrecord at such sites.
the algorithm recursively walks the instrecord indexed by pc and produces a final expression for the tainted operands.
in the following we present a representative example to show how we perform the address resolution.algorithm on demand ptr rexp generation let rec resolve data path p pc v value t instmap exp ifp then value v else let sem op1 op2 hashtbl.find t pin match semwith move resolve op p op1 t binary binop resolve op p op1 t resolve op p op2 t call mem resolve op p op1 t and resolve op p pc op taintop t instmap exp match opwith memoptaint v1 pc1 v2 pc2 scale disp let regvalue1 resolve data path pc1 v1 t in let regvalue2 resolve data path pc2 v2 t in deref regvalue1 regvalue2 scale disp regoptaint v3 pc3 resolve data path pc3 v3 t nooptaint value example.
consider the third example in table again.
when the instruction 0xd894e013 call 0x8 eax is executed the targeted memory address is 0xc028ea88 as eax 0xc028ea80 .
because this instruction generates a new memory reference we will have a new instrecord for address 0xc028ea88 as s 0xd894e013 !
call mem 0xd894e00c 0x8 .
since the pcpin the baseaddr reg is 0xd894e00c and not null as shown in the 5throw in table we recursively resolve the operand resolve op with pc 0xd894e00c and a memoptaint .
note that according to the instmap the instrecord indexed by 0xd894e00c is mov m2r 0xd894e007 0x20 .
now pcpis 0xd894e007 also not null and we have to recursively resolve the operand with pc 0xd894e007 and a memoptaint and theinstrecord indexed by 0xd894e007 is mov m2r 0xc034bc78 .
now that the pcpis null we will directly output a value v which is and return.
because of the recursion a deref will be called and it will dump a ptr rexp of the function pointer as 0xc034bc78 0x20 0x8 .
using this ptr rexp we can precisely locate the function pointer at the untrusted memory mu.
note that this example is actually the read function for the proc file system in linux kernel .
.
.
from this example we see that although read may be dynamically loaded and the structure pointer f ops could be in kernel heap we can still locate it precisely in an untrusted kernel memory by using its ptr rexp .
.
handling practical issues handling loops .because of the use of recursive data structures e.g.
arrays link lists and trees one pc can be used multiple times with different targeted memory addresses in a ptr rexp .
for instance to remove a linux kernel module kernel will iterate each module descriptor to find the to be removed module and then call module.exit function.
during the iteration instruction that iterates module.list.next will be used multiple times to reach the final desired module.
then if we back track the dependence graph from the instrecord hashtbl examples shown in table we will not be able to find the unique path.
as such we introduce a counter to our pc to make the back tracking unique and generate an abstract ptr rexp for the recursive data structures.
more specifically all of our own data structure defined in fig.
will not be changed except that the pcbecomes pc counter where counter is initially and gets increased by whenever encountering a new data dependence while iterating the loop.
however directly using the above pc counter dependence graph would only capture one instance of ptr rexp .
therefore we would like to generate an abstract representation that captures all of its instances.
to generate an abstract ptr rexp we need to build a path graph g v e which captures the dependencies among the instructions that are used to calculate the address of the function pointer.
here node vdenotes the instructions involved in the address calculation and edge edenotes the dependencies between the instructions.
gis built when we back track the instrecord .
then we traverse gto generate the abstract representation of the recursive ptr rexp .
similar to regular expressions where a string can have one or multiple appearances our abstract representation of the ptr rexp can capture the cases where one or multiple dereferences are needed to reach a particular pointer instance.
details are elided due to space limitation.
pruning the ptr rexp of non persistent pointers.
it is possible that a function pointer can only exist in certain time window e.g.
kernel could allocate a dynamic object at certain context and later remove it.
we call this pointer non persistent.
for any snapshot based memory analysis we have to exclude them because we cannot check them in a reliable way unless with execution context information .
to prune these non persistent pointers our approach is quite straightforward.
specifically we just take nnumber of memory snapshots running with diverse workloads to perform the cross check during the dynamic execution phase which is also how hookscout inspects whether a pointer is persistent.
currently we set nas .
if the pointer exists over all the memory snapshots by traversing them through our ptr rexp then we keep it.
otherwise we will not check these pointers.
merging the target values for mutable pointers.
also a persistent pointer can change its value during its life span.
therefore when checking its integrity we have to be aware that such a pointer could have a set of trusted values.
to this end we just merge these values whenever we observe there is a different trusted value in the trusted memory snapshot.
.
pointer integrity checker given a ptr rexp of a kernel function pointer f with a trusted kernel memory snapshot mtand an untrusted kernel mu our pointer integrity checker aims to identify whether fhas been compromised by comparing ptr rexp f mt andptr rexp f mu where ptr rexp a m denotes the concrete address when following the ptr rexp ofain snapshot m. there are two steps in this comparison.
step i direct value comparison for core kernel code.
iff points to core kernel code which are those excluding kernel modules and the value of ptr rexp f mu belongs to the trusted values set from ptr rexp f mt meaning that this pointer is not compro a relocation tableoffset type value 0000000d r 386 pc32 current kernel time00000013 r 386 32 init task0000001c r 386 32 init task00000031 r 386 32 .rodata.str1.
... init module push ebp push edi push esi push ebx ec sub 0x10 esp 8d lea 0x8 esp eax b push eax c e8 fc ff ff ff call d init module 0xd 8b 1d mov 0x50 ebx eb sub 0x50 ebx 1a fb cmp 0x0 ebx 8b 7c mov 0x8 esp edi 8b 6c 0c mov 0xc esp ebp je 4b init module 0x4b 2a ff b3 push 0x88 ebx push 0x0 ... b disassembly of the static code 0xd894e000 push ebp0xd894e001 push edi 0xd894e002 push esi 0xd894e003 push ebx0xd894e004 ec sub 0x10 esp0xd894e007 8d lea 0x8 esp eax0xd894e00b push eax 0xd894e00c e8 e0 7c e7 call 0xc011c054 0xd894e011 8b 1d 7a c0 mov ds 0x3fd78570 ebx0xd894e017 eb sub 0x50 ebx0xd894e01a fb 7a c0 cmp 0xc0287a40 ebx0xd894e020 8b 7c mov ss 0x8 esp edi0xd894e024 8b 6c 0c mov ss 0xc esp ebp 0xd894e028 je 0xd894e04b 0xd894e02a ff b3 push ds 0x88 ebx 0xd894e030 a4 e0 d8 push 0xd894e0a4... c disassembly of the dynamically loaded code in memory snapshotfigure code differences in static disk image and dynamic memory snapshot for the same function mised in mu then we directly return since this pointer is trusted.
otherwise if it points to kernel modules goto step ii .
otherwise we return this pointer has been compromised.
to decide whether a pointer points to core kernel code or kernel module is trivial because we have the trusted kernel.
in our analysis phase we check each ptr rexp and verify its target address.
if it does not belong to kernel module then we conclude its the core kernel code and directly compare the values.
step ii direct target comparison for kernel modules.
when fpoints to kernel modules it becomes more sophisticated as we cannot compare its value with the trusted kernel any more.
instead we have to compare its targeted code.
before presenting our solution we would like to first examine how a kernel module is loaded and what the code difference is in different executions.
in general kernel code is composed of static core kernel code and dynamically loaded kernel modules.
functions in dynamically loaded kernel modules may be loaded to different memory addresses.
as a result some of the operands of some instructions need to be dynamically patched when loading the modules.
the patching is informed by the relocation table in the binary code generated by compilers.
for example as shown in fig.
c for a kernel module code snippet which is disassembled from a memory snapshot compared to fig.
b we could find there are four operand patches at relative offset 0xd 0x13 0x1c 0x31 and these locations are specified in the relocation tables in the module s binary code.
such a dynamic patching mechanism works for both windows and linux kernel modules.
619table the number of exercised reference path.
kernel versioncall mem call reg jmp mem jmp reg .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
average therefore our solution is to directly compare the code page of the targeted function body in both muandmt.
more specifically since we have the starting address of the function that is the pointer value and the relocation table of the targeted module that is from the trusted kernel then we compare each un patched byte the patched byte is informed by the information stored in the relocation table until the end of the function.
we can know the end address of the target function because we have the ground truth of the trusted kernel modules and they are not usually obfuscated that also explains why fpckrejects the unknown kernel modules .
there could be some optimizations such as only comparing the first x bytes of the code.
in our design we just compare the entire function body.
.
ev aluation we have developed a prototype of fpckwith over 10k lines of our own c code.
among then 8k lines of the code loc belongs toptr rexp extractor which is built atop qemu .
and the rest 2k loc belongs to the pointer integrity checker that is an independent program which scans the memory normalizes the instruction byte in the target page and performs the comparison.
in this section we present our evaluation result.
we first tested the effectiveness offpckwith a number of linux kernels and a number of kernel rootkits in .
.
we report the performance of each component of fpckin .
.
all of our experiments were carried out on a host machine with intel xeon w5620 cpu 24g memory running red hat enterprise .
with linux kernel .
.
.
.
effectiveness experiment setup.
we acquired an extensive test case suite from the linux test project ltp for our dynamic analysis.
the ltp consists of a large set of regression tests designed to confirm the behavior of a linux kernel.
in total we downloaded test cases from ltp.
interestingly the ltp test suite has several test cases for each specific aspect of linux kernel and we consider these cases as duplicates since they all test the same kernel functionality.
thus we select only one test case from each functionality test suite to be part of our test cases.
also we limit each test case to be finished in minutes.
if not we removed it from our final set of test cases.
after applying these constraints we end up with test cases which we package them in a script file and automatically execute them in the trusted os.
result.
to test how effective our kernel ptr rexp extractor is we took linux kernels.
as shown in table for each tested linux kernel installed with the default kernel modules or device drivers we evaluated how many ptr rexp we extracted from the indirect control flow transfers.
specifically these indirect control flow transfers include indirect calls via a memory address call mem indirecttable kernel pointer check with linux rootkits.
denotes there is no trusted value.
symbol name of trusted hijackedrootkitthe pointer value valuejcj module init 0xd0923ad6 moduel exit 0xd0923af7 sys read 0xc0144d27 0xd092343c override sys chdir 0xc0143ced 0xd0923001 sys getuid 0xc011f59c 0xd09232ce sys geteuid 0xc011f5ac 0xd09232f1 sys getdents64 0xc0154292 0xd0923314 module init 0xd09267e8 module exit 0xd0926896 sys fork 0xc010488a 0xd092651e sys write 0xc0144d8a 0xd09265f6 synapsys .
sys open 0xc014444c 0xd0926000 sys kill 0xc0121fa5 0xd09264c5 sys clone 0xc01048a4 0xd092657f sys getdents 0xc0154082 0xd09265e0 sys getuid 0xc011f59c 0xd09263f9 module init 0xd091b1aa module exit 0xd091b215 sys utime 0xc0143970 0xd091b000 kbdv3 sys getuid 0xc011f59c 0xd091b142 sys utimes 0xc0143b84 0xd091b097 sys read 0xc0144d27 0xce271000 sys open 0xc014444c 0xcdde6000 phalanx b6 sys newlstat 0xc014c7ad 0xcdde3000 sys lstat64 0xc014c9a8 0xcdde2000 tcp4 seq show 0xc022be91 0xcdde5000 module init 0xd8985000 module exit 0xd897f9b4 ext3.ext3 readdir dynamic 0xdd97f774 adore .
do sync write 0xc0144bb0 0xd897f8a4 proc root readdir 0xc016b608 0xd897f477 proc root lookup 0xc016b5ba 0xd897f13e module init 0xd091b05d rkit .
module exit 0xd091b097 sys setuid 0xc0123209 0xd091b000 suckit idt enty 0x80 0xc0105f68 0xcc8c0906 module init 0xd08c3000 hookswrite module exit 0xd0843216 idt enty 0x80 0xc0105f68 0xd0843000 module init 0xd08a119c int3backdoor idt enty 0x3 0xc0106b48 0xd08a1000 call via a register call reg indirect jumps to a memory address jmp mem and indirect jumps via a register value jmp reg .
we can see from table that our extractor has revealed thousands of reference expressions to reach those kernel function pointers and the majority of them are from indirect call mem cases.
since our extractor is dynamic analysis based certainly it does not expose all of the kernel function pointers.
however it has exercised those commonly used which are also usually of attackers interest as discussed below.
checking the function pointer integrity.
we also evaluated pointer value comparer to check the function pointer integrity of linux kernel .
.
.
we took 9real word rootkits from packetstormsecurity.org for this experiment.
the detailed result is presented in table .
note that we tweaked the code of synapsys .
and suckit such that they can be compiled on our testing kernel.
the rest were compiled and ran without any change.
for each rootkit we present the symbol name of the function pointer in the 2ndcolumn of table the trusted value of the function pointer in the 3rdcolumn and the hijacked value in the 4thcolumn.
finally we present the length of the data reference chain jcj in the last column.
as we can see from this table that for each rootkit fpck successfully identified all the hijacked pointers without any false positives fp or false negatives fn .
among these hijacked pointers pointers are pointing to the core kernel code and we .perlbench .bzip2 .gcc .mcf .gobmk .hmmer .sjeng .libquantum .h264ref .omnetpp .astar .xalancbmk averagenormalized performance overheadw o extractor w extractor figure performance evaluation with spec cpu2006 programs on linux kernel.
can directly see and compare with the trusted value to detect the contamination.
the rest pointers point to kernel modules and they have dynamic addresses.
fpckwill compare their targeted function bodies instead of the values to decide their contamination.
note that we have acquired the source code of these rootkits and we thus have the ground truth of the function pointers these rootkits hijacked.
there are also several interesting findings for these rootkits.
in particular two rootkits directly modify kernel function pointers suckit via dev kmem phalanx via dev mem and the other seven are implemented using kernel modules.
fpckquickly identified the suspect kernel function pointers such as module init andexit .
also because we tested these rootkits one by one they were always inserted to the head of kernel module list.
that is why the jcjof init andexit functions for the rootkits are all with a ptr rexp as 0xc041da18 0x68 and 0xc041da18 0x188 respectively.
also why its jcjis for ext3 readdir and the reason is the derived ptr rexp extractor ofext3 readdir is fetched from current fs struct dentry inode file operations readdir itsjcjis we can also notice that the majority of these rootkits tend to hijack the core kernel function pointers in global regions such as the system call table except adore .
which hijacks a kernel module function ext3 readdir .
therefore we believe that to hijack the kernel control flow attackers are more in favor of the pointers that are always present in the memory such as the system call tables and are frequently used.
again these pointers are the persistent function pointers that f pckaims to discover.
.
performance overhead extractor.
ourptr rexp extractor instruments each kernel instruction to capture the pointer reference expressions.
to evaluate this overhead namely how slow an analyst will feel while using fpck to extract the ptr rexp we took spec cpu2006 benchmark programs and executed them atop our instrumented qemu.
the result is presented in fig.
.
we can notice that the overhead for these programs ranges from .6x for program .hmmer and .h264ref to .4x for .gobmk with an average overhead of .3x for these benchmark programs.
overall we can observe that for programs with system call intensive execution they tend to have larger overhead and these overhead mainly comes from our data dependence tracking at kernel level.
note that the instructions of user level programs will not be monitored and our extractor only instrumentskernel level instructions.
meanwhile it is worth noting that extractor will be only executed in offline analysis.
checker.
from our design we can notice that the major overhead of our integrity check comes from identifying the function pointer location in muby following their ptr rexp for all identified persistent pointers exposed by our extractor comparing the value or the byte stream of the targeted function code.
this overhead is what a fpckuser eventually has.
it turns out that this overhead is pretty small.
in particular it took less than a second more precisely .10s on average to check a 1g physical memory image in finding the hijacked pointers by each rootkit in table .
note that our integrity check is not a brute force scanning of all kernel memory and instead it is guided by a static representation of the addresses of the persistent kernel function pointers.
.
limitations and future work increasing the coverage.
first like all other dynamic analysis fpck s results depend on the code coverage at of the running test cases and it could miss certain execution paths and have false negatives when recognizing hijacked kernel function pointers.
though we have tried our best to combine as many test cases as possible we have to emphasize that fpckitself is not a code coverage technique .
rather it has used the test suites to cover as many of the kernel execution paths as possible these test case exercised paths are also often of interest to kernel rootkit developers .
certainly any code coverage improvement techniques will make fpckmore practical.
therefore we plan to investigate other techniques such as symbolic execution e.g.
to systematically expand and increase our coverage.
handling temporary pointers.
temporary pointers include nonpersistent pointers that may or may not exist as well as the local pointers including the function argument pointers only reachable in certain execution context.
our ptr rexp extractor currently does not cover these temporary pointers and instead all of the supported pointers start from kernel global variables and they are persistent.
the reason why fpckdoes not check these temporary function pointers is that memory snapshot is context less it can be taken at arbitrary moment .
therefore we are not able to reliably check these pointers.
this also introduces problems for attackers as they cannot reliably tamper with them at arbitrary time that is why they are more in favor of persistent pointers as discussed earlier .
one possible avenue to address this problem is to recognize the execution context e.g.
the call stack of each live kernel execution path in the memory snapshot and associate the context to these temporary function pointers.we leave the investigation of these techniques in our future work.
addressing other attacks.
fpckcurrently focuses on kernel function pointer hijacking attacks exclusively and it does not handle other attacks such as the direct kernel object manipulation dkom .
for the recent rop based data only rootkits we believe highly likely fpckis able to detect them because these attacks still hijack the kernel function pointers instead of the return addresses as in and also they make these pointers pointing to the existing kernel code gadget and our hash based integrity checker will be able to spot them.
we leave the evaluation of detecting these data only rootkits also in our future work.
other limitations.
we assumed the kernel code is immutable when designing fpck.
however recently linux and various bsds began to support in kernel just in time compilation as shown in the network packet filter implementation .
also kernel tracing and 621interception mechanisms rely heavily on the runtime code patching e.g.
ftrace and detours which will also modify the kernel code.
certainly f pckwill not work in these situations.
.
related work since the favorite targets of many kernel attacks are the function pointers there is a large body of research focusing on locating the kernel pointers and checking their integrity.
in this section we review and compare f pckwith these related works.
intuitively locating a kernel function pointer in memory would require the kernel data structure definitions.
therefore sbcfi made an early attempt of extracting the kernel data structure definitions through analyzing the kernel source code and generating a type map of kernel objects in order to identify the compromised persistent function pointers in kernel memory.
later on various approaches have been proposed to address the limitations of sbcfi e.g.
cannot type void pointers cannot prevent pointer hijacking other than the detection and does not attempt to recognize the invariants by systems such as gibraltar kop hooksafe livedm osck and mas .
from binary analysis perspective a number of profiling systems were proposed to understand the kernel malware behavior including the function hooking.
hookfinder tried to identify the hooks compromised by kernel rootkit by performing an impact analysis using dynamic tainting.
hookmap leveraged dynamic slicing to identify the potential hooks in the execution path used by security applications.
it also required kernel symbols to annotate the hooks.
poker studied the multi aspect of kernel rootkit by traversing the type graphs extracted from the debugging information or the kernel source code.
without accessing the kernel source code k tracer achieved similar goals for rootkit profiling through dynamic binary analysis but required the knowledge of important kernel data structures e.g.
eprocess in windows .
memory analysis based approach can only detect the tampering with the kernel function pointers.
to have prevention capability hookscout proposed a proactive defense by tracking the kernel heap object that contains the function pointers and preventing unauthorized modification against them.
these objects are identified by tracking whether the value of a static function pointer flows to the kernel object.
if so the object must contain a kernel function pointer.
the values of a function pointer were pre identified using a static binary code analysis facilitated by the relocation information from the kernel binary.
hookscout also required the cooperation of an in vm kernel module.
in addition it cannot be used for snapshotbased memory analysis since it does not tell how a function pointer can be reached in the kernel heap.
most recently hooklocator demonstrated that we can periodically check the integrity of the persistent function pointers in the kernel heap pool.
these heap function pointers are identified by comparing with the known function pointer values which are pre extracted through relocation table guided approach as hookscout or through a cross comparison approach between memory snapshots.
while hooklocator does not require the entire kernel data structure knowledge it still needs to know how to traverse the kernel heap pools.
besides hooklocator blacksheep was another lightweight approach to identify the contamination of persistent kernel function pointers.
it did not intend to precisely identify the locations of the function pointer and then perform the integrity check but rather directly identify them through a pattern matching based cross comparison approach among a crowed vms since cloud usually hosts many homogeneous vms.
therefore as summarized in table we can notice that the existing efforts require either kernel source code or debugging symbols table comparison with the most related works.
systems wo source code wo kernel symbols wo relocation table wo kernel data structure wo in vm assistance wo pattern matching continuous monitoring snapshot based profiling detection sbcfi 7x x 7x x 7x 7x hookfinder x x x x x 7x hookmap x 7x x x x x 7x gibraltar 7x x 7x x 7x x x k tracer x 7x 7x x x 7x poker x 7x x 7x x kop 7x x 7x x 7x x x hooksafe x x x x hookscout x x 7x 7x x 7x x livedm x 7x x x 7x x osck x 7x x 7x x x huko x 7x x 7x x x mas 7x x 7x x 7x x x blacksheep x x x x x x x x hooklocator x x x x x x fpckx x x x x x 7x x x or relocation tables or kernel data structure definitions to locate the kernel function pointers.
there are other approaches that can directly work on binary as in hooklocator but rely on certain heuristics to identify the kernel function pointers such as purely based on the values which may lead to false positives.
for instance there could be cases that a kernel heap object contains a large integer value which looks like a function pointer.
in this way hooklocator will make mistakes.
as such we still need techniques that can directly extract the locations of persistent kernel pointers including those allocated in the dynamic kernel heap and then inspect their integrity based on their locations.
fpckis exactly designed to achieve these goals.
.
conclusion we have presented fpck a binary exclusive approach for automatically locating kernel function pointers for their integrity checking.
to locate the function pointers we propose an on demand pointer reference expression generation algorithm that extracts data reference expressions for kernel pointers during the kernel execution.
this pointer reference expression encodes how a pointer is accessed through the combination of a base address usually a kernel global variable with certain offset and further pointer dereference operations and allows us to locate them in different instances of a kernel memory.
to check their integrity we propose to compare the function pointers of an untrusted kernel memory image against the ones in the trusted kernel.
we have implemented a prototype of fpck.
our experimental results with a number of real world kernel malware form linux platform show that fpckcan automatically identify all the hijacked pointers for these testing samples within just few seconds.
we believe fpckwill be particularly useful for both public and private cloud providers to check the guest kernel integrity and estimate the function pointer damages inflicted by kernel malware.
.
acknowledgement we thank the anonymous reviewers for their insightful feedback.
this research was partially supported by an afosr grant fa955014 and an nsf grant .
any opinions findings conclusions or recommendations expressed are those of the authors and not necessarily of the afosr and nsf.
.