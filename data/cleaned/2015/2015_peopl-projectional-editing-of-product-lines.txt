peopl projectional editing of product lines benjamin behringer university of luxembourg luxembourg htw saar germanyjochen palz htw saar germanythorsten berger chalmersjuniversity of gothenburg sweden abstract the features of a software product line a portfolio of system variants can be realized using various implementation techniques a.k.a.
variability mechanisms .
each technique represents the software artifacts of features differently typically classified into annotative e.g.
c preprocessor and modular representations e.g.
feature modules each with distinct advantages and disadvantages.
annotative representations are easy to realize but annotations clutter source code and hinder program comprehension.
modular representations support comprehension but are difficult to realize.
most importantly to engineer feature artifacts developers need to choose one representation and adhere to it for evolving and maintaining the same artifacts.
we present peopl an approach to combine the advantages of annotative and modular representations.
when engineering a feature artifact developers can choose the most suited representation and even use different representations in parallel.
peopl relies on separating a product line into an internal and external representation the latter by providing editable projections used by the developers.
we contribute a programminglanguage independent internal representation of variability five editable projections reflecting different variability representations a supporting ide and a tailoring of peopl to java.
we evaluate peopl s expressiveness scalability and flexibility in eight java based product lines finding that all can be realized that projections are feasible and that variant computation is fast 45ms on average for our largest subject berkeley db .
i. i ntroduction a software product line spl is a portfolio of systems engineered in a specific application domain such as telecommunication automotive or industrial automation .
the individual systems of an spl called variants orproducts share commonalities and variabilities.
as such constructing an spl amounts to engineering common and variable software artifacts each of which realizing one or several features .
individual variants are derived from the spl in an automated process by selecting the desired features of the variant.
many implementation techniques so called variability mechanisms have emerged for engineering spls such as variability annotations templates deltas or feature modules .
these techniques represent features differently typically classified into annotative and modular approaches each having their own advantages and disadvantages.
annotative approaches e.g.
the c preprocessor cpp represent all feature artifacts directly in the codebase by wrapping them with annotations.
such annotations are easy to apply but challenge program comprehension by obscuring the structure and data flows of source code hampering editing experience and negatively impacting maintenance and evolution .
moreover developers always see all possiblevariants many of which might not be relevant for the current engineering activity.
modular approaches e.g.
ahead and featurehouse represent all of a feature s artifacts in one module.
they facilitate a clear structure of the system and allow engineering features without being distracted by irrelevant ones.
yet decomposing a system into modules is challenging since it requires finding the right decomposition strategy and since creating modules imposes substantial overhead.
although these representations are complementary existing spl engineering approaches typically focus on one representation.
most importantly these approaches force developers to choose one representation for developing a feature artifact and to adhere to it for evolving and maintaining this artifact.
while refactorings were proposed for switching between annotative and modular representations such refactorings are heavyweight and do not allow to quickly switch the representation for a feature artifact.
ideally developers could exploit the benefits of different representations on demand and always choose the one that suits the current engineering activity.
we present the approach peopl projectional editing of product lines to realize this flexibility.
it allows developers to flexibly choose the best suited among very different representations of feature artifacts.
developers can also use various representations in parallel side by side for the same artifact.
the core idea of peopl is to establish an internal representation of the spl and separate it from the external representations that developers use.
fig.
1illustrates this idea.
internally the feature artifacts are uniformly represented in a variational abstract syntax tree ast whose nodes are annotated using concepts from our variability language corevar which is programming language independent.
the variational ast is manipulated using editing operations we conceived upon corevar.
for meaningful variational asts corevar can easily be tailored to specific programming languages.
we provide such a tailoring for java declaring which of its language concepts are annotatable.
externally this variational ast is represented editing variability realizationprojectionsdeveloperrendering target language core variability language corevar target language specific corevar tailorings e.g.
javavar modularannotativeblendedvariantext.... rendering rules editing operations...common variational astinternal representationexternal representation figure .
peopl separates internal and external variability representations ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
using different editable projections which developers use to engineer feature artifacts.
any of their editing activities directly change the underlying ast which immediately updates all projections.
we conceive projections showing feature artifacts as i textual annotations ifdef ii visual annotations colored bars iii feature modules iv annotations blended into feature modules and v variants i.e.
hiding artifacts related to non selected features .
we show the feasibility of our approach by realizing a complete ide built upon the language workbench jetbrains meta programming system mps .
it realizes our projections and operations for engineering feature artifacts while benefiting from common program editing facilities e.g.
for java in mps.
we evaluate peopl using eight java spls.
our largest subject and running example is berkeley db an spl with 70kloc including features and classes.
peopl s expressiveness suffices to realize all spls without workarounds.
the evaluation also shows that it is feasible and practical to conceive an internal representation that is projected into very different external representations.
furthermore our approach scales all projections can be rendered and edited without introducing significant latencies.
for instance variant editing is smooth since computing a specific file variant 1ms on average for all subjects and calculating all ast nodes included in a variant is quick 45ms for berkeley db on average .
we contribute the core variability language corevar a tailoring of it to java five editable projections an ide realizing our approach evaluation data for eight spls and an online appendix with a replication package and screencasts.
ii.
m otivation and background we briefly discuss contemporary approaches to engineer spls together with their advantages and disadvantages.
annotative representations.
mechanisms such as the cpp and cide represent feature artifacts as annotation markers embedded into source code.
the markers are either textual e.g.
ifdef or visual e.g.
background colors and have a boolean expression over features.
variants are derived by removing the annotated code whose expression evaluates to false for a concrete selection of features.
fig.2a shows a cpp based excerpt from berkeley db.
ifdefs e.g.
line and endifs mark the beginning and the end of variable source parts belonging to a feature.
notice lines and partially annotating the if statement i.e.
not the body .
such annotations are called undisciplined.
in java annotations on one or a sequence of entire classifiers e.g.
classes members e.g.
method declarations and statements are disciplined all others are undisciplined.
since in practice around of all annotations are undisciplined approaches such as peopl need to support them.
annotations are easy to incorporate and frequently used in practice .
artifacts can be annotated in an ad hoc fashion on a very fine grained level individual code lines or ast nodes .
for instance annotations can even wrap expressions or method parameters.
in contrast annotations are known to negatively impact program comprehension 1234567891011121314151617181920class in loc void init more code ifdef latches latch ls.mklatch endif more code boolean latchnowait ifdef latches if latch.aquirenowait endif more code return true ifdef latches else return false endif a ifdef variabilityb featurehouse modulesbasepublic class in void init more code init latches hook more code void init latches hook boolean latchnowait more code return true 1234567891011public class in void init latches hook latch ls.mklatch boolean latchnowait if latch.aquirenowait original else return false 123456789latchesfigure .
berkeley db feature latches realized in cpp and featurehouse as well as maintenance and evolution .
they clutter source code and developers have to work with all variants at a time since features cannot be edited in isolation.
modular representations.
mechanisms such as ahead featurehouse and deltaj represent the artifacts of a feature and the interaction of features in a cohesive unit called composition unit feature module delta module or just module .
the key idea is to start with a common base module and use other modules to introduce new structural elements refine existing elements and even remove elements step by step.
deriving a variant amounts to composing or applying the modules in a given ordering .
fig.2b shows a featurehouse realization of the two berkeley db features base andlatches .
the method latchnowait is introduced by the feature base lines and refined by latches lines .
note featurehouse s keyword original in line to call the original implementation of latchnowait inbase .
refining the method init requires a hook method in thebase code line as modular approaches do not support fine grained changes .
the hook s declaration is left empty inbase line since it is overridden by latches lines .
modularity fosters comprehension .
a module can be edited without being distracted by irrelevant feature code .
for example instead of searching for latches code in around loc developers can just explore the respective feature module which is less intellectually challenging .
in contrast the effort to create modules is typically high since developers need to find the right decomposition strategy which hinders adoption in practice.
it is also difficult to realize fine grained features which might require boilerplate code e.g.
hook methods or code clones.
variant representations.
typically realized upon an annotative representation so called variation control systems or variant editors allow editing spl variants in isolation.
some approaches fold or hide feature code others mimic the workflow of version control systems by allowing to checkout variants edit them and commit the edited variants .
in fig.
2a for instance we would hide a feature s annotations and code if irrelevant for the current code editing task e.g.
modifying code of the feature latches .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
variant editors reduce editing complexity which can positively impact efficiency up to .
in contrast they do not provide true modularity and easily face code alignment issues with respect to the hidden code .
furthermore a checkout edit commit workflow imposes an overhead.
iii.
pe opl o verview we discuss peopl s key benefits and illustrate how developers can use it.
we also provide an overview of its architecture.
fig.3shows an excerpt of our running example berkeley db realized in peopl.
the upper half of the figure shows the different projections we explain in this section.
the lower part illustrating the internal representation is described in sec.
iv.
a. peopl s benefits the benefits of our approach can be summarized as follows.
first peopl has a uniform internal representation a variational ast defined by the corevar language designed to support diverse external variability representations.
uniformity allows persisting variability in a consistent manner.
using different internal representations for feature modules and for annotations would break uniformity for instance when adding ifdefs into featurehouse modules.
second developers can switch the external representation of an artifact e.g.
class on demand.
peopl allows a fluent movement between external representations e.g.
of databaseimpl in fig.
to enable developers to exploit the distinct advantages of different techniques for a given task.
third developers can observe and edit the same artifact using different external representations in parallel by showing them side by side enabling an even faster movement between representations.
moreover it helps observing the impact of changes made in one representation to another in real time e.g.
editing a feature module and a variant in parallel .
fourth peopl mitigates typical shortcomings of modular representations imposed by granularity problems and the lack of context information as they are contained in external modules .
by blending annotations into modules on demand developers can realize fine grained changes in feature modules without breaking modularity and uniformity and integrate context information from other modules on demand e.g.
accessible field and method declarations .
fifth our uniform internal representation enables plugging new external representations into peopl on demand.
thus peopl can serve as a framework to evaluate representations.
b. peopl in practice we conceive realize and evaluate five external representations.
textual annotation projection.
reflecting cpp s popularity we provide a projection with cpp annotations as shown in fig.3a.
as most developers are familiar with cpp yet not with peopl s other representations starting by adding and exploring ifdefs is a useful option.
notice that peopl also supports various undisciplined annotations.
lines show such undisciplined annotations on types method parameters and wrappers.
the latter are program elements that wrap codeblocks body .
in practice it is sometimes necessary to only make the wrapper variable but not its body wrappee .
visual annotation projection.
when ifdefs clutter code and challenge comprehension we can switch to visual annotations.
the learning curve is low since ifdef directives and visual annotations can be explored for the same feature artifact in parallel.
fig.
3c shows a projection of the class databaseimpl with annotations represented as colored bars each related to a feature declared in fig.
3b.
for instance lightgray bars relate to feature base .
vertical bars are shown to the left of the program code and align with its indentation.
horizontal bars underline fine grained feature artifacts within a line of code e.g.
method call parameters in line and partially annotated wrappers e.g.
the try catch statement in line .
the sign in line makes alternatives explicit.
module projection.
now imagine we want to evolve the memory budget feature or fix a bug in it.
obviously it is beneficial to edit the class databaseimpl in isolation and therefore switch from the annotative projection to the feature module implementing memory budget .
fig.
3d shows the projection.
similar to ahead the refines keywords indicate that the feature module memory budget modifies the class databaseimpl the inner class preloadprocessor and its method processlsn lines .
blending projections.
fig.3c shows several fine grained feature artifacts scattered base code lines and alternative return types line and parameter variability line .
these cannot be implemented without workarounds in classical modular approaches .
although we could explore the annotative and the modular projection in parallel it might be beneficial to allow integrating annotation markers into feature modules as shown in fig.
3d statement level markers in lines .
to avoid obfuscation only memory budget code is shown.
all other code is hidden.
this way the granularity trade off can be addressed and fine grained changes implemented.
yet the surrounding code might be important for comprehension.
for instance the variable maxbyte in line of fig.
3d is declared in the hidden base code from line of fig.
3c which can be shown on demand.
variant projection.
now imagine we want to evolve the features base andmemory budget or fix a bug that occurs when both features are enabled.
we could show all feature artifacts of base by expanding annotation markers in the module memory budget or switch to a corresponding variant editor as shown in fig.
3e.
among others this allows exploring variant specific code and control flows in isolation.
to understand which code artifact implements which feature we can show colored bars not depicted .
in summary developers can use the best representation of feature artifacts for an spl engineering task and observe the impact of changes in real time supporting the comprehension of individual features their combinations and the whole spl.
c. peopl s architecture we implement the peopl approach that is its internal and external representations upon the language workbench authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ifdef base class databaseimpl static class preloadprocessor ... ifdef statistics preloadstats else void endif preload preloadconfig c long maxbyte c.getmaxbyte ifdef memory budged if maxbyte more code endif ifdef statistics preloadstats ret new preloadstats endif preloadprocessor cb new preloadprocessor envimp maxbyte ttime ifdef statistics ret endif more code ifdef statistics try endif walker.walk ifdef statistics catch haltpreloadexception hpe ret.status hpe.getstatus endif more code ifdef statistics return ret endif endif1234567891011121314151617181920212223242526272829303132333435class databaseimpl long maxbyte c.getmaxbyte more code if maxbyte more code preloadstats ret new preloadstats preloadprocessor cb new preloadprocessor envimp maxbyte ttime ret more code try walker.walk catch haltpreloadexception hpe ret.status hpe.getstatus more code return ret void preloadstats preload preloadconfig c static class preloadprocessor void processlsn long c logenttyp t assert c !
dblsn.null lsn if envimp.getmemorybudget .get if childtype.equals ... more code 123456789refines class databaseimpl refines void preload preloadconfig c 1refines static class preloadprocessor refines void processlsn long c logenttyp t original c t if envimp.getmemorybudget .get module memory budget class databaseimpl static class preloadprocessor void processlsn long c logenttyp t assert c !
dblsn.null lsn if envimp.getmemorybudget .get void preload preloadconfig c long maxbyte c.getmaxbyte more code if maxbyte more code preloadprocessor cb new preloadprocessor envimp maxbyte ttime more code walker.walk if maxbyte more code1112a textual annotation projectionc visual annotation projectiond module projection with annotation marker blending e variant projection base and memory budget selected basestatisticsmemory budgetfeature module declaration of berkeley dbb feature module declaration editing operations menu assign variability to returnstatement assign alternative to returnstatementf variational ast baserenderingrenderingrenderingmethoddeclarationprocesslsn classconceptdatabaseimplmethoddeclarationpreloadreturntypevoidreturntypepreloadstats nonoptional alternativef4.1f4.2vp4assertstatementassert c ...ifstatementchildtype... featureblockvariabledeclarationcb variable reference ret...featureblockfeature blockreturnstatementret......ifstatementenvimp.........statementlistfeatureblockbodycatchclause...classcreatorclassconceptpreloadprocessorf0f5f6f7f9 trystatementf10f8f11f12vp0statementlist featureblockf2 featureblock featureblockf3f1vp1vp2vp3vp5vp6vp7vp8 vp9vp10vp11vp12 ......... statisticsmemory budgetvariant projection for base and memory budget wrappereditable projections external representation variational ast internal representation 13codemorecodemorecodemore codemorefigure .
excerpt of berkeley db in peopl.
top projections used by developers external representation .
bottom variational ast internal representation jetbrains mps .
mps relies on a technology called projectional editing a.k.a.
structured editing orsyntax directed editing which is conceptually different from parser based editing .
developers editing gestures directly change the underlying ast which is rendered into a concrete syntax.
no parsing is involved.
while the editing experience is different and editing efficiency has long been questioned modern projectional editors allow efficient editing .
in mps a language s abstract syntax is defined using socalled language concepts a.k.a.
meta classes which define the structure of their instances ast nodes .
each concept has its own concrete syntax defined by rendering rules a description of how ast nodes appear in a projectional editor.
we realize the languages corevar and javavar both are explained shortly in mps as follows.
the concepts of corevar used to add variability to target languages are implemented using mps core meta modeling facilities for declaring languages.
the javavar language the tailoring of corevar to java reuses concepts from corevar and extends mps meta model of java.
our five projections are packaged in mps also as languages which contain both target languageindependent and dependent rendering rules.iv.
pe opl sinternal representation we now present the concepts of peopl s internal representation the corevar language operations for editing the ast variant derivation and the tailoring of corevar to a target language.
a. the corevar language formalism.
corevar adopts modifies and extends the structured document algebra sda an abstract formalization of feature modularity.
the sda enables variability through feature modules which assign fragments tovariation points vps .
letv fvp1 vp gbe a set of vps and f ff1 f2 ga set of fragments.
a module m v fis an injective partial function assigning fragments to vps.
in contrast to sda not using an injective function fragments are unique to a vp which is not a limitation but eases our implementation.
the domain dom m of a module mis the set of vps assigned bym.
the module massigns a fragment to the vp vpif vp2dom m otherwise vpis not related to m. a module can assign a vp only once but multiple modules can assign the same vp.
for a fragment f2f we define the helper function vp f returning the vp vpassociated with f possible as of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
injection .
similarly let m f be the helper function returning the module massigning ftovp f .
both helper functions return?if there is no module massigning ftovp i.e.
before a developer explicitly chooses mfor assigning ftovp .
example for the fragment f1in our running example berkeley db m f1 yields the feature module base and vp f1 the vp vp1 cf.
fig.
3f and fig.
.
all vps vberkeley fvp0 vp1 vp12gare associated with fragments via modules for instance base fvp07!f0 vp17!f1 vp47!f4 g. in fact the feature module base assigns fragments to the vps in its domain dom base fvp0 vp1 vp4 vp5 vp8 vp11g.
another example is the feature module statistics fvp37!f3 vp47!
f4 gwith the domain dom statistics fvp3 vp4 vp7 g. note that dom base dom statistics fvp4gand thus base andstatistics share vp4 cf.
fig.
3f and fig.
.
variational ast.
ast nodes are made variable by annotating them with fragments from f. let ast fn1 n2 gbe a set of ast nodes.
a variational ast vast f ast is an injective non surjective function assigning ast nodes to fragments from f. the image vast f of a variational ast vast is the set of ast nodes annotated with fragments.
an ast node nis annotated if n2vast f .
the domain dom vast is the set of fragments f i.e.
the ast nodes assigned to fragments by vast .
due to injection fragments are unique to ast nodes.
every fragment annotates exactly one node but not every node must be annotated.
the helper function fn n either returns the fragment annotating the node n2ast or?
if the node is not annotated i.e.
n 2vast f .
example fig.4shows an excerpt of the mappings in our running example .
for instance vast fberkeley ffeatureblock returntype nonoptionalalternative ...g fn returntype f4 m fn returntype base and vp fn returntype vp4.
b. editing operations to manipulate the ast corevar provides three basic variabilityrelated editing operations which can be refined by its tailoring extensions e.g.
javavar assign variability assign wrapper variability assign alternative all available via a menu in the program cf.
fig.
3c or triggered automatically by an editing gesture e.g.
typing ifdef or elif .
assign variability operation.
the operation marks an ast node as variable such as class databaseimpl assigned to f0 .
an algorithm creates a new vp vpi2vand fragment fi2f and annotates the selected ast node njwith the fragment such that vast fi nj.
then the developer selects the desired feature module mkassigning fitovpi.
assign wrapper variability operation.
the operation marks only a wrapping node as variable not its body the wrappee .
the idea is to annotate the wrapping node such that its wrappee vfastvp1vp4...f1f4.1f4.2returntypefeatureblocknonoptionalalternative......basebasestatisticsvastclasscreator figure .
annotating ast nodes as variableis not removed during variant derivation explained shortly .
assigning variability to a wrapping node corresponds to the assign variability operation.
the only difference is that an additional annotation called wrapper is added to the target node which refers to the wrappee cf.
fig.
3f vp10 .
assign alternative operation.
the operation marks an ast node naas alternative to another ast node no.
let nobe variational with fn no ?
and let its fragment fo fn no be assigned to the vp vpo vp fo with vp fo ?.
if the alternative node nais variational with fn na ?
then an algorithm changes the alternative node s feature module m fn na such that it assigns the fragment fn na tovpo which is then associated with foandfn na .
if the node nais not variational an algorithm creates a fragment fainf assigns it to vpo according to the developer s module selection and annotates nawith the fragment such that vast fa na.
fig.
gives an example.
the fragments fn returntype f4 1and fn nonoptionalalternative f4 2are both assigned to vp4 by their respective feature modules.
notice that noandnaare typically but not necessarily siblings in the ast e.g.
statements alternative to each other .
in fact some non optional ast nodes cannot have siblings e.g.
exactly one return type is required in a method declaration according to java s syntax .
for such non optional nodes corevar provides the concept nonoptionalalternative whose instances are used by the assign alternative operation to annotate no while holding an alternative node na.
for example the return type of the method preload is annotated by a nonoptionalalternative holding an alternative return type cf.
f4 2in fig.
3f .
non optional language concepts are declared in corevar tailorings explained shortly in sec.
iv d .
c. variant derivation the derivation of variants is a two step process.
first we calculate the set of fragments contained in the variant by composing feature modules.
second we remove any variability by iterating over all fragments in the tree to either remove the fragment to remove the annotated node or to restructure the tree for wrapper and non optional alternative nodes .
composition.
composing modules results in a transient variant set fvariant containing all fragments of a variant.
sda provides three operations to compose modules addition subtraction and overriding which we adopt in peopl as follows.
let fmand fnbe the set of fragments associated with a module mandn respectively.
the addition of two modules m nfails if mandncontain conflicting fragments dom m dom n .
in fig.
fragments f4 1and f4 2are conflicting as both assign fragments to the vp vp4.
without conflicting fragments addition results in a greater set of fragments fm n ffm fngand therefore a larger module serving as input for further operations.
note that the fragments of the larger module reflect a preliminary or the final variant set fvariant .
the subtraction ofm nis the set fm n ffjf2fm vp f 2dom n g. in other words we remove the fragments of mthat share a vp with fragments ofn so subtraction removes fragments from the variant set.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i example configurations for berkeley db f ig.
no module configuration variant s fragment set fvariant valid base f0 f1 f4 f5 f8 f11x base memory budget f0 f1 f2 f4 f5 f6 f8 f11x base statisticsf0 f1 f3 f5 f7 f8 f9 f10 f11 f127 base statisticsf0 f1 f3 f5 f7 f8 f9 f10 f11 f127 base statistics f0 f1 f3 f4 f5 f7 x statistics base f0 f1 f3 f4 f5 f7 x overriding is simply a combination of addition and subtraction m n d fm n m to enable replacement.
example table ishows different compositions for our running example .
for instance configuration adding base andmemory budget results in a valid set of fragments.
in contrast configuration adding base andstatistics is erroneous as fragments f4 1andf4 2fill the same vp vp4.
to resolve conflicting fragments we use subtraction and overriding.
for instance configuration removes f4 .
the resulting fragment set is valid but the ast invalid both return types pruned which is detected during derivation.
typechecking module composition is part of our future work.
using overriding developers decide between conflicting fragments.
for instance configuration denotes that all fragments of base replace those conflicting with statistics .
note that ordering matters for overriding since configuration includes the fragments of statistics instead.
moreover notice that a feature selection can be realized by overriding modules according to their declaration order.
for instance configuration reflects a selection of base andstatistics based on the ordering defined in fig.
3b i.e.
base has lowest priority .
remove variability.
next we remove any variability from our ast such that vast f .
fig.
5shows our algorithm which takes the variational ast vast and the variant s fragment set fvariant as input.
we iterate over all fragments in the variational ast line .
if the fragment is in fvariant we simply delete the fragment to remove variability line .
otherwise if the node has a wrapper annotation we move the wrappee s children up in the tree as siblings of the wrapper line and remove the wrapper line .
if the node is non optional i.e.
hasnonoptionalalternatives we pop the first alternative and get the node it holds line such as the alternative return type preloadstats in fig.
3f.
since a node may have multiple non optional alternatives we must add all of func removevariability func vast set fragment fvariant for each f dom vast if f fvariant f.delete delete only the fragment else if haswrapperannotation vast f handling the wrapper for each n getwrappee vast f .children vast f .add prev sibling n moving the content up else if hasnonoptionalalternatives vast f node a popfirstalternative vast f .getthenodeihold a.addall getnonoptionalalternatives vast f vast f .replace with a replace the node return vast f .delete delete the node and its fragment figure .
algorithm to remove variability from the ast can assign variability declarations for javasimple inclusion for concepts statement parameterdeclaration ...parameterized inclusion for node sourcenode boolean return sourcenode.parent.isinstanceof basemethoddeclaration sourcenode.hasrole basemethoddeclaration throwsitem ...simple exclusion for concepts placeholdermember ... all rules from can assign variability default true non optional node concepts type expression...can assign alternative declarations for java123456789figure .
annotatable nodes declaration for java them to the popped alternative line .
then we can safely replace the non optional node in the tree with it line .
if the node neither has a wrapper annotation nor is a non optional alternative we remove the node line .
d. target language specific tailoring peopl requires tailoring corevar to a specific target language.
we now explain the tailoring in general and illustrate it with our examples from tailoring to java.
annotatable nodes declaration.
without restriction the editing operations of corevar allow annotating any ast node also non optional ones with fragments which may lead to syntactically incorrect variants.
to declare annotatable nodes and restrict editing operations to a meaningful level we provide can assign variability andcan assign alternative declarations.
fig.6shows an example for java.
can assign variability declarations are either simple orparameterized inclusions orexclusions of concept instances and their subconcept instances due to concept inheritance .
for example fragments can annotate statement concept instances line and thus all statement subconcept instances e.g.
ifstatement instances .
moreover we declare that throwsitems of method declarations can be annotated lines .
the can assignalternative declaration allows adopting the rules declared in can assign variability line add new rules and declare non optional nodes.
for instance javavar allows annotating the language concept instances of type andexpression with nonoptionalalternative instances cf.
fig.
line and the nonoptionalalternative in fig.
3f .
due to concept inheritance not many declarations are needed for java.
the can assign variability declaration has nine simple and eight parameterized inclusions as well as one simple and three parameterized exclusions.
the can assign alternative declaration adopts these rules plus two non optional node inclusions one parameterized inclusion and four exclusions.
wrapper declaration.
which nodes in the ast can have a wrapper annotation where the wrapping node is variable but not its subtree wrapper body is target language dependent.
a wrapper declaration specifies the wrapper s language concept and the corresponding wrappee child node .
fig.
7shows the four wrapper declarations for java.
for instance a trystatement can be replaced by its body.
wrappers that can be partially annotated in javainstance of abstractloopstatement replaced by its body instance of ifstatement replaced by its truebody instance of sychronizedstatement replaced by its block instance of trystatement replaced by its body ... figure .
wrapper declaration for java authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
further declarations.
javavar also declares variabilityspecific type system and data flow rules cf.
.
moreover it extends the java language with a convenience concept that eases handling variability.
our featureblock concept groups statements belonging to the same feature module cf.
fig.
3f .
in fact we enforce that any statement except partially annotated wrappers are contained by at least one featureblock e.g.
f1 in fig.
3f .
otherwise all individual statements would need to be annotated as they are siblings in the ast .
in the projections the block s statement list is just rendered without showing curly braces cf.
statement level vertical bars in fig.
3c .
a featureblock also extends its enclosing statement list s scope to make the featureblock s statements visible to its siblings.
during variant derivation if the featureblock s module is in the variant it is replaced by its statements otherwise removed.
v. pe opl sexternal representations we use mps projection facilities to realize peopl s external representations.
each language concept requires a projectional editor defining the rules for rendering concepts into concrete syntax.
for instance a blockstatement editor renders its statementlist and surrounds it with curly braces.
editors can accommodate so called editor hints defining in which context the rendering rules are to be applied.
a language concept can have different editors through different hints.
in peopl the variability related language concept is the fragment.
for each of its external representations we implement a projectional editor that is oblivious to the target language e.g.
java .
next we explain how we realize our projectional editors.
rendering annotations.
for most target languages projecting textual and visual annotations is easy.
fig.
8shows a visual annotative editor for our main concept fragment.
such editor definitions consist of so called cells .
the cell embeds the editor of the node annotated with the fragment lines and .
a fragment can be rendered in three ways.
first fragments constituting disciplined annotations are rendered with a vertical bar line where verticalbar and module refer to editor components editors reusable among different editors.
second undisciplined annotations within a line of code are underlined with a horizontal bar lines .
third annotations requiring a more specific syntax e.g.
partially annotated wrappers whose body is not annotated are propagated to the customized target node s editor line which targets a target language specific concept e.g.
java s trystatement that recognizes a fragment and provides respective partial coloring.
finally the textual annotative editor looks similar and just adds keywords such as ifdef.
rendering variants.
projecting variants is simple the editor for fragments checks whether the fragment is in the variant s fragment set.
if so the annotated node is rendered otherwise else if iscomplex if isdisciplined verticalbar module else if iswithinline module horizontalbar visualannotative editor for concept fragment figure .
simplified visual annotative projectional editor for fragmentshidden for wrappers the wrappee is shown .
to provide a variant specific file explorer we simply check for each root node e.g.
class or interface if it is in the current variant.
rendering feature modules.
modular projections show the code of a feature module in isolation .
in contrast to projecting annotations and variants projecting modules is currently language dependent since the editor rendering fragments cannot simply hide annotated nodes that is we need to show refined structural elements as well cf.
sec.
ii .
luckily it is still feasible to project java code as feature modules.
we only need three simple fragment aware editors defining how to render the java language concepts classifiermember e.g.
method declarations ivisible e.g.
public orprivate andstatementlist e.g.
a method declaration s or a block statement s body in the presence of variability.
in other words we override these editors from java with editors that can handle the variability induced by a fragment.
we realize these three editors as follows.
first a fragment aware classifiermember editor renders a classifier member conditionally if the member or one of its descendants is annotated with a fragment of the module.
for instance the class preloadprocessor a member ofdatabaseimpl is shown in the modular editor of memory budget since a descendant featureblock is annotated with fragment f2ofmemory budget fig.
3d line .
second to understand whether classes and members are introductions or refinements we render the keywords defines andrefines into the concrete syntax by overriding the ivisible language concept editor originally rendering only the member s visibility e.g.
public and private keywords .
for instance memory budget only refines the class databaseimpl i.e.
in fig.
3f f0is associated with base and thus the refines keyword is shown fig.
3d line .
third we override the editor of the concept statementlist .
it filters out featureblock nodes whose fragment does not belong to the current feature module e.g.
the featureblock in line in fig.
3c is not shown below line in fig.
3d .
in case of wrappers not belonging to the module the wrappee s statement list is the next level to investigate for featureblocks and wrappers.
note that the original keyword is a projection of the base code s featureblock fig.
3d line and fig.
3f f1 .
so it is not a real method call as in classical modular approaches and currently restricted to the statement level which however sufficed in practice.
to support the original keyword on the expression level i.e.
as a real method call we could implement further but likely more complex on the fly tree transformations and rendering rules.
finally note that to provide a module specific file explorer we simply check for each file whether it is introduced or refined by the selected module e.g.
a memory budget file explorer would show the databaseimpl file cf.
fig.
3d .
combining renderings.
blended projections simply reuse editor components defined by the projections involved.
for instance to blend annotations into feature modules elements of the annotative and modular fragment editor as well as horizontal and vertical bars are reused.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii java based product lines adopted in peopl size complexity scalability latency spl loc cla met f fm vp tgv tcv tcf source tool description jest 19k 2535ms 9ms 1ms from scratch java elasticsearch client berkeley db 70k 5153ms 45ms 1ms cide embedded database gpl 1k 248ms 2ms 1ms cide graph product line java chat 6k 260ms 1ms 1ms cide chat client lampiro 45k 4234ms 7ms 1ms cide instant messaging client prop4j 2k 249ms 1ms 1ms featurehouse propositional formula libary vistex 2k 287ms 1ms 1ms featurehouse graph visualization and text editor ste 1k 259ms 1ms 1ms deltaj simple text editor loc lines of code source jcla classesjmet method declarations jf featuresjfm feature modules jvp variation points tgv time to generate a variant jtcv time to compose a variant jtcf time to compose a file variant vi.
e valuation we now evaluate peopl with three objectives.
a. objectives and subjects objectives.
o1.
analyze expressiveness we show that peopl can realize spls by writing them from scratch or migrating from common annotative or modular variability representations.
o2.
analyze scalability we investigate latencies for creating file variant projections and for deriving full variants together with qualitatively assessing the editing efficiency.
o3.
assess the benefit of multiple projections we study this benefit by analyzing the overhead of a pure modular approach by approximating the boilerplate code it would require to write.
subjects.
table iishows our spls.
we migrate seven spls used in previous research and implement one jest from scratch.
all cover different domains and scales.
most migrations are cide projects for two reasons.
first it is easy to migrate annotative spls to peopl.
we import the codebase and manually re implement annotations.
second we aim at using annotative spls to evaluate the potential overhead in a pure modular approach.
we also migrate three projects from deltaj and featurehouse which use modular representations.
we import each module as a java package into peopl and use our modular projection for migrating the code.
the adoption effort for all subjects is moderate.
creating the subjects takes seven days for berkeley db three days for jest and just a few hours each for the others including comprehending the spls .
b. expressiveness o1 although time consuming and error prone and an analytical approach could have sufficed to evaluate expressiveness the manual adoption helps us understanding the usability of our projections.
no subject requires specific workarounds.
we conclude that peopl s expressiveness suffices to handle those annotative and modular spls.
to reduce adoption effort we plan to write custom importers.
c. scalability latencies o2 metrics.
we use the following three metrics all in milliseconds to evaluate scalability.
tcf time to compose file is the time to compose the variant s set of fragments of a single file.
tcv time to compose variant is the time to compose thevariant set of all files i.e.
the complete fragment set .
tgv time to generate variant includes tcf plus the time to write all java classes of the variant to disk.
we use tgv to compare peopl to composition times of other spl tools.
methodology.
tcv measures the editing latencies of variant projections since we compose a full product to update the variant editor and explorer i.e.
the tree view on a product s files .
peopl caches the current variant s fragment set until variability related operations e.g.
adding a fragment invalidate the cache.
so we turn off caching to avoid confounding.
to measure tcv we compose all feature modules included in the current configuration.
tcv is most important as it excludes the confounding model to text transformation introduced with tgv .
we compare tcv totcf to determine whether the reduced set of fragments of tcf improves composition performance and yields a better efficiency.
a drawback of tcf may be that we need to populate all module fragment relationships of a file before the composition since the reduced set is not persisted.
we conduct all measurements on a standard imac 1ghz intel i5 16gb radeon hd 6970m os x .
.
mps .
.
java .
with randomly generated distinct variants.
we then compare the composed variant set to all variant sets previously generated.
if sets are equal we skip the current set otherwise save it for future comparison.
results.
table iishows all results and fig.
9the distribution of tcv values for berkeley db for the others the values are too low to be meaningful .
generating and writing berkeley db variants to disk is below .
sec.
on average tgv .
using equivalent product configurations we compose and write the same berkeley db variant to disk using peopl around sec.
featurehouse around sec.
and cide around sec.
.
composing a full variant is below ms on average tcv and just a single document below 1ms tcf .
in summary the peopl prototype scales well to spls of berkeley db size.
latencies to compose the fragments for a variant projection are efficient according to the tcf andtcv measures.
peopl does not introduce any significant overhead.
100berkeley db latency in ms figure .
calculation times for a full variant tcv authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii methods requiring boilerplates in pure modular approaches berkeley db lampiro gpl java chat fm met boil met boil met boil met boil fm feature modules involved in method body jmet method declarations boil method declarations that would require boilerplate code d. overhead of pure modular representations o3 metrics.
the basic idea of o3 is that a developer uses feature modules for their advantages.
yet classical modular approaches require boilerplate code for fine grained feature artifacts such as hook methods.
we aim to show the need for annotations providing indirect evidence that peopl which allows blending annotations into modules and switching to annotations on demand is useful.
to approximate the potential interest of these two peopl facilities we measure the number of methods that would require boilerplate code in a pure modular projection in correlation to the involved modules.
this shows whether variability in a method s body introduced by different modules impacts the number of boilerplates.
methodology.
to determine the required boilerplates of a method we search for variability in the middle of a method and fine grained variability e.g.
annotated method call parameters .
the method requires boilerplates if such variability is found.
notice that we allow variational method parameters and returntypes in our modular projection.
thus we do not mark such methods as demanding boilerplates although they would require boilerplates in some classical modular approaches .
results.
it is not surprising that all methods adopted from the modular featurehouse and deltaj examples do not require additional boilerplates in a pure modular projection.
thus we concentrate on the cide examples.
with total numbers of berkeley db lampiro gpl and javachat all tested annotative spls contain a relatively small number of methods requiring boilerplates.
however as soon as investigating variability in the method s body the need for blended projections and fluent movement between projections becomes obvious.
table iiishows our boilerplate test results.
the majority of methods not requiring boilerplates in pure modular approaches are simple introductions i.e.
only one feature module is involved .
the picture changes as soon as a method gets refined i.e.
at least two feature modules are involved .
especially the berkeley db methods require a large number of boilerplates.
e. threats to validity internal validity.
to mitigate the threat that our spls are incorrectly implemented we cross checked their implementations and carefully specified and reviewed our generation rules.
moreover in the final java code generation mps would have detected invalid asts.
furthermore peopl relies heavilyon cross tree