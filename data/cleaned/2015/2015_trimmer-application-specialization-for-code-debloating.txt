trimmer application specialization for code debloating hashimsharif departmentofcomputerscience universityofillinoisaturbana champaign urbana usa hsharif3 illinois.edumuhammadabubakar departmentofcomputerscience lahoreuniversityofmanagementsciences lahore pakistan bakar95 gmail.com ashishgehani computersciencelaboratory sriinternational menlopark usa ashish.gehani sri.comfareedzaffar departmentofcomputerscience lahoreuniversityofmanagementsciences lahore pakistan fareed.zaffar lums.edu.pk abstract with the proliferation of new hardware architectures and everevolvinguserrequirements thesoftwarestackisbecomingincreasinglybloated.inpractice onlyalimitedsubsetofthesupported functionalityisutilizedinaparticularusagecontext therebypresentinganopportunitytoeliminateunusedfeatures.inthepast programspecializationhasbeenproposedasamechanismforenablingautomaticsoftwaredebloating.inthiswork weshowhow existing program specialization techniques lack the analyses requiredforprovidingcodesimplificationforreal worldprograms.
wepresentanapproachthatusesstrongeranalysistechniquesto take advantage of constant configuration data thereby enabling moreeffectivedebloating.wedevelopedtrimmer anapplication specializationtoolthatleveragesuser providedconfigurationdata to specialize an application to its deployment context.
the specializationprocessattemptstoeliminatetheapplicationfunctionality that is unused in the user defined context.
our evaluation demonstrates trimmer can effectively reduce code bloat.
for applicationsspanningvariousdomains weobserveameanbinary sizereductionof21 andamaximumreductionof75 .wealso showspecializationreducesthesurfaceforcode reuseattacksby reducingthenumberofexploitablegadgets.fortheevaluatedprograms weobservea20 meanreductioninthetotalgadgetcount andamaximumreductionof87 .
ccs concepts software and its engineering compilers keywords staticanalysis codedebloating programspecialization llvm permissiontomakedigitalorhardcopiesofallorpartofthisworkforpersonalor classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrightsforcomponentsofthisworkownedbyothersthanacm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.requestpermissionsfrompermissions acm.org.
ase september montpellier france 2018associationforcomputingmachinery.
acmisbn978 ... .
reference format hashimsharif muhammadabubakar ashishgehani andfareedzaffar.
.trimmer applicationspecializationforcodedebloating.in proceedings of the 33rd acm ieee international conference on automated softwareengineering ase september3 montpellier france.
acm newyork ny usa 11pages.
introduction ashardwarearchitecturesanduserrequirementscontinuetoevolve softwareplatformsandapplicationsarebecomingincreasinglycomplex .
with such software growth it is not surprising to see applicationsbecomingsubjecttofeaturecreep.asavariantofthe rule it has been argued that of the users only utilize of the functionality with each user requiring a distinct set offeatures .withmostusersdemandingonlyasubsetofthe completefunctionality featureextensionsoftencomeatthecostofsoftwarebloat.suchcodebloatmaynegativelyimpactperformance whilealsopotentiallybroadeningtheattacksurfaceoftheapplication .moreover softwarebloatisafirst classconcern inembeddedsystemshostedonresource constraineddeviceswith limitedmemoryandsecondarystoragecapabilities .
protocolstacksforembeddedsystemsoftenneedtobehighly customizedinviewoftheirtargetapplications.thisrequiresdevelopers to manually identify and eliminate unused code from thestack .suchmanualstrippingofunnecessaryfeaturescan beatime consuminganderror proneprocess.alternatively programspecializationtechniqueshavebeenacknowledgedasauseful mechanismforautomaticcustomizationofsoftware .
conceptually aspecializertakesatargetapplicationandaspecializationcontextasinput andproducesaversionoftheapplicationspecializedfortheprovidedcontext.thespecializationcontext iscomposedofknowndatavaluesandconfigurationparameters available at compile time.
prior work has leveraged partial evaluation as a technique for program specialization .
partial evaluationisanoptimizationtechniquethatprecomputesprogram expressionsintermsoftheknownstaticinput therebygenerating aspecializedbinary .
inthiswork weshowhowexistingpartialevaluationmechanismsareinsufficientforprovidingusefulprogramspecialization forreal worldprograms.specifically thecurrentapproachesfor automatedspecializationarenotequippedwiththeanalysesthat catertothediverseprogrammingpatternsemployedforreading authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france hashim sharif muhammad abubakar ashish gehani and fareed zaffar and parsing user configuration.
moreover the absence of propagating configuration invariants coupled with the conservative natureofexistingoptimizationsinproductioncompilers limits opportunitiesforconstantfoldinganddeadcodeelimination.
accordingly wehavedevelopedtrimmer atoolthatenables configuration basedsoftwareslimming.trimmerspecializesatar getprogramwithrespecttoauser definedconfiguration.theprovidedconfigurationspecifiestheusagecontextoftheapplicationin thedeploymentofinterest andisleveragedtopruneunusedfunctionalityfromtheapplication.ourtoolusesstrongertechniquestoincorporateconfigurationinformation andincludescompiler transformationstailoredtotakeadvantageoftheknownprogram constants therebyenablingeffectivedebloating.insteadofrelying onheroiccompileranalysis wedevelopthenecessarytransforms that enable effective propagation of configuration invariants.
in particular webuildaninterproceduralconstantpropagationtransformationthatismoreprecise andhencefacilitatesthepruningof programpathsthatareunreachableinthecontextoftheuserconfiguration.theunreachablepathsareprunedasaresultofstatically evaluatingbranchconditionsbyleveragingtheprovablyconstant data.moreover thispotentiallyallowsforpruningfunctionsthat areinvokedwithintheeliminatedprogrampath.
additionally we show existing transformations such as loop unrollingcanbeappliedmoreusefullyinlightoftheknownstatic input.ourexperimentsshow byapplyingtheseadditionaltransforms weachievemorepreciseconstantpropagation asaresult enablingaggressiveeliminationofunusedprogramcode.thecom pilertransformsincludedinthetoolaredevelopedusingthellvm compilerframework .
ourspecificcontributionscanbesummarizedasfollows wedevelopaninterproceduralconstantpropagationtransformationthatpropagatesthestaticprogramconfigurationmore precisely andhencefacilitatesthepruningofunreachablecode paths.
wedevelopaloopunrollingtransformationtomoreaggressively unrollloops.inparticular weleveragetheimprovedconstant foldingcapabilitiestobetterguidethecostmodelsthatdrivetheloopunrollingtransform.forthemajorityofprograms fullloop unrollingforcertainloops particularlyinputparsingloops isa prerequisiteforanyusefulconstantpropagation.
wepresenttheresultsofanevaluationofourtool.ourexperimentsdemonstrate reducedcodesize forasetof13commonlyusedlinuxapplications weobserveageometricmeanbinarysizereductionof .
andamaximumreductionof75.
.reduced attack surface code reuse attacks use instruction sequences calledgadgets fromexecutablecodesectionsasthe attackpayload.weshowspecializationintroducessoftwarediversity and reduces the number of exploitable gadgets.
in our evaluation we observe specialization reduces the gadgets by .
onaverage .moreover forallourbenchmarks applying specializationeliminatesallsurvivinggadgets atknownbyte locations .
motivation wediscussourmotivationsforapplicationspecialization.
eliminating auxiliary program features priorstudieshave shownasignificantfractionofprogramfeaturesarerarelyused .
we view this as an opportunity to eliminate the less commonly usedfeaturesbyspecializingapplicationstotheircorefunctionality.
inourexperiments weaimtoselectconfigurationsthatrepresent thecorefunctionalityofthetargetapplicationswhileleavingout theauxiliaryfeatures.
reduced attack surface modern operating systems protect againstcodeinjectionattacksbypreventingpagesfrombeingsimultaneously executable and writable .
code reuse attacks circumventtheserestrictionsbyusinginstructionsequencesintheexecutablesectionsastheattackpayloaditself .thesecode snippets calledgadgets endinareturnorjumpinstruction thus allowinganattackertochaintheexecutionofmultiplegadgets .
asspecializationeliminatesunusedprogramfeatures itreducesthe attacksurfaceoftheprogrambyreducinggadgets.inourresults weshowareductioninbinarysizecorrespondinglyreducestheset ofprogramgadgetsanattackercanexploit.toconductacodereuse attack anattackermusthaveknowledgeofthegadgetlocations intheexecutable .weshowspecializationintroducessoftware diversity makingitharderforattackerstogaininsightsaboutthe gadgetlocationsinthetargetbinary.
trimmer in this section we describe the workflow for our configuration based debloating tool trimmer.
for our implementation we se lected the llvm framework since it provides frontends for popularprogramminglanguagesincludingc c andsupports awealthofcompileranalysesandoptimizationpassesthatmake it suitable for developing new compiler transforms.
trimmer isintendedtobeusedwithsoftwarethatiscompiledtollvmbitcode modules bitstream container format for encoding llvm intermediaterepresentation ir .figure 1showstheworkflowfor theproposedsystem.
the input to the tool is a manifest file that includes the userdefinedstaticconfiguration andthepathtoawhole programllvm bitcodefile.theuser definedstaticconfigurationcharacterizesthe usagecontextoftheapplicationforagivendeployment.trimmer specializesthetargetapplicationmoduleswithrespecttothisusage context.thewhole programbitcodefileconsistsofapplicationcode thatiscompiledandlinkedintoasinglellvmmodule.
trimmeriscomposedofthreemajorcompilertransformsnamely inputspecialization loopunrolling andconstantpropagation.the firstphaseofthetoolworkflowincludesinputspecialization.in put specialization propagates the static configuration data into theprogramviatheprogramentrypoint.this inturn facilitates simplifying program expressions dependent on these configura tionconstants.inputspecializationisdescribedinmoredetailin section3.
.nextinthepipelineisaloopunrollingpassthataggressively unrollsloops toaidlater optimizationpasses.
we observe thatimprovedloopunrollingisnecessarytofacilitateeffectiveinterproceduralconstantpropagation.thetransformisdiscussedin section3.
.
oncetheconfigurationparametersareincorporatedasprogram invariants they can be aggressively propagated throughout the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
trimmer application specialization for code debloating ase september montpellier france figure overview of the tool workflow.
inputs to the tool include a a whole program llvm bitcode file and b a manifest file.
the userdefined configuration specified in the manifest is leveraged to generate a specialized binary.
program.productioncompilerssuchasllvmprovideoptimization passes for constant propagation that enable this goal.
however as llvm optimizations tend to be conservative for purposes of correctnessandefficiency thisleadstomissedopportunities foroptimizingthecodemoreaggressivelyinlightofthestatically knownvalues.accordingly wedevelopamoresophisticatedinterproceduralconstantpropagationtransformthatbetterpropagates the static configuration data throughout the program callgraph therebyenablingcodesimplification.theimplementationoftheconstantpropagationoptimizationisdescribedinmoredetailin section3.
.asconfigurationdataisincorporatedandpropagated existingcompileroptimizationscanbeinvokedlaterinthepipeline tofurtherattemptcodesimplification.finally thelinkertakesas inputthespecializedbitcodeandthelinkerflags alsoreadfrom themanifestfile andgeneratesaspecializedbinaryexecutable.
.
input specialization applicationsparseuser providedconfigurationinavarietyofdifferentways.commonly configurationissuppliedasprogramargumentsandconfigurationfiles.whileourtoolincludestransformationsforincorporatingcommand linearguments supporting file basedconfigurationisnotwithinthescopeofthecurrentwork.
inpractice weobserveamajorityofapplicationsincludeawealth ofconfigurablecommand lineflagsthatcanbeexploitedforspecialization.
wedescribeourinputspecializationtransformthatleverages partialevaluationconcepts .thegoalofthistransformis toincorporateuser definedconstantinputsdirectlyintotheprogram therefore specializing the application for a specific usage context.laterpassessuchasloopunrollingandconstantpropaga tioncanleveragetheseconstantstosimplifyprogramexpressions consequently facilitating code debloating.
specifically the trans form specializes the program entry point for the user provided inputarguments.thesestaticprogramargumentsareprovidedas partofthemanifestfilethatisinputtothespecializer.
algorithm 1shows the algorithm for the input specialization transform.thepassbeginsbyreadingtheinputargumentsfrom the manifest file.
then for each constant argument specified inthemanifest alloriginalusesoftheargumentaresubstitutedbythe known constant value.
if a target argument is explicitly an notated as dynamic input as part of the manifest the original usesremainunsubstituted.thisisparticularlyuseful asitallows userstospecializeprogramsonapartially specifiedsetofconstant arguments.
asapracticalexampleofinputspecialization consideranetwork monitoringtoolthattakesasinputaparticularnetworkinterface.algorithm algorithmforinputspecialization 2function inputspecialization manifestfile programentry 3inputargs readargs manifestfile 4programargs getprogramargs programentry 5argindex 6foreachargvalue in inputargs do ifargvalue is constant then replacearguses argvalue programargs end argindex argindex 11end whiletheapplicationmaysupportmultiplenetworkinterfaces a usage scenario may only require monitoring a specific interface e.g.
ethernet .specializingtheapplicationforaparticularinterface allowsforpruningunusedfunctionality thusreducingcodesize.
.
loop unrolling in this section we introduce our loop unrolling transformation.
inthecontextofprogramspecialization weobservethatloopunrollingisanecessaryoptimization.unrollingisparticularlyimportantforinputparsingloopsthatextracttheuser providedconfigurationandstorethesevaluesasprogramvariables.sinceunrolling facilitatesthefoldingofprogramexpressionsinsidetheloopbody itsupportsconstantpropagationofthestaticconfiguration.
whilellvmincludesaloopunrollingpassintheoptimizations suite it is not entirely suited for our use case.
since the llvm unrollingpassisdrivenbyconservativeheuristicstoestimatethe profitabilityoftheloopunroll itveryoftenmissesopportunitiesfor simplifyingexpressionsintheloopbody.accordingly wedevelop aloopunrollingtransformthatleveragesourimprovedconstant foldingtransformtomorepreciselydeterminetheprofitabilityof unrolling a target loop.
specifically the transform aggressively unrollsloopsandthereafterappliesacostmodelontheunrolled loop.inthecontextofaspecificloop thecostmodeldeterminesthe usefulnessofthetransformbyidentifyingloop basedoperations that are simplified folded as a result of the unrolling.
since the transformreliesonconstantfoldingtodrivethecostmodel ourtoolbundlestheloopunrollingtransformandtheconstantpropagation transformasoneunifiedcompilerpass.constantpropagationis describedindetailinsection .
.
algorithm 2illustratesthealgorithmfortheunrollingtransformation.the trytounrollloop procedureattemptstofullyunroll theprovidedtargetloop.first thecallto getlooptripcount extracts the trip count for the loop.
if the loop trip count can be staticallydeterminedasaconstantvalue theloopisfullyunrolled.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france hashim sharif muhammad abubakar ashish gehani and fareed zaffar algorithm algorithmforloopunrolling 2function trytounrollloop loop 3tripcount getlooptripcount loop 4ifisconstant tripcount then unrolledloop unrollloop loop tripcount runconstprop unrolledloop unrollcost evaluatecost unrolledloop ifunrollcost costthreshold then rerollloop unrolledloop tripcount end 11end 12ifnot isconstant tripcount then peeledloop peelloop loop peelcount runconstprop peeledloop ifisfullyunrolled peeledloop then unrollcost evaluatecost peeledloop ifunrollcost costthreshold then rerollloop peeledloop tripcount end else rerollloop peeledloop tripcount end 23else 24end figure2a theexampleparsingroutineextractsthecommand line options in a loop.
voidparse input int argc char argv structconfig config while intc getopt argc argv quotedblvarpd quotedblvar !
switch c case quotesinglevarp quotesinglevar config enable plugins false break case quotesinglevard quotesinglevar config enable debug false break oncetheloopbodyisfullyunrolled itallowsforpreciselydeterminingtheusefulnessoftheunroll.afterunrolling the runconstprop procedurerunsaconstantpropagationpassontheunrolledloop.
thepurposeofinvokingtheconstantpropagationpassistofacilitatesimplificationoftheunrolledloopexpressions.subsequently evaluatecost leveragesacostmodeltocomputethecostassociatedwithunrollingthetargetloop.sinceunrollingcertainloops canpotentiallyincreasecodesize itisnecessarytoevaluatethe benefitofunrollingandskipunrollingifitdoesnotassistconstant foldingofloop orientedexpressions.
evaluatecost determinesthe fractionofinstructionssimplifiedasaresultofapplyingconstant propagationontheunrolledloopandaccordinglycomputesacost value.ifnoorfewinstructionsaresimplified folded thecostmodel returns a high cost value.
if the cost model returns a high costassociatedwiththeunroll theunrolledloopisrerolledtoregeneratetheoriginalloop.ifthelooptripcountisnon constant the peelloop procedureisinvokedtopeelthefirstfewiterationsofthe loop.subsequently runconstprop invokesconstantpropagation topromoteconstantfoldingofexpressionsinthepeelediterations.
applyingconstantpropagationonthepeeledloopiterationspotentiallyallowsforstaticallyevaluatingtheloopexitconditions therebyassistingafullunroll.iftheloopisnotfullyunrolled it cannotpromotefurtherconstantpropagation andhence theloop isrerolled.figure 2b the parsing loop is fully unrolled.
voidparse input int argc char argv structconfig config intoption quotesinglevarp quotesinglevar getopt replaced switch option case quotesinglevarp quotesinglevar config enable plugins false break case quotesinglevard quotesinglevar config enable debug false break option quotesinglevard quotesinglevar getopt replaced switch option case quotesinglevarp quotesinglevar config enable plugins false break case quotesinglevard quotesinglevar config enable debug false break figure2c theunrolled getoptcallsarefoldedtocorrespondingconstant values.
voidparse input int argc char argv structconfig config config enable plugins false config enable debug false figure2ashowsaninputparsingroutinethatreadstheinput arguments in a getoptloop and sets the program configuration variablesaccordingly.forpurposesofillustration weassumethat thestaticprograminputincludestwocommand lineflags pandd.
sincetheloopexitswhenthe getoptcallindicatesnomoreoptions arepresent thetripcountfortheargumentprocessingloopisnota compile timeconstant.accordingly theunrollingtransformpeels thefirstfewiterationsoftheloop anticipatingthatthesubsequent constantfoldingtransformcanallowforstaticallyevaluatingthe loopexitcondition therebyeffectivelyfullyunrollingthetarget loop.
the transformed program in figure 2bshows the loop is fullyunrolledparticularlybecausetheresultofthe getoptcallis staticallyevaluatedintermsofthestaticprogramarguments.as getoptandgetopt long areverycommonlyusedinparsingcode wehaveincludedacustomtransformtospecializethesecallsin termsofconstantarguments.asthe getoptcallsareevaluated the configurationsettingscanbecorrespondinglyresolvedtoconstant values.figure 2cdemonstratestheconfigurationsettingsarecorrespondinglyresolvedtoconstantvalues.theexampledemonstrates howfullyunrollingtheinputparsingloopfacilitatestheconstant foldingofexpressionsintheloopbody.
.
constant propagation the goal of our tool is to effectively debloat unused application functionalitywithrespecttoagivenuser definedusagecontext.inordertoenablethis theuser providedconstantconfiguration valuesmustbeaggressivelypropagatedthroughouttheprogram callgraph therebyaidingthecompileroptimizationpassesinfurthersimplifyingprogramexpressionsandpotentiallypruningdead code.however duetotheconservativenatureofconstantpropagationinproductioncompilerssuchasllvm thesesimplificationsareoftennotfullyrealizable.theconservativenatureof thesetransformsisinspiredbyaneedformaintainingreasonable compile timesinthegeneralcompilationworkflow thusavoiding potentiallyexpensiveanalyses.nonetheless forourparticularuse case of debloating a more sophisticated albeit relatively expensiveconstantpropagationtransformisjustified.ourexperimental resultsdemonstratetheanalysesoverheadsareveryreasonable.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
trimmer application specialization for code debloating ase september montpellier france wedevelopaninterproceduralconstantpropagationtransformation that provides more precise propagation of configuration invariants.thetransformworksbymaintainingmemorystatefor eachoftheprogramobjectsandtrackstheloadsandupdatesfrom thetargetobjects.algorithm 3givesthealgorithmforthetransform.the runonbasicblock procedureisinvokedoneachbasic blockofafunction inreversepostorder.r eversepostorderensures ablockisvisitedafterallitspredecessorblockshavebeenvisited.
theprocedureisinitiallyinvokedontheentrybasicblockofthe programentryroutine.theargumenttotheprocedureisacontext datastructurethatmaintainsthestateforeachtrackedmemory object.withintheprocedure eachinstructioninthebasicblockis traversed.thekeypointsofthealgorithmcanbesummarizedas follows algorithm algorithmforinterproceduralconstantpropagation 2function processcallinst callinst context 3ifcallee is externally defined then foreachargument in callinst do checksideeffects argument context end 7else runonbasicblock callee entryblock context 9end 10function processbranchinst branchinst 11foreach successor block in branchinst do ifall predecessors are visited then newcontext mergepredecessorcontext runonbasicblock successor newcontext end 16end function runonbasicblock basicblock context 19i firstinstructioninbasicblock 20repeat ifi is an allocation then objectcontext createobjectcontext i addtocontext objectcontext context end ifi is a store instruction then ifconstant value store then updatememcontext operand source context else marknonconstant operand context end end ifi is a load instruction then ifoperand is constant in context then replaceloadwithconstant i context end end ifi is a call instruction then processcallinst i end ifi is a branch instruction then processbranchinst i end i getsuccessorinst i untili is the last instruction 45markvisited basicblock handlingallocations foreachallocationsite heapandstack allocations a context data structure is created to represent the memorystateoftheunderlyingmemoryobject.thememorystate forgloballydeclaredobjectsiscreatedatanalysisstartup.
handling loads and stores foreach storeinstruction the memorycontextofthetargetmemoryobjectisupdated.forconstant value stores the memory state is updated with the correspondingconstantvalue.fornon constantstores thecorrespondingmemorystateismarkedasnon constant.foreach loadthat correspondstoaconstantvalueinthetargetmemorycontext the load is directly replaced with the constant value.
such constant foldingofloadspromotesfurtherconstantpropagation.
handling function calls theprocesscallinst procedure detailsthepoliciesforhandlingcallinstructions.forcalleefunctions defined internally the control is transferred to the callee.
moreover the state of the memory context at the call site is forwardedtothecallee.
as the constant propagation transform replaces the constant memory loads inside a function body the specialized call pathisonlyvalidinaparticularmemorycontext.therefore foreachdistinct memory context a new cloned specialized routine mustbe created.
however since creating multiple clones of a single functioncanincreasecodesize weonlyspecializefunctionsthat haveasingleidenticalmemorycontextacrossallcall sites.thisconservative approach prevents a code size blow up that could resultwithgeneratingaspecializedfunctionperdistinctmemory context.
handling branches asbranchinstructionsareencountered controlistransferredtothesuccessorblocks.the processbranchinstproceduredetailsthepoliciesforhandlingbranchinstructions.
controlistransferredtoabasicblockonceallitspredecessorblockshavebeenvisited.thisisnecessarysincethememorycontextavailableataparticularblockiscomputedasanintersectionoftheconstantmemorycontextsavailableatallthepredecessorblocks.for instance ifoneofthepredecessorsincludesanon constantstoreto amemoryobject thesuccessor smemorycontextcorresponding tothatobjectismarkednon constant regardlessofapotentially constantcontextinadifferentpredecessor.specifically thecallto procedure mergepredecessorcontext merges the memory contextsofallpredecessorblocks.weincludespecialhandlingofloops.
ifthebasicblockistheheader entryblock ofaloop theanalysis doesnotwaitfortheanalysiscompletionofthelooplatches blocks that branch back into the loop header and starts traversing the loopbody.
theimplementationsupportsamuchwiderrangeofinstruction types.
however due to space limitations we have detailed only specific interestingdetailsofthealgorithm.figure 3aincludescode thatpopulatestheconfigurationstructureswiththeuser provided settings.
the parsing code under parse input is assumed to be alreadysimplifiedbyacombinationofinputspecializationandloop unrolling.theroutine start process includescodethatisconditionalontheconfigurationsettings.sincetheconfigurationvalues enable plugins andenable debug areresolvedasconstants the constantpropagationtransformcanbeleveragedforpropagating the constant values to the corresponding branch conditions un der start process .thisallowsexistingcompileroptimizations to further simplify the code by statically evaluating the branch authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france hashim sharif muhammad abubakar ashish gehani and fareed zaffar figure 3a the example code invokes routines that are conditional on the configuration settings.
the data structure configis populated with the configuration values.
voidparse input int argc char argv structconfig config config enable plugins false config enable debug false voidstart process struct config config if config enable plugins load plugins conditional invocation if config enable debug print debug conditional invocation start main process config voidmain int argc char argv structconfig config malloc sizeof struct config parse input argc argv config start process config figure3b theconstantconfigurationvaluesarepropagated hence pruning the unreachable branch conditions and in turn eliminat ing unreachable routines load plugins and print debug.
voidstart process struct config config pruned unreachable calls start main process config voidmain int argc char argv structconfig config malloc sizeof struct config parse input argc argv config start process config conditions thereby eliminating dead code.
figure 3bshows the correspondingtransformedprogramafterapplyingourconstant propagationtransformfollowedbythestandardllvmoptimizations.
the calls to routines load plugins andprint debug are prunedasaresultoftheoptimizations.
.
soundness of transformations trimmerprovidespropagationofconfigurationvaluesthrougha combinationofsequentiallyexecutedpasses inputspecialization loop unrolling and constant propagation while allowing existingllvmanalysestopruneprovablyunusedcodeinlightofthe introducedconstants.topreserveprogramsemantics ourtransformationsmustpreventanyincorrectconstantfolding replacinga non constantexpressionwithaconstantvalue .incorrectconstant foldingmayalsopotentiallyleadtounsounddeadcodeelimination eliminatingfunctions branchesthatmaybeinvoked .
toensurethecorrectnessofconstantfolding wemakeconservative assumptions regarding memory side effects.
while these assumptionslimittheprecisionofouranalysis theyensurethat thetransformationsaresound.wediscussscenariosthatpresent threatstothevalidityofourtransformationsandtheassumptions necessarytopreservesoundness.
inputspecialization intheinputspecializationtransform we replaceoccurrencesoftheprograminputarguments argv