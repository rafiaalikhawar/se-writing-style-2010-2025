singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems using finite state models for log diff erencing using finite state models for log diff erencing hen am ar tel aviv univ ersity lingf eng ba o zhejiang univ ersity nimr od busan y tel aviv univ ersity david l o singapor e management univ ersity davidlo smu.edu.sg shahar m aoz tel aviv univ ersity follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the softwar e engineering commons and the theor y and algorithms commons citation citation amar hen ba o lingf eng busan y nimr od l o david and m aoz shahar .
using finite state models for log diff erencing.
.
esec fse pr oceedings of the 26th a cm joint meeting on e uropean softwar e engineering con f erence and symposium on the f oundations of softwar e engineering lak e buena vista fl no vember .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
using finite state models for log differencing hen amar tel aviv university israellingfeng bao zhejiang university city college chinanimrod busany tel aviv university israel david lo singapore management university singaporeshahar maoz tel aviv university israel abstract much work has been published on extracting various kinds of models from logs that document the execution of running systems.
in many cases however for example in the context of evolution testing or malware analysis engineers are interested not only in a single log but in a set of several logs each of which originated from a different set of runs of the system at hand.
then the difference between the logs is the main target of interest.
in this work we investigate the use of finite state models for log differencing.
rather than comparing the logs directly we generate concise models to describe and highlight their differences.
specifically we present two algorithms based on the classic k tails algorithm 2kdiff which computes and highlights simple traces containing sequences of kevents that belong to one log but not the other and nkdiff which extends k tails from one to many logs and distinguishes the sequences of length kthat are common to all logs from the ones found in only some of them all on top of a single rich model.
both algorithms are sound and complete modulo the abstraction defined by the use of k tails.
we implemented both algorithms and evaluated their performance on mutated logs that we generated based on models from the literature.
we conducted a user study including participants demonstrating the effectiveness of the approach in log differencing tasks.
we have further performed a case study to examine the use of our approach in malware analysis.
finally we have made our work available in a prototype web application for experiments.
ccs concepts software and its engineering software testing and debugging keywords log analysis model inference lingfeng bao was affiliated with singapore management university singapore when this work was performed.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
reference format hen amar lingfeng bao nimrod busany david lo and shahar maoz.
.
using finite state models for log differencing.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction logs which document the execution of running systems contain valuable information about their behavior.
much work has been published on extracting various kinds of models from such logs from finite state machines that approximate the behavior of the system that generated the log to candidate temporal properties that characterize their behavior over time see e.g.
.
these models and properties may provide useful information for engineers for tasks such as debugging testing and comprehension.
in many cases however engineers are interested not only in a single log but in a set of several logs each of which originated from a different set of runs of the system at hand.
for example in the context of evolution an engineer may be interested in the differences between logs generated by different versions of the system.
such differences may highlight bugs or new functionality that have been eliminated or introduced.
as another example in the context of testing and deployment an engineer may be interested in the differences between logs generated by a system when deployed in different environments e.g.
lab tests vs. field.
then the differences may highlight e.g.
behaviors that occur in the field but not in the lab and thus may call for updates to the lab tests.
as another example in the context of malware analysis engineers may be interested in finding the differences between two versions of a system the original one and a suspected infected one and try to identify these differences based on logs produced by runs of the two systems.
in all these cases one does not require an analysis of each log alone but rather a comparative analysis which focuses on the differences between a number of available logs.
as logs are long complex and often very detailed a direct comparison between them is neither feasible nor desired.
instead one would be interested in a concise expressive and engineer friendly representation of their differences.
this motivates the use of models.
in this work we investigate the use of finite state machine fsm models for log differencing.
rather than comparing the logs themselves we generate concise models that describe and highlight their differences.
specifically we present two very different algorithms both based on the classic k tails algorithm .
k tails has been 49esec fse november lake buena vista fl usa h. amar l. bao n. busany d. lo s. maoz implemented and used over the last two decades in several variants by many e.g.
.
roughly given a log and a positive integer k k tails extracts a fsm that over approximates the system that generated the log using k sequences i.e.
event sequences of length kor less.
one may suggest the following approach to compare logs using models build a model from each log alone e.g.
using k tails and then compare the models e.g.
by intersecting one with the complement of the other or by enumerating traces that are accepted by one and not the other.
indeed this was recently suggested in .
however this approach has a number of weaknesses in terms of soundness completeness and performance.
since the models overapproximate the logs their comparison may yield spurious differences which have no evidence in the logs.
moreover a complete comparison may become very costly for inferred models which typically include loops and non determinism.
finally this approach does not scale to compare many logs because it requires combinatorially many comparisons between subsets of logs.
our approach is different.
first we present 2kdiff a basic algorithm to compare two logs.
2kdiff compares two logs by focusing on their k differences i.e.
ksequences that belong to one log but not the other.
2kdiff computes the set of k differences and selects from the logs representative traces containing them.
then it computes the k tails fsm of each log separately and presents the selected traces on top of them with the k differences highlighted.
2kdiff is limited to compare two logs.
second we present an advanced algorithm we call nkdiff which extends the classic k tails algorithm it takes a set of n 2logs as input and it outputs a single labeled fsm that represents their differences.
the labeling consisting of subsets of .
.
.
n provides two way traceability between the behaviors in the ninput logs and the behaviors induced by the labeled fsm.
nkdiff is built to compare many logs at once.
most importantly both algorithms 2kdiff and nkdiff guarantee soundness and completeness modulo the k tails abstraction i.e.
their over approximation is not worse than the over approximation induced by the use of k tails.
they do not yield spurious differences and they do yield all differences.
we present the two algorithms and discuss their properties in sect.
.
to evaluate our work we implemented the two algorithms validated the implementations and evaluated their performance on mutated logs generated based on publicly available non trivial models from the literature.
we conducted a user study including participants which were given log comparison tasks.
we measured both the correctness and the time required to perform each task using our approach and two alternative tools as baselines.
the results demonstrate the effectiveness of the approach in improving both aspects.
we have further performed a case study to examine the use of our approach in android malware analysis.
finally we have made our work available in a prototype web application for experiments .
we present the evaluation in sect.
.
while much work has been published on extracting various kinds of models and temporal properties from logs see e.g.
almost no work has considered the problem of using models for log differencing.
we discuss related work in sect.
.check out check out check out check out valid coupon invalid coupon invalid coupon invalid coupon reduce price check out check out check out check out valid coupon valid coupon get credit card get credit card reduce price reduce price check out check out check out check out get credit card get credit card valid coupon get credit card reduce price check out check out check out check out invalid coupon get credit card invalid coupon invalid coupon reduce price check out check out check out check out get credit card get credit card get credit card invalid coupon reduce price check out check out check out check out valid coupon valid coupon get credit card get credit card reduce price reduce price check out check out check out check out get credit card invalid coupon valid coupon get credit card check out reduce price check out get credit card check out check out get credit card get credit card invalid coupon check out reduce price check out valid coupon check out check out get credit card reduce price valid coupon get credit card check out reduce price get credit card check out check out invalid coupon invalid coupon check out check out get credit card valid coupon reduce price check out check out get credit card get credit card check out invalid coupon reduce price check out get credit card figure four logs of the shopping cart system in four columns l1 tol4 left to right each consists of several traces separated by .
example in beschastnikh et al.
use an example of a shopping cart.
the log used in their example contains a bug where the user can use an invalid coupon to reduce the price.
below we present a variant of this example where an engineer has four logs some of which from a version of the shopping cart with the bug and some from a version without it.
we present the example semi formally for illustration purposes.
formal definitions appear later in the paper.
fig.
shows excerpts from four logs of the shopping cart system from left to right l1tol4 each containing several traces.
although this is only an excerpt of traces from each of the four logs it is already difficult to identify any difference.
real world logs are much longer and more complex.
how can the engineer find the bug that is hidden in some of them?
the first algorithm we present 2kdiff allows the engineer to compare two logs.
assume that the engineer is interested in comparing l1andl3.
2kdiff visualizes the differences between the logs by highlighting sequences of length kor less that appear only in one of the two logs.
the parameter kis set by the engineer the higher thekthe more differences are expected to appear.
for example if the engineer selects k 2kdiff finds that the sequence invalidcoupon reduce price appears only in l3.
2kdiff highlights this k sequence by superimposing a concrete trace from l3that includes this k sequence over the k tails model of l3 as illustrated in fig.
produced by our prototype implementation of 2kdiff where the trace is highlighted in red and the k sequence is emboldened.
the model shows that the bug appears in l3but not in l1.
50using finite state models for log differencing esec fse november lake buena vista fl usa check out invalid coupon check out valid couponcheck out invalid coupon reduce priceterminal check outget credit cardinitialinitial figure the output of 2kdiff when comparing logs l1and l3.
a trace visualizing the differences between the models is superimposed over the k fsm model of l3.
specifically the third trace from l3 i n it ial check out invalid coupon reduce price check out et credit card t ermi n al is highlighted to reflect the k sequence invalid coupon reduce price which does not appear in any trace in l1.
this k sequence is emboldened to emphasize the difference.
3check out check out 4invalid coupon check outvalid coupon reduce priceinitial6 7get credit cardterminal invalid coupon figure the output of nkdiff when comparing the four logs l1to l4.
note the red transition labeled signifying that the transition invalid coupon after which reduce price occurs appears in l2andl3 but not in the two other logs.
the second algorithm we present nkdiff compares many logs at once.
given all four logs l1tol4 as input nkdiff outputs a single model that highlights the difference in behaviors between them.
specifically fig.
shows the output of our prototype implementation of nkdiff with k a finite state machine extended with colored and labeled transitions.
black transitions represent behaviors that are common to all logs.
red transitions represent behaviors that occur in only some of the logs whose numbers appear as a label.
in our example the red transition labeled invalid coupon after which reduce price has occurred appears only in l2andl3.
thus the model that nkdiff presents reveals and highlights the bug.
note that the algorithms are complementary.
2kdiff highlights concrete traces of discovered differences between two logs.
nkdiff identifies differences between many logs at once but highlights no concrete traces.
one is not a generalization of the other.
preliminaries basic definitions.
a trace over an alphabet is a finite word tr e1 e2 .
.
.
em where e1 .
.
.
em .
for j 1we use tr j to denote the jth element in tr.
we use tr to denote the length of tr.
for a positive integer k ak sequence is a consecutive sequence of k or less events denoted by kseq.
kis the set of all k sequences over .
a log lover an alphabet is a set of traces l tr1 .
.
.
trn .definition .
finite state machine fsm .
a finite state machine fsm is a structure m q qi qs where qis a set of states qi qis a set of initial states qs qis a set of accepting states is an alphabet and q p q is a transition relation wherep q is the power set of the set of states q. letmbe an fsm over an alphabet .
we usel m to denote the set of all words accepted by m. k tails.
k tails first introduced in is a classic model inference algorithm.
over the last two decades k tails has been presented in several variants and implemented in many works e.g.
.
we use a definition inspired by .
k tails takes a log and a parameter kas input.
it starts by representing the log as an fsm mlincomposed of linear sub fsms one per trace which are joined by adding a single initial state qinit transitioning to the start of each trace via a unique label and a single terminal state qaccto which all traces transition to at the end via a unique label.
notice that the language of mlinequals the set of traces in the log given that each trace is encapsulated by and events.
we refer to this version of the log as the encapsulated version denoted by len.
k tails iteratively merges states in the mlinfsm two states are merged iff they are k equivalent i.e.
if their future of length kor less is identical.
when no two remaining states are k equivalent the algorithm terminates and outputs the resulting fsm called a k fsm.
more formally we define a function future qmlin p k mapping states in mlinto k sequences.
the k equivalence relation induces a partition of the states of the initial fsm mlininto equivalence classes e e1 e2 .
.
.
em where each of the equivalence classes in eis uniquely defined by its future sequences of length k or less.
two states s1 s2 eiifffuture s1 future s2 .
when lifted from qmlintoe the function future becomes the injective function id e p k .
for all s ei future s id ei .
formally definition .
k fsm .
k fsm the fsm computed by k tails for a log land a positive integer k is an fsm ml q qi qs where q e where eis the set of equivalence classes defined above is the alphabet of the log l e e a e a e s s mlins.t.s mlin s a s e s e qi qinit is an artificial initial state and qs qacc is an artificial terminal state.
when clear from the context we write fsm instead of k fsm.
for a given k fsm ml generated by running k tails on log l we usel ml to denote the set of all words accepted by ml.
among other properties the correctness of the k tails algorithm implies that mlmay over approximate the set of traces in lbut may not under approximate it i.e.
l l ml .
consequently every ksequence included in any trace in l is part of at least one accepting word of ml.
additional useful properties of the k fsm are that all its states are reachable from the initial state qinit and that the accepting state qaccis reachable from all states.
using models for log differencing we present the main contributions of our work 2kdiff for differencing of two logs and nkdiff for differencing of many logs.
we give formal definitions and examples but omit the proofs which can be found in .
51esec fse november lake buena vista fl usa h. amar l. bao n. busany d. lo s. maoz algorithm 2kdiff algorithm procedure 2kdiff l1 l2 k k seqs l1 find ks l1 k k seqs l2 find ks l2 k k seqs l1 l2 k seqs l1 k seqs l2 genmodel l1 k seqs l1 l2 procedure genmodel l k seqs traces 2ks selecttraces l k seqs m k tails l k hi hli ht m traces 2ks displays the model marking the selected traces and k sequences procedure selecttraces l k seqs returns a mapping of traces in lcovering the k sequences in k seqs traces 2ks map while k seqs .empty do tr seqs find top coverin trace k seqs l returns a trace in l tr covering the max.
num.
of k sequences seqs in k seqs k seqs .remove seqs traces 2ks seqs map the trace to the k sequences that it covers return traces 2ks .
2kdiff differencing two logs given a positive integer k 2kdiff compares two logs by focusing on k differences i.e.
k sequences that appear in one log but not the other and presenting them in the context they appear in.
the 2kdiff algorithm.
first 2kdiff computes the sets of k sequences included in each of the logs and compares the two sets to find the k sequences that are unique to each log i.e.
the set of k differences if there are any alg.
lines .
second in order to present the k differences in their context over concrete traces for each of the two logs the algorithm looks for a locally minimal set of traces such that every k sequence is included in at least one trace alg.
lines .
the set of traces is computed in a greedy iterative manner in each step the algorithm goes over the traces of the logs and selects the trace with the highest coverage of kdifferences that have not yet been covered.
the iteration terminates when all the k differences are covered.
finally 2kdiff computes the k fsm for each log.
it replays the selected traces from the previous step over these k fsms and highlights transitions visited during the replay in red alg.
lines .
transitions that belong to a k difference are emboldened.
when there are multiple traces the engineer can iterate over them one trace at a time.
example .
.
consider running 2kdiff on l1andl3from sect.
with k .
first 2kdiff searches for the k differences between the logs.
it finds that while all k sequences in l1appear in l3 l3contains a single k sequence that does not appear in l1 kseq invalidcoupon reduce price .
next 2kdiff searches for a trace containingkseqand finds the third trace in l3 tr check out invalidcoupon reduce price check out et credit card .
finally 2kdiff computes the k fsm for l3 and highlights the trace trover it while emboldening the transitions in kseq as we show in fig.
.
it is important to note that 2kdiff is sound and complete modulo the k sequences abstraction.
specifically any k sequence that appears in one log and not the other is included in at least onehighlighted trace on the k fsm of the respective log and any such highlighted trace contains at least one such k sequence.
roughly these strong notions of soundness and completeness are guaranteed thanks to properties of k fsm built by the k tails algorithm.
theorem .
2kdiff soundness and completeness .
letk be a positive integer and let l1 l2be two logs compared using 2kdiff with k fsm 1and k fsm 2their corresponding k fsm models.
then any trace highlighted by 2kdiff over k fsm 1is a trace from l1that includes at least one k sequence missing from l2 and every k sequence that appears in l1and does not appear in l2is highlighted by at least one accepted trace in k fsm .
the same holds for k fsm .
in search for a small set of traces that covers the k differences as described above we chose to implement a greedy algorithm which ensures that we find a locally minimal covering set removing any trace from this set will reduce coverage.
still there may exist a smaller covering set of traces.
as finding a globally minimal set may require the enumeration of all possible subsets of traces from the log we chose a greedy algorithm to ensure reasonable performance.
time and space complexity.
to construct the k tails model 2kdiff uses the k tails variant from which yields quadratic time complexity with respect to the number of events in the log.
searching for k differences and highlighting traces over the resulting fsm is linear in the number of events in the logs.
hence k tails model construction dominates the time complexity of 2kdiff.
its space complexity is linear in the number of events in the log.
.
nkdiff differencing many logs 2kdiff is limited to comparing two logs.
we now present nkdiff a sound and complete extension of k tails from one to many logs.
roughly given a set of nlogs l1 .
.
.
ln and a positive integer k our goal is to compute a single model an fsm labeled with subsets of log indexes which will be sound and complete its projection on any given index will result in the k fsm we could have computed for the log with that index soundness and any behavior that appears in at least one of the logs will be included in it completeness .
this labeled fsm is inspired by a similar model named featured transition system fts which has been presented for the purpose of model checking of software product lines see related work in sect.
.
labeled fsm lfsm and k difflfsm.
to formalize the above we first extend the basic definition of fsm from def.
.
to a labeled fsm lfsm .
the extension is made by labeling each of the fsm transitions with a subset of log indexes.
formally definition .
labeled finite state machine lfsm .
a labeled fsm is a structure m q qi qs i label where q qi qs and are defined as in an fsm iis a set of indexes for us log indexes and label q q p i is a labeling function which maps every transition in to a subset of indexes from i. a trace tris accepted by an lfsm miff there exists an index ind is.t.trreaches an accepting state on a path whose all transition labels include ind.
more formally a path s1 .
.
.
sm is accepting for a trace trin an lfsm miff ind is.t.s1 qi sm qs i js.t.j i i tr sj si tr i ind label si tr i sj .
as in an fsm the language of the lfsm is the set of all traces it accepts.
52using finite state models for log differencing esec fse november lake buena vista fl usa an lfsm induces a projection operation proj lfsm i fsm given an index i i proj removes from the lfsm all transitions whose set of labels does not include i removes all states that become unreachable from the initial state and then removes all labels from the remaining transitions.
the result of proj is an fsm.
example .
.
the model presented in fig.
represents an lfsm over the set of logs l1 l2 l3 l4 .
the transition invalid coupon from state to state is labeled with a set of log indexes in this case the set to avoid clutter in fig.
we do not show the label for transitions labeled with all log indexes .
when applying proj to this lfsm with index or the result is an fsm that does not include the transition invalid coupon from state to state .
theorem .
.
the language of an lfsm mis equal to the union of the languages of all projections of mto indexes from i. formally l m i il proj m i .
we now extend the definition of k fsm from def.
.
to a kdifflfsm.
roughly the k difflfsm is a labeled k fsm which accepts all traces from all logs inclusion and whose projection to any label jresults in the k fsm generated by running k tails only on lj projection .
inclusion and projection soundness and completeness are important.
inclusion is important as it guarantees that just like the k fsm for each log the k difflfsm accepts all traces from all logs no under approximation .
projection is important as it guarantees that the over approximation in the k difflfsm is exactly like that of the k fsm for each log not worse.
more formally let l li i n .lis a union of sets of traces so it is a valid log.
recall the k tails algorithm from sect.
letmj lindenote the fsm of linear sub fsms of lj.
let futurejbe the mapping of states to their future s of length kor less in mj lin.
definition .
k difflfsm .
for set of logs l1 .
.
.
ln and a positive integer k a k difflfsm ml1.
.
.lnis an lfsm q qi qs i label where q e the set of equivalence classes of states from the k fsm ml iis the set of indexes .
.
.n is the union of the alphabets of the logs l1to ln e e e a label e a e j s s mj lins.t.s mj lin s a f uturej s id e f uturej s id e e e e a e e a ifflabel e a e qi qinit is an artificial initial state and qs qacc is an artificial terminal state.
we now formally define k difflfsm s soundness inclusion and completeness projection and illustrate them with our example.
theorem .
nkdiff soundness and completeness .
let ml1.
.
.lnbe the k difflfsm for a set of logs l1 .
.
.
ln and a positive integer k. then for all i n li l ml1.
.
.ln and for all1 i n proj ml1.
.
.ln i is identical to the k fsm mli generated by running k tails only on li.
in particular for all i n l proj ml1.
.
.ln i l mli .
example .
.
consider the four logs shown in fig.
and their corresponding k difflfsm model shown in fig.
resulting by executing nkdiff on these logs.
one can check that inclusion soundness holds as every trace in any of the four input logs is part of l ml .
projection completeness holds too since e.g.
for i algorithm nkdiff algorithm procedure nkdiff logs l1 l2 .
.
.
ln k findalphabet lo s i findlo labels lo s ml lin generatelabeledlinearfsm lo s eqv cls2states mapequivalenceclassestostates ml lin k maps each equivalence class to its states in ml linaccording to their future of length kor less q eqv cls2states .keys qi findinit eqv cls2states ml lin qs findterminal eqv cls2states ml lin map label map fore e eqv cls2states .keys do a etconnectin event e e returns null if none exists labels getlo labels e e a eqv cls2states ml lin computes si j s e s e s.t.s ml lin s a j labelml lin s a s iflabels then label label e return ml q qi qs i label removing the only transition twhose label is will result in the exact k fsm generated by running k tails on l1orl4alone.
the nkdiff algorithm.
nkdiff takes as input a set of logs l l1 .
.
.
ln and a positive integer k it outputs a k difflfsm ml.
first nkdiff computes alphabet of the logs and the logs labels alg.
lines .
then instead of an unlabeled initial fsm mlin it builds an initial lfsm ml lin where each trace s linear sub fsm is labeled with the single index of the log from which it came from alg.
line .
second it merges all states in ml lininto a set of equivalence classes ebased on the states futures of length kor less alg.
line .
eis defined as the set of states of the output k difflfsm ml.
further the equivalence classes holding the dummy initial and terminal states are defined accordingly alg.
lines .
third to construct the transition function ofml and the transitions labeling function label for each ordered pair of states e e e. the algorithm checks if the future of eis succeeded by e and if so finds the next event a. then it computes the maximal set of indexes sis.t.
for each j si s e s e s.t.s ml lin s a j labelml lin s a s .
ifsi nkdiff adds the transition and label to ml alg.
lines .
time and space complexity.
nkdiff uses the k tails variant of to construct a model from all logs.
its time complexity is dominated by states merging phase of k tails alg.
line and is quadratic in the number of events in all logs.
the additional steps in nkdiff of denoting transitions with labels and computing the label function alg.
line require a linear time in the number of events in all logs.
space complexity is linear in the number of events in all logs.
.
implementation and validation implementation.
we have implemented 2kdiff and nkdiff by extending the k tails implementation used in .
the implementation 53esec fse november lake buena vista fl usa h. amar l. bao n. busany d. lo s. maoz includes all steps from parsing the logs to computing the model to visualizing it.
we made the implementation publicly available as a prototype web application that allows review and experiments.
we encourage the interested reader to check it out see .
validation.
to validate 2kdiff we implemented unit tests covering the steps of the algorithm k sequences extraction from log kdifferences coverage by traces from the logs and trace highlighting over the generated model.
further we implemented an integration test run the algorithm over pairs of manually constructed example logs and manually compare the output with the expected results.
to validate nkdiff we have created and executed automated validation.
the validation code runs k tails on each log in the input set and runs nkdiff on the set of logs.
it then checks that the output models satisfy the inclusion and projection soundness and completeness requirements by comparing the generated models.
we repeated the automated validation many times with many different logs generated from models.
the above procedures provide evidence that our implementations are correct.
evaluation we present an evaluation in three parts.
the first evaluates the performance of 2kdiff and nkdiff.
the second is a controlled user study to examine the potential use of 2kdiff and nkdiff by engineers.
the third is a case study in malware analysis.
.
performance evaluation we conducted a preliminary evaluation of the performance of 2kdiff and nkdiff guided by the following research questions rqa1 how is the performance of 2kdiff and nkdiff affected by thenumber of k differences between the compared logs?
rqa2 how is nkdiff performance affected by the number of logs ?
.
.
models used.
we used finite state machine models in our evaluation all taken from lo et al.
and from pradel et al.
.
the models vary in size and complexity i.e.
the alphabet size ranges from to the number of states ranges from to and the number of transitions ranges from to .
the complete list of models and their statistics are available in supporting materials .
.
.
experiment design and setup.
we generated logs from the models described above using a publicly available trace generator configured to provide state coverage and yielding logs of roughly thousand traces each.
for 2kdiff and nkdiff in all experiments we used k a value ofkthat is commonly used in the literature on k tails.
to introduce k differences into the logs we used the following log mutation procedure clone a randomly selected trace and flip a random pair of consecutive events in it if the modified trace consists of a k sequence missing from the log add it to the mutated log otherwise repeat the procedure.
in measuring computation times we included all steps from parsing the logs to computing the models to exporting to dot format for visualization.
we executed all experiments on an ordinary laptop computer intel i5 cpu .4ghz 8gb ram with windows bit os java .
.0 45 bit.
we executed all runs times to average out measurement noise from the java execution.
.
.
experiment i varying mutation type.
we aim to investigate how the performance of 2kdiff and nkdiff depends on the number of k differences between the logs.
first we selected a model and generated a log from it.
second we created a mutated version of the log by following the mutation procedure described above.
in our experiments we consider three types of log mutation policies no mutation n one mutation o and multiple mutations m .
no mutation means we compare two identical logs.
one mutation means that the mutated log includes a new trace with at least one new k sequence.
multiple mutations m means that we repeat the process of mutating each log times effectively adding new traces to the mutated log.
lastly we run both methods 2kdiff and nkdiff over the original log and the mutated log and measured their running times.
we repeated each combination of model and mutation policy times.
.
.
experiment ii varying the number of logs.
we aim to check the effect of the number of logs on the performance of nkdiff.
for each model and for each mutation policy we generated a varying number of logs .
for experiments with the n mutation policy all logs were kept identical for experiments with the o mutation policy n 1logs were kept identical and one log contained a single mutation and for experiments with the m mutation policy for each i n thei thlog included a single additional mutation over the i 1log.
we repeated each combination of model number of logs and mutation policy times.
.
.
results.
we run 2kdiff and nkdiff on the mutated logs generated from the models using each of the three mutation policies.
for each model we measured the average number of traces average trace length in the generated logs and the average running times of 2kdiff and nkdiff per mutation policy.
the results show acceptable average running times for logs of realistic sizes originating from different models with an average running time below seconds for out of the models and where the longest average running time did not exceed seconds for both methods.
furthermore while running times of both methods vary much across different models the mutation policy seems to have no significant effect.
nkdiff requires twice the time of 2kdiff a phenomena which is consistent across all models.
this is not surprising as nkdiff constructed a model from both logs while 2kdiff only constructed a model from the mutated version of the logs due to the nature of the mutation which makes one of the logs contain all k sequences of the other.
as a result 2kdiff only constructed the model for the log containing the additional k sequence.
for identical logs i.e.
the nmutation policy 2kdiff constructed a single model without superimposing any of the traces.
detailed performance results are available in .
to answer we have evidence that 2kdiff and nkdiff are applicable to systems of different size and complexity and logs of varying similarities.
both methods generate models from large logs in acceptable times.
the results of experiment ii considering average running times of four selected models with different mutation policies when growing the number of logs from to reveal that in all mutation 54using finite state models for log differencing esec fse november lake buena vista fl usa policies nkdiff running times show a quadratic growth with respect to the number of logs.
this is consistent with the complexity analysis in sect.
.
as the logs and their mutations were kept on roughly equal sizes.
to further investigate we run the variant of k tails over the logs used in our experiments and observed the same quadratic trend.
this indicates that nkdiff s performance is dominated by and similar to that of k tails.
detailed results of experiment ii are available in .
to answer we have evidence showing that nkdiff running time is quadratically dependent on the number of logs when the logs are kept in similar sizes.
this phenomenon is evident across models and the three mutation policies.
.
.
threats to validity.
first the selection of models in our evaluation may not represent typical systems.
to mitigate this we used publicly available models with non trivial size and complexity taken from two previous works see sect.
.
.
.
yet we do not know to what extent these are representative of real world systems and do the mutations that we performed are representative of real world changes.
second to generate logs from the publicly available models and their mutations we used a publicly available trace generator as described above.
it is possible that one may get different results if a different trace generator or a different coverage criterion is used.
.
controlled user study we conducted a controlled user study to quantitatively measure the benefit that 2kdiff and nkdiff can provide to their potential users.
we choose to conduct a controlled study to focus on evaluating pertinent features of the algorithms.
the research questions guiding our user study are rqb1 can using 2kdiff and nkdiff help participants more accurately identify behavioral differences between different versions of the same system?
rqb2 do 2kdiff and nkdiff shorten the time required for participant in identifying if and when a behavioral difference was introduced into a system?
.
.
experiment setup.
to answer the research questions we capture a scenario where a behavioral difference is introduced into a system.
a participant is given access to logs of different runs of five versions of the system.
the participant is tasked to identify a behavioral difference and when it was first introduced into the system by answering a set of questions.
to capture this scenario we generated a log with traces produced by a trace generator for a model.
we copied the log five times and numbered the copies to represent consecutive versions of the system.
then we randomly chose a trace from the first log and mutated it by flipping two consecutive events i.e.
a sequence.
to guarantee that the flip added a new behavior we checked that the new pair of consecutive events does not appear in any of the traces in the log.
we then randomly chose one of the versions apart from the first version and replaced the original trace with the mutated trace in this version and in all the following versions.independent and dependent variables.
the experiment s purpose is to examine whether 2kdiff and nkdiff provide participants with support in finding log differences better than some alternatives baselines while considering a number of different logs and usage scenarios.
thus our experiment has three independent variables thetoolused to find log differences the log set and the usage scenario and two dependent variables correctness of the task solution i.e.
answers given by participants and completion time .
we consider three tools i.e.
2kdiff nkdiff a popular webbased text differencing tool and k tails six sets of logs i.e.
columba cruisecontrol.net ctas.net cvs.net java.util.stringtokenizer androomcontroller.net generated as above from models found in existing literature and two usage scenarios i.e.
regression test and user interaction .
the regression test scenario simulates a case when an engineer runs a test suite on multiple versions of a software system while the user interaction scenario simulates a case when a user tries various features of multiple versions of a system.
to capture the regression test scenario we randomly applied a mutation according to the procedure described above while maintaining similar trace order between different logs.
to capture the user interaction scenario we shuffled the traces mimicking different interactions with the application.
in both scenarios a single random mutation in the form of a new sequence was the only behavioral difference between the logs.
participants and task assignments.
we invited graduate students with background in software engineering from two universities.
we divided the participants into six groups of participants each.
one factor that could have an impact on the participants performance is experience level.
we collect participants personal information e.g.
the year they start their post graduate program their prior experience in industry etc.
and use it to categorize the participants into junior and senior participants.
the ratio ofjunior andsenior participants for each group was kept approximately .
every participant is required to perform six tasks by analyzing six log sets.
he she needs to use a log differencing tool twice one for the user interaction scenario and another for the unit testscenario.
the participants in all groups were presented with the log sets in a similar order.
to avoid biases we designed the experiment such that each log was analyzed by each of the tools in each of the usage scenarios covering all different orders.
detailed procedure.
at the beginning of the study participants are required to read a tutorial and watch a video explaining the three log differencing tools and how they can be used to complete the tasks.
participants typically spend to minutes this.
then they attempted each of the six tasks one by one.
to complete each task participants are required to analyze a log set using a specified tool and eventually answer a several questions through a web interface.
the following are the four questions that we asked participants for each task is there a log that contains any 2sequence that does not appear in its preceding log?
what is the id of the earliest log that introduces a new sequence?
what is the sequence that appears in the new version but not in the old version?
and what is the trace that shows the sequence difference?
note that if a participant answers no to the first question they will not be asked the subsequent questions.
our web interface 55esec fse november lake buena vista fl usa h. amar l. bao n. busany d. lo s. maoz 0510user interaction unit test columba cruisecontrol ctas cvs stringtokenizer roomcontroller q2 q3 q4 q2 q3 q4 text k tails 2kdif f nkdiff figure number of participants who answer questions correctly for different tasks scenarios and tools.
recorded participants answers and the amount of time they used to complete each task.
.
.
results.
we report experiment results by answering the research questions mentioned earlier as follows rqb1 correctness.
after all participants completed the experiments we evaluated the correctness of the participant answers.
if a participant chose no option for the first question of a task the other three questions are labeled as incorrect.
figure shows the number of participants who gave correct answers for questions and for the different tasks.
note that we don t show the count for the first question since a yes answer for the first question does not mean that the participant found the difference among the logs.
from the figure we observe the following most participants who use 2kdiff nkdiff answered the questions correctly.
only three did not answer the questions correctly these happen when they use 2kdiff nkdiff for the first time to complete a task.
we talked with them and found that they were not very familiar with the tool the first time they used it.
for the text differencing tool the correctness for tasks in user interaction scenario is much lower than that for tasks in unit test scenario.
note that for the user interaction scenario traces in logs are shuffled.
for such logs the text differencing tool often returns a large number of syntactic differences which make it difficult for participants to identify the sequence difference.
for the unit test scenario the number of returned syntactic difference is much lower.
hence the correctness of participants who use the text differencing tool in unit test scenario is close to that of participants who use 2kdiff nkdiff.
for k tails the difference in correctness between the two scenarios is minor.
however we find that the complexity of the log set impacts correctness.
for example the model used to generate cruisecontrol log set is much more complex than that used to generate columba log set.
comparing the results for these twotable aggregated correctness results for the different tools considering each scenario.
user interaction unit test average correctnesstext .
.
k tails .
.
2kdiff nkdiff97.
.
p value text .
.
large .
.
large k tails .
.
large .
.
large log sets we find that using k tails participants produced substantially fewer correct answers for cruisecontrol than for columba .
we also find that some participants who performed tasks with columba using k tails answered the second question correctly but the next two questions incorrectly.
this might be because participants found that the two models generated by k tails are different but they could not identify which transitions are the new sequences by comparing two k tails models manually.
we further compute the average correctness for the different tools when used to complete tasks in each of the two scenarios see table .
the average correctness for tasks completed using 2kdiff nkdiff is very high more than for each scenario.
on the other hand the average correctness for tasks in user interaction scenario completed using the text differencing tool is the lowest only .
.
to measure whether the differences on correctness between 2kdiff nkdiff and baselines were statistically significant for the two scenarios we apply wilcoxon signed rank test with bonferroni correction.
the corrected p values are all smaller than .
which indicates that the difference is statistically significant at a confidence level of .
we also calculated cliff s delta1 which is a non parametric effect size measure to show the effect sizes of the correctness difference between 2kdiff nkdiff and each of the baselines.
the cliff s deltas are all large demonstrating the effectiveness of our proposed tool in helping participants produce correct results for the tasks.
2kdiff nkdiff can help participants accurately identify behavioral differences among different logs.
the differences in average correctness between tasks completed using our tool and those using a baseline are statistically significant with large effect sizes.
rqb2 completion time.
table shows the average participant completion time for each task using our tool and the baselines.
from the table we can note the following the average completion time for tasks performed using 2kdiff nkdiff is lower than that of the two baselines except for two tasks one uses the cvslog set considering the unit test scenario and the other uses the stringtokenizer log set considering the unit test scenario.
for the first of the two tasks mentioned above the average completion time of participants using k tails is slightly lower but close to that of participants using 2kdiff nkdiff .
vs. .
seconds .
for the second the average completion time of participants using the text differencing tool is slightly lower but close to that of participants using 2kdiff nkdiff .
vs. .
seconds .
note that a participant with the baseline tools might quit the tasks in a short time if they believed that it was very hard 1cliff defines a delta of less than .
between .
to .
between .
and .
and above .
as negligible small medium and large effect size respectively .
56using finite state models for log differencing esec fse november lake buena vista fl usa textk tails2kdiff nkdiff020040060080010001200 textk tails2kdiff nkdiff a user interaction b unit testcompletion time seconds figure box plots of completion time for different tools considering the two scenarios.
table completion time for 2kdiff nkdiff and the baselines.
ui ut ui ut ui ut columba cruisecontrol ctas average completion time seconds text .
.
.
.
.
.
k tails .
.
.
.
.
.
2kdiff nkdiff205.
.
.
.
.
.
cvs stringtokenizer roomcontroller average completion time seconds text .
.
.
.
.
.
k tails .
.
.
.
.
.
2kdiff nkdiff202.
.
.
.
.
.
table p values and cliff s deltas for completion time differences between participants using 2kdiff nkdiff and a baseline considering each scenario.
user interaction unit test p valuetext .
.
k tails .
.
text .
large .
small k tails .
medium .
small for them to find the difference.
this could make the average time for these tasks performed using the baseline tools lower.
this hypothesis is supported by the fact that the average accuracy in completing these two tasks using the two baselines are lower than when 2kdiff nkdiff is used see figure .
participants using text differencing tool spend much less time for unit test tasks than for user interaction tasks.
this is because it is difficult for participants to identify sequence difference among the large number of syntactic differences produced by the text differencing tool when applied to user interaction logs.
this is also reflected by the high variance in the completion time as can be viewed in the corresponding box plot.
the completion times of both k tail and 2kdiff nkdiff are influenced by the model.
to investigate this we run linear regression using the number of transitions as an independent variable and the completion time as the dependent variable.
the coefficient p value and adjusted r squared for k tails and 2kdiff nkdiff are .
.
.
and .
.
resp.
this shows that k tails significantly depends on the model complexity while 2kdiff nkdiff has a weaker statistical dependence with a smaller effect i.e.
coefficient .
figure shows the box plots of completion times for different tools considering each of the two scenarios.
we performedwilcoxon signed rank test with bonferroni correction and find that the differences are all statistically significant at a confidence level of see table .
the effect sizes of the differences on completion time for user interaction scenario are medium and large while the effect sizes for unit test scenario are both small.
2kdiff nkdiff can shorten the time required for participants to identify behavior differences between logs.
the average differences in task completion time between participants using our proposed approach and those using a baseline are statistically significant with small to large effect sizes.
.
.
threats to validity.
several threats may affect the validity of our findings.
first there may be errors in the tools and web interface that we provide to user study participants.
we have tried to reduce possibility of error by performing a thorough check and by conducting a pilot study with a few participants whose results we have excluded from the ones reported above.
second all our user study participants are students it is possible that the findings would be different if professional engineers are used as participants instead.
to mitigate this threat we did not invite undergraduates but rather graduate students with substantial years of programming experiences.
many of our participants have worked in the industry prior to joining the graduate program.
additionally a number are currently still working on industrial projects while completing their master degree.
students are used as participants in many past software engineering studies e.g.
.
moreover a recent work by salman et al.
highlights that there are only minor differences between students and professionals in their user study .
third results of our controlled experiment may differ from a field study.
we choose controlled experiments to allow us to control study variables.
this enables us to investigate the performance of our approach and the baselines when some of these variables are varied.
we can also prevent unwanted variables from affecting the results.
basili has highlighted these and many other benefits of controlled experiments .
many prior software engineering work have also chosen to perform controlled experiments .
.
case study we conducted a case study to examine the potential of 2kdiff and nkdiff on malware analysis in practice.
due to the popularity of android platform a large amount of android malware are produced by attackers.
most android malware are generated by infecting benign apps with malicious code which results in a different behavior from the original benign apps e.g.
accessing privacy or security data.
therefore in this study we want to investigate whether 2kdiff and nkdiff can identify malicious behavior by comparing the api logs of malware with those of the original benign apps.
we use the log dataset from the study of bao et al.
in which they use five automated test case generation tools to generate log traces by running more than pairs of malware and benign apps it infects.
they instrumented the tested apps to record the api calls and the format of each record is caller callee .
the app pairs are from a real life malicious piggybacked android app dataset collected by li et al.
.
the malicious piggybacked apps are built by attackers by unpacking benign apps and then grafting some malicious code to them.
57esec fse november lake buena vista fl usa h. amar l. bao n. busany d. lo s. maoz initial folderlistactivity init sudoklistactivity init telephonymanager getsimserialnumber urlconnection connect telephonymanager getlinenumber url openconnection sudokplayactivity init terminal figure example malicious behavior identified by nkdiff when applied to a pair of logs from a real life piggybacked android app dataset collected by li et al.
.
log was generated from the original benign app.
log was generated from the infected app.
since the generated logs in are very long average of more than a million events we automatically filtered each app log as follows we extract all activity classes that refer to the windows of the app from the apk file of the app we iterate all the records in the log file and only keep the callees that belong to sensitive api calls i.e.
api calls that access sensitive resources and callers that are constructors of the activity classes we use the invocations of constructors of the main activity class to segment the filtered logs because the main activity is the start entry of the app and if several consecutive records are duplicated api calls we only keep one api call.
then we used 2kdiff and nkdiff to generate a model based on the filtered logs of benign and malicious apps.
figure shows an example result.
in this example the logs were generated by running a pair of sudoku game apps using the test case generation tool droidbot .
based on the generated model the malicious behavior can be easily observed i.e.
stealing the phone number of the device then sending it by network.
moreover we can also identify the context of the malicious behavior i.e.
during the initialization of folderlistactivity .
2kdiff and nkdiff can be used to identify malicious behavior for android apps which indicates one of the potential applications of the tool in practice.
related work much literature deals with inferring models from systems execution logs e.g.
.
the works differ in the kinds of input logs and output models.
however almost no work has considered logs comparison.
recently wang et al.
used log comparison specifically comparing sets of inferred temporal invariants as one of several approaches to examine whether tests are representative of field behavior.
unlike our work uses the sets of temporal invariants to compute metrics for the difference between the logs but neither builds the actual model nor shows the concrete differences that were found.
comparing lab and field logs is one potential application of our work which we view as complementary to .
also recently goldstein et al.
published an experience report on log based behavioral differencing focusing on visualizing anomalies.
roughly given two logs they use k tails to build a model for each log and then compare the two models.
the methodinvolves the enumeration of paths from the two models.
their models are enriched with quantitative data which they use as another comparison criteria.
their work is limited to comparing two logs while our nkdiff algorithm compares many logs at once.
unlike our work provides no soundness and completeness guarantees.
other literature has dealt with behavior model comparison but not in the context of logs.
most relevant is which presents semantic differencing between two activity diagrams using selected traces that are possible in one but not the other.
due to complexity considerations is limited to comparing deterministic models.
our work may be viewed as a form of semantic differencing for execution logs.
its complexity is independent of the non determinism in the models we construct.
we compare logs not models.
finally not in the context of logs or differencing classen et al.
presented the featured transition systems fts a variant of transition systems for a software product line designed to describe the combined behavior of an entire system family consisting of many features.
our labeled fsm syntax and semantics are similar to that of fts.
it allows us to concisely describe many logs using a single model.
unlike we build this model from given logs.
conclusion and future work we investigated the use of models for log differencing to present sound and complete concise log comparisons.
in particular we introduced formally defined and implemented two algorithms.
2kdiff takes two logs as input and highlights k difference between the logs by superimposing corresponding traces as paths on the two k tails fsms.
nkdiff extends the classic k tails algorithm it takes a set of nlogs as input and it outputs a single labeled fsm that represents their differences.
we implemented both algorithms validated them and evaluated their performance using logs generated from models from the literature.
we conducted a user study including participants which were given log comparison tasks.
we measured both the correctness and the time required to perform each task using our approach and two alternative tools as baselines.
we have further performed a case study to examine the use of our approach in malware analysis.
the results show that both algorithms scale well and demonstrate the effectiveness of the approach for the task of log comparison.
our work is part of a larger project aiming to build tools that help engineers make better use of execution logs.
in this context we envision the following challenges ahead.
first our present work is limited to identifying k differences.
it may be useful to investigate additional notions of behavior differences that we can infer from the logs e.g.
temporal invariants or other extra functional properties .
second our current approach reports all differences but in many cases some differences may be more important than others.
a quantitative extension that takes frequencies into consideration and applies a statistical approach may help engineers to rigorously distinguish between significant and insignificant differences.
acknowledgment this work is partly supported by the len blavatnik and the blavatnik family foundation blavatnik interdisciplinary cyber research center at tel aviv university and singapore national research foundation s national cybersecurity research development programme award number nrf2016ncr ncr001 .
58using finite state models for log differencing esec fse november lake buena vista fl usa