code2graph automatic generation of static call graphs for python source code gharib gharibi rashmi tripathi and yugyung lee school of computing and engineering university of missouri kansas city kansas city mo usa ggk89 mail.umkc.edu leeyu umkc.edu abstract a static call graph is an imperative prerequisite used in most interprocedural analyses and software comprehension tools.
however there is a lack of software tools that can automatically analyze the python source code and construct its static call graph.
in this paper we introduce a prototype python tool named code2graph which automates the tasks of analyzing the python source code and extracting its structure constructing static call graphs from the source code and generating a similarity matrix of all possible execution paths in the system.
our goal is twofold first assist the developers in understanding the overall structure of the system.
second provide a stepping stone for further research that can utilize the tool in software searching and similarity detection applications.
for example clustering the execution paths into a logical workflow of the system would be applied to automate specific software tasks.
code2graph has been successfully used to generate static call graphs and similarity matrices of the paths for three popular open source deep learning projects tensorflow keras pytorch .
a tool demo is available at ccs concepts so ware and its engineering automated static analysis keywords static code analysis call graph construction python static code analysis call graph construction python acm reference format gharib gharibi rashmi tripathi and yugyung lee.
.
code2graph automatic generation of static call graphs for python source code.
in proceedings of the 33rd acm ieee international conference on automated so ware engineering ase september montpellier france.
acm new york ny usa h ps introduction a call graph is a visual representation of the relationships i.e.
calls among the system s functions .
it is typically visualized as a directed graph where each node represents a function and each edge represents a function call.
the function initiating the call is the caller function and the invoked function is the callee.
a call graph can be dynamic constructed during run time or static constructed during compile time.
a dynamic call graph represents all target functions of a single execution path i.e.
run of the system .
a static call graph represents every possible execution path of the system .
the call graph can support a comprehensive understanding of the system and thus leads to better software related activities such as maintenance and evolution.
in addition the call graph is a prerequisite to build a similarity matrix of all execution paths of the system.
an execution path represents all function calls between an entry point i.e.
function to an exit point in the system.
for example the similarity matrix can be used as an input to a deep learning model that generates similar but more sophisticated applications.
this was the main motive in developing the code2grap tool.
while there are several existing tools that can automatically construct static call graphs for several oop languages the methods and tools that address call graph construction for a python source code are still limited due to the dynamic nature of python.
the existing python based tools that attempt to automatically construct static call graphs either require the user s manual intervention such as inspect or can analyze only one module at a time such as constructcallgraph or one directory at a time such as pyan .
in addition these tools can neither construct all possible execution paths of the system nor their similarities.
note that from hereafter a call graph is referring to the static call graph unless otherwise distinguished.
to this end we introduce a tool named code2graph which can automatically analyze python code and extract its structure i.e.
the hierarchy of the packages modules classes and functions construct and visualize the call graph and generate a list of all possible execution paths of the system and calculate their similarities.
code2graph uses static analysis code traversal techniques to extract the structure of the system using ast to process trees of python s abstract syntax grammar.
then it constructs and visualizes the call graph and builds the similarity matrix of the system s paths as explained in the following sections.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro fit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permi ed.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci fic permission and or a fee.request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
h ps authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france gharib gharibi rashmi tripathi yugyung lee approach overview code2graph is a python stand alone tool that can automatically analyze python source code generate its call graph and construct a similarity matrix of all possible execution paths of the system.
figure illustrates an overview of the tool using an example from the tensorflow case study which is explained in section .
an overview of the approach is explained in the following stages.
.
extracting the code structure our tool uses a static analysis code traversal approach that crawls the codebase and builds a dictionary whose keys are the namespaces of each package module and class and the values are lists of functions and their calls i.e.
caller callee relationships .
in particular the tool retrieves the hierarchical structure of the software s packages modules classes and functions based on the user s specified root directory of the system software .
a package structure contains a list of python modules and contains an additional init .py file to distinguish it from other packages that could contain random python scripts.
a module in python is simply a file that contains python code and it is treated as an object with an arbitrary number of attributes.
the class structure contains information about the class imported libraries and the class attributes and functions.
the output of this stage includes statistics on the program s structure i.e.
the number of packages modules classes and functions and a hierarchical view of the structure visualized using d3.js.
an example of extracting the code structure with its visualization is illustrated in step of figure .
the code structure is used to extract the caller callee relationships as explained in the next subsection.
.
extracting the caller callee relationships using the static analysis output from the previous stage the tool automatically parses the function calls and forms a relationship between each caller function and its targets i.e.
callee functions .
calls to python s built in functions e.g.
print and input libraries e.g.
os and random and test cases e.g.
assertequlas and assertnull are ignored and not included in the graph due to the fact that they neither contribute to the overall structure nor the logical workflow of the project.
however code2graph is capable of parsing the library calls and visualizing them but they are excluded to simplify the call graph visualization.
a 2d matrix is used to represent the caller callee relationships in which the first column represents the caller functions and the second column represents the callee functions.
the user can view the matrix in csv or .xlsx file formats and as shown in figure .
.
.
constructing and visualizing the call graph a call graph is a rooted directed graph g v e in which each node v represents a function v and each edge e v u represents a function call from the function v i.e.
the caller to function u i.e.
the callee .
a function with no incoming calls is considered as an entry point to the program.
a function that does not call any other function is considered as an exit point of the program.
a function that is neither called nor calls any other function is called an orphan function .
orphan functions are visualized in the call graph but are not included in any execution paths of the system.
we use networkx to create and construct the call graph from the caller callee matrix generated in the previous stage.
networkx is a python graph data structure that facilitates the creation and figure .
approach overview with snippet examples from the tensorflow case study.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
code2graph automatic generation of static call graphs... ase september montpellier france manipulation of the graphs.
each node in the network represents a caller callee function linked with a directed edge that shows the direction of the call.
the object of networkx is translated automatically using code2graph into a graph description language written to a file with a dot file extension .
a dot file uses the dot language to describe a graph but does not provide facilities for rendering i.e.
visualizing the graph.
we use graphviz an open source graph visualization software to render the dot files.
graphviz can take a text description of any graph and render it into useful diagrams in several formats.
figure.
.
shows an example of the automatically constructed call graph .
generating the similarity matrix of the execution paths a similarity matrix is an imperative prerequisite for several innovative applications such as clustering the similar execution paths into a logical workflow and generating machine learning models that focus on automating software related activities.
a similarity matrix illustrates the similarity score between each execution path and all other execution paths of the system.
we explain the generation of the similarity matrix as follows.
.
.
path generation.
the first step in this stage is to identify all possible execution paths of the program using the directed graph generated in the previous stage.
a single execution path represents a possible run of the program from an entry point to an exit point.
we used a modified version of the depth first search built in networkx to generate a matrix of all possible execution paths.
each row in the matrix represents a single execution path as shown in figure .
this matrix is also available for the user to view in .csv or .xlsx file formats.
.
.
encoding the execution paths.
in order to simplify the matrix operations we encoded the paths matrix generated in the previous step into a binary system inspired by the one hot encoding also known as dummy variables .
the values of one and zero are used to represent the presence or absence of a particular function from each path respectively.
the order of functions at this stage is not important since we have already generated the call graph and are more interested in generating the similarity matrix.
a representation of the encoded paths is illustrated in table a of figure .
.
.
calculating the similarity matrix.
code2graph uses the jaccard similarity coefficient also known as the jaccard index to identify the similarity between all system paths.
jaccard similarity compares two paths at a time and calculates a similarity coefficient between and or and .
an index of or means that the two paths are identical and an index of or indicates that the two paths do not share any functions.
the similarity matrix of size n n where n is the total number of paths is generated by calculating the jaccard similarity coefficients between each path and all other paths of the program.
the set of paths are treated as an ordered vector p p2 ... p n which is placed as the row and column headers of the matrix as shown in table b of figure the table included five paths only for explanatory purposes .
figure .
an example of generating paths from the code.
case studies in this section we demonstrate the usage of our tool using three popular open source projects written in python including tensorflow keras and pytorch .
the three case studies are platforms that facilitate deep learning computations in python.
following this we demonstrate the results of the first case study tensorflow.
we present a complete list of the results with higher resolution and readable images for all case studies at the tools website .
the code structure analysis showed that the current version of tensorflow includes more than .
million sloc written in python c and other languages.
we cloned the tensorflow repository from github and provided its local directory path to code2graph.
the structure analysis using code2graph showed that tensorflow codebase consists of packages modules classes functions and import statements.
a snippet of the tensorflow structure view is shown in figure which shows the root directory subdirectories modules and the functions inside each module.
figure .
a snippet of tensorflow s structure visualization.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france gharib gharibi rashmi tripathi yugyung lee the total number of extracted paths is unique paths out of them only paths contained five or more nodes i.e.
functions .
the maximum length of a path included nodes.
the paths data are used in the following steps to generate the call graph and later the similarity matrix.
table summarizes the results of the static analyses of the three case studies.
the user can visualize this data in excel or csv file formats.
table .
summary of the case studies analyses results entity tensorflo w kera s pytorc h no.
of packages no.
of classes no.
of functions total no.
of paths maximum path length no.
of paths with more than five nodes analysis time seconds the static code analyses results are used to construct the call graphs of the three projects.
a complete list of the projects call graphs is available on the tool s website .
once the call graph is generated the tool can then construct the similarity matrix and visualize it.
figure depicts the similarity matrix of tensorflow execution paths represented using a heat map.
the x and y axes represent the path.
we used random paths for explanatory purposes.
the scale of the heat map is .
the value of represents no similarity between the two paths and it is represented using the color blue.
the value of represents identical paths and it is represented using the color red.
the similarity matrix is a solid stepping stone for further in search and machine learning applications such as clustering the execution paths and detecting the similarity between two projects.
figure .
an example of the similarity matrix of tensorflow s execution paths visualized using a heat map.
proposed evaluations code2graph was developed to serve in a bigger research project that requires the availability of the system s call graph and a similarity matrix of its execution paths.
however we have examined its potential in generating a high level logical workflow of the system by clustering the similar execution paths.
we are currently starting a user study to look at two hypotheses first code2graph assisting developers in understanding the overall structure of the system.
second code2graph can automatically cluster execution paths based on their similarity in a faster and more accurate way than the existing tools.
conclusions this paper introduced a new tool prototype code2graph which can automatically analyze the python source code extract and visualize its structure and build a similarity matrix of the system s execution paths.
we plan to use the tool in an on going work to automatically generate the logical workflows for new deep learning solutions based on the user s requirements.
more information on the case studies are available on the tool s website .
a video demo is available at