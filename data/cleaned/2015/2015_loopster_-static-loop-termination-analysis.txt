singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems loopster static loop termination analysis loopster static loop termination analysis xiaof ei xie singapor e management univ ersity xfxie smu.edu.sg bihuan chen liang z ou shang w ei lin yang liu see next page for additional authors follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the programming languages and compilers commons and the softwar e engineering commons citation citation xie xiaof ei chen bihuan z ou liang lin shang w ei liu y ang and li xiaohong.
loopster static loop termination analysis.
.
proceedings of the 11th joint meeting on f oundations of softwar e engineering p aderborn germany september .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
author author xiaof ei xie bihuan chen liang z ou shang w ei lin y ang liu and xiaohong li this conf erence pr oceeding ar ticle is a vailable at institutional k nowledge at singapor e management univ ersity https ink.libr ary.smu.edu.sg sis r esear ch loopster static loop termination analysis xiaofei xie tianjin key laboratory of advanced networking tianjinuniversity china xiexiaofei tju.edu.cnbihuan chen nanyang technological university singapore bhchen ntu.edu.sgliang zou nanyang technological university singapore zouliang ntu.edu.sg shang wei lin nanyang technological university singapore shang wei.lin ntu.edu.sgyang liu nanyang technological university singapore yangliu ntu.edu.sgxiaohong li tianjinkey laboratory of advanced networking tianjinuniversity china xiaohongli tju.edu.cn abstract loop termination is an important problem for proving the correctness of a system and ensuring that the system always reacts.existingloopterminationanalysistechniquesmainlydependonthe synthesis of ranking functions which is often expensive.
inthis paper we present a novel approach named loopster which performsanefficientstaticanalysistodecidetheterminationfor loops based on path termination analysis and path dependency reasoning.
loopster adopts a divide and conquer approach weextract individual paths from a target multi path loop and analyze theterminationofeachpath analyzethedependenciesbetween eachtwopaths andthen determinetheoverallterminationof the target loop based on the relations among paths.
we evaluate loopsterbyapplyingitontheloopterminationcompetitionbench markandthreereal worldprojects.theresultsshowthatloopster is effective in a majority of loops with better accuracy and performance improvement compared to the state of the art tools.
ccsconcepts theory of computation program analysis software and its engineering automated static analysis keywords loop termination reachability path dependency automaton acm reference format xiaofeixie bihuanchen liangzou shang weilin yangliu andxiaohongli.
.loopster staticloopterminationanalysis.in proceedingsof 201711thjointmeetingoftheeuropeansoftwareengineeringconferenceand also with nanyang technological university singapore.
shang wei lin and yang liu have equal contribution in this work.
xiaohongliisthecorrespondingauthor schoolofcomputerscienceandtechnology tianjin university.
permissionto make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn ... .
paderborn germany september esec fse pages.
introduction programterminationanalysisisanimportantprogramanalysistask toguaranteethecorrectnessandreliabilityofsystems.nonterminationbugs can causeperformance problems or denial of service attacks .
furthermore termination proving techniques canbeusedtoprovelivenessproperties.loops asthebasicprogram structure are the key challenge in program termination analysis.
programterminationanalysishasreceivedconsiderableattention andalotofadvances have beenmade.thegeneralapproachistosynthesizeterminationarguments which requires solving two problems the search for ranking functionsand thevalidityofthe rankingfunctions.
however terminationprovinghasbeenprovedtobeundecidable anditisnotalwayspossibletofindsuitablerankingfunctions.thus theexisting techniques can only handle certain restricted types of programs.forexample thetechniquesin arecomplete only for linear arithmetic loops.
besides the search for ranking functions can be very expensive especially for complex lexicographic rankingfunctions.
forexample the techniques in maynotterminatewhenprovingtheterminationofsomeprograms.inprinciple enumerationcanprovideacompletemethodbutisnot practical .moreover the validityof rankingfunctions usually depends on a safety checker to search for invariants on demand which is known to be the bottleneck of ranking function based techniques .insteadoffindingnon triviallexicographicrankingfunctions severaltechniques attempttofindsimple terminationargumentsbasedonramsey stheorem.however these techniquesstillhavetomaketrade offsbetweenthetimeoverhead for thesearch and validity of ranking functions.
therefore themainlimitationofrankingfunction basedtechniquesisthesubstantialtimeoverheadforsearchingandvalidating ranking functions.
from our study on loops there are many loopswhoseterminationcanbequicklydeterminedbyanalyzing the termination in each path and the dependencies between the paths.inthispaper weproposeloopster arelativelylightweight static analysis based approach to proving termination and nontermination for such loops which does not depend on ranking 84esec fse september paderborn germany x. xie b. chen l. zou s. lin y. liu and x. li 1int n 2int x 3int z 4while x n if z x x else z a loopq 7a b cd !
q q !
ef b cfg c pdax figure unnested loop from with cfg and pda x functions.
our key idea is to use a divide and conquer approach at the path level to extract paths in a target loop and analyze the termination of each path analyze the dependencies between each pair of paths and determine the overall termination of the targetloop based on the dependencies between paths.
technically to formally analyze multiple paths in a loop we firstextendthepathdependencyautomaton pda x inourprior work tocapturethedependenciesamongthepaths section2.
.
basedonthepda x loopsterperformstheterminationanalysisfor a multi path loop in three steps section .
in the first step it uses exit conditions as the slicing criteria to perform a program slicing on the target loop and obtains the control flow graph cfg of the loop.
in the second step it first extracts paths and analyzes the terminationofeach pathby astatic monotonicityanalysis o r temporal logicproving .analyzingmonotonicityofacertainfunctionineachpathisusuallyeasierthaninferringaranking functioninamulti pathloop.apathcanbe terminating ornonterminating.then itconstructsthepda xofthelooptocapturethepath dependencies.ifthereisanypaththatcannotbedeterminedasterminating or nonterminating in the second step a context sensitive depth firstsearchonthepda xisperformedtorefinethe unknown pathsinthelaststep.duringthetraversal ifonepathmarkedas nonterminating is reachable loopster finds a nonterminating trace.
ifallthepathsalongthetracearemarkedas terminating andthe traversal ends with an accepting state loopster concludes that the traceterminates.ifthereexistsonepaththatismarkedas unknown and cannotbe refined loopster returns unknown.
we implemented loopster and evaluated its effectiveness and performance section4 byapplyingitontheloopsfromthetermination analysis benchmark and three open source projects.
for the loop programs taken from the benchmark loopster can correctlyhandle93 .
oftheprogramswithonly7.76seconds whilethebeststate of the arttooluautomizer inourexperimentscancorrectlyhandle92of themwith2246seconds.forthe total6820loopsfromreal worldprojects loopstercanhandle2655 with91seconds.theresultsshowthatloopsterisscalableand effective andthebiggestadvantageisthatourstaticanalysiscan make a dramatic performance improvement for most loops.
in summary the contributions of our paper are threefold weextendthepathdependencyautomaton pda x toi support nestedloopsandii computetransitionsforthepathswithnoninductionvariables.int x int y int z while y x while y z x z y x y a loop !
!
77a b cd e fg b cfg c pdax figure nested loop from with cfg and pda x basedonthepda x weproposeanefficientstaticanalysistoi prove termination of multi path loops and ii detect nontermination through finding nonterminating state with reachability analysisonthepda x andprove thesoundnessofourapproach.
we implement our approach in loopster and conducted an evaluationtodemonstratetheeffectivenessandscalabilityof loopster on benchmarks and real world projects.
loop modeling in this section we define the scope of this work and extend the path dependency automaton pda x .
.
scope of the work we focus on multi path loops in which the variables are over integers and the operations are standard integer operations addi tion subtraction multiplication and division .
let dbe a finite integer domain and x x1 x2 ... xn be a finite set of variables ranging over d. an atomic predicate over xis of the form f x1 x2 ... xn b wheref dn mapsto dis a function that representsthestandardintegeroperationson x and b d.apredicateisabooleancombinationofatomicpredicates overx.pxis to denote the set of all possible predicates over x. loops containing data structures and function calls are not supported in this work.
however we can perform a program slicing if they donot affectthe termination ofthe loop.the possible extensionsfor some unsupported loops is discussed in section .
.
.
pathdependencyautomaton the loop we considered can be modeled by a control flow graph cfg as formulated in definition .
.
definition .
.
a control flow graph cfg of a loop is a tuple g l e lpre lh le where lis a set of basic blocks each ofwhichcontainsasequenceofassignmentinstructions.
e l px lisasetofdirectededgesconnectingthebasicblocks.
lpre listhepre headerafterwhichtheentryblockoftheloop will execute.
lh lis a set of header blocks.
given two blocks l l prime l we sayldominates l prime ld o ml prime if every path from lpre tol primepasses through l.lh l l l prime p l e ld o ml prime .
le l l l prime l p px l p l prime nelemente is a set of exit blocks.
forsimplicity weuse l1p l2todenoteanedge l1 p l2 e which means that in the basic block l1 if the condition pholds 85loopster static loop termination analysis esec fse september paderborn germany edvhg 7huplqdwlrq qdo vlv frqvwuxfwlrq 7huplqdwlqj 1rqwhuplqdwlqj 8qnqrzq qlwldo 6wdwhv3dwk 7huplqdwlrq qdo vlv qwhu 3dwk qdo vlv rrs 3urjudp6olflqj dqg rqvwuxfwlrq5hilqhphqw 2yhudoo 7huplqdwlrq qdo vlv figure flow diagram of loopster then the loop program goes to the basic block l2.
in this work we considertheweakestpreconditionoperator wpandthestrongest postcondition operator sp based on hoare logic .
definition .
.
given a cfg g l e lpre lh le a path denotedas isasequence l0p0 l1p1 ...pk lk wherel0 lh is the head of denoted by head lk lh le is the tail of denoted by tail i k li nelement lh le .
the weakesttriggeringconditionofpath denotedas iscomputedas wp l0 p0 wp l0 l1 p1 ... wp l0 ... lk pk where the liinwprepresents the instructions in the basic block.
forsimplicity wewilluse pathcondition torepresenttheweakest triggeringconditionofapathinthefollowingsections.forexample the path condition for while y x if x z isy x ratherthan y x .
thepath isfeasibleonlywhen issatisfiable.otherwise itis aninfeasible path.
we use to denote a sequence of assignment instructions in and kto denote the consecutive repetition of path withktimes.
k iskrepetitionof i.e.
... .
for example if isx then 2 isx x .
the precondition of the loop is a predicate pre g which constrains the possible valuations for the variables before executingthe loop g. we assume that the loop precondition is known.
we usepre andpos k to denote the precondition of the path and the postcondition after kexecutions of respectively.
pre andpos k arepredicateswhichconstrainthepossiblevaluations forthevariablesbeforeexecutingthepath andafterexecuting thepath forktimes.givenapathwithitsprecondition pre wecaninferitspostcondition pos k assp k pre which gives the strongest condition after executing kw.r.t.pre .
example .
.
fig.
b gives the cfg of the unnested loop in fig.
a wheretherearesixbasicblocksnamedfrom atofand seven edges.
the basic block ais the pre header from which the program enters the loop.
bis the header block and dis the exit block.
there is one predicate on each edge.
for example bx n c is feasible if the predicate x nholds.trepresents truewhich means the predicate always holds.
there are three paths in the cfg 1 bx n cz x etrue b 2 bx n cz x ftrue b 3 bx n d.forthepath 1 itspathconditionis 1 x n z x. the loop precondition is truesincex n z can be any value before the loop.
suppose pre 1 x then we can infer pos 1 sp x x x andpos 12 sp x x x x .
different from fig.
b there are two header blocks bande i n fig.
b sincetheloopsarenested.infig.
b therearefourpaths 1 by ctrue e 2 ey z ftrue e 3 ey z true b 4 by d.intuitively oneloopexecutioncontainsmultipleiterations which are the interleaving of the feasible paths in the cfg.
to model the dependencies between different paths in a loop we propose the path dependency automaton as formulated in definition .
.
definition2.
.
givenaloopwiththecfg g l e lpre lh le apathdependency automaton pdax i sa s i t f where s is a feasible path in g is a set of states.
i s lpre true head e pre g is satisfiable is a set of initial states.
t prime s s tail head prime nequal prime i logicalandtext.
k isp k primeis satisfiable isasetoftransitions.
f s prime s prime nelementt is a set of accepting states.
intuitively astatein acorrespondstoapathin g.astateisan initialstateifitscorrespondingpathcanbethefirstiterationundertheloopprecondition.thetransition prime trepresentsthat prime can be executed i.e.
primeis satisfiable after some i repetitions of .
a state is an accepting state if it has no successors.
a run of the pdax denoted as is a sequence of states 1 2 ... where 1 iand i i i t. the sequence can be infinite.
thesemanticsof canberepresentedbytheloopexecutionwhich is the interleaving of the paths.
with different loop preconditions ap d axhas different runs.
we use rato represent the set of all runsofaundertheloopprecondition pre g .theconstruction oftwill be described in section .
.
iftail is an exit block then path called exit path will end theloop.hence ifeachrunoftheloopcan endwithanexitpath theloopwillterminate.ifthereisanyrunwhichisinfinite theloop is nonterminating e.g.
while x if x x else x .
or ifarunisfinitebutthelastpathisnotanexitpath theloopenters onestuckstate which has no successors and the loop does not terminate e.g.
while x x .
example .
.
fig.
c shows the pda xof the loop in fig.
a wheres 1 2 3 i 1 2 3 f 3 andt 1 2 2 1 1 3 .
the states 1 2and 3represent the paths in the cfg.
the precondition of the loop is true.
1 2and 3can be initial states as they can be firstly executed under the precon dition.
for example by definition .
we check whether 1can beinitialstatebysolvingthecondition true x n z x.the conditionissatisfiable hence 1canbeaninitialstate.thereisa transitionfrom 1to 2becausethepathcondition 2canbesatisfiable after some execution of 1. the details about computing the transitionin this examplewill be described in example .
.
there are four patterns which represent all possible runs of the pda x 1 3 2 1 3 3 1 2 1 3 4 2 1 3 .
fig.
c is the pda xof the nested loop in fig.
a .
86esec fse september paderborn germany x. xie b. chen l. zou s. lin y. liu and x. li loop termination analysis we propose a static method for loop termination analysis.
the keyideaistoadoptthedivide and conquerstrategy weanalyze the termination of each path in the target loop and determine the overallterminationofthetargetloopbasedonthedependencies among the paths.
fig.
shows the overall flow of our approach.
given a loop as the input our approach determines whether the loop terminates through the following three steps step1.
we use the program slicing technique to remove irrelevant statements from the loop program.
based on the sliced loop we construct its cfg to extract paths in the loop.
the details of slicingare omitted and can be found in .
step .we construct the pda xw.r.t.
the control flow graph generated instep .we firstidentify the initialstates thenperform the termination analysisof each path based on monotonicity analysis or prover see section .
.
at last the dependency analysis among paths see section .
is performed.
step .with the pda xconstructed we perform a reachability analysisonpda xtodeterminetheoverallterminationofthetarget loop c.f.
section .
.
if the information is not sufficient to have aconclusiveresult weperformarefinementsteptoobtainmore informationto determine the overall termination c.f.
section .
.
.
pathtermination analysis a path is nonterminating if it can be executed infinitely before executingotherpaths otherwise itisterminating.todetermine whetheronepathisterminatingornot weadoptasufficientconditionchecking i.e.
wecomputethesufficientconditionsofnontermination and termination for each path respectively.
for a path if the sufficient condition of nontermination is true i.e.
it does notterminateinanycase thenwecanconcludethatitdoesnot terminate.
similarly if the sufficient condition of termination is true then we can conclude thatitterminates.
otherwise we cannot conclude anything from the sufficient conditions.
based on the three cases above we can identify each path as terminating t nonterminating nt orunknown un .
obviously apathisalwaysterminatingifitsheadandtailnodes are different.
thus its sufficient terminating condition is trueand nonterminating condition is false.
in the following we explain how to compute the nonterminating sufficient condition and the terminating sufficient condition for the path whose head node andtailnodearethesamebasicblock.considerapath withpath condition p prime p prime p prime kwherep prime iisapredicateoftheform fi x1 x2 ... xn bifor i k. to simplify the notation we useeito denote the function fi x1 x2 ... xn .
for each predicate p prime i we define its sufficient conditions iand iusing the following monotonicityanalysis for a predicate of the form ei biorei bi its nonterminating sufficient condition ishould make eiincrease monotonically or not change in each iteration the terminating sufficient condition ishouldmake eidecreasemonotonically ineach iteration.
for the predicate of the form ei biandei bi its nonterminating sufficient condition ishould make eidecrease monotonically or not change in each iteration the terminating sufficient condition ishould make eiincrease monotonically.intx while x x a ntintx y while x y x x y y b tintx a while x x x a c un figure path examples for the predicate of the form ei bi its nonterminating sufficient condition ishould make eikeep the same value in each iteration theterminatingsufficientcondition ishouldmake eichange the value in some iterations.
withthesufficient conditionsforeachpredicate pi theoverall sufficientconditionsfor the path are defined as logicalanddisplay.
i k iand logicalordisplay.
i k i if istrue we conclude that does not terminate.
if istrue we conclude that terminates.
otherwise we mark as unknown.
tocompute each iand imentionedabove weneed todeterminethemonotonicityof ei.themonotonicityofonevariablecan beanalyzedbythestatictechniquein whichsupportsthree types basic monotonic statements dependent monotonic statements andcyclicallymonotonicstatements.weextenditintwo aspects checkthemonotonicityforabasicexpressionsuchas addition and subtraction on multiple variables.
for example when xisincreasingand yisdecreasing then x yisincreasing y x is decreasing and x yis unknown.
a backward reasoning to computethe sufficient conditionswhich can makethe variable or expressionincreasemonotonically decreasemonotonicallyorbe constant i.e.
does not change .
for example in the basic monotonic statement x x a the sufficient condition which makes xmonotonic increasing is a monotonic decreasing is a and constant is a .
in the dependent monotonic statements x x y y y a thesufficientcondition whichmakes xstrictly monotonic increasing is y0 a where y0is the initial value for variable ybefore executing the path.
forthosecasesinwhichthemonotonicitycannotbedetected by or the sufficient condition cannot be computed by our extension we leverage temporal logic proving techniques .
we generate one dummy loop which only contains one path and prove the ctl property ag in the loop.
if the result is true it means that the path condition always holds during the execution of i.e.
the path does not terminate.
if the result is false we check the ctl property af .
if the result of the secondpropertyis true itmeansthatthepathcondition will notholdeventually i.e.
thepath terminates.iftheresultsofboth properties are falseor the ctl checking is unable to produce a conclusiveresult wemark thepath asunknownandset both and to be falsesince we cannot compute the nonterminating and terminatingsufficient conditions.
lemma .
if an accepting state fis marked as terminating thentail must be an exit block.
example3.
.
infig.
a thereisaloopconsistingofonlyone path whosepathconditionis x .wethencomputethecondition as the nonterminating sufficient condition which can make x increasing monotonically.
obviously xis always increasing and thus istrue.
hence the path is marked as nt.
in fig.
b we 87loopster static loop termination analysis esec fse september paderborn germany knowxandyareincreasingmonotonically where ycanbechecked bybasic monotonic statements andxcan be checked by dependent monotonicstatements .thus isfalseand istrue.hence the path is marked as t. for the loop in fig.
c our extended strategy can compute the sufficient nonterminating condition a under whichxwillincreasemonotonicallyordoesnotchange andthe sufficientterminatingcondition a underwhich xwilldecrease monotonically.theterminationofthepathdependsontheinput ofa.
thus we mark the path as un.
.
inter pathanalysis afteranalyzingwhethereachpathisterminating weneedtofurther analyze the dependency between each two paths i.e.
whether a path is able to transit to another.
algorithm shows how to constructthetransitionsinapda x.theinputisthecfg goftheloop and we use producttext.
gto represent the set of all feasible paths in g. note that ican only transit to the path jwhose head node is equal to the tail of i i.e.
tail i head j at line .
a variable is an inductionvariable iv whenitischangedbyaconstantvalueor assigned by constant values in each iteration of the path.
a conditione is an iv condition if the expression e regarded as avariable isaniv.ifallvariablesin iareivsandallconditions in iand jare iv conditions we introduce kijto represent the numberofiterationsof ibeforetransitingto j.withthevariable kij wecancalculatetheeffectaftersomeexecutionsof iforall the ivs.
for example if x x in each iteration of i then we can calculate x x kafterkexecutions of i. we compute the value of ivs after kij andkijexecution of i denoted by xkij 1andxkij respectively line .
represents that thevariables xin aresubstitutedwith x prime.atline7 wecompute theweakestprecondition ijfortriggeringthetransition i j .
head i tail i ?kij kij means if the head node and tailnodearethesamenode then icanbeexecutedmorethanone timebefore executing j. otherwise itcan only execute onetime.
if ijissatisfiable then jcanbeexecutedafter kijiterationsof i line and we add the transition to t line .
note that the introduced variable kijcan be bounded in the predicate ij.
if there are some non ivs or non iv conditions we cannot computethetransitionwith kij.weusethetemporal logicproverto check whether the transition is feasible line .
we create one dummy loop lwhich only contains the path iand check the ctl property ef during the loop execution line .
if the property is satisfied imaytransit to jin some cases.
if it is not satisfied there is no transition from ito j. example3.
.
infig.
allvariablesareivsandalltheconditions are iv conditions.
for example x nis an iv condition because x nischangedbyaconstant.wecanusethefirststeptocompute the transition.
to check whether 1can transit to 2 we compute xk12 x x k12 n n z z xk12 x x k12 n n z z 12 x n z x x k12 n z x k12 x k12 n x k12 z k12 hence thereisatransitionfrom 1to 2because 12issatisfiable.k12is bounded by k12 z x k12 x k12 z. let us see how the second step works.
in fig.
b to check whetherthereisatransitionfromthestate 1 1isx y algorithm1 computetran g input g cfg 1let producttext.
gbe the set of all feasible paths in g 2foreach i j m n m producttext.
g n producttext.
g tail m head n m nequaln do 3ifall variables xin iare ivs and all conditions in iand j are iv conditions then letkijrepresent the iteration count of i xkij f x kij computes the value after kij iterations of i xkij f x kij computes the value after kijiterations of i ij i i j head i tail i ?kij kij if ijis satisfiable then t t uniontext.
i j 10else create loop lwhich only contains path i ifef holds for lthen t t uniontext.
i j totheacceptingstate 2 2isx y wecannotusethe firststepasthevaluechangeof xisnotconstant.inthiscase we checkef and it is true.
thus we know 1can transitto 2. .
loop termination analysis with the pda xconstructed we can determine the overall terminationofthetargetloop.theorem1andtheorem2belowgivethe sufficientconditionsonapda xforitscorrespondingtargetloop being terminating or nonterminating respectively.
based on the twotheorems adepth firstsearchcanbeusedtocheckwhetherthe target loop terminates.
if there are some unknown states or cyclesinthepda x wewillperformarefinement section3.
or reduce cycles from the pda x section3.
.
theorem .
if apda xsatisfiesthe two conditionsbelow itscorrespondingloopterminates itisacyclic and2 itsstates reachable from initial states are all marked as terminating.
theorem2.
ifapda xhasareachablestatewhichismarkedas nonterminating its correspondingloop does not terminate.
.
refinement so far our approach is presented in a way such that each path is analyzed independently i.e.
the effects from other paths arenot considered.
for example a path if analyzed alone may be marked asunknown.
however it couldbe actuallyterminating or nonterminatingunderthe precondition pre .
to be more accurate for determining the termination of each path we need to refine the states that are marked as unknownaccording to the execution of the loop.
algorithm gives a dfsbasedalgorithmtorefinethestatesthataremarkedasunknown in an acyclic pda x. given a state and its precondition pre algorithm2refinesthenonterminatingorterminatingsufficient conditionsofthestate andvisitsitssuccessorstatesinadfs style.
isspisabooleanvaluewhichdenoteswhether pre isastrongest postcondition of the previous state.
88esec fse september paderborn germany x. xie b. chen l. zou s. lin y. liu and x. li algorithm2 refinestate a pre issp input a p d ax a state of a pre the precondition of issp boolean value output a refined pda x 1ifpre is satisfiable then 2if is marked as un then ifissp true pre then mark as nt return ifpre then .list.append t 8let be the set of successors of 9foreach prime do 10ifall variables xin are ivs and all conditions in and primeare iv conditions then pre prime sp x f x kij pre prime 12else pre prime prime issp false refinestate a prime pre prime issp givenastate anditsprecondition pre weonlyrefinethe terminationstatusof inthecasewhere isreachableunder its precondition i.e.
pre is satisfiable line and is marked as unknown line .
note that if pre is the strongest postconditionofthetraversedpathand pre issatisfiable then must be reachable.
the refinement is performed for the followingcases if the condition pre holds it means that the nonterminating sufficient condition of is satisfiable under the precondition of .
then we can conclude that does not terminate line .
in this case we can conclude that the overall loop does not terminate by theorem .
.
ifthecondition pre holds theterminatingsufficient conditionof issatisfiableunderthepreconditionof .inthis case weappendt whichrepresentsthatthestate isrefinedas terminatingalongthecurrenttrace tothelist .list line6 .
tocontinuetherefinementoneverysuccessorof wecompute the postcondition after some execution of which is also the precondition of prime.
at line we infer the strongest postcondition pre prime wherepre isfrominputand prime hasbeencomputed at line of algorithm .
x f x kij is a sequence of assignment instructions and is computed at line of algorithm .
if the conjunction of pre prime and primeis satisfiable i.e.
the next traversal atline1 thenthereexistsavariable kijthatmakes primereachable becausepre prime isthestrongestpostconditionofthepreviousstate .otherwise weuseaconservative andsoundcondition i.e.
the pathconditionof prime asthepostconditionof whichalsoservesas thepreconditionof prime line13 .
primeisnotastrongestpostcondition andisspis assigned false line .
algorithm3refinesthewholepda xbyinvokingalgorithm2 for all initial states and returns a set of refined pda xbased on different initial states.
we assume the precondition of the loop is a strongestpostconditionand isspisassigned true.algorithm3aims to check whether a state originally marked as unknown couldalgorithm3 refinepda a pre a input a s i f t ap d ax pre a the precondition of a output a set of refined pda x 1 2foreach ido 3a prime refinestate a pre a true 4foreachstate ina primemarked as un do ifeach element e .listis tthen mark as t a prime be refined as terminating line .
notice that we can do so only when all the markings in the list .listare t which means is terminating in all paths.
note that algorithm assumes that the inputpda xisacyclicsuchthattheterminationofalgorithm2is guaranteed and the cyclic pda xwill be described in section .
.
to sum up given a target loop represented by a pda xa i fw e cannotdirectlydecideitsterminationbytheorem1andtheorem2 wecanapplyalgorithm3on atorefineeachstatethatisoriginally marked as unknown.
let be the set of refined pda xobtained by invoking refinepda a pre a .
we can further analyze the targetloopbasedon bycorollaries3.3and3.
.ifbothofthem do not hold we mark the loop as unknown.
corollary .
.
ifa primesatisfies theorem for all a prime then thetarget loop terminates.
corollary .
.
ifa primesatisfies theorem for some a prime then thetarget loop does not terminate.
notice that the refinement can only be used in acyclic pda x currently.incyclicpda x theexecutioncountofthecyclemightbe unknown.thus algorithm2maynotterminateforcyclicpda x and we leave the refinment of cyclic pda xin the future work.
.
cyclic pda xanalysis theorem1requiresthepda xtobeacyclic.givenacyclic pda x even though all of its states are marked as terminating we cannot conclude that the loop terminates since it may have an infinite execution between the states in the cycle.
for example in the loop while x if x x else x .
all the three paths are marked as terminating however the loop does not terminate since there is an infinite execution in the cycle.
to determine the termination of a cyclic pda x we need further analysis on cycles.
we firstly detect the strongly connected components sccs fromthepda x.noticethatweonlyconsiderthesccwithmore thanonestate i.e.
thecycleinthepda x here.ourmainideaof terminationanalysis on cycles is as follows trytoprovetheterminationbyreducingthecyclic pda xto acyclic pda x c.f.
section .
.
.
try to prove the nontermination by finding one reachable nonterminatingstate in the scc c.f.
section .
.
.
.
.
proving termination.
akeyobservationisthatsomestates willnotbeexecutedaftersomeiterationsofthescc thenthescc can be reduced to a simple structure.
the main idea of proving termination is to reduce the cyclic pda xto an acyclic pda xby 89loopster static loop termination analysis esec fse september paderborn germany finding the pivot states which will not be executed eventually.
for example in the cyclic pda xfig.
c the scc is 1 2 .t od e termine whether the scc can terminate we find the pivot state 1 whichwillnotbeexecutedafter xincreasestobe n.hence thescc is reduced after 1terminates and becomes acyclic.
we formulate the conceptas follows.
inspired by ranking functions we check whether each state can be a pivot state as formulated in definition .
.
definition3.
.
let m sbeastatein a s i f t .thestate mis apivotstate if we can find a function f x suchthat m f x c wherecis a constant value.
f x will be monotonic decreasing after some execution of m. f x is decreasing or not changed in any other state s. intuitively apivotstatecanbeexecutedforafinitenumberof iterations.thus wecanbreakthesccbyremovingthetransitions whichend with a pivot state as formulated in definition .
.
definition .
.
leta s i f t be a pda xwith all states markedasterminating.if ahasanscc denotedby c wesayais safetobe reducedas a m s i f t prime ifwecanfind a pivotstate m c wherethetransition t primeisdefinedas t prime t 1 2 t 2 m 1 c .
lemma .
letabe a cyclicpda xsuch that ahas onescc and allstatesof aaremarkedasterminating.if acanbesafelyreduced by a pivot state manda mis acyclic then aterminates.
noticethatifthereducedpda xisacyclic thenwecanconclude that the loop terminates.
if the reduced pda xis still cyclic we recursively apply lemma if possible on the reduced pda xuntil thereducedpda xisacyclic.otherwise wemarkthetermination of the loop as unknown .
example3.
.
infig.
c wecaninferthat n xismonotonically decreasingin 1 n x andn xdoesnotchangein 2.hence 1isapivotstate anditisterminatingafterremovingthetransition 2 1 .infig.
c from z y 1andzdecreasesin 2 w ecan first find one pivot state 2. after removing 1 2 from the scc itisacyclicpda xandthecycleinthenewpda xis 1 3 .inthe cycle from x y y x we know ywill decrease eventually.
then we find another pivot state 3. finally the pda xbecomes acyclic and we prove it can terminate.
.
.
proving nontermination.
toprovethenonterminationof a cyclic pda x which contains the nonterminating or unknown states weunrollthesccforseveraltimestorefinetheunknown state and check whether any nonterminating state can be reached.
tomakethecheckingefficient weonlytraverseeachcycleonce the number of unrolling can be adjusted .
if we cannot find the reachable nonterminating state after a certain number of iterations of the cycle then we conclude the loop is unknown.
implementation and evaluation we implemented loopster based on llvm .
and the smt solverz3 .theinputisaloopprograminclanguage whichis compiledintollvmir.weusetheslicingtechnique toreduce irrelevant pathsin the constructed control flow graph.thegoalofourevaluationistodemonstrate theeffectiveness andperformanceimprovementofourstaticapproachbycomparing with the state of the art tools on the loops in a benchmark section .
and .
and the effectiveness and scalability of our static approach on the loops in real world projects section .
.
note thatwe use wall time in the experimental results.
.
experimentalresults on loop benchmarks to evaluate the performance of loopster we selected difficult loop programs from the termination crafted benchmark and programs with numeric nested loops from the termination category in competition on software verification sv comp .
thetermination crafted benchmarkconsistsof85non trivialprograms and70ofthemcontainloops.weusedthe70programsin the experiments where programs areknown to be termination and31programsareknowntobenon termination.oneprogram collatz unknown termination.c is known to be unknown and we omitthiscaseforavoidingambiguity.forthe32nestedloops 27of them are terminating and of them are nonterminating.
all these programsaredesignedtobesimplifiedprogramswhichdonotneed slicing.hence slicingdoesnotaffectthefairnessofthecomparison.
we compared loopster against three termination analysis tools.
aprove and uautomizer respectively won the first and second prize for the termination category in sv comp .
t2 is an advancedverificationtool whichhasmuchbetterperformanceand effectivenessthanothertoolsorconfigurations e.g.
armc size change mcnp and kittel as empirically demonstrated in .
thus the selected three tools represent the state of the art.
specifically aprove and uautomizer we used are the provided versions for sv comp and t2 is the version .
we ran allthe tools with the timeout being seconds.
table1reportstheresultsofthesetoolsonthebenchmarks.the second column reports the numbers of terminating t and nonterminating nt loop programs in unnested and nested benchmarks crrepresentsthenumberofprogramsthatcanbecorrectlyanalyzed ctrepresentsthetimeoverheadforthecorrectlyanalyzed programs and ttrepresentsthetimeoverheadforalltheprograms including those that time out .
for loopster ctlrepresents the number of programs which used the temporal logic prover.
from table we can see that loopster can correctly handle .
programs including .
terminating programs and .
nonterminating programs in .
seconds.
for the othertools aprovecan correctlyhandle84 .
programsin .95seconds uautomizercancorrectlyhandle92 .
programs in .
seconds and t2 can correctly handle .
programs in .
seconds.
this indicates that the time overhead of these three tools is very expensive some programs may time out and the performance improvement of loopster over these tools is dramatic.
note that even only considering the time overhead of the correctly analyzed programs ignoring the programsthat time out loopster is still much more efficient it took .36seconds for programs but aprove took .
seconds for programs uautomizertook315.18secondsfor92programs and t2 took .
seconds for programs.
for the monotonicity analysis in loopster .
programs can be handled by our extended static technique and programs 90esec fse september paderborn germany x. xie b. chen l. zou s. lin y. liu and x. li table experimental results on the benchmark programloopster aprove uautomizer t2 crct s tt s ctlcrct s tt s crct s tt s crct s tt s unnestedt .
.
.
.
.
.
.
.
nt .
.
.
.
.
.
.
.
nestedt .
.
.
.
.
.
.
.
nt .
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
table detailed results of comparison program loopster ap.ua.t2 programs mccarthy91 iteration true termination.c cycle no 03 false termination.c cycle telaviv amir minimum true termination.c cycle piecewise true termination.c cycle logag true termination.c mon nontermination2 false termination.c mon division false termination.c mon lexindexvalue pointer false valid deref.c mem n cannotbehandled andthustheproverisusedfortheirpathterminationanalysis.itindicatesthatthemonotonicitycanbesuccessfullydetectedinmostprograms anditisausefulpropertythatcan be used for loop termination analysis.
the average time used with prover and monotonicity are similar .1s in the benchmarks.
further we provide a detailed analysis of how often different analysismethodsinourapproachareneededtoprove non termination forthebenchmark.forthe93handledprograms programs can be proved with theorem and after we construct the pda x. programscontaintheunknownstatesintheconstructed pdax and we first perform refinement analysis and then conclude the result with theorem and .
programs contain cycles intheconstructedpda x andthusweperformthepda xreduction analysis.
the results show that the refinement and cycle reduction are very important and effective to prove loop termination.
in summary loopster can handle more programs correctly with much less time overhead performance improvement even if only considering those correctly analyzed programs which shows the effectiveness and performance improvement of loopsterover the state of the art.
the biggest advantage of loopster owestoourstaticanalysis whileothertoolsneedexpensivetime overhead to infer and validate ranking functions on demand.
.
detailed comparison with state of the art todiscusstheadvantagesanddisadvantagesofloopsteroverthe ranking function based approaches we give the detailed results of the programs that can cannot be handled by loopster but cannot can be handled by aprove uautomizer and t2 in table .
thefirstrowindicatesthat amongthe93programsthatloopster can handled aprove uautomizer and t2 can respectively handle and .
after analyzing the programs that cannot be handle by other tools we summarize our advantages as follows.
using monotonicity .
monotonicity is a common and useful property in the loop iteration.
by using the monotonicity wecanoftenconcludeterminationornonterminationquickly.
for example all the other three tools failed to handle the pro gramhanoi plus false termination.c but loopster proved its nontermination in about .
seconds.
specifically loopster cancomputeanonterminatingsufficientconditionafteranalyzing the monotonicity of x. in this program the monotonicity of x y andzbelong to cyclic monotonicity and loopster computes the nonterminating sufficient condition as x0 y0 z0 .
considering the precondition .
we can handle programs whose terminationdependsonthepreconditionoftheloopwhilethe other tools may fail.
for example all the other three tools failed tohandle gothenburg v2 true termination.c asitsresultdepends on the precondition a b x .
however our refinement analysis refines the termination status of each state by consideringthe precondition.
reducing complexity .
with our divide and conquer strategy i.e.
theterminationanalysisineachpath andthentheoveralltermi nation of the loop we can reduce the complexity when proving the termination of some programs that need complex ranking functions.forexample provingtheterminationof pure3phase truetermination.c needs a phase ranking function and t2 spent seconds and uautomizer timed out.
proving the termination ofaaron3 true termination.c needs a multi dimensional ranking function and uautomizer spent seconds and aprove timed out.
instead loopster correctly handled them in less than one second without computing complex ranking function.
ontheotherhand thereareeightprogramsthatloopsterfailed tohandlecorrectly asshownintable2.thesecondcolumnreportsthefailurereasons including1 thecyclecannotbereduced marked ascycle the monotonicity cannot be detected marked as mon and3 thenonterminationoftheprogramiscausedbyamemory vulnerabilitywhichinterferes themonotonicity markedas memn .
hence the main disadvantages of our approach are as follows.
monotonicitycannotbedetected .insuchcases wecannotcompute the non terminating sufficient condition and thus the refinement may fail.
for example for nontermination2 falsetermination.c we cannot compute the nonterminating sufficient conditionas the monotonicity of x oldxcannotbe detected.
the cycle in a cyclic pda xmay not be reduced .
in such cases we cannot prove the termination or detect the nontermination that is caused by the cycle.
for example all the paths inno 03 false termination.c are terminating but loopster returnsunknownaswecannotfindthepivotstatetoreducethe cyclic pda xfor proving its termination.
in summary loopster and the ranking function based approachesarecomplementarytoeachother.fortheloopsthat aprove uautomizer and t2 cannot handle loopster can be used by them to reduce the complexity and improve the efficiencyforinferringcomplexrankingfunctions.fortheloops wecannothandle wecanextendloopstertoprovideadvanced monotonicityanalysis based on ranking functions.
91loopster static loop termination analysis esec fse september paderborn germany table experimental results on real projects project loops sliced handled time s nt gmp .
libxml .
httpd .
total .
.
experimentalresultson real projects to evaluate the effectiveness and scalability of our static approach we ran loopster on the loops in three open source real world projects including the arithmetic library gmp .
.
the xml c parser and toolkit libxml2 .
.
and the apache http server projecthttpd .
.
.
we extracted the loops in these projects by llvm looppass .
theprecondition of each loopis determined by theinitializationofthevariablesbeforetheloop.iftheinitialvalue dependsonthecomputationbeforetheloop weassumethatitis nondeterministic whichmaycauseinaccurateresultbutdoesnot affect the soundness of our approach.
table shows the results of our analysis on these projects.
the column loopsshows the number of extracted loops in each project.
the column slicedlists the number of loops that can be sliced by our slicing technique.
the columns handledandtime give the number of loops we can handle correctly and the timerequired for the analysis.
the column ntreports the number of nonterminatingloops we identified.
among the total loops loops can be sliced to reduceirrelevantpathsandimprovetheeffectivenessandperformance of our static approach.
for example one program from httpd .
.
contains more than paths.
after slicing the loop becomes for c c c andhas onlyonepath makingiteasy to analyze its termination.
therefore slicing is necessary to termination analysis especially for complex loops in real world projects.
on one hand loops can be correctly handled in .
seconds.
there are nonterminating loops since we set their precondition to be nondeterministic for simplicity and cause an overapproximationtotheirrealprecondition.forexample infig.
the value ofchunk nbitsdepends on the computation before this loop but we set it to be nondeterministic.
thus the loop is terminating whenchunk nbitsisgreaterthan zero andnonterminatingwhen chunk nbitsis less than or equal to zero.
ontheotherhand loopstercannothandle4165 loopsdue to two main reasons the loops contain complex data structures e.g.
arrays heaps and function calls the variables are updated by complex computation e.g.
bitwise calculator which makes the monotonicity calculation difficult.
actually the two challenges are orthogonal to our research and the possible solutions will be discussed in section .
.
inparticular gmpisanarithmeticlibrary whichhasmanyinteger or simple pointer calculation related loops.
thus loopster canhandle77 oftheloops.
libxmlandhttpdcontainmanycomplex data structures e.g.
xml parser in libxmland http protocol handlingin httpd andthuswecanonlyhandle27 oftheloops.
hence except for the challenging loops described above which are orthogonal to our approach and also non trivial to be handled by the state of the art tools a large part of the loops in real world projects can be analyzed by the static approach efficiently.intrbitpos verifier nondet int intchunk nbits verifier nondet int intnbits verifier nondet int while rbitpos chunk nbits nbits rbitpos c hunk nbits figure a simplified loop from gmp wealsoattemptedtocompareloopsterwiththestate of the art tools on the loops from these r eal world projects.
however the state of the arttoolscannotdirectlyworkontheserealloopswithout modification.
therefore we manually modified a set of loop programs based on the loops in these real world projects by the following three steps remove the simple loops that are trivial to checkaswellastheloopsthatarenotsupportedbyloopsterand thestate of the arttools e.g.
loopsthatcontaindatastructuresand function calls that affect the loop termination randomly select loops for each project from the remaining loops and adapt the selected loops by putting the loops in a main function adding initializationforthevariablesintheloopsandsimplifyingcomplexstatements and function dependencies that are not relevant to loop termination to make them executable.
these modified programs canbefoundin asabenchmarkforfutureresearchonloopterminationanalysis.noticethat wecomparedloopsterwithaprove and uautomizer but not t2 because llvm2kittel failed to convert most of the real world loops into t2 s input format.
instead weranthetool2ls verion0.
.
sinceithasbeenempirically demonstrated that 2ls can check larger programs with thousands of lines of code .
here we set the timeout to seconds.
table shows the comparison results on the modified loop programs.thecolumn crliststhenumberofcorrectlyhandledprograms and the column treports the time overhead.
among the total30modifiedloopprograms underthecolumn modified loopster can check all of them correctly in .
seconds while aprove can onlycheck programs in seconds uautomizer can check programs in seconds and 2ls can check programs in seconds.
the results show that the three tools can only handle a small part of the loops but need much time since the loops in real projects contain some complex statements e.g.
array comparisonanddatastructure thatareirrelevanttothetermination.
loopstercanhandlesuchloopswellsinceweperformaprogram slicing to reduce the irrelevant statements.
to ensure a fair comparisonacrossthesetools weslicedtheloopprogramsmanually andalsoran thestate of the arttoolsonthe slicedversion under the column sliced .
with the sliced programs all the three tools cancheckmoreprogramswithmuchlesstime.still loopstercan handlemuchmoreprogramswithmuchlesstimethanothertools.
insummary loopstercanhandlesomeloops inreal world projectsefficiently whichindicatestheeffectivenessandscalabil ityofourtoolonreal worldloops.inaddition thestate of the art tools often have limitations to analyze real world loops and slicing is a useful preprocessing step for termination analysis.
.
discussion on the unsupported loops advancedmonotonicityanalysiscanbedevelopedtosupportthe loops with data structures.
for example by modeling the contents ofheapsorabstractingpointeroperatorsasarithmeticprograms.
slicingcan alsohelp toremovethe structuresthatdo notaffect the 92esec fse september paderborn germany x. xie b. chen l. zou s. lin y. liu and x. li table experimental results on the real world loop programs projectloopsteraprove uautomizer 2ls modified sliced modified sliced modified sliced crt s crt s crt s crt s crt s crt s crt s gmp .
.
.
.
.
.
.
libxml .
.
.
.
.
.
.
httpd .
.
.
.
.
.
.
total .
.
.
.
.
.
.
termination.
in addition we also plan to investigate the possibility to integrate the existing techniques for handling heaps and bitvectors .
for multi thread loop programs we can try totranslate suchprogramsinto sequentialprograms and then apply our approach.
on the other hand if we cannot handle the cycleinapda x the non terminationoftheloopcannotbedecided.
in this case we can perform more specific analysis on the whole effect of the cycle e.g.
unrolling the cycle for some times to get more information or computing ranking functions.
related work inthissection wediscusstherelatedworkonterminationproving and non terminationproving.
.
termination proving existingresearchonterminationprovingmainlyfocusesonthesynthesis of termination arguments.
michael and henny first introduce the automatic synthesis of one dimensional linear rankingfunctionsoverlinearloops.thenpodelskiandrybalchenko propose a complete method to synthesize linear ranking functions.
however it is only used for single path linear loops.
for complex programs multi dimensional and lexicographic ranking functions are needed .
christophe et al.
propose a complete approach to compute multi dimensional ranking functions.
bradley et al.
generalize the method in t o multi path loops and synthesize lexicographic linear ranking functions based on inductive linear invariants.
then this method isextended with template trees .
ben amram and genaim studythecomplexityofthesearchforrankingfunctionsandprove it to be a conp complete problem.
rybalchenko proves program termination and safety by ranking functions interpolants invariants resource bounds and recurrence sets with a series ofillustrating examples.
leike and heizmann introduce some linear ranking templates such as multiphase nested piecewise paralleland lexicographical ranking templates.
in general the main difficulties of termination proving based on rankingfunctionsaretwo fold.first thesearchforefficientrankingfunctionsisnon trivial.lexicographicrankingfunctionsareneeded for complex programs while linear ranking functions can be only usedincertaintypesofloops e.g.
.unfortunately itisdifficultandexpensivetofindlexicographicrankingfunctions .for someprogramssuchasnon terminationloops thesearchmayevennotterminate.second thevalidityoftherankingfunctionsmaybe expensive .
the validity of constraint based ranking functions oftendependsoninvariantsthatmustbestrongenough oran iterative approach .
thus such techniques are often expensive especially for complex multi path loops.
tomitigatethedifficultyinconstraint basedsynthesisforlexicographic ranking functions several techniques a r eproposedbasedonramsey stheorem.thebasicideaistofindaset ofsimplelinearrankingfunctionsratherthanfindingnon trivial lexicographic ranking functions .
however the validity of the terminationargumentis still difficult.
comparedwiththeabovetechniques ourstaticapproachavoids searchingrankingfunctions.hence loopsterismuchfasterthan ranking function based techniques as shown in the evaluation.
the limitation is that loopster fails when monotonicity cannot be detected or some scc cannot be reduced by the static analysis.
besides several advances have been made to support division and modulo arithmetic bitvectors and heaps which are not yet supported in loopster.
.
nontermination proving the approaches based on ranking function usually cannot decting nontermination.severaltechniques havebeen proposed to prove non termination.
gupta et al.
propose to generateallpossiblelassosbyexecutingtheprogramuntilsomecontrol location is re visited then check whether each lasso isfeasible by template based constraint solving.
invel proves non termination by the combination of theorem proving and invariant generation.
trex and t2 check non termination by searching and refining an under approximation of the loop thatcanmaketheloopneverterminate.cppinv provesnonterminationwithamax smt basedinvariantgeneration.atiget al.
propose to detect non termination in multi threaded programsby a systematic translation to sequential programs.
compared with the above techniques loopster reduces the nonterminating proving to the reachability problem.
the disadvantage is that we currently consider the nonterminating path the nonterminatingsccis not considered yet which is our future work.
conclusion in this paper we have proposed a novel approach for loop termination analysis based on path termination analysis and path dependency reasoning.
we implemented the approach in loopster and demonstrated the capability of loopster on a competition benchmark and three real world projects.
the results have demonstratedtheeffectiveness performanceandscalabilityofloopster over the state of the art tools.
in the future we plan to extend loopsterbysupportingrecursiveprogramsandcomplexstructures and handlingmore loops with unsupported scc.