synthesizing tests for detecting atomicity violations malavika samak indian institute of science bangalore malavika csa.iisc.ernet.inmurali krishna ramanathan indian institute of science bangalore muralikrishna csa.iisc.ernet.in abstract using thread safe libraries can help programmers avoid the complexities of multithreading.
however designing libraries that guarantee thread safety can be challenging.
detecting and eliminating atomicity violations when methods in the libraries are invoked concurrently is vital in building reliable client applications that use the libraries.
while there are dynamic analyses to detect atomicity violations these techniques are critically dependent on e ective multithreaded tests.
unfortunately designing such tests is non trivial.
in this paper we design a novel and scalable approach for synthesizing multithreaded tests that help detect atomicity violations.
the input to the approach is the implementation of the library and a sequential seed testsuite that invokes every method in the library with random parameters.
we analyze the execution of the sequential tests generate variable lock dependencies and construct a set of three accesses which when interleaved suitably in a multithreaded execution can cause an atomicity violation.
subsequently we identify pairs of method invocations that correspond to these accesses and invoke them concurrently from distinct threads with appropriateobjects to help expose atomicity violations.
we have incorporated these ideas in our tool named i ntruder and applied it on multiple open source java multithreaded libraries.
i ntruder is able to synthesize multithreaded tests across nine classes in less than two minutes to detect harmful atomicity violations including previously unknown violations in thread safe classes.
we also demonstrate the e ectiveness of i ntruder by comparing the results with other approaches designed for synthesizing multithreaded tests.
categories and subject descriptors d. .
testing and debugging testing tools f. .
semantics of programming languages program analysis keywords atomicity violation dynamic analysis concurrency1.
introduction designing scalable and reliable multithreaded applications is challenging due to the complexities associated with multithreading.
oftentimes developers of such applications avoid the complexities by using thread safe libraries.
these libraries are structured such that concurrent invocation of methods from multiple clients always corresponds to some linearization of the associated invocations .
moreover such libraries limit the use of synchronizations to provide better performance for the client applications.
maintaining thread safety without sacrificing performance can be a demanding task.
therefore even if a library or component is only partially thread safe specifying the context under which thread safety violations occur will enable the users of the library to take corrective action.
atomicity violations are an important class of concurrency defects in multithreaded programs.
many static analyses and dynamic analyses are designed to detect such violations.
one of the many advantages of dynamic analyses over static analyses is that they can be used to reproduce an erroneous execution corresponding to a reported defect.
while various aspects pertaining to dynamic analyses including precision scalability due to the number of interleavings and reproducibility have been investigated rigorously their e ectiveness is critically dependent on the presence of defect revealing multithreaded tests.
designing such tests requires nuanced understanding of the implementation and is therefore not easy.
contege attempts to address this problem by adopting a brute force approach to automatically generate multithreaded tests and detect a violation by analyzing failing executions.
while an important first step the number of possible multithreaded tests is significantly large and the probability of generating a defect revealing multithreaded test can be quite low.
firstly the pairs of methods that need to be invoked concurrently is a function of the number of methods in the class.
secondly appropriate parameters need to be passed to such invocations so as to trigger the violation which can be combinatorial in the number of parameters.
this necessitates the design of a directed approach to e ectively synthesize multithreaded tests for detecting atomicity violations.
in previous work we have designed and implemented directed approaches to synthesize multithreaded tests to enable detection of deadlocks and races .
just as a race detector or a deadlock detector cannot be used to detect atomicity violations the aforementioned synthesizers cannot be deployed for generating tests to enable detection of atomicity violations.
in this paper we present a novel and scalable approach for synthesizing tests to enable detection of atomicity violations in multithreaded libraries.
the implementation of the library and a sequential seed test suite form the input to our approach.
the output is a permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
131set of multithreaded tests such that appropriate methods are invoked concurrently in each test from di erent threads.
the key insight of our technique is the derivation of specialized constraints by analyzing the sequential execution and generation of a multithreaded test that will satisfy the derived constraints when executed.
analyzing the execution of the synthesized test using an atomicity violation detector can help reveal and confirm the underlying bugs.
our approach operates by analyzing the execution of the sequential tests in the seed testsuite.
we maintain a record of the synchronized blocks the objects on which the locks are held the field accesses and their corresponding types read or write within each block.
we construct a set of properties that need to be satisfied in a sequential execution to help identify whether a pair of consecutive field accesses can become potential candidates for atomicity violation.
we analyze the recorded information and identify the potential candidate pairs of consecutive field accesses.
furthermore we identify a remote access for each such candidate pair that could be potentially interleaved between the consecutive accesses in a multithreaded execution.
after identifying the three field accesses that can constitute an atomicity violation we identify the methods that need to be invoked concurrently.
the parameters to the invocations should satisfy a few constraints such that the locks and accesses happen on theappropriate objects for the defect to manifest.
these constraints are derived from the analysis of the sequential execution.
to obtain the concrete objects required for the invocations in the synthesized multithreaded test we execute the relevant sequential tests multiple times suspend their execution and collect the necessary objects after driving them to the required state.
the synthesized tests can be used by any of the atomicity violation dynamic detectors to detect the violations.
we have implemented a tool named i ntruder that incorporates these ideas and evaluated it on a number of open source multithreaded java libraries and components.
our experimental results show that i ntruder is able to generate e ective multithreaded tests that expose many atomicity violations.
we use an atomicity violation detector based on ct rigger to detect atomicity violations by analyzing the synthesized tests.
we analyzed nine classes with our approach that resulted in the synthesis of multithreaded tests leading to the detection of harmful atomicity violations.
the time taken for the entire process is less than two minutes with negligible memory overhead.
we also compare i ntruder with c ontege o men and n arada and show the ability of our approach in enabling detection of atomicity violations.
the paper makes the following technical contributions we develop an approach to synthesize multithreaded tests to enable detection of atomicity violations in library code by using the implementation of the library under consideration and a sequential seed test suite as input.
our approach analyzes sequential execution traces identifies the methods that drive objects to states conducive for triggering an atomicity violation and reuses existing sequential tests to generate the objects for the multithreaded execution.
we provide a detailed discussion of the design and implementation of our approach and validate our approach by analyzing many open source java libraries.
we demonstrate the e ectiveness of our approach in synthesizing e ective tests for detecting atomicity violations compared to the tests synthesized by c ontege o men and n arada .
.
motivation in this section we provide a real example from colt a popular high performance scientific and technical computing library implemented in java to motivate the problem addressed in the paper.
the class dynamicbin1d is documented to be thread safe and hence multiple clients can invoke apis concurrently without holding any additional locks.
dynamicbin1d.java synchronized dynamicbin1d samplebootstrap dynamicbin1d other ... binbinfunction1d function since resamples can be quite large we care about performance and memory int maxcapacity int s1 size int s2 other.size dynamicbin1d sample2 new dynamicbin1d cern.colt.buffer.doublebuffer buffer2 sample2.buffered math.min maxcapacity s2 resampling steps for int i resamples i sample1.clear sample2.clear this.sample s1 true randomgenerator buffer1 other.sample s2 true randomgenerator buffer2 bootbuffer.add function.apply sample1 sample2 synchronized void sample int n boolean withreplacement ... if !withreplacement without ... else with uniform uniform new uniform randomgenerator int s size for int i n i buffer.add this.elements.getquick uniform.nextintfromto s synchronized void clear if this.elements !
null this.elements.clear doublearraylist.java you should only use this method when you are absolutely sure that the index is within bounds.
public double getquick int index return elements figure motivating example.
figure presents partial implementations of two classes from the library.
the implementations of samplebootstrap sample andclear from dynamicbin1d are shown in the figure.
as shown all the three methods are synchronized .
the implementation of getquick from doublearraylist is also shown in the figure where the comment above the implementation emphatically places the burden of using the appropriate index on the caller of the method.
we claim that clients using dynamicbin1d can observe violation of atomicity properties depending upon the invoked methods and the objects on which the methods are invoked.
more specifically executing the multithreaded program shown in figure can 132public void testatomicity dynamicbin1d bin1 new dynamicbin1d ... dynamicbin1d bin2 new dynamicbin1d ... ... thread t1 new thread void run bin1.samplebootstrap bin2 ... thread t2 new thread void run bin2.clear figure multithreaded test to expose atomicity violation.
expose the atomicity violation in dynamicbin1d when the following happens the first thread initiates the execution of bin1.samplebootstrap .
after other.size at line is executed by the first thread bin2.clear is executed from the second thread clearing all the elements in bin2 .
this should invalidate the value of s2 obtained at line .
subsequently when other.sample ... at line is invoked from the first thread the loop in sample at line ideallyshould not execute but is executed for a few iterations depending upon s2 incorrectly.
elements from this.elements at line are obtained using invalid indices as part of the execution of the loop conflicting with the comments given at line in doublearraylist.java .
designing this multithreaded test manually is a non trivial task because it requires a nuanced understanding of dynamicbin1d and the associated classes.
more specifically we need to identify that the methods samplebootstrap andclear need to be invoked concurrently among the methods present in the class.
even though there are at least four parameters to samplebootstrap the necessary constraint that needs to be satisfied is that its first parameter and the receiver of clear need to refer to the same object.
moreover there may be scenarios where the execution does not crash hiding the presence of the error from the user.
for example the distribution of the elements returned from sample can become biased non uniform invalidating the relevant statistical computations.
when we apply none of the tools are able to synthesize this multithreaded test automatically.
this is because is random and the maximum time to generate tests was set as five hours is searching for deadlocks and is searching for races.
public void test dynamicbin1d bin1 new dynamicbin1d ... dynamicbin1d bin2 new dynamicbin1d ... ... bin1.samplebootstrap bin2 ... bin1.clear figure sequential seed test.
using the analysis described in the paper we are able to automatically synthesize the multithreaded test shown in figure .
the implementation of the library along with a sequential seed test shown in figure forms the input to our analysis.
we observe that a sequential seed testsuite that invokes each method in the class under consideration once with random parameters can be used to synthesize defect revealing multithreaded tests.
moreover writing suchsequential seed tests is trivial.
we emphasize that in the sequential test we invoke clear withbin1 instead of bin2 and yet are able to synthesize the required multithreaded test.
we analyze the execution traces of the seed tests to construct the multithreaded test.
the rest of the paper describes our analysis that results in this construction.
.
design instrumentor test generatorvariable lock dependenciesinstrumented library testsdependenciesvariable lock access analyzer atomicity detectorfeasibilty scannerpc r pair synthesizer defects multithreaded testsscannedsequential tests library multithreaded testspc r pairs pc r pairs figure overall architecture the architecture of our tool named i ntruder which generates multi threaded tests to enable detection of atomicity violations is presented in figure .
the entire process of synthesizing the tests is accomplished by integrating multiple components.
the implementation of the library under test and the sequential seed testsuite form the input to the instrumentor which performs the necessary instrumentation to track the lock acquisitions and releases variable accesses method invocations etc.
access analyzer takes as input the instrumented library and the sequential tests executes the tests and monitors the execution to output variable lock dependencies where a dependency specifies the relation between the access and the various locks in the execution.
the accesses are further analyzed by the pc r pair synthesizer to derive a set of pc r pair accesses1.
the underlying intuition is that if these accesses are performed on the same object such that two accesses previous and current happen consecutively when a library method is invoked from one thread and another remote access happens due to a method invocation from a di erent thread such that the remote access interleaves with the other two accesses then an atomicity violation can manifest.
feasibilty scanner analyzes the generated pairs and eliminates the pairs where the remote access cannot interleave due to a variety of factors including being guarded by the same locks.
test generator uses the feasible pc r method pairs and the variable lock dependencies to synthesize the multithreaded tests to expose atomicity violations.
these tests can then be used by a third party detector e.g.
a tomfuzzer ct rigger etc to detect atomicity violations.
for our experiments we use an atomicity violation detector based on ctrigger to expose atomicity violations.
.
preliminaries in this section we provide the necessary background for our approach by describing a few primitives.
to be able to synthesize a test it is necessary to identify the defective accesses the ability of a client to influence accesses and its ability to drive objects to states conducive for a defect to manifest.
for this purpose we 1pc r stands for previous current and remote .
133use the primitives symbol controllable andsetter defined in and briefly describe them here for the sake of completeness.
we provide the explanations on a running example from figure .
we define a variable to be controllable if it