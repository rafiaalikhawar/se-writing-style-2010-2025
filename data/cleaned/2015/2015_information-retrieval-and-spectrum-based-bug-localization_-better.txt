singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems information retrie val and spectrum based bug localization information retrie val and spectrum based bug localization better t ogether better t ogether tien duy b. le singapor e management univ ersity btdle.
phdis.smu.edu.sg richar d j. oen taryo singapor e management univ ersity roentar yo smu.edu.sg david l o singapor e management univ ersity davidlo smu.edu.sg follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the softwar e engineering commons citation citation le tien duy b. oen taryo richar d j. and da vid l o. information retrie val and spectrum based bug localization better t ogether .
.
esec fse pr oceedings of the 10th joint meeting on foundations of softwar e engineering ber gamo italy august september .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
information retrieval and spectrum based bug localization better together tien duy b. le richard j. oentaryo and david lo school of information systems singapore management university btdle.
roentaryo davidlo smu.edu.sg abstract debugging often takes much e ort and resources.
to help developers debug numerous information retrieval ir based and spectrum based bug localization techniques have been proposed.
ir based techniques process textual information in bug reports while spectrum based techniques process program spectra i.e.
a record of which program elements are executed for each test case .
both eventually generate a ranked list of program elements that are likely to contain the bug.
however these techniques only consider one source of information either bug reports or program spectra which is not optimal.
to deal with the limitation of existing techniques in this work we propose a new multi modal technique that considers both bug reports and program spectra to localize bugs.
our approach adaptively creates a bug speci c model to map a particular bug to its possible location and introduces a novel idea of suspicious words that are highly associated to a bug.
we evaluate our approach on real bugs from four software systems and compare it with a state of the art ir based bug localization method a state of the art spectrum based bug localization method and three state of the art multi modal feature location methods that are adapted for bug localization.
experiments show that our approach can outperform the baselines by at least .
.
.
and .
in terms of number of bugs successfully localized when a developer inspects and program elements i.e.
top top and top and mean average precision map respectively.
categories and subject descriptors d. .
testing and debugging keywords bug localization information retrieval program spectra .
introduction developers often receive a high number of bug reports and debugging these reports is a di cult task that consumes much resources .
to help developers debug many research studies have proposed a number of techniques thathelp developers locate buggy program elements from their symptoms.
these symptoms could be in the form of a descriptions of a bug experienced by a user or a failing test case.
these techniques which are often collectively referred to as bug or fault localization would analyze the symptoms of a bug and produce a list of program elements ranked based on their likelihood to contain the bug.
existing bug localization techniques can be divided into two families information retrieval ir based bug localization techniques and spectrum based bug localization techniques .
irbased bug localization techniques typically analyze textual descriptions contained in bug reports and identi er names and comments in source code les.
it then returns a ranked list of program elements typically program les that are the most similar to the bug textual description.
spectrumbased bug localization techniques typically analyze program spectra that corresponds to program elements that are executed by failing and successful execution traces.
it then returns a ranked list of program elements typically program blocks or statements that are executed more often in the failing rather than correct traces.
the above mentioned approaches only consider one kind of symptom or one source of information i.e.
only bug reports or only execution traces.
this is a limiting factor since hints of the location of a bug may be spread in both bug report and execution traces and some hints may only appear in one but not the other.
in this work we plan to address the limitation of existing studies by analyzing both bug reports and execution traces.
we refer to the problem as multimodal bug localization since we need to consider multiple modes of inputs i.e.
bug reports and program spectra .
it ts well to developer debugging activities as illustrated by the following debugging scenarios .
developer dis working on a bug report that is submitted to bugzilla.
one of the rst tasks that he needs to do is to replicate the bug based on the description in the report.
if the bug cannot be replicated he will mark the bug report as worksforme and will not continue further .
he will only proceed to the debugging step after the bug has been successfully replicated.
after dreplicates the bug he has one or a few failing execution traces.
he also has a set of regression tests that he can run to get successful execution traces.
thus after the replication process dhasboththe textual description of the bug and a program spectra that characterizes the bug.
with this dcan proceed to use multi modal bug localization.
this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication esec fse august september bergamo italy c acm.
... .
developer druns a regression test suite and some test cases fail.
based on his experience dhas some idea why the test cases fail.
dcan create a textual document describing the bug.
at the end of this step dhas bothprogram spectra and textual bug description and can proceed to use multi modal bug localization which will leverage not only the program spectra but also d s domain knowledge to locate the bug.
although no multi modal bug localization technique has been proposed in the literature there are a few multi modal feature location techniques.
these techniques process both feature description and program spectra to recommend program elements typically program methods that implement a corresponding feature .
these feature location approaches can be adapted to locate buggy program elements by replacing feature descriptions with bug reports and feature spectra with buggy program spectra.
unfortunately our experiment see section shows that the performance of such adapted approaches are not optimal yet.
our multi modal bug localization approach improves previous multi modal approaches based on two intuitions.
first we note that there are a wide variety of bugs and di erent bugs often require di erent treatments.
thus there is a need for a bug localization technique that is adaptive to di erent types of bugs.
past approaches propose a one size ts all solution.
here we propose an instance speci c solution that considers each bug individually and tunes various parameters based on the characteristic of the bug.
second parnin and orso highlight in their study that some words are useful in localizing bugs and suggest that future research could also investigate ways to automatically suggest or highlight terms that might be related to a failure .
based on their observation we design an approach that can automatically highlight suspicious words and use them to localize bugs.
our proposed approach named a daptive m ulti modal bug l ocalization aml realizes the above mentioned intuitions.
it consists of three components amltext amlspectra and amlsuspword.
amltextonly considers the textual description in bug reports and amlspectra only considers program spectra.
on the other hand amlsuspwordtakes into account suspicious words learned by analyzing textual description and program spectra together.
amlsuspwordcomputes the suspicious scores of words that appear as comments or identi ers of various program elements.
it associates a program element to a set of words and the suspiciousness of a word can then be computed based on the number of times the corresponding program elements appear in failing or correct execution traces.
each of these components would output a score for each program element and aml computes the weighted sum of these scores.
the nal score is adaptively computed for each individual bug by tuning these weights.
we focus on localizing a bug to the method that contains it.
historically most ir based bug localization techniques nd buggy les while most spectrum based bug localization solutions nd buggy lines .
localizing a bug to the le that contains it is useful however a le can be big and developers still need to go through a lot of code to nd the few lines that contain the bug.
localizing a bug to the line that contains it is useful however a bug often spans across multiple lines.
furthermore developers often do not have perfect bug understanding and thusby just looking at a line of code developers often cannot determine whether it is the location of the bug and or understand the bug well enough to x it.
a method is not as big as a le but it often contains su cient context needed to help developers understand a bug.
we have evaluated our solution using a dataset of real bugs from four medium to large software systems aspectj ant lucene and rhino.
we collected real bug reports and real test cases from these systems.
the test cases are run to generate program spectra.
we have compared our approach against state of the art multi modal feature localization techniques i.e.
promesir ditaand ditb a state of the art ir based bug localization technique and a state of the art spectrum based bug localization technique .
we evaluated our approach based on two evaluation metrics number of bugs localized by inspecting the top n program elements top n and mean average precision map .
top n and map are widely used in past bug localization studies e.g.
.
top n is in line with the observation of parnin and orso who highlight that developers care about absolute rank and they often will stop inspecting program elements if they do not get promising results when inspecting the top ranked program elements .
map is a standard information retrieval metric to evaluate the e ectiveness of a ranking technique .
our experiment results highlight that among the bugs aml can successfully localize and bugs when developers only inspect the top top and top methods in the lists that aml produces respectively.
aml can successfully localize .
.
and .
more bugs than the best baseline when developers only inspect the top top and top methods respectively.
in terms of map aml outperforms the best performing baseline by .
.
we summarize our key contributions below .
we are the rst to build an adaptive algorithm for multi modal bug localization.
di erent from past approaches which are one size ts all our approach is instance speci c and considers each individual bug to tune various parameters or weights in aml.
.
we are the rst to compute suspicious words and use these words to help bug localization.
past studies only compute suspiciousness scores of program elements.
.
we develop a probabilistic based iterative optimization procedure to nd the best linear combination of aml components i.e.
amltext amlsuspword and amlspectra that maximizes the posterior probability of bug localization.
the procedure features an e cient and balanced sampling strategy to gracefully handle the skewed distribution of the faulty vs. non faulty methods i.e.
given a bug there are more non faulty methods than faulty ones in a code base .
.
we have evaluated our approach on real bugs from software systems using real bug reports and test cases.
our experiments highlight that our proposed approach improves upon state of the art multi modal bug localization solutions by a substantial margin.
the structure of the remainder of this paper is as follows.
in section we describe preliminary materials about irbased and spectrum based bug localization.
in section we present our proposed approach aml.
in section we describe our experiment methodology and results.
we dis580cuss related work in section .
we conclude and describe future work in section .
.
background in this section we present some background material on ir based and spectrum based bug localization.
ir based bug localization ir based bug localization techniques consider an input bug report i.e.
the text in the summary and description of the bug report see figure as a query and program elements in a code base as documents and employ information retrieval techniques to sort the program elements based on their relevance with the query.
the intuition behind these techniques is that program elements sharing many common words with the input bug report are likely to be relevant to the bug.
by using text retrieval models ir based bug localization computes the similarities between various program elements and the input bug report.
then program elements are sorted in descending order of their textual similarities to the bug report and sent to developers for manual inspection.
all ir based bug localization techniques need to extract textual contents from source code les and preprocess textual contents either from bug reports or source code les .
first comments and identi er names are extracted from source code les.
these can be extracted by employing a simple parser.
in this work we use jdt to recover the comments and identi er names from source code.
next after the textual contents from source code and bug reports are obtained we need to preprocess them.
the purpose of text preprocessing is to standardize words in source code and bug reports.
there are three main steps text normalization stopword removal and stemming .
text normalization breaks an identi er into its constituent words tokens following camel casing convention.
following the work by saha et al.
we also keep the original identi er names.
.
stopword removal removes punctuation marks special symbols number literals and common english stopwords .
it also removes programming keywords such asif for while etc.
as these words appear too frequently to be useful enough to di erentiate between documents.
.
stemming simpli es english words into their root forms.
for example processed processing and processes are all simpli ed to process .
this increases the chance of a query and a document to share some common words.
we use the popular porter stemming algorithm .
there are many ir techniques that have been employed for bug localization.
we highlight a popular ir technique namely vector space model vsm .
in vsm queries and documents are represented as vectors of weights where each weight corresponds to a term.
the value of each weight is usually the term frequency inverse document frequency tf idf of the corresponding word.
term frequency refers to the number of times a word appears in a document.
inverse document frequency refers to the number of documents in a corpus i.e.
a collection of documents that contain the word.
the higher the term frequency and inverse document frequency of a word the more important the word would be.
in this work given a document dand a corpus c webug summary base64converter not properly handling bytes with msb set not masking byte to int conversion description every 3rd byte taken for conversion least signi cant in triplet is not being masked with added to integer if the msb is set this leads to a signed extension which overwrites the previous two bytes with all ones .
.
.
figure bug report of apache ant compute the tf idf weight of a word was follows tf idf w d c log f w d logjcj jdi2c w2dij wheref w d is the number of times word wappears in documentd.
after computing a vector of weights for the query and each document in the corpus we calculate the cosine similarity of the query s vector and the document s vector.
the cosine similarity between query qand document dis given by sim q d p w2 qtd weight w q weight w d rp w2qweight w q rp w2dweight w d wherew2 qtd means word wappears both in the query qand document d. also weight w q refers to the weight of wordwin the query q s vector.
similarly weight w d refers to the weight of word win the document d s vector.
spectrum based bug localization spectrum based bug localization sbbl also known as spectrum based fault localization sbfl takes as input a faulty program and two sets of test cases.
one is a set of failed test cases and the other one is a set of passed test cases.
sbbl then instruments the target program and records program spectra that are collected when the set of failed and passed test cases are run on the instrumented program.
each of the collected program spectrum contains information of program elements that are executed by a test case.
various tools can be used to collect program spectra as a set of test cases are run.
in this work we use cobertura .
table raw statistics for program element e e isexecuted e isnot executed unsuccessful test nf e nf e successful test ns e ns e based on these spectra sbbl typically computes some raw statistics for every program elements.
tables and summarize some raw statistics that can be computed for a program element e. these statistics are the counts of unsuccessful i.e.
failed and successful i.e.
passed test cases that execute or do not execute e. if a successful test case executes program element e then we increase ns e by one unit.
similarly if an unsuccessful test case executes program elemente then we increase nf e by one unit.
sbbl uses these statistics to calculate the suspiciousness scores of each program element.
the higher the suspiciousness score the 581table raw statistic description notation description nf e number of unsuccessful test cases that execute program element e nf e number of unsuccessful test cases that do not execute program element e ns e number of successful test cases that execute program element e ns e number of successful test cases that do not execute program element e nf total number of unsuccessful test cases ns total number of successful test cases more likely the corresponding program element is the faulty element.
after the suspiciousness scores of all program elements are computed program elements are then sorted in descending order of their suspiciousness scores and sent to developers for manual inspection.
there are a number of sbbl techniques which propose various formulas to calculate suspiciousness scores.
among these techniques tarantula is a popular one .
using the notation in table the following is the formula that tarantula uses to compute the suspiciousness score of program elemente tarantula e nf e nf nf e nf ns e ns the main idea of tarantula is that program elements that are executed by failed test cases are more likely to be faulty than the ones that are not executed by failed test cases.
thus tarantula assigns a non zero score to program element ethat hasnf e .
.
proposed approach the overall framework of our a daptive m ulti modal bug localization aml is shown in figure .
aml enclosed in dashed box takes as input a new bug report and the program spectra corresponding to it.
aml also takes as input a training set of historical bugs that have been localized before.
for each bug in the training set we have its bug report program spectra and set of faulty methods.
if a method contains a root cause of the bug it is labeled as faulty otherwise it is labeled as non faulty .
based on the training set of previously localized bugs and a method corpus aml produces a list of methods ranked based on their likelihood to be the faulty ones given the new bug report.
aml has four components amltext amlspectra amlsuspword and integrator.
amltextprocesses only the textual information in the input bug reports using an irbased bug localization technique described in section .
amltextin the end outputs a score for each method in the corpus.
given a bug report band a method min a corpus c amltextoutputs a score that indicates how close is mtob which is denoted as amltext b m c .
by default amltext uses vsm as the ir based bug localization technique.
amlspectraprocesses only the program spectra information using a spectrum based bug localization technique described in section .
amlspectrain the end outputs a score for each method in the corpus.
given a program spectra p and a method min a corpus c amlspectraoutputs a score aml text input bug report input program spectra training data aml spectra aml suspword integrator method corpus data ranked list of methods figure proposed approach aml that indicates how suspicious is mconsidering pwhich is denoted as amlspectra p m c .
by default amlspectrauses tarantula as the spectrum based bug localization technique.
amlsuspwordprocesses both bug reports and program spectra and computes the suspiciousness scores of words to rank methods.
given a bug report b a program spectra p and a method min a corpus c amlsuspwordoutputs a score that indicates how suspicious is mconsidering band p this is denoted as amlsuspword b p m c .
the integrator component combines the amltext amlspectra amlsuspwordcomponents to produce the nal ranked list of methods.
given a bug report b a program spectrap and a method min a corpus c the adaptive integrator component outputs a suspiciousness score for method mwhich is denoted as aml b p m c .
the amltextand amlspectracomponents reuse techniques proposed in prior works which are described in section .
in the next subsections we just describe the new components namely amlsuspwordand the adaptive integrator component.
.
suspicious word component parnin and orso highlighted that future research could also investigate ways to automatically suggest or highlight terms that might be related to a failure however they did not propose a concrete solution.
we use parnin and orso s observation which highlights that some words are indicative to the location of a bug as a starting point to design our amlsuspwordcomponent.
this component breaks down a method into its constituent words computes the suspiciousness scores of these words and composes these scores back to result in the suspiciousness score of the method.
the process is analogous to a machine learning or classication algorithm that breaks a data point into its constituent features assign weights or importance to these features and use these features especially important ones to assign likelihood scores to the data point.
the component works in three steps mapping of methods to words computing word suspiciousness and composing word suspiciousness into method suspiciousness.
we describe each of these steps in the following paragraphs.
step mapping of methods to words.
in this step we map a method to its constituent words.
for every method we extract the following textual contents including the name of the method along with the names of its parameters and identi ers contained in 582the method body the name of the class containing the method and the package containing the class the comments that are associated to the method e.g.
the javadoc comment of that method and the comments that appear inside the method and comments that appear in the class containing the method that are not associated to any particular method.
after we have extracted the above textual contents we apply the text pre processing step described in section .
at the end of this step for every method we map it to a set of pre processed words.
given a method m we denote the set of words it contains as words m .
step computing word suspiciousness.
we compute the suspiciousness score of a word by considering the program elements that contain the word.
let us denote the set of all failing execution traces in spectra pas p fand the set of all successful execution traces as p s. to compute the suspiciousness scores of a word wgiven spectra p we de ne several sets ef w p ft2p fj9m2t s t w2words m g es w p ft2p sj9m2t s t w2words m g the setef w p is the set of execution traces in p fthat contain a method in which the word wappears.
the set es w p is the set of execution traces in p sthat contain a method in which the word wappears.
based on these sets we can compute the suspiciousness score of a word wusing a formula similar to tarantula as follows ssword w p jef w p j jp failj jef w p j jp failj jes w p j jp successj using the above formula words that appear more often in methods that are executed in failing execution traces are deemed to be more suspicious than those that appear less often in such methods.
step computing method suspiciousness.
to compute a method m s suspiciousness score we compute the textual similarity between mand the input bug reportb and consider the appearances of min the input program spectra p. in the textual similarity computation the suspiciousness of words are used to determine their weights.
first we create a vector of weights that represents a bug report and another vector of weights that represents a method.
each element in a vector corresponds to a word that appears in either the bug report or the method.
the weight of a word win document i.e.
bug report or method dof method corpus cconsidering program spectra pis sstfidf w p d c ss word w p log f w d logjcj jdi2c w2dij in the above formula ss word w p is the suspiciousness score of wordwcomputed by equation f w d is the number of times word wappears in document d anddi2c means document diis in the set of document c. similarly w2dimeans word wbelongs to document di.
the above formula considers the weight of a word based on its suspiciousness and well known information retrieval metrics term frequency i.e.
log f w d and inverse document frequency i.e.
logjcj jdi2c w2dij .
after the two vectors of weights of method mand bug reportbare computed we compute the suspiciousness score of the method mby computing the cosine similarity of these two vectors multiplied by a weighting factor.
the formula to compute this score is as follows amlsuspword b p m c ss method m p p w2b msstfidf w p b c sstfidf w p m c rp w2bsstfidf w p b c rp w2msstfidf w p m c here we use ss method m p that computes the suspiciousness score of method mconsidering program spectra p as the weighting factor.
this can be computed by various spectrum based bug localization tools.
by default we use the same fault localization tool as the one used in amlspectracomponent.
with this amlsuspwordintegrates both macro view of method suspiciousness which considers direct execution of a method in the failing and correct execution traces and micro view of method suspiciousness which considers the executions of its constituent words in the execution traces .
.
integrator component the integrator component serves to combine the scores produced by the three components amltext amlspectra and amlsuspwordby taking a weighted sum of the scores.
the nal suspiciousness score of method mgiven bug report band program spectra pin a corpus cis given by f xi amltext b m amlspectra p m amlsuspword b p m whereirefers to a speci c b p m combination aka data instance xidenotes the feature vector xi and is the parameter vector where are arbitrary real numbers.
note that we exclude mentioning corpuscin both sides of equation to simplify the set of notations used in this section.
the weight parameters are tuned adaptively for a new bug report bbased on a set of top k historical xed bugs in a training data that are the most similar to b. we nd these top k nearest neighbors by measuring the textual similarity ofbwith training historical bug reports using the vsm model.
in this work we propose a probabilistic learning approach which analyzes this training data to ne tune the weight parameters and for the new bug report b. probabilistic formulation.
from a machine learning standpoint bug localization can be interpreted as a binary classi cation task.
for a given combination b p m the positive label refers to the case when method mis indeed where the bug bis located i.e.
faulty case and the negative label is when mis not relevant tob i.e.
non faulty case .
as we deal with binary classication task it is plausible to assume that a data instance follows bernoulli distribution c.f.
p xi yij f xi yi f xi yi 583whereyi yi denotes the positive negative label and x exp x is the logistic function.
using this notation we can formulate the overall data likelihood as p x yj ny i f xi yi f xi yi wherenis the total number of data instances i.e.
b p m combinations and y is the label vector.
our primary interest here is to infer the posterior probabilityp jx which can be computed via the bayes rule p jx y p x yj p p x y speci cally our goal is to nd an optimal parameter vector that maximizes the posterior p jx y .
this leads to the following optimization task arg max p jx y arg max p x yj p arg min log p x yj log p here we can drop the denominator p x y since it is independent of the parameters .
the term p refers to the prior which we de ne to be a gaussian distribution with identical zero mean and inverse variance p jy j 1r exp j where the number of parameters jis in our case i.e.
and .
by substituting and into and by droppping the constant terms that are independent of the optimal parameters can be computed as arg min nx i 1li 2jx j j!
whereliis called the instance wise loss as given by li solution to this minimization task is known as the regularized logistic regression .
the regularization term 2pj j j which stems from the prior p serves to penalize large parameter values thereby reducing the risk of data over tting.
algorithm.
to estimate we develop an iterative parameter tuning strategy that performs a descent move along the negative gradient ofli.
algorithm summarizes our proposed parameter tuning method.
more speci cally for each instance i we perform gradient descent update for each parameter j j j li j j where the gradient term li jresolves to li j f xi yi xi j algorithm iterative parameter tuning require matrixx2rn each row is a vector xi for bug report b program spectra p and method m in one of the top k most similar training data label vectory2rn each element yiis the label of xi learning rate regularization parameter maximum training iterations tmax ensure weight parameters initialize to zero repeat foreachn2f1 ngdo ifnmod then.draw a positive instance randomly pick ifromf1 ngs.t.yi else .draw a negative instance randomly pick ifromf1 ngs.t.yi end if compute overall score f xi using eq.
compute gradient gi f xi yi gi amltext b m gi amlspectra p m gi amlsuspword b p m end for untiltmaxiterations with the feature values xi amltext b m xi amlspectra p m andxi amlsuspword b p m corresponding to the parameters and respectively.
the update steps are realized in lines of algorithm .
one key challenge in the current bug localization task is the extremely skewed distribution of the labels i.e.
the number of positive cases is much smaller than the number of negative cases.
to address this we devise a balanced random sampling procedure when picking a data instance for gradient descent update.
in particular for every update step we alternatingly select a random instance from the positive and negative instance pools as per lines of algorithm .
using this simple method we can balance the training from positive and negative instances thus e ectively mitigating the issue of skewed distribution in the localization task.
it is also worth noting that our iterative tuning procedure is e cient.
that is its time complexity is linear with respect to the number of instances nand maximum iterationstmax.
.
experiments .
dataset we use a dataset of bugs from popular software projects to evaluate our approach against the baselines.
these projects are aspectj ant lucene and rhino .
all four projects are medium large scale and implemented in java.
aspectj ant and lucene contain more than kloc while rhino contains almost kloc.
table describes detailed information of the four projects in our study.
the aspectj bugs are from the ibugs dataset which were collected by dallmeier and zimmermann .
each bug in the ibugs dataset comes with the code before the x pre x version the code after the x post x version and a set of test cases.
the ibugs dataset contains more 584table dataset description project bugs time periodaverage methods aspectj .
ant .
lucene .
rhino .
than aspectj bugs but not all of them come with failing test cases.
test cases provided in the ibugs dataset are obtained from the various versions of the regression test suite that comes with aspectj.
the remaining bugs from ant lucene and rhino are collected by ourselves following the procedure used by dallmeier and zimmermann .
for each bug we collected the pre x version post x version a set of successful test cases and at least one failing test case.
a failing test case is often included as an attachment to a bug report or committed along with the x in the post x version.
when a developer receives a bug report he she rst needs to replicate the error described in the report .
in this process he is creating a failing test case.
unfortunately not all test cases are documented and saved in the version control systems.
.
evaluation metric and settings we use two metrics namely mean average precision map and top n to evaluate the e ectiveness of a bug localization solution.
they are de ned as follows top n given a bug if one of its faulty methods is in the top n results we consider the bug is successfully localized.
top n score of a bug localization tool is the number of bugs that the tool can successfully localize .
mean average precision map map is an ir metric to evaluate ranking approaches .
map is computed by taking the mean of the average precision scores across all bugs.
the average precision of a single bug is computed as ap mx k 1p k pos k number of buggy methods wherekis a rank in the returned ranked methods m is the number of ranked methods and pos k indicates whether the kthmethod is faulty or not.
p k is the precision at a given top kmethods and is computed as follows p k faulty methods in the top k k note that typical map scores of existing bug localization techniques are low .
we use fold cross validation for each project we divide the bugs into ten sets and use as training data and as testing data.
we repeat the process times using di erent training and testing data combinations.
we then aggregate the results to get the nal top n and map scores.
the learning rate and regularization parameter of aml are chosen by performing another cross validation on the training data while the maximum number of iterations tmaxis xed as .
we use k as default value for the number of nearest neighbors.
we conduct experiments on an intel r xeon e5 .9ghz server running linux .
.we compare our approach against state of the art multimodal feature localization techniques i.e.
promesir ditaand ditb a state of the art ir based bug localization technique named lr and a state of the art spectrum based bug localization technique named multric .
we use the same parameters and settings that are described in their papers with the following exceptions that we justify.
for ditaand ditb the threshold used to lter methods using hits was decided such that at least one gold set method remained in the results for of the .
in this paper since we use ten fold cross validation rather than using of all bugs we use all bugs in the training data i.e.
of all bugs to tune the threshold.
for promesir we also use fold cv and apply a brute force approach to tune promesir s component weights using a step of .
.
promesir dita ditb and multric locate buggy methods however lr locate buggy les.
thus we convert the list of les that lr produces into a list of methods by using two heuristics return methods in a le in the same order that they appear in the le return methods based on their similarity to the input bug report as computed using a vsm model.
we refer to the two variants of lr as lraand lrbrespectively.
.
research questions research question how e ective is aml as compared to state of the art techniques?
promesir sitir and several algorithm variants proposed by dit et al.
are state of theart multi modal feature location techniques.
among the variants proposed by dit et al.
the best performing ones are irlsidynbinwmhits h bin bottomand irlsidynbinwmhits h freq bottom.
we refer to them as ditaand ditbin this paper.
dit et al.
have shown that these two variants outperform sitir.
however dit et al.
s variants have never been compared with promesir.
promesir has also never been compared with sitir.
thus to answer this research question we compare the performance of our approach with promesir ditaand ditb.
we also compare with the two variants of lr lraand lrb and multric which are recently proposed state of the art ir based and spectrum based bug localization techniques respectively.
research question are all components of aml contributing toward its overall performance?
to answer this research question we simply drop one component i.e.
amltext amlsuspword and amlspectra from aml one at a time and evaluate their performance.
in the process we create three variants of aml aml text aml suspword and aml spectra.
to create aml text aml suspword and aml spectra we exclude amltext amlsuspword and amlspectracomponents from equation of our proposed aml respectively.
we use the default value ofk and apply algorithm to tune weights of these variants and compare their performance with our proposed aml.
research question how e ective is our integrator component ?
rather than using the integrator component it is possible to use a standard machine learning algorithm e.g.
learning585to rank to combine the scores produced by amltext amlsuspword and amlspectra.
indeed the two state ofthe art ir based and spectrum based bug localization techniques i.e.
lr and multric are based on learning torank.
in this research question we want to compare our integrator component with an o the shelf learning to rank tool namely svmrank which was also used by lr .
we simply replace the integrator component with svmrank and evaluate the e ectiveness of the resulting solution.
research question how e cient is aml?
if aml takes hours to produce a ranked list of methods for a given bug report then it would be less useful.
in this research question we investigate the average running time needed for aml to output a ranked list of methods for a given bug report.
research question what is the e ect of varying the number of neighbors kon the performance of aml?
our proposed approach takes as input one parameter which is the number of neighbors k that is used to adaptively tune the weights and for a bug.
by default we set the number of neighbors to .
the e ect of varying this default value is unclear.
to answer this research question we vary the value of kand we investigate the e ect of di erent numbers of neighbors on the performance of aml.
in particular we want to investigate if the performance of aml remains relatively stable for a wide range of k. .
results table top n aml vs. baselines.
n2f1 10g.
p promesir d dit l lr and m multric.
top project aml pdadblalbm 1aspectj ant lucene rhino overall 5aspectj ant lucene rhino overall 10aspectj ant lucene rhino overall table mean average precision aml vs. baselines.
p promesir d dit l lr and m multric.
project aml p dadblalbm aspectj .
.
.
.
.
.
.
ant .
.
.
.
.
.
.
lucene .
.
.
.
.
.
.
rhino .
.
.
.
.
.
.
overall .
.
.
.
.
.
.
.
.
rq1 aml vs. baselines table shows the performance of aml and all the baselines in terms of top n. out of the bugs aml can successfully localize and bugs when developers inspect the top top and top methods respectively.
this means that aml can successfully localize .
.
and .
more bugs than the best baseline i.e.
promesir by investigating the top top and top methods respectively.
table shows the performance of aml and the baselines in terms of map.
aml achieves map scores of .
.
.
and .
for aspectj ant lucene and rhino datasets respectively.
averaging across the four projects aml achieves an overall map score of .
which outperforms all the baselines.
aml improves the average map scores of promesir dita ditb lra lrb and multric by .
.
.
.
.
and .
respectively.
moreover considering each individual project in terms of map aml is still the best performing multi modal bug localization approach.
aml outperforms the map score of the best performing baseline by .
.
.
and .
for aspectj ant lucene and rhino datasets respectively.
moreover we nd that our novel component of aml i.e.
amlsuspword can outperform all the baselines.
amlsuspwordcan achieve a top top top and map scores of and .
.
these results outperform the best performing baseline by .
.
.
and .
respectively.
.
.
rq2 contributions of aml components table shows the performance of the three aml variants and the full aml.
from the table the full aml has the best performance in term of top top top and map.
this shows that omitting one of the aml components reduces the e ectiveness of aml.
thus each of the component contributes towards the overall performance of aml .
also among the variants aml suspwordhas the smallest top top top and map scores.
the reduction in the evaluation metric scores are the largest when we omit amlsuspword.
this indicates that amlsuspwordis more important than the other components of aml .
table contributions of aml components approach top top top map aml text28 .
aml suspword28 .
aml spectra26 .
aml .
.
.
rq3 integrator vs. svmrank table shows the results of comparing our integrator with svmrank.
we can note that for most subject programs and metrics integrator outperforms svmrank.
this shows the bene t of our integrator component which builds a personalized model for each bug and considers the data imbalance phenomenon.
.
.
rq4 running time table shows means and standard deviations of aml s running time for di erent projects.
from the table we note that aml has an average running time of .
seconds.
among the four projects aml can process rhino 586table integrator vs. svmrank.
metrics project integrator svmrank top 1aspectj ant lucene rhino overall top 5aspectj ant lucene rhino overall top 10aspectj ant lucene rhino overall mapaspectj .
.
ant .
.
lucene .
.
rhino .
.
overall .
.
bugs with the least average running time i.e.
.
seconds and aml needs the longest running time to process aspectj bugs i.e.
.
seconds .
compared to the other three projects aspectj is considerably larger.
therefore it takes more time for aml to tune its component weights.
considering that a developer can spend hours and even days to x a bug aml running time of seconds is reasonable.
table running time of aml seconds project mean standard deviation aspectj .
.
ant .
.
lucene .
.
rhino .
.
overall .
.
.
.
rq5 effect of varying number of neighbors to answer this research question we vary the number of neighborskfrom to all bugs in the training data i.e.
k .
the results with varying numbers of neighbors is shown in table .
we can see that as we increase k the performance of aml increases until a certain point.
when we use a largek the performance of aml decreases.
this suggests that in general including more neighbors can improve performance.
however an overly large number of neighbors may lead to an increased level of noise i.e.
the number of non representative neighbors resulting in a degraded performance.
the di erences in the top n and map scores are small though.
.
discussion number of failed test cases and its impact in our experiments with bugs most of the bugs come with few failed test cases average .
.
we investigate whether the number of failed test cases impacts the e ectiveness of our approach.
we compute the di erences between the aver table e ect of varying number of neighbors k neighbors top top top map k .
k .
k .
k .
k .
k .
age number of failed test cases for bugs that are successfully localized at top n positions n and bugs that are not successfully localized.
we nd that the di erences are small .
to .
test cases .
these indicate that the number of test cases do not impact the e ectiveness of our approach much and typically to failed test cases are sufcient for our approach to be e ective.
threats to validity threats to internal validity relate to implementation and dataset errors.
we have checked our implementations and datasets.
however still there could be errors that we do not notice.
threats to external validity relate to the generalizability of our ndings.
in this work we have analyzed real bugs from medium large software systems.
in the future we plan to reduce the threats to external validity by investigating more real bugs from additional software systems written in various programming languages.
threats to construct validity relate to the suitability of our evaluation metrics and experimental settings.
both top n and map have been used to evaluate many past bug localization studies .
map is also well known in the information retrieval community .
we perform cross validation to evaluate the e ectiveness of approach on various training and test data.
cross validation is a standard setting used to evaluate many past studies .
unfortunately cross validation ignores temporal ordering among bug reports.
if bugs reported at di erent dates do not exhibit substantially di erent characteristics in terms of their program spectra and descriptions then this threat is minimal.
.
related work multi modal feature location multi modal feature location takes as input a feature description and a program spectra and nds program elements that implement the corresponding feature.
there are several multi modal feature location techniques proposed in the literature .
poshyvanyk et al.
proposed an approach named promesir that computes weighted sums of scores returned by an ir based feature location solution lsi and a spectrumbased solution tarantula and rank program elements based on their corresponding weighted sums .
then liu et al.
proposed an approach named sitir which lters program elements returned by an ir based feature location solution lsi if they are not executed in a failing execution trace .
later dit et al.
used hits a popular algorithm that ranks the importance of nodes in a graph to lter program elements returned by sitir .
several variants are described in their paper and the best performing ones are irlsidynbinwmhits h bin bottomand irlsidynbinwmhits h freq bottom.
we refer to these two as ditaand ditb respectively.
they have showed 587that these variants outperform sitir though they have never been compared with promesir.
in this work we compare our proposed approach against promesir ditaand ditb.
we show that our approach outperforms all of them on all datasets.
ir based bug localization various ir based bug localization approaches that employ information retrieval techniques to calculate the similarity between a bug report and a program element e.g.
a method or a source code le have been proposed .
lukins et al.
used a topic modeling algorithm named latent dirichlet allocation lda for bug localization .
then rao and kak evaluated the utility of many standard ir techniques for bug localization including vsm and smoothed unigram model sum .
in the ir community historically vsm is proposed very early four decades ago by salton et al.
followed by many other ir techniques including sum and lda which address the limitations of vsm.
more recently a number of approaches which considers information aside from text in bug reports to better locate bugs were proposed.
sisman and kak proposed a version history aware bug localization technique which considers past buggy les to predict the likelihood of a le to be buggy and uses this likelihood along with vsm to localize bugs .
around the same time zhou et al.
proposed an approach named buglocator that includes a specialized vsm named rvsm and considers the similarities among bug reports to localize bugs .
next saha et al.
proposed an approach that takes into account the structure of source code les and bug reports and employs structured retrieval for bug localization and it performs better than buglocator .
subsequently wang and lo proposed an approach that integrates the approaches by sisman and kak zhou et al.
and saha et al.
for more e ective bug localization .
most recently ye et al.
proposed an approach named lr that combines multiple ranking features using learning to rank to localize bugs and these features include surface lexical similarity api enriched lexical similarity collaborative ltering class name similarity bug x recency and bug x frequency .
all these approaches can be used as the amltextcomponent of our approach.
in this work we experiment with a basic ir technique namely vsm.
our goal is to show that even with the most basic ir based bug localization component we can outperform existing approaches including the state of the art ir based approach by ye et al.
.
spectrum based bug localization various spectrumbased bug localization approaches have been proposed in the literature .
these approaches analyze a program spectra which is a record of program elements that are executed in failed and successful executions and generate a ranked list of program elements.
many of these approaches propose various formulas that can be used to compute the suspiciousness of a program element given the number of times it appears in failing and successful executions.
jones and harrold proposed tarantula that uses a suspiciousness score formula to rank program elements .
later abreu et al.
proposed another suspiciousness formula called ochiai which outperforms tarantula.
then lucia et al.
investigated di erent association measures and highlighted that some of them including klosgen andinformation gain are promising for spectrum based bug localization .
recently xie et al.
conducted a theoretical analysis and found that several families of suspiciousness score formulas outperform other families .
next yoo proposed to use genetic programming to generate new suspiciousness score formulas that can perform better than many human designed formulas .
subsequently xie et al.
theoretically compared the performance of the formulas produced by genetic programming and identi ed the best performing ones .
most recently xuan and monperrus combined di erent suspiciousness score formulas into a composite formula using their proposed algorithm named multric which performs its task by making use of an o the shelf learning to rank algorithm named rankboost .
multric has been shown to outperform the best performing formulas studied by xie et al.
and the best performing formula constructed by genetic programming .
many of the above mentioned approaches that compute suspiciousness scores of program elements can be used in the amlspectracomponent of our proposed approach.
in this work we experiment with a popular spectrum based fault localization technique namely tarantula published a decade ago which is also used by promesir .
our goal is to show that even with a basic spectrum based bug localization component we can outperform existing approaches including the state of the art spectrum based approach by xuan and monperrus .
other related studies.
there are many studies that compose multiple methods together to achieve better performance.
for example kocaguneli et al.
combined several single software e ort estimation models to create more powerful multi model ensembles .
also rahman et al.
used static bug nding to improve the performance of statistical defect prediction and vice versa .
.
conclusion and future work in this paper we put forward a novel multi modal bug localization approach named a daptive m ulti modal bug localization aml .
di erent from previous multi modal approaches that are one size ts all our proposed approach can adapt itself to better localize each new bug report by tuning various weights learned from a set of training bug reports that are relevant to the new report.
aml in particular its amlsuspwordcomponent also leverages the concept of suspicious words i.e.
words that are associated to a bug to better localize bugs.
we have evaluated our proposed approach on real bugs from software systems.
our experiments highlight that among the bugs aml can successfully localize and bugs when developers inspect the top top and top methods respectively.
compared to the best performing baseline aml can successfully localize .
.
and .
more bugs when developers inspect the top top and top methods respectively.
furthermore in terms of map aml outperforms the best baseline by .
.
in the future we plan to improve the e ectiveness of our proposed approach in terms of top n and map scores.
to reduce the threats to external validity we also plan to investigate more bug reports from additional software systems.
dataset.
additional information of the bugs used in the experiments is available at amlfse amldata downloads amldata.7z .
.