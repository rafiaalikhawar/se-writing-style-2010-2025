reasonably most general clients for javascript library analysis erik krogh kristensen aarhus university erik cs.au.dkanders m ller aarhus university amoeller cs.au.dk abstract a well known approach to statically analyze libraries without having access to their client code is to model all possible clients abstractly using a most general client.
in dynamic languages however a most general client would be too general it may interact with the library in ways that are not intendedby the library developer and are not realistic in actual clients resulting in useless analysis results.
in this work we explore theconcept of a reasonably most general client in the context of a new static analysis tool r eagent that aims to detect errors in typescript declaration files for javascript libraries.
by incorporating different variations of reasonably mostgeneral clients into an existing static analyzer for javascript we use r eagent to study how different assumptions of client behavior affect the analysis results.
we also show how r eagent is able to find type errors in real world typescript declarationfiles and once the errors have been corrected to guarantee thatno remaining errors exist relative to the selected assumptions.
i. i ntroduction typescript has become a popular alternative to javascript for web application development.
typescript provides static type checking but libraries are still implemented mostly in javascript.
these libraries use separate type declaration files to describe the typed apis towards the typescript application developers.
the definitelytyped repository contains such type declaration files as of february .
previous work has shown that there are numerous mismatches between the type declarations in these files and the library implementations causing spurious type errors and misleading ide suggestions when used by application developers .
existing approaches in the literature for detecting such mismatches include tscheck tstest and tpd .
tscheck applies light weight static analysis of the library functions but the analysis is unsound and errors can thereforebe missed.
also tscheck only reports an error if an inferred function result type is disjoint from the declared one which makes tscheck miss even more errors.
tstest is based on automated testing and as such inherently underapproximates the possible behaviors of libraries resulting in no more than statement coverage of the library code on average .
tpd similarly uses dynamic analysis although with existing test suites to drive execution instead of automated testing and therefore also misses many errors.
another line of work involves static analysis for javascript.
by conservatively over approximating the possible behaviorof the program being analyzed static analysis tools canin principle detect all type errors exhaustively.
flow usesfast type inference but it is incapable of reasoning about unannotated library code .
similarly to typescript flow relies on type declaration files for interacting with untyped library code and flow blindly trusts these files to be correct.
several static analyzers have been specifically designed todetect type related errors in javascript programs without requiring type annotations.
state of the art tools are tajs safe and jsai .
however these analyzers have not been designed for analyzing libraries without client code and they do not exploit or check typescript types.
although previous approaches have been proven useful for finding mismatches between the typescript declaration file andthe javascript implementation of a given library none of them can guarantee that they find all possible type mismatches that a realistic client may encounter when using the declaration fileand the library.
in this work we present a novel framework that aims to complement existing techniques by having the ability toexhaustively find all possible type mismatches or prove that there are none relative to certain reasonable assumptions.
the approach we take is to build on an existing static type analysis tool for javascript specifically the tajs analyzer.
the first challenge is that such tools have been designed with a closed world assumption i.e.
where the entire programis available for the analysis whereas we need to analyzelibrary code without having access to client code.
in thepast the problem of analyzing an open program using ananalysis designed with a closed world assumption has been addressed through the notion of a most general client for the library .
a most general client is an artificial program that interacts with the library in all possible ways therebysoundly modeling all possible actual clients.
however wefind that the concept of a most general client does not work well for a dynamic language like javascript.
due to the poor encapsulation mechanisms in javascript clients can in principle interfere with the library in ways that are not intended by the library developer and are not realistic in actual clients.
as a simple example a most general client may overwrite parts of the library itself or the standard library that the library relies on thereby breaking its functionality and rendering the static analysis results useless.
for this reason we introduce the concept of a reasonably most general client that restricts the capabilities of the artificial client.
our framework provides a methodology for library developers to exhaustively detect possible type mismatches under different assumptions of the client behavior.
ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
existing static type analysis tools for javascript including tajs have not been designed with support for typescript type declarations however it turns out that typescript s notion of types fits quite closely with the abstract domains used by tajs .
a bigger challenge is that the typescript type declarations for libraries are written in separate files with no clear link between for example the type declaration for a function and the code that implements that function.
javascript libraries initialize themselves dynamically often in complicated ways that are difficult to discover statically.
to this end we adapt the feedback directed approach by tstest which incrementally discovers the relation between the type declarations and the library implementation to a static analysis setting.
by building on an existing static analysis tool for javascript we naturally inherit some of its limitations as well as any improvements made in the future .
although much progress has been made to such tools within the last decade javascript libraries are notoriously difficult to analyze statically even when considering simple clients .
the goal of this paper is not to improve the underlying static analysis tool but to explore how such a tool can be leveraged to exhaustively find errors in typescript declaration files.
usually when javascript analyzers encounter difficulties regarding scalability and precision they do not degrade gracefully but fail with an error message about a catastrophic loss of precision inadequate memory or a timeout.
to partly remedy this problem our framework selective stops the analysis of problematic functions.
in summary the contributions of our work are the following.
we introduce the concept of a reasonably most general client rmgc that restricts the traditional notion of most general clients to enable static analysis of javascript libraries section iii .
some of the restricting assumptions that we consider are necessary for the analysis to have meaningful results others provide a trade off between generality of the rmgc i.e.
what errors can possibly be found and false positives in the analysis results.
we discuss how to incorporate abstract models of the different variations of rmgc s on top of an existing static analysis tool tajs that has originally been designed for whole program javascript analysis thereby enabling openworld analysis of javascript libraries section v .
by adding support for creating abstract values from typescript types and conversely type checking abstract values according to typescript types the resulting analysis tool can exhaustively detect errors in typescript declaration files for javascript libraries.
we adapt the feedback directed technique from tstest to incrementally discover the relation between the type declarations in the typescript declaration files and the program code in the javascript implementation.
we experimentally evaluate our tool reagent on realworld libraries section vi .
reagentuses tajs largely unmodified and we believe it could easily be ported to similar analyzers such as safe orjsai .
with reagent we detected and fixed type errors in these libraries totaling lines changed across libraries with the guarantee thatthe fixed declaration files do not contain any remaining type errors under the assumptions of the rmgc .
moreover we investigate the impact of each optional assumption of the rmgc by evaluating the trade off between generality of the rmgc and accuracy of the analysis.
ii.
m otiv ating example to motivate our approach we begin by describing an example from the semver library 1which is a small library for handling version numbers according to the semantic versioning scheme.
a simplified portion of the library implementation is shown in figure 1a.
the constructor in line returns a semver object if the argument string matches the semantic versioning scheme.
the definitelytyped repository hosts a declaration file forsemver a small part of which is shown in figure 1b.
our goal is to detect mismatches between the declaration file and the implementation of the library.
for this reason we need to consider how clients may interact with the library.
because of the dynamic nature of javascript a client of the library could in principle interact with the library in ways that are not possible with statically typed languages.
a mostgeneral client interacting with the semver library would perform every possible action including replacing the format function declared in line with a function that just returns a constant string.
the format function in semver is responsible for creating and setting the version property of the semver class line and thus replacing format will cause all objects created by thesemver constructor to lack the version property.
a mostgeneral client will thus find that the declaration file which states that the version property is present may be erroneous.
if the library developer did not intend for clients to overwrite the format function and no client developer would ever consider so then the missing version property is a false positive.
our reasonably most general client rmgc works under a set of assumptions described in section iii that restrict the actions performed compared to a truly most general client.
one of these assumptions includes that the rmgc does not overwrite library functions and under this assumption the false positive related to the version property would not occur.
it is nontrivial for any automated technique that relies on concrete execution to provide sufficient coverage of the possible behavior of semver .
for instance the simple random string generator in tstest will generate a string matching the semantic versioning scheme with a probability of around and without such a string no semver object will ever be created so most of the library will remain untested.
by the use of abstract interpretation we overcome the shortcomings of the techniques that rely on concrete executions.
this approach allows us to evaluate the semver constructor abstractly with an indeterminate string value passed as parameter.
when the semver constructor is evaluated abstractly the condition in line is considered as possibly succeeding by the abstract interpreter so that an abstract semver object is constructed and returned which is necessary to test the rest of the library.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
function semver version ... if version.length max length throw newtypeerror varm version.trim .match regexp if !m throw newtypeerror ... numberify any prerelease numeric ids this.prerelease m .split .
.map id if .test id id id max int return id return id this.format semver.prototype.format function this.version this.major .
this.minor .
this.patch if this.prerelease.length this.version this.prerelease.join .
return this .version a a simplified version of the semver constructor.
export class semver constructor version string semver major number minor number patch number version string prerelease string format string compare other string semver b the declaration for semver from the typescript declaration file.
for path semver.new .prerelease.
expected string or undefined but found number c error reported by r eagent for the prerelease property.
figure implementation and declaration file of the semver library.
an example of a type mismatch that is not easily detectable by techniques that rely on concrete executions but is found by our abstract rmgc is a mismatch related to theprerelease property declared in line .
the correct type for the prerelease property is string number since a conversion to number is attempted for every element of the array during the initialization of the semver object lines .
the type violation reported by reagentfor this error is shown in figure 1c.
the downside of using abstract interpretation is that reagentis sometimes overly conservative and may report type violations in situations where no concrete execution could lead to a type mismatch.
however in return it finds all possible mismatches relative to the rmgc assumptions.
iii.
r easonably most general clients a most general client mgc uses a library by reading and writing its object properties and invoking its functions and constructors.
we refer to such possible uses as actions .
a library can be stateful so the behavior of its functions may depend on actions that have been performed previously so anmgc must perform any possible sequence of actions not just single actions.
some of the function invocations performed by the mgc involve callback functions that originate from themgc and may similarly perform arbitrary actions.
an mgc may invoke the functions of a library with arguments of any type even if the declaration file declares that the function should be called with arguments of a specific type.
however the declaration file describes a contract between the library and the client.
if we know that the client does not break this contract then the library can be blamed for any type errors that are encountered.
areasonably most general client rmgc does the same as anmgc but with certain restrictions that ensure both that the rmgc does not break the contract in the declaration file and that the rmgc does not interact with the library in ways that are unrealistic and unintended by the library developer.
thefirst two assumptions we describe next are necessary for the rmgc to work meaningfully whereas three other assumptions are optional and ultimately depend on what guarantees the user of our analysis wants.
a. respecting declared types a necessary assumption is that an rmgc respects declared types if a function in a library is declared as receiving e.g.
numbers as its arguments then the rmgc only calls the function with numbers.
otherwise we would be unable to blame the library and its type declaration file for any type mismatch that occurs when the client uses the library.
assumption .
a n rmgc respects the types declared in the type declaration file when passing values to the library.
note that because typescript s type system is inherently unsound this assumption is not the same as requiring that the client passes the typescript type check without warnings.
a consequence of this assumption is that the set of possible actions is bounded by the types that appear in the declaration file which is useful when we in section v define the notions of abstract rmgcs and action coverage.
b. preserving the library as motivated in section ii typescript clients can in principle overwrite library functions like the format function in the example but it is clearly unreasonable to blame the library for type errors that result from that.
a possible approach is to expect that properties that are intended to be read only are declared as such in the declaration file.
typescript properties are writable by default but can be declared with the modifier readonly orconst .
however authors of declaration files rarely use these modifiers.
additionally some features such as class methods cannot easily be declared as read only.
2it is possible to create a read only method by declaring it as a property with a function type but this feature is rarely used.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
overwriting properties of standard libraries specifically the ecmascript standard library the browser dom api and the node.js api may similarly cause the library under test to malfunction.
for instance the semver constructor from the motivating example depends on the functionality of thestring.prototype.trim function from the ecmascript standard library.
only a few of the properties of the standard libraries are marked as read only.
sometimes some of these nonread only properties are overwriten on purpose for example to improve support of certain features in outdated browsers by loading polyfills.3still both regarding the library under test and the standard libraries it is reasonable to assume that a library does not depend on the client to overwrite functions in the library which justifies the following assumption.
assumption .
a n rmgc considers all properties of the standard libraries and all properties declared with a non primitive type4from the library under test as read only and thus never writes to those properties.
this assumption does not prevent the rmgc from writing to library properties declared with primitive types such properties are occasionally used for library configuration purposes .
in contrast writing to an undeclared property is considered a type error in typescript so the respect types assumption ensures that the rmgc never does so.
c. obtaining values for property writes and function arguments whenever an rmgc passes an argument to a library function or writes to a property of a library object a value of the declared type is needed.
there are two ways the rmgc can obtain such a value either the value originates from the library and the client receives the value via a function call for example or the value is constructed by the rmgc itself.
we refer to these as library constructed values and client constructed values respectively.
even an mgc cannot construct all possible values itself for example a libraryconstructed value may be a function that has access to the internal state of the library via its free variables so we need to take both kinds of value constructions into account.
typescript is structurally typed meaning that when a function is declared as taking an argument of some object type then the type system allows the function to be called as long as the argument is an object of the right structure.
according to the respect types assumption an rmgc should pass any structurally correct client constructed or library constructed value of the desired type.
however that is not always the intent of the library developers as the structural types may not fully describe what is expected from the arguments.
for instance the structural types in typescript cannot describe prototype inheritance and sometimes a library assumes other invariants about values constructed by the library itself.
4the primitive types in typescript are boolean string number undefined symbol andnull .example .
in the code below taken from the leaflet library 5the value of this.options.tilesize is supplied by the client and the tilesize property is declared to have type l.point number .i ftilesize is set to a value that has the same structure as l.point but is not constructed by the l.point constructor then the instanceof check in line in the program will fail resulting in an invalid l.point being constructed.
1vargettilesize function vars this.options.tilesize return sinstanceof l.poin t?s newl.point s s the following assumption may better align with the intended use of such a library.
assumption .
when passing values of non primitive types to the library anrmgc uses library constructed values if possible clientconstructed values are only used if the rmgc is unable to obtain library constructed values of the desired types according to the type declaration file.
a recent study of javascript object creation has found that it rarely happens that the same property read in a program uses objects that were created at different program locations suggesting that the prefer library v alues assumption is satisfied by most clients in practice.
string values are optionally handled in a special way.
since a string provided by the rmgc might be used in a property lookup on an object in the library a string that is the name of a property defined on for example object.prototype may result in a property of object.prototype being accessed.
the perhaps implicit assumption of the library developer in this case might be that clients do not use strings that are property names of prototype objects from the standard library as such accesses could have unintended consequences.
example .
in the simplified code below taken from the loglevel library 6thegetlogger function line makes sure that only one logger of a given name is constructed by checking if a property of that name is defined on the loggers object lines .
if a logger has already been constructed it is returned line and otherwise a new one is created line .
however if the name is for example tostring then the property lookup in line will return the tostring method defined on object.prototype and that method will then be returned by getlogger resulting in a type mismatch.
1declare function getlogger name string logger 2var loggers 3function getlogger name varlogger loggers if !logger logger loggers newlogger ... return logger this observation motivates the following assumption.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
assumption .
a n rmgc does not construct strings that coincide with the names of properties of the prototype objects in the standard libraries.
another issue is that typescript s type system supports width subtyping which means that for an object to match a type the object should have all the properties declared by the type and any undeclared property in the type can be present in the object and have any value.
therefore it seems natural that when anrmgc constructs an object of some type the constructed object may also have undeclared properties.
however since these undeclared properties can have arbitrary values false positives might appear if the library reads one of these undeclared properties.
example .
in the simplified example below from the uuid library 7thev4function obtains random numbers from the opts object line and puts them into the bufarray line .
theopts object can have two different types declared in line .
the v4function attempts to detect which of the two types the concrete opts object has and uses this to create an array of random numbers line .
a client can choose to use the second variant of the opts object that only has declared arngproperty but because of width subtyping the client is technically allowed to add a property random of any type to that object.
if the client chooses to call v4with such an opts object then the property read opts.random can read any value which in turn can cause a false positive when non number values are written to the bufarray line .
1type opts random number rng number 2declare function v4 opts opts buf number number 3function v4 opts buf varrnds opts.random opts.rng rng for vari i i buf rnds return buf we therefore leave it as an optional assumption whether client constructed objects should have undeclared properties.
assumption .
a n object constructed by the rmgc does not have properties that are not declared in the type.
if this assumption is disabled for client constructed objects all properties that are not explicitly declared may have arbitrary values of arbitrary types.
in the following sections we demonstrate that these five assumptions are sufficient to enable useful static analysis results for javascript libraries.
iv .
a bstract domains in static type analysis to be able to explain how to incorporate rmgc s into the tajs static analyzer we briefly describe the structure of the abstract domains used by tajs and related tools like safe and jsai .
the iterative algorithm performed by the abstract rmgc.
input library source code and typescript declaration 1invoke tajs to analyze the library initialization code 2allstate abstract state after library initialization 3vmap 4do forall functions finvmap do args use obtain value to get arguments for f propagate allstate and args to function entry of f invoke tajs to analyze new dataflow forall functions finvmap do propagate state at function exit of ftoallstate add libval abstract return value of f declared return type of f forall properties pin all objects oinvmap do add libval abstract value of pinallstate declared type of p 14while allstate orvmap changed tajs is a whole program abstract interpreter that overapproximates the flow of primitive values objects and functions in javascript programs.
we here ignore many details of the abstract domains including the use of context sensitivity that are not relevant for the topic of rmgc s. abstract objects are partitioned by the source locations called allocation sites where the objects are created .
basically at each program point tajs maintains an abstract state which is a map from allocation sites to abstract objects and an abstract object is a map from abstract property names to abstract values.
abstract values are described by a product lattice of sublattices for primitive values of the different types strings numbers booleans etc.
as in traditional constant propagation analysis and a sub lattice for object values modeled by allocation sites like in traditional points to analysis and abstract function values like in traditional control flow analysis .
as in other dataflow analyses tajs uses a worklist algorithm to propagate abstract states through the program until a fixed point is reached.
we refer to the literature on tajs for more details.
v. u sing rmgc si n static type analysis our static analysis is made of two components the tajs abstract interpreter and an abstract rmgc .
the abstract rmgc interacts with the library by using the abstract interpreter to model the actions described in section iii.
it maintains an abstract state allstate that models all program states that are possible with the actions analyzed so far.
the basic steps of the abstract rmgc are shown in algorithm .
the abstract rmgc cannot immediately invoke all functions in the library because the connection between the implementation of a function and the declared type of the function is only known after a reference to the function has been returned by the library.
in the motivating example section ii if thecompare method had been defined in the semver constructor authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm handling library constructed abstract values.
input an abstract value and a typescript type add libval val type ifnot type check val type then report type violation fval filter val type vmap vmap instead of being present on the semver.prototype object a client would only be able to invoke the method after having constructed an instance of semver .
therefore a crucial component of the abstract rmgc is a map called vmap from types in the declaration file to abstract values as used by tajs see section iv .
a type is modeled as an access path in the declaration file for example the access path semver.new .minor is the typescript type number in the semver declaration file.
this map allows the abstract rmgc to keep track of which parts of the library have been explored so far during the analysis and for obtaining abstract libraryconstructed values for further exploration.
abstract values invmap that contain allocation sites modeling