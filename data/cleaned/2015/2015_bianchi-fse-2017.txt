reproducing concurrency failures from crash stacks francesco a. bianchi usi universit della svizzera italiana switzerland francesco.bianchi usi.chmauro pezz usi universit della svizzera italiana switzerland university of milano bicocca italy mauro.pezze usi.chvalerio terragni usi universit della svizzera italiana switzerland valerio.terragni usi.ch abstract reproducing field failures is the first essential step for understanding localizing and removing faults.
reproducing concurrency field failures is hard due to the need of synthesizing a test code jointly with a thread interleaving that induce the failure in the presence of limited information from the field.
current techniques for reproducing concurrency failures focus on identifying failureinducing interleavings leaving largely open the problem of synthesizing the test code that manifests such interleavings.
in this paper we present concrash a technique to automatically generate test codes that reproduce concurrency failures that violate thread safety from crash stacks which commonly summarize the conditions of field failures.
concrash efficiently explores the huge space of possible test codes to identify a failure inducing one by using a suitable set of search pruning strategies.
combined with existing techniques for exploring interleavings concrash automatically reproduces a given concurrency failure that violates the thread safety of a class by identifying both a failure inducing test code and corresponding interleaving.
in the paper we define theconcrash approach present a prototype implementation of concrash and discuss the experimental results that we obtained on a known set of ten field failures that witness the effectiveness of the approach.
ccs concepts software and its engineering software testing and debugging concurrent programming languages object oriented languages keywords software crashes debugging concurrency test generation acm reference format francesco a. bianchi mauro pezz and valerio terragni.
.
reproducing concurrency failures from crash stacks.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
introduction concurrent systems are increasingly popular due to the spread of multi core architectures.
these systems are prone to concurrency faults which are extremely hard to avoid due to the complexity of the thread synchronization and the huge size of the interleaving space.
concurrency faults often remain undetected during the testing process and manifest in production runs leading to failure that are difficult to reproduce because they often occur only in the presence of specific thread interleavings .
reproducing failures is the first essential step towards understanding localizing and removing the related faults .
reproducing concurrency failures from field reports is a non trivial task since it requires identifying both a test code and thread interleaving of the test code that induce the failure from the limited information available in the reports where a test code is a runnable piece of code that exercises the system under test and an interleaving is a temporal order of a set of shared memory accesses.
the main techniques to reproduce concurrency failures rely on information collected at runtime either continuously record andreplay approaches or only at the time of the failures post processing approaches .
both classes of approaches require information that may be expensive and hard to obtain in many practical situations and identify the failure inducing interleaving but not the failure inducing test code.
record and replay techniques instrument the program for recording executions with a runtime overhead ranging from up to in some worst cases which may be acceptable in testing but not in production environments .
post processing techniques rely on memory core dumps that provide full information of the program state at the time of the failure .
memory core dumps are expensive to collect and not available on all platforms .
moreover both the recorded executions and memory core dumps often contain sensitive information which introduces privacy concerns .
both record and replay and post processing techniques produce failureinducing conditions on the program input and the state the failure inducing interleaving or both but do not synthesize a fully executable failure inducing test code as the one presented in figure that we discuss in the next section.
in this paper we present concrash concurrency crashes reproduction the first automated technique that synthesizes both failure inducing test codes and related interleavings with neither overhead nor privacy issues.
concrash targets concurrency failures that violate the thread safety of a class.
thread safe classes encapsulate efficient synchronization mechanisms that guarantee a correct behavior of the class when invoked concurrently from multiple threads and are largely adopted in modern concurrent systems as they avoid the difficulty of writing such synchronizationesec fse september paderborn germany francesco a. bianchi mauro pezz and valerio terragni void info string s .
.
.
log level.info msg void log level l string s .
.
.
logrecord r new logrecord l s dolog r void dolog logrecord r .
.
.
log r void log logrecord r .
.
.
synchronized this cr419 if filter !
null filter can be set to null421 if !filter.isloggable r return void setfilter filter f .
.
.
this.filter f figure faulty class java.util.logging.logger of jdk .
.
java.lang.nullpointerexception at java.util.logging.logger.log logger.java pof at java.util.logging.logger.dolog logger.java at java.util.logging.logger.log logger.java at java.util.logging.logger.info logger.java crashing method at test.testcode .runtest testcode.java at java.lang.thread.run thread.java figure crash stack of class logger bug id mechanisms .concrash requires in input only the class that violates thread safety and the standard crash stack of the failure.
differently from execution traces and memory core dumps that are expensive to produce and hard to obtain crash stacks are easily obtainable and do not suffer from performance and privacy issues .
recent studies show that of concurrency failures lead to crashes or hangs that usually generate a crash stack .
crash stacks contain only partial information about the state of the system thus challenging the reproduction of concurrency failures .
in particular crash stacks provide only information about the failing thread and give little data about the state of the objects and the values of the input parameters of the methods involved in the failure.
to identify a failing execution that reproduces a crash stack concrash must explore a huge space of possible test codes and thread interleavings.
concrash explores efficiently the huge space by alternately generating test codes and exploring thread interleavings.
it iteratively generates test codes by implementing pruning strategies that exclude both redundant and irrelevant test codes to optimize the exploration of the interleaving space.
test codes are redundant if they induce the same interleaving space of previously investigated test codes and thus would not reproduce the failure.
test codes are irrelevant if concrash can infer the impossibility of reproducing the failure from the crash stack and the single threaded execution of the call sequences that comprise the test code.
concrash pruning strategies are cost effective as they analyze single threaded executions of the call sequences rather than exploring the full interleaving space of concurrent executions.
concrash privileges short test codes to improve the efficiency of exploring interleavings localizing and fixing the fault.
we evaluated concrash by experimenting with a prototype implementation for the java language on ten real world concurrency failures.
the experiments indicate that concrash takes on average seconds to reproduce a concurrency failure including the time for both generating test codes and exploring their interleavings .
the contributions of this paper include i the first automatic technique to synthesize failure inducing concurrent test codes from crash stacks to reproduce concurrency failures in thread safe classes ii a publicly available implementation of the technique concrash iii an experimental evaluation of concrash showing the effectiveness of the proposed technique.
private void runtest throws throwable sequential prefix logger sout logger.getanonymouslogger myfilter myfilter0 new myfilter sout.setfilter filter myfilter0 suffix thread t1 new thread new runnable public void run sout.info crashing method suffix thread t2 new thread new runnable public void run sout.setfilter null interfering method t1.start t2.start figure a concurrent test code that reproduces the crash stack in figure reproducing concurrency failures in this paper we address the problem of synthesizing concurrent test codes that reproduce concurrency failures of classes that violate thread safety.
a class is thread safe if it encapsulates synchronization mechanisms that prevent incorrect accesses to the class from multiple threads .
incorrect synchronization mechanisms are concurrency faults that manifest at runtime as concurrency failures that is deviations from the expected behaviour of a concurrent usage of the class and expose a thread safety violation.
in this work we address the relevant class of concurrency failures that manifest as runtime exceptions.
a key characteristic of concurrency failures is that they manifest non deterministically due to the non determinism of the scheduler that decides the threads order of multi threaded executions.
the order of accesses to shared memory locations is fixed within one thread but can vary across threads.
an interleaving is a total order relation of shared memory accesses among threads .
concurrent executions can manifest many different interleavings and only some usually few of them trigger concurrency failures .
motivating example.
figure shows the code snippet of a known concurrency fault in class java.util.logging.logger of the jdk .
.
library.
method logaccesses field filter at lines and within a synchronized block that locks the object instance.
the method checks whether the field is initialized line before dereferencing it line .
method setfilter line accesses and modifies the same field without locking the object instance.
as a result another thread can execute line between the executions of lines and while a thread is executing method logand set the reference to null thus violating the intended atomicity of method log.
if both threads access the same object instance this thread interleaving triggers a nullpointerexception at line figure .
figure shows a concurrent test code that can induce such failure inducing interleaving.
crash stack trace.
concrash generates concurrent tests code that reproduce concurrency failures from crash stacks.
figure presents an example of crash stack produced when executing the test code in figure .
a crash stack trace or simply crash stack reports the ordered sequences of functions on the call stack at the time of the failure and terminates the sequence with the exception that results from the failure nullpointerexception at line in figure .
each entry frame in the crash stack reports a functionreproducing concurrency failures from crash stacks esec fse september paderborn germany cut crash stack traceauxiliary classesinputfailure inducing test codeinterleavingoutput p s1 s2 pthread 2 s2thread 1 s1new test codeprunedfailure not foundcall sequence generatorpruning strategiesinterleaving explorertest code generatorconcrash legend p sequential prefix s1 s2 concurrent suffixes figure logical architecture of concrash and a code location.
the code location of each entry identifies either the location of the call to the next function or in the case of the top entry e.g.
line in figure the location of the point of failure pof which is the static line of code that triggered the failure.
given a crash stack developers can easily identify both the class responsible for the concurrency failure which we denote as class under test cut and the cut method whose invocation led to the failure which we denote as crashing method .
such method corresponds to the outermost cut method in the crash stack.
in our running example the cut is the jdk class logger and the crashing method is method info of class logger as inferred from the frame at line in figure .
concurrent test code.
concurrency failures of supposedly thread safe classes can be reproduced with multi threaded executions of concurrent test codes.
in this paper a concurrent test code is a set of method call sequences that exercise the public interface of the cut from multiple threads without additional synchronization mechanisms other than the one implemented in the cut .
a call sequence is an ordered sequence of method calls m1 .
.
.
mn that are executed in a single thread.
the methods in the sequence have a possible empty set of input parameters which can be either primitive values for instance of type floats integers and booleans or