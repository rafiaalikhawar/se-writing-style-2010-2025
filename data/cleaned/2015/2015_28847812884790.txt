jumping through hoops why do java developers struggle with cryptography apis?
sarah nadi stefan kr ger mira mezini eric bodden technische universit t darmstadt universit t paderborn fraunhofer iem lancaster university nadi mezini cs.tu darmstadt.de stefan.krueger cased.de eric.bodden uni paderborn.de abstract to protect sensitive data processed by current applications developers whether security experts or not have to rely oncryptography.
while cryptography algorithms have become increasingly advanced many data breaches occur because developers do not correctly use the corresponding apis.
to guide future research into practical solutions to this prob lem we perform an empirical investigation into the obstacles developers face while using the java cryptography apis the tasks they use the apis for and the kind of tool supportthey desire.
we triangulate data from four separate studiesthat include the analysis of stackoverflow posts 100github repositories and survey input from developers.
we find that while developers find it di cult to use certain cryptographic algorithms correctly they feel surprisingly confident in selecting the right cryptography concepts e.g.
encryption vs. signatures .
we also find that the apis are generally perceived to be too low level and that developers prefer more task based solutions.
categories and subject descriptors d. .
software libraries keywords cryptography api misuse empirical software engineering .
introduction as software applications collect more and more sensitive data it is becoming increasingly essential for developers torely on cryptography to protect this data.
however this iseasier said than done.
application developers are not nec essarily cryptography experts and the o ered cryptography application programming interfaces apis are often rathercomplex and not easy to use.
for instance consider the java cryptography architecture jca the o cial framework for working with cryptography in java.
the jca is designed to allow java applipermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita tion on the first page.
copyrights for components of this work owned by others thanacm must be honored.
abstracting with credit is permitted.
to copy otherwise or re publish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
developers to easily use cryptography by separating the apis developers use from the underlying implementa tions that can be supplied by any provider e.g.
java s default implementation or bouncycastle .
however jca apis o er a broad variety of di erent algorithms that in turn support many modes and configuration options.
while any jca provider must support a certain list of cryptogra phy algorithms it may also support additional algorithms or even provide di erent default values for the same jca api call.
as a result the task to use and compose theseapi components may be challenging.
in fact the misuse of cryptography apis has already been established as a common cause of many security vulnerabilities .
solutions that e ectively support application developers in correctly and easily incorporating cryptogra phy into their applications are thus urgently needed.
toprovide such solutions it is essential to understand the rootcauses behind the phenomenon and the kind of support developers would perceive as useful.
eliciting these causes and requirements in the specific context of java based software development is the goal of this paper.
specifically this paperaddresses the following research questions.
rq1 what obstacles if any do developers face during theuse of java cryptography apis?
while existing studies established after the fact that apis are misused they give no insights into the underlying reasons.if developers do face obstacles while using the apis understanding the nature of these obstacles is essentialfor deriving guidance towards useful solutions.
rq2 what are the common cryptography tasks developers perform?
robillard concluded that a main obstacle to learning an api is the lack of information on how to use this api to accomplish a specific task.
to the best of our knowledge there is no data that identifies common cryptography tasks developers perform which would help in providing better support for them.
rq3 what tools methods would help developers use cryptog raphy more e ectively?
to aid in developing solutions we elicit developers expectations and requirements.
to answer these research questions we conduct an empirical investigation consisting of four separate studies.
study s1 analyzes the top java cryptography questions askedon the popular question answer site stackoverflow.
study s2 is a pilot survey that gathers data from developerswho asked java cryptography related questions on stack overflow.
in study s3 we analyze randomly selected public github repositories that use java s cryptog2016 ieee acm 38th ieee international conference on software engineering raphy apis to identify the tasks developers usually need to accomplish.
finally study s4 surveys developers who use java s cryptography apis to confirm some of our find ings from the previous three studies.
the material used in all four studies is available on our online artifacts page .
we answer rq1 by triangulating data from s1 s4.
we find that developers do indeed have di culties in using the java cryptography apis and that their main obstacle is the api complexity and lack of a proper level of abstraction.our survey participants suggest several solutions and werecommend a list of tool features for guiding future tool builders in addressing the obstacles faced by developers.
.
s1 stackoverflow posts we analyzed java cryptography related posts on stackoverflow so to check if developers face problems using the apis and to understand their obstacles rq1 .
.
study design to query so we used the online stackexchange data explorer .
the query results were then downloaded as acsvfile for further analysis.
to search for relevant posts we used the tags java and cryptography and explicitly excluded javascript.
on june such a query returned posts.
to be able to manually analyze each of theseposts we selected only the top .
to identify the topquestions we sorted posts by view count followed by score followed by favorite count .
when faced with a problem an application developer would search the web or so and clickon the relevant question link s from the search results toview it.
we believe that a high view count suggests that more application developers face the same or a similar problem.
since only so members are allowed to vote on ques tions and not everyone uses the voting system we used thescore count as the second rather than first sorting criterion.for completeness we included the favorite count as the third sorting metric.
the selected posts had views on average while the 100th post already had only views.
we manually analyzed all questions reading both the question and answers to identify two factors the question topic and the obstacle the poster is likely facing.
to reduce subjectivity the first two authors independently an alyzed the questions and discussed any disagreements.
thecombined analysis time of the posts was around 33hrs.
since our study is of exploratory nature we did not use any pre defined categories.
instead we used open coding where we assigned a short description code to each post foreach of the two factors above re iterating and refining thesecodes as necessary.
at the end we grouped the identified topics and underlying obstacles into relevant categories.
the researcher agreement measured by the kappa score forthese two factors was .
and .
respectively.
.
results question topics.
the fact that we found over java cryptography related questions on so suggests that developers do indeed face di culties using cryptography.
to understand these di culties we look at the topics posters ask about.
we identify nine main topics shown in table and divide four of these main topics into further sub categories not shown in table for space limitations .
the n a category contains questions that are not cryptography relatedtable question topics for the top java cryptographyrelated posts questions on stackoverflow main topic questions symmetric encryption public key encryption provider signature hashing keystore random numbers n a total even though they matched our query tags e.g.
general random number generation or migrating code from java to .net .
table shows that of the top java cryptography questions on so are related to symmetric encryption.
symmetric algorithms use the same key for encrypting and decrypting the data and are on large data more e cientthan public key algorithms.
in terms of sub categories outof these questions are related to how to encrypt data in general.
however we also find more specific questions such as handling padding during encryption ordealing with keys and their lengths .
the next most popular topic we found was public key encryption with questions .
we find that half of the posts dealing with public key encryption ask about keys.
itseems that many developers have di culty correctly setting up and reading the required pairs of public and private keys.
we also found that of the questions are about java cryptography providers including how to set them up thedefault values of di erent providers or whether some algorithm is supported by a specific provider or not.
apart fromthe seven n a questions the remaining identified categories include some questions about signatures hashing keystores and random numbers for cryptographic applications.
s1 obs.
of top java cryptography related questions on so are about symmetric encryption.
obstacles.
table shows the obstacles we identified for the same top questions after excluding the seven questionscategorized as n a. in questions we find that theproblem is related to knowing how to use the api.
for instance users are not sure what method calls are needed to generate a key or why the sequence of method calls they useto perform some task e.g.
encrypt certain data is not work ing properly.
one example is post number .
the poster uses a symmetric cipher and calls the cipher.update method that encrypts part of the input data.
however sheignores the returned encrypted byte array which causes any following decryption to be incorrect.
another example is post number that asks how to generate an initialization vector iv .
from the answers it seems that a devel oper can either use securerandom to generate the iv herself or she can get it through the cipher parameters using the ivparameterspec class if the block mode requires an iv.
the obstacle in these two examples is a matter of understanding how the api works and which methods should be used to achieve the given task.
in cases such as these two examples and the other questions in this category we realized that the question poster had some domain knowledge i.e.
she at least knows which algorithms to use and knew the api to use but the api 936table identified obstacles in the analyzed stackoverflow questions from table excluding the n a posts obstacle questions api use domain knowledge provider setup issues library identification domain knowledge api use total complexity led to incorrect usage.
this category also includes problems in understanding the underlying api implementation e.g.
knowing the encoding of the return value ofan api call or understanding an unclear api error message .
s1 obs.
of question posters have some domain knowledge but the api complexity or unclearunderlying implementation prevents them from usingthe correct sequence of method calls parameters.
however we also find posts where lack of domain knowledge is the main obstacle.
for example wefind three di erent posts and where the question posters confuse encryption and hashing.
the third post asked how to decrypt a sha encrypted string.
by looking at the answers we infer that the poster lacks domain knowledge since sha is a hashfunction and hash functions are one way and irreversable by definition.
similar issues include understanding the key sizes supported by di erent algorithms or what a keystore is.
such users cannot identify the correct algorithms to usein the first place and cannot di erentiate between the vast amount of options available.
note that in six additional questions the obstacle includes both api use and domain knowledge.
additionally we find six posts where theuser does not know which java library to use.
s1 obs.
of question posters lack domain knowledge do not know the correct cryptographic al gorithms to use or cannot identify suitable libraries.
in of the cases we looked at the obstacle is setting up the environment.
the majority of these problems arerelated to setting up and using the correct provider.
for ex ample in posts and4895773 the same code caused exceptions only on certain machines because the users didnot set up the providers correctly on all the machines theytested on.
another common problem is that certain algorithms only work with a special unlimited strength setup that needs an extra jar file to be installed .
s1 obs.
of question posters have problems setting up their environments and providers.
.
intermediate discussion s1 obs.
ands1 obs.
suggest that developers face problems even for simple tasks such as symmetric encryption.even when they know the right algorithm to use they maystill need guidance on how to use the apis properly.
on the other hand s1 obs.
suggests that there are also users who lack the appropriate domain knowledge or are not even sure which libraries to use.
such users require significant guidance to accomplish their tasks.
finally irrespective of theuser s domain knowledge s1 obs.
suggests that users still run into setup issues frequently and that jca s provider architecture is sometimes confusing to developers.
such users may need support with selecting the right provider and set ting up their environments correctly.
.
s2 pilot survey s2 addresses rq1 and also serves as a focused pilot study in preparation for s4.
we use the opportunity that posters of java cryptography related questions on so have actually faced problems themselves.
our goal is to understand the obstacles they faced the kind of tasks they need to perform and the solutions they might find useful.
.
study design survey design.
we asked the following questions q1 what is your current occupation?
undergraduate or graduate student academic or industrial researcher industrial or freelance developer other.
q how many years of java programming experience doyou have?
year years q rate your background knowledge about cryptographyconcepts such as encryption digests signatures etc.not knowledgeable i do not know anything about cryptography somewhat knowledgeable i have a vague idea about various areas of cryptography and whatthey are used for knowledgeable i am familiar with various areas of cryptography and what they are usedfor very knowledgeable i know all most areas of cryptography the di erent available algorithms and what they are used for.
q how often do you need to use cryptography in yoursoftware applications?
never rarely i need cryptography for less than of the software applications i develop occasionally i use cryptography in more than but less than of the software applications i develop frequently i need cryptography for more than of the software applications i develop.a similar scale was used by moreno et al.
.
q what kind of cryptography related tasks do you usuallyimplement in your applications?
free text.
q how much e ort did you go through before resorting to posting your question?
didn t spend much time to be honest stackoverflow just seemed like a reasonable place to start is p e n taf e wh o u r sr e a d i n gr e s o u r c e s and trying a few things here and there ih a daq u i c k look at some apis but didn t really understand much andis p e n tn i g h t st r y i n gt ofi g u r et h i st h i n go u t !
q7 describe the steps you took to try to solve the problemyourself before resorting to stackoverflow.
free text.
q what obstacles made it di cult for you to accomplish your tasks?
free text.
we use the exact question format used by robillard .
q9 rank the following obstacles to using cryptography inyour applications where is the biggest obstacle.
rank from to for three obstacles we believe might be relevant identifying which concepts and algorithms to use identifying which java libraries to use and identifying how to use the apis of the identified library.
question is provided on a separate page from previous question.
q what do you think would be a useful tool technology idea that can help you complete your cryptographic tasks 937table background of survey participants so users .
we assign a code to each participant.
participant current java exp.
cryptography cryptography code occupation in years knowledge use s2 p1 industrial developer somewhat knowledgeable frequently s2 p2 industrial developer very knowledgeable rarely s2 p3 industrial developer knowledgeable frequently s2 p4 industrial developer knowledgeable rarely s2 p5 undergrad.
student somewhat knowledgeable rarely s2 p6 freelance developer somewhat knowledgeable rarely s2 p7 grad.
student knowledgeable rarely s2 p8 other senior sw eng.
team lead knowledgeable rarely s2 p9 freelance developer knowledgeable occasionally s2 p10 freelance developer somewhat knowledgeable rarely s2 p11 industrial developer knowledgeable frequently more correctly e ciently etc.?
free text.
participant recruitment.
we identified so users who asked java cryptography related questions1.
as so provides no means to directly contact users we identified email addresses of only users by visiting their listed websites.
wecontacted these users explaining the goal of our project and asking them to fill the survey.
out of these users eight responded to the survey.
to increase the number of participants we additionally identified users who asked questions with tags java and encryption since a quick analysis of such questions suggests that not all users tag their ques tions explicitly with cryptography.
this allowed us to send invitations to additional users three of whom answered our survey.
this resulted in a total of participants.
.
results participant profiles.
table shows the background of the so posters that participated in this survey.
we can see that with the exception of two students s1 p5 and s1 p7 most of the participants can be considered as professional developers.
this provides us some reassurance that the questions they have asked on so are related to real application development rather than student assignments.
the level of java experience varies between participants though but ismore skewed towards experienced developers.
eight partic ipants have at least two years of java development experience with five having at least six years.
most of the participants seven say that they rarely need cryptography in the various software they develop.
this suggests that theyare typical application developers who only sometimes needto use cryptography in their applications.
in terms of cryptography knowledge all participants rated themselves as at least somewhat knowledgeable.
cryptographic tasks.
we grouped similar free text answers provided by participants resulting in nine categories encrypt data encrypt files secure connections communication store authenticate user login encrypt cookies generate store secret keys derive keys transfer files securely and protect sensitive data in a database .
participants were able to provide more than one task.
however with the exceptionof three tasks each task was only mentioned by one participant.
the three tasks mentioned by more than one participant are store authenticate user login participants secure connections communication participants and encrypt files participants .
1tags java and cryptography excluding javascript .s2 obs.
the most common task needed by of participants is storing and authenticating user login.
effort.
in terms of e ort ten participants said that they spent a few hours reading resources and trying out so lutions on their own.
the remaining participant points outthat her problem was simply a typo that she kept overlook ing.
only six participants described the steps they took before resorting to so this was an optional question .
most of these participants mentioned reading lots of api docu mentation tutorials and blogs.
one participant even men tioned taking a coursera cryptography course and reading two cryptography books.
this points out the problem that application developers spend valuable time trying to under stand the cryptography domain as well as its specific apis.
s2 obs.
to accomplish their cryptography tasks participants spend at least several hours readingthrough online resources.
obstacles.
only six participants answered optional q .
we grouped similar answers together resulting in three main obstacle categories documentation s2 p1 p2 p8 p9 p10 api design s2 p2 p8 p9 p10 and lack of cryptography knowledge s2 p4 .
as expected the most mentioned obstacle was lack of documentation which has been previously noted as a general api usability problem .
participants complained that there is no specific place tofind answers s2 p1 as well as about the lack of java cryp tography tutorials s2 p8 and up to date api documenta tion s2 p2 p8 p9 p10 .
in terms of api design s2 p6 mentioned that it is generally di cult to implement key generation and secure transfer of public private keys using the api.
s2 p1 p4 and p8 discussed problems due to dif ferences between api versions and unclear error messages.
s2 p2 also mentioned the need to understand underlying implementation details due to the layer of indirection betweenthe jca apis and the algorithm implementations jca isdesigned as a set of abstract classes interfaces that are implemented by the specific providers .
since only three participants explicitly ranked their free text obstacles we could not infer any meaningful conclusions from the rankings.
s2 obs.
as obstacles participants mention lack of documentation di culty in api use and indirection between the apis and the underlying implementation.
on the other hand ten participants ranked our three predefined obstacles.
with the exception of one participant who did not view identifying the cryptography concepts to use as an obstacle i.e.
did not provide a ranking for it the 938two other obstacles were ranked by all participants.
since the majority of participants ranked all three factors this suggests that they are indeed obstacles developers face.
we considered the one unranked choice as having a rank of ten since higher ranks are reflected in smaller values.
on average the highest ranked obstacle was identifying how to usethe apis avg.
rank .
.
this was followed by identifying which java libraries to use avg.
rank .
and identifying which concepts and algorithms to use avg.
rank .
.
s2 obs.
participants consider how to correctly use the apis as their biggest obstacle.
developer support.
we received comments from five participants.
three participants asked for better documenta tion and or examples while two ask for more high level apisthat solve common tasks.
it seems that developers find ithard to deal with intricate details and knowledge about the apis and may prefer an input based black box kind of api.
s2 obs.
participants ask for better api documentation and or higher level abstraction of apis in the form of common tasks.
.
intermediate discussion all our participants considered themselves as at least somewhat knowledgeable about cryptography and yet they allfaced problems using cryptography.
this suggests that evendevelopers who have some cryptographic knowledge still faceproblems accomplishing cryptography related tasks.
the obstacles we observe here s2 obs.
and s2 obs.
m a t c h those identified in s1.
participants desire for better documentation s2 obs.
along with the valuable time theyspend reading online resources s2 obs.
suggest that improved documentation technology is needed.
.
s3 tasks in open source software this study addresses rq2 by identifying cryptographyrelated tasks implemented in public github repositories.
.
study design to determine common cryptography tasks performed by application developers we inspected the actual code theywrite.
we used the github search apis through apython wrapper library to find open source projects that use the java cryptography apis provided by jca.
we limited our search to recent java projects created within the last five years that have more than stars and use the package javax.crypto in the code.
by filtering out repositories with less than stars we sought to ensure that thestudy only considers popular projects that are actually used by people rather than small projects that nobody uses.
in the end we obtained a list of all repositories that contain matching code files and the links to these files.
this resultedin unique projects with code files a project maycontain multiple matching code files .
our goal was to understand what cryptographic tasks are performed in the identified code.
unfortunately this is amanual task since any topic analysis techniques would notgive us an accurate description.
to make this task more feasible we randomly selected projects and split them between the first two authors.
we then used open coding totable tasks identified from analyzing github projects a project may implement more than one task .
task projects symmetric encryption sign verify generate secret key asymmetric encryption key storage user authentication secure connection other hashing generate key pair analyze the identified tasks.
in total we analyzed java files over 50hrs.
while we did not intentionally select reposi tories based on their domain our randomly chosen reposito ries included di erent types of projects such as web services android libraries and apps content management systems and web applications.
we could identify di erent types of projects which shows that the random selection was not focused on a specific domain.
the top three categories cov ered by the selection were android apps ten repositories database or data storage related projects ten repositories and communication projects nine repositories .
.
results table shows the distribution of tasks we identified.
we found that most projects perform some form of sym metric encryption.
the type of data being encrypted in cludes messages keys server tokens response cookies documents pin codes and session ids.
we even found passwords being encrypted a practice that is often discouraged and should be replaced by hashing .
the next most popular task that occurs in of the projects is signing data and later verifying this signature.similar to symmetric encryption we found signatures for a variety of input types including uris messages requests files and session ids.
generating secret keys was also a very common task .
this is not surprising since generatinga secret key is often a prerequisite to symmetric encryption.
s3 obs.
the most common tasks found in the analyzed repositories are symmetric encryption signing andverifying data and generating secret keys .
other tasks we identified include asymmetric encryption key storage and user authentication all occurring in at least10 of the analyzed projects.
the remaining tasks such as hashing securing connections or generating key pairs occurred in less than of the projects we analyze.
we alsoincluded an other category that groups very infrequenttasks in our dataset such as the checking of certificates.
.
intermediate discussion in s2 we observed that storing and authenticating user login is the most common task needed by participants s2 obs.
.
on the other hand we found that only of the analyzed github projects implement some form of user authentication.
this discrepancy could be due to the domain of the projects analyzed.
additionally it is hard to general ize based on the participants from s2 which is why we use the survey in s4 for further investigation.
on the other hand the fact that of the analyzed projects need some student researcher professional developerother a occupation year years2 years6 years11 years b years of java experience not knowledgeablesomewhat knowledgeableknowledgeable very knowledgeable c cryptography knowledge never rarely occasionally frequently d frequency of cryptography use figure background of study participants form of symmetric encryption s3 obs.
matches s1 obs.
that of the so questions are about symmetric encryption.
since developers often need this task it is likely theywill have questions about how to accomplish it.
.
s4 general survey in our final study we surveyed java application developers who use cryptography apis.
this survey addresses all threeresearch questions posed in the introduction and validatessome of of our observations from the previous three studies.
.
study design survey design.
the following is the list of questions posed in the survey all mandatory .
during its design we usedour experience with the pilot survey from s2.
q same as section .
q q3 q4 same as section .
q but using percentage of development tasks instead of percentage of projects toavoid corner situations where the participant only workedon one project.
answering never here ends the survey.
q what are the most common cryptography related tasksyou need in your applications?
rank the tasks ... tasks identified from s2 store authenticate user login encrypt files secure connections and communications and transfer files securely .
additional tasks can be added through other fields.
note that the timeline of s3 and s4 overlapped which is why s3 tasks are not included here.
q did you use java cryptography apis before?
yes no.
answering no ends the survey.
q7 please rank the java cryptographic libraries apis below according to your frequency of use where is most used.
this question examines if most developers actually use the jca apis.
choices include java cryptography architecture jca apis irrespective of provider andlightweight bouncy castle apis .
additional apis can be added through other .
q8 thinking of your most used api q rank choice how would you rate its ease of use in terms of accomplishing your tasks correctly and securely?
very hard to use hard to use easy to use and very easy to use .
q9 what obstacles make it hard for you to learn and use features make it easy to use q rank choice ?
free text.
q10 thinking of when you have a new cryptography relatedtask to implement in your software e.g.
... do youever have di culties with the following?
short form of obstacle choices is shown in fig.
each with choicesnever rarely occasionally frequently and don t know.
note that we divide the obstacle previously used ins2 identifying which concepts and algorithms to use into two obstacles identify the correct algorithm e.g.
aes vs des to use and identify which concepts e.g.
encryption vs hashing to use .
q same as section .
q10 participant recruitment.
since there is no way of determining the whole population of developers who use javacryptography apis we used non probabilistic sampling .
we advertised the survey on our social media accounts and also asked colleagues to forward to any relevant java developers they know snowball sampling .
additionally we emailed developers who have committed to java files that use cryptography apis on github.
however we made sure that these developers do not belong to the projects weanalyzed in study .
data analysis.
fourty three developers completed the survey.
however during data analysis we removed six participants who indicated that they do not need cryptography in any of their development tasks q or have not used java cryptography apis before q .
we base our findings below on the remaining participants.
we used quantitative analysis for multiple choice and rating questions and qualitative analysis mainly open coding for free text answers.
each participant is assigned a code s4 p .
.
results participant background.
fig.
shows participants backgrounds.
for simplicity we group undergraduate and graduate students as student academic and industry researchers asresearcher and freelance developer and industrial developer as professional developer.
most participants are professional developers and only are students.the majority of participants have at least years of javadevelopment experience .
additionally the majorityof participants rated themselves as at least knowledgeableabout cryptography .
however most participants rarely need cryptography in their development tasks.
common cryptography tasks.
fig.
shows the most common cryptography tasks as ranked by participants.
figures 2a 2d show the four tasks we provide while fig.
2eshows the only free text task through the other fields that is mentioned by multiple participants.
note that percentages do not add up to since participants can leave a task without a rank if they do not encounter it in theirdevelopment tasks.
however they have to mark at least onetask i.e.
rank .
fig.
shows that securing connections and communications was the highest ranked task of participants rankedit as fig.
2c .
this is followed by authenticating users that is ranked by .
we also determined the average rank per task again assigning rank to any un94030 a store authenticate usernames passwords b encrypt file c secure connections communications d transfer files securely e other signing verifying data figure task ranking by study participants q ranked tasks.
this also gives preference to tasks that were ranked by more participants.
this results in the followingordered task ranking securing connections and communications avg.
rank .
participants authenticating users avg.
rank .
participants encrypting files avg.
rank5.
participants transferring files avg.
rank .
22participants and signing verifyinig data avg.
rank .
participants .
s4 obs.
the top three tasks needed by participants are securing connections and communications authenticating user logins and encrypting files.
additional tasks mentioned by participants in the other fields include checking licenses hashing generating and man aging keys and handling openpgp emails.
however eachof these tasks was mentioned only by one participant.
used java apis.
when ranking their most used java apis q7 of participants ranked jcaas while ranked bouncycastle as .
apart from spongycastle that was mentioned by two participants in the other field rank and rank additional apis listed by participants include j2me crypto apis ranked flexiprovider ranked keyczar ranked bcmail ranked and bcopenpgp ranked each mentioned only once.
s4 obs.
jca is the most used api rated by but developers also use other apis.
to analyze the ease of use ratings q we aggregated very hard andhard ashard andvery easy andeasy aseasy.w e found that of participants rate their commonly used library as hard to use including those who provided their own api at rank .
we could not detect any statistically significant relationship between the most used library and the ease of use rating chi squared test p value .
.
we also did not find a correlation between participants backgroundsand their ease of use ratings.
the occupation and level ofcryptography knowledge of the participants who found the apis hard to use was very diverse.
there were researchers professional developers ceo and technical evange list.
three of them were somewhat knowledgeable knowl edgeable and very knowledgeable about cryptography.
s4 obs.
irrespective of the library used and background of participants find the apis hard to use.
obstacles in hard to use apis.
we elicited obstacles from participants who find their most used library hard to use three participants put none or .
.
since we could not find a relationship between the library being used and the ease of use rating we collectively analyzed all listed obstacles.
out of the participants who provided feedback ten participants said that the api is not high level enough s4 p8 p12 p16 p19 p24 p27 p33 eight of which list it as their obstacle.
participantsmentioned that the apis are too complex even for basictasks.
for example s4 p24 says it s way too low level and modular.
most developers need simple high level abstractions not the complete toolbox with a wide variety of implementation.
nine participants mention poor documentation as one of their obstacles s4 p3 p7 p10 p16 p19 p23 p25 p31 with four rating it as .
most of these participants mentioned the lack of useful examples.
seven participants mentioned specific api design obstacles with three as their obstacle.
threeof those complained that debugging client code using the api and understanding the api error messages is di cult s4 p11 p23 p31 .
the others complained about not knowing which methods and parameters to use s4 p1 especially since there are misleading default values for algorithms methods e.g.
ecb mode as default s4 p3 as well as the lack of proper constants for algorithm names s4 p12 .
as one participant pointed out such thingsmake it easy to dangerous errors s4 p8 .
to illustrate these points consider how a symmetric encryption cipher is created cipher cipher cipher.getinstance aes .
note that the algorithm name i.e.
the cipher algorithm in this case is a string instead of a proper java constant aspointed out by s4 p12.
also note that an encryption cipher needs both a mode and a padding scheme to function properly.
when no mode is provided as in the code above thestandard provider defaults to the insecure ecb mode as discussed by s4 p3.
finally as s4 p1 pointed out devel opers must understand which modes and padding schemes are secure in order to correctly pass them as parameters to the algorithm.
this is actually a mix of an api use problem as well as domain knowledge.
developers must know the state of the art in proper security domain knowledge and must know how to pass these parameters to the appropriate method calls api use .
the remaining participants s4 p28 p35 p36 mentioned class loading issues missing functionality in the apiwhich means resorting to additional libraries and the fact that it is very time consuming to understand the api.
s4 obs.
participants main obstacles are lack of high level apis poor documentation and bad api design e.g.
misleading defaults di cult debugging .
identify correct algmidentify crypto conceptsidentify java apisetup environmentidenitify sequence of api callsidentify parametersindentify providerunderstand api implementationunderstand error msgsnumber of participantsfrequently occasionally rarely never don t know figure obstacles rated by study participants features of easy to use apis.
similar to robillard and deline we did not find the feedback on positive api features helpful.
since many participants only provided genericanswers such as good api or put periods as answers we could only meaningfully evaluate seven answers.
surprisingly six of these participants mentioned completeness levelof abstraction documentation and clean api endpoints aspositive features s4 p9 p13 p17 p21 p37 .
the seventh participant s4 p29 mentioned that it is a matter of a steep learning curve rather than being generally hard.
rated obstacles.
we first checked if there is any correlation between the ratings of di erent obstacles using a spearman correlation test.
we found statistically significant strongcorrelations .5or .
and p value .
between the ratings of four pairs of obstacles identifyingthe api to use and setting up the environment .
identifying the api to use and identifying the providerto use .
setting up the environment and understanding the underlying implementation .
and identifying sequence of method calls and identifying pa rameters .
.
we interpret these strong correlations as follows.
for the first and second pair identifying the api to use is usually followed by setting up the environment and determining which provider to use.
thus the three obstacles can be seen as part of the startup process.
the fourth cor relation suggests that it may be the case that developers donot distinguish between troubles with method call sequences and those with the parameters to provide.
we cannot find a reasonable explanation for the third correlation but we note that the correlation coe cient is not that much higher than the threshold.
all other obstacles were weakly correlated suggesting that participants view them as distinct obstacles.
despite the correlations mentioned above we still looked at all the rated obstacles since they present potential fea tures that future solutions should include.
fig.
shows howoften participants face the obstacles we asked them about.
darker colors show more frequently faced obstacles.
the figure shows that identifying the correct sequence of methodcalls is the most frequent obstacle .
this is followedby understanding the underlying api implementation and identifying the parameters to use .s4 obs.
the most frequently faced obstacle is identifying the correct sequence of method calls frequentlyfaced by followed by understanding the under lying api implementation and identifying the parameters to use both frequently faced by .
none of the participants including those with limited cryptography knowledge marked identifying which concepts to use as a frequent obstacle second column of fig.
.
infact of the participants said they never face such anobstacle.
however the first column also shows that ofparticipants cannot at least occasionally identify the correct algorithm to use.
this suggests that most participants know which area of cryptography to use but may not always be sure about the trade o s between various algorithms.
s4 obs.
of participants never have problems identifying relevant cryptography concepts but cannot at least occasionally identify the correct algorithm to use.
note that a chi squared test of independence showed no statistically significant relationship between participants back grounds or their most used api and their obstacle ratings.
desired support.
twenty seven participants provide suggestions for how to improve cryptography use in java.
weidentified three general categories for the suggestions different api design participants better documentation participants and tool support participants .
we also categorized parts of the feedback we got from three partic ipants as other since the suggestions were specific feature requests such as improving certificate creation.
in terms of api design nine participants mentioned words such as use cases task based o rhigh level design.
s4 p24 comments that cryptographic libraries should be reserved to people who implement protocols.
the average software developer writing an application needs something much higher level.
.
along the same lines s4 p6 asked for libraries that simple api calls one or two methods and simple parameters for di erent use cases .
s4 p27 echoed that by suggesting having higher level task oriented apis for things like public key crypto key exchanges secure local storage .
s4 p10 commented that the ability to 942simple cryptographic tasks in java without jumping through hoops would be brilliant.
participants also said that the api documentation can generally improve with more examples.
finally some participants provided tool based suggestions such as having a cryptodebugger s4 p11 cryptography aware testing tools s4 p13 s4 p17 analysis tools that identify where cryptography protection is needed and find configuration mistakes and weak algorithms s4 p17 and code templates or fac tories for common tasks s4 p7 s4 p9 through code gen eration ide plugins s4 p6 .
s4 obs.
participants suggest task based solutions whether in the form of better api design examples indocumentation or analysis and code generation tools.
.
discussion .
putting it all together rq1 what obstacles if any do developers face during the use of java cryptography apis?
our results confirm that developers face obstacles while using the apis.
first of s4 participants found the apis hard to use s4 obs.
and s2 participants also spend a considerable amount of time reading resources s2 obs.
.
specifically developers haveproblems determining the correct sequence of method calls because apis are too complex to use s1 obs.
s2 obs.
s2 obs.
ands4 obs.
.
s1 showed that another obstacle faced by developers is lack of domain knowledge s1 obs.
.
however based on s4 obs.
we speculate that the problem here often lies in determining the right algorithm to use rather than which general area of cryptography is needed.
another obstacle that appeared in both s1 and s4 isunderstanding the underlying api implementation s1 obs.
s4 obs.
.
finally developers seem to have problems in correctly setting up their environments to use the apis supported by both s1 obs.
and the fact that of s4 participants frequently face this obstacle .
rq2 what are the common cryptography tasks developers need?
the three most common cryptographic tasks those highly rated or mentioned frequently in more than one study are storing and authenticating user login s2 obs.
s4 obs.
securing connections and communications s4 obs.
and di erent forms of symmetric encryption s1 obs.
s3 obs.
s4 obs.
.
rq3 what tools or ideas would help developers use cryptography more e ectively?
participants of both surveys advocated for more task based solutions whether in the form ofbetter example based task based api documentation s2 obs.
s4 obs.
higher level abstractions of apis s2 obs.
s4 obs.
or tools that catch common mistakes or generate code templates s4 obs.
.
.
moving forward based on our findings we see three directions for moving forward.
the first is naturally to improve api documentation.
since this relies on the api creators themselves we do not currently see a way to enforce this.
other documentation related solutions include those that synthesize code examples for specific apis or those that try to present the existing documentation and online resources in ways more useful to developers e.g.
.the second is to encourage api designers to hide some of the unnecessary details and provide their clients with more high level or task based method calls.
this was something suggested by more than one participant.
there are several libraries some non java trying to achieve this e.g.
nacl keyczar .
we also do not see this as some thing that can be enforced but at least guidelines can bedeveloped to help api designers achieve this.
the third solution removes the dependency on the api designers by building automated support tools on top ofthe apis.
based on the suggestions we got task based code generation tools are one example of such tools.
other examples are analysis or debugger tools that warn users or help them debug cryptography vulnerabilities.
based on ourfindings we suggest the following list of task based toolfeatures that we encourage future tool or solution designersto consider.
however we do not currently know the relative importance of these features.
support at least the following tasks storing and authenticating user login securing connections and communications and symmetric encryption.
given a particular cryptography task identify the relevant library to use.
setup the identified library correctly including providers .
identify the correct algorithm to use.
identify the correct algorithm settings to use.
identify the correct sequence of api method calls andtheir appropriate parameters.
given a piece of code that uses cryptographic apis iden tify any potential vulnerabilities.
given a piece of code identify where cryptographic pro tection might be needed.
.
threats to validity s1 and s3 relied on manual analysis of posts and code.
the observations we make are of course subjective.
in s1 we mitigated this risk by having two of the authors analyzethe posts and discuss any discrepancies.
in s3 due to the higher analysis time cost the projects were equally divided among two of the authors providing us a mix of di erent interpretations.
we also published our coded dataset on our artifacts page to facilitate replication or further analysis.
the number of participants of s2 is fairly limited.
even though the results of the study provide interesting insights we do not base any conclusions on s2 alone unless confirmed by at least one other study.
the participants of s4 may not be completely representative of the whole population due tothe non probabilistic sampling we follow which subjects the study to non response bias.
however since our population is very specific developers who use java cryptography apis and our participants have a diverse background in both javaand cryptography experience we believe our observationsare still relevant to the larger population.
since our findings only accurately reflect the opinions of our participants we encourage other researchers to conduct similar surveys on aneven larger scale.
additionally our survey did not includeanyone without any cryptography knowledge.
we did not intentionally filter such participants during recruitment or during analysis.
however since we were recruiting develop ers who already used the java cryptography apis it is very unlikely that any of them would still have no cryptography knowledge.
the list of libraries presented to participants in 943s4 q is not comprehensive.
however our experience analyzing posts in s1 suggests that the two libraries we listed there are the most popular ones.
we also allowed participants to add their own libraries.
this additional list of libraries identified can be used to guide future studies.
our findings may su er from confirmation bias.
in our previous work we presented a possible solution to help developers use java apis more securely.
it may be the case that we subconsciously tried to confirm our prior beliefs.however we argue that this is not the case since many ofour prior beliefs are not confirmed by our studies e.g.
difficulties in di erentiating between cryptography concepts .
additionally we found several new tasks e.g.
securing connections and tool requirements e.g.
setting up the envi ronment and identifying missing cryptography protection incode that we did not previously consider.
.
related work misuse of cryptographic apis.
researchers have already established many security vulnerabilities due to incor rect usage of cryptography apis.
lazar et al.
manuallyinvestigated published security vulnerabilities and found that of them are caused by misuse of cryptographic libraries.
egele et al.
statically analyzed androidapps for api misuse and found that of these apps fact violate at least one of six basic cryptography rules.
similarly fahl et al.
also found that ssl api misuse causes many android apps to be vulnerable to man in the middle attacks.
georgiev et al.
show that even majorweb applications misuse ssl certificate validation libraries allowing the authors to extract sensitive information such as credit card numbers.
most of the solutions suggested by these papers focused on preventing consequences ratherthan addressing the underlying problem of api misuse.
anexception is our previous work that proposed a tool to address api cryptography misuse.
however the tool does not include all features identified in section .
and we did not empirically validate the claims on which we design it a gap that is filled by the studies in this paper where we exam ine the actual causes of misuse from a developer perspective.
assessing general api usability.
robillard and deline surveyed and interviewed microsoft developers tounderstand their api learning obstacles.
they found that poor documentation is a major learning obstacle.
our work here is di erent in that we only focus on one api category namely java cryptography apis with the goal of finding ideas and requirements for solutions not necessarily in theform of better documentation that may help application developers use cryptography more easily and securely.
moreover we are not limited to views from one company.
the work by zibran et al.
also tried to identify api usability factors.
they manually analyzed bug reports of four projects to identify feedback given by its api users.
hou and li also used some manual analysis similar to theone we use in s1.
however they focused on the newsgroupforum of a particular api namely swing.
while we use so in s1 and use a di erent classification scheme that emerged during open coding some of the obstacles we find are similarto theirs e.g.
wrong environment configurations .
roover et al.
also explored how certain apis are used in a large project corpus with the goal of providing insights to both api designers and api users.a main advantage of our work is that we do not rely on one source of information but rather combine three di erent sources so github projects and developer surveys .
api documentation.
researchers also looked at how to assess and improve api documentation since it was often identified as a usability obstacle.
this included identifyingdocumentation issues through surveying industrial developers identifying relevant documentation parts given a particular api element and developing a taxonomy ofapi documentation knowledge patterns that can be used by practitioners to evaluate their own api documentation .
it has also been established that crowd sourcing sites such as so provide a rich documentation for many apis .
api usage protocols.
sunshine et al.
focused on api usage protocols restrictions on the order of api calls .
similar to our s1 they also relied on so but looked for questions that are specifically related to usage protocol restrictions.
similarly saied et al.
observed how four types of api usage constraints are exhibited in several apis.
whilesuch usage restrictions are not our main focus such studies complement ours and understanding api usage restrictions can alleviate developers di culties in identifying the correct sequence of method calls to use.
proposed solutions there have also been other solutions to help both api users and designers such as informing api designers of common problems with their api or recommending the relevant libraries to use for applica tion developers .
treude et al.
also recently propose the idea of task based documentation navigation.
they extract tasks from documentation as well as their related codeelements.
our findings support that tasks are e ective inhelping developers use an api.
we also empirically identi fied the cryptographic tasks relevant to developers.
finally many solutions are based on synthesizing relevant api usage examples.
we point the reader to the survey by robillardet al.
that summarizes the techniques used in this area.
.
conclusion many security vulnerabilities are caused by developers incorrect use of cryptography apis.
however it is not clear what obstacles such developers face when using cryptography in their applications.
we reported on an empirical study to investigate such obstacles in the context of java through examining questions on stackoverflow github repositories and two surveys of a total of developers.
our findings showed that developers do indeed face di culties in using the java cryptography apis.
we found that developers com monly need to authenticate users and store login data toestablish secure connections and to encrypt di erent forms of data.
in our surveys developers indicated that the exist ing apis are too low level and asked for task based solutions whether in the api design documentation or through assis tance tools.
based on these observations we recommended a list of features that such solutions should include.
this list can guide future tool and solution designs.
.