generating test cases to expose concurrency bugs in android applications hongyin tang guoquan wu jun wei hua zhong state key laboratory of computer sciences institute of software chinese academy of sciences china tanghongyin14 gqwu wj zhongh otcaix.iscas.ac.cn abstract mobile systems usually support an event based model of concurrent programming.
this model although advantageous to maintain responsive user interfaces may lead to subtle concurrency errors due to unforeseen threads interleaving coupled with non deterministic reordering of asynchronous events.
these bugs are very difficult to reproduce even by the same user action sequences that trigger them due to the undetermined schedules of underlying events and threads.
in this paper we proposed racerdroid a novel technique that aims to expose concurrency bugs in android applications by actively controlling event schedule and thread interleaving given the test cases that have potential data races.
by exploring the state model of the application constructed dynamically our technique starts first to generate a test case that has potential data races based on the results obtained from existing static or dynamic race detection technique.
then it reschedules test cases execution by actively controlling event dispatching and thread interleaving to determine whether such potential races really lead to thrown exceptions or assertion violations.
our preliminary experiments show that racerdroid is effective and it confirms real data races while at the same time eliminates false warnings for android apps found in the wild.
categories and subject descriptors d. .
testing and debugging keywords record replay data race mobile application android testing.
.
introduction android devices currently lead the smartphone marketplace.
as of may there are more than .
million android apps available from google play store.
the widespread use of these devices poses great demands on the quality of the apps.
however as both android platforms and the accumulated developers are still immature compared to old areas of computing e.g.
desktop and server software meeting these demands is still very challenging.
a primary feature of mobile applications is their event driven nature the application must handle asynchronously generated events from a diverse set of sources including user interface sensors network and the framework to maintain responsive user interfaces.
unfortunately this asynchrony can cause harmful bugs due to data races that will potentially corrupt the overall application behavior or change the intended semantics of the application.
such concurrency bugs are often difficult to find and debug as they can only be manifested under very specific events scheduling and threads interleaving.
to detect such harmful behaviors researchers have recently devised program analyses aiming to automatically discover concurrency errors due to data races.
for instance cafa identifies user after free violations a typical of kind of concurrency bug based on the proposed causality model to infer happen before relations between events.
eventracer for android for brevity we will refer it as eventracer since the scope of this paper is android apps proposes a scalable race detection algorithm for android applications which finds data races based on a precise happen before model of android concurrency.
deva is static analysis technique to detect event anomaly two or more events access the same memory location and at least one is write access in event based system.
asynchronizer a refactoring tool that aims to extract long running operations into asynctask also provides a static race detector which can identify the potential data races existed in asynctask.
despite recent advances these techniques still often report many data races that are false warnings.
for example eventracer reports data races for flick uploader app out of which only are harmful.
moreover being imprecise in nature most of these tools require manual inspection to see if a race is real or not which is difficult and time consuming especially for inexperienced developers.
nevertheless these tools are very effective in finding data races because they can predict data races that could potentially happen during a real execution in case of static race detection or they just need to see one real concurrent execution in case of dynamic race detection.
in this paper leveraging potential data races reported by existing static dynamic race detection technique we proposed racerdroid a new technique to assist developers to verify whether reported data races can really lead to concurrency errors by generating a test case and rescheduling test case execution under specific interleaving of the threads or the reordering of asynchronous events.
specifically racerdroid designs a lightweight scheduler by adapting existing android testing framework to actively control event schedule and thread interleaving to expose real race condition with high probability and confirm the concurrency bug by determining whether the detected races could cause a thrown exception or assertion violation.
the technique works as follows racerdroid first uses an existing static or dynamic race detection technique to compute a set of statement pairs that could potentially race in a concurrent execution.
then based on the constructed state model of the app racerdroid generates a test case automatically which will corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
execute the statement pair that has potential data race.
racerdroid will replay the test case with a different schedule by interleaving threads or reordering events based on the proposed lightweight reschedule technique.
such alternative schedule can help racerdroid to find whether a thrown exception or assertion violation can occur due to data race.
generally racerdroid has the following useful features l it exploits the results reported by existing static dynamic race detection technique to generate a test case automatically that will contain potential data race based on the state model of the app constructed dynamically.
l it designs a lightweight rescheduling technique which can actively control test case execution by adapting existing android testing framework.
l leveraging test oracles contained in the test cases it can expose some semantic race errors which will not crash the app but only violate the semantics of the application.
.
background on android android application organizes its logic into activities each representing a single screen of ui.
an activity contains widgets that users can interact with which can be buttons text boxes and number pickers etc.
similar to many typical gui frameworks such as swing and swt android applications are largely event driven.
events in android include user actions lifecycle events sensor events etc.
for each kind of events the framework provides corresponding callbacks and developers can implement their own callback to respond to these events.
for example oncreate callback is invoked when an activity is created onclick callback of a button is executed when a button is clicked and onlocationchanged callback will be triggered when physical location changes.
android framework orchestrates app control flow by invoking user provided callback in response to various user and system events.
it uses a single thread model to process events by default.
when an application is launched the system will create a main thread also called ui thread which is charge of dispatching ui events to appropriate widgets or lifecycle events to activities.
however if main thread executes cpu intensive work or blocking i o calls such as network access or database queries the application will be blocked until the corresponding operation has finished.
to avoid unresponsiveness and provide a good user experience all potentially slow running operations in an android application should run asynchronously.
android also supports multi threads.
in android each thread may be associated with an event queue by attaching looper object which has a messagequeue .
threads can communicate by posting events to each other s event queues and a thread can also post an event to its own queue.
for each thread with a queue it runs in a loop processing events from its event queue in the order of their arrival.
when the queue is empty the thread will block.
event handling is atomic and no other message processing routine can be started until current one completes.
threads can also communicate with each other via shared memory which is the same as in traditional java programming.
in android s concurrency model each application process has a main thread and only the main thread can access gui objects to prevent nonresponsive threads from blocking ui.
to update ui non main threads can send messages to ui thread.
the main thread will attach a looper object automatically when the app launches.
we refer to any thread that has an attached looper as looper thread.
in addition to looper thread android also supports two other kinds of threads binder thread and background thread.
the former is created as thread pools and mainly used for inter process while the latter are the result of a regular thread fork .
to ease the use of concurrency android provides additional constructs such as handler and asynctask class to perform asynchronous processing.
handler class can be used to register to a thread and provides a simple channel to dispatch event to the main thread.
asynctask is a high level abstraction for encapsulating the creation of a background thread and the synchronization with the main thread.
it also provides some callbacks such as onpostexecute that will execute on the main thread when the task has finished.
.
approach overview the goal of our approach is to verify concurrency bugs from the potential data races identified by existing static or dynamic analysis technique such as eventracer or deva .
we also assume these potential races are reported with the format sharedvar act1 task1 statement1 act2 task2 statement2 which means that execution sequence of task1 in act1 and task2 in act2 is non deterministic both statement1 executed in task1 and statement2 executed in task2 have accessed shared variable sharedvar and at least one is write access.
here task1 task2 can be the callback function for asynchronous events or the running method for the background thread.
for the former act1 act2 can be the components e.g.
activity service in android applications and they usually refer to the same one if act1 and act2 are both activity.
for the latter act1 act2 is android component that creates the background thread.
statements statement1 and statement2 are also called as statement pair in the following.
fig.
shows the overall process of our approach.
generally it consists of two steps test case generation and test case replay.
the aim of first step is to generate a test case that contains potential data race and the second step tries to confirm whether the data race can lead to thrown exception or assertion violation hence it is a concurrency bug by rescheduling underlying events and threads during the test case replay.
in the following we elaborate these two steps.
fig.
overall framework of racerdroid .
test cases generation gui exploration.
based on reported potential data races racerdroid first tries to find a path user action sequence that can trigger the execution of statement1 and statement2 leveraging the state space model of the app.
one can construct this model based on dynamic analysis such as the work or static analysis such as the work .
racerdroid chooses to build this model dynamically.
currently we are developing a crawling tool which aims to explore the application and construct the state space model of the app.
app.explorerpotential data racesrescheduleassertion violation exceptioninstrumentationinstrumented app test case 649different from existing exploration techniques for android applications we leverage existing test cases of the app to first construct the partial model of the app which contains useful user input and test assertion information .
based on this partial model crawler then continues to explore the remaining states of the app which is similar to the work done for the web application.
note that besides the activity the model will also contain information such as when service component is created e.g.
after user clicks ok button .
to support this racerdroid will instrument start stop method of service component to notify the crawler when the service is started stopped.
the model also contains lots of useful information e.g.
each state contains the widgets available in current screen that can direct test case generation.
furthermore in the model states activities may have some test oracles obtained from existing test cases which can be used to detect whether the potential data race can leads to some semantic errors that will not result in thrown exception but change the intended semantics of the app .
test case generation.
racerdroid then generates a test case that executes statement1 and statement2 by dynamically exploring the application based on the constructed state space model.
before exploration racerdroid will instrument statement statement1 and statement2 firstly.
when both statement1 and statement2 are executed exploration will stop.
for the race reported by the dynamic race detector it is possible that statement1 statement2 is accessed in the framework e.g.
eventracer reports some such races .
in this case racerdroid will instrument the statement located in the user code that invokes statement1 statement2 by analyzing its call context if the report provides such information.
otherwise racerdroid will seek to determine whether the corresponding task is executed.
to do this racerdroid will also instrument the callback of task1 and task2.
another function of instrumenting the callback is that racerdroid needs to log the execution sequence of two tasks in this step which will be alternated during the test case replay.
note that racerdroid avoids instrumenting the statement located in the framework as we aim to make our technique easily run on any android devices.
to find such user action sequence quickly racedroid first computes a path from main activity to target activity which is or contains act1 act2 by querying the state model of the app.
it then fires the actions along the path to arrive the state act1 and act2.
after that crawler systematically explores the widgets in current active activity and fires various user actions on the widget to trigger statements that have potential data races.
during exploration if one statement or both of them are triggered after firing a user action racerdroid will check whether test oracle assertion is violated in current state if it exists.
it is possible that assertion is violated as the content of corresponding widget specified in the assertion changes e.g.
server updates the content frequently .
in the case of violation racerdroid will update the assertion with new value obtained from the corresponding widget which will then be added into the generated test cases.
explorer will also take a screenshot for current active activity which can be compared with the corresponding one taken during the test case replay to assist developers to locate inconsistency between two activities quickly.
after exploration completes based on fired user actions crawler will generate test cases expressed in android espresso or robotium testing scripts automatically which will be replayed in step .
when explorer reaches the target activity besides triggering the user action bound to the widget it will also fire some actions that android system provides to trigger some lifecycle events.
for example it can send back or rotate action to trigger pause stop destroy event and send lock wakeup and swipe the screen to return to the app to trigger restart event which also trigger pause stop .
for the lifecycle events create pause resume they will be sequentially triggered when the explorer enters into the target activity.
it is possible that existing static race detection technique will report some races if the callbacks of two different user actions both access the shared variable racerdroid does not consider it as a concurrency bug as the input user action sequence needs to change to generate the expected execution.
for the same reason racerdroid also does not generate test case for the reported race in which two tasks are both lifecycle events e.g.
onpause onresume of the same activity.
api interception.
during test case generation the application may interact with the server communicate with other app using intent and invoke sensor services and random function.
to assure input determinism during the test case replay and avoid false assertion violations racerdroid also instruments the app by intercepting various apis of sensor services network intent and random function to cache the sensor data network request response intent result and random number.
these data will be directly sent back to the app when the test case is replayed.
.
test case replay in this step the test case generated from step will be replayed with alternative schedule to expose concurrency bug and eliminate some false warning at the same time.
racerdroid leverages existing android testing framework e.g.
robotium espresso to execute test cases.
to control event schedule and thread interleaving during test cases replay racerdroid modifies the testing framework to access the message queue of app s ui thread.
therefore it can monitor and control the event dispatching process e.g.
postpone one event until another event has been handled .
to control the execution of background thread racerdriod instruments app by inserting synchronization primitives at the position where synchronization needs to be done.
in the following we describe how racerdroid controls event schedule and thread interleaving to expose concurrency bugs.
if statement1 and statement2 are both invoked in the callback of task1 and task2 with the sequence task1 task2 in the phase of test case generation racerdroid will alternate their execution by suspending task1 if it occurs before task2.
after task2 is dispatched racerdroid will continue to dispatch task1 and the following events in the queue.
note that it is possible that if task1 is not dispatched task2 will not appear in the queue which means task2 is registered during the execution of task1 .
in this case task1 and task2 will have deterministic execution in this test case.
however it only means that statement1 and statement2 have no data race in the test case under consideration.
to further verify this potential data race racedroid can go back to step and find another different user action sequence that callback task1 and task2 are invoked.
if such path can be found racerdroid will go to step to replay the new test case to try to expose the bug.
if all the test cases found by racerdroid cannot produce the alternate event schedule racerdroid concludes that this potential data races is a likely false positive.
racedroid cannot provide a definitive verdict on whether the race is a false positive or not because there might exist some other execution in which the purported false positive proves to be a real race.
if statement1 is invoked from background thread and statement2 is invoked from event s callback vice versa racerdroid will instrument app by first inserting synchronization primitives for 650statement1.
during the replay racerdroid can alternate their execution by controlling event dispatching and thread execution.
it s also possible that background thread is started in the callback of statement2.
in this case reschedule will fail.
however as the background thread can interleave with the callback execution in android racerdroid can insert synchronization primitives for the statement2 in the callback of task2 to confirm whether it is really a concurrency bug.
if statement1 and statement2 are both invoked through background thread racerdroid just needs to instrument app to add synchronization primitives for two statements and alternates the execution of two background threads during the replay to expose a concurrency bug.
during the replay if app crashes or a thrown exception is caught a race bug can be verified.
however some race bugs will only change the intended semantics of the application.
for example in work the authors conclude one such kind of data race caused by object reuse.
to confirm these bugs racerdroid relies on the assertion existed in the test case and if assertion is violated a harmful race bug is detected.
if no assertion exists racerdroid will compare two screenshots of the same activity captured during test case generation and test case replay by using image difference algorithm such as perceptual image differencing pid a computer vision technique to find visual difference.
if no difference is found racerdroid can determine that the reported data race is harmless.
otherwise it will provide the corresponding screenshots to developer and let the developer decide whether the race bug is harmful or not.
.
implementation racerdroid needs a model of the app to generate a test case that contains the potential data race.
currently we are developing a crawling tool that aims to explore the app systematically to construct its state space model leveraging existing test cases.
to facilitate developers to write test cases we also developed an app based on accessibility api that android provides which can record user actions when user interacts target application through this app.
it also provides the function that allows user to insert assertion e.g.
text assertion during the interaction with the app.
to simulate back rotate lock wakeup and swipe screen actions during the test case generation racerdroid relies on uiautomator to send corresponding commands which will trigger stop destroy restart lifecycle events.
to control event schedule currently racerdroid modifies the android espresso testing framework to control event dispatching for the events placed in the queue.
when the test case is running espresso gets the event queue of the main thread using the java reflect mechanism and then dispatch the events to their target handlers so that the events would not pass the loop method of looper object defined in the android framework.
in this way racerdroid can postpone the dispatching of the event that it is interested in and then resume the execution of this event after another event in the reported race has been handled.
to control the thread interleaving in the app racerdroid uses semaphores to synchronize the execution between different threads including ui thread and background thread .
instrumentation also plays an important role in racerdroid.
it needs to instruments app to obtain the casual relation between the activities with the underlying services during the construction of the state model of the app.
during the test case generation app needs to be instrumented to capture various sensor inputs and network activity which will be sent back during the test case replay.
in addition the semaphore that is used to schedule the threads interleaving also needs to be inserted.
to implement the instrumentation racedroid first disassembles dalvik bytecode to smali code and then inserts the instrumentation code.
at last assemble the smali code back to the dalvik code and repackage it to the apk.
racerdroid will then run the instrumented app installed on the devices and perform steps described in section to expose concurrency bugs.
.
case studies as an instructive case study we investigate a race bug in the mytracks app which is an application used to track the location of the user.
this race bug is reported in work .
the example in fig.
shows the segment codes that are related to this race.
in the activity mytracks when user presses the button to start a track recording startrecording callback will be invoked which starts and binds trackrecordingservice service.
as soon as the service is ready an event would be sent to the queue of ui thread and onserviceconnected callback will be executed when this event is dispatched which calls startnewtrack of trackrecordingservice through ipc mechanism.
when user stops recording stoprecording callback will be invoked which stops and unbinds trackrecordingservice.
this procedure will invoke ondestroy asynchronously that set the providerutils to null.
in normal execution ondestroy will be invoked after startnewtrack .
however there exists a situation that is contrary to the normal execution.
due to trackrecordingservice is started and stopped asynchronously startnewtrack may still not be executed while ondestroy is performed and an exception is thrown when startnewtrack is invoked.
this data race is expressed as providerutils mytracks onserviceconnected providerutils.updatetrack track trackrecordingservice ondestroy providerutils null in racerdroid.
here onconnectedservice and ondestroy are two asynchronous tasks located in mytracks activity and trackrecordingservice service respectively.
when onconnectedservice is scheduled it will execute statement providerutils.updatetrack track and when ondestroy callback of trackrecordingservice is scheduled statement providerutils null will be executed.
obviously a null pointer exception will be thrown if ondestroy is executed before onconnectedservice .
fig.
code segment of mytracks table .
results of case study subjects components of potential data races tp fp tp manual fp manual todowidget colorcirle connectbot hosteditoractivity hostlistactivity pubkeylistactivity terminalmanager anymemo downloaderanymemo mytack mytracks trackrecordingservice oi file manager filelistmanager as our test case generation tool is still developing in order to confirm this potential data race we first generate a test case manually that will trigger these two callbacks.
fig.
shows the corresponding test case.
it first presses menu button to show the options menu on the screen and starts recording by pressing the record button.
then the test case calls the options menu again and presses the button to stop recording.
at last it saves the recording.
when this test case is executed without controlling schedule onserviceconnected will be invoked before ondestroy with high probability.
therefore no exception will be thrown.
during the test case replay when onserviceconnected is monitored to be scheduled racerdroid will suspend its dispatch by removing it from the queue.
after ondestroy callback of service trackrecordingservice is scheduled racerdroid will then resume the execution of onserviceconnected task.
in this way this concurrency bug is guaranteed to produce.
fig.
.
test case of mytrack we also perform racerdroid on several other open source applications to evaluate the feasibility of the technique.
we select some race bugs reported from the existing works .
then we generate a test case for each potential data race and run them by our scheduler.
the result is shown in table more details can be found in for each application the table shows the number of potential data races that we selected.
it also shows the components where these races are located.
each test case contains user actions.
tp shows number of harmful races that are confirmed by racerdroid.
fp shows the number of likely fp that cannot be confirmed by racerdroid.
we also manually check these potential races.
the last two columns tp manual fp manual show the number of real bugs false warnings by manual analysis respectively.
as result shows all the real races reported by racerdroid are also confirmed by manual analysis and the likely false warnings reported by racerdroid are also true.
based on these initial case studies we can conclude that racerdroid is feasible and can assist developers to verify potential data races automatically.
.
related work numerous techniques and tools have been developed to support software testing and race detection of mobile apps and we here discuss the most closely related work.
.
data race detection and testing many studies have been done in the literature to detect data races either statically or dynamically .
however these techniques are mostly designed for thread based programs and usually work poorly for event based programs.
recently some works start looking at race detection techniques for event based programs especially web applications and mobile applications.
webracer and eventracer for web app are two recent studies focusing on detecting races in web applications.
a web application is typically executed in a single thread by the browser in an event driven style.
these works have shown that even if there is only one thread executing races are still possible.
to detect such type of races happen before relation causality for web application is redefined and lots of data races are found in many popular web sites.
targeting mobile applications cafa focuses on detecting race errors that lead to user after free violation based on the casual order due to the event sequences.
droidracer is also a dynamic analysis technique for race detection in android application based on a formal semantic model for android concurrency.
eventracer is a scalable race detection technique for android application which proposed a fast algorithm to build and query happen before graph.
it also reports fewer false positives by using some domain specific filters.
deva is a static analysis race detector for automatically detecting event anomalies in event based systems including mobile applications which can handle the semantics of implicit invocation ambiguous interface and implicit concurrency.
asynchronizer is an automated refactoring tool which assists developers to extract long running tasks into asynchronous task.
it also provides a race detector specialized for asynctask which can detect the potential data races in asynctask after refactoring.
recently a couple of random testing techniques for concurrent programs have been proposed which systematic explores the alternate schedules of threads.
one limitation of applying such technique to android applications is that test cases may contain lots of alternate schedules and most of them have no data races.
exploring these schedules blindly will consume a lot of test resources.
our work is inspired by the racefuzzer which aims to multi thread applications and use potential data race information obtained from existing dynamic analysis technique to control a random scheduler of threads which can create real race condition with high probability.
.
gui model for android racerdroid depends on a state space model to generate a test case automatically.
there are some related works that aim to explore the app systematically.
a3e is an automated gui exploration tool for android applications which can explore the app running on the actual devices.
specifically it proposes a targeted exploration strategy which supports fast direct exploration activities based on a statically constructed high level control flow graph.
swifthand uses machining learning to learn a model of the app uses the learned model to generate user actions that visit unexplored states of the app and uses the execution of app to refine the model.
a key feature of swifthand is that it can avoid restarting the app.
652the state model can also be built statically.
for example yang et.al build a gui model of the android applications using context sensitive static analysis of callback methods.
in they further proposed static window transition graph a comprehensive model which represents the possible gui window sequence and their associated events and callbacks.
.
record replay android application our work is also related to record replay technique proposed for android application.
reran supports to record replay sophisticated gui gestures without requiring to access to app source code.
valera captures network activity inter app communication sensor inputs by api interception and event schedule by modifying android framework to achieve high accuracy replay.
racerdroid also uses api interception to capture network activity and various sensor inputs.
the difference is that racerdroid does not need to modify android framework and it can reschedule the execution of user action sequence test case by just adapting existing android testing framework.
.
conclusion and future work in this paper we introduced a new technique for generating test cases to verify concurrency bugs reported in android applications re.
in our initial case studies the approach exposes of the concurrency bugs from the given potential data races reported by existing static dynamic race detector.
overall these preliminary results are promising and indicate the feasibility our approach in being able to assist developers to automatically confirm the concurrency bugs.
in the future work we will first complete the implementation of our test case generation tool.
we will also conduct more comprehensive studies to evaluate the effectiveness and efficiency of our approach.
.
acknowledgement this work is supported by national natural science foundation of china under grant no.
national basic research program of china under grant no.
2015cb352201 and national key technology r d program under grant no.
2015baf05b01.
.