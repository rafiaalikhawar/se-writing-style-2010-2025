model checker execution reports rodrigo casta o victor braberman diego garbervetsky sebastian uchitel departamento de computaci n fceyn uba conicet buenos aires argentina rcastano diegog vbraber suchitel dc.uba.ar abstract software model checking constitutes an undecidable problem and as such even an ideal tool will in some cases fail to give a conclusive answer .
in practice software modelcheckers fail often and usually do not provide any information on what was effectively checked.
the purpose of this work is to provide a conceptual framing to extend software modelcheckers in a way that allows users to access information about incomplete checks.
we characterize the information that model checkers themselves can provide in terms of analyzed traces i.e.
sequences of statements and safe cones and present the notion of execution reports ers which we also formalize.
we instantiate these concepts for a family of techniques based on abstract reachability trees and implement the approach using the software model checker cpachecker .
we evaluate ourapproach empirically and provide examples to illustrate the ers produced and the information that can be extracted.
i. i ntroduction software model checking constitutes an undecidable problem and as such even an ideal tool will in some cases fail to give a conclusive answer.
but the limitations are also practical.
the vast state spaces can lead to the exhaustion of system resources or impractically long execution times.
software model checking has been making steady progress during the past decade and today s state of the art softwaremodel checkers can handle specific industrial problems par ticularly well.
for instance sdv is highly successful in finding bugs in windows device drivers.
unfortunately some instances take hours of computation only to inform the user that no counterexample was found within the allotted time or memory limit.
a user facing this situation is confronted with several high level questions about what the verification attempt actually achieved.
should she retry with a longer time limit?
how much longer?
is the tool making progress?
maybe she should try another technique?
our goal is to extend and complement existing work on partial verification by providing a different way for users to observe the work performed by the software model checker.
an important step towards our goal is to be able to answer much simpler inquiries about incomplete verification attempts.
we believe answering the following questions would be valuable for a user after an inconclusive verification attempt can partial safety assurances about the system be extracted from an incomplete verification attempt?
for instance a user that receives a report showing that a whole class of relevant behaviors has been exhaustively checked may use this as part of a dependability case.
can behavior that was not analyzed be explored by a user?
for instance a user that can observe that relevantclasses of behavior have not even been looked at by the checker let alone verified may decide that what seemed like a sufficiently thorough analysis is not such e.g.
an inexperienced user would benefit from knowing that a tool based on bmc with a fixed bound can sometimes give up without ever exploring anything beyond an initialization loop .
moreover a more experienced user attempting full verification may decide that a drastic change inthe verification strategy is needed e.g.
another tool abstracting the system under verification etc.
.
in this paper we explore answering the first question using the notion of safe cone.a safe cone is a finite trace for which any extension has been analyzed in the incomplete verification attempt.
a minimal feasible safe cone represents compactly a set of traces that have been successfully verified by the checker.
for the second question we build on the notion of a frontier.
afrontier trace is one that was analyzed by the checker but none of its extensions were.
frontier traces represent compactly classes of traces that were not explored by the checker.
we will see how ensuring traces are feasible plays a central role in interpreting these results.
our hypothesis is that execution reports that under approximate the set of minimal feasible safe cones and the set of maximal feasible frontier traces can be computed efficiently with respect to the cost of verification and can provide nontrivial feedback on incomplete verification attempts.
we will start by illustrating with examples the information we wish to extract and defining a possible formalization of the idealized properties it should have.
subsequently we define and discuss execution reports ers an under approximation of the ideal output.
afterwards we instantiate these concepts for the family of techniques based on abstract reachability trees art .
we also briefly discuss a proof of concept implementation built as an extension of cp achecker and an empirical evaluation of our implementation.
we conclude this paper with a discussion of related work and how our approach compares to existing techniques followed by a few concluding remarks.
ii.
m otiv a tion w ha t has and has not been analyzed ?
we frame our work in the context of a verification attempt being interrupted before its completion.
many verification techniques work by incrementally exploring the state space.
this is the case for software model checking techniques like bmc lazy predicate abstraction inlining and unrolling based techniques like corral .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research new ideas200 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1int min int a int n int res a for int i i n i if a res res a return res 7void init vector int a int n int i for i i n i a nondet 13void test min int large int n if large n else n int a init vector a n int min elem min a n assert min elem a figure harness for method min dse and in general art based implementations of various techniques including explicit value analysis and cegar variants of some of the previous among other.
in these techniques one can understand that incremental exploration leads to an incremental but silent increase of analyzed traces i.e.
sequences of statements as depicted in the examples that follow.
in fact some traces might reach a fully verified portion of the behavior space implicitly defining asafe cone containing all possible extensions of such traces.
understanding that partial explorations provide safety assurances we will discuss the frontiers defined by minimal safe cone traces and maximal analyzed statement traces.
we illustrate these concepts with a verification attempt of the instance in figure with bounded model checking.
example analyzed behaviors in bmc .the code snippet in figure corresponds to a parametric test harness exercising the method min .
the harness input as well as the result of method nondet are interpreted by the verification technique as non deterministic.
our verification attempt in this example is not interrupted due to reaching a resource limit but instead due to using a bounded model checker with a bound on the number of loop iterations set to .
using this configuration the tool would perform an exhaustive exploration but would disregard any executions involving the fourth loop iteration of the for loop in init vector.
any sequence of statements reaching line n will necessarily satisfy the safety property since the incomplete verification attempt would not find any assertion failures and the loop within init vector can be exhaustively analyzed.
that means the sequence of statements consisting of lines int n if large and n defines asafe cone because every continuation of the statement trace is alsosafe .
the former is also minimal in that if the last statement line were removed it would not be a safe cone.
moreover any execution that carries out line for i i n i at most times full iterations and bound check has also been analyzed.
in contrast any sequence containing line at least times is ignored by bmc and therefore will not be examined.
therefore any trace exercising line times or more will not be considered analyzed.
that is the trace composed of lines and then 4repetitions of lines for i i n i and a nondet is a maximal analyzed trace.
triangle we will now revisit these concepts from an entirely different technique lazy predicate abstraction .
lazy predicate abstraction the algorithm used by blast consists of two alternated phases.
the first phase generates on the fly a reachability tree whose nodes correspond to vertices of the control flow automaton1 cfa of the program.
this process goes on until exhaustively exploring the tree or until reaching a node that corresponds to an assertionfailure.
each node is associated with a predicate initially true that must hold for any path reaching that node and prunessome unreachable successors.
when a node that representsan error is reached the second phase deals with analyzingthe potential counterexample to determine whether the path reaching the error node is feasible.
if the latter phase determines the potential counterexample is infeasible the tree is refined by strengthening the predicates along the path so that the spurious error node is pruned.
lastly when a counterexample is produced it can be checked with a more precise analysis to ensure its feasibility.
however if this additional check fails the search is abandoned.
example analyzed behaviors in lazy predicate abstraction .
the code presented in figure reproduced from the papers presenting conditional model checking contains a non linear safety property.
as explained the construction of the reachability tree will reach the error node and the second phase would attempt to verify the feasibility of the path leading to it.
the feasibility check is usually implemented by creating a verification condition to be checked by an underlying smt solver and therefore inherits its limitations.
in particular smt solvers usually cannot handle non linear arithmetic and instead multiplication is modeled as an uninterpreted function.
concretely this loss of precision prevents the smt solver from proving infeasibility.
the subsequent more precise check would prove the path infeasible and stop exploration.
in this context the following is a maximal analyzed trace lines int p nondet if p i n tx i n ty and i n tr x y .
on the other hand the then branch of the if statement can be successfully verified with this technique since tracking 1a control flow automaton is similar to a control flow graph.
specifically nodes capture locations and edge labels are statements.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1int main int p nondet if p int i for i i i assert i else int x int y int r x y assert r x return figure non linear arithmetic.
reproduced from cmc papers .
the predicate i suffices to prove the assertion always holds when execution leaves the for loop.
the successful verification of the then branch would make the trace composed of lines int p nondet if p a n d4 int i asafe cone.
triangle iii.
e xecution reports er s we now formally define ers as an under approximation of the set of safe cones andfrontier traces.
these definitions rely on two predicates analyzed?
and issafecone?
whose definition depends greatly on the underlying verification technique used in the incomplete verification attempt.
consequently in this section we only provide properties that predicates analyzed?
and issafecone?
ought to satisfy.
in the next section we ground the definition of these predicates for art based verification techniques .
examples and show how the notions of analyzed and safe cone apply to diverse techniques.
we will capture these notions as predicates over traces in the following definitions.
let the alphabet contain all statements in a program making a sequence of statements.
property .
the predicate analyzed ?
bool satisfies the following property where stands for concatenation prime .
analyzed?
analyzed ?
prime property aims to formalize the notion of incrementality that we mentioned.
note that this property is logically equivalent to its contrapositive that is analyzed?
prime analyzed?
as expected of an incremental exploration.
property .
the predicate issafecone ?
bool satisfies the following property prime .
issafecone ?
issafecone ?
prime property reflects our notion of safe cone as a trace reaching a fully analyzed portion of the behavior space.
any trace extension will necessarily also be a safe cone.
property .
the predicates issafecone ?
bool and analyzed ?
bool satisfy the following property .
issafecone ?
analyzed ?
property connects the two predicates capturing how issafecone?
subsumes analyzed?
.
definition .
given a trace and a program p w e introduce the following predicate feasible p holds iffthere exists a concrete execution of the program pthat executes .
given that we will always refer to a single program at a time the system under analysis we will omit the subscript.
property .
given bool a boolean predicate that captures the safety property of interest the predicate analyzed ?
bool satisfies the following property .
analyzed?
feasible property is at the core of interpreting analyzed traces as providing safety assurances.
this property also holds for issafecone?
due to property .
the predicate feasible in the antecedent places the focus of safety assurances on feasible traces that is actual behaviors of the system under analysis.
recall that we provide properties that constrain analyzed?
and issafecone?
but concrete definitions depend on the underlying technique.
we now define the set of safe cones and frontier traces of an incomplete verification attempt.
definition .
the setfrontier is defined as follows frontier s s analyzed?
feasible s analyzed?
s definition .
the setsafecone is defined as follows safecone s s issafecone ?
feasible s issafecone ?
s definitions and are related to properties and respectively since the incrementality of the analysis is key to the search for maximal analyzed traces as in the set frontier and minimal safe cone traces as in safecone .
the setsafecone can provide safety assurances about the system as in example where the then branch of the if statement has been fully verified.
conversely frontier can suggest shortcomings in the incomplete verification attempt.
for instance in example the existence of a trace frontier that did not even go past the initialization loop suggests an important part of the test harness was not sufficiently analyzed.
the conclusions obtained from inspecting both sets can help assess the progress of an incomplete verification attempt.
we anticipated the intuitions captured by these definitions in examples and but there is one important consideration that we omitted so far and only bring up now feasibility.
feasibility is relevant because by definition infeasible traces do not correspond to system behaviors.
without feasibilityguarantees interpreting each trace would require careful analysis because it could mislead a user into either increasing or decreasing her confidence in the system under analysis.
definition .
an execution report is a tuple s f where s safecone andf frontier .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure architecture of er generation.
definition defines ers as under approximations of the sets safecone andfrontier allowing empty sets as valid ers.
the sets safecone andfrontier can grow quickly making it impractical to compute the full sets.
furthermore traces can be redundant in a sense if they only differ in a few statements making it sensible to under approximate.
fully characterizing these approximations might be too restrictive but some notion of adequacy seems necessary.
we opted for a relaxed notion of completeness.
for both sets safecone andfrontier we require that if a trace safecone resp.frontier ending in a specific location lexists then there exists prime s resp.f and primealso ends in l. this guarantee does not force extremely large sets of paths to be reported and loosely resembles a notion of coverage.
our algorithm guarantees this completeness criterion.
iv .
r eports for art b ased implementa tions throughout this section we will explain how we generate ers for art based techniques.
arts constitute a relevant intermediate data structure used in verification.
the variety of techniques implemented using arts makes them ideal for our proof of concept implementation.
art based implementations comprise a wide range of dissimilar techniques encompassing lazy abstraction bmc explicit value analysis and cegar variants of some of the previous among other.
in order to explain how we generate ers for art based techniques we first define analyzed?
and issafecone?
for these techniques in subsection iv a .
finally in subsection iv b we will explain how we compute ers from an earlier incomplete verification attempt taking the art structure and the systemunder verification as input as depicted in figure .
a. arts as intermediate data structures we have discussed how the concepts of analyzed and safe cone captured by predicates analyzed?
and issafecone?
respectively apply to example techniques.
in this sub section we will instantiate these concepts to arts .
an art is a tree whose nodes correspond to vertices of the cfa and each node is associated to an element of an abstract domain.
for example a lattice of predicates in blast.
art based algorithms consist of two phases the first one comprises an incremental generation of the art and the second phase involves a more thorough counterexample check.
for the purpose of stating which traces can be considered analyzed we can ignore the abstract domain elements associated to each node.
we can then think of an art asa tuple g w q covered whereg s is a graph w srepresents a wait list q0 sis the initial state covered s scaptures subsumption between nodes and s sis a transition function.
the graph gcaptures the structure of the partially built art.
w is the wait list that contains elements to be analyzed in order to continue the construction of the art.
the function covered is necessary to represent subsumption between nodes but is not total.
we say that a node eis covered by e primeiffcovered e e prime.
analogously we consider that a node eis not covered iffcovered e is undefined.
successors of a subsumed node eare not explored because the state space captured by eis also represented by covered e .
hence subsumption is relevant to defining which parts of the state space to consider explored.
to make the definitions easier to read we will assume the following invariant holds for arts relative to covered property .
e s.such that covered e is defined then covered covered e is not defined.
in art based algorithms a node ecovered by e primeneed not be further analyzed because any error state found from ewill also be found from e prime.
however a sequence of statements that reachesemight not be a safe trace if it is possible to reach an assertion failure from e prime.
in other words the sub tree rooted in ecannot be considered exhaustively built unless that is also the case for the sub tree rooted in e prime.
this observation is crucial to define what can be regarded as analyzed orsafe cone.
we will extend as prime s none s none withnone sto make it total and resolve the covered function transparently as follows prime q s q s if q s is defined and covered q s is not covered q s if both q s and covered q s are defined none otherwise due to property prime q is never a covered node.
moreover we will adapt primeto traces with prime s none s none as follows givenq s none s and prime q s prime q s prime q s prime prime q s we will consider that analyzed?
holds for a trace iff no prefix of reaches a node in wfrom the initial node.
definition .
we define analyzed ?for arts as analyzed ?
iff prime .isprefix prime prime q0 prime w informally we consider analyzed when no prefix of reaches a state pending exploration i.e.
one in w. the predicate analyzed?
is clearly monotonic satisfying property analyzed?
means there exists a prefix that reaches w therefore any extension primewill also share that prefix.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
similarly we will consider that issafecone?
holds for a trace iffthere exists a prefix of that leads from the initial node to a sub tree already exhaustively built.
intuitively a sub tree is exhaustively built when none of its nodes are in w the set containing states pending exploration.
definition .
we define issafecone ?for arts as issafecone ?
iff prime .isprefix prime prime q0 prime negationslash none prime prime .
prime q0 prime prime prime w analogously the predicate issafecone?
is monotonic satisfying property issafecone?
means there exists a prefix from which wis unreachable and consequently any extension primewill also share that prefix.
b. generating reports for cpachecker we built a proof of concept implementation on top of cpachecker capable of generating ers for art based techniques.
the input is an art without the abstract domain elements and the original system under analysis.
our output are the sets sandf composed of statement traces generated by two independent verification tasks as shown in figure .
although it would be possible to evaluate the predicates as stated in definitions and cpachecker already outputs a pre processed representation of the art structure collapsing entirely verified sub trees into a single node and exports the resulting graph .
this way we generate f by performing successive reachability queries to art nodes in wand similarly to generate s the target nodes are those resulting from the collapsed sub trees.
informally we augment an existing art based algorithm by composing in parallel the art being built with the one taken as input.
we define the algorithm in terms of configurable software v erification formalizing how different reachability analyses can be used.
due to space constraints we omit the details which are present in a technical report .
it is worth noting that the algorithm used to generate an er can be any artbased technique regardless of what was used for the original verification attempt.
v. e v alua tion in this section we briefly comment the conclusions of a preliminary evaluation we conducted.
due to space constraints we omit the details available in a technical report .
we analyzed the performance of our proof of concept implementation with a set of standard benchmark instances.
to conduct the experiment we first analyzed the instances with twodifferent techniques lazy predicate abstraction and explicit value analysis and collected the arts at the moment of reaching the stime limit.
then we attempted to generate ers for each of the art collected.
when using lazy predicate abstraction for verification it was possible to generate ers within a fraction of the time originally allotted for verification for the majority of instances.
moreover when using explicit value analysis the set f could also be generated within a fraction of the verification time inmost cases.
additionally we manually inspected each of the ers and gained non trivial insights in most instances.
vi.
r ela ted work conditional model checking cmc is an approach where model checkers are extended to produce results even when the verification run could not be completed successfully.
the output in its general form is a condition under which the program can be safely run.
cpachecker instantiates cmc by generating an assumption automaton a machine readable encoding of the art structure.
we use this implementation to produce the ers.
ers introduce the notions of frontier and safe cone to characterize the progress of an incomplete verification attempt.
the lack of any feasibility guarantees in assumption automata has significant consequences.
a user might be misled by the size of the assumption automaton since a vast automaton might correspond to a minuscule number of concrete feasible executions and also the other way around.
we overcome this limitation by formally characterizing the properties of our output and adding feasibility guarantees.
a slightly different approach to providing feedback of partial verification results consists of a language extension to be used to annotate assumptions made during verification.
this extension can be used to annotate the code and explicitly state conditions under which the program is guaranteed torun safely.
these annotations are especially well suited for local assumptions sometimes used during manual verification and for uniform assumptions such as the absence of integer overflows which are not affected by the context in which they occur.
however these annotations are not well suited to state assumptions made by some techniques such as those based in unrolling loops or those tackled by assumption automata and as such they are incomparable to our approach whichcan provide value in these cases.
one of the use cases of these annotations is to complement the verification efforts and produce a small test suite.
this idea of testing to complement earlier verification efforts was later replicated using assumption automata as input.
a recent extension of the dafny ide provides as one of its many features hints about parts of a specification that might cause timeouts.
however given the modular nature of the tool and the sort of specifications shown as examples the approach tackles a different problem than ours and the feature might not be applicable in our setting.
there is also previous work on quantifying partial model checker explorations based on usage profiles .
these estimations are based on abstract models of behavior and heavily depend on the provided usage profile.
a similarapproach works applying symbolic execution over the source code of a system without the need for an abstractmodel but in this case the implementation requires finitedomains for all input variables as well as a usage profilefor each of them.
reliability as they define it can be hardto interpret and once again could be extremely sensitive tothe usage profile provided.
both techniques can be used in conjunction with ours providing different value.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the modeling language alloy enables its users to specify structural properties.
an extension of the alloy analyzer highlights parts of the specification that are problematic or hard in the authors own words by monitoring the activity of variables and clauses in the underlying sat solver.
the output is inherently heuristic whereas our technique provides strong guarantees backed by a formal definition of the properties of the output.
the ideas behind the alloy analyzer extension could also be applied in conjunction with our techniques to provide additional information.
our work is heavily influenced by the ideas and tool support of witness validation which we leverage as a machinereadable representation of exploration progress.
however we aim at enabling a richer manual interaction whereas that line of work also attempts to increase tool automation and reduce the need for manual inspection.
vii.
c onclusions and future work software model checking is already capable of handling industrial instances and produce valuable results.
however some instances still remain intractable for full verification.
our work provides a different way to observe the progress of an incomplete verification attempt by means of an er.
we formulated the concepts of analyzed and safe cone traces and formalized the notion of ers.
we also implemented a proof of concept implementation and conducted a preliminary evaluation with standard benchmark instances.
we plan to explore ways to abstract the traces included in the ers for easier visualization and understanding.
furthermore we would define both existential and universal semantics for abstract traces in the sense that a property applies to the some or every concretization of these abstractions.
for instance guaranteeing that every concretization has been analyzed could be useful and would pose interesting challenges.
in a similar line to better assess the relevance of an element s w e need to devise meaningful views and metrics of the possible continuations of e.g.
coverage metrics of the cone defined by .
we would also like to analyze how our technique performs for a specific verification technique and varying time limits.
it would be desirable to conduct a user study to assess the effectiveness of our approach once more competing output representations become available.
we intend to look into alternative usages of our output.
for example elements of an er can be leveraged as additional input to choose the right algorithm to proceed after an incomplete verification attempt.
as mentioned in section ii the concepts we present are also applicable to verification techniques beyond those already implemented using arts corral dse inlining or unrollingbased among other.
it seems possible to adapt many of these tools to produce similar intermediate representations making it possible to evaluate the generality of our approach.