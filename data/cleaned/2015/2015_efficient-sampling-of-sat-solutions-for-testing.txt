efficient sampling of sat solutions for testing rafael dutra kevin laeufer jonathan bachrach and koushik sen eecs department university of california berkeley usa rtd laeufer jrb ksen cs.berkeley.edu abstract insoftwareandhardwaretesting generatingmultipleinputswhich satisfy a given set of constraints is an important problem with applications in fuzz testing and stimulus generation.
however it is a challenge to perform the sampling efficiently while generating a diversesetofinputswhichsatisfytheconstraints.wedeveloped a new algorithm quicksampler which requires a small number of solver calls to produce millions of samples which satisfy the constraintswithhighprobability.weevaluate quicksampler on large real world benchmarks and show that it can produce unique validsolutionsordersofmagnitudefasterthanotherstate of theart sampling tools with a distribution which is reasonably close to uniform in practice.
ccs concepts software and its engineering software testing and debugging formal software verification hardware theorem proving and sat solving keywords sampling stimulusgeneration constraint basedtesting constrainedrandom verification acm reference format rafael dutra kevin laeufer jonathan bachrach and koushik sen. .
efficient sampling of sat solutions for testing.
in proceedings of icse 40th international conference on software engineering gothenburg sweden may june icse pages.
introduction givenasetofconstraints theproblemofgeneratingasetofrandom solutionstotheconstraintsisimportantbothinsoftwareandhardwaretestingandverification.
forinstance conventionalsymbolic execution and dynamic symbolic execution techniques generate a path constraint for eachprefixoffeasibleexecutionpathsinaprogramanduseasmtsolver to generate a solution for each such constraint.
however in practice these techniques face scalability problems because the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
instead of generating a single solution for the path constraint of a path prefix one could generate multiple solutions to randomly testmultiplepathshavingthesameprefix.wecallthisapproachconstraint basedfuzzing.ifmultiplesolutionscouldbegenerated efficiently thiswouldsignificantlyspeedupsymbolicexecutionand reap the benefits of random testing .
similarideashavebeenproposedanddevelopedinhardwareverification.forexample constrained randomverification crv has been proposed to generate high quality inputs for hardwaredesigns.
in crv verification engineers specify preconditions re quired by the hardware and other constraints based on domainspecific knowledge .
multiple random inputs satisfying the constraintsarethengeneratedusingaconstraintsolverthatcan sample random solutions from a constraint.
however despiteitsimportance theproblemofsamplingadiversesetofsolutionsefficientlyisstillchallengingtoday .there are approaches which give strong guarantees of uniformity but are expensive to run when a large number of samples is re quired.
other approaches use heuristics for faster sampling butthatcanmakethesamplesbiasedtowardsoneportionofthe sampling space.
in this work we specifically focus on the goal of generating randomsamplestobeusedasinputsfortesting.weassumethat theconstraintsaregivenasbooleansatisfiability sat problems since constraints from higher level domains such as bit vectors or othersatisfiabilitymodulotheories smt problemscanbemappedintosat.ourgoalistoefficientlygeneratelotsofrandomsatisfying assignments to sat formulas also known as sat witnesses.
inthetestingdomain itisoftenacceptabletogenerateinvalid solutionssomeofthetime.forexample inconstraint basedfuzzing wemayuseconstraintstodirecttheexecutiontowardsacertain portion of the program but it is still fine if some samples don t satisfytheconstraintsandendupexecutingotherprogramparts.
itisalsoimportantto noticethat inthetestingdomain themost importantmetricisthenumberofuniquevalidsolutionsgenerated overtime.thatisbecauseeachuniquevalidinputcanhelpcover newportionsoftheprogramandfindpreviouslyunseenbugs while repeated samples do not increase coverage.
withthatinmind wehavedesigned quicksampler anewtechniqueforefficientsampling.
quicksampler usesasmallnumber of constraint solver calls to generate a large number of samples.
quicksampler works as follows.
first it finds a random assignment tothe variables ofthe boolean formula i.e.
the constraint .such an assignment may not satisfy the formula.
quicksampler then uses a max sat solver to find a solution of the formula that is close to the random satisfying assignment.
it then flips the value of each variable in the solutionand again uses max sat to find another close solution of the formula.
the difference between the acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden dutra et al.
original solution and the modified solution is called an atomic mutation.
for each variable in the formula this generates at most one atomicmutation.asmallboundednumberofsuchatomicmutations are then combined and applied to the original solution to generate a potentially new solution.
we found that such combinations of small atomic mutations often results in new valid random solutions.thisisbecauseeachatomicmutationidentifiesasmall setofvariablesthataretightlycoupledwitheachother.whereas thevariablesfromtwodifferentatomicmutationsareoftenindependent.therefore iftwosuchatomicmutationsarecombinedand applied to the original solution then the resulting solution will oftensatisfytheformula.theentireprocessisrepeatedseveraltimes.since quicksampler createslotsofsolutionsbysimplycombining atomicmutations itavoidsmaking frequentsolvercalls whichis often the bottleneck .
this in turn results in quick generation of lots of random solutions.
we have implemented quicksampler as an open source tool availableat we use z3 to solve max sat queries.
the samples generated byquicksampler are not guaranteed to satisfy a given formula butourexperimentsshowthattheyarevalidsolutionsinourbenchmarkswithhighprobability i.e.
.
.quicksampler also produces unique valid solutions orders of magnitude i.e.
faster thanother state of the artsamplers whilegenerating adistributionofsampleswhichisstillclosetouniform.forapplications which require only valid solutions it is also possible to use our technique bysimplycheckingthesamplesforvalidityandfiltering out the invalid ones.
our evaluation shows that quicksampler is still faster than the other samplers even when including this additional checking.
related work thereareseveraldifferenttechniquesusedtotackletheproblem of sampling solutions to boolean constraints .
the problem of sampling sat witnesses is also closely related to the problem of countingthenumberofsolutions whichhas p completecomplexity.
several sampling techniques can be applied to model counting or use some form of model counting internally .
oneclassofsamplingmethodsisbasedonmarkovchainmonte carlo mcmc algorithms .theseincludesimulatedannealingandmetropolis hastingswhichareusedtogeneratesamples from a probability space.
those mcmc methods are guaranteedto eventually converge to the desired distribution such as uniform sampling .
however this convergence is slow in practice for real world problems so the algorithms typically employ heuris tics which make the sampling more biased .
for example combinesmetropolisstepswithrandomwalkstepsthrough the assignments to the variables of the formula.
in comparison quicksampler doesnotneedtowaitforaconvergencetimeand covers the search space by finding solutions closest to randomly selected points.
one similar line of work attempts to modify the sat solver searchheuristicsinordertogenerateamorediversesetofsolutions .
however unlike quicksampler thisdiversesampling has different goals and does not attempt to cover the whole searchspace nearly uniformly.
quicksampler also does not modify the a a a b b b a b a b figure combining two mutations.
inner search strategies of sat solvers but instead uses the sat solvers as an oracle to answer max sat queries.
the closest technique to quicksampler in literature appears to besearchtreesampler which also uses a sat solver as anoracle.however searchtreesampler performssimplesatisfiability queries instead of the max sat queries by quicksampler .
searchtreesampler works by exploring the tree of variable assignmentsinabreadth firstway generating pseudosolutions which are partial assignments to the variables that can be completed to a full solution.
searchtreesampler uses a parameter kwhich specifies the number of samples computed per level in the tree and canbeusedtotrade offuniformityandnumberofsolvercallsrequired.ontheotherhand quicksampler usesadifferentstrategy tocoverthesearchspace andalsogeneratesavastlylargernumber of samples per solver call by combining learned mutations.
a different class of algorithms is based on universal hashing and can provide strong guarantees of uniformity.
these techniquesworkbyaddingadditionalconstraintstotheformula known as hash functions in order to partition the search space uniformly.thosehashfunctionsaretypicallyformedbycomputing the xor of a random subset of variables .unigen andunigen2 are examples of this class with the latter also employing parallelism to improve performance.
in comparison quicksampler does not attempt to be perfectly uniform but only closetouniforminpractice.
quicksampler primarilyaimsforefficiency usingsolvercallswhicharemuchlessexpensivetosolve than the xor constraints of hash functions and generating a large number of samples per solver call.
quicksampler algorithm givenabooleanformula thegoalof quicksampler istogenerate unique solutions of efficiently.
another goal of quicksampler istomakesurethatsolutionsof aresampledalmostuniformly at random.
the key idea behind quicksampler is to make a small number of solver calls to generate a large number of potentially uniquesolutionsof .thecorealgorithmbehind quicksampler works as follows.
quicksampler assumes that we are given an initial random solution i.e.
a satisfying assignment to where isavectorof1sand0s.eachlocationinthevectorcorrespondsto a boolean variable in and the value at that location in the vector denotes the value assigned to this variable in the solution .
letv be the set of all boolean variables in .
for example in figure we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficient sampling of sat solutions for testing icse may june gothenburg sweden show a possible vector in a case where the number of variables is v .
foreachvariable v v quicksampler findsasolution vsuch that vand are minimally different and v v nequal v where v is the value of the variable vin the solution .
note that such asolutionmaynotexistforallvariablesin v.thediffbetween and v which we will denote using vand which is the xor of and v is called an atomic mutation of .
that is v v .
in the example from figure if the first variable of the formula is a wemightfindanewsolution awhichhasthefirstbitflipped correspondingtovariable a andadditionallyothertwobitsflipped.
thecorrespondingatomicmutation aisalsoshowninfigure1.
similarly ifthesecondvariableoftheformulais b wemightfind anewsolution basshowninfigure1 whichhasthesecondbit correspondingtovariable b flipped butalsoother3bitsflipped.
the corresponding atomic mutation bis again shown in figure .
bydefinition theatomicmutation valwaysensuresthatatleast v v is one i.e.
and vat least differ in the value of the variable vanddifferenceinthevaluesoftheremainingvariablesisminimal.
wewilllaterexplainhowamax satquerytoasatsolvercan be used to find vgiven andv.
given quicksampler first computes the set of all atomic mutations by going over all the variables v v. let us denote the set of all such atomic mutations by 1 .
note that given and v we can compute vas v .
after computing 1 quicksampler computes setsof compositemutations k fork where k containstheunionofall k distinctmutationsin 1 .forexample if aand baretwomutationsin 1 suchthat a nequalb then a bisamutationpresentin 2 .
sinceeachof aand barebit vectors a biscomputed by taking bitwise or of the two bit vectors.
for example after computing the atomic mutations a b 1 from figure the combined mutation a bis added to 2 .
if we apply the combined mutation to by computing a b we obtain a new assignment asinfigure1.notethat differsfrom onallthe bits set in either of the two atomic mutations aand b. this new assignment is not guaranteed to be a valid solution butwehavefoundthatithasahighprobabilityofbeingvalidin realbenchmarks1.thisisbecausethedifferences aand bconsist of a minimal set of bits which can be flipped while still preserving the satisfiability of the formula.
so the bits in aare likely to be closelyrelatedtoeachotherbysomeclausesintheformula.itis likely that those clauses would still be satisfied in a b where we flip all the bits from ain addition to the bits from b. ingeneral eachmutation presentina k denotesacomposite mutationandcanbexoredwith togetanassignment tothe variablesin .suchanassignmentmayormaynotbeasolutionof .
surprisingly in our experiments we found that for small values ofk i.e.k more than of such assignments obtained by xoring are solutions of .
let us denote the assignments obtained by applying all the mutations present in k to by k i.e.
k braceleftbig k bracerightbig 1ourheuristictogeneratesamplesexploitstheclausestructurefoundinreal world benchmarks.
we expectit to perform poorly if appliedto a randomly generated sat formula.we let k 6 k .
we found experimentally that over all benchmarks of the assignments in are solutions of .
we now make a few interesting and important observations about the set of assignments .quicksampler needs to make solvercallsonlytocompute 1 .moreover itisnotalwaysnecessary to make a solver call while computing the elements of 1 if quicksampler flips the bit corresponding to the variable vin anddiscoversthattheresultingbit vectorisasatisfyingassignment to thenquicksampler can skip the solver call for v. for the computation of all other k quicksampler needs no solver calls because each element in k is obtained by applying at most kbitwisebooleanoperations.anassignmentin k mayormaynotbea validsolution howevercheckingitsvalidityisfastandtakeslinear timeinthesizeof .insummary quicksampler canpotentially makesolvercallsforthecomputationof 1 butitmakesnosolver callstocomputetheremainingsets k .anotherobservationisthat size of k could grow exponentially with k. this observation combinedwiththefactsthatasignificantnumberofassignmentsin have been empirically found to be solutions of and that we make atmost v solvercallssuggeststhatgiven quicksampler can rapidly generate lots of unique solutions of by making very few solvercalls.thisformsthecruxof quicksampler scorealgorithm for sampling.
given a random solution we described how quicksampler generateslotsofsolutionsthataresmallmutationsof .w ene xt describe how we generate a random solution .quicksampler first chooses a random assignment primeby picking the values of variablesin vuniformlyatrandom.thenitusesamax satquery tofindaclosestsolution totherandomassignment prime.wepicked this strategy to make sampling of solutions more uniform.
overall quicksampler execution is divided into epochs.
in each epoch quicksampler generates a random solution using the method described above.
then it computes and outputs the elements of thataresolutionsof .quicksampler repeatsthisprocessina loopuntilithasrunoutoftimebudgetorithasfinishedgenerating a user specified number of solutions.
nowwedescribehowmax satqueriescanbeusedtoobtain the random solution and also to obtain the solutions vfor each variablev.
the maximum satisfiability problem or max sat is defined as follows given a set of hard constraints and a set of soft constraints find a solution which satisfies all the hard constraints and additionally satisfies the maximum possible number of soft constraints.
in order to compute the random solution we just need to specify one hard constraint that the formula must be satisfied and v soft constraints indicating that the values of each variablevshouldpreferablybeequaltotheirrespectivevaluesin the random assignment prime i.e.
u v u prime u .
in order to compute each solution v we specify two hard constraints and v 1softconstraints.thehardconstraintsarethattheformula must be satisfied and that the value of variable vmust be flipped i.e.
v v nequal v .thesoftconstraintsarethatthevaluesofother variables should preferably remain the same or u v v v u u .
this completes the general description of the quicksampler algorithm.however wehavealsomadesomeadaptationstothis initialalgorithminordertoimproveitsperformance.wediscuss authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden dutra et al.
a 1 b 2 c figure combining mutations in .
the eager generation of samples in .
the use of the independent support of the formula and in .
the removal of unsatisfiable variables.
.
eager generation of samples aswehaveseen quicksampler onlyrequiressolvercallsinorder toproducetheatomicmutationsin 1 .afterthat thecomputation ofthesamplesin k canbeperformedwithsimplebitwiseoperations.however thesolvercallscanbeexpensiveforthelargest benchmarks.soideallywewouldliketoleverageeachsolvercall to generate samples as soon as the call is completed so that we do not need to wait for all solver calls before generating samples.
wehaveadaptedthebasic quicksampler algorithmtogenerate samples as soon as each solver call is completed.
figure presents an example of this eager generation.
each circle represents one mutationandinsideitweindicatethenumberofatomicmutations used to generate it.
when solution ais returned by the solver we learn one atomic mutation a represented by the first circle in the figure.
then as soon as solution bbecomes available we learn theatomicmutation bandalsocombineitwith atogeneratea mutation in 2 .
then as soon as solution cbecomes available we learn the mutation cand combine it with the three previously known mutations in order to generate three new mutations.
in conjunction with this eager generation of mutations we also eliminateduplicatemutationsinthecurrentsamplingepoch.we found it important to avoid duplicates within one epoch otherwise we would output too many repeated samples and perform unnecessary work computing them.
wemaintainacollection ofcurrentlyknownmutationsgenerated in the current epoch.
whenever we learn a new mutation from a solver call we combine it with the mutations in .
the new generated mutations are added to only if they are previously unseen mutations in this epoch.
also we only combine the new atomic mutations with mutations from k fork .
we do notwanttogeneratemutationscomposedofmorethan6atomicmutations because they would have a lower chance of generating valid solutions according to our experiments.
.
independent support similarlyto unigen2 wecanrestrictoursamplertoonlyoperate over the variablesin an independent support sof the formula instead of generating assignments to all the variables in v. the independent support is a subset of variables which completely determines all the assignments to a formula.
more specifically given anassignmentofvaluestothevariablesintheindependentsupport s thereisatmostonecompletionofthisassignmenttotheremaining variables which satisfies the formula.
so we can think of all othervariablesbeingdependentonthevariablesintheindependent support.knowinganindependentsupportishelpfulinreducing the number of variables for which we need to assign values.
in many cases an independent support arises naturally from the application.
for example when the tseytin transformation is used to transform a combinatorial logic circuit into a boolean formula in conjunctive normal form cnf auxiliary variables are introduced for all intermediate wires in the circuit.
all of thoseauxiliary variables can be uniquely determined given the inputs to the circuit so the inputs form an independent support.
in cases when an independent support is not known for a formula there are also methods to compute a minimal independent support for it .
.
unsatisfiable variables ifonemax satqueryforvariable vreturnsnosolutions welearn thatvcan only have one truth value in this formula.
when this happensinthefirstepoch werecordthevariable vinasetuofunsatisfiablevariables.then wedonottrytoflipthevalueof vagain inotherepochs.wefoundthat overallbenchmarks onaverage6 ofthevariablesfromtheindependentsupportwereaddedtothe setu.
this means that after the first epoch all subsequent epochs canworkoverareducedsamplingsetandavoidunnecessarysolver calls.
implementation we have implemented2the technique in c using z3 a s the underlying solver.
quicksampler uses the z3 optimization subsystem z in order to solve the max sat queries.
we also use thepush andpop interfaces to efficiently add and remove constraints from a single solving context.
quicksampler takes as input a sat formula in conjunctive normal form cnf represented in the dimacs file format.
the formula includes a list of variables which compose its independent support.
our implementation outputs the samples generated to a file withoutcheckingiftheyarevalidsolutions.ifdesirable itispossible toaddaposteriorcheckwhichverifiesifthesamplesarevalidor not andpossiblyfiltersouttheinvalidones .wealsodonotcheck forduplicates whichcanappearbetweendifferentepochsinthe sampling algorithm.
this global check for uniqueness could alsobe added but it would require an additional time and memory 2the source code is available at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficient sampling of sat solutions for testing icse may june gothenburg sweden overhead.someapplicationsmightprefernottokeepallgenerated samples in memory and allow the generation of repeated samples instead.
wehaveimplementedanofflineanalysistocheckifthesamples arevalidandgeneratehistogramsthatcounthowmanytimeseach solutionhasbeensampled.werecordthetimetakenbythesample generation and also the time taken by the checking phase.
the checking phase is not heavily optimized and for most benchmarks itwasmoreexpensivethanthesamplingphase.webelievethereisstillroomforimprovementinthecheckingphase sinceallitneeds to do is to propagate the values of the independent support to the remaining variables and check if all clauses are satisfied.
evaluation weevaluate quicksampler bycomparingagainsttwostate of theartsamplers unigen2 andsearchtreesampler .unigen2 provides strong uniformity guarantees by using hash functions composedofxorconstraintsinordertopartitionthesearchspace into similar sized bins.
searchtreesampler ontheotherhand usesthesatsolverto findpseudosolutions partialassignmentstothe firstfewvariables andprogressivelyaugmentsthepseudosolutionsintorealsolutions.
searchtreesampler isonlyapproximatelyuniform.theuniformity can be increased with a higher number of samples per level k but at a cost of also increasing the number of solver calls required.
in our experiments we used the default value of k .
bothquicksampler andunigen2 can leverage the knowledge of an independent support of the formula to improve sampling performance.soinordertomakeforafaircomparison wemodifiedsearchtreesampler tousethisadditionalinformation.we reorder the variables of the formula in order to place first the ones which are part of the independent support.
and we additionally tellsearchtreesampler to finish sampling after processing those variables and output pseudosolutions assignments to the variables of the independent support that it has produced so far.
since an assignmenttotheindependentsupportcanonlybecompletedto one solution there is no need to find assignments to the remaining variables.
for the evaluation we use the set of benchmarks from the unigen2 paper available online3.from thebenchmarks listed in wefound173ontheonlinerepo.thebenchmarksinclude bit blasted versions of smtlib benchmarks iscas89 circuits augmented with parity conditions on randomly chosen subsets of outputs and next state variables problems arising from automated programsynthesisandconstraintsarisinginboundedmodelchecking.thus theyarerepresentativeofthekindsofconstraintsthat mightappearinsmtformulasforsoftwaretestingorcircuitconstraints for hardware.
on benchmarks4 unigen2 reported an error because the specified independent support is not really an independent support for the formula.
in all those benchmarks we verified that the 3benchmarks and source code for unigen2 were obtained from kuldeepmeel unigen.
4guidanceservice2.sk 2 27 guidanceservice.sk 4 27 issueserviceimpl.sk 8 30 phaseservice.sk 14 27 activityservice.sk 11 27 iterationservice.sk 12 27 activityservice2.sk 10 27 concreteactivityservice.sk 13 28 notificationserviceimpl2.sk 10 36 loginservice.sk 20 34.table correctness statistics for the samples produced in one epoch of quicksampler average among all bench marks atomic mutations total valid total numberofsolutionscomputedbytheexactmodelcountersharpsat is larger than s which should not happen if sis a realindependentsupportfortheformula.sowedecidedtoexcludethosebenchmarksfromourresults.theresultsinthispaperinclude the remaining benchmarks.
on3benchmarks unigen2 couldnotestimatethenumberof solutions onparity.sk 11 11 unigen2 raisedafloatingpointexceptionandonisolaterightmost.sk 7 481andlistreverse.sk 11 43 theapproxmc modelcounterusedby unigen2 couldn tfinish even in hours.
on benchmarks unigen2 estimated the number of solutions but couldn t produce any samples on doublylinkedlist.sk 8 37ittimedoutandondiagstencilclean.sk 41 36 it ran out of memory.
the experiments were conducted on a core .50ghz intel corei7 5930kcpu.foreachbenchmark eachofthealgorithms wasgivenonecoreand1.5gbofmemory.for quicksampler and searchtreesampler weallowedamaximumtimeoutof1hour or hours on the hardest benchmarks.
we also stopped the sampling after a large number of samples had been produced at least million samples .
forunigen2 werequestedthegeneration of1000samplesfor mostbenchmarks allowingupto20hourstoproducethem.forthe hardest benchmarks we reduced the number of requested samples to500.forallthebenchmarksinwhich unigen2 failedtoproduce anysamples ittimesout after20hours evenwhenthe numberofrequested samples was .
.
correctness of samples ontable1 welisttheaveragenumberofsamplesproducedand how many of those were valid on one epoch of the sampling algorithm.
the results were averaged across all benchmarks.
they areclassifiedaccordingtothenumberofindividualatomicmutationswhichcomposethemutation.thebasesolutionusedinthe epoch is the one with atomic mutations and the neighbors of thebasesolutionobtainedwhenflippingeachbitcorrespondto1 atomicmutation.thosearealwaysvalidsolutionstotheformula since they are obtained as the result of solver calls.
from2to6atomicmutations weseethatthefractionofvalid solutionsdecreasesfrom96 to73 .andoverall ofallsamples produced were valid when we allow a maximum of atomic mutations.
table shows that by adjusting this maximum we can authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden dutra et al.
changetheaccuracyofthesampling.forexample withamaximum of atomic mutations instead of the fraction of valid samples wouldincreaseto83 .however therewouldbeasubstantialdecrease in the quantity of samples produced.
we have chosen to use themaximumnumberof6atomicmutationstoallowthegeneration of millions of samples while still having a reasonably good accuracy of .
ifnis the number of atomic mutations then the number of mutations of level can go up to parenleftbign parenrightbig a sixth degree polynomial inn.
this explains why we can generate millions of samples from only tens of atomic mutations.
.
performance comparison for the performance comparison we define tq ts tuto be the average time taken by quicksampler searchtreesampler and unigen2 respectivelytoproduceavalidsample.
tqwascomputed astq tq sq p wheretqis the total execution time sqis the total number of samples produced and pis the fraction of samples which are valid for quicksampler .
we additionally define t qto be the estimated time per valid sample that quicksampler would require if it also checked all samples for validity.
t qwas computed ast q tq tc sq p wheretcis the total time taken to check the validity of all sqproduced samples.
table2showstheperformancecomparisonamongaselectedset of benchmarks.
we have included the largest benchmarks more than4000variables thebenchmarkswhichwerelistedasrepresentative benchmarks in and the benchmarks used for uniformity plotsin .
.thisincludesthebenchmarkswhichquicksampler or searchtreesampler found hard.
thefirstgroupofcolumnsintable2showsbasicinformation about the benchmarks size of the independent support number of variables clauses and solutions.
the number of solutions was obtainedfrom unigen2 .onmostbenchmarks anexactnumberof solutionsisknown whileforsomeweonlyknowanapproximation represented with and on some unigen2 failed completely to compute the number of solutions.
the second group of columns shows results for quicksampler thenumberofepochscompleted numberofmax satsolvercalls number of samplesgenerated fraction of sampleswhich are valid and the average times per valid sample tqandt q in microseconds.
the third and fourth group of columns present results for searchtreesampler andunigen2 the number of samples produced and the average time per sample taken in comparison with the quicksampler time tq.
the mean value for some ratios of interest is shown on table .
forexample ts tq .
.
.thiswascomputedbytakingthe averageandthestandarddeviationof log10 ts tq acrossallbenchmarks.
figure shows a comparison of the average time per valid sample against searchtreesampler andunigen2 .
as reported in table quicksampler was on average .
orders of magnitude faster than searchtreesampler and .
orders of magnitude fasterthan unigen2 .overall quicksampler wasonlyslowerthan searchtreesampler onthebenchmarkdiagstencilclean.sk 41 36 withts tq .
.
we believe quicksampler did not do well0 benchmarksts tq a searchtreesampler quicksampler benchmarkstu tq b unigen2 quicksampler figure average time per valid sample ondiagstencilclean.sk 41 36becausethez3solverusedinourimplementation did not perform well on this formula.
in comparison minisat thesolverusedby searchtreesampler wasmuchfaster onthisbenchmark.theoppositeeffectcanbeseen forexample on parity.sk 11 11 where minisat was only able to complete a small number of solver calls.
nextwepresentgraphsofthesamemetrics butnowalsotaking intoaccountthetimethatwouldberequiredfor quicksampler to checkifthesamplesarevalid.thisshouldonlybeneedediftheapplication cannot deal with invalid samples.
figures 4a and 4b show thecomparisonwith searchtreesampler andunigen2 respectively.weseethat quicksampler isstill1orderofmagnitudefaster thansearchtreesampler and3.2ordersofmagnitudefasterthan unigen2 evenwhenincludingthischeckingtime.
quicksampler wasonlyslowerthan searchtreesampler onthreebenchmarks authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficient sampling of sat solutions for testing icse may june gothenburg sweden table comparison of sampling algorithms quicksampler searchtreesampler unigen2 benchmark s vars clauses solutions ncalls samples valid tq s t q s samples ts tqsamples tu tq blasted case47 .
.
.
blasted case110 .
.
.
s820a 7 4 .
.
.
s820a 15 7 .
.
.
s1238a 3 2 .
.
.
s1196a 3 2 .
.
.
s832a 15 7 .
.
.
blasted case 1 b12 2 .
.
.
blasted squaring16 .
.
.
blasted squaring7 .
.
.
.sk 3 40 .
.
.
processbean.sk 8 64 .
.
.
.sk 6 38 .
.
.
.sk 3 52 .
.
.
.sk 2 48 .
.
.
.sk 4 50 .
.
.
doublylinkedlist.sk 8 37 .
.
.
.sk 3 48 .
.
.
.sk 3 45 .
.
.
isolaterightmost.sk 7 481 .
.
.
.sk 3 45 .
.
.
.sk 5 51 .
.
.
loginservice2.sk 23 36 .
.
.
sort.sk 8 52 .
.
.
parity.sk 11 11 .
.
.
.sk 3 44 .
.
.
.sk 1 51 .
.
.
enqueueseqsk.sk 10 42 .
.
.
karatsuba.sk 7 41 .
.
.
diagstencilclean.sk 41 36 .
.
0tutorial3.sk 4 31 .
.
.
table mean ratio comparisons across all benchmarks ratio mean ts tq102.
.
tu tq104.
.
ts t q101.
.
tu t q103.
.
uq us102.
.
uq uu104.
.
wheretheratio ts t qwas0.95for17.sk 3 45 .71for70.sk 3 40 and .
5for diagstencilclean.sk 41 36. thoseresultsshowclearlythat quicksampler iscapableofgenerating valid solutions orders of magnitude faster than the other techniques.
however we believe that an even more important metric is the number of uniquevalid solutions generated over time sincerepeatedsolutionsdonothelpuncovernewbehaviorinthe testprogram.soweperformedanexperimenttoevaluatethenumber of unique valid solutions generated.
all three algorithms were allowed to run until they produced millionsamplesorreached1hourofexecution.iftheirexecution times are tq ts tu we define t min tq ts tu and look at the numberofuniquevalidsolutionsthateachalgorithmcouldproduce in timetand represent those numbers as uq us uu.
we found out thatonmostbenchmarks quicksampler wasabletoproduce10 millionsamplesbefore1houranditwasthefastestalgorithmto finish.sotheuniquenesscomparisonisperformedattime tq.on sixbenchmarks neitherofthealgorithmscouldproduce10million samples before hour so the uniqueness comparison is performedat hour.
the names of those benchmarks are marked with an asterisk in table .
figure5acomparesuniquesolutionsproducedby quicksampler andsearchtreesampler .
on average the number of unique solutions produced by quicksampler was .
orders of magnitude larger as seen in table .
on only one benchmark it was lower karatsuba.sk 7 41 with uq us .
.
infigure5b wepresenttheratioofuniquesolutionsbetween quicksampler andunigen2 .again theratiowasloweronlyon karatsuba.sk 7 41 with uq uu .
.onaverage uqwas4.4ordersofmagnitudehigherthan uu.wefoundthat quicksampler performed poorly on karatsuba.sk 7 41 because it had not completed one sampling epoch within the first hour of execution and most of the samples are generated towards the end of the sampling epoch.
however within hours quicksampler was able to complete 2sampling epochs generating avastly largeramount of samples as reported in table .
.
uniformity of coverage theresultsfrom .2showthat quicksampler canproduceunique validsolutionsveryfast whichwasourprimarygoal.butwewould still like to check if the distribution of samples produced is similar to uniform because we don t want to be missing a large portion of the solution space while focusing on a very biased subset of solutions.wehavedesignedourmainsamplingfunctiontostart from a random point in the space of possible variable assignments in order to make our coverage more uniform.
this also guarantees that any solution has a positive probability of being output by our algorithm.
inordertoempiricallyevaluatetheuniformityof quicksampler we compare its distribution of solutions with the ones from the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden dutra et al.
benchmarksts t q a searchtreesampler quicksampler benchmarkstu t q b unigen2 quicksampler figure average time per valid sample including time to check validity two other samplers searchtreesampler unigen2 as well as a distributionfromaperfectuniformsampler.onlythevalidsamples are considered in this analysis.
we compare on the benchmarks for which the number of samples generated by unigen2 in a time limit of hours was at least five times the total number of solutions.itisimportantforstatisticalsignificancethateachsolution be sampled on average at least five times.
for each of the benchmarks let sq ss sube the number of valid samples generated by each algorithm and s min sq ss su .
we subsample uniformly s samples from the valid samples produced by each algorithm and wealsogenerate ssamplesfromaperfectlyuniformdistribution using the total number of solutions provided by unigen2.
figures to show the results of the comparison on all benchmarks for which the number of generated samples scan be at least0 benchmarksuq us a quicksampler searchtreesampler benchmarksuq uu b quicksampler unigen2 figure unique solutions produced over same amount oftime !
figure blasted case47 histogram authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficient sampling of sat solutions for testing icse may june gothenburg sweden !
figure blasted case110 histogram !
figure s820a 7 4 histogram !
figure s820a 15 7 histogram fivetimesthenumberofsolutionsbeforethetimeoutisreached.the xaxis represents the number of times each solution has been sampledandthe yaxisrepresentsthequantityofsolutionswhichhave beensampled xtimes.wecanseethat searchtreesampler and unigen2 areusuallyindistinguishablefromuniform but quicksampler is also very close to uniform behavior.
wehavealsoappliedpearson schi squaredtesttothe ssamples obtained from each algorithm.
we compute the 2statistic and the corresponding p value using the known number of solutions to !
figure loginservice2.sk 23 36 histogram table chi squared uniformity test not rejected rejected quicksampler searchtreesampler unigen2 theformula.werejectthenullhypothesisthatthedistributionis uniform if the p value is lower than the confidence level of .
.
this gives a bound on the type i error rate i.e.
the probability thatauniformdistributionismistakenlyrejectedasnon uniform .
table4showtheresultsofapplyingthistesttothe160benchmarks for which we know an estimate of the number of solutions.
we canseethat searchtreesampler andunigen2 aremoreuniform butquicksampler is still close to uniform on most benchmarks.
however thisresultshouldbetakenwithcare sincetheuniformitytestisnotveryreliableonbenchmarkswhere quicksampler completed a small number of epochs or when the number of produced samples is too low.
besides analyzing the uniformity of the distribution we also measured the number of unique valid solutions generated.
this is arguablymoreimportantthanthehistogramsofsolutioncounts because we want unique solutions to increase coverage in testing.
we computed the number uof unique valid solutions generated byquicksampler and also the number uof unique solutions that should be generated if the sampling was perfectly uniform.
we record the ratio u ufor all benchmarks for which we have an estimateofthenumberofsolutions.theratio u uhadanaveragevalue of .
with standard deviation of .
.
besides one benchmark doublylinkedlist.sk 8 37 with value0.
all otherbenchmarks hadu u .
.incomparison for searchtreesampler theaverage was .
and standard deviation .
.
searchtreesampler alsoperformedworstonthebenchmarkdoublylinkedlist.sk 8 37 with value .
and all other benchmarks having u u .
.
unigen2 obtained an average of .
and a standard deviation of .
withaminimumvalueof0.
.ondoublylinkedlist.sk 8 37 unigen2 timed out so we cannot compare on this benchmark.
5we could not perform power analysis to estimate the type ii error rate because that would require a specific alternative hypothesis and we did not see any natural alternative hypothesis for the distribution of samples.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden dutra et al.
!
figure s820a 7 4 unique solutions !
figure enqueueseqsk.sk 10 42 unique solutions we also present plots of the number of unique solutions producedovertime fortworepresentativebenchmarks.infigure11 weshowthegraphforbenchmarks820a 7 4 wherethenumber of samples produced is larger than the total number of solutions.
we see that the number of unique solutions grows very fast initially and then stabilizes as we approach complete coverage of all solutions.
searchtreesampler andunigen2 ontheotherhand produce solutions at a much slower rate.
in figure we show benchmark enqueueseqsk.sk 10 42 where the number of valid samplesproducedismuchsmallerthanthetotalnumberofsolutions.
we can see that quicksampler is able to generate unique solutions orders of magnitude faster than searchtreesampler andunigen2 .wealsonoticeadistinctivesteppatterninthegraph.
thishappensbecauseweproducethelargestnumberofsamples attheendofeachsamplingepoch whenthecollectionofknown mutations is the largest.
insummary weseethat searchtreesampler andunigen2 are a bit closer to uniform sampling but quicksampler is still very close.
in almost all cases the number of unique solutions generated wasveryclosetothenumberthatwouldbeexpectedifthesampling was uniform and we are able to produce new unique solutions at a faster rate than the other techniques.
conclusion wehavedevelopedanewtechniquetosamplesolutionstoboolean constraints with the goal of applying it to constrained random verificationandfuzztesting.forthoseapplications itistypically acceptable to produce a small number of invalid inputs so we allowourtechniquetooutputsampleswhicharenotguaranteed to be valid.
by leveraging a small number of max sat solver calls quicksampler can generate millions of samples.
our experiments show that the produced samples are valid with anaverageprobabilityof75 onasetoflarge real worldbenchmarks.moreover quicksampler ismorethan2ordersofmagnitude faster at producing valid samples when compared to other state of the art samplers.
it is also more than orders of magnitude faster at producing uniquevalid samples which is specially importanttoincreasetestingcoverage.wehavealsoverifiedthat quicksampler is still order of magnitude faster even when it takes the additional time to verify that the generated solutions arevalid.finally thedistributionofsamplesproducediscloseto uniform on most of the benchmarks.