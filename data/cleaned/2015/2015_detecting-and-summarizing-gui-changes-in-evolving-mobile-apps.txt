detecting and summarizing gui changes in evolving mobile apps kevin moran cody watson john hoskins george purnell and denys poshyvanyk college of william mary department of computer science williamsburg va usa kpmoran cawatson jbhoskin gwpurn denys cs.wm.edu abstract mobile applications have become a popular software development domain in recent years due in part to a large user base capable hardware andaccessibleplatforms.however mobiledevelopers alsofaceuniquechallenges includingpressureforfrequentreleases to keep pace with rapid platform evolution hardware iteration and user feedback.
due tothis rapid pace of evolution developers need automated support for documenting the changes made to their apps in order toaid in program comprehension.
one of themore challenging types of changes to document in mobile appsare those made to the graphical user interface gui due to its abstract pixel basedrepresentation.inthispaper wepresentafully automatedapproach calledgcat fordetectingandsummarizing gui changes during the evolution of mobile apps.
gcat leverages computer vision techniques and natural language generation to accurately and concisely summarize changes made to the gui of a mobileappbetweensuccessivecommitsorreleases.weevaluate theperformanceofourapproachintermsofitsprecisionandrecallindetectingguichangescomparedtodeveloperspecifiedchanges and investigate the utility of the generated change reports in a controlleduserstudy.ourresultsindicatethatgcatiscapableof accurately detecting and classifying gui changes outperforming developers while providing useful documentation.
ccs concepts softwareanditsengineering softwaredevelopmentprocess management software development methods keywords mobile apps gui changes software evolution android acm reference format kevin moran cody watson john hoskins george purnell and denys poshyvanyk.
.
detecting and summarizing gui changes in evolv ing mobile apps.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 11pages.https permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
introduction mobile application development has solidified itself as a prominent specializationsforsoftwareengineers.infact accordingtostackoverflow s survey of developers over of respondents identified as mobile developers making this the fourth most popularspecialization overall behindthree differentwebdevelopment roles.
this popularity is sustained by several factors including a large and growing user base performant hardware powerful development platforms and apis and ease of software distribution through app marketplaces just to name a few.
highly competitive app stores like apple s app store o r google play contain millions of apps many of which implementsimilarfunctionality.inordertosucceedinsuchmarketplaces developersneedtoensuretheirapplicationprovidesanengaging userexperienceandaestheticallypleasinguserinterface .unfortunately paststudieshaveshownthatdesigningandimplementing effective guis can be a difficult task especially for mobile apps .
these difficulties are due in large part to challengesuniquetothemobiledevelopmentprocessthathavebeen well documented in research literature and include i rapidly evolvingplatformsandapis ii continuouspressurefor newreleases iii inefficienciesintesting iv overwhelmingandnoisyfeedbackfromuserreviews and v market device and platform fragmentation .
mobile guis are typically stipulated in files separate from the main logic of the app e.g.
.xmlfor android and .nibor storyboards for ios .
these files delineate attributes of gui components inrelativeterms e.g.
displayindependentpixel dpivalues andare arrangedaccordingtoahierarchicalstructure i.e.
aguihierarchy tofacilitatereactivedesignacrossfragmenteddeviceecosystems.
reasoning about the actual rendering of a gui using such an ab stract definition in code is a difficult task.
conversely collecting screenshotstodiscernvisualchangesisdifficult asitrequiresmanualinterventionandadeptvisualperceptionisneededtodiscern meaningful gui changes.
thus it is clear that comprehending how gui codeaffects the visualrepresentation ofan app requiresmentally bridging a challenging abstraction gap.
furthermore the design and implementation of a gui for a mobileappisnota singlecost taskthatisperformedattheinception of development.
instead gui changes must evolve to keep pace with constant user feedback and the evolution of the prescribed designlanguageandguidelinesoftheunderlyingmobileplatform e.g.
android stransitionstodifferingversionsofmaterialdesign thus developers must constantly evolve an app s gui to satisfy changing design requirements.
this illustrates that there is a clear needforautomatedsupportineffectively documenting guichanges authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. moran c. watson j. hoskins g. purnell and d. poshyvanyk to help aid developers in time consuming program comprehension tasks related to mobile app development.
in particular automated summarizationof visualgui changeswouldallowfordevelopers tomoreeffectivelycomprehendtheaffectofcode basedchanges on the visual representation of a mobile gui.
toassistdevelopersincomprehendingguichangesinmobile apps we introduce a fully automated approach aimed at detecting classifying and summarizing visual gui changes between subsequent app versions.
our approach called gcat guichange analysistool is triggered upon a specified commit to a mobile app s version control system and performs a gui differen tiation analysis.
this process begins by automatically executingthetargetapp extractingarepresentativesetofscreenshotsand gui metadata and comparing these to similar files extracted from a previous version of the same app using computer vision tech niques.
gcat then generates a comprehensive report describinggui changes that includes annotated screenshots a natural languagesummaryofguichanges andavisualizationofmatching segments of each screen s gui hierarchy.
we performed an extensive evaluation of gcat across several different quality attributes.
first we empirically examined the performance of gcat in terms of i automatically extracting filtering matching screens and ii detecting and classifying gui changes fromasetof31mobileappsfromthef droid repositoryofopen sourceapps.nextweperformedauserstudymeasuringdevelopers performance in detecting and classifying mobile app gui changes and the perceived usefulness of the gui change summarization reportsproducedbygcat.ourresultsindicatethatgcatisable to i accurately and automatically extract filter and match screens betweensubsequentversionsofandroidapps ii effectivelydetect and summarizegui changes iii outperform developersin terms of identifying detecting and classifying gui changes and iv automaticallygenerateguisummarizationreportsthatdevelopersfound useful in comprehending gui changes.
in summary this paper makes the following contributions weintroducegcat afullyautomatedapproachfordetect ing classifying andsummarizingguichangesinevolving mobile apps we conduct acomprehensive evaluation of gcat that measures its detection and classification performance compared to developers and the perceived usefulness of gcat reports wederiveasizabledatasetofguichangesisolatedfromreal fossappswhichcanfacilitatefutureresearchinprogram comprehension related to mobile guis we make available an online appendix that includes additional materials such as examples of reports generated by gcat anopensourceversionofourapproach andallstudy data to facilitate reproducibility.
background problem statement in general the goal of the approach set forth in this paper is to automaticallydetect classify andsummarizechangesthatoccurin theguiofanevolvingmobileapp.ourapproachiscurrentlyimplementedforandroid themostwidelyusedosintheworld despitebeingapplicabletootherplatformssuchasios.thus inthis paper we examine the principles of mobile guis and gui changes in the context of android.
relative layout textview textview linear layout image button image button image button partial gui hierarchy for the pandora application gui componentgui container figure illustration of the gui structure of the pandora android application .
mobile gui fundamentals inthecontextofandroidtherearetwobasiclogicalconstructsthatcomprise the gui of a mobile app which are illustrated in figure .
the first of these is a gui component.
gui components used interchangeably with the term component in this paper have been definedinpriorworkas atomicgraphicalelementswithpre definedfunctionality displayedwithintheguiofasoftwareapplication .
in the context of android there are several differenttypes of components such as textviews buttons and numberpickers .
each of these serves a distinct set of purposes.
for instance a buttonis typically used to trigger certain functionality from the code and anumberpicker allowsa userto selectfroma pre definedrange of numbers as input.
in addition to their typethere are also several stylistic detailsthat define acomponent such asa displayedimage colors or font.
two textview components and three imagebutton components are shown highlighted in green as part of the gui for thepopularpandoramusicappinfigure .asthisfigureshows each component has a bounding box that stipulates the area occupiedbythecomponent thisistypicallydefinedbyspatialcoordinatessuchasthe xandycoordinatesofthetopleft handcornerof the box and its widthandhei ht.
however gui components are not the only building block that compriseamobilegui.therealsoexist gui containers whichhave been succinctly defined in prior work as a logical construct that groups members of gui components and typically defines spatial display properties of its members .
thus gui containers are largely meant to help provide a spatial structure to the gui and define stylistic details regarding the background or canvas upon which gui components are rendered.
gui components are typically rendered on a screen according to the spatial properties of theircontainers ratherthanpredefinedscreencoordinatevalues.
thisallowsforamoreflexibledesignthatcanfluidlyadaptbetween devices with different display dimensions and densities.
two guicontainers a relativelayout anda linearlayout arehighlightedin red for the pandora app in figure .
whentakentogether gui components andgui containerscompose agui hierarchy which typically takes the form of a rooted treewheresmallercomponentsandcontainersexistwithinasingle container that serves as the root of the hierarchy.
in figure a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detecting and summarizing gui changes in evolving mobile apps ase september montpellier france table the taxonomy of gui changes used in the development and evaluation of gcat change category specific change description text changetext change the text content of a component from a previous version of the app does not match a later version font change the text font of a component from a previous version of the app does not match a later version font color change the text font color of a component from a previous version of the app does not match a later version layout changevertical translation the location of a component was translated in the vertical direction between versions of an app horizontal translation the location of a component was translated in the horizontal direction between versions of an app vertical size change the size of a component was changed in the vertical direction between versions of an app horizontal size change the size of a component was changed in the horizontal direction between versions of an app resource changeimage color change the color of an image associated with a component changed between versions of an app removed component a component was removed between versions of an app added component a component was added between versions of an app image change the image associated with a component was changed between versions of an app component type change the type of a component changed between versions of an app a version .
.
b version .
.
figure illustration of gui changes in fasthub partial gui hierarchy for the pandora app is illustrated as a tree.
inthis hierarchy the relativelayout servesas therootnode with othergui componentsandcontainersfillingoutthetree.asstated earlier the gui hierarchies for mobile apps are typically defined in a domain specific language outside ofthe functional code of an app.
in android properties of the gui are stipulated in xml files in the app resource directory e.g.
res layout using a domain specificxmlformat.whenanandroidapp sguiis renderedona device screen metadata describing the gui including information suchasthecoordinatesofrenderedcomponents theirtypes and whetherornottheyareinteractive canbereadfromadeviceusing theuiautomator framework.itisimportanttonotethatthereare distinctdifferencesbetweenthestaticanddynamicrepresentations of an app s gui.
full information regarding the appearance of a guicannotbegleanedfromthestatic coderepresentationalone asthisinformationisdefinedinrelativetermsandtheguimustbe interpreted and instantiated for target screen attributes.
further more components such as lists can be dynamically populated at runtime which impacts gui appearance.
.
evolutionary gui changes now that we have described the basic building blocks of mobile guis it is important to understand how gui changes affect these building blocksand how theymight belogically categorized.
ata high level a gui change canbedescribedasanymodificationto the spatial or stylistic properties of a gui component or container.
there are a finite number of logical manners in which components canbealteredbetweenappversions.inordertoaccuratelydescribe guichanges itisimportanttostipulatedifferentcategorizations of changes that might occur.
to dothis welook topast workon detectingdesign violations in mobile apps .
adesign violation in the context of mobileapps has been defined as a mismatch between the attribute vectors of two gui components that exist both in a mobile gui mock up and implementation where the attribute vectors can be rep resented as a a four tuple in the form x position y position height width text image .inthisworktheauthors performed a grounded theory survey on an industrial dataset of design violations and derived a taxonomy.
given that in this work a design violation essentially describes a changein a mobile gui albeitoneintroducederroneouslybyadeveloper weadaptthis taxonomytodescribe gui changes thatsurfacebetweensubsequent versions of a mobile app.
our gui change taxonomy is described in table 1and consists of three main categories i text changes that concern differences in text displayed by components ii layout changes that concern differences between the spatial properties of components and iii resource changes that describe phenomena such as missing or added components or differences between utilized images or colors.
each of these three main categories has a subset of specific change categories which directly describe a gui change.
it should be noted that more than one gui change can apply to a single gui component.
for instance a component might change in size and location between app versions.
some examples of gui changes between subsequent app versions of the popular fasthub github clientareillustratedinfigure .forexample the accesstoken textview component exhibits a layout change whereas the the enterprise textview component representsan added component change.
the textview component which displays sign in using yourgithubaccounttousefasthub exhibitstwochangetypes namely a text change and asize change.
given this background on mobile guis and our gui change taxonomy our problem statement can be formulated as follows problem statement given an android app with a change history v1 v2...vi our approach aims to automatically extract screenshots andguimetadatafortwoversions viandvksuchthat k i.then our approach aims to filter corresponding screens between the twoversions and detect classify and summarize gui changes between corresponding pairs of screens.
the gcatapproach therearethreemaincomponentsofthegcatapproachdepicted infigure i versioncontrolintegration ii automatedgui based exploration and iii guiinterpretationandchangedetection.gcat is able to analyzesubsequent commits from a software repository authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. moran c. watson j. hoskins g. purnell and d. poshyvanyk integration with version control git ci integration2 automated gui based exploration project historyvirtual or physical device pool n1 n2 n3n4n5 t7t3 t17t35t12 t25t42 t59t29 t21n6crashscope automated execution engine screenshot metadata pairs commit i screenshot metadata pairs commit i n3 gui interpretation change detection screen matching filtering activity window comparator bipartite image comparisongui hierarchy for commit igui hierarchy for commit i n leaf node component detection and matching gui change resolution perceptual image differencing pid gui change report layout change detectiontext change detectionresource change detection nl summary generator checks x y checks width height normalized string comparison image comparison analysis commit icommit i 1commit i 2commit i n figure overview of the gcatapproach that utilizes a version control system such as git and automatically compiles and executes target commits.
it then filters and matches screens discovered during automated exploration of a target app s gui and finally detects and reports changes related togui components.
gcat was implemented for the android plat formandiswritteninjava.itwasdesignedtoallowforincorpo ration into continuous integration and version control systems to facilitate fully automated generation of documentation.
from a developer s perspective gcat would simply need to be installedon a developer s machine or integrated into continuous integration ci pipeline and frequency of analysis specified e.g.
running on each commit or major releases etc.
.
then developers could viewtheweb basedgui change reportseitherlocally orvia aci system inorder tomoreeffectivelycomprehend thegui changes between subsequent app versions.
in this section we describe each component of the gcat approach.
.
integration with version control in order to provide practical automated documentation of gui changesasamobileappevolves gcatcantakeadvantageofthe versioncontrolsystem ofatargetmobile app ssoftware repository.
furthermore gcat could be triggered in a continuous integration pipeline such as travisci or gitlab s ci framework as illustrated in figure .
in order to derive and document changes in a change report gcat accepts two subsequent commits iand i nwherenrepresents the number of commits between analyzed versions.whenanewrepositoryiscreated orgcatisaddedtothe cisystemofanexistingrepository gcatautomaticallycompiles and performs automated gui based exploration of the most recent commitoftheprojectandcachesextractedscreenshotsandguirelatedmetadata.additionally adevelopermaystipulatethatgcat analyzesubsequentpairsofhistoriccommits.thechoiceofhow frequentlytorungcatislefttothedeveloper.insection 4wedetail our experimental methodology for deriving subsequent commits.
.
automated gui based exploration oncetwocommitshavebeenisolatedfromanandroidapp srepos itory screenshots andmetadatadescribingtheprogrammaticstructure ofthe gui hierarchy associated with thesescreenshots must beautomaticallyextracted.then onceasetofscreenshasbeenex tracted corresponding screensfromthepairoftargetcommitsmustbematchedwithoneanother andredundantscreensmustbefiltered out in order to reduce the information burden on developers.
this process is illustrated in figure .
.
.
automated gui exploration.
in order to automatically explore the gui of a target app gcat makes use of the crashscope gui explorationengine.crashscope sautomated exploration simulates touch events on a mobile device or emulator to explore the screens of a target app.
to do this effectively thecrashscopeengineperformsasystematic depth firstsearch dfs exploration of an app s gui that has been shown to achieve comparable coverage to other testing approaches .
during this explorationprocess theguiofanappisanalyzedinrealtimeusing android s uiautomator framework.
interactive components are identified and an event flow model of an app is constructed in an online manner.
dfs exploration proceeds according to a given set ofparametersknownasan explorationstrategy .inouradaptation of crashscope s exploration engine for gcat we utilized two variations of the dfs gui traversal a top down variation where interactive components are exercised from the top of the screendown and a bottom up variation where interactive components are exercisedfrom thebottom ofthe screenup.two variationsof text input strategies were utilized one strategy generated expected textbyinputtingallowablecharactersaccordingtoparametersof a given text field and another strategy generated no textto be input to text fields.
we chose not to implement other strategies fromtheoriginalcrashscopeexecutionengineduetothefactthat these strategies were more likely to discover crashes from a target app and our objective in gcat is not crash detection but rather state exploration.
the selected exploration and text input strategiesexhibitedhighercoverageinpastwork .foreachaction thatcrashscopeexecuteson adevice a screenshot and dumpof the gui metadata from uiautomator are saved before and after the action sexecution.thissetofscreenshotsandgui metadataare then passed to the screen matching and filtering procedure.
currently gcat only supports gui comparisons between corresponding screens captured on the same device.
however it should be noted that the automated exploration for gcat can be run on aconcurrentsetofvirtualandroiddevicesthatsimulatearange of screen sizes densities in order to extract gui information for a predefined set of device configurations.
gcat reports can then begeneratedfor corresponding screenpairsonaper devicebasis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detecting and summarizing gui changes in evolving mobile apps ase september montpellier france furthermore gcatcouldbeadaptedtoutilizeasetofpre specified automatedguitestsusingatestwrapperthatcapturesscreenshots and uiautoamtor files after each test case step.
.
.
screen matching and filtering.
using the screenshot and metadatapairsthatcanbegeneratedforagivenpairofcommits correspondingscreens screensthatretainhighlysimilarintended functionality can be identified between commits for which useful changereportscanbederived.wemodelthisprocessasabipartitematchingproblem wherethecostofanassignment cbetweenany two screen pairs s1 s2is the sum of two values c s1 s2 cd bbox dif f wherecdisequaltotheeuclideancolordistancebetweenthetwo images and bbox dif fisequaltothe normalizedpixeldifference between two binary images b1andb2 created by drawing white filledrectanglescorrespondingtotheboundingboxesoftheleaf nodecomponentsontoablacksilhouetteofthescreen.eachbounding box will only be drawn if its total area is less than 100k pixels to avoid large overlay components from affecting the analysis.
bothconstituentsoftheassignmentscoreareorthogonallybeneficial cdisabletocapturepurevisualsimilarity butisapoormeasureofmatchingpotentialinexampleswheretherearealargenumber ofcolorchanges.
forthese cases we needa wayto utilizethe structuralinformationofthescreenshotsprovidedby bbox dif f. both sets of nodes in our bipartite graph correspond to the screenxml pairs for their respective commits.
the edge weights between each node are equal to c si sj for alli jin each set.
once the graphisconstructedasanadjacencymatrix m wefindamatching such that it minimizes the sum cost of all assignments.
the optimization algorithm used in our implementation runs ino n3 time.inaddition thesetsofscreensfromtargetpairsof subsequent commits may be quite large.
thus in order to make thisprocessdramaticallymoreefficient wedefinedalightweight heuristic to cut back on superfluous screens and reduce the size of the sets.
during each step in the automatic gui exploration thenameofthecurrentactivityisrecorded aswellasthenameandtype of the currently active window e.g.
fragment popup .
this informationwas extractedat eachstep ofthe executionusingthe adb shell dumpsys window windows command.usingthisinformation wefilterourscreensetssuchthatonlyscreen xmlpairsthat representthefirstoccurrenceduringtheautomatedexecutionof a unique activity window pair are kept.all others arediscarded.
from a developer s perspective gui change reports will only be generatedformatchedscreens however gcatcouldalsobeconfiguredtoallowadevelopertoexamineunmatchedscreenspairs and trigger the change analysis for these pairs.
.
gui interpretation change detection once corresponding screen pairs between a target pair of commits have been extracted using gcat s automated gui exploration and screen matching and filtering techniques gcat then needsto identify the gui changes that occurred between these screenpairs.
to do this gcat decodes the hierarchical representationof the gui represented in a given screenshot using data from uiautomator xmlfiles.itthenidentifiesandmatchescorresponding gui components between screen pairs analyzes corresponding componentsforchanges andclassifiesthesechanges.finally anhtml basedguichange reportisgeneratedcompletewithimages and natural language descriptions of changes.
this process is visualized in figure .
.
.
guihierarchyconstruction componentmatching.
fora given corresponding screen pair gcat parses the uiautomator xml filesassociatedwitheachscreenshotandconstructsatree based representationofthegui hierarchy.itthenparsesandstorescollections of leaf node components for each screen including several attributes such as location information e.g.
x y width height and the component type e.g.
imagebutton .
as stated earlier gcat reports gui changes according to leaf node components as they tend toalso reflect changesto container components.
thus gcat employsa k nearestneighborsmatchingprocedurebasedonspatial componentinformationthathasprovensuccessfulinpastworkon reportingguidesignviolationsformobileapps .duringthis procedure each component is matched against its closest neighbor according to the following simialrity score xm xr ym yr wm wr hm hr where a smaller represents closer matches.
the x y wandh variables correspond to the x ylocation of the top and left hand borders of the bounding rectangle and the height and width of the bounding rectangles for components respectively.
.
.
gui change resolution.
after corresponding pairs of leaf nodecomponentshavebeenidentified gcatmustthendetectgui changes between screens.
gcat first employs perceptual image differencing pid an image differencing algorithm modeled after the human visual system that has been successfully applied in past researchondetectingguidifferences .pidhelpstoidentify asetofpotentialchangesbasedonvisualdifferencesbetweenimages.then eachofthesepotentialguichangesisanalyzedfurther to determine the specific type of change to report.
this in depth analysis varies depending upon the type of change.
these analyses have been adapted from prior work on detecting gui design viola tions to work with gui metadata from corresponding screens extracted from commits of a target app.
layoutchanges identifying layoutchanges isrelativelystraightforward.
gcat simply compares the x y and width hieght valuesforeach pairofcorrespondingleaf components.ifdifferences inx y widthorhie htvary by more than a threshold lc then a layout change is reported.
text changes therearethreedifferenttypesoftextchanges i font color change ii font style change and iii text content change.eachofthesespecifictypesisdetectedinadifferentmanner but all utilize cropped images for each pair of potentially changed text components by cropping an image from both previous and subsequent screenshots according to the bounding boxes of the components in question.
to check for a font color change a color histogram ch is constructed for each cropped image by accumulatinginstancesofalluniquergbpixelvalues.gcatthencalculates the normalized euclidean distance between these color histograms and if the distance is greater than a threshold fca font color changeisreported.ifthecolorhistogramsdomatch thenafont stylechangeisreported.todetectchangesintextcontent strings betweentextcomponentsarepre processedtolowercase spaces areremoved andtheresultingstringsarecompared.ifthestring authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. moran c. watson j. hoskins g. purnell and d. poshyvanyk values do not match a change is reported.
our implementation of gcat uses an fcvalue of .
resource changes gcat is able to report different types of resourcechangesincluding i addedcomponents ii removed components iii imagecolorchanges iv imagechanges and v componenttypechanges.leafnodecomponentsthatareaddedto a subsequent version of an app correspond to components without a matched corresponding component.
thus these are reportedas added component changes.
likewise missing componentsare those components from the previous version of the app that were not able to be matched to components in the subsequent version.
image changes are detected by extracting cropped images of components in question from screenshots of both versions of an app.
then these cropped images are converted to a binary color space e.g.
black and white and pid is run again.
if the images do match according to pid within a threshold icthen an image change is reported.
otherwise a color change is reported.
in our implementation of gcat ic .
.
.
natural language summary generation.
the gui change reports generated by gcat contain a nl summary as well nl descriptions of each identified change.
gcat s natural language summariesof allgui changesincludeadescriptionofboth what happened as well as whereit happened.
to do this gcat identifies thepartsofagivenscreenthatcontainthemostchanges.first thescreenisdividedintoacongruent3x3gridandchangesareassigned to each grid region.
if no grid section in the 3x3 division contains a majorityofchanges thescreenisdividedintoacongruent2x2girdandtheprocessisrepeated.thishelpstoinformthenldescription ofwherechanges occurred.
after changes are isolated to particular areas of the screen they need to be effectively summarized.
we use a heuristic based ap proach for general summarization.
each change is described by threecharacteristics level astringdescribinghowmuchthe guis changed visually location the location on the screen that changed the most and amount a string describing the number of changes made to the gui.
dependingonthevaluesoftheaforementionedcharacteristics our processdetermines which formthe template will take.an example summary is given in figure .
we forgo an enumeration of the template and potential combinations due to space limitations however thisisshowninourappendix.nldescriptionsof individualgui changetypesaregeneratedaccordingtodifferent templates specific for each change type.
.
.
reportgeneration.
gcatgenerates htmlbasedreportsthat enumerate gui changes in four major ways three of which areillustratedbytheexamplereportinfigure .thefirstoftheseis a set of full screenshots depicted at the top of the report where the previous and subsequent screens are shown on the left and the right respectively and the middle screenshot highlights changes fromtheperspectiveofthepreviousversionscreenshot.thesecond piece of information reported is the nl summary of changes in the gui.
the third piece of information is a list of detailed changes on a component by component basis.
these include both a nldescription and if clicked on a side by side comparison of thecomponents in the old and new version of the app.
finally the figure partial example of a report generated by gcat fourthpieceofinformation notshowninfigure isthemaximum common spanning tree of the screen pair gui hierarchies.
design of the experiments the overarchinggoal of gcatis todetect classify and summarize gui changes that occur in mobile apps as they evolve.
thus toevaluate gcat we carry out an empirical study aimed at investigating the performance of the approach and a user study aimed at analyzinggcat s usefulness todevelopers.
tothis endwe explore the following four rqs rq1 how well does gcat sscreen matching and filtering procedure function?
rq2 howwelldoes gcatperformintermsofdetectingand classifying gui changes that occur during the evolution of mobile apps?
rq3 isgcatable to more accurately detect and classify gui changesinevolvingmobileappscomparedtomanualefforts from developers?
rq4 do developers find gcatreports useful for documenting and summarizing gui changes in evolving mobile apps?
in the context of our study rq r q2 and rq 3are directed towardquantitativelymeasuringhowwellgcatperformsinterms of extracting screens and detecting and classifying different types of gui changes that occur during the evolution of android apps.
rq4isaimedatqualitativelymeasuringtheperceivedusefulnessof gcat reports by collecting feedback regarding the user experience andpreferences.tocollectuserdatatohelpanswerrq rq4we conducted a user study in the form of an online survey.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detecting and summarizing gui changes in evolving mobile apps ase september montpellier france .
study context in order to evaluate gcat we required a set of popular subject applications from which a collection of gui changes for particular screensbetweensubsequentappversionsexist.toderivethisset of screens we utilized a set of applications from fdroid .
tocollecttheseapps threeauthorsmanuallycrawledorthogonal sections of fdroid and downloaded the set of available release apksfor each app.
in order to facilitate controlled experimentation and ensure a sizable set of screen pairs with existing gui changes the same authors launched subsequent versions of the apps on concurrent nexus emulators running android .
from genymotion andensuredthatatleastonecorrespondingscreen pair between the two versions exhibited a gui change.
apps with out any version pairs that could be launched on the emulator that were hybrid apps used non standard components or that did not exhibit any gui changes were discarded.
this process resulted in a setof62 apkscorrespondingtoprogramversionsfrom31apps.we provide detailed information about these apps and make all of our study data available in our online appendix .
.
rq evaluating gcat sscreen matching and filtering tomeasurehowwellgcat sscreenfilteringandmatchingprocedure function we ran each of the apksextracted for the study throughthesystematicautomatedinputgenerationapproachderived from the crashscope.
the average time per app for running thisexplorationstrategyandextractingthescreenshotsandgui metadatais39.46minutesperapp.however itshouldbenotedthis process is completely automated and can be run passively in the background.wethenmeasuredtwometrics i thepercentageof filteredscreens fs and ii thematchingprecision mp .thefs metric measures the number of redundant screens filtered and the mpmetric illustrates the number of correctly matched corresponding screens.
more formally these metrics can be represented as fs ts fs ts 100mp tp tp fp wheretsisthetotalnumberofscreensdiscoveredbycrashscope fsis the number of screens filtered by gcat tpis the number ofcorrectlymatchedscreens and fpisthenumberofincorrectly matched screens.
one author examined the matched screens pairs from gcat in order to determine the tpandfp whereas the other metrics can be calculated automatically.
.
rq measuring the performance of gcat themain goalofthis rqisto examine howwellgcatperformsin terms of detecting and classifying real world mobile gui changes.
inapracticalusecaseofgcat theentiregui changereportgeneration process is automated from the extraction of corresponding screenpairs tothereportgeneration.thus ininvestigatingthisrq weaimedtoemulatethisautomatedcontextbyusingtheoutputof gcat s screen matching and filtering procedure carried out as part of the previous rq .
gcat sscreenfiltering matchingprocedure resultedinasetof screen pairs consisting of screenshot gui metadata tuples for correspondingscreensbetweendifferingapplicationversions.gcat was then applied to screen pair tuples that were correctly matched a previous application menu bar b new application menu bar figure illustration of a potential ambiguous gui change andthegui changesummarizationreportsweregenerated.during thegeneration process wealso measuredthetime takenbygcatto generate each report.
tomeasuretheperformanceofgcatindetectingandclassifyinggui changes threemetricswerecalculated i thedetection precision dp ii the classification precision cp and iii the recall r .thedpmeasureshowwellgcatcandetectguichanges whereas the cpmeasures how well detected changes are classified intotheircorrespondingtypes.wemakethisdistinctionbecause gcatiscapableofdetecting butincorrectlyclassifyingcomponent changes intotheir proper types.
dp cpandrwere measuredas dp cp tp tp fpr tp tp fn where for dp tprepresents gui changes that were detected by gcat and for cp tprepresents gui changes that were both detectedandcorrectlyclassifiedintheirpropertype.foreachofthese metrics fpcorresponds to detected gui changes that either did not exist or that were misclassified respectively.
for recall tprepresentsguichangesthatwerecorrectlydetectedand fnrepresents existing gui changes in the ground truth that were not detectedby gcat.
due to the cost of calculating these metrics explainedbelow we randomly sampled screen pairs from the correctly matchedcorrespondingscreenstoanswerrq .tofacilitatethis we ran each of the screen pairs through pid and ranked them in threegui changegroups high medium andlow accordingto the rank of the percentage of difference pixels reported by the pid procedure.
screen pairs classified in the high group exhibited a high amount of pixel difference according to pid and thus a larger numberofgui changes whereasthelowgroupexhibitedalow amount of pixel difference according to pid and thus had a low number of gui changes.
we randomly sampled an even number from each group to provide for a varied set of gui changes.
.
.
metric collection procedure and gui change ambiguities.
in order tocollect these metrics it is necessaryto manually examine eachpairofcorrespondingscreensbetweenversionsandgenerated reports.
however this isa veryexpensive manual procedurethat involvesevaluators visuallyexamining screenshots and inspectinggui metadatainordertocalculatethemetricslistedabove.furthermore classifications of gui changes between subsequent versions of an application are open to multiple subjective interpretations which may impact their calculation.
for example take the menu barofthesgitapplicationshowninfigure .thisgui changeis relatively simple an additional icon was added in the new app version.ho wever this couldbeinterpretedinmultiplemanners.for example one interpretation may be that the icon was changed tothe icon anew wasadded andthe iconwasshiftedto theleft.anotherinterpretationmaybethatthe iconwasadded and the and icons were shifted to the left.
both of these are authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. moran c. watson j. hoskins g. purnell and d. poshyvanyk valid interpretations of the gui change.
in fact during our experimental investigation we came across different types of gui change ambiguities thatmayleadtomultipleinterpretations.weforgoa detailed discussion of all ambiguities but provide descriptions and examples in our online appendix .
inordertoeffectivelycollecttheevaluationmetricslistedearlier we took several measures to ensure accurate calculations.
first wedevelopedatoolthatparsesinformationfrombothscreensin a corresponding screen pair and prints formatted readouts that list each gui component its corresponding spatial metadata a croppedimageofthecomponent andthepidoutputinorderto helpinmanualcalculationofthesemetrics.second forrq 2and rq3 wesimplyaccepted anycorrectinterpretationofaguichange as correct when calculating the dpandcp.
third we employed multipleindependentmanualevaluatorstoexaminethereportsandscreenpairstocalculatethemetrics.morespecifically twoauthors independentlycalculatedthemetricsfor eachscreenpair.thena third author evaluated the responses from the first two evaluators anddeterminedthefinalcalculationsfromthecombinedresponses.
.
rq measuring developer performance in detecting and classifying gui changes themain goalofthisrqistocomparetheeffectivenessofgcat to developers at detecting and classifying gui changes.
in order tocarryoutthiscomparison weneededtoexaminehowwelldevelopers are able to comprehend and report changes in the guis of mobile apps.
thus we conducted a user study in the form of an online survey consisting of four major components i a backgroundcomponent that introduced the concept of a gui change andourtaxonomyofgui changetypes ii a demographic component that asked participants about their programming background iii agui comprehension component that asked participants to examine pairs of screenshots containing changes and documentthese changes and iv a report feedback component that asked participants to examine gcat reports and answer questionsabout their usefulness.
the gui comprehension component of this user studyhelpstoanswerrq whereasthe reportfeedback component helpstoanswerrq 4andisexplainedinfurtherdetailinthenext subsection.
faculty and graduate student participants with at least three years of programming knowledge were recruited across different universities.
to derive the screen pairs to be used in both parts of the user study threeauthorsexecutedconcurrentcorrespondingversionsof each of the apps and identified at least one screen pair between the two versions that contained a gui change.
for each identified screen pair with gui changes a screenshot and gui metadata file were extracted using the android debugging bridge s adb screencap utilityandthe uiautomator frameworkrespectively.this resulted in a set of app screen pairs.
note that we did not use crashscope and gcat s filtering procedure to produce this set of screens in order to control the quantity of pairs for the user study.
given that the set of screen pairs extracted for the user study were taken from subsequent versions of real apps the extent to whichthe guichangedvaries acrossthedataset.
however in the contextofthe gui comprehension userstudy wewanttounderstand the extent to which each participant can comprehend both simpleandcomplexgui changes.thus similartotheprocedureusedin rq2 we divded the screen pairs into three groups according to thepidscore.forthe gui comprehension componentoftheuser study we randomly selected screen pairs from the candidate set of50 ensuringthatthe30screenswereevenlydistributedacross the three gui change groups.
each participant in the study was assigned3screensfromthissetandthescreenswereassignedin such a manner that each screen was evaluated by two participants eachparticipantevaluatedonehigh onemedium andonelow fromeachgui changegroup andtheorderinwhichthescreens were presented to participants was randomized.
during the gui comprehension component of the survey participantswereaskedtoexamineeachscreenpairandreporteach gui change according to the taxonomy presented at the beginning of the survey.
the gui change taxonomyto be used was repeated onthesurveyscreenwhereparticipantsdescribedthegui changes for reference.
each screen pair was accompanied by a text input box where participants were instructed to record one gui change per line in the form gui change category description of the guichange .afterallsurveyresponseswerecollected the dp cp andrforeachparticipantwascalculated.threeauthorsderived thegroundtruthandtheevaluationmetricsforthesetofuserstudy screens following the same methodology as in sec.
.
.
.
rq investigating perceived developer usefulness of gcatreports thegoalof this rq is measure the perceived developer utility of gcat reports.
this was carried out through the report feedback component of the user study survey.
for this component of the survey eachparticipantwasshowntwoscreenpairs andthecorre spondinggcatreportforthesescreens.theparticipantswerethenasked5likert based userexperience ux andfivefree response user preference up questions whichwerederivedfromsususability scale introduced by brooke and the user experience honeycomb by morville respectively.
the screen pairs for the report feedback componentoftheuserstudysurveywerecomprisedofthe 20remainingscreensafterthesamplingforthe gui comprehension component.screenswereassignedtoparticipantsinsuchamannerthateachscreenpairandreportwereevaluatedbytwoparticipants screenpairsweredistributedasevenlyandrandomlyaspossible across the gui change groups.
empirical results .
rq performance of screen filtering and matching ourfirstrqinvestigatestheperformanceofgcat sscreenfiltering andmatchingprocedure.runningcrashscopethroughall61of our subject apksresulted in total extracted screens or screens per apk.
gcat s filtering procedure was able to reduce this settoamuchmoremanageable316screensforthematchingprocedure.
this results in an fsmeasurement of .
meaningthatover90 ofthecollectedscreenswere filtered out as redundant drastically reducing the information burdenondevelopersforreadinggui changereports.thesefiltered screens resulted in matched screen pairs which exhibited a matching precision mp of .
.
this illustrates that gcat is able authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detecting and summarizing gui changes in evolving mobile apps ase september montpellier france figure gcatdp cp andr to both effectively filter and match corresponding screen pairs that were automatically extracted from automated dynamic analysis of subsequent app versions.
.
rq gcatperformance runninggcat schangeanalysisoverthe158matchedscreenpairs tookanaverageof13.1secondsperscreenpair.thegcatresults fordp cpandrare illustrated as box plots across the analyzed reports in figure .
gcat is able to achieve an average dpof .
and an average rof .
however cpis a bit lower than these with an average value of .
.
this means that gcat is able to effectively detect gui changes with few false positives and rarely missesreportingexistinggui changeso nascreen.
however when classifying thesegui changes intotheir corresponding taxonomy categories there were certain cases of incorrect classification.
the largest source of false positives in terms of the cpcame from ambiguities relatedto font changes and font colorchanges.
asexplainedinsection .
gcatderivesacolorhistogram ch fromcroppedimagesoftextualcomponents andiftheeuclidean distancebetweenthesecolorhistogramsdoesnotmatchwithin agiventhreshold thenafontcolorchangeisreported.however thesensitivityofthisthresholdcanvarybetweendifferentstyles of fonts making it difficult to properly tune.
this results in several fontcolorviolationsbeingclassifiedasfontstylechanges.however itshouldbenotedthattheseclassificationsareverysimilarand arelessimpactfultotheutilityofreportsthanifamoreorthogonal classification was made e.g.
font color layout change .
.
rq developer performance thedeveloperresultsfor dp cpandrareillustratedasabox plots across the analyzed reports in figure .
on average developers achieveda dpof94.
anda cpof91.
.however theirrecall suffered quite a bit with developers on average only reporting .
ofexistinggui changesforagivenscreenpair.furthermore on average developersrequired minutesand seconds todetect and classify the gui changes for the three assigned screen pairs.
in general this means that while developers were generally accurate atreportingandclassifyingchangeswhentheyrecognizedthem there were a large number of changes that were not reported and the reporting process was time consuming.
the underlying reason for missed changes varied across developers and screen pairs.
incertaincases subtlechangesinthelayoutorsizeofcomponents were not reported however in other cases more easily observable changesweremissed includingthefailuretoreportentirelynewor removedcomponentsbetweenscreenpairs.whencomparingthe developer sperformancetogcat wefindthatgcatoutperformed developers in each metric.
figure developer dp cp andr figure average developer ux question responses.sd strongly disagree d disagree n neutral a agree sa strongly agree .
rq perceived utility of gcatreports theresultsfortheuxquestionsusedtomeasurethedeveloperperceivedusefulnessofthegcatreportsaregivenasaveragevaluesin figure8.
these results are generally very positive with developers agreeing on average that the gcat reports are i easy to understand ii usefulforidentifyingguichanges and iii applicableforfrequentuse.theyalsogenerallyfoundthatgcatreportswere not cumbersome to read or overly complex.
these responses help to illustratetheutilitythatdevelopersfoundwhenexaminingreports.
for the user experience questions ux we asked participants about four aspects of the reports i the information that was most useful ii what additional information would have been helpful iii the elements they liked the most from the reports and iv the elementstheylikedtheleastfromthereports.inresponsetothe first question many users indicated that they found the full annotatedscreenshots anddetailedlist ofgui componentchanges themostuseful.forexampleoneparticipantresponded thedetailed changes since they show the status of the elements before after thechanges.
whereasanotherparticipantindicated seeinghow componentsmovedwiththe highlightedredboxes.
.thedevelopers alsogavesomeusefulfeedbackforimprovementstothetool.for example a way to group the changes or a potential importance e.g.
a new component may be more important as compared to a 2px change .
.in respondingto whichelements theyliked themost the responses mostly echoed the first question where the side by side annotated screenshots and detailed list of gui changes were the most cited.
finally while some participants indicated that they did notdislikeanyoftheinformationinthereports otherscitedthe nlsummary andtreecomparisonasareasforimprovement.we provide the full set of responses in our online appendix .
limitations threats to validity limitations our experimental evaluation of gcat has shown the toolachievesremarkableeffectiveness however theapproachdoes exhibit certain limitations that serve as motivation for future work.
currently our approach may not properly handle dynamic screen authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. moran c. watson j. hoskins g. purnell and d. poshyvanyk content.
for example a list that is loaded over the network that mightnot actuallychangebetweenversionscouldbedetectedas a series of gui changes due to differing content.
this problem could be mitigated by asking developers to annotate certain screen content as dynamic or through automatic recognition of dynamic contentviamachinelearning.second currentlyourapproachoperatesonlyonnativeandroidapps andhasnotbeenimplementedor testedforiosorhybridapps.however weexpecttheunderlying techniquesfordetectingandclassifyingguichangestoapplyto other types of apps and platforms where the largest challenges lie inengineeringmethodstoextractaccurateguimetadata.finally our study of gcat s screen matching algorithm revealed limitationsofourapproach as ofthescreenswerenotcorrectly matched.
future work could look towards exploring more sophisticatedmatchingalgorithmsthattakegreateradvantageofcertain structural properties of gui metadata.internal validity in our experiments evaluating the gcat approach internal threats may arise from our manual examination ofreports rq andresponsesfromusers rq .however three authors independently examined all reports and user responses followingaset rigorousmethodology.also ourresultsillustrate clear trends that we expect would hold across different evaluators.
construct validity one threat to construct validity concerns differences in the sets of screen pairs utilized to investigate rq 2and rq3.
in answering rq 2we used randomly sampled screen pairs thatwereautomaticallyderivedfromgcat sautomatedguiexplorationengine.thisstudywascarriedoutinthiswaytoevaluategcat in its intended fully automated use case.
however for the userstudy weneededmorecontroloverthenumberofscreenpairs in order to design the screen pair assignment for participants and thuswemanuallyextractedscreensfromoursetofsubjectapplica tionsthathadknowndifferences.however thesamplingprocedure based on pid described in section 4ensured that a similarly varied set of screens was used between the two studies mitigating this threat to validity concerning our experimental observations.
external validity we utilized a set of open source subject applications from the f droid marketplace in our experimental evaluation of gcat.
there is the potential that the experimentalresults observed in this paper may not generalize to a larger setof applications or that the guis of the open source applications studieddifferfromthoseofpaidappsongoogleplay.howeverour set of subject applications represent varying sizes and popularities ofapps.thusweassertthatoursubjectsetofapplicationsisvaried enough to draw meaningful experimental conclusions.
anotherthreat to external validity concerns the generalization of the results of our developer survey to a broader set of mobile developers.
whileourparticipantsprimarilycamefromacademicbackgrounds they had an average general programming experience of .
years andanaveragemobileprogrammingexperienceof1.5years.furthermorepastworkhasfoundresponsesfromsuchstudiestobe representative of professional developers .
related work thereisasizablebodyofexistingthataimstoautomaticallysummarizecode relatedinformation suchasmethodsandreleasenotes .however weforgoadetaileddiscussionofthesetechniques as they do not specifically attempt to summarize aspects of guis.gui differencing the most closely related work to ours is that by xieet al.who introduced a gui differencing approach called guide .
guide is capable of resolving mappings between gui objectsofguihierarchytreesindifferentappversions however its matching procedure is not described in detail.
while guideis capable of deriving gui mappings it is not capable of detect ing reporting or summarizing gui changes that occur between these mappings.furthermore the effectiveness ofguide was not evaluated on a large dataset of apps with existing gui changes.detectingpresentationfailuresinmobile webapps agrowing body of work has been dedicated to detecting presentation failuresand design violations in mobile and web apps.
moran et al.
introducedgvt whichiscapableofdetectingdesignviolations andpresentationfailuresthatoccurbetweenamock upofanapp s gui and its implementationof that mock up.
while this approach sharessimilaritieswithgcat thereareseveralkeydifferences.first rather than resolving information between a gui mock up and an implementationofthatmock up gcatmustresolveinformationbetweensubsequentappversions.second whereasgvtrequires themanualspecificationofscreenstocompare gcatderivesthese screens automatically via automated gui exploration of an app.
third gcat aimsto supportcomprehension tasks and thusmust effectivelysummarizetheguichangesbothvisuallyandinnatural language.
there is also an existing body of work that aims to detect classify and fix presentation failures in web apps .
however these approaches do not target mobile apps and are not concerned with summarizing gui changes in evolving apps.cross browser testing there also exist approaches for xbt also known as cross browser testing that are capable of detectingandreportingdifferencesbetweenwebpagesrenderedindifferenttypesofbrowsers.whilethisworksharessomeunderlyinggoalswithourapproach e.g.
detectingcorrespondingscreens gui elements gcatexhibitsafewnotabledeparturesthatillustrateits novelty.
first in order to effectively summarize evolutionary gui changes gcat is capable of classifying detected changes into common change categories for mobile app guis.
second our approach is able to generate human readable reports that contain natural language summary changes at multiple granularities.
conclusion future work we present gcat an automatic summarization tool used for detectingandreportingguichangesduringtheevolutionarydevelopment of mobile apps.
an evaluation of gcat illustrates that our approach is effective outperforming developers and reports useful information in a comprehensible manner.
our future work entails a more precise classification for gui changes as well as continuing to improve the quality of the nl summarizations.
additionally we aim to enable gcat to effectively analyze and classify dynamic screen content.