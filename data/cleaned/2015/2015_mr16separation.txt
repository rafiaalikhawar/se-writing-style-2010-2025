on well separation of gr specifications shahar maoz school of computer science tel aviv university israeljan oliver ringert school of computer science tel aviv university israel abstract speci cations for reactive synthesis an automated procedure to obtain a correct by construction reactive system consist of assumptions and guarantees.
one way a controller may satisfy the speci cation is by preventing the environment from satisfying the assumptions without satisfying the guarantees.
although valid this solution is usually undesired and speci cations that allow it are called non well separated.
in this work we investigate non well separation in the context of gr an expressive fragment of ltl that enables e cient synthesis.
we distinguish di erent cases of nonwell separation and compute strategies showing how the environment can be forced to violate its assumptions.
moreover we show how to nd a core a minimal set of assumptions that lead to non well separation and further extend our work to support past time ltl and patterns.
we implemented our work and evaluated it on speci cations.
the evaluation shows that non well separation is a common problem in speci cations and that our tools can be e ciently applied to identify it and its causes.
ccs concepts software and its engineering !formal methods keywords reactive synthesis gr well separation assumptions .
introduction reactive synthesis is an automated procedure to obtain a correct by construction reactive system from its temporal logic speci cation .
rather than manually constructing an implementation and using model checking to verify it against a speci cation synthesis o ers an approach where a correct implementation of the system is automatically obtained for a given speci cation if such an implementation exists.
in the case of reactive synthesis an implementationis typically given as a controller i.e.
an automaton that accepts input from the environment e.g.
from sensors and produces the system s output e.g.
commands for actuators to always satisfy the speci cation.
one challenge for applying reactive synthesis to software engineering practice relates to the process of writing the speci cation which typically consists of assumptions and guarantees.
assumptions play an important role as they describe the possible environments a system has to operate in.
one way a controller may satisfy the speci cation is by preventing the environment from satisfying the assumptions without satisfying the guarantees.
although valid this vacuous solution to the reactive synthesis problem is usually undesired.
following klein and pnueli we call speci cations that allow this solution non well separated .
in this work we investigate non well separated speci cations in the context of gr a fragment of ltl which has an e cient polynomial time symbolic synthesis algorithm and whose expressive power covers most of the well known ltl speci cation patterns of dwyer et al.
.
we distinguish di erent cases of non well separation and compute strategies showing how the environment can be forced to violate its assumptions.
moreover we show how to nd a core a minimal set of assumptions that lead to non well separation and further extend our work to support past time ltl and patterns.
speci cally rst we present an algorithm for the diagnosis of non well separated environment speci cations see sect.
.
.
the algorithm checks for well separation and distinguishes several cases it identi es whether the environment can be forced to violate its assumptions from all initial or only from some reachable states and whether the safety or the liveness assumptions can be forced to be violated.
the distinction between the di erent cases is important for the following strategy synthesis in case our algorithm identi es non well separation we synthesize strategies that demonstrate how the environment can be forced to violate its assumptions see sect.
.
.
second we de ne and show how to compute a non wellseparated core a minimal subset of assumptions that already makes the environment speci cation non well separated see sect.
.
as shown in our evaluation see below the core is indeed typically much smaller than the original set of assumptions facilitating better focus on the reasons for nonwell separation.
finally we show in sect.
.
how the above can correctly handle extensions of the speci cation language with pasttime ltl and ltl speci cation patterns .
we presentcontroller boolean atstation boolean cargo motorcmd mot liftcmd lift enum motorcmd fwd stop turn bwd enum liftcmd lift drop nil figure a forklift and its controller controller further extensions in sect.
.
together our analyses serve as powerful debugging tools for speci cations which can assist in nding and understanding the reasons for non well separation in reactive synthesis speci cations.
we have implemented the above in our gr synthesis framework on top of jtlv .
we present evaluation of the diagnosis algorithm and the non well separated core computation on speci cations created by students who took a six month project class on reactive synthesis.
the evaluation shows that non well separation appears in many speci cations that our diagnosis algorithm is e cient and that non well separated cores e ectively reduce the set of assumptions one has to consider when trying to understand the reasons of non well separation.
we describe the evaluation in sect.
.
some previous works suggested criteria for environment speci cations susceptible to being forced to violate assumptions .
our work is partly inspired by these works.
these works however did not consider algorithms and automated means for debugging the problematic environment speci cations computing cores etc.
and did not evaluate the problem on a corpus of speci cations.
unrealizability is another common problem of reactive systems speci cations which can be handled using counter strategies and a notion of core.
however non well separation is very different than unrealizability.
it requires the construction of strategies not only from all initial states but also from some reachable states.
moreover its core as we de ne it is made of assumptions not guarantees.
we discuss related work in sect.
.
.
example we start o with a running example adapted from our speci cation of a lego forklift shown in fig.
see .
the forklift has two sensors one sensor to determine whether it is at a station and one sensor to detect cargo.
it also has two motors to drive the forklift and to lift the fork.
values read by the sensors are provided as inputs to component controller and its outputs are commands that control the motors.
all inputs and outputs are typed e.g.
the outputmothas type motorcmd .
the datatypes are boolean or de ned as enumerations in fig.
.
a team of engineers is writing a speci cation of the forklift controller to automatically synthesize an implementation.
the main task of the forklift is to traverse an open area and always eventually deliver cargo it nds cargo at 1note that this is a real lego robot that we have built.
we use our synthesis tool and code generation to run it.specification 1asm findstat always possible to find a station g f atstation 3asm samepos same station position when stopped g mot stop next atstation atstation 5asm liftcargo lifting clears sensor g lift lift next !
cargo 7asm dropcargo dropping senses cargo g lift drop next cargo 9asm clearcargo backing up clears cargo g mot bwd next !
cargo listing excerpt of an environment speci cation for the forklift controller stations lifts it and drops it at other stations.
a benet of synthesizing a controller is that it is guaranteed to satisfy its speci cation.
however without any environment assumptions a forklift controller cannot be synthesized.
as an example the forklift can not ensure that it will nd a station to deliver cargo to because the sensors are completely controlled by the environment.
to guarantee the completion of its task the forklift has to assume that it will always nd stations.
this is expressed in the assumption g f atstation named findstat in listing ll.
.
the temporal operator gintuitively stands for always i.e.
at every state and fstands for eventually i.e.
within nitely many steps.
additional assumptions in listing describe reactions of the environment to actions of the forklift controller.
the assumption samepos speci es that the value of the station sensor remains the same if the forklift stops g mot stop next atstation atstation in other words stations do not move .
the temporal operator next v interprets vin the next time step here the next value of atstation must be equal to its current value.
the next three assumptions follow the same pattern and restrict the expected environment behavior for handling cargo.
when the forklift lifts cargo the cargo sensor is cleared assumption liftcargo l. .
when it drops cargo the cargo is detected by the sensor assumption liftcargo l. .
finally the forklift can clear the cargo by moving backward from it assumption clearcargo l. .
the engineers complete the speci cation consisting of assumptions and guarantees and successfully synthesize a controller that satis es all guarantees if all assumptions hold.
however once the controller is deployed to the forklift the team observes strange behavior.
sometimes the forklift drops cargo and behaves chaotic.
an engineer nds out that this happens when the forklift drives backwards while dropping cargo.
our new well separation analysis informs her that the environment can be forced to violate safety assumptions from all initial states diagnosed case p all e safe see sect.
.
speci cally one of the assumptions dropcargo or clearcargo can be forced to be violated.
she xes the problematic assumptions by changing the assumption dropcargo from g lift drop next cargo tog lift drop mot!
bwd next cargo .
after some more runs of the forklift the team observes that the forklift sometimes stops between stations and does not continue delivering cargo.
it clearly does not continue to satisfy its guarantees i.e.
some assumption must be violated.
again our new well separation analysis informs the team that the environment can be forced to violate a justice assumption from some reachable states diagnosed case p reach e just see sect.
.
the reason involves the as sumption to always eventually nd a station findstat and the safety assumption samepos which states that the station sensor reading does not change when motors are stopped as described above .
when the forklift is not at a station it stops and thus forces the environment to violate its liveness assumption findstat .
this example shows how non well separation can lead to unexpected behavior of a synthesized controller and how a small set of relevant assumption can be used to explain the reason for non well separation.
.
preliminaries .
ltl and gr we repeat some of the standard de nitions of linear temporal logic ltl e.g.
as found in a modal temporal logic with modalities referring to time.
ltl allows engineers to express properties of executions of reactive systems.
the syntax of ltl formulas is typically de ned over a set of atomic propositions apwith the future temporal operators x next and u until and the past time temporal operators y previous and s since .
definition .the syntax of ltl formulas over ap is pj j jx j u jy j s forp2ap.
for 2apa computation u u0u1 !is a sequence whereuiis the set of atomic propositions that hold at the i th position.
for position iwe useu ij to denote that holds at position i inductively de ned as u ij pi p2ui u ij i u i6j u ij 1 2i u ij 1oru ij u ij x i u i 1j u ij 1u 2i 9k i u kj 2and 8j i j k u jj u ij y i u i 1j u ij 1s 2i 9k k i u kj 2and 8j k j i u jj we denote u 0j byuj .
additional ltl operators are de ned as abbreviations of the above f true u nally g f globally 1w 1u g weak until h true s historically ltl formulas can be used as speci cations of reactive systems where atomic propositions are interpreted as environment input and system output variables.
an assignment to all variables is called a state.
a strategy for an ltl speci cation prescribes the outputs of a system that from its winning states for all environment choices lead to computations that satisfy .
a speci cation is called realizable if a strategy exists such that for all initial environment choices the initial states are winning states.
this strategy can be represented as an automaton called a controller.
the goal of ltl synthesis is given an ltl speci cation to nd a controller that realizes it if such a controller exists.
gr synthesis handles an assume guarantee fragment of ltl where speci cations contain assertions over initial states safety constraints relating the current and nextstate and justice constraints requiring that an assertion holds in nitely many times during a computation.
a gr synthesis problem consists of the following elements x input variables controlled by the environment youtput variables controlled by the system eassertion overxcharacterizing initial environment states sassertion overx y characterizing initial system states e x y x transition relation of the environment s x y x y transition relation of the system je i21 njustice requirements of the environment js j21 mjustice requirements of the system we also write environment and system speci cations as tuplesh ji.
gr synthesis has two di erent notions of realizability which are expressed in the following ltl speci cations .
the rst and more intuitive notion is called implication realizability because all environment assumptions imply all system guarantees !
e g e i21 ngfje i !
s g s j21 mgfjs j the second kind of realizability is called strict realizability sr e!
s e!g h e !
s e g e!
i21 ngfje i!
j21 mgfjs j realizability of srimplies realizability of !.
specications for gr synthesis have to be expressible in the above structure and thus do not cover the complete ltl.
efcient symbolic algorithms for gr realizability checking and controller synthesis for srhave been presented in .
the algorithm of piterman et al.
computes winning states for the system i.e.
states from which the system can ensure satisfaction of sr. .
well separation klein and pnueli de ned well separation as a su cient property of environment speci cations h e e jeisuch that realizability of sris equivalent to realizability of !.
a well separated environment can satisfy all assumptions from every reachable state.
we repeat the de nition of klein and pnueli adapted to our syntax in def.
.
definition well separation .
a gr environment speci cation h e e jei is well separated i sr has no reachable system winning states for system speci cationhtrue true ffalsegi.
note that well separation is de ned as a property of the environment part of the gr speci cation i.e.
the assumptions without the guarantees.
intuitively the system speci cation htrue true ffalsegimeans that initially and for every step the system choices are unconstrained s true s but its justice requirements cannot be satis edjs ffalseg.
winning strategies for srthus have to force the environment to violate its assumptions.
klein and pnueli showed how to reduce implication realizability to strict realizability.
for the system speci cation in def.
strict realizability srand implication realizability !both reduce to the ltl formula e g e v i21 ngfje i .
the set of states where the environment can be forced to violate its assumptions can thus be computed by the standard gr algorithm.
.
debugging non well separation we start by arguing why well separation is desired and why it is necessary to provide tools for debugging non wellseparated environment speci cations.
we then follow with an analysis of di erent cases of non well separation.
these cases distinguish winning positions and environment speci cation parts that can be forced to violate.
the cases on the one hand present an informative summary of well separation of the speci cation and on the other require di erent means to further explain reasons for non well separation.
we explain in sect.
.
how strategies to demonstrate the di erent cases of non well separation can be computed.
well separation is a property of the environment speci cation i.e.
the assumptions in gr synthesis.
in most cases the environment is speci ed by the same engineer specifying the guarantees of the system2.
non well separation is a problem in the speci cations due to two main reasons.
first controllers that force an environment to violate assumptions are undesired in general because they do not have to satisfy their guarantees.
second we assume that the true environment e.g.
in the physical world of the synthesis problem is well separated i.e.
cannot be forced to violate its assumptions.
thus it should not be possible to force an environment to a deadlock or prevent it from satisfying its justice assumptions.
a non well separated environment thus points to a gap or a mismatch between the real environment and the assumptions describing it i.e.
it points to a problem in the speci cation.
due to its assume guarantee nature the gr synthesis algorithm might exploit non well separation and synthesize controllers that fail in a real environment.
note that according to def.
an environment can also be non well separated without a malicious system i.e.
no matter what the system does the environment has to violate its assumptions.
we consider this again to be an undesirable speci cation.
we now present approaches to debug non well separated environments by further distinguishing di erent cases of nonwell separation and presenting methods that assist engineers in understanding the reasons for non well separation.
.
cases of non well separation we distinguish di erent cases of non well separation based on two di erent criteria winning positions and environment speci cation parts.
.
.
winning positions all or reachable well separation in def.
is de ned based on winning states for the system speci cation htrue true ffalsegi i.e.
the only way for the system to win is to ensure assumption violations by the environment.
non well separation is weaker than realizability of srin def.
.
realizability of srimplies non well separation.
if the environment speci cation is realizable but not non well separated there exists a state that can be reached by environment choice from which the environment can be forced to violate its assumptions.
to distinguish these two cases we de ne the positions from which a controller can force the violation of assumption p all force violation from all initial environment choices p reach force violation from some reachable state.
2exceptions that we do not consider here are for example speci cations derived from existing components.the rst case p all means that a controller can always force the environment to violate its assumptions i.e.
it does not have to satisfy any guarantee.
an example of this case are the two assumption dropcargo andclearcargo shown in listing a controller can always force a violation of either one.
the second case p reach means that during execution of a controller the environment can reach a state from which the controller can force it to violate its assumptions i.e.
until the state is reached if ever all guarantees have to be satis ed.
an example for this case is the combination of assumptions samepos and findstat from a state with station false .
it is easy to see that p all implies preach but not the other way around.
.
.
env.
parts initial safety or justice to express which part of the environment speci cation can be forced to be violated we distinguish the following cases e ini all initial environment choices are invalid e false e safe force violation of safety assumptions e deadlock e just force violation of some justice assumption je i2je.
both cases of e ini ande safe imply the case of e just i.e.
all non well separated environment speci cations are of case e just .
an example for e safe are the two assumptions dropcargo andclearcargo while the two assumptions samepos and findstat are only an example for case e just .
.
.
summarizing case combinations when checking all environment parts and the positions from which each can be violated we obtain possible combinations of cases e ini may appear with p all or be absent while the other parts may appear with p all preach or be absent .
a combinations of cases might contain redundancies because one case implies another one e.g.
case p all e safe implies p all e just and we can summarize their combination as case p all e safe .
more formally we summarize case combinations by de ning the total orders p all pp reach ande ini ee safe e e just and their product order on pairs i.e.
the partial order p1 e1 p e p2 e2 p1 pp2 e1 ee2.
finally we represent a combination of cases by their smallest elements.
this summarization of case combinations leaves combinations shown in fig.
.
the only time two cases are reported is for cases p reach e safe and p all e just because these cases are not comparable in the product order.
the representation in fig.
is ordered from the weakest case combination at the top i.e.
well separation to the strongest case combination of non well separation f p all e ini gat the bottom.
.
.
an algorithm to identify the cases algorithm presents our algorithm to identify non wellseparation and the cases along the dimensions of winning positions and environment speci cation parts.
its input is an environment speci cation h e e jeiand its output is a set of cases of non well separation.
a case of non wellseparation is reported as a tuple of winning positions pallorp reach and responsible parts of the speci cation eini e safe ore just .
the algorithm reports summarized strongest case combinations as discussed in sect.
.
.
and shown in fig.
.
note that the algorithm returns an empty set i the environment speci cation is well separated.
p all e ini p all e safe p reach e safe p all e just p reach e just p all e just p reach e safe strongest case of non well separation weakest case i.e.
well separation figure cases of non well separation from weakest case i.e.
well separation to strongest case p all eini the cases p reach e safe and p all e just are incomparable algorithm diagnosing non well separation cases if e false then returnf p all e ini g end if de neresas set reach reachstates e e wins syswinsts h e e i htrue true ffalsegi ifwins reach6 then if syswinallini wins e then returnf p all e safe g end if add p reach e safe tores end if win syswinsts h e e jei htrue true ffalsegi ifwin reach6 then if syswinallini win e then add p all e just tores else ifres then add p reach e just tores end if end if returnres the algorithm starts by rst checking case e ini of nonwell separation by testing the satis ability of e. for e false the system wins from all positions.
it then checks case e safe by computing the environment reachable states in line and the system winning states according to def.
but forje in line .
for an empty set of justice assumptions a system can only win by violating safety assumptions.
the method syswinsts returns all system winning states i.e.
the z x point in the gr algorithm of .
if any of the winning states is reachable the environment is nonwell separated l. .
in case all initial states are winning for the system l. the strongest result is p all e safe .
otherwise the algorithm also checks the complete environment speci cation including jefor possible system winning states.
this second e just part in lines is analogous to the rst part of case e safe but the case p reach ejust is only added if resis empty i.e.
does not contain the stronger case p reach e safe possibly added in line .
the time complexity of algorithm for n jjejand state space sizenis ino nn2 because it uses the gr algorithm of to compute syswinsts and its other opera tions syswinallini and reachstates are ino n .
note that a simple algorithm to check well separation according to def.
without our diagnosis computes the sets reach l. andwin l. and checks for an empty intersection l. .
the time complexity of this algorithm is also ino nn2 .
applied to the example in listing algorithm reports f p all e safe g. after replacing assumption dropcargo with its modi ed version as suggested in the end of sect.
the algorithm reports f p reach e just g. .
strategies forcing assumption violation in addition to identifying and distinguishing the di erent cases of non well separation as a means to further explain the reasons for non well separation to the engineer we compute and present concrete strategies that demonstrate how a system can ensure assumption violations.
di erent non well separation cases require di erent strategy computations.
what is common is that all strategies are constructed from the game memory stored during realizability checking as implemented in the gr algorithm and described in .
.
.
winning positions all or reachable in case the system can force an assumption violation from all initial states case p all controller construction is the same as for regular gr synthesis.
a controller constructed for the system speci cation htrue true ffalsegishows how to force assumption violations.
the case p reach and not p all is more complicated.
if p all does not hold a controller does not exist because for some initial environment choices the environment cannot be forced to violate assumptions.
however from every state that is winning for the system here those that can force assumption violations a winning strategy exists and can be computed from the game memory.
the only di erence during strategy computation is the treatment of initial states.
in controller construction for case p all the initial states are computed one for every initial environment choice.
strategy construction from reachable states in case p reach starts with all reachable states i.e.
possibly multiple assignments to system variables for each assignment to environment variables.
understanding reasons for non well separation for the case p reach might require understanding how the states of the strategy can be reached from initial states.
how these states are reached might already exhibit environment behavior that should be restricted by additional assumptions to make the environment well separated.
to show how a state can be reached we can simply compute a trace starting with an initial state and ending with a state in the strategy.
.
.
env.
parts initial safety or justice in addition to the distinction between cases p all and p reach we distinguish the environment parts that can be forced to be violated.
non well separation of case e ini means that the initial assumptions of the environment are contradicting.
in this case the system has nothing to do to force assumption violations so there is no need to discuss it further.
to obtain a controller for case e safe that shows safety violations only we have to use the modi ed environment speci cationh e e i. otherwise the controller might chose to!atstation !cargo mot stop lift lift !atstation cargo mot stop lift nil !atstation cargo mot stop lift lift !atstation cargo mot stop lift drop atstation cargo mot bwd lift drop a b controller for all initial environment choices strategy from reachable states figure a a controller forcing violation of assumptions clearcargo ordropcargo for all initial environment choices case p all e safe and b a strategy forcing violation of assumption findstat from reachable states case p reach e just for the speci cation in listing violate a justice assumption in jeinstead.
strategies for case e safe with environment speci cation h e e iinclude only nite computations.
to obtain a strategy for case e just we simply use the game memory computed for the check of def.
.
strategies for case e just might include in nite computations.
.
.
examples the environment of the example of sect.
shown in listing is non well separated of case p all e safe .
a controller that forces assumption violations is shown in fig.
a .
the initial choices of the environment are not constrained i.e.
the environment can choose all four possible assignments to the variables atstation and cargo .
the controller has a single initial state labeled with assignments to environment and system variables.
the symbol denotes all possible values of a variable i.e.
the symbolic state in fig.
a denotes four concrete states.
the controller assigns mot bwd forcing !cargo in the next state and lift drop forcing cargo in the next state i.e.
a contradiction and thus an assumption violation of clearcargo ordropcargo from listing .
in the second part of the example of sect.
the assumption dropcargo from listing was changed to g lift drop mot!
bwd next cargo to resolve the rst non wellseparation case p all e safe .
the modi ed environment is non well separated of case p reach e just .
a strategy that forces it to violate assumptions from reachable states is shown in fig.
b .
the strategy is only de ned for states where the forklift is not at a station and stops.
the strategy forces the environment to violate the justice assumption findstat by stopping forever and thus forcing the environment to always keep atstation set to false .
.
cores of non well separation every environment speci cation h e e jeiconsists of a set of assumptions similar to the ones shown in listing .
the speci cation elements e e andjemight result from many assumptions e.g.
for the speci cation in listing eis the conjunction of assumptions samepos liftcargo dropcargo and clearcargo .
to further assist in debugging non well separated environments we compute a minimal subset of the assumptions that demonstrates a reason for non well separation.
we call these minimal subsets nonwell separated cores.
.
the importance of monotonicity the notion of a core has appeared in works that address unrealizability see e.g.
.
these works rely on the monotonicity of unrealizability with regard to adding guarantees to make the core de nition meaningful and to allow its e cient computation.
a de nition of core with regard to non well separation is however challenging because non well separation by itself is not monotonic with regard to adding assumptions.
without monotonicity the reason for non well separation exhibited by a subset of assumptions is not necessarily a reason for non well separation of the original speci cation.
theorem non well separation not monotonic .
non well separation is not monotonic wrt.
adding or removing assumptions.
proof.
we show counter examples for both cases.
non well separation is not preserved when removing assumptions the non well separated environment speci cation consisting of justice assumption findstat and safety assumption samepos from listing becomes well separated when removing assumption samepos .
non well separation is not preserved when adding assumptions the non well separated environment speci cation consisting of assumptions findstat samepos becomes well separated when adding the assumption g atstation .
def.
of well separation includes both the reachable states and states winning for the system.
this provides di erent possible resolutions of non well separation in an environment speci cation.
intuitively these are weakening assumptions to remove system winning states and strengthening assumptions to remove reachable states.
both cases are demonstrated in the proof of theorem .
it is important to note that these cases are not exclusive.
the dependence on reachable states and winning states makes the property of non well separation not monotonic.
.
non well separated core to address the non monotonicity challenge we provide a stronger de nition of core which relates to the reachable states of the original complete speci cation and ensures that the reason for non well separation exhibited by a core is a reason for non well separation of the original speci cation.
thus we de ne a non well separated core to be a minimal subset of a speci cation s assumptions which can be forced to be violated from the reachable states of the original speci cation.
given a set of assumptions asmwe denote the environment speci cation resulting from it by e asm e asm andje asmin def.
.
definition non well separated core .
a nonwell separated core for a set of assumptions asmis a minimal setc asmsuch that syswinsts h e c e c je ci htrue true ffalsegi reachstates e asm e asm intuitively we look for a minimal set of assumptions c that is non well separated within the reachable states for the original set of assumptions asm.
on the one hand this restriction is natural when debugging non well separation of asmbecause it relates only to states relevant to the originalspeci cation.
on the other hand the restriction makes the check monotonic with respect to adding assumptions i.e.
for all c c asmifccan be forced to violate its assumption in reachstates e asm e asm then the same applies to c and asm .
this makes cores as de ned in def.
meaningful because the reason for non well separation in the core cis a reason for non well separation in asm.
we show this monotonicity in theorem .
theorem core monotonic .
the check for a nonwell separated core cin def.
is monotonic with respect to adding assumptions from asm.
proof.
a strategy to force violation of c asminreachstates e asm e asm is also a strategy to force violation of c with c c asminreachstates e asm e asm .
adding assumptions can only make the environment speci cation stronger i.e.
e c e c e c e c andje c je c .
all cwinning states in reachstates e asm e asm are also c winning states because their successor states in care deadlocks or exist in c i.e.
if a strategy can force a deadlock in cit can force a deadlock in c because e c e c. otherwise there exists at least one j2je c je c that can be prevented by a strategy to violate assumptions c. a winning strategy for c also prevents jinc because e c e cand thus states in c have the same ore less successor states not satisfying j. the proof of theorem also shows how to construct a strategy to force violation of h e asm e asm je asmifrom the result of checking the gr realizability of c. .
implementation and example we implemented the computation of non well separated cores in our synthesis framework based on jtlv using the delta debugging algorithm of zeller to check subsets of assumptions and compute minimal cores according to def.
.
after core computation our tools can construct a strategy as described in sect.
.
to demonstrate non wellseparation and present a minimal set of assumptions to the engineer.
for the example of sect.
shown in listing our core calculation algorithm computes the core fliftcargo clearcargog.
after the modi cation of assumption dropcargo as described in sect.
the core calculation algorithm computes the corefsamepos findstatg.
.
extensions .
support for patterns and past time ltl the ltl fragment of gr is limited to initial constraints safety constraints over the current and next state and justice constraints over states to visit in nitely often.
this is a very restricted subset of ltl.
however gr synthesis is quite expressive because deterministic b uchi automata can be used as assumptions and guarantees .
this additional expressiveness is achieved by adding auxiliary variables to the gr synthesis problem.
in practice this allows gr speci cations to include most ltl speci cation patterns of dwyer et al.
as shown in and pasttime ltl as shown in .
3actually both checks returned the second core which is also a core for the rst variant.
to obtain the core fliftcargo clearcargogwe had to restrict the analysis to safety parts of the speci cation as in algorithm l. .technically the support of ltl speci cation patterns and past time ltl works by encoding deterministic b uchi automata or observer automata as additional safety constraints a awith auxiliary variables aencoding the statespace of the automata.
the acceptance of b uchi automata is encoded as justice assumptions in jeor justice guarantees in js.
finally a system speci cation for synthesis with patterns and past time ltl is updated to h s a s a jsiover the new system variables y a .
as an example consider the following assumption using the response pattern to express that the forklift can nd a station by going forward asm res g !atstation f atstation mot!
fwd this response formula is not in the gr fragment.
it can however be used in gr synthesis by adding a new boolean variable auxtoa adding aux true to a adding next aux atstation mot!
fwd aux atstation to a and adding aux true toje.
similar translations exist for past time ltl .
the translations have in common that the auxiliary speci cation parts aand aand the new variablesaare added on the system side of the speci cation for the gr algorithm.
the de nition of well separation in def.
uses the system speci cationhtrue true ffalsegiand thus does not support patterns and past time ltl.
when naively applying def.
to speci cations that use patterns or past time ltl in assumptions an analysis automatically yields potentially false negatives.
for the example of assumption resthe systemhtrue true ffalsegifully controls the new variable auxand can thus always prevent the environment justice aux true2je.
we x this inconsistency between the support for patterns and past time ltl for gr synthesis and the de nition of well separation by replacing the system speci cationhtrue true ffalsegiin def.
withh a asm a asm ffalsegi where a asmand a asmare the auxiliary initial and safety constraints from the translation of patterns and past time ltl that appear as part of assumptions in asm.
the reachable states to consider for well separation are accordingly reachstates e a asm e a asm .
we update algorithm with the restriction of reachable states in line and the system speci cationh a asm a asm ffalsegiin line and line .
in the updated de nition of well separation the assumption resalone will not be identi ed as a reason for non wellseparation.
the environment can always force aux true by either keeping atstation true or setting atstation true after atstation false .
.
preventing forced assumption violations via safety guarantees a non well separated environment is undesirable because it might allow synthesis of controllers that force assumption violations instead of satisfying their guarantees.
we have presented ways to diagnose and debug non well separated environments.
in this subsection we consider a di erent approach considering the guarantees of a speci cation to prevent the system from forcing assumption violations.
from a methodological point of view xing a non wellseparated environment speci cation should be preferred to enable reuse and support evolution of the environment speci cation.
from a pragmatic point of view it might be enough that a system guarantees to not force the environment toviolate assumptions.
recall that the satisfaction of safety guarantees until assumptions are violated is part of strict realizability semantics srbut not implication semantics !.
as an example consider a non well separated environment speci cation consisting of the assumptions dropcargo andclearcargo from listing .
a strategy to force assumption violation is dropping cargo to require next cargo and driving backwards to require next !cargo .
the following new guarantee dropstop expresses that the system has to stop when dropping cargo gar dropstop g lift drop mot stop a system satisfying dropstop cannot force a violation of an environment speci cation consisting the two assumptions dropcargo and clearcargo .
more formally we de ne a weaker version of well separation over the complete speci cation i.e.
all assumptions and guarantees.
definition well separation wrt.
guarantees .
a gr speci cation with environment h e e jeiand systemh s s jsi is well separated i syswinsts h e e jei h s s ffalsegi reachstates e s e s note that well separation implies well separation with respect to guarantees but not the other way around.
also note that a trivial case of well separation wrt.
guarantees is unrealizability of the safety part of the system i.e.
when the environment can force the system to a deadlock before the system can force an assumption violation.
.
annotating synthesized controllers finally we present a complementary approach for helping to understand non well separation by annotating a synthesized controller with traceability information see of the assumptions it tries to violate.
note that we now talk about controllers synthesized for realizing a gr speci cation including system guarantees and not the ones of sect.
.
synthesized to show non well separation.
given a controller realizing a speci cation we annotate every state in the controller with a reason why it was added to the controller.
the annotations link states to guarantees the controller tries to satisfy or assumptions it tries to prevent from being satis ed.
an excerpt of a controller for the forklift is shown in fig.
.
the system speci cation for this example has two justice guarantees to always eventually pick up cargo formally gf lift lift and to always eventually deliver cargo formally gf lift drop .
the upper left state in fig.
satis es the justice guarantee gf lift lift and its successor to the right works towards satisfying the next justice guarantee gf lift drop .
note that the state on the bottom right is annotated as trying to prevent the justice assumption gf atstation .
this annotation helps to identify undesired behavior caused by non well separation and links it to a responsible assumption.
we have implemented this approach in our synthesis environment as an extension of for assumption traceability.
.
ev aluation we have implemented algorithm the non well separated core computation of sect.
and the three extensions discussed in sect.
in our synthesis framework using jtlv .
atstation cargo mot stop lift lift atstation !cargo mot fwd lift nil !atstation !cargo mot stop lift nil atstation !cargo mot fwd lift nil working towards system justice gf lift lift working towards system justice gf lift drop satisfying system justice gf lift lift trying to prevent environment justice gf atstation figure an excerpt of a synthesized controller annotated with reasons why states were added during controller construction to evaluate the mechanism we suggest for debugging nonwell separation we consider the following research questions r1does non well separation appear in speci cations?
r2can diagnosis be run e ciently during development?
r3does core computation e ectively reduce the number of assumptions to inspect?
.
material and execution only few gr speci cations are available and these were usually created by authors of synthesis algorithms or extensions thereof.
the most popular gr speci cations are amba and genbuf published and used in many works .
we consider these speci cations not well suited for our evaluation due to their origin and purpose.
to collect more realistic speci cations we have conducted a project class on reactive synthesis for undergraduate students at tel aviv university.
the task of the students was to write gr speci cations for robotic systems similar to the case study described in with automation for synthesis and code generation to lego nxt robots.
students worked in six teams of two or three students each for the full duration of a semester.
they developed speci cations using an extended version of the aspectltl tools and stored these in a version control system.
the time between the rst committed speci cation and the last committed speci cation was six month.
the typical development cycle of the students was updating their speci cation synthesizing a controller and deploying generated code directly on their robot for validation.
the di erent robots were a color sorter an elevator a humanoid a self balancing and remotely controlled robot and two self parking cars.
the students had tools for synthesis and code generation but not for detecting or debugging non well separation except for the possibility to synthesize controllers annotated with the controller s objective as described in sect.
.
.
we have collected a total of speci cations for six robots with to revisions per robot.4seven committed speci cations were syntactically invalid.
the valid speci cations have on average assumptions per speci cation from a single case of up to a maximum of assumptions.
the state space input output and auxiliary variables ranges from 24to median third quartile .
4the speci cations are available from ac.il syntech separation .non ws g unreal 5ws wrt.
g ws figure an overview of the evaluated speci cations are well separated are non wellseparated of which are well separated wrt.
guarantees of which have unrealizable safety guarantees .
r1 occurrence of non well separation we have analyzed all syntactically valid speci cations for well separation with algorithm extended to support patterns and past time ltl as described in sect.
.
.
as a result only out of environment speci cations were found to be well separated.
the algorithm detected non well separation for environment speci cations.
algorithm diagnosed the following cases of non wellseparation times case p all e safe times casef preach e safe p all e just g times casef p reach e safe p reach e just g times case p all e just and times case p reach e just .
these cases do not only appear in intermediate versions but also in the nal submissions of the students.
the tool used by the students implements the more robust strict realizability semantics sr. we have thus also checked whether including the guarantees in the well separation check described as an extension in sect.
.
prevents the system from exploiting non well separation.
indeed out of non well separated environment speci cations are wellseparated wrt.
guarantees i.e.
the safety guarantees ensure that the environment cannot be forced to violate assumptions.
a further check revealed that in out of these cases the well separation wrt.
guarantees is trivially satised because the safety guarantees are unrealizable.
we have summarized the numbers in an overview in fig.
.
the leftmost box represents the desired well separated speci cations while the right boxes represent non well separated speci cations.
with strict realizability semantics speci cations in the dotted middle box prevent forced assumption violations trivially by unrealizable safety guarantees .
to answer research question r1 non well separation frequently occurs in environment speci cations out of speci cations and in many speci cations violation of an assumption can be forced from all initial positions p all out of speci cations .
.
r2 efficiency of diagnosis it is important that the diagnosis of non well separation is fast and can be executed frequently by the engineer.
we have thus measured running times of algorithm for a diagnosis of cases of non well separation for the speci cations in our evaluation.
again the algorithm supports past time ltl and patterns as described in sect.
.
.
we have run the experiments for measuring diagnosis times on an ordinary laptop computer with an i7 .
ghz cpu running windows 64bit java .
32bit and cudd .
.
32bit with automatic variable reordering.
neither our java implementation nor cudd made use of more than one coreof the cpu.
the times we report are wall clock times measured by the java api.
we repeated each experiment times and report running times in milliseconds for all runs on syntactically valid speci cations.
due to the small size of some speci cations many runs of algorithm were reported to complete after 0ms.
the minimum time and the rst quartile of all runs are both 0ms.
the median of measured running times is 15ms the third quartile is 78ms and the maximum time to run algorithm on the speci cations was 250ms.
as a reference time for each speci cation we have also measured synthesis times i.e.
time of the realizability check and construction of a symbolic controller5.
we report on the factors that nonwell separation diagnosis is faster than symbolic controller synthesis we removed out of cases where the time of algorithm was measured as 0ms .
the rst quartile is at factor i.e.
non well separation diagnosis is times faster than checking realizability and constructing the controller the median at factor and the third quartile is at factor .
only for ve very small speci cations synthesis was faster than diagnosis and both times measured were below 16ms.
to answer research question r2 diagnosing non wellseparation using algorithm is conveniently e cient indeed it is in of the cases more than times faster than the synthesis step which is executed frequently during speci cation development.
.
r3 reduction by core computation we are interested whether the computation of a non wellseparated core e ectively reduces the number of assumptions to consider for understanding a reason for non wellseparation of the environment speci cation.
we have run our core computation algorithm based on delta debugging and def.
as described in sect.
on all non well separated speci cations.
the results of the computation were minimal sets of assumptions consisting of a single assumption for speci cations and of two assumption for speci cations.
the reduction factor rst quartile is the median is and the third quartile is .
.
a non well separated core of a single assumption is very surprising.
we expected a set of assumptions that together presents a non well separation problem.
we have thus inspected some of the speci cations with a singleton core and found out that indeed the assumptions in the core refer to system variables the environment cannot control.
we have rerun the experiments with all system guarantees according to sect.
.
to ensure that the analysis did not miss implicit patterns implemented by the students.
except for the speci cations where the guarantees prevent forced assumption violation the cores remained at sizes of one or two assumptions.
to answer research question r3 core computation e ectively reduces the number of assumptions to consider by a factor larger than in and larger than in of the speci cations .
5for most of the speci cations concrete controller construction was not feasible and students executed symbolic controllers on their robots.
.
discussion and threats to validity it is important to note the limitations of our ndings and threats to their validity.
we have based our evaluation on speci cations created by students with no prior experience in ltl and speci cation writing.
from diagnosing speci cations we found out that of the speci cations are non well separated and most nonwell separated cores consisted of a single assumption.
these rather simple cases of non well separation may be due to students unawareness of the problem of non well separation which was not part of the teaching during the project.
moreover non well separation did not always lead to a visible problem because our gr implementation uses the more robust strict realizability semantics srand favors progress over assumption violation during strategy extraction and because validation by execution on the robot typically did not exercise many scenarios.
nevertheless many times students consulted with us about observed undesired behavior in controllers resulting from non well separation which indicates that the problem was indeed there implicitly.
the analysis of multiple revisions of the same speci cation from the version control system used by the students bares the risk of analyzing intermediate speci cations that are more likely to contain problems.
our observations of development behaviors and the low number of committed revisions however indicate that most versions were considered stable by the students before committing them.
nevertheless our debugging techniques are intended to support developers during all stages of development including intermediate versions.
finally students might have implemented assumption patterns in the speci cation that were not identi ed by our analysis.
the analysis is limited to patterns described in sect.
.
.
to mitigate this threat we have overapproximated the pattern implementations by considering all guarantees as described in sect.
.
.
we still found that out of nonwell separated speci cations remain non well separated.
.
related work we give a brief overview of works on the relation between environment speci cations and controllers debugging mechanisms for unrealizable speci cations and vacuity.
assumptions bloem et al.
provide an overview and discussion how assumptions are treated in reactive synthesis.
they argue that most approaches e.g.
gr synthesis insu ciently handle assumption violations.
they suggest and later de ne cooperative synthesis levels where the highest level ensures that assumptions and guarantees are always satis ed.
ehlers et al.
present cooperative gr synthesis for one of the levels that ensures that from every state the environment can satisfy its guarantees.
cooperative synthesis may fail when regular gr synthesis does not.
our work on well separation can help in the context of cooperative synthesis because every controller for a well separated speci cation is cooperative.
well separation for gr environments has been introduced by klein and pnueli .
they de ned this property to show when the gr semantics of strict realizability and implication realizability agree.
we have argued for the importance of well separation in general and extended klein and pnueli s work with more ne grained analysis of cases strategies a core implementation and evaluation.d ippolito et al.
present gr synthesis for eventbased controllers and de ne anomalous controllers that satisfy their speci cation by forcing assumption violations.
the notion of assumption compatibility in the event based case is a dual of well separation.
we believe that the techniques we introduced can be transferred to debug environments in the event based case.
debugging unrealizability one may view our work as using and extending ideas that were recently introduced to deal with unrealizability counter strategies cores in order to create new means to deal with the challenge of wellseparation.
counter strategy synthesis for gr and interactive execution were presented e.g.
by cimatti et al.
k onighofer et al.
maoz and sa ar for aspectltl and for scenarios and raman and kress gazit in a robotics domain.
non well separation is very di erent than unrealizability.
compared to our work on non wellseparation counter strategies for unrealizability focus on the system part and deal only with the case p all .
alur et al.
suggest a heuristics for xing unrealizability by adding assumptions obtained from enumerated candidates checked against a counter strategy.
the case of wellseparation is di erent because it is not monotonic and deals with assumptions only.
a dual approach might be possible for the extension with guarantees de ned in sect.
.
.
vacuity finally the problem of vacuity as de ned by beer et al.
and studied in many works e.g.
in the context of model checking can be viewed as related to wellseparation and synthesis.
fisman et al.
have extended vacuity to speci cations where satisfaction is replaced by realizability and witnesses are subformulas.
all these works are however very di erent than our work in their approach and motivation.
first a vacuous controller could be synthesized for a non well separated speci cation of case p all6 and second non well separation of case p reach cannot be detected by checking a controller for vacuous satisfaction.
.
conclusion in this work we investigated non well separation where an environment can be forced to violate the assumptions in the context of gr an expressive fragment of ltl.
we distinguished di erent cases of non well separation and computed strategies showing how the environment can be forced to violate its assumptions.
we further showed how to nd a core a minimal set of assumptions that lead to nonwell separation and extended our work to support past time ltl and patterns.
we implemented our work and evaluated it on speci cations.
the evaluation shows that non well separation is a common problem in speci cations and that our tools can be e ciently applied to identify it and its causes.
our work is the rst to investigate and implement means to identify and address non well separation.
it is also the rst to evaluate non well separation on a corpus of speci cations.
the work is part of a larger project on bridging the gap between the theory and algorithms of reactive synthesis on the one hand and software engineering practice on the other.
as part of this project we are building engineer friendly tools for writing and understanding temporal speci cations for reactive synthesis.
6non well separation is necessary but not su cient for a controller that is vacuous in the system guarantees.
.