codematch obfuscationwon t concealyour repackagedapp leonid glanz sven amann michael eichberg michael reif ben hermann johanneslerch and mira mezini technischeuniversit tdarmstadt germany glanz amann eichberg reif hermann mezini cs.tu darmstadt.de lerch st.informatik.tu darmstadt.de abstract an established way to steal the income of app developers or to trick users into installing malware is the creation of repackaged apps.theseare clonesof typically successfulapps.toconceal their nature they are often obfuscated by their creators.
but given that it is a common best practice to obfuscate apps a trivial identification of repackaged apps is not possible.
the problem is further intensified by the prevalent usage of libraries.
in many apps the size of the overall code base is basically determined by the used libraries.
therefore two apps where the obfuscated code bases are very similar donot have to be repackagesofeachother.
to reliably detect repackaged apps we propose a two step approach which first focuses on the identification and removal of the library code in obfuscated apps.
this approach libdetect relies on code representations which abstract over several parts oftheunderlyingbytecodetoberesilientagainstcertainobfuscation techniques.
using this approach we are able to identify on average more used libraries per app than previous approaches.
after the removal of an app s library code we then fuzzy hash the mostabstractrepresentationoftheremainingappcodetoensure that we can identify repackaged apps even if very advanced obfuscation techniques are used.
this makes it possible to identify repackagedapps.usingourapproach wefoundthat ofall apps inandroid app stores are repackages.
ccs concepts security and privacy software reverse engineering software and its engineering software libraries and repositories applied computing systemforensics keywords library detection repackagedetection obfuscation code analysis acmreference format leonid glanz sven amann michael eichberg michael reif ben hermann johannes lerch and mira mezini.
.
codematch obfuscation won t concealyourrepackagedapp.in proceedingsofesec fse paderborn germany september 11pages.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse september paderborn germany associationfor computing machinery.
acm isbn ... .
introduction popularapps inthegoogleplaystore areinstalledonmillionsof devices.thisattractsmaliciousactorstocreatealtered repackaged versionsofthoseappstostealtheoriginalowner srevenue orto trickusersandinfecttheirmobiledeviceswithmalware.detecting suchrepackagedappsisthereforenecessaryforasecureandviable app market.
several techniques for repackage detection have already been proposed andcan be broadlyclassified as being code agnostic graph based user interface based and code signature based .
thecode agnostic approaches hashinternal filesofanapp withoutconsidering the filecontentortype asaresult thehashescouldbeevadedbysingle bit changes.
graph based techniques derive the control flow datafloworcallgraphoftheanalyzedappandmeasurethesimilarity by comparing isomorphic sub graphs of the derived properties.
given that graph matching is a hard problem these approaches potentially suffer from scalability issues .
those approaches whichtrytoabstractfromtheconcretegraphstoachievescalability e.g.
byusingmetrics sufferfromhighfalsepositiverates .userinterface based techniques also construct a graph but use views as nodesandthetransitionsfromoneviewtoanotherasedges.these graphs can easily be fooled by changing or introducing pseudoviews.code signature based approaches create signatures based on an apps code to address the weaknesses of the graph based approaches the proposedapproach alsobelongs to this category.
challenges.
achallengeforallexistingrepackagedetectiontechniquesare codetransformations.
developers regularly minify and optimize their apps to increase performance.
additionally they obfuscatetheirappstoprotecttheirintellectualproperty.however attackersalsoapplyobfuscationtohidemaliciouscodeandtoevade signature baseddetectors such as anti virussoftware.
currentrepackagedetectiontechniquescanonlyhandlebasic forms of obfuscation such as one by one identifier renaming replacingtypes andreorderingoffieldsandmethods .more sophisticated obfuscation techniques such as moving classes betweenpackagesorchangingandroidapicallsarenotsupported.
our evaluation of google play store apps revealed that are at least partially obfuscated and that at least use more advancedtechniques.theeffectivenessofrepackagedetectionis furtherinhibitedthroughtheprevalentreuseoflibrariesinapps.
wangetal.
reportedthatmorethan60 ofthesub packagesin android apps belong to library code.
hence separating the library code from the app code is necessary.
otherwise apps which use nearly thesamelibrariesautomaticallysharealargeportionofthe overall code base and are always identified as repackages even if 638esec fse september04 paderborn germanyleonidglanz sven amann michaeleichberg michaelreif ben hermann johannes lerch andmiramezini theapps codeiscompletelydifferent.abasicapproachtofilterout non obfuscated librarycode isto use package white lists .
anotherchallengeforrepackagedetectiontoolsareappsgeneratedbyappmakers e.g.
apps builder .inthatcase thevast majorityofthecodebase thegenerator slibraries willbethe sameandtherestwillstillbeverysimilar.currentapproaches will generallyflag such apps as repackages.
proposed approach.
to address the identified challenges we propose a method for repackage detection that consists of a library detection technique libdetect and an app matcher codematch whereby the latter uses the former.
libdetect usesfivehierarchicallyorganizedrepresentations.the firstoneistheoriginalbytecode.theotherrepresentationseach abstractoversomeadditionalaspects suchastheusedidentifiers or the control flow.
hence each higher level is less precise but potentially enablesa higher recall.
asa result of theprecision recall trade offourlibrarydetectioninternallyusesthefiverepresentationsstep by step.ifalibrarymethodisonlymarginallyobfuscated our approach will identify the method using a less abstract representationwhencomparedtomethodsthataremoreeffectively obfuscated.
after identifying the library methods we regroup them tomatchthepotentialoriginallibraryclasses.thisenablesusto identify methods and classes which were moved across class package boundaries.
to evaluate the robustness of our representations we extracted roughly sample library apks from maven central obfuscatedthemwithastate of the artobfuscator dexguard and tried to reidentify the original library methods.
fortheevaluationof libdetect werandomlyselected1 000apps andidentifiedthe libraries manually to establishagold standard.
ourappmatcher codematch usesfuzzyhashing ofanapp s codetowithstandvarioussophisticatedobfuscationtechniquesand optimizations including class relocating slicing duplication of androidapisintheapp codechangesandcodeoptimizationsthat affectthedetection.additionally itorderstheapp spackagesbased onthesizeoftheirclasses.thisaddressesthechallengesfacedby droidmoss dueto reorderingsofclassesandpackages.
to test if an app is repackaged codematch performs the following steps first it filters apps which were generated using app makers these2.
ofallappscanreliablybefilteredusingawhitelistofthemain packageprefixes theyarerequiredbyandroid s signing process and cannot be obfuscated.
second it filters the library code of apps using libdetect .
third it filters apps which haveless than 300linesofcode such appscannotbeclassified reliablybyourapproach.fourth itgeneratesforeachappthemost abstract obfuscation resilient representation and fuzzy hashes it.
fifth itcomparesthefuzzyhashesandifthesimilarityexceedsa predefinedthreshold the apps are markedas repackaged.
we prepared the evaluation of codematch by fuzzy hashing the descriptions of downloaded apps and randomly selecting apppairs whosefuzzy hasheddescriptionsareatleast90 similar we considered very similar descriptions as a first indicator for repackaging.afterwards we installedandexecutedeachapp pair toreconfirmtheirsimilaritymanually.weusedtheseresultsasthe groundtruth toevaluatethefindingsof codematch viewdroid droidmoss fsquadra andanrepackagedetectionthat uses the centroid concept from physics .additionally weevaluatedtheeffectsof codematch independent oflibdetect .
to evaluate the effect that library detection has on repackagedetection weexecutedtwooftherepackagedetection tools droidmoss and centroid based additionally with libdetectandlibradar aspre filtersandcomparedtheresultswiththe other tools.
to evaluate the effect of codematch in isolation we additionally run itwith alibrary white list and with libradar.
we show that codematch enables us to identify in all library detection configurations up to more obfuscated and repackaged apps than the other approaches.
in summary we make the following contributions five abstract code representationsthat enable library and repackagedetectionwithdifferentprecision recalltradeoffs libdetect a technique to detect library code on a class basisthatoutperformsthecurrentmostadvancedlibrary detection tool libradar by70 .
codematch atechniquethatdetectsapprepackaging which useslibdetect tofilteroutlibrariesbeforemeasuringthe similarityofthe apps.
thefirstquantitativecomparativeevaluationofavailable repackage detection approaches codematch viewdroid droidmoss fsquadra andacentroid based approach theremainderofthispaperisstructuredasfollows.section2 presentstheattackermodel.section3givesanoverviewofobfuscation techniques.
section describes the state of the art.
section presents the proposed approach.
section discusses theresultsof our evaluation.
section examines threats to validity.
section concludes the paper.
attacker model we identified three kinds of attackers who create repackaged apps attackersfromthefirstcategoryonlyapplybasicchanges obfuscations of an app that do not require a deep understanding and configuration of obfuscators.
their primary goal is to avoid that the repackaged app is identified by hash based approaches.
the second category is able to make full usage of existing advanced obfuscators to effectively hide their apps even if state of the art repackage detection approaches are used.
the third category of attackersare expertswhoare ableto apply customobfuscations.
currentrepackagedetectiontoolsareabletoidentifyrepackaged apps created by attackers from the first category.
the proposed approach codematch isadditionallyabletoidentifyrepackaged apps ofattackersfrom category two.
code obfuscation webrieflyintroduceknownobfuscationtechniques whichwere seen in the wild or are performed by known obfuscators .
optimization techniques are also included because they introduce variance similar to obfuscation and cause similar issues.
throughout the paper we will refer to both techniques as obfuscationtechniques name mangling.
in general meaningful identifiers such as field method class andpackagenames are replacedbymeaningless small strings e.g.
person aa .
package identifiers can even be reduced to the empty string this justputs all classes in 639codematch obfuscation won t concealyourrepackagedapp esec fse september04 paderborn germany thedefaultpackage.shorteningnamesalsoimprovestheoverall performance dueto the smallercode size .
modifier changes.
field method and class modifiers can be changed most of the time without affecting the semantics of a program.
the modifications range from basic changes e.g.
raising the visibilityof classes orclass members e.g.
package private public or adding removing the finalmodifier to more complexones.e.g.
transforminganinstancemethodintoastaticone requires an extraparameterto make the thisreference explicit.
structuralchangestoamethod simplementation.
avery basictechniqueistoadd nops i.e.
instructionswhichhavenoeffect on the method s semantics but modify the structure of the code.
the primary effects are a larger method body and shifted jump targets of jump instructions such as if switchorgoto.
more involvedchanges suchaschangingthekindofan if instruction if if generallyaffectthemethod scontrol flowgraph.
code slicing.
most applications do not use all features of the libraries they include.
therefore it is possible to remove unused library code bycreating aslice ofessentialfunctionality.
code restructuring.
common obfuscaters move classes and methods between packages classes and methods.
such changes affectallcallsitesrelatedto the changedclass structure.
methodparametersmanipulation.
reorderingorremoving adding unused method parameters affects both the signature and bodyofthemethod.thisgenerallyrequiresacorrespondingupdate ofallcallsites.
constant computation.
constant values are replaced by expressions that compute the constant e.g.
the constant 100is replacedbythecomputation .amoreadvancedtechniqueis the encryption ofstrings whichare then decryptedondemand.
faketypes.
alreadyexistingclasses inparticularfromlibraries such asthe androidsdk are duplicatedand used withinthe program instead of the original class e.g.
java.util.hashset com.myset .
in more advanced cases a field s primitive type is changed e.g.
from inttolong.
code optimization.
classic code optimizations also influence thecode sstructurewhenevermethodsareinlined valuespropagated unusedvariables are removed orcontrol flowismodified.
hidefunctionality.
sophisticated obfuscators hide functionalitybyencryption recompilation compression andvirtualization of selected classes see sharif et al.
.
these techniques are currentlythemosteffectiveprotectionmechanisms butgenerallyslow downtheapp sexecutiontime needadvancedknowledgeofthe app sinternalstructure orrequiremanualcodechangesandare therefore rarelyusedinpractice.
stateofthe art this section presents the state of the art in the area of library and repackagedetection for android applications.
.
librarydetection different repackage detection approaches use common librarywhitelists todetectandfilteroutlibrarycode.whitelists contain package names of known libraries and are compared with packagenamescontainedinandroidapps.currentlythelargest white list is collected by li li et al.
it contains over 000different names of library packages.
the problem with using white listsisthatchangingjustonecharacterofalibrary spackagename can completely evade the library detection.
libd usesthesub super packagerelation inclusion andthe inheritance relation between classes across packages inheritance to construct one reference graph per library.
these graphs can thenbecomparedwithgraphsextractedfromanapp.agraphis constructedbyusing sub packagenamesasnodesandinheritance orinclusionrelationsasdirectededges.whilethisapproachreduces the information needed for comparing libraries to the package level itisvulnerabletochangesthatsplitormergepackages.ifthe package hierarchy is changed thegraph has a different number of edges per node andcannotbe comparedwiththis approach.
libradar is an approach for detecting library code in android apps.
given an app s code it extracts for each package a feature vector consisting of the observed android api calls.
these vectors are then hashed to get a fingerprint per package.
these fingerprintscanthenbecomparedagainstfingerprintsofknown library packages.
libradar is therefore resilient against the renamingofpackages butcannothandleobfuscationsthatmergeorsplit packages that affectthe vector of api calls.
the goal of libscout is to identify the version of an android api that is used inobfuscated code.
itgenerates merkle tree hash profiles in three steps.
first it replaces all types of a method signaturethatdonotbelongtotheandroidapiwithan x andthen hashes the transformed signature.
second the method signature hashesaresortedandhashedattheclasslevel classhashes .third class hashes are again sorted and hashed per package package hashes .finally allhashesareusedtoidentifylibrarycode.ifthe package hash does not match the class and the method hashes areused.ifnohashmatchesthecodeelementisdeclaredasnonlibrarycode.thehashesaregeneratedfordifferentlibraryversions to make it possible to identify a specific version.
since the computationofthetreehashinherentlyreflectstheimplicittreestructure between packages classes and methods libscout is not robust against cross class package code restructurings .
to recap the discussion above indicates the need for better library detection that is able to handle library instances with a changed package hierarchy.
additionally beyond white lists libradaris the only approach that can directly be used as a pre step to repackage detection.
both white lists and libradar have their specificlimitationsmentionedabove.moreover neithertheynor the other approaches exploit information about the method bodies.
these limitationslead to poor recall as our empirical comparison of these techniques against our new approach will reveal in sec.
.
.
repackagedetection droidmoss usesanapp sbytecodeinstructionnames mnemonics without arguments to compute a fingerprint by fuzzy hashing the entire mnemonic sequence in the given order.
a white list is used for library filtering.
droidmoss is vulnerable to code restructuringsbecause the fingerprintdepends onthe code order.
viewdroid detectsrepackagedcodebybuildingviewgraphs.
itextractsall activityclassesasviewnodesandallactionsasedges e.g.
button pushes or intent execution.
the tool performs a subgraphsimilaritymeasurementtocompareviewgraphs whichis 640esec fse september04 paderborn germanyleonidglanz sven amann michaeleichberg michaelreif ben hermann johannes lerch andmiramezini timeconsuming.
viewdroid isvulnerabletoinsertionoflibraries with own views because it does not filter libraries.
furthermore it canonlycompareappswithmorethanthreeviews.inarandom sample of1 apps .
hadless than 3views.
cuixia et al.
developed a tool that represents code in the samewayas viewdroid butusesfixedsizevectorsofapicallcounts per ui widget instead of whole views.
the tool achieves a more robust representation but has the same drawbacks as viewdroid .
fsquadra computes for allfilesreferencedinthe manifest.mf of an apk the hash values and compares them with theextractedhashesofapotentiallyrepackagedapp.
fsquadra has nolibrarydetectionandtheinsertionoflibrarycodewouldchange theentirehashvalueofthecodefile.however eventheadditionof some useless resources e.g.
sound files or images would change the computedhashesandreduce the similaritywithotherapps.
wukong detectsrepackagedappsinthreesteps first ituses libradar to filter out library code.
second it filters equivalent appsbycomparingtwodifferentfingerprints.whereasthefirstis generatedthesamewayas libradar sfingerprints thesecondis basedonthefrequencyofapicallsperpackage.third itgenerates featurematriceswhichcontainoccurrencefrequenciesofallvariablesindifferentcontexts tocomparethemforrepackagedetection.
aslibradar is used in the first two steps the approach also suffers from the same drawbacks.
libraries that remain undetected during step one potentially cause a high false positive negative rate in the detectionresults.whenoneofthefingerprintsisfalselymatched instep two the repackageanalysisisnot executed.
dnadroid filters out libraries by using package names and classhashes.afterthat dnadroid extractsthedata dependency graph ddg ofeachappmethodandidentifiesrepackagedapps bycomparingtheapp sddgswiththeddgsofotherapps.the library filtering step of dnadroid s is vulnerable to renamings affectingpackagenamesorclasshashes.determiningsub graph isomorphismisgenerallycomputationallyexpensive which makesdnadroid unsuitableforrepackagedetectioninhugeapp stores such as google play store .
andarwin detectsrepackagedapps infoursteps first comparableto dnadroid itcomputestheddgforeachmethod.second itcomputesforeachddgthefrequenciesofeachunderlyinginstruction e.g.
assignmentsoradditions .third tofilteroutlibrary code it prunes vectors that occur more often among different apps thanapredefinedthreshold.finally andarwin hasheseachremaining vectorandcomparesthesehasheswith hashesofpotentially repackagedapps .theapproachfailstofilteroutlibrariesthat are not usedfrequentlyenough according to the threshold.
theapproachbykaichenetal.
constructsacontrolflow graph per method and represents it as a centroid.
the algorithm filters out popular libraries with a white list and matches the centroids of the remaining methods pairwise.
the advantage of this approach is that similar centroids can be found efficiently due to the sorting capability of the centroids.
however it also has two drawbacks.first thedetectiondependsonthesortingorder e.g.
if wefilterfirstbytheinstructioncount wepossiblymissmethods thatareverysimilarbytheinvocationcount.second whenlibrary codeisnotfilteredproperly see4.
itisconsideredasappcode whichrenderscomparedapps artificiallymore similar.torecap eachrepackagedetectionapproachhasitsownspecific drawbacks all share problemsdue to limitationsof the library detection in use.
to address these problems we designed codematch whichweevaluateagainst droidmoss viewdroid fsquadra and thecentroid baseapproachinsection6.for fsquadra andviewdroid thesoftwarewaseitheravailableonlineorwasmadeavailable to use upon request.
the code for droidmoss and for the centroid based approach was not available but we were able to re implementthembasedontheinformationavailableintheirpublications .
the remaining approaches could not be acquired from their authors and we were not able to re implement them basedontheirpublications.
the approach our approach consistsof two parts first an approach libdetect for the identification and removal of library code from a given android app apk .
second an approach that takes the app s code after library removal to find repackages.
both parts rely on abstract representations of the app s code to handle obfuscation.
in section5.
wefirstpresentthedifferentcoderepresentationsbefore we discuss libdetect in section .
and codematch in section .
.
.
the abstractrepresentations todealwithobfuscationofmethodsandclasses seesection3 we usefivedifferentabstractrepresentationsofmethods.therepresentationsbuildupononeanother eachabstractingoversomeadditionalelementsoftheoriginalbytecodecomparedtoitspredecessor.
table1showswhichrepresentationaddresseswhichobfuscation techniquesandtable2showsanexamplemethod compare int int inthe firstfourrepresentations.
weusethe bytecode bc ofamethodasis toreliablyidentify non obfuscatedlibrary methods.
intheaddresslessrepresentation ar weremove nopsand program counters and abstract over jump targets.
in the latter case we replace forward jumps by along and backward jumps by back .takentogether thisaddressesrespective structuralchanges to a method s implementation .
furthermore we remove allmethod modifiersto address modifierchanges .
inthenamelessrepresentation nr weaddress namemanglingandfake types .
for that we remove method names from the method signatures and invocation instructions and replace nonandroid api type