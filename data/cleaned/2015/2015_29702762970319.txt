towards bounded model checking using nonlinear programming solver masataka nishi center for technology innovation r d group hitachi ltd japan.
masataka.nishi.en hitachi.com abstract due to their complexity currently available bounded model checking techniques based on boolean satis ability and satis ability modulo theories inadequately handle non linear oating point and integer arithmetic.
using a numerical approach we reduce a bounded model checking problem to a constraint satisfaction problem.
currently available techniques attempt to solve the constraint problem but can guarantee neither global convergence nor correctness.
using the ipopt and antigone non linear programming nlp solvers we transform the original constraint satisfaction problem from one having disjunctions of constraints into one having conjunctions of constraints with a few introduced auxiliary variables.
the transformation lowers the computing cost and preserves the boolean structure of the original problem while complying with limits of nlp solvers.
ccs concepts software and its engineering !software veri cation and validation formal software veri cation keywords bounded model checking nonlinear programming sat .
introduction we need to develop a toolchain for formally verifying control software that operates a complex autonomous system .
a particular issue is that supporting a safety claim and functional integrity of the systems requires correctness of many assumptions about their operating environment but often these assumptions are violated.
the violation can put the systems in a situation where conditions for supporting the safety and integrity claim get unsatis able.
as we can hardly predict preemptively which subset of an initial assumption may be violated we can hardly x the impaired claims at pre market stage .
unpredictable nature of the acm isbn .
.
1235violation poses a certi cation challenge for the control software involved .
regulatory authorities and casualty insurance rms are concerned about when the situation could occur under what condition the autonomous systems could go wrong and how to discover the violation from a recorded log and to replay the situation.
the authorities and insurance rms need to develop an e ective procedure for exhaustively exploring the situation.
software developers need to propose a scheme of repairing the once impaired claim in a justi able way.
the procedure would assist in obtaining a certi cation before deployment and for accident investigation after deployment in the eld.
yet it is a complex inverse problem.
bounded model checker bmc for software serves as an automated tool for modeling formulating formalizing and solving the inverse problem.
but real world autonomous systems run with complex control algorithms on a large architecture beyond that currently available bmc can handle.
one of existing toolchains is cbmc .
cbmc o ers a generic way of describing a model that consists of assumptions on an input and an initial state a procedure of producing an output and a veri cation condition vc on a relation between the input and the output.
cbmc consists of a front end procedure for translating an original problem expression into the static single assignment ssa form for building a formula of predicates produced using a dedicated encoding technique.
cbmc also consists of a back end procedure of solving a satis ability sat problem of the formula.
we can verify dynamic behavior of a reactive system by putting a state transition logic in a loop construct.
linear temporal logic ltl is a primitive language for expressing the vc.
it can be built in a model program with two threads using a dedicated formulation of an assertion construct.
by the design of bmc we can explore a nite number of transition steps.
we selectively build the formula by bit vector encoding or satis ability modulo theories smt encoding of the ssa form.
cbmc implements the rst one to build the formula and solve it using boolean sat solver minisat2.
if the formula is reducible or if the original program is inadequately expressed using a bit vector encoding then smt encoding using smt solvers z3 and mathsat is more suitable.
if the formula consists of a mix of disjunctions and conjunctions of predicates the both solvers exploit an e cient decision procedure cdcl .
yet the existing sat smt solvers can hardly handle equations commonly used in numerical control software equations of non linear of oating point arithmetic and of standard mathematical functions.
it is due to hurdles regarding complexity of modeling bit vector arithmetic and unpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
decidability of a general sat problem over reals and integers.
practitioners sidestep the known hurdles by bounding search domain developing numerically approximate techniques and limiting on using speci c constructs only.
dreal is based on interval constraint propagation icp .
we found that it shares a well known weakness of simplex method revealed by rosenbrock.
it exhibits poor convergence if the equation is non convex and of multivariables.
the weakness originates from that a contracting feasible domain speci ed by intervals is an axis aligned convex polytope and it can hardly asymptotically t non convex feasible region.
calcs employs convex programming and the same issue arises.
other attempts are reducing the sat problem to a numerical optimization problem.
reports attempted to minimize a sum of constraint violations and explored a global minimum where a satis able solution resides.
yet a search strategy based on a derivative free method or gradient descent lacks a mechanism of guaranteed global convergence and thus fails.
the search for the global minimum stalls at a local minimum of the objective function and results in a false report that the sat problem is unsatis able or may not terminate.
as we usually take refutation of the vc and if the formula is unsatis able it can cause an unfavorable false negative decision.
we exploit a high level mathematical property of the original sat problem and solving it using selected constrained nonlinear programming nlp solvers antigone and ipopt .
we use them in a way that global convergence is guaranteed and we correctly decide satis ability.
we quickly compute a numerically approximate satis able solution with speci ed small error bounds.
existing numerical techniques and other nlp solvers lack the guarantee of global convergence and thus possibly incorrectly decide satis ability when the equations are non linear or non convex.
as the nlp solvers can receive a formula of conjunction of predicates only we propose techniques of transforming the formula having disjunction of predicates into one having conjunction of predicates while preserving the original boolean structure.
few attempted that way since the majority persistently regards the original one as a logic formula.
coincidentally we only have to solve fewer independent nlp instances and we can handle larger complex formula.
.
background .
generation of satisfiability problem we inherit an existing front end procedure of bounded model checking technique based on symbolic execution .
it includes preprocessing loop unwinding appending assertions and a procedure of translating the original program expression of an input to output relation into a partial order graph of components comprised of branching assignments assertions labels and goto instructions.
each component is translated into an intermediate representation ssa form and then into a predicate.
by rule a new variable is assigned to a return value at each step of computation.
thus an array of predicates is produced from an n step sequential program that consists of assignment functions feq k xk .
n k xk feq k xk xk fxk xkgis a program state produced up un til step k xk 1is a newly assigned return value of an assignment at step k x0 fxinit kj0 8k n initgis an initial program state that contains inputs to the program.
we introduce a decision function dl k fbr k xk du k 2b k n that splits execution path at a branching step in the program.
it is divided into a pair of an assignment xk fbr k xk and a comparison dl k xk du k. we combine with some constructs necessary to organize a bounded model checking problem.
an assumption function al fas k x0 au 2b 8k w limits a search space and speci es a constraint on x0.
it is divided into an assignment xas k fas k x0 and a comparison al k xas k au k. an assertion function cl fas n xn cu 2bencodes a veri cation condition and divided into an assignment xn far n xn and a comparison cl xn cu.
herefas eq br ar k can contain non linear arithmetic.
we trail a sequence of executions for each branching path and build a formula .
w 1v k xas k fas k x0 al k xas k au k n 1v k xk feq br k xk dl k xk du k xn far n xn cl xn cu we attempt to nd a satis able xnby numerically solving this system of equations .
to avoid producing a vacuous model checking problem we assume that the assertion and a conjunction of the assumption functions are satis able.
.
constrained nlp solver general algebraic modeling system gams is a highlevel modeling system for describing a constrained nlp problem with a common interface to a collection of solvers.
mixed integer nlp solver minlp is an extension of the nlp solver for handling non linear integer arithmetic.
a standard mi nlp solver attempts to compute a local global optimal solution of an objective function f x y subject to constraints gj x y and bounds on variables given as .
m j 1gl j gj x y gu j nr i 1xl i xi xu i ni i 1yl i yi yu i it consists of problem variables x2rnrandy2zni a twice di erentiable objective function f x y rnr zni!
r twice di erentiable constraint functions gj x y rnr zni!rwith a pair of bounds gl j gu j2rfor each j m bounds on the variables f xl i xu i j1 i nrg andf yl i yu i j1 i nigwherexl u i2r yl u i2z.
the bound constraints speci es the entire search space.
we use a particular nlp solver ipopt and a minlp solver antigone .
ipopt is an implementation of primaldual interior point method using logarithmic barrier function.
each mi nlp solver adopts a di erent mechanism of solving a mi nlp instance.
for clarity of explaining a mechanism of the nlp solver we remove integer part in this section.
for our purpose of solving satis ability problem we setf x y and assign one predicate in to each gj x y .
we need to transform a non linear inequality constraintgl j gj x gu jinto a pair of an equality constraint gj x sj and a bound constraint gl j sj gu j on an auxiliary variable sj.
a search for a global op561timum of constraint violationpjgj x jtoward a direction prxjgj x jdoes not guarantee global convergence and thus fails.
instead ipopt builds a barrier problem .
l x mx j jgj x nx i log v i log v i j2ris a lagrangian multiplier for each gj x that penalizes large constraint violation.
is called a barrier parameter that enforces the bound constraints v i where v i xi xl i v i xu i xi.
the constraint functions and bound constraints are embodied di erently.
we de ne a barrier kkt point fx z gusing a bound multiplier z i where the following kkt condition is satis ed.
n i 4z iv i mp j jrxigj x z i z i m j 1gj x ipopt computes a search iterate witr fxitr itr z itrg and a search direction 4witrtoward the kkt point by solving a matrix equation rr witr t4witr r witr where r witr fr xl x fgj x g fz iv i gg.
the last barrier term in and a primal dual mechanism modify the search direction.
a capability of driving witrfrom an arbitrary initial point xinitto the barrier kkt point is called global convergence .
ipopt drives !
and computes a converging series of the kkt points until is met.
max krxl x k1 sd kgj x k1 kz iv i k1 sc tol sc sdare scaling parameters assigned inside ipopt and become at a convergent point.
when is feasible the newton like iteration continues until the second term in and the third term in get below a su ciently small tol.
ipopt drives the search iterates to a satis able solution of .
we get a numerically approximate solution to the original sat problem .
the property of global convergence is preserved even when is infeasible and we get correct decision of satis ability of .
if unsatis able then ipopt terminates at a point where either at least one of terms in is violated.
we analyze the amount of constraint violations gj xunsat using a nal assignment of xunsat .
.
limitations and scalability each mi nlp solver has a di erent capability and limits often implicitly stated.
a common limit is that we need to organize a conjunction of twice di erentiable constraint functionsgj x .
a dedicated parser can decompose a complex formula feq kinto a composite of elementary arithmetic functions.
compilers such as llvm can decompose it into machine instructions which an appropriate nlp encoding is applicable.
in section we propose techniques of converting a formula of a disjunction of predicates into a formula of conjunctions that preserves the boolean structure.
other limits originate from the mechanism of mi nlp solver.
.
.
continuity of constraint functions a search strategy of major mi nlp solvers exploits that constraint functions are twice di erentiable within the do main of the bound constraints.
we should identify discontinuity in the formula symbolically as existing nlp solvers can hardly nd it numerically and correctly.
we refer to some techniques for reformulating an apparently discontinuous function into a continuous one.
ones for a discrete functionmin fvjg is shown in section .
.
a non smooth functionabs g x onx2ris reformulated as abs g x g x g x g x g x .
integers arithmetic produce a discontinuous function.
yet a suitable reformulation often exists.
modulo operator b x aon x a b2nis rewritten as a formula x a c b b a using an auxiliary variable c2nwith checking over ow caused bya c. k bit shift operator on an unsigned r bit integerx kisx 2k whilex kis 2k x 2r.
.
.
global convergence from infeasible point guarantee of global convergence is required to decide satis ability correctly.
as we do not know preemptively that the posed nlp instance is satis able or not the nlp solver may have to start from a potentially infeasible initial point and explore a potentially unsatis able nal point as iteration proceeds.
with the reformulation of non linear constraints mentioned in section .
ipopt and antigone are quali ed in this sense.
some nlp solvers implicitly require that the non linear constraint functions fgj x gis convex .
this signi cantly limits applicability.
thus we need to adopt a nlp solver that can handle non convex constraint functions.
the hurdle of non convexity is relaxed by assigning an auxiliary variable on a return value of each convex component in the original constraint functions and reformulating the original one as sum of linear bilinear or convex ones.
some advanced solvers overcome the hurdle by exploiting such a special structure of the original one .
.
.
path connectedness the mechanism of producing a converging series of search iterates from an initial search point to the nal satis able kkt point is homotopy continuation regarding .
we need to assume path connectedness of the domain of constraint functions in topological sense and warrant that there exists a continuous path between the points.
it requires the continuity of the constraint functions.
transforming a discontinuous constraint function into a composite of continuous ones recovers path connectedness and avoids fragmenting feasible regions.
nlp solver can drive them toward the nal one as the newton like iteration proceeds.
otherwise the nlp solver may not be able to reach the nal kkt point and incorrectly reports unsatis able.
a branch condition breaks this limit.
we need to organize one nlp instance for each branching path and the path explosion problem revives.
.
.
bounded execution time if the lagrangian lin is a function of oating points and self concordant the number of newton like iterations is bounded .
it is o pm log m wheremis the number of constraint functions.
it can be multiplied by log kgj x0 k1 tol .
at every iteration jacobian and hessian matrix of the constraint functions is organized and inverse of the matrix are computed using a subroutine in blas library.
as each constraint function gj x usually contains few of the problem variables in x the jacobian and the hessian matrix are sparse.
cost of inverting a sparse matrix scales linearly to the number of non zero elements that is roughly 562o m n .
the total amount of computational cost is in the order of o pm log m o m n .
we can add variables of integer type and call minlp solver antigone.
but there is no technique that rmly bounds the number of iterations for solving the minlp instance.
at least we need to use the minlp solver within a limited set of speci c non linear functions for the global convergence.
.
encoding sat into nlp .
solving bmc problem by nlp solver we propose reducing a bmc instance to a sat problem of the formula .
if is satis able we want an accurate satis able solution xnwhere xk f xk xkg x0 f xinit jj0 j n initg xas j fas j xj for j w and xj feq br ar j xj for j n. however ipopt produces a numerically approximate satis able solution xnthat contains accumulation of numerical error.
they are apart from xnby the amount of xj xj xj xinit j xinit j xinit jand xas j xas j xas j. ipopt reports xsuch thatkgj x k1 tol.
it implies that tol xj feq br ar j xj tolfor 8j n and tol xas j fas j x0 tolfor 8j ninit.
the third term in warrants that all components in xnare within their bounds.
if fas eq br ar j are not twice di erentiable then we need to transform them into a composite of twice di erentiable functions.
we suppose that all offgjgare twice di erentiable.
then there exists leq br ar j k such that fas eq br ar j xinit k las eq br ar j k for k n init.
there exists leq br ar j k such that feq br ar j xk leq br ar j k for k j and forj k n. thus errors are constrained as follows.
w 1v j xas j ninit 1p k las j k xinit k tol nv j bb k xj 1k ninit 1p k leq br ar j k xinit k jp k 1leq br ar j kk xkk1 cca tol3 as the inequality matrix with respect to a composite of error vectorsf xinit j j0 j n initg f xas j j0 j wg andfk xjkj1 j n 1gforms a lower triangular matrix having diagonal values eigenvalues of the matrix is .
thus the error bounds are at most xinit j r0for 8j n init xas j rwfor 8j w andk xjk rw jfor 8j n where rj pninit j tol.
an impact of the accumulation of numerical errors on evaluation offas br ar j are bounded as follows.
al k r0 xas j fas j x0 au k r0 dl k rw j xj fbr j xj du k rw j cl rw n xn far n xn cu rw n the errors extend only linearly with respect to square root of the number of program steps.
actual amount of the errors is revealed once we recompute fas eq br ar j using x0.
to avoid falsely reporting that x0is a satis able solution regardless of the errors we need to validate that the decision on satis ability of is irrelevant to the errors.
alternatively we cancheck if at least weakening of the original predicates are satis ed .
a practical treatment for warranting soundness is keeping equality constraints in untouched while tightening inequality constraints of the comparisons in by accommodating the amount of the errors rw n .
.
error tolerance .
.
data type range and precision mi nlp solver internally builds an instance using a standard set of data types that may di er from those of program states in .
data range used in the instance needs to be wider than that of the variables in the model.
we need to recompute the program using x0to validate that the correctness of decision is irrelevant to the potential incompatibility.
concerns of numerical inaccuracy in contrast to bit precise reasoning techniques that guarantee zero error tolerance is misleading in practice.
indeed if program states are integers and if return values from arithmetic operations on them are also integers then we can get an exact satis able solution vector by setting tol and enforcing zero error tolerance.
it is infrequent but we may be able to get analytically derived satis able solution vector.
yet data representation of the analytically precise solution vector can get large in practice or given with implicit functions.
after all we need a numerical solver and the same error tolerance tolto decipher the solution vector into decimal numbers.
.
.
machine arithmetic machine arithmetic is a potential source of incompatibility machine dependent data types rounding rules of integers and compliance with ieee standard of oating point operations.
an actual program may produce a program statexnthat greatly deviates from one based on real arithmetic that our nlp encoding presumes.
the limits of mi nlp solvers can be broken by constructs which are compliant with ansi c standard de cient type conversion that discontinuously changes the value or results in precision loss from unsigned to signed integer and from double precision to single precision oating point number.
we can remove them by using a static analyzer and enforce a conservative coding standard in return for ease of veri cation.
in practice for safeguarding against unnoticed error originating from them we need to compute each return value of fas eq br ar k in the same way that we execute the original program.
if we nd that the error is beyond rw kat stepk it implies either a bug of nlp encoding or a awed mi nlp solver that lacks the guarantee of global convergence.
.
conversion of cnf and dnf the nlp solvers can receive a formula comprised of a conjunction of predicates.
we need to develop reformulation techniques to remove disjunctions of predicates.
.
.
conversion of cnf into conjunctions conjunctive normal form cnf is a standard form of a formula which consists of conjunction of clauses and each clause is disjunction of predicates gi j x .
m i mi j 1gi j x !
as long as one persistently regards as a logic formula 563we need to solveqm i 1miindependent nlp instances for each combination of the predicates.
this adversely impacts on cost of computation and scalability of numerical techniques in general.
we propose some techniques of transforming a disjunction of predicates into a conjunction of predicates by appending some auxiliary variables while preserving the boolean structure of the original formula.
lemma .givenftj2rj1 j mg.mw j 1tj 0is satis able if and only if parameters fpj2rj1 j mg in the following formula is satis able.
m j pj mx j 1pj mx j 1pjtj w w proof.
asmin j mtj w max j mtjand w thus max j mtj.
by lemma each disjunction of predicates in is rewritten as a formula with auxiliary variables pi jandti j. miv j pi j gi j x ti j mip j 1pi j mip j 1pi jti j wi wi .
.
conversion of dnf into conjunctions disjunctive normal form dnf is a standard form of a formula which consists of a disjunction of clauses and each clause is conjunction of predicates gi j x .
m i mi j 1gi j x !
this dnf formula is transformed into conjunction of predicates with auxiliary variables fsig.
m i 1si m i si min j migi j x by lemma the rst term of is reformulated as .
m i pi mx i 1pi mx i 1pisi w w lemma .givenftj2rj1 j mig.s min j mitjis a satis able solution of the following formula.
mi j 1tj s mi j qj mix j 1qj mix j 1qjtj s proof.
asmin j mitj s max j mitjandmiv j 1tj s thuss min j mitj.
each predicate in the second term of is rewritten as .
mi j gi j x ti j ti j si qi j mix j 1qi j ti j si the proposed way of converting the dnf is not bene cial ifmis small and miare large.
because m pm i 1miauxiliary variables andpm i mi constraint functions are added.
instead we should build m independent nlp instances and solve them in parallel.
.
limitation on scalability common determinants of the cost for solving a sat problem using our nlp encoding are the number of program steps giving m the number of problem variables giving n m number of branching paths and non linearity of arithmetic operation.
we need to add some auxiliary variables and increase n if a vc has disjunction of predicates.
also the number of independent nlp instances that we need to solve increases as the number of branches increases.
we need a better nlp encoding of a branch or reinvent a cdcl procedure suitable for our nlp encoding.
.
non trivial way of encoding assertions a generic assertion construct can be built in a function far nin .
we focus on particular assertions that break the limits of nlp minlp solvers arithmetic over ow and invalid arithmetic operation known as runtime errors.
.
.
arithmetic overflow a constraint function that reproduces the e ect of arithmetic over ow is discontinuous and breaks the limits discussed in section .
.
we need to detect the over ow and remove such cases before organizing a nlp instance with a vc.
it is a problem of checking if any of return values xkfrom the arithmetic operation feq br ar k in exceed a bound xl k xu k of the data type of xk.
we employ a formula to detect the over ow when fas k x0 is satis able.
xl x0 xu eq n k 1xl k xk xu k the last term in is disjunction of predicates as we take negation of a formula composed of conjunction of predicates.
by applying lemma we get and then translated into that is conjunction of predicates.
as this adds fewer variables this reformulation is better than ones using .
s max max k n 1xk xu k max k n 1xl k xk n 1p k xk xu kxl k xk pu k pl k s n 1v k pl u k s .
.
invalid arithmetic operation floating point division is inevitable in computing an inverse matrix.
veri cation of oating point division has been regarded as a challenge as it needs to handle precision loss correctly.
as existing nlp solvers store numbers in bit ieee double precision values and compute using them the same e ect of precision loss is reproduced.
our nlp encoding has a di erent challenge when the constraint function contains the division y d x x y2rwhered x d0 x d1 x .
we suppose that the divisor d1 x and the dividendd0 x are twice di erentiable in the domain speci ed by bound constraints.
setting a constraint function 564y d0 x d1 x is not twice di erentiable at which d1 x it violates the limit of smoothness and thus path connectedness.
we may start from an initial search pointfx y 0gsuch that there exists no smooth path between the initial point and a satis able point fx y d x g if there exists a separating hyper surface d1 x .
we avoid it in two steps.
firstly we decide if an assertionabs d1 x is unsatis able with respect to a small bound for each divisor and check if the division retains arithmetic validity without returning a not a number value.
if the assertion is unsatis able we proceed to check if y s1 s0 s0 d0 x s1 d1 x is satis able.
it preserves the same satis able assignment fx y d x g and recover smoothness of constraints.
if y sqrt y and log y can get invalid.
instead we check if z2 y z andez y are satis able.
encoding unsigned integer divisionr p q p q r2ndi ers from oating point division.
we use a predicate p q r s s q p q r s q r 232and check if q is unsatis able.
.
discussion on complexity we argue that it is a misleading thought that deciding satis ability of a formula having predicates of non linear integer arithmetic and of non convex functions is greatly di cult due to combinatorial complexity.
indeed some minlp solvers su er from increasing number of branch and bound steps that re ect the inherent combinatorial complexity.
yet the program is forward computation.
there exists a satis able assignment once given x0 irrelevant to the length of program steps and arithmetic complexity of feq br k .
we are e ectively exploring the search space fxn x0grather than the entire space of xn.
the search space of x0is rstly constrained by fas kand that of xnis done by feq br ar k .
the predicate of the assertion function far nis the single one that may con ict with other predicates.
thus the complexity is manageable as far as we use the mi nlp solver to solve a sat problem generated accordingly.
meanwhile the decision functions at branching steps contribute to the combinatorial complexity since they discontinuously split the search space.
yet modern control software is automatically generated from an ide that encourages developers to describe a data ow diagram composed of function blocks rstly and implement a complex algorithm in a block afterward.
using unbounded loops in real time control software is prohibited.
thus the complexity in control ow and resulting path explosion problem is unlikely a practical issue.
.
conclusions we presented a new way of translating a bmc problem into a satis ability sat problem using a constrained nonlinear programming nlp solver.
we presented techniques for reformulating the original sat problem into a nlp problem in a way that the global convergence of the nlp solvers is preserved.
as we need to organize one mi nlp instance for each branching execution path the path explosion problem persists.
we explore a way of merging branch andbound steps in the mi nlp solver with the cdcl scheme.
.