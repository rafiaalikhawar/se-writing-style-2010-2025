detection and repair of architectural inconsistencies in java negar ghorbani joshua garcia and sam malek school of information and computer sciences university of california irvine usa negargh joshug4 malek uci.edu abstract java is one of the most widely used programming languages.
however the absence of explicit support for architectural constructs such as software components in theprogramming language itself has prevented software developersfrom achieving the many benefits that come with architecture based development.
to address this issue java has introducedthe java platform module system jpms resulting in thefirst instance of encapsulation of modules with rich softwarearchitectural interfaces added to a mainstream programminglanguage.
the primary goal of jpms is to construct andmaintain large applications efficiently as well as improve theencapsulation security and maintainability of java applicationsin general and the jdk itself.
a challenge however is thatmodule declarations do not necessarily reflect actual usage ofmodules in an application allowing developers to mistakenlyspecify inconsistent dependencies among the modules.
in thispaper we formally define inconsistent modular dependenciesthat may arise in java applications.
we also present d arcy an approach that leverages these definitions and static programanalyses to automatically detect the specified inconsistentdependencies within java applications and repair thoseidentified inconsistencies.
the results of our experiments con ducted over open source java applications indicate thatarchitectural inconsistencies are widespread and demonstrate thebenefits of d arcy in automated detection and repair of these inconsistencies.
i. i ntroduction a software system s architecture comprises the principal design decisions employed in the system s construction .
although every system has an architecture the architecture of many systems is not explicitly documented for instance in the form of uml models.
ensuring that the architecture as documented or intended known as the prescriptive architecture matches the architecture reflected in the system s implementation known as the descriptive architecture remains a major challenge .
architecture of a system is often conceptualized in terms of high level constructs such as software components connectors and their interfaces while programming languages provide low level constructs such as classes methods and variables making it a non trivial task to map one to the other.
inconsistencies between prescriptive and descriptive architectures are of utmost concern in any software project since architecture is the primary determinant of a software system s key properties.
one promising approach for abating the occurrence of architectural inconsistencies is to make it easier to bridge the gap between architectural abstractions and their implementation counterparts.
to that end the softwareengineering research community has previously advocatedforarchitecture based development whereby a programming language e.g.
archjava or a framework e.g.
c2 provides the implementation constructs for realizing the architectural abstractions.
in spite of this prior work in the academic community until recently java arguably the most popular programming languages over the past two decades lacked extensive support for architecture based development.
this all changed with the introduction of java platform module systems jpms in java .
modules are intended to make it easier for developers toconstruct large applications and improve the encapsulation security and maintainability of java applications in general as well as the jdk itself .
using java s module system the developer explicitly specifies the system s components i.e.
modules in java as well as the specific nature of their dependencies in a file called module info .
however java does not provide any mechanism to ensure the prescriptive architecture specified in themodule info file is in fact consistent with the descriptive architecture of the implemented software i.e.
whether the declared dependencies in the module info file are accurately reflecting the implemented dependencies among the system s components.
inconsistencies between the prescriptive anddescriptive architectures in java matter.
the java platformuses the module info file to determine the level of access granted to each module and to determine which modules should be packaged together for deployment.
as a result inconsistencies between prescriptive and descriptive architecture in java have severe security and performance consequences.
these inconsistencies also affect the engineers ability to use the prescriptive architecture for understanding the system s properties or to make maintenance decisions.
in this paper we formally define modular inconsistencies that may occur in java applications.
we present d arcy a n approach that leverages these definitions and static analyses to automatically detect the specified inconsistencies within java applications and repair them.
d arcy is also publicly available .
the results of our experiments conducted over opensource java applications indicate that architectural inconsistencies are widespread and demonstrate the benefits of d arcy in automated detection and repair of these inconsistencies.
darcy found instances of inconsistencies among java applications in our data set.
by automatically fixing these inconsistencies d arcy was able to measurably improve ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
various attributes of the subject applications architectures by reducing the attack surface of applications by .
improving their encapsulation by .
and producing deployable applications that consume .
less memory.
the remainder of this paper is organized as follows.
section ii introduces the module system of java and its design goals.
section iii formally specifies the architectural inconsistencies in the context of java .
section iv provides details of our approach and its implementation.
section v presents the experimental evaluation of the research.
section vi includes the threats to validity of our approach.
the paper concludes with an outline of related research and future work.
ii.
j ava pla tform module system to aid the reader with understanding architectural specification in java we introduce the new module system for java called java platform module system jpms .
we overview jpms s goals and the architectural risks that arise from its misuse.
we then discuss the details of modules in java including module declarations and module directives.
a. jpms goals and potential misuse jpms enables specification of a prescriptive architecture in terms of key architectural elements specifically components in the form of java modules architectural interfaces and resulting dependencies among components.
jpms aims to enable reliable configuration stronger encapsulation modularity of the java development kit jdk and java runtime environment jre to solve the problems faced by engineers when developing and deploying java applications .
software designers and developers can achieve strong encapsulation in their java systems by modularizing them and allowing explicit specification of interfaces and dependencies.
encapsulation in java is achieved by allowing architects or developers to specify which of a java module s public types are accessible or inaccessible to other modules .
a module must explicitly declare which of its public types are accessible to other modules.
a module cannot access public types in another module unless those modules explicitly make their public types accessible.
as a result jpms has added more refined accessibility control allowing architects and developers to decrease accessibility to packages reduce the points at which a java application may be susceptible to security attacks and design more elegant and logical architectures .
prior to java the java platform was a monolith consisting of a massive number of packages making it challenging to develop maintain and evolve.
software developers could not easily choose a subset of the jdk as a platform for their applications.
this results in software bloat and more potential points of attack for malicious agents.
with the introduction of jpms in java the java platform is now modularized into modules.
furthermore many internal apis are hidden from apps using the platform potentially reducing problems involving software bloat and security.
using jpms in java java developers can now create lightweight custom jres consisting of only modules they needfor their application or the devices they are targeting.
as a result the java platform can more easily scale down to small devices which is important for microservices or iot devices .
for example if a device does not support guis developers could use jpms to create a runtime environment that does not include the gui modules significantly reducing the runtime memory size .
although jpms allows for specification of prescriptive architectures the descriptive architecture of a java application may be inconsistent with the prescriptive architecture.
such inconsistencies may arise due to architects or developers misunderstanding of a software systems architectures e.g.
an architect mistakenly specifies a more accessible interface than he intended or simply due to mistaken implementations e.g.
a developer neglects to use a module s interface even though the architect intended such a use .
this can result in a poorly encapsulated architecture making an application harder to understand and maintain bloated software or insecure software.
in terms of security for instance one of the potential problems is the granting of unnecessary access to internal classes and packages potentially resulting in security vulnerabilities.
in terms of software bloat inconsistent dependencies can compromise scalability and performance of java software e.g.
requiring many unnecessary modules from the jdk .
b. understanding java jpms modules in jpms a module is a uniquely named reusable group of related packages as well as resources such as images and xml files .
each module has a descriptor file module info.java which contains meta data including the declaration of a named module.
a named module should specify its dependencies on other modules i.e.
the classes and interfaces that the module needs or expects and should specify which of its own packages classes and interfaces are exposed to other modules.
a module can be a normal module or an open module .a normal module allows access from other modules at compile time and run time to only explicitly exported packages an open module allows access from other modules at compile time to only explicitly exported packages and at run time to all its packages .
the module declaration file consists of a unique module name and a module body.
any module body can be empty or contain one or more module directives which specifies a module s exposure to other modules or the modules it needs access to.
figure shows an example of a project with three modules bar foo and service .
the declarations of each module provided in its module info.java file is described in figure 1a.
figure 1b is a diagram that depicts the relationship between the same modules based on dependencies in their declarations.
a module body can utilize combinations of the following five module directives which specify module interfaces and their usage the requires directive specifies the packages that a module needs access to the exports and opens directives authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
make packages of a module available to other modules the provides directive specifies the services a module provides and the uses directive specifies the services a package consumes.
these directives can be declared as described below 1module bar requires java.desktop requires service exports com.example.bar.lang exports com.example.bar.http tofoo provides com.example.service.srv with com.example.
bar.impl.implservice module foo requires service requires java.logging requires transitive bar exports com.example.foo.utils exports com.example.foo.internal tobar opens com.example.foo.network opens com.example.foo.exnet tobar uses com.example.service.srv module service exports com.example.service a module declarations and their directives provided in their moduleinfo.java files.
b specified dependencies between modules based on their directives fig.
three example modules with their inter dependencies the requires directive with declaration requires m2of a module m1specifies the name of a module m2that m1 depends on.
m2can be a user defined module or a module within the jdk.
for example in figure module bar requires module java.desktop .
the requires declaration of a module m1may be followed by the transitive modifier which ensures that any module m3that requires m1also implicitly requires module m2.
as an example in figure module foo requires module bar and any module that requires foo also implicitly requires bar.
the exports directive with declaration exports pof a module m1specifies that m1exposes package p s public and protected types and their nested public and protected types to all other modules at both runtime and compile time.
for example in figure the module bar exports the package com.example.bar.lang .
we can also export a package specifically to one or more modules by using theexports ptom2 m3 ... mndeclaration.
in this case the public and protected types of the exported package are only accessible to the modules specified in the toclause.
as an example in figure module foo exports com.example.foo.internal to the module bar.
theopens directive with declaration opens pspecifies that package p s nested public and protected types and the public and protected members of those types are accessible by other modules at runtime but not compile time.
this directive also grants reflective access to all types in p including the private types and all its members from other modules.
for example in figure module foo makes package com.example.foo.network available to other modules only at runtime including through reflection.
this directive may also be followed by the tomodifier resulting in the opens ptom2 m3 ... mndeclaration.
in this case the public and protected types of pare only accessible to the modules specified in the toclause.
for instance in figure module foo makes package com.example.foo.exnet available only at runtime including through reflection to the module bar.
unlike the other directives that can only be used in the body of a module s specification open can be used in both the body of a module s specification and in its header i.e.
before the module s name .
the latter usage is a shorthand way of denoting all packages in the module are open .
the provides with directive with declaration provides c1with c2 c3 .
.
.
cnof module m1specifies that a class c1is an abstract class or interface that is provided as a service by m1.
the with clause specifies one or more service provider classes for use with java.util.serviceloader .a service is a well known set of interfaces and usually abstract classes.
a service provider is a specific implementation of a service.
java.util.serviceloader s is a simple serviceprovider loading facility.
it loads a provider implementing the service type s .
for instance in figure module bar provides the abstract class com.example.service.srv as a service using the com.example.bar.impl.implservice class as the service s implementation.
the uses directive with declaration uses c1of a module m1specifies that m1uses a service object of an abstract class or interface c1 provided by another module.
for this purpose the module should discover providers of the specified service via java.util.serviceloader .a sa n example from figure module foo uses the service object of class com.example.service.srv which is provided by module bar.
note that as depicted in figure both provides with and uses directives need the module being declared to require the service module as well.
iii.
i nconsistent module dependencies based on the module directives described in the previous section inconsistencies may arise when using modules.
insufficiently specified dependencies e.g.
a module that attempts to use a package it does not have a requires directive for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
are already checked by the java platform.
however excess dependencies where a module either exposes more of its internals than are used or requires internals of other modules that it never uses are not handled by java.
these inconsistencies can affect various architectural attributes a1 encapsulation and maintenance requiring unneeded functionalities of other modules increases the complexity of the module unnecessarily compromises its encapsulation and decreases its maintainability.
a2 software bloat and scalability requiring unneeded modules especially from jdk can result in bloated software which compromises scalability of the application.
a3 security excessively exposing the internals of a module can result in errors or security issues arising in the module.
to achieve a systematic and comprehensive coverage of all types of inconsistent module dependencies we studied all potential inconsistencies resulting from developers misuse of each type of module directive.
in the remainder of this section we focus on specifying eight types of inconsistent dependencies that may arise when using jpms and the functions needed to specify those dependencies.
table i includes functions that directly model different variations of the five module directives in jpms.
to describe a class loading a service using java.util.serviceloader api we define the loadsservice function.
for actual code usage among packages as opposed to those specified through module directives we define the dep function.
table i functions describing dependencies based on module directives of jpms function description req m1 m2 module m1requires module m2.
reqjdk m1 mjdk module m1requires the jdk module mjdk.
reqtransitive m1 m2 module m1requires transitive module m2.
exp m p module mexports package p. expto m1 p1 m2 m3 ... module m1exports package p1to the set of modules m2 m3 ... .
open m module mis open.
opens m p module mopens package p. opensto m1 p m2 m3 ... module m1opens package pto the set of modules m2 m3 ... .
uses m s module muses service s. provideswith m s c1 c2 ... module mprovides service swith the set of classes c1 c2 ... .
loadsservice c s class cloads service svia the java.util.serviceloader api.
dep p1 p2 source code in package p1uses classes of package p2.
re f ldep p1 p2 source codes in package p1uses classes of package p2via reflection.
by leveraging the functions in table i we introduce eight types of excess inconsistent dependencies requires jdk requires requires transitive exports to provides with uses open and opens to modifiers.
for each inconsistentdependency type there is a dependency explicitly defined in amodule info file which is not actually used in the source code of the module.
using these formal definitions section iv detects and repairs the following inconsistent dependencies.
inconsistent requires dependency this scenario describes an inconsistent requires dependency in which module m1explicitly declares that it requires another module m2and no class of m1actually uses any class inside exported packages of m2.
as a result this inconsistency mostly affects attribute a1.
it can also affect attribute a2.
req m1 m2 p1 m1 p2 m2 dep p1 p2 inconsistent jdk requires dependency this scenario describes an inconsistent requires dependency in which module m1explicitly declares that it requires a module inside the java jdk mjdk.
however none of the classes inside m1 uses any class inside exported packages of mjdk.
hence it affects attribute a1 and more importantly a2.
we distinguish this scenario from the previous one because an inconsistency involving jdk modules has a greater effect on portability than the previous more generic scenario.
req m1 mjdk p1 m1 p2 mjdk dep p1 p2 inconsistent requires transitive dependency an excess transitive modifier in a requires dependency consists of the following a module m1explicitly declares in its module info file that it transitively requires another module m2 which means any module that requires m1also implicitly requires m2 and no class of a module that requires m1 actually uses any class in m2.
this type of inconsistency mostly affects attribute a1 but also affects a2.
reqtransitive m1 m2 m req m m1 p m p2 m2 dep p p2 inconsistent exports exports to dependency an inconsistent exports dependency occurs when a module m1explicitly exports a package p1to all other modules while no package in those other modules use p1.
exp m1 p1 p m1 dep p p1 for an exports to directive this inconsistency occurs when m1 exports the package p1to a specific list of modules m while no class outside m1 or inside module list m uses any class inside p1.
expto m1 p1 m p m dep p p1 these inconsistencies mostly affect attribute a3 by granting unnecessary access to classes and packages.
they also affect attribute a1 due to complicating the architecture.
inconsistent provides with dependency an inconsistent provides with dependency has two key parts a module mexplicitly declares that it provides a service s which is an abstract class or interface that is extended or implemented by a set of classes e c1 c2 .
.
.
ck inside m and none of the classes inside other modules uses service svia the java.util.serviceloader api.
consequently this inconsistency type similar to inconsistent requires dependency affects attribute a1 and a2 because the provides with depen563 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dency necessitates a requires directive as well.
additionally this inconsistency type grants unnecessary access to a subset of the application s classes via the serviceloader api which affects attribute a3.
provideswith m s e m prime negationslash m uses m prime s inconsistent uses dependency an inconsistent uses dependency occurs when a module mexplicitly declares in itsmodule info.java file that it uses a service sand none of the classes inside mactually use the service svia thejava.util.serviceloader api.
this inconsistency type similar to the previous type will affect attribute a1 and a2 due to adding an additional requires directive.
uses m s c m loadsservice c s inconsistent open modifier an excess open modifier occurs in the following scenario a module mdeclares that it opens all its packages to all other modules recall from section ii b that unlike the other directives open can be used in the header of a module s specification to denote all its packages are open and there is at least one package pinside mthat no class outside mreflectively accesses.
as a result any such package pis potentially open to misuse through reflection e.g.
external access to private members of a class that should not be allowed by any other class.
this inconsistency type will affect attribute a3 and make the architecture inaccurate and more complicated affecting attribute a1.
open m p m p prime m re f ldep p prime p inconsistent opens opens to an inconsistent opens dependency occurs when a module mdeclares that it opens a package pto all other modules via reflection while none of the classes outside mreflectively accesses any classes of package p. opens m p p prime m re f ldep p prime p similarly for opens to the tomodifier specifies a list of modules mfor which module mopens a package pto access via reflection while no package of mreflectively accesses p. opensto m p m p prime m re f ldep p prime p for these inconsistency types private members of pare open to dangerous misuse through undesired access and reflection affecting attribute a3 and can also affect attribute a1 due to unnecessarily complicating the architecture.
iv .
d arcy in the previous section we introduced various types of inconsistent dependencies.
this section describes how we leverage these definitions to design and implement d arcy .
figure depicts a high level overview of d arcy comprised of two phases detection and repair .d arcy is implemented in java and python.
a. detection the detection phase takes a java application as input and identifies any instance of the eight inconsistent dependencies described in section iii.
to identify actual dependencies of an input java application darcy relies on static analysis represented as class dependency analysis in figure .
in the implementation of d arcy fig.
a high level overview of d arcy we leveraged classycle for class dependency analysis .
more precisely the information about actual dependencies in the source code of the input application is collected by running classycle which provides a complete report of all dependencies in source code of a java application at both the class and package levels.
we only need the extracted dependencies among packages since the dependencies defined in modules are at the package level.
class dependency analysis s results are stored inactual dependencies which is a database component.
a java application may contain multiple modules each with amodule info file describing the module s dependencies.
for extracting a prescriptive architecture we developed moduleinfo scanner which examines all module info.java files within the input java application and extracts all specified dependencies which are defined at the package level.
the collected information of specified dependencies are stored in another database component specified dependencies .
java reflection analysis leverages a custom static analysis which we have implemented using the soot framework to identify usage of reflection in the input application.
the traces of any actual usage of reflection in the java application is then stored in actual dependencies .
java reflection analysis extracts reflective invocations that occur in cases where non constant strings or inputs are used as target methods of a reflective call.
reflective invocation of a method for both constructor and non constructor methods occurs in three stages class procurement i.e.
a class with the method of interest is obtained method procurement i.e.
the method of interest to be invoked is identified and the method of interest is actually invoked.
java reflection analysis attempts to identify information at each stage.
classloader cl myclass.
getclassloader try class c cl.loadclass netclass ... method m c.getmethod getaddress ... ... m.invoke ... catch .
.
.
fig.
reflective method invocation example a simple example based on those found in real world apps of reflective method invocation not involving constructors is depicted in figure .
in this example a classloader formyclass is obtained line which is responsible for loading classes.
the netclass class is loaded using authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
thatclassloader line .
the getaddress method of netclass line which performs network operations is retrieved and eventually invoked using reflection line .
our analysis identifies reflectively invoked methods using a backwards analysis.
that analysis begins by identifying all reflective invocations e.g.
line in figure .
next the analysis follows the use def chain of the invoked java.lang.reflect.method instance e.g.
mon line to identify all possible definitions of the method instance e.g.
line .
our analysis considers various methods that return method instances i.e.
using getmethod or getdeclaredmethod ofjava.lang.class .
the analysis then records each identified method name.
if the analysis cannot resolve the name this information is also recorded.
in this case the analysis conservatively indicates that any method of the package opened for reflection can be accessed.
for constant strings the analysis attempts to identify the class name that is being invoked.
similar to the resolution of method names the analysis follows the use def chain of the java.
lang.class instance from which a java.lang.class is retrieved e.g.
following the use def chain of con line .
we model various means of obtaining a java.lang.class instance.
for example the class may be loaded by name using aclassloader sloadclass ... method e.g.
line using java.lang.class sforname method or through a class constant e.g.
using netclass.class .
the analysis then records the class name it can find statically or stores that it could not resolve that name.
note that our analysis considers any subclass of classloader .
our reflection analysis involving constructors works in a similar manner by analyzing invocations of java.lang.reflect.constructor and invocations of its newinstance method.
similar to our analyses for reflectively invoked methods we perform analyses for any set methods ofjava.lang.reflect.field e.g.
setint ... orget field methods of java.lang.class e.g.
getdeclaredfield string .
for extracting the actual dependencies of type uses we implemented serviceloader usage analysis which leverages a custom static analysis using the soot framework to identify usage of java.util.serviceloader in the input application.
the traces of any actual usage of a service is then stored in actual dependencies .
an application obtains a service loader for a given service by invoking the static load method of serviceloader api.
a service loader can locate and instantiate providers of the given service using the iterator orstream method through which an instance of each of the located service providers can be created.
as an example figure depicts the code that obtains a serviceloader formyservice line .
the serviceloader loads providers of myservice line and can instantiate any of the located providers of this service using its iterator created by the for loop in line .
in this example the service provider with the getservice method is desired line .
our analysis identifies the usage of the serviceloader1 serviceloader myservice loader loader serviceloa der.load myservice.
class for myservice s loader if s.getservice !
null ... fig.
service loader example api using a backward analysis by following the use def chain ofserviceloader instances e.g.
son line to identify all possible definitions of a serviceloader e.g line in figure .
the results of the serviceloader api usage is then stored in actual dependencies .
java inconsistency analysis s main goal is to identify all types of inconsistency scenarios described in section iii.
for each directive in a module info.java file java inconsistency analysis explores actual and specified dependencies stored in their respective database components to identify any occurrence of an inconsistent dependency defined in section iii.
if a matching instance is found java inconsistency analysis reports the identified architectural inconsistency the module affected and the specific directive involved.
the component then stores the identified inconsistencies in inconsistent dependencies which are then used in the repair phase.
b. repair to repair inconsistent dependencies module info transformer deletes or modifies the explicit dependencies defined in themodule info files.
inconsistencies found in the previous phase are all unnecessarily defined dependencies among an application s modules and packages.
therefore module info transformer needs to omit those inconsistent dependencies specified in the module info files.
the result of the detection phase includes the type and details of identified inconsistencies.
for instance in the case of an inconsistent exports dependency one result stored in inconsistent dependencies includes the module in which this dependency is specified the type of the inconsistent dependency exports in this case and the package that is unnecessarily exported.
the repair phase takes the results of the detection phase as input.
for each module the repair phase finds the related records of inconsistent dependencies defined in that module and modifies the affected lines in module info .
for this purpose we leveraged antlr to transform themodule info.java files to repair the inconsistent dependencies.
antlr is a parser generator for reading processing executing or translating a structured text.
hence we generated a customized parser using java grammar so that we can modify it to check the records of inconsistent dependencies found in the detection phase of d arcy .
more precisely we have implemented the generated parser so that if it finds any match between the tokens of module info files and the inconsistent dependencies it skips or modifies the specific token with respect to the type of the inconsistency.
as a result depending on the type of dependency the corresponding line in the module info file is omitted or modified.
module info transformer repairs each type of inconsistent dependency.
in most cases module info transformer deletes authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the entire statement.
however for requires transitive module info transformer only removes the token transitive .
in case of inconsistencies involving open module m equation in section iii the open modifier is removed from the header of the module declaration.
however there may be some packages in mthat other modules reflectively access.
for each of these packages module info transformer adds an opens to statement thats make private members of the package accessible to the modules that reflectively access the package.
if there is no package in mthat is reflectively accessed by other modules no statement will be added to the module s body.
in certain situations the d arcy user may disagree with the way it repairs and modifies the specified dependencies because darcy is not aware of the architect s or developer s intentions.
for example this situation may occur if the user wants to develop a library and export some packages for further needs or even allow other modules to reflectively access the internals of some classes and packages.
d arcy warns the developers and architects about potential threats caused by architectural inconsistencies in their java application and allows them to override d arcy prior to application of repairs.
v. e v alua tion to assess the effectiveness of d arcy we study the following research questions rq1 how pervasive are inconsistent architectural dependencies in practice?
rq2 how accurate is d arcy at detecting inconsistent architectural dependencies and repairing them?
rq3 to what extent does d arcy reduce the attack surface of java modules?
rq4 to what extent does d arcy enhance encapsulation of java modules?
rq5 to what extent does d arcy reduce the size of runtime memory?
rq6 what is d arcy s runtime efficiency in terms of execution time?
to answer these research questions we selected a set of java applications from github a large and widely used open source repository of software projects all of which are implemented in java .
for this purpose we searched through java applications in github and selected projects that contain a module info.java file.
our search covered about a hundred pages of search results in the github repository.
to assess module dependencies projects needed to have more than one module in their respective module info.java files.
our final evaluation dataset resulted in java applications avoiding any selection bias toward our approach.
a. rq1 pervasiveness table ii shows for each application the total number of inconsistent dependencies d arcy found modules module directives used and inconsistent dependencies by type.
of applications in our dataset out of have inconsistent dependencies.
recall that even one existing inconsistent dependency could cause undesired behaviors or issues withencapsulation security or memory utilization see section iii .
as depicted in table ii most of the inconsistent dependencies are of types exports orrequires because these two types of directives are used more frequently than others.
the high frequency of inconsistent exports dependencies indicates that granting unnecessary access to internal packages are quite common in java applications which could cause security vulnerabilities.
among the inconsistent requires dependencies therequires jdk dependency occurred more than others which increases the risk of loading unnecessary jdk modules and compromising portability.
table ii indicates that a few applications have inconsistent dependencies of type provides with and only one application has an inconsistent uses dependency.
in fact these directives are rare compared to other directives.
for provides with and uses java checks most of the requirements for avoiding inconsistent dependencies at compile time.
therefore the possibility of defining an inconsistent provides with and uses dependencies decreases.
nevertheless d arcy covers the inconsistent dependencies corresponding to these two directives because they are risky and may appear more frequently in future usage of java .
b. rq2 correctness to answer rq2 for d arcy s detection capability we ran the detection phase for each of the java applications in our evaluation dataset to assess whether d arcy can accurately detect inconsistent dependencies.
to that end we manually checked the inconsistent dependencies found by d arcy to ensure their correctness.
more precisely we compared the corresponding record in both actual dependencies and specified dependencies to verify the correctness of the inconsistencies discovered by the detection phase.
the result as described in table ii shows that all inconsistent dependencies found by darcy are correct.
to evaluate d arcy s ability to correctly repair inconsistencies we ran the repair phase of d arcy for each of the java applications in our evaluation dataset to assess whether d arcy repairs the detected inconsistencies without introducing any unexpected behavior.
to assess correctness of a repair we check if each application compiles successfully after running the repair phase and if the application contains a test suite determine if the application obtains the same test passing rate i.e.
the ratio of the number of passing test cases to the total number of test cases both before and after repairs.
we also ran the detection phase after the repair actions.
the result showed zero inconsistencies within the transformed java applications.
the results for compilation after repair are shown in table ii indicating that all the applications compiled successfully.
this confirms that the inconsistent dependencies have been repaired robustly in a way that does not prevent compilation of the applications.
additionally three applications in our study contain a test suite.
the passing rate for each of these test suites remains the same both before and after d arcy repairs demonstrating that d arcy does not negatively affect expected behavior of repaired applications.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii identified inconsistencies and robustness results no.
application modules directives total inconsistencies types correct compiled test passing rate name incons.
r r.j. r.t e p u o incons.
after repair before after sense nine check number to text check vstreamer check jigsaw resources check javautils check bunnyhop check java9 modules check jwtgen check project constantin check java spi example check codersonbeer app check rahmnathan utils check auto sort check java9 demo check java9 modules tlb check java lab check meetup check java bookstore check springuni java9 check java modularity check java spring mvn check music ui start check java9 labs check practical security check java9 junit check the message check jigsaw tst check trpz check c. rq3 security to assess d arcy s ability to enhance security we consider the attack surface of java applications.
the attack surface of a system is the collection of points at which the system s resources are externally visible or accessible to users or external agents.
manadhata et al.
introduced an attack surface metric to measure the security of a system in a systematic manner .
every externally accessible system resource can potentially be part of an attack and hence contributes to a system s attack surface.
this contribution reflects the likelihood of each resource being used in security attacks.
intuitively the more actions available to a user or the more resources that are accessible through these actions the more exposed an application is to security attacks .
for a java application the main resource under consideration is a java module.
as a result we define the attack surface of an application as the number of packages that are accessible from outside its modules.
to measure the attack surface of java applications we count the number of packages exposed byexports to and open s to directives.
these directives make internals of packages accessible to other modules.
as shown in table iii out of applications had an average attack surface reduction of about .
d arcy was able to totally eliminate the attack surface in applications.
although eliminating the module based attack surface does not result in perfect security d arcy can maximize protection to the asset i.e.
java packages through a module s interfaces by eliminating all unnecessary exports and opens directives of the module other attack vectors e.g.
ipc over network sockets 1these applications are essentially software utilities or libraries including different modules that provide functionalities for different situations but do not have any dependency on one another.table iii result for attack surface reduction application exposed exposed attack surface name pckg before pckg after reduction sense nine .
number to text .
jigsaw resources .
javautils .
bunnyhop .
java9 modules .
jwtgen project constantin java spi example .
codersonbeer app .
rahmnathan utils auto sort .
java9 demo .
java9 modules tlb .
java lab .
meetup .
springuni java9 java spring mvn music ui start .
java9 labs .
practical security .
java9 junit .
the message .
jigsaw tst .
trpz .
avg.
attack surface reduction .
still remain but are out of scope for d arcy .
the relatively large reduction of the attack surface in applications achieved by d arcy indicates that it can significantly curtail security risks in java applications.
d. rq4 encapsulation to evaluate the ability of d arcy to enhance the encapsulation of java applications we leveraged two metrics selected from an extensive investigation by bouwers et al.
about the quantification of encapsulation for implemented software architectures.
we selected metrics that involve architectural dependencies and are appropriate for the context of modules authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in jpms and java applications.
the first metric we selected is ratio of coupling roc which measures coupling among an application s modules.
for java modules roc is the ratio of the number of existing dependencies among modules to the number of all possible dependencies among modules .
ideally the value of roc would be low meaning that only a small part of all possible dependencies among modules is actually utilized making it less likely that faults failures or errors introduced by changes or additions to modules will propagate across modules.
the second metric we selected is a variant of cumulative component dependency ccd which is the sum of all outgoing dependencies for a component.
for java modules outgoing dependencies are requires and uses dependencies of each module.
the specific variant we used is normalized ccd ncd which is the ratio of ccd for each module to the total number of modules.
ideally the value of ccd or ncd is low indicating lower coupling and better encapsulation.
table iv results for encapsulation improvement application directives roc ncd name before change change sense nine .
.
number to text .
vstreamer .
.
jigsaw resources .
javautils .
.
bunnyhop .
.
java9 modules .
jwtgen .
.
project constantin .
.
java spi example .
.
codersonbeer app .
.
rahmnathan utils .
.
auto sort .
java9 demo .
java9 modules tlb .
java lab .
meetup .
java bookstore .
.
springuni java9 .
.
java modularity .
.
java spring mvn .
.
music ui start .
.
java9 labs .
practical security .
.
java9 junit .
the message .
jigsaw tst .
trpz .
total of affected systems roc roc reduction avg.
.
total of affected systems ncd ncd reduction avg.
.
table iv presents the amount of roc and ncd change in java applications with inconsistent dependencies.
across all applications the amount of roc is reduced by an average of .
and up to .
.
the amount of ncd is also reduced in applications by an average of .
and up to .
these results indicate that d arcy can successfully enhance the encapsulation of java applications by a significant amount.
e. rq5 software bloat to answer this research question we measured the runtime memory needed by each application before and after d arcy s repair phase.
recall the fact that in java with the jdk being modularized we are able to create a lightweight custom javaruntime environment jre reducing software bloat.
more specifically the size of a custom jre may be reduced after a repair if the application has inconsistent dependencies of type requires jdk equation of section iii .
table v results for software bloat reduction application jre size mb runtime memory name before after reduction sense nine .
.
.
javautils .
.
.
bunnyhop .
.
.
java spi example .
.
.
rahmnathan utils .
.
.
practical security .
.
.
avg.
memory reduction .
table v shows reduction of software bloat in terms of runtime memory size of affected applications after removing inconsistent requires jdk dependencies.
according to the results the reduction is about in applications and up to .
such results are particularly substantial for deployment and scalability goals in microservices or iot devices that contain very little memory.
f .
rq6 performance as described in section iv d arcy builds on three tools classycle soot and antlr .
as a result to assess d arcy s performance we answer rq5 in terms of these three underlying tools execution time.
table vi results for execution time component avg.
execution time ms class dependency analyzer classycle java reflection analysis serviceloader usage analysis java inconsistency analysis repair total table vi describes the average execution times for d arcy .
results for classycle are shown separately from results for other components since the execution time is dominated by classycle.
on average d arcy takes under seconds for any system to execute which is highly time efficient for both detection and repair.
vi.
t hrea ts to validity in terms of accuracy the main threat to internal validity is the risk of false positives or negatives of the static analysis tools used in the implementation.
false positives or negatives in the results of the static analysis tools may cause d arcy to miss some inconsistencies in the detection phase or report false inconsistencies which may lead to compilation errors or harming functionality of the application after the repair phase.
since d arcy takes classycle s results as an input for the java inconsistency analysis it inherits all of classycle s limitations.
the accuracy of detecting the inconsistent dependencies is affected by the accuracy of the static analysis tool we use.
however classycle has been used and in development for over years and leveraged by other state of the art tools for software architecture and antipattern analysis .
a similar threat to internal validity exists for our use of soot however soot is a widely used and actively maintained authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
framework for static analysis of java programs.
we further manually determine whether every identified inconsistency is correct to ensure that any unforeseen issues with underlying static analyses do not compromise d arcy s accuracy.
one of the main threats to external validity is the selection and number of java applications in the evaluation dataset.
to mitigate this threat we selected open source java applications from many developers and about a hundred pages of search results on github one of the largest and most widely used open source repositories online.
another threat to external validity is whether the types of inconsistencies we identify comprehensively cover those that may exist.
to alleviate this threat we considered the architectural inconsistencies based on all types of module directives defined in java .
darcy s evaluation on only one programming language i.e.
java is another threat to external validity.
this threat is alleviated by the fact that java is one of the most widely used languages in the world .
furthermore the general idea behind d arcy can be extended to any other languages with modular programming constructs that utilize provides and requires interfaces advocated by software architecture based development and design .
vii.
r ela ted work the most closely related literature to d arcy bridges the gap between software architecture and implementation.
there are a variety of different types of strategies to address this issue focusing only on the descriptive architecture by reverse engineering it obtaining the descriptive architecture and the prescriptive architecture followed by checking their conformance ensuring that early in the software lifecycle that the descriptive and prescriptive architectures conform by providing architectural constructs in code and approaches that ensure conformance of the descriptive and prescriptive architecture from the beginning and into maintenance.
many approaches address the architecture implementation mapping issue by ignoring the prescriptive architecture and simply trying to obtain the most accurate descriptive architectures possible .
a large number of these approaches rely on software clustering to determine components from implementations .
a series of approaches detect inconsistencies between architecture and implementation by reverse engineering the descriptive architecture from the code and comparing it with the prescriptive architecture .
murphy et al.
introduced the software reflexion method which helps an engineer compare prescriptive and descriptive architectures in a manual manner .
a number of these approaches extend the reflexion method with automated architecture recovery techniques .
other approaches provide implementation level constructs that represent architectural elements e.g.
customizable programming language classes representing components that help ensure architectural conformance from a forwardengineering perspective .
many of these approaches support various notions of software architectural connectors or interfaces rather than just components.certain approaches achieve architecture implementation mapping from both a forward engineering e.g.
code generation and reverse engineering perspective i.e.
round trip engineering .
.x way mapping allows manual changes to be initiated in the architecture and a separated portion of the code with architecture prescribed code updated solely through code generation.
.x line mapping extends .xway mapping to product line development.
song et al.
introduce a runtime approach for architecture implementation mapping from a roundtrip engineering perspective.
darcy is the first approach that supports architecturalimplementation conformance checking in a mainstream programming language using architectural constructs built directly into the programming language by its creators.
furthermore our approach includes repair of non conforming architectures rather than just determining inconsistencies.
d arcy is the only approach for architecture implementation mapping that focuses on software bloat and attack surface reduction.
the module system has been recently introduced in java and the only existing framework similar to jpms is osgi .
the major differences between osgi and jpms are as follows.
osgi was not able to modularize the jdk preventing the construction of customized runtime images with a minimized jdk which jpms enables.
additionally osgi cannot handle reflective access to modules internal packages.
similar dependency analysis facilities for osgi are limited to removing unused dependencies of type import which represents the require dependency and cannot cover the other types of inconsistencies in jpms applications previously introduced in section iii.
therefore there is no similar facility for osgi that repairs all types of inconsistent dependencies as d arcy does.
viii.
c onclusion this paper formally defines types of architectural inconsistencies in java applications and introduces d arcy a n approach for automatic detection and repair of these types of inconsistencies.
d arcy leverages custom static analysis stateof the art static analysis tools and a custom parser generator in its implementation to effectively detect and robustly repair architectural inconsistencies.
the results of our evaluation indicates a pervasive existence of architectural inconsistencies among open source java applications.
according to our experiment darcy s automatic repair results in a significant reduction of the attack surface enhancement of encapsulation and reduction of memory usage for java applications.
in the future we aim to expand d arcy to other programming languages and improve it to provide architectural visualization and be used as a plug in for java integrated development environments ide which helps developers avoid architectural inconsistencies when developing java applications.
ix.
a cknowledgement this work was supported in part by awards ccf cns ccf and cns from the national science foundation.
we would like to thank daniel popescu for informing us about jpms before it was released as part of java.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.