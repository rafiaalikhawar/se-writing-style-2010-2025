detecting javascript races that matter erdal mutlu ko c universityserdar tasiran ko c universitybenjamin livshits microsoft research abstract as javascript has become virtually omnipresent as the language for programming large and complex web applications in the last several years we have seen an increase in interest in nding data races in client side javascript.
while javascript execution is single threaded there is still enough potential for data races created largely by the nondeterminism of the scheduler.
recently several academic e orts have explored both static and runtime analysis approaches in an e ort to nd data races.
however despite this we have not seen these analysis techniques deployed in practice and we have only seen scarce evidence that developers nd and x bugs related to data races in javascript.
in this paper we argue for a di erent formulation of what it means to have a data race in a javascript application and distinguish between benign and harmful races a ecting persistent browser or server state.
we further argue that while benign races the subject of the majority of prior work do exist harmful races are exceedingly rare in practice harmful vs. benign .
our results shed a new light on the issues of data race prevalence and importance.
to nd races we also propose a novel lightweight runtime symbolic exploration algorithm for nding races in traces of runtime execution.
our algorithm eschews schedule exploration in favor of smaller runtime overheads and thus can be used by beta testers or in crowd sourced testing.
in our experiments on sites we demonstrate that benign races are considerably more common than harmful ones.
.
introduction when it comes to client side web programming today javascript powers the majority of large and popular web sites.
javascript execution is single threaded.
yet the complex needs of sites such as facebook outlook google maps and the like have led to asynchrony becoming a common way to program complex web applications.
it is asynchronous processing that is responsible for interactive and responsive user interfaces uis that operate without blocking the ui thread or requiring a reload as did web applications of the late 1990s.
despite javascript lacking conventional threads the presence of asynchrony creates a potential for races.
in particular the ordering of event execution in javascript as well as the timing of completions of asynchronous requests is non deterministic prone to be a ected by network delayes etc.
resulting in data races.
in this paper we argue that one should distinguish between races that have persistent consequences and those that are ephemeral.
we argue that the majority of races in javascript have no persistent consequences we dub these races benign .
this is because these races only result in invisible to the user portions of the program state or at worst ui glitches that are either unnoticed by the user or disappear if the user reloads the page.
given the forgiving nature of javascript execution where failures of individual event handlers force the scheduler to terminate the current event handler and move execution to the next one these kinds of failures are not as important as previously believed.
we suggest that a more useful way to think about data races on the web is by focusing on persistent state such as client local cookies localstorage andsessionstorage mechanisms as well as server based side e orts.
the latter are achieved via post calls to the server getcalls are designed for reads and are supposed to be idempotent and thus are not frequently used for state updates .
our experiments con rm that the number of such harmful races is quite modest yet it is these kinds of races that are more likely to be considered serious and xed by developers.
previous research e orts tend to produce a large number of reports despite the emphasis on suppressing false positives .
it is not our goal to provide a sound over approximation of all possible races in a given application or site.
so is a very di cult task.
indeed there are some fundamental limitation of program analysis for nding races in javascript.
static analysis is unlikely to be sound for large programs given the presence of eval and complex language features not to mention the fact that precise reasoning about happens before relationship between event handlers statically is simply very di cult.
runtime analysis including various forms of symbolic exploration of possible schedules falls victim to code coverage.
instead our goal is to provide a lightweight exploration algorithm that allows for the exploration of multiple schedules while only requiring a single run.
this approach can be used for testing including collaborative testing by a large number of beta or crowd sourced testers.
a number of companies nowadays provide commercial crowd sourced testing services for web sites which can be used as a cheap and practical way to increase coverage.
contributions we make the following contributions we propose a new view of benign and harmful data races in javascript web applications and argue that harmful races should be the primary focus of analysis tools due to them a ecting the persistent client or server side state of the applications.
we propose a lightweight exploration algorithm for nding data races in runtime traces of javascript programs.
a key advantage for the scalability of our approach is that it does not require multiple program runs and can operate on the basis of a single execution.
we nd and investigate a total of harmful and benign races in web sites with only observed false positives.
.
overview in the last several years we have seen an upsurge of interest in data races in asynchronous programs and in javascript more speci cally.
researchers have tried applying static and runtime analysis to the problem of nding races.
a fundamental challenge with static analysis for a language as dynamic as javascript is that it is really quite di cult to even enumerate all the relevant code as much of the javascript code is produced with the help of eval calls and dynamic code loading.
as a result the traditional advantage of static analysis namely full path coverage largely does not apply to this problem.
as such the ability to make sound statements about the lack of data races is compromised .
additionally reasoning about runtime events such as multiplexmlhttprequest s xhrs whose callbacks race against each other statically is fundamentally very di cult because the happens before relation is quite complex.
runtime techniques in this space are also vulnerable to losing precision which leads tool authors to develop heuristics to eliminate potential false positives .
they also su er from the lack of coverage and the inability of making sound guarantees about the lack of races.
additionally runtime techniques that involve combinatorial schedule exploration can run into scalability challenges especially when the number of possible handlers to schedule is high .
our technique attempts to combine the advantages of static and runtime analysis.
we execute the code only once yet we explore multiple execution orders.
as such our technique scales well while increasing the coverage of a singlepass runtime analysis.
one way to see our approach is that in explores neighboring schedules for a particular runtime execution.
we foresee this approach as being especially useful in the context of beta or crowd sourced testing having a large number of users will naturally increase code coverage.
at the same time the users sessions will not be signi cantly slowed down.
it should be noted that in the browser slowing down the browser runtime runs the risk of modifying the behavior of timeout set with settimeout and setinterval additionally the runtime may actively attempt to terminate slow running events.
.
what is a data race?
several possibly de nitions of data races have been proposed for web applications .
they all center around the idea of writes to shared state that are performed by callbacks.
some of the races in prior work are caused by user interactions and browser induced timing.
in this work our chief focus is on the xmlhttprequest mechanism which allows client side code to request data from servers var xhr new xmlhttprequest xhr.
open get http www.
data .com mydata .
json xhr.
onreadystatechange function e d ... xhr.
send null the code above is for a typical getrequest that obtains json data from a server and schedules an asynchronous onreadystatechange callback to process the data once it arrives.
multiple such callbacks can be outstanding creating the possibility of what we dub an xhr xhr race if these callbacks write to shared state.
moreover commonly while synchronous xhr execution is possible xhrs are scheduled to be dispatched asynchronously to maintain a responsive client side ui .
in the rest of the paper we shall focus on asynchronous xhrs.secondly a single xhr callback can race with the browser resulting in the state variable being set to either or .
this is because the browser may have multiple script blocks some of which may be scheduled either before or after the callback depending on the callback s arrival and how fast the browser is rendering content script var xhr new xmlhttprequest xhr.
open get http www.
data .com mydata .
json xhr.
onreadystatechange function e d state xhr.
send null script ...a lot of text and images here ... script state script thirdly and even more subtly if the user opens the same site in multiple browser tabs it is possible for these tabs to lead to concurrent execution.
two instance of the code below may race with each other when run in di erent tabs resulting in a cookie based race on line script var xhr new xmlhttprequest xhr.
open get http www.
data .com mydata .
json xhr.
onreadystatechange function e d document .
cookie value math .
random xhr.
send null script the happens before relation for asynchronous callbacks is de ned by the creation order.
the xhr callback is preceded by the code that creates the xhr xhr send .
a speci c case of this is what we call nested or chained xhrs when callbacks are de ned one within another.
practically this is about the only way for the developer to ensure that there is ordering of xhr callbacks so we see this programming pattern quite a bit.
.
motivating examples in an e ort to understand the possible impact of data races on the web we spent some time analyzing bug reports for open source projects located on github.
below we describe some of the examples of subtle server side bugs from github.
in the interest of fairness we should mention that these examples of races reported as github issues were not particularly common bugs for javascript projects an intuition that is largely con rmed by our results in section .
example issue for the wheatonwhale project1describes the following situation .
the user reloads the page .onbeforeunload listener res and the data is saved to server .
the page is loaded up again and asks the server for the data .
the client side javascript code loads up the old outdated data .
client state is saved to the server.
in the last step the old outdated data is saved to the server essentially ignoring data updates.
the culprit is the fact that steps and can race with each other the data load request html script var xhr new xhr xhr .
open false xhr .
onreadystatechange function document .
cookie var1 xhr .
send for i i i console .
trace i script ... !
input id mydiv script document .
cookie var1 script ... script var xhr2 new xhr xhr2 .
open false xhr2 .
onreadystatechange function document .
cookie var1 xhr2 .
send script html put your code here .
figure multiple xhr example.
may arrive before the save is processed.
the implemented x makes data updates synchronous.
example a somewhat similar situation that has to do with the issue of stale data obtained from the server is captured in issue in a project called likelines2.
likelines provides users with a in browser video player with a navigable heat map of interesting regions for the videos they are watching.
this case describes two racing xhr calls that are issued to the backend server during initialization by the following functions createsession and aggregate .
the rst call is to create a new session for recording user interactions.
the second call is needed for drawing a heat map.
the problem arises when a user has not contacted the backend server before.
in this case both xhr calls will be issued without a cookie and in both cases the server will create a new user id.
this is clearly a problem because interaction sessions are tied to a user id in this applications.
if the cookie from the call to aggregate wins i.e.
arrives last then subsequent calls to the server will contain a user id that does not match the interactions session.
in addition to the github issues discussed above below we list an illustrative example inspired by some of the samples from prior work although prior work did not focus on the issue of asynchronous xhrs.
example consider the code in figure .
for convenience we mark every handler above with a number.
the happens before relation induced by this code example is as follows .
as such our exploration algorithm will consider the possibility and .
similarly because and are weakly ordered traces in which happens before or after will be considered.
while one can explore these traces via a search in the schedule space we choose to do so via data ow.
we keep track of the event handlers that may be concurrent and mark the writes that they make to the same locations as weak writes.
.
read prop id open jsfunction xhr open get read prop id send jsfunction xhr send xhr callback begin xhr callback read id document jsobject write prop id cookie jsinteger cookie write var1 end xhr callback read id document jsobject write prop id cookie jsinteger cookie write var1 read prop id open jsfunction xhr open get read prop id send jsfunction xhr send xhr callback begin xhr callback read prop id readystate jsinteger read id document jsobject write prop id cookie jsinteger cookie write var1 end xhr callback figure sample trace illustrating cookie races.
because and can race the value of document cookie will be either var1 1orvar1 .
similarly for and the value of document cookie will be either var1 1or var1 .
to preserve precision our algorithm maintains existing happens before relations such as those between and and and .
.
trace processing figure shows a simple trace obtained by running the code in figure that illustrates cookie based races.
we start processing the lines where the xhr is opened and send to the remote server we mark the xhr callback as an active callback which can be executed asynchronously any time in the future.
as we process the rst xhr callback on lines we will record the write value made to cookie variable into the memory map where we store values for each variable id i.e.
for cookie .
while recording the written value we will look for values of the variable that are written by any callbacks that may be racing with each other and complain about a race if there is any.
as we continue processing the trace we will record the value written on lines by rst checking the earlier values of document cookie .
as this sequential code segment can race with the earlier xhr callback there is no happens before edge our processing will record a race on document cookie while adding a new value for the cookie into the memory map.
as we continue to process the trace a new xhr is opened and send to the server on lines and added to the active callbacks list.
later the callback for the second xhr will be processed when a write to the cookie is performed on lines .
while processing the write operation the values for document cookie will be checked and a race will be recorded as two xhr callbacks are marked as racing resulting in different cookie values.
.
algorithm summary here we provide the underlying intuition for our approach with a more formal treatment relegated to section .
the key idea behind our approach is to consider alternative scenarios within a given trace.
we do not attempt to force exploration 16of ui interactions for example however we do explore the possibilities of di erent schedules that may occur because of the order of arrival of asynchronous handlers that are part of the trace.
our approach e ectively performs static analysis on a trace that is collected at runtime as a way to consider different schedule orders.
when considering multiple execution of xhr callbacks as shown in figure the key observation is that instead of separately considering each of the possible schedules we can encode the e ect of the possible race by merging the state and keeping track of multiple merged values.
this is analogous to meets in static data ow or abstract interpretation style analysis as an alternative to a costly meet over all paths mop solution.
conceptually given a merge point for variable xwith multiple values coming in for two racing xhrs x v1andx v2 we keep track of both values fv1 v2g not of course that if v1 v2 no need to keep two copies of the same values exists.
xhr x y z v1xhr z v2 z v1 v2 figure merging two states after an xhr.we formulate our race detection algorithm as a data ow analysis on the values within a given execution trace.
we ag a possible race if multiple values may ow to a sensitive location indicating a presence of scheduling dependencies these sensitive locations are persistent storage such as cookies localstorage sessionstorage and lastly the dom etc.
these latter locations serve as the sinks of our data ow analysis.
returning to the example in figure we can represent the race between handlers and as an assignment document cookie f var1 var1 g as a merge node after handler .
this of course represents a direct ow of multiple values to a sensitive persistent storage location document cookie .
more interesting cases involve multiple steps of propagation.
.
implementation to collect execution traces we have instrumented the most recent version of the firefox web browser.
our changes span both the spidermonkey javascript engine to track data propagation through the memory of the browser as well as operations on cookies localstorage and the like which are recorded by instrumenting the dom.
our instrumentation spans over three main components of firefox xpcom cross platform component object model in order to record the triggered xhr callbacks we instrumented the event queue in firefox in nsthread cpp.
when events are taken from the queue for execution we mark xhr readystatechanged events as well as button clicks initiated by the user.
gecko layout engine we also need to instrument dom api implementation of firefox for recording updates made to dom elements of interest.
we achieved this by modifying various dom class implementations likensglobalwindow cpp domstorage cpp etc.
spidermonkey javascript interpreter lastly we instrumented the javascript interpreter for recordingvalue manipulation on variables and objects and also to mark the start and end points of xhr callback execution.
the former is achieved by instrumenting the javascript bytecode interpreter on interpreter cppandjsapi cpp.
overall our instrumentation is quite sparse and we believe can be easily migrated to another open source browser such as chromium.
we have added a total of about lines of instrumentation code to firefox to collect our traces.
a total of les were modi ed.
deployment strategies the process of race detection is something that can be performed both online3 as the application is running as well as o ine as an auditing step.
we envision that as part of beta testing traces from multiple users can be analyzed.
note that as we will highlight in section even relatively simple looking sites can create long traces with a large number of events.
at the same time the number of events relevant to asynchrony and scheduling is relatively small.
our analysis for nding potential races is implemented as a linear pass over the trace.
however if desired this is something that can be parallelized as well by splitting longer traces to be analyzed on di erent machines.
.
formalization since javascript execution is single threaded the execution of event handlers and xhr callbacks is carried out nonpreemptively without interruption.
we nd it convenient to represent the executions of event handlers xhr callbacks and portions of script code executed without pre emption sequential blocks as execution blocks with unique ids.
other entries in an execution trace will also be assigned unique ids as detailed later4.
there is no universally accepted de nition of the happens before relation for web based javascript code.
we de ne the happens before relation denoted not at the level of low level memory accesses but at the level of higherlevel language constructs based on causality information we abstract from javascript operational semantics as was illustrated in figure .
within each uninterrupted execution block trace entries are ordered by the program and therefore happens before order.
we de ne and record a happensbefore order between blocks such that if id id0then all trace entries in idhappen before those in id0.
we order id id0ifid0appears later in the trace and one of the following hold .
both blocks are sequential blocks.
sequential blocks are ordered by in the order they appear in the trace because of the browser imposed ordering.
.
both blocks are event handling blocks.
event handling blocks are ordered by by how they occur in the trace to re ect the order of user interactions.
.id0is an xhr callback and its xhr send is within block id this is because the xhr callback can only happen after the send operation.
3according to the data in figure our analysis is fast enough to be run online so the beta testers only need to use a di erently compiled version of the browser or perhaps a browser with a ag that they turn on.
the results of such exploration can be centrally collected and communicated to the site developers.
4note that these ids are not to be confused with the staticallyassigned numbers in figure as for instance the point in an execution where an xhr callback is registered and the point where it is executed are di erent.
.
modeling and analysis of traces the set of memory locations simply referred to as locations from here on manipulated by a javascript program is denoted by locs and the set of values they can take by val.
to denote the values of locations that have not yet been assigned a value we use the symbol ?val.
we treat each eld of each object as a unique separate ordinary location for race detection purposes.
client side persisted locations are of type key value store and are treated specially.
these aredocument cookie sessionstorage and localstorage .
the set of these locations is denoted by kv.
to treat read and write accesses in the trace uniformly we consider each kv ky pair to be a memory location i.e.
an element in locs and use?valto represent the value for keys not in the store.
accesses to distinct keys in a given kv2kv similarly to accesses to di erent memory locations do not race with each other the set of locations that represent dom elements and are written to using the setter for the innerhtml property of a dom element is denoted by domelts locs.
the value of each location vat each point in the execution is represented by a memory map v.v v consists of set of pairs of the form vl id wherevl2valand id2ids.
intuitively vl id 2v v means that in this trace or a reordering of it preserving the happens before relation vmay have the value vlwhich has been written to it within the block id.
when a trace entry with id idis a write access to v all entries in the memory map v v by trace entries with idid0that happen before idare removed.
other entries in v v are there due to concurrent execution blocks and are therefore not removed.
.
de ning traces formally a trace is a nite sequence of trace entries h niof the following types xhr event handling and sequential blocks trace entries cbbegin id and cbend id denote the beginning and end of the execution of the callback for the xhr with id id.
handlerbegin id and handlerend id do the same for event handler blocks and seqbegin id and seqend id for sequential blocks.
key location innerhtml accesses keywr kv ky vl varsrd id denotes the writing of the value vlfor the key kyin the key value store kvwithin the block with id id.
the value vlhas been computed immediately prior to the write trace entry as the result of an expression over the memory locations varsrd .
keyrm kv ky id denotes the removal of the value the key kyfrom kvwithin block id.
varwrite v vl id denotes the writing of the valuevlto the location vwithin block id.
finally sethtml helt hval id denotes the setting of the innerhtml property of a dom element helt to value hval within block id.
post xhr send post url id idin vl varsrd is a post request xhr call or window with id idand the call occurs within an execution block with id idin.
the data postedvlis the computed result of an expression over the memory locations varsrd .
xhrsend id idin denotes an xhr send operation for the xhr object with id id that takes place within an execution block with id idin.
this send is agetrequest.evt handler begin handlerbegin id hb0 transclose hb f idevt id g v hb p idseq idevt !
v hb0 p idseq idevt evt handler end handlerend id id0 evt id v hb p idseq idevt !
v hb p idseq id0 evt seq blk begin seqbegin id hb0 transclose hb f idseq id g v hb p idseq idevt !
v hb0 p idseq idevt seq blk end seqend id id0 seq id v hb p idseq idevt !
v hb p id0 seq idevt xhr post post url id idin vl varsrd p0 p f v id jv2varsrdg hb0 hb f idin id g v hb p idseq idevt !
v hb0 p0 idseq idevt xhr send xhrsend id idin hb0 transclose hb f idin id g v hb p idseq idevt !
v hb0 p idseq idevt key write keywr kv ky vl varsrd id v0 v kv ky v kv ky v hb p idseq idevt !
v0 hb p idseq idevt write varwrite v vl id v0 v v hb p idseq idevt !
v0 hb p idseq idevt set dom sethtml helt hval id v0 v helt v helt v hb p idseq idevt !
v0 hb p idseq idevt xhr post post url id idin vl varsrd p0 p f v id jv2varsrdg hb0 hb f idin id g v hb p idseq idevt !
v hb0 p0 idseq idevt xhr send xhrsend id idin hb0 transclose hb f idin id g v hb p idseq idevt !
v hb0 p idseq idevt figure trace analysis rules.
.
interpreting traces given a trace trace h ni our race detection algorithm analyzes it by processing it sequentially one log entry at a time.
the algorithm maintains analysis state represented by the tuple v hb p idseq idevt .
here vis the memory map.
hbis the happens before relation which is a partial order over ids.
whenever new elements are added to hbby a trace processing rule the transitive closure of the relation is taken to obtain the resultant hb.
hbis initially the empty relation.
pis a list of pairs of the form v id where the location vhas been read while computing the value submitted by a xhr post request with id id.
finally idseq and idevtare the ids of the last sequential block processed or the last event handling block processed by our algorithm respectively or ?if no such callback or block exists.
given a state v hb p idseq idevt reached at a point in the trace the analysis state reached after processing the log entry is described by the rules given in figure and explained below.
16xhr persistent state writes session state writes dom writes web site xhr open xhr send xhr callbacks nested xhr count cookie nested cookie nested xhr posts localstorage nested localstorage sessionstorage nested session storage setinnerhtml nested set innerhtml input element nested input edition.cnn.com mlb.mlb.com news.qq.com wireless.att.com figure characteristics of our benchmarks web sites.
callbacks cb begin andcb end not shown keep track of the id of the ongoing xhr callback block.
seq blkbegin processes the log entry indicating the beginning of a sequential block with id idby setting idseqtoid.seqblk end resets idseqto?.
the rules ensure that the occurrence order of sequential blocks in the trace and their happens before order coincide.
evt handler begin and evt handler end operate similarly to the corresponding seq blk rules.
the order of occurrence in the trace of the event handlers is the same as their happens before order.
event handlers and sequential blocks are not ordered with respect to each other by the happens before relation.
location updates key write handles the case where key kyin the key value map kvis updated.
we declare a potentially harmful race if jval v j any location v read while the new value for the key is being computed v2varsrd indicating the potential for non determinism.
the rule computes v0 kv ky by fromv kv ky by adding the pair vl id .
removing all pairs vl0 id0 such that id0 id.key remove not shown writes the value ?valto the keyky.write andset dom are similar to key write above updatingvfor a location vor a dom element helt by removing value id pairs overwritten as dictated by the happens before relation and adding the new value id pair written by the current trace entry.
post send the rule xhr post declares a potentially harmful race ifjv v j for any location v2varsrd since at least one location used in the computation of vl the data posted has the potential for non determinism.
xhr send updates the happens before relation.
xhrsend id idin indicates that the send for the xhr with id idhas taken place in block idin.idin id.
this rule and the fact that cb begin andcb end do not modify the happens before relation en code the fact that only chained xhr calls are ordered by with respect to each other5.
.
detecting races we sayv v has non determinism potential on a location v when the memory map contains at least two di erent values forv i.e.
when there are pairs vl id and vl0 id0 inv0 v such thatvl6 vl0and id6 id0.
our algorithm declares a race on a location vwhile evaluating the write set dom andkey write rules if the memory map v0 v computed by the rule has non determinism potential on v. we also declare a race when evaluating the xhr post andkeywrite rules if a variable read when computing the value posted or written v2varsrd v v has non determinism potential for v. of these races only the ones associated with key write andxhr post rules are deemed to be harmful races.
consider a pre x of the trace in a quiet state such that at the end of the pre x no xhr callback or execution block is in progress.
suppose that our algorithm has signaled nondeterminism potential on a location vwhile processing a trace entry within the last block or callback with id idin this pre x. then a di erent re ordering of the the execution blocks and or xhr callbacks while leaving the happensbefore relation in the pre x intact may result in a di erent nal value for v as explained next.
5note that it is possible to de ne the happens before relationship di erently for instance declaring xhrito happen before xhrjif the send entry for xhrjappears later in the trace than the end of the callback for xhri.
while such a de nition may capture the happens before relationship observed in a particular schedule more precisely our de nition narrows in on ordering relationships enforced by the javascript semantics and excludes those that may have taken place di erently in di erent executions of the same program driven by the same user interaction.
16website trace size mb compressed trace size mb browsing time sec analysis time sec .
.
.
.
news.qq.com .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mlb.mlb.com .
.
wireless.att.com .
.
.
.
.
.
.
.
.
.
edition.cnn.com .
.
.
.
.
.
.
.
.
.
.
.
figure trace statistics and processing times.
let vl id and vl0 id0 be in val v such that id06 id andvl6 vl0.
it must be the case that while both id0and id wrote tov these two execution blocks are not ordered by the happens before relationship.
otherwise either vl id or vl0 id0 would have been removed from val v according to the update rules of our algorithm and how they use the happens before relation in variable updates.
therefore it is possible to modify the execution by delaying the execution of the block with id id0until after the execution of the block with id id.
in this case the nal value of the locationvor kv ky would be di erent at the nal state of the newly obtained execution.
this points to a potentially di erent result produced purely as a result of xhr callback scheduling non determinism.
there are two sources of false positives in our race detection approach.
the rst source is the assumption made in the argument in the previous paragraph while obtaining a new execution by delaying the execution of the block with id id0 past other blocks.
the assumption is that control decisions made in the original execution based on data values written by the block idarenot modi ed in a way that makes the reordered execution infeasible.
in our empirical experience such cases are rare and can be ruled out by inspection or replaying and validating the reordered execution.
the second source is the check performed when a value is written to a persisted location or sent on the network.
in these cases if while computing the written or sent value a location with non determinism is read our algorithm signals a potentially harmful race.
this approach is conservative i.e.
non determinism in the value of one of the locations in an expression may not result in non determinism in the value of the result.
even in cases where this is the cause of a false alarm we believe that the potentially di erent data values owing to a persisted output location may be of concern to programmers.web site document cookie localstorage sessionstorage xhr post innerhtml input element memory xhr get postmessage edition.cnn.com mlb.mlb.com news.qq.com wireless.att.com totals figure races found by our analysis.
.
evaluation this section describes the experimental evaluation we have performed on a set of complex pages.
research questions our goal has been to address the research questions listed below.
rq1 how common are races on persistent state such as document cookie localstorage and side e ects such as post requests?
we consider these to be the most harmful races there are in web applications.
rq2 how common are races on sessionstate ?
session state is cleared on browser restarts.
however given that the browser is often not restarted for days if not weeks data in sessionstate can persist for long periods of time if not permanently.
rq3 how common are races on transient state such as memory locations and dom elements?
these are generally not the kind of errors that we deem to be highly problematic and moreover often these are not even observable by the user .
.
experimental setup for our experiments we have selected a set of sites from alexa s top list.
to nd suitable sites we used an instrumented browser to crawl all sites focusing on sites that have a large number of outstanding xhrs.
site statistics figure summarizes various aspects of the sites we picked.
we speci cally separate the number of operations within xhr callbacks as these can lead to races.
columns show the number of observed xhr open and send operations executed xhr onreadystatechange callbacks and the number of callbacks within other callbacks so called nested xhrs .
columns focus on the use of persistent storage.
columns show the number of writes todocument cookie as well as writes nested in an xhr callback.
column shows the number of xhr post operations in an xhr callback.
columns give the num7 16ber of writes to localstorage both in general and within xhr callbacks.
columns give the same information forsessionstorage .
lastly columns give information about various forms of dom manipulation such as setting innerhtml and changing the contents of input elements both totals and nested variants of these counts are provided.
trace statistics the workload used to collect these counts was simply loading the page and applying basic user interactions like button link clicks.
the counts for dom manipulation are generally higher than those for cookies localstorage or sessionstorage .
it is natural to expect more races on dom elements as well compared to more uncommonly used persistent elements.
figure summarizes information about the traces we used for our analysis.
the compression ratios range between .
and .
.
the percentage of time it takes to analyze a trace compared to the time to record a trace ranges between and .
detection time figure shows the trace collection6and analysis time as a function of trace size.
analysis time grows approximately linearly with the size of the trace and is a fraction of the trace recording time shown in the second column.
since trace analysis can be parallelized or run on an unused core we can envision this analysis being run in parallel with execution.
among other advantages this would obviate the need for trace storage and transfer.
.
detection results in this section we describe and analyze several representative races found with our approach.
example in the case of the race on sessionstorage was caused by a shared variable namespace that is used for generating the key name.
the variable is written at two di erent locations one being an xhr callback that is executed using jquery ajax method.
the execution steps are listed below and the relevant code is shown in figure .
as a page loads an xhr is created using the jquery ajax method included in js?v and sent to the server lines .
once the response is received a user de ned callback is executed using jquery ajax done lines .namespace variable is set to empty string at the end of jquery ajax done method line .
an external library is initialized by setting the namespace variable to uv line .namespace variable is subsequently used for generating a sessionstorage key lines .
in the last step the value of namespace is used for setting an item on the sessionstorage for recording user interactions with the web page.
in this particular trace we observe that multiple items are added to the sessionstorage using thenamespace as a pre x i.e.
uvautoprompt disabled uvr .
any future read operations on the sessionstorage keys will depend on this pre x namespace .
as the xhr callback can race with the namespace writes which sets the value for namespace to the empty string it may result in a failed read operation.
example another raceinducing execution trace is obtained from 6sample traces can be found at pastebin.com mxf7enpx pastebin.com jesy4fy8 and pastebin.com 1pusgugb .
script function milgraphwithstatsv2 ... jquery .
ajax method url www.
milliyet .com.tr d j base .js?v function data process data ... script ...a lot of text and images here ... script jquery .
extend ajax function url options ... var xhr new xmlhttprequest xhr .
open method url xhr .
onreadystatechange done xhr .
send null ... function done ... www.
milliyet .
com .tr d j base .js?v namespace write to sessionstate script ... script widget .
uservoice .com ue6mda0sqpbmbkaehfauig .js r. prototype .
get function t if this .
storage var e this .
storage .
getitem this .
makekey t return e r. prototype .
set function t e this .
storage this .
storage .
setitem this .
makekey t json .
stringify e r. prototype .
remove function t this .
storage this .
storage .
removeitem this .
makekey t r. prototype .
makekey function t return r. namespace t r. namespace uv write to sessionstate script figure sessionstorage manipulation in milliyet com tr.
to save space we remove unrelated lines of code.
com.tr where two xhr callbacks race with each other when it comes to writing to innerhtml property of a div block in the dom.
in this news web site users can lter displayed news according to their preferred categories by using category links on the page.
each click action on a category link will generate an xhr call to server to gather news for the corresponding category.
the race is captured within the execution steps listed below the corresponding code is shown in figure .
user clicks on a category link lines for enabling a category on the web page triggering the addcategory method lines .addcategory method will than trigger getarticle method line .getarticle method lines makes an xhr call using jquery load for div with id r5content upd line .
user clicks another category link lines triggering another xhr call .
both xhr calls sets innerhtml of the same div on the dom line .
html index .
html a id a hayat class category href javascript addcategory hayat hayat a a id a spor class category href javascript addcategory spor spor a div id r5 content upd div script function addcategory categoryname mynewcategoriesvalue categoryname getarticle mynewcategoriesvalue function getarticle categoryvalue var c url c srcdomain categoryvalue r5 content upd .
load c url cbfunction script html figure race on innerhtml manipulation in radikal com tr.
to save space we remove unrelated lines of code.
at the end of this execution the displayed dom will depend on the order of the responses returned from the server as the div id r5 content upd is directly a ected by the asynchronous xhr callback.
script rum dytrc .
gazzetta .it ajax dtagent60 bjnprs3t 7082 .js function sb a b var d d d ?
dtcookie x3d encodeuricomponent v ua encodeuricomponent document .
location .
href fb cb d c e e q load function fb m b. path n b. data function fb a b c d var h h. onreadystatechange function a. readystate a. status ?
e a. responsetext db b.sf eb.
push path b data c a m h. open post b c h. send d function e a a a a. split for var b b a. length b var c a .
indexof dtcookie x3d if c y dtcookie decodeuricomponent a .
substr c break function y a b document .
cookie a x3d b path x3d w. domain script figure race on document cookie manipulation in gazetta it.
to save space we remove unrelated lines of code.
example in this example of a document cookie race from the web site uses an application monitoring library dynatrace real user monitoring found at dynatrace.com for recording and posting user actions and browsing experience to a remote server.
each post request initiated by this library updates the key dtcookie of the document cookie with the1 xhr send ... read id document jsobject write prop id cookie jsstring cookie write fsr .s 7b v2 d ... read id document jsobject write prop id cookie jsstring cookie write fsr .s 7b v2 c 7d ... xhr callback begin xhr callback ... read id document jsobject read prop id cookie jsinteger fsr.s b v2 c 7d ... read id document jsobject write prop id cookie jsstring cookie write fsr .s 7b v2 c a1 7d end xhr callback figure trace from optimum netillustrating a false positive.
response value from the server.
a race occurs when multiple xhr calls try to write the new response value to document cookie .
the execution steps are listed below with line