diversity based web test generation matteo biagiola fondazione bruno kessler trento italy biagiola fbk.euandrea stocco universit della svizzera italiana lugano switzerland andrea.stocco usi.ch filippo ricca universit degli studi di genova genoa italy filippo.ricca unige.itpaolo tonella universit della svizzera italiana lugano switzerland paolo.tonella usi.ch abstract existing web test generators derive test paths from a navigational model of the web application completed with either manually or randomly generated input values.
however manual test data selection is costly while random generation often results in infeasible input sequences which are rejected by the application under test.
random and search based generation can achieve the desired level of model coverage only after a large number of test execution attempts each slowed down by the need to interact with the browser during test execution.
in this work we present a novel web test generation algorithm that pre selects the most promising candidate test cases based on their diversity from previously generated tests.
as such only the test cases that explore diverse behaviours of the application are considered for in browser execution.
we have implemented our approach in a tool called dig.
our empirical evaluation on six real world web applications shows that dig achieves higher coverage and fault detection rates significantly earlier than crawling based and search based web test generators.
ccs concepts software and its engineering software testing and debugging .
keywords web testing test generation diversity page object acm reference format matteo biagiola andrea stocco filippo ricca and paolo tonella.
.
diversity based web test generation.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
introduction modern web applications available nowadays provide the same high level of user interaction as native desktop applications while eliminating the need for in site deployment installation and update.
for instance single page web applications spa achieve high responsiveness and user friendliness by dynamically updating the document object model dom of a single web page by means of javascript functions that react asynchronously to user events.
to test such complex software systems engineers typically adopt test automation frameworks such as selenium .
in this context the tester verifies the correct functioning of the application under test aut using test scripts that automate the set of manual operations that the end user would perform on the web application s graphical user interface gui such as delivering events with clicks or filling in forms .
testers implement business focused test scenarios within such test scripts along with the necessary input data.
each test case hence exercises a specific test path along the navigational graph of the web application.
despite the research advancements in automated test generation only a few tools have been proposed in the web domain whose applicability to the complex systems available nowadays is still unfortunately quite limited.
consequently to date the development of system level test cases such as selenium s is still performed mostly manually .
generating web test cases automatically is indeed quite challenging because specific sequences of events and associated input data must be generated so as to ensure an adequate level of coverage.
existing approaches rely on crawling to obtain a navigational model of the aut in the form of a graph of the dynamic web pages and the event based interactions between them.
then test paths also called abstract test cases are derived from the model in order to ensure full coverage of the navigational graph using e.g.
breadthfirst visit or semantically interacting events .
to generate executable tests test paths require specifying proper input data which can be produced either manually or by random generation.
however these approaches have several drawbacks that limit their applicability in practice.
first random input generation makes existing approaches quite ineffective because they may either exercise the same portion of the aut repeatedly without exploring new behaviours that are likely to expose previously unknown faults or produce infeasible tests which violate constraints and preconditions of the aut.
the drawback is that a huge number of random test cases needs to be generated before covering the navigationalesec fse august tallinn estonia m. biagiola et al.
figure simplified navigational model of petclinic web application.
transitions between states are labelled with the corresponding actions which can be parameterized.
the path in bold represents an instance of coverage maximizing test path which are those our diversity based technique aims to generate.
graph adequately which is highly inefficient.
additionally web tests are characterized by slow execution times due to the interaction with the browser which further hinders the applicability of existing test generation techniques when strict timing constraints apply.
as such the mentioned techniques resort mostly to manual input generation which is however costly and limited by the testing resources e.g.
time available to testers.
to overcome these limitations in this paper we propose a novel solution for generating system level web test cases.
the goal of our approach is to generate a set of test cases that diversify the coverage of the navigational graph and the use of input data in order to escape infeasible scenarios that are not executable in practice or that do not produce any coverage improvement.
the key insight of our approach consists in assessing the quality of newly generated test cases without executing them just by evaluating their diversity with respect to previously executed candidates.
diversity based test generation allows escaping local optimum regions of the input space where similar test cases might all cover the same code and navigations and only the most diverse candidates are selected for in browser execution.
we implemented our approach in a tool named dig diversitybased generator which automatically extracts a navigational model of the web application through crawling and creates a code based abstraction of the possible actions executable in each web page following the page object design pattern .
then candidate test cases i.e.
possible paths and inputs are generated using a diversitybased heuristics so as to cover the model adequately and efficiently.
our work makes the following main contributions a novel diversity based system level test case generator for web applications.
an algorithm for identifying coverage and input maximizing candidate test cases.
our algorithm uses a novel diversityaware distance metric between test cases so as to minimize the need for in browser executions.
an implementation of our approach in a tool called dig which automatically extracts a navigational model composed of page object abstractions and generates test cases maximizing both navigation sequence and input data diversity .
an empirical evaluation of dig in generating test suites for six open source web applications.
dig generated test suites having higher coverage and fault detection rates significantly faster than crawling based and search based test generators.
background we present the web testing concepts that are needed to understand the remainder of the paper.
we provide background information on the navigational model of a web application its characteristics and properties and we explain how it can be used to enable automated test case generation.
.
navigational model the navigational model of a web application can be represented as a state flow graph sfg where nodes are the dynamic dom states of the web pages and the edges the event based transitions between them .
definition state flow graph .a state flow graph sfg for a web application wis a labeled directed graph denoted by a tuple r v e g where r is the root node called index representing the initial dom state whenwhas been fully loaded into the browser.
vis a set of vertices representing the nodes.
each v v represents an abstract dom state of w. eis a set of directed edges between vertices which we call actions.
each v1 v2 a erepresents a possible transition between two nodes v1 v2if and only if node v2is reached by executing the action ain nodev1and the guard is satisfied.
gis a set of guards on edges v1 v2 a e. sfg can have multi edges and be cyclic.
.
example of navigational model figure shows a simplified navigational model of petclinic a web app allowing veterinarians to manage information about their clients and their pets which is among the experimental subjects used in our evaluation.
the graph consists of eight abstract dom states each having several possible actions that can trigger transitions between them.
next we define the notion of feasibility and its impact on automated test case generation on our running example.
.
feasibility given an abstract dom state n the set of possible actions emay be constrained by one or more guards a.k.a.
preconditions .diversity based web test generation esec fse august tallinn estonia definition guard .a guard s a i is a boolean condition over the possible input values i iof an action ain a specific application state s. the guard needs to be satisfied in order to enable the transition between state nand the target state of the action a typically another state n ornitself .
the application state sincludes the global variable values the dom and any persistent data that remain available across user interactions.
hence satisfiability of a guard depends on the input values i igenerated for the given action a as well as the internal business logic state sof the application produced by previous user interaction sequences.
for instance in the owners state of figure an action displayowner allows to navigate towards the ownerinfo state.
a simple guard over this action imposes that the owner identified by the input ownername must be present in the application prior to executing the action.
for readability we omitted the guards in the figure.
as such the guard depends not only on the specific value assigned to the input ownername of the displayowner action but also on the internal business logic state of the application.
in fact the owner to display must have been previously inserted into the application by a dedicated action e.g.
by executing the addaction in the addowner state .
to recap for a given action a if the input values do satisfy the guards ofain the given application state s then we say that this transition is feasible it is infeasible otherwise.
.
test generation problem given a navigational model of a web application the goal of a web test generator is to automatically extract sequences of actions and generate suitable inputs in order to exercise the application behaviours thoroughly potentially covering all transitions in the navigational model.
definition test path .a test path is a sequence of test states paired with a corresponding sequence of actions with unspecified input values.
then a test case can be defined by instantiating concrete input values within a test path.
definition test case .a test case is a sequence of concrete values for a corresponding sequence of actions in a specific test path.
for example in petclinic a simple test path that enables the addition of a new visit for a pet consists of the test state sequence index find addowner owners ownerinfo newvisit .
the corresponding action sequence is given by gotofind addnewowner add displayowner addnewvisit .
in this sequence of actions three input values need to be specified info the data of the owner to insert required by action add of state addowner ownername the name of the owner required by action displayowner of state owners and pet the data of the pet to be visited required by action addnewvisit of state ownerinfo .
the action addnewvisit is guarded by a precondition that states that the pet identified by petmust exist before the execution of the action.
since in the considered test path no pet is added by any action before executing addnewvisit the chosen test path cannot be taken for any possible values of input pet.
therefore we say that such path is infeasible .definition test path feasibility .a test path is feasible if there exists an input parameter value assignment that satisfies all the guards related to the actions in the test path it is infeasible otherwise.
.
existing test generation approaches different strategies can be adopted to generate tests cases from a navigational model.
in this section we briefly discuss the most notable existing solutions as well as their limitations which motivate the need for a novel and more efficient approach.
in section we will then describe our novel diversity based test generator.
.
.
graph visit approaches.
breadth first and depth first graph visit algorithms have been applied to the navigational model of a web application to derive test paths also called abstract test cases i.e.
sequences of states and actions lacking concrete input data to become executable .
in the tool atusa random input data generation has been proposed to fill the gap between test paths and concrete test cases.
however randomly generated inputs have often low chance of producing feasible test cases hence they typically require a huge number of input generations and corresponding test executions.
moreover atusa generates big test suites even for simple web applications because it relies on a state abstraction function that creates a large number of test states and correspondingly a large number of test paths.
.
.
semantic based approaches.
alternatively test paths can be restricted to those exercising semantically relevant interactions i.e.
event sequences in which the ordering of events affects the state reached at the end of the interactions .
such approach has been successfully applied to web applications but yet it produces a set of abstract test cases semantically interacting event sequences that require manual specification of input data to make them executable.
.
.
search based approaches.
search based techniques iteratively sample the input space selecting the fittest candidate test cases and evolving the fittest ones using genetic search operators to create new test cases .
since these algorithms can effectively guide the generation of test cases even for large input spaces they are suited for system level testing .
concerning the web domain an effective fitness function can be defined based on approximate information available in the navigational model specifically the actions guards.
researchers have shown that this approach can guide the search toward generating test cases unaffected by the path infeasibility problem .
however this approach needs the manual specification of all guards for each action a task that is time consuming and laborious for testers.
indeed such information depends on the web application business logic and intended behaviour and thus cannot be generated fully automatically.
additionally the evaluation of the fitness function is costly because it requires a large number of candidates to be generated and executed in the browser before converging to an adequate set of tests.
.
.
summary.
while all discussed approaches provide theoretical warranties of asymptotic convergence to the desired input values they exhibit poor execution time performance when applied to web applications as compared for instance to standardesec fse august tallinn estonia m. biagiola et al.
web appownerinfoeditownereditowneraddpetaddnewpet newvisitaddnewvisit pet findgotofind indexgotohomesubmiteditgotofindgotohomesubmitaddgotofindgotohomesubmitvisitgotofindgotohomeaddowneraddnewownergotohomeownersfindownergotofindgotohomeadd info findownergotofinddisplayowner ownername gotofind gotohomesearchnavigational model page objectsdiversity based test generation testing model extraction test suite figure system level web test generation approach java desktop applications .
the reason why both random and search based approaches are computationally expensive is that they always need to execute the candidate test cases to assess their feasibility and in the latter case the value of the fitness function.
this disadvantage is amplified in web testing because the overhead imposed by browser s interaction makes evaluating these tests very slow and the input space may contain local optimum regions in which all candidate test cases are likely to be behaviourally equivalent e.g.
all equally infeasible hence increasing the run time of the test generation algorithm without benefiting the overall coverage .
the limitations discussed in this section test suite s size high computational cost need for manual guard specification justify the investigation of alternative possibly cheaper and more automated algorithms.
diversity based web test generation in a nutshell our goal is to efficiently generate system level web test cases that exercise the application behaviours adequately.
figure depicts the main steps of our approach which is based on the inference of testing model as follows.
first a navigational model of the dynamic web pages is extracted .
second each web page is modelled in form of page objects object oriented classes that expose the actions executable in each web page as methods.
finally our test generator uses a novel metric distance between test actions and input data to generate a test suite that exercises the web application thoroughly .
our approach does not require specifying the guards of the actions in the navigational model.
we now detail each step of our approach as well as the computation of the distance between tests which is exemplified on our running example.
.
testing model extraction in the first step we obtain a navigational model of the web application.
this can be performed manually by testers through manual exploration of the web app functionalities or automatically.
our approach adopts this latter option we use a web crawler to automatically explore the state space of the web application see section .
for more details .
the output of this phase is a navigational model of the application in which nodes are the dynamic dom states and edges are the event based transitions between them.
the navigational model retrieved by the crawler is used to generate an intermediate code based abstraction that can conveniently support our diversity based automated test case generation.
we usepage objects hereafter referred to as pos as a concrete representation for the dom states in the navigational model and their actions.
following the guidelines provided by this design pattern each dynamic dom state is represented as an object oriented class whose main functionalities are exposed to testers as po methods.
in our running example petclinic for instance the addowner state would be represented by its own class containing three methods add gotoindex and gotofind .
the motivation for the choice of pos as our state representation is twofold page objects are a well known and utilized pattern in web test automation to enhance the development and maintainability of test cases and they can be created automatically from a given navigational model with a good degree of accuracy .
.
diversity based path and input generation inspired by adaptive random testing which makes the assumption of contiguous failure regions we conjecture that web applications might also have contiguous infeasibility regions .
correspondingly in the case of web apps the main advantage of test case diversity would be the possibility of exploring the search space at large diversifying the region where navigation sequences are sampled.
this is expected to help escaping local solutions as well as avoiding generating infeasible test paths and ensuring a more effective exploration of alternative i.e.
diverse behaviours.
indeed research has shown that diversity is especially beneficial to fault detection.
diverse inputs are necessary to expose different failures whereas inputs from contiguous areas of the input space are likely to expose the same program failure .
asecond advantage of diversity based test case generation is its higher efficiency with respect to existing random and search based approaches.
in fact the quality of a candidate test case is evaluated by measuring its diversity with respect to previously generated test cases and using such metric to assess its potential at increasing the exploration of diverse behaviours.
interestingly such assessment can be performed without actually executing the candidate test cases as described in section .
.
algorithm describes our overall procedure for diversity based path and input generation.
the test generation starts from an empty set of tests and therefore the first generated test is random.
the algorithm generates a set cofcandidate test cases instantiating candidate test paths along with concrete input vectors lines .
to select the most promising candidates the distance between each candidate test case and the current set of already executed test cases texec is computed lines and only the farthest test case t is executed line .
test case tis restricted to its feasible prefix in case it includes a divergence line .
a divergence occurs whenever the test path of a test case tdiffers from the execution trace obtained by running t. then the test case is added to the final test suite ts enonly if it contributes to increase coverage of the navigational model m lines .
algorithm shows how candidate test paths are created.
in our notation vrepresents a state sequence aindicates a method sequence having xas a input vector sequence.
v aandxare incrementally created within the main loop lines by choosing an edge v v arandomly with uniform probability among those available from state vaccording to the navigational model m.diversity based web test generation esec fse august tallinn estonia algorithm diversity based test case generation input m navigational model k number of candidates output t s en test suite that optimizes coverage of m 1texec set of executed test cases 2t s en set of generated test suite 3generate randomly a test case t addttotexec and execute it whilemis not adequately covered by t s enor timeout is not reached do m getrandomuncoveredmethod m dmax c set of candidate test cases for i tokdo c c generatecandidatetest m m see algo end for ci cdo di min ci tj tj texec see eq if di dmax then dmax di t ci end end addttotexec and execute it if tis divergent then t getfeasibleprefix t end if tincreases coverage of mw.r.t.t s enthen t s en t s en t end end return t s en algorithm candidate test case generation input m navigational model m target method output v a x candidate test case reaching m 1a 2x 3v getrootnode m 4v v while m ado v v a getrandomedge m v m must ensurev m 7v v x getrandominputvector a 9v v .add v 10a a .add a 11x x .add x end return v a x the selection is constrained by the fact that the target method m must remain reachable from v .
at last a vector of input values as parameters to ais randomly chosen line .
.
distance between test cases algorithm requires a distance metric to assess the diversity between test cases.
differently from object oriented or numerical applications testing in our setting we cannot rely only on the input values as the distance function must also take into account the sequence of actions composing a test case.
as such we devised a novel distance metric between two test cases taking into account the diversity of the respective sequences of actions and in cases in which this is not discriminative privileging the test case having the farthermost diversity in terms of concrete input values.
by diversifying the sequence of actions as well as the associated input values we conjecture that we can escape infeasible test path regions and we can diversify the app behaviours.
.
.
distance formula.
intuitively our distance formula comprises two terms the first measuring the distance between theaction sequences in the two test cases being compared and the second measuring the distance between the input values used by matching actions in the two sequences.
to compute the first term the distance function reports the number of non matching actions in the two sequences.
to compute the second term we rely on the longest common subsequence to obtain the matching actions upon each matched actions we compute the normalized distance between their parameter values.
given two test cases ti tj where ti vi ai xi andtj vj aj xj the distance ti tj is given by equations ti tj vi ai vj aj k1 k2 lcs i j xi xj x y x k x y in equation the notation vx ayindicates that the two sequences of actions are identified both by their actions ai ajand the states vi vjin which they are applicable.
this helps disambiguate cases in which an action ayis present with the same name in different states.
function represents the sequence edit distance which determines the number of non matching elements in two sequences e.g.
a b e f when comparing a b b c to e b c f .
lcs is the set of matching indexes in the longest common subsequence e.g.
when comparing a b b c to e b c f .
function computes the distance between the two parameter value sequences xi xj of two matching actions indexed by k1andk2respectively in vi aiandvj aj .
at last function computes the normalized distance between two primitive input values of the same type see table .
the second term of equation matches the actions ai aj in the two sequences.
correspondingly the two input vectors xi andxj have the same cardinality.
function computes the average distance between the parameter values xandyof two matching actions.
it resorts to function to compute the normalized distance between pairs of primitive input values x y .
the computation of function varies depending on the type of parameters occurring into the actions see table .
the input distance is normalized between and .
for types string ornumber normalization is achieved using function x x x 1as proposed by arcuri et al.
that maps a value xonto the range .
equation resembles the computation of the fitness function for branch coverage commonly adopted in search based testing .
table input distance computation type input distance w z boolean w z 0ifw z 1otherwise enum w z 0ifw z otherwise string w z w z w z number w z w z w z esec fse august tallinn estonia m. biagiola et al.
in such a case the two terms of the fitness function are approach level and normalized branch distance respectively.
we share with that definition the idea of making the first term action sequence distance dominant while resorting to the second term input value distance only when the first term is not discriminative enough.
in fact the range of isn so the minimum non zero distance is whereas ranges between and such that the contribution to of each matching pair of actions cannot be greater than .
the intuition is that the major contribution to diversity comes from the action sequence distance while the input value distance for each matching action pair contributes at most as the minimum non zero action sequence distance i.e.
.
however in case of a large number of actions being matched the aggregate value of the input value distance might become dominant.
.
example of distance computation we present how the distance between test cases is computed using a simplified notation in which only the actions are reported while omitting the states e.g.
index findowner becomes findowner .
in fact in all our examples the state sequence associated with a given action sequence will be unique this is not true in the general case .
moreover parameter values are indicated in brackets rather than separate input vectors e.g.
an action sequence a findowner and the corresponding input sequence x john doo become findowner john doo .
let us consider three simple test cases t1 t2 t3for the running example petclinic section defined as follows t1 findowner john doo find t2 findowner johnny boo addnewowner add johnny boo t3 findowner john doo find suppose that t1is already in the list of generated test cases t en whereas t2ort3are in the set of generated tests c. our algorithm must decide which test to execute next.
the sequence edit distance between t1andt2is because there are three non matching actions in t1 t2 find int1 and addnewowner addint2 .
concerning the matching actions findowner in both t1andt2 the input distance is computed by function which in turn resorts to function for the distance between primitive values.
in our running example john doo johnny boo john doo johnny boo .
because john doo johnny boo the three non matching characters in johnny boo being n y b .
therefore t1 t2 .
.
.
conversely the sequence edit distance between t1andt3is since there are no unmatched actions in the two sequences.
thus our distance formula relies on the input distance john doo john doo and we use the function that applies to numbers .
therefore t1 t3 .
.
thus themost diverse test case t2is selected and executed.
.
implementation we implemented our approach in a java tool called dig diversitybased generator which is publicly available .
to retrieve the po testing model dig relies to apogen .
finally our diversitybased test generator is implemented on top of evosuite whichwe extended to handle the po model.
our algorithm uses the po method information to generate and evaluate candidate test cases.
at last only the most diverse candidates are executed through selenium webdriver in headless execution mode.
empirical validation .
research questions we address the following research questions rq1 effectiveness how do diversity search and crawlingbased random test generation compare in terms of state coverage code coverage and fault detection?
rq2 efficiency how do diversity and search based test generation compare in terms of efficiency over time?
rq3 distance computation what is the impact of distance computation in the diversity based test generation process?
rq4 manual pos what is the effect of using manually defined pos within the diversity and search based test generation approaches?
rq1and rq 2aim to compare dig with two state of the art solutions a search based web test generator called subweb and atusa which is based on a crawling based random approach.
rq3and rq 4aim at assessing the impact of the internal factors of the proposed approach namely distance computation and pos generation method on the final test suites.
.
subject systems we overviewed the most popular javascript frameworks for developing web applications from github collections .
popularity was measured as the number of stars owned by the framework s github repository at the time of writing august .
we retained five frameworks with more than 15kstars.
second we selected web applications developed with one of the selected frameworks and are popular number of stars mature number of commits and have been maintained recently year of last commit .
third from the resulting candidate set in order to maximize diversity and representativeness we randomly sampled six applications considering the six most popular javascript frameworks dimeshift backbone.js pagekit vue.js splittypie ember.js phoenix trello phoenix react retroboard react petclinic angularjs .
table summarizes the main characteristics of our subjects.
the size of the selected systems 1kclient side javascript locs frameworks excluded is representative of modern web applications ocariza et al.
report an average of locs for a dataset of web applications developed with the angularjs framework with at least stars .
table experimental subjects subject framework loc js stars commits year dimeshift backbone pagekit vue.js splittypie ember.js phoenix react retroboard react petclinic angularjs 2018diversity based web test generation esec fse august tallinn estonia table effectiveness efficiency and distance computation results automated pos for rq rq and rq 3for all subjects and approaches.
values in bold indicate statistically significant differences between dig andsubweb .
stars indicate statistically significant differences between dig s ianddig s. nc indicates non comparable values since the test generation terminates before the given time budget.
effectiveness efficiency distance computation structural coverage faults structural coverage faults tests distance state cov.
branch cov.
avg unique state auc branch auc auc gen. exec.
dig s i dig s subweb dig s i dig s subweb atusa dig s i dig s subweb atusa dig s i dig s subweb dig s i dig s subweb dig s i dig s subweb dig s i dig s subweb dig s i dig s dig s i dig s dimeshift .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
nc nc nc nc nc nc nc pagekit .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k7.9k218 k 628k splittypie .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k11.8k329 k1 398k phoenix .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
nc nc nc nc nc nc nc retroboard .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
nc nc nc nc nc nc nc petclinic .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
nc nc nc nc nc nc nc average .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k15.3k274 k1 000k .
procedure and metrics effectiveness rq .we ran dig subweb andatusa on each subject system.
for dig we set the number of candidate test cases generated at each step of the algorithm to .
as subweb requires we manually specified the guards for the pos methods.
we granted each tool the same time budget of minutes because in our exploratory experiments we empirically observed convergence of state coverage to a plateau within half an hour.
additionally we repeated each experiment times and computed the average across all executions to cope with non deterministic behaviours.
we considered three metrics of effectiveness.
first we measured thestate coverage of the navigational model according to the transition coverage adequacy criterion.
second we measured branch coverage of the javascript code of our subject systems.
we instrumented the client side of each web application libraries and framework excluded with the tool istanbul and executed the generated test suites against the instrumented applications.
third we studied thefault detection capability by counting the number of unique faults i.e.
unique javascript exceptions and errors reported in the javascript console upon test suite execution.
efficiency rq .to assess efficiency we measured how the competing algorithms perform over time in terms of state coverage branch coverage and fault detection.
to this aim we computed the area under the curve auc of each metric as a function of the test generation time with higher values of auc denoting a superior efficiency of the algorithm within the given time budget minutes .
concerning state coverage we computed the auc accurately because evosuite outputs the value of such metric at every new test case generation.
differently to measure auc for branch coverage and fault detection we had to execute each intermediate test suite produced during the test generation process.
given the huge number of test suites to be considered in the order of dozens of thousands considering all applications approaches and repetitions for each subject we sampled three time intervals the point at whichthe state coverage difference between dig andsubweb is maximal the point at which is of the maximum and minutes.
in fact by graphically plotting the two state coverage functions we observed that state coverage difference has a steep peak followed by a smooth decline.
hence in order to accurately estimate the auc with only a few data points time intervals it makes sense to sample them where the difference is the largest and the next one when it is halved.
distance computation rq .distance computation is expensive because it grows quadratically with the number of test cases at each test generation step the number of distance computations is given by the number of previously executed test cases multiplied by the number of candidates.
the input distance term of equation further increases the cost for distance computation.
to assess such impact we ran dig disabling the input distance computation thus computing the distance as just the sequence edit distance.
we refer to these two variants of our approach as dig sanddig s i respectively and computed the same effectiveness efficiency metrics used for rq 1and rq .
additionally we assessed the overhead of distance computation on the number of test executions by reporting the number of tests generated and executed by each tool configuration.
manual pos rq .a developer may develop more accurate pos than those produced by an automatic technique.
thus we compared the effectiveness and efficiency of digandsubweb when manually defined pos are utilized.
unfortunately none of our subjects was equipped with po based test suites.
thus we had to manually create the pos for each subject application.
to minimize any subjectivity bias we developed the pos prior to running apogen by adopting a rigorous procedure.
specifically we adhered to the guidelines given by van deursen on the design of po based web test suites.
each po represents a test state with explicit responsibilities for state navigation and state inspection.
thus we represented each action of a test state as a trigger method in the page object.
instances of such methods are for instance clicks and data submitting forms that bring the browser to a new state.
inspection methods have been used to retrieve theesec fse august tallinn estonia m. biagiola et al.
value of key unique elements displayed in the browser when it is in a given state such as a username.
in light of these design considerations we modelled the web applications into pos as follows.
starting from the root i.e.
the initial web page typically the login page we modelled it as a po.
following the navigations that were possible from the initial state new test states were discovered e.g.
for user registration which in turn were modelled as pos.
then we proceeded following the actions that were possible in each newly discovered state building page objects iteratively and incrementally until all the pages were accounted for.
additionally states having common behaviours e.g.
menu bars were organized into reusable components .
to compare automatically vsmanually generated pos we computed the same effectiveness and efficiency metrics used to answer rq1and rq as described above.
.
results effectiveness rq .table effectiveness compares dig s i dig s andsubweb in terms of state coverage code coverage and fault detection.
statistical significance of the difference was assessed by applying the non parametric mann whitney u test with a confidence threshold .
.
concerning atusa we do not report comparisons in terms of state coverage because the navigational model retrieved by the crawler is different usually much larger from those based on the po abstraction that dig generates.
to compare them accurately one would need to find the isomorphism between the two sfgs which requires mapping each state and each transition from one model onto the other a manual and expensive process.
thus for atusa we only compare code coverage and fault detection metrics.
looking at the results both digandsubweb outperform atusa substantially.
in all cases the differences are statistically significant not reported in table .
as far as effectiveness is concerned when automated pos are utilized dig andsubweb can be considered comparable test generators with minimal performance variations.
despite both tools cover almost all navigational models within the given time budget of minutes there is however a remarkable difference.
dig is totally automated and achieved these results by relying only its diversity heuristic.
subweb on the contrary is semiautomatic as it takes advantage of manually defined preconditions to guide the search and avoid path infeasibility.
rq1 diversity and search based approaches achieve substantially higher state coverage code coverage and fault detection than the crawling based random approach.
despite being comparably effective the diversity based approach is preferable because it is fully automated.
efficiency rq .table efficiency compares dig andsubweb in terms of state coverage code coverage and fault detection achieved over time auc metrics .
digoutperforms subweb by a statistically significant amount in subjects for state and branch coverage.
regarding fault detection dig is significantly better than subweb in subjects retroboard revealed no faults .
the plot in figure shows a meaningful example regarding the efficiency difference on state coverage for phoenix .dig reaches the maximum state coverage after nearly one third of the total time figure average efficiency over time in terms of state coverage of the compared approaches on phoenix .
budget whereas subweb takes approximately twice as much time.
moreover for small time intervals the effectiveness difference of dig vssubweb is further amplified.
for instance the maximum difference between the two algorithms is after minutes of the time budget .
in practice this means that dig is preferable if strict testing time constraints apply.
rq2 the diversity based approach achieves high coverage and fault detection rates substantially faster than the search based approach.
distance computation rq .table distance computation shows the number of test cases generated and executed by dig andsubweb and the number of distance computations required by dig s ianddig s forsubweb the number of generated test cases always equals the executed test cases .
on average dig computed a large number of distances 857k bydig s iand 000kbydig s .
such computations reduces the time available for test case execution.
thus while subweb run on average test cases dig s ianddig srun an average of and less test cases respectively dimeshift phoenix retroboard and petclinic are excluded from the analysis since they always terminate before minutes which means that the number of test executions is not constrained by the time budget .
the number of generated test cases not necessarily executed bydig is substantially higher than the test cases generated and executed by subweb e.g.
.2kand .3kvs274 .
however despite a lower number test executions the time spent in distance computation allows dig to produce test cases that have a higher chance of increasing coverage and fault detection see results for rq1andrq2 .
this confirms our initial hypothesis that it is possible to assess the quality of web test cases without executing them while still achieve high coverage and fault detection rates.
let us now compare dig s ianddig s. the extra computational cost associated with the input distance reduces on average the number of executed test cases by .
on the other hand the increased accuracy of the distance computed by dig s idoes not bring considerable advantages in terms of coverage or fault detection see results for rq1andrq2 .
rq3 the overhead brought by the distance computation is overshadowed by the benefits in efficiency and automation.
moreover the input component of the proposed distance metric can be discarded with little to no associated penalty.diversity based web test generation esec fse august tallinn estonia table effectiveness efficiency and distance computation results manual pos for rq and rq 3for all subjects and approaches.
values in bold indicate statistically significant differences between dig andsubweb .
stars indicate statistically significant differences between dig s ianddig s. effectiveness efficiency distance computation structural coverage faults structural coverage tests distance state cov.
branch cov.
avg unique state auc gen. exec.
dig s i dig s subweb dig s i dig s subweb atusa dig s i dig s subweb atusa dig s i dig s subweb dig s i dig s subweb dig s i dig s dig s i dig s dimeshift .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k .0k k 331k pagekit .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k .3k k 537k splittypie .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k .5k k 569k phoenix .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k .6k k 856k retroboard .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k .8k k 930k petclinic .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k .6k k 607k petclinic .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k .6k k 607k average .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
k .5k k 805k manual pos rq .table presents the results obtained when manually defined pos are utilized for test generation.
for all subjects both tools did not cover the entire navigational model within the given time budget minutes .
this is motivated by the higher number of methods contained in the manual pos which model the web applications more accurately at the cost of making test generation more challenging.
table shows reports information about the size in lines of code loc of the pos of our study as well as the number of methods they contain.
methods determine the transitions hence the complexity of the navigational model.
the manually generated pos contain on average more loc column and more transitions column than apogen s pos.
for subjects dimeshift phoenix and petclinic we observed no significant difference between using automated or manual pos in terms of branch coverage and fault detection see results of dig in table and table .
overall when manually defined pos are available dig outperforms subweb with statistical significance in terms of state coverage in all cases and in cases concerning branch coverage.
rq4 by using manually defined pos the diversity based approach outperforms the search based approach in terms of structural coverage reached by the generated test suites.
.
threats to validity using a limited number of subject systems in our evaluation poses anexternal validity threat in terms of generalizability of our results.
we tried to mitigate this threat by choosing six subject systems developed with real world javascript frameworks and pertaining to different domains although more subject systems are needed to fully address the generalization threat.
threats to internal validity might come from confounding factors of our experiments.
we compared all competing algorithms under identical parameter settings e.g.
time budget intervals on realworld web applications.
the manual po development task poses atable manually vs automatically generated pos po size loc po methods apogen manual incr apogen manual incr dimeshift pagekit splittypie phoenix retroboard petclinic threat to validity that we tried to mitigate by following a rigorous systematic procedure.
conclusion validity is related to random variations and inappropriate use of statistical tests.
to mitigate these threats we ran each experiment times and used the non parametric mann whitney u test for statistical testing.
with respect to reproducibility of our results the source code of dig and all subject systems are available online making the evaluation repeatable and our results reproducible.
discussion .
effectiveness and automation by combining pos and test generation diversity and search based approaches achieved substantially higher state coverage code coverage and fault detection than a state of the art crawling based po agnostic approach.
dig is fully automated while subweb is only semi automated as manual preconditions need to be specified.
our results show that dig can potentially save testers a considerable amount ofesec fse august tallinn estonia m. biagiola et al.
time by generating both pos and test cases automatically.
if necessary testers can refine the generated pos with missing actions or transitions and repeat the test generation.
additionally the test suites generated by our approach are based on the page object design pattern which brings known advantages in terms of maintainability .
.
efficiency our efficiency results demonstrate that our approach is preferable especially in settings where the time devoted to testing is strict or when test cases are executed very often during the development process.
indeed the diversity based approach achieved high coverage and fault detection scores substantially earlier than the search based approach regardless the pos being used.
this gives us confidence in the applicability of our technique in modern software development processes such as xp and devops.
.
benefits to feasibility under the conjecture of contiguous infeasibility regions promoting diversity is beneficial not only to a thorough exploration of the application behaviours but also to the feasibility of automatically generated test cases.
the search based approach on the contrary uses the guards in the navigational model explicitly to guide the search towards inputs that satisfy them.
.
comparison with manual pos the pos automatically generated by apogen are usually simpler than those developed manually in terms of number and complexity of actions being exposed for testing.
apogen creates methods based on the actions statically extracted from each test state.
as such in most cases the resulting methods may miss complex interactions that are possible on the web gui.
additionally due to a transition minimization strategy apogen does not create reusable components for repeated headers such as menu bars .
thus the number of possible test paths cases that can be generated by dig is lower.
despite such limitations automated pos are competitive with manual pos in a subset of the considered applications.
an interesting option available to testers could be the refinement of automatically generated pos to achieve the same performance of manual pos at a lower development cost.
overall our empirical results show that when high quality pos are available our diversity based approach outperforms all other approaches both in terms of effectiveness state and branch coverage and efficiency rate at which coverage is reached .
related work automated test case generation for web applications is a challenging and extensively researched activity as highlighted by the high number of papers proposed in literature only in the last few years .
the work presented in this paper instantiates concepts from adaptive random testing and diversity based test generation in the context of web testing.
specifically it provides a web specific diversity based algorithm and defines ad hoc distance measures and test generation heuristics.
the main existing model based works have been already presented and discussed in section .
.
on the same category feedex uses dom and path diversity to guide a crawler towards the generation of smaller yet more accurate testing models.
however feedex is not a test case generator hence a direct comparison with dig is left for future work.
yu et al.
propose an incremental two steps algorithm implemented in the prototype tool inwertgen in which creation of novel pos and generation of test cases are intermixed.
test cases are generated using the tool randoop .subweb proposes a genetic algorithm that performs path selection and input generation at the same time starting from a manually created po based model.
existing techniques and tools for automated web test generation either ignore path feasibility or require a high number of executions to ensure path feasibility.
indeed approaches based on crawling or dynamic analysis generate a navigational model and then extract paths from it without considering that the associated inputs must ensure feasibility.
on the other hand all approaches that explicitly address path feasibility require the execution of a huge number of test case candidates.
in fact they employ random or search based test generation algorithms both of which assess the feasibility of the candidate test cases by executing them.
on the contrary we assess the quality of the candidates by their diversity before executing them to determine their feasibility.
our empirical studies show that as a side effect higher diversity results also in higher feasibility.
recent papers have considered increasing the robustness and maintainability of web test suites.
in order to make test scripts robust several tools producing smart web element locators have been proposed or to repair them additionally stocco et al.
investigate the automated generation of page objects that confine causes of test breakages to a single class a form of breakage prevention.
finally in the mobile domain sapienz uses multi objective search based testing to automatically explore and optimize test sequences minimizing length while simultaneously maximizing coverage and fault revelation.
evodroid is a model based test generator for android based on an evolutionary algorithm that performs a step wise search for test cases.
conclusions and future work we have proposed a diversity based approach for web test generation implemented in our tool dig.dig can assess a high number of test case candidates without executing them in the browser making test generation significantly more efficient than state of the art techniques.
differently from search based approaches our tool is fully automated and it does not require any specific guidance to generate feasible test cases.
in our future work we plan to experiment alternative distance metrics among which those based on information theoretic concepts such as the normalized compression distance .
moreover we will also decouple dig from evosuite so as to further optimize its performance.
a further interesting line would be to study the effectiveness of dig subweb and atusa starting from a navigational model produced by a diversity oriented tool such as feedex.
lastly we plan to experiment our technique with more subjects as well as to run a controlled experiment with human subjects to measure the accuracy of the generated testsdiversity based web test generation esec fse august tallinn estonia