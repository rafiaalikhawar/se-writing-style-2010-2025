esbmc .
an industrial strength c model checker mikhail r. gadelha university of southampton united kingdomfelipe r. monteiro federal university of amazonas braziljeremy morse university of bristol united kingdom lucas c. cordeiro university of manchester united kingdombernd fischer university of stellenbosch south africadenis a. nicole university of southampton united kingdom abstract esbmc is a mature permissively licensed open source contextbounded model checker for the verification of single and multithreadedcprograms.itcanverifybothpredefinedsafetyproperties e.g.
bounds check pointer safety overflow and user defined programassertionsautomatically.esbmcprovidesc andpython apis to access internal data structures allowing inspection and extensionatanystageoftheverificationprocess.wediscussimprovements over previous versions of esbmc including the description ofnewfront andback ends ieeefloating pointsupport andan improved k inductionalgorithm.ademonstrationisavailableat ccs concepts software and its engineering formal software verification theoryofcomputation verificationbymodelchecking hardware bug detection localization and diagnosis keywords software model checking k induction bug detection.
acm reference format mikhailr.gadelha feliper.monteiro jeremymorse lucasc.cordeiro berndfischer anddenisa.nicole.
.esbmc5.
anindustrial strength cmodelchecker.in proceedingsofthe201833rdacm ieeeinternational conference on automated software engineering ase september montpellier france.
acm new york ny usa 4pages.
org .
.
introduction esbmc is a mature bounded model checking bmc tool for multithreaded c programs.
its development started in on top of the cprover framework but almost all components have been re designed and re implemented in subsequent years including thebasicdatastructures front end symbolicexecution memory model andback end.thepurposeofthispaperistodescribethe recenttoolmodificationsandextensions including i amorerobust e mail esbmc googlegroups.com permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
frontend ii an improved handling of floatingpointarithmetics iii animproved k inductionschemethatallows esbmc to better handle programs with unbounded loops and iv a python api that gives users access to esbmc s data structures.
esbmcprimarilyaimstohelpsoftwaredevelopersbyfinding subtle bugs in their code e.g.
array bounds violations nullpointerdereferences arithmeticoverflows ordeadlocks .itdoes not require any special annotations in the source code to find such bugs butitdoesallowuserstoaddtheirownassertionsandalso checksforviolationsofthese.inaddition esbmcimplements kinduction and can be used to provethe absence of property violations resp.
the validity of user defined assertions .
it relies on off the shelf satisfiability modulo theory smt solvers such as boolector z3 yices mathsat andcvc4tocheckautomatically the verification conditions corresponding to the safety properties.
esbmchasbeenappliedtoalargenumberofapplicationsincludingtelecommunications controlsystems andmedicaldevices .
itisopensource underthetermsoftheapachelicense2.
and its source code and self contained binaries for bit linux environments are available at and respectively.
components and features by default esbmc takesacp r ogram and checks for array bounds violations divisionsbyzero pointersafety incl.alignment andall user definedproperties.ithasoptionstocheckforoverflows mem ory leaks deadlocks and data races and to choose between a fixedor ieee floating pointarithmetic.figure 1showsitsarchitecture.
front end.
esbmc now uses clang a state of the art compiler suite for c c objectivec objectivec widely used in industry asitsfront end.asdevelopers wethusavoidtheneedto maintainaseparatefront end butthisapproachalsobringsanumber of advantages for users i esbmc provides compilation error messages as expected from an industrial strength tool ii esbmc leveragesclang spowerfulstaticanalyzertoprovidemeaningful warnings when parsing the program iii clang can simplify the inputprogram e.g.
calculate sizeofexpressions evaluatestatic asserts whichsimplifiestheanalysisofthecode.notethatweuse clang sapitoaccessandtraversetheprogramast withouthaving details of the input program compiled away which differs from other verifiers e.g.
llbmc that rely on the llvm bytecode.
control flow graph cfg generator.
the cfg generator takes the program ast and transforms it into an equivalent goto program asimplifiedrepresentationthatconsistsonlyofassignments conditionalandunconditionalbranches assumes andassertions.
in particular this step eliminates all for while do while andswitchstatements.
it also adds checks for division by zero authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france m. r. gadelha f. r. monteiro j. morse l. c. cordeiro b. fischer and d. a. nicole !
!
!
!
!
figure1 esbmcarchitecturaloverview.thetooltakesacprogramasinput.itthenconvertstheastgeneratedbyclanginto a cfg and the symbolic execution engine unrolls the program and generates the ssa form of the program.
the ssa is then converted to an smt formula which is satisfiable only if the program contains errors.
and out of bounds access and for integer and floating point overflow ifenabled .in k inductionmode cf.section italsoanalyses loopbodiesand havocs anyvariablewritten toinsidealoopwith non deterministicvalues thehavockedvariablesareusedbythe inductive step to over approximate the loop.
symbolic execution engine.
esbmc then symbolically executes the goto program it unrolls loops ktimes generates the static single assignments ssa form of theunrolled program and derivesallthesafetypropertiestobecheckedbythesmtsolver.
this step also inserts pointer safety checks for dynamically allocated memory if they are enabled.
note that this can only be done after unrolling because the pointer analysis needs to know the maximumsetofdynamicallyallocatedstructures.esbmcaggressively simplifies the program to generate small ssa sets using constantfoldingandvariousarithmetic includingfloating point simplifications.
smt back end.
esbmc s smt back end supports five solvers boolector default z3 mathsat cvc4andyices.theback end ishighlyconfigurableandallowstheencodingofquantifier free formulas with support for bitvectors arrays tuple fixed point and floating point arithmetic all solvers and linear integer and real arithmetic allsolversbutboolector .weusetheback endtoencode the ssa form of the program into a quantifier free formula and check satisfiability of c p wherecis the set of constraints andpis the set of properties.
if the formula is sat the program containsa bug esbmcwillgenerate acounterexample with the set of assignments that lead to the property violation.
python api.
esbmcnowincludesapythonapithatreduces the difficulty of prototyping new features and makes the tool internals accessible to a wider audience i.e.
the verification process showninfigure 1canbeinterceptedandchangedatanypoint.for example a developer can easily add their own intrinsic function to model a new library function or to exploit a different smt theory 1def symex step self art boilerplate accessing instruction insn omitted 3ifinsn.type gptypes.
function call 4call esbmc.
downcast expr insn.code 5sym esbmc.downcast expr call.function ifsym.name.
as string c isnan interpretation of call here return otherwise call through to rest of esbmc 10super thisclass self .
symex step art thecodeoverridesthedefaultinstructioninterpretationfunction l1 andforfunction callinstructions l3 aquiresthecalldefinition l4 the name of the called function l5 and should it be named isnan l6 appliesspecialhandling l7 detailsomitted .forallother instructionsthedefaultinstructioninterpretationfunctioniscalled l10 .
python is well known for its expressiveness e.g.
set comprehensions andthelanguagebindingseliminatetheneedtoconsider object lifetime and other low level details.
rapid prototyping is encouragedbyavoidingrecompilationofthemaintool itenablesnew verificationideastobequicklytested.however thepythonapialso has drawbacks it is slower than c and developers can operate itillegally causingthetooltocrash.inthelongterm itwouldthus be desirable to provide esbmc as a library of verification facilities for the development of new tools.
the k induction proof rule k induction allows bmc to find a property violation or even to prove partial correctness without fully unwinding loops.
esbmc uses the algorithm in an iterative deepening style kind p k pcontains a bug ifb k is sat pis correct ifb k is unsat kind p k otherwise .
here the base case formulab k is the standard bmc formula which is satisfiable iffthe program has a counterexample of length kor less.
if all states are reachable for the current k we know thattheprogrammustbecorrectwithoutcheckingtheinductive step.the forwardcondition f k formalizesthis itcanbederived fromtheprogrambyinserting unwindingassertions aftereachloop.
thisstepisparticularlyusefulforprovingsafetyinthepresence of bounded loops.
the inductive step i k checks that if a safety property holds in the first ksteps then it also holds for k steps.
iterative deepening implies that esbmc always finds the smallest kto either prove correctness or find a property violation.
esbmc nowuses scheme improvedover the earlierversion describedbygadelhaetal.
.inparticular thisnewversionnolonger collects havocked variables into states rewriting every access to these variables into state accesses.
instead the havocked variables are directly assigned nondeterministic values in the inductive step.
thisisasimplerandmoreaccuratetransformationandfollowsthe workbydonaldsonetal.
.note however thattheirimplementation works by unwinding the program during cfg generation thus replicating the loop ktimes and removing the backward jump.
in esbmc the algorithm only adds the nondeterministic assignmentsbeforetheloopandtherequiredassumptions duringcfg generation and relies on the symbolic execution to unroll the loop.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
esbmc .
ase september montpellier france floating point encoding in esbmc in previous versions esbmc verified programs using a fixed point arithmetic thisisappropriatefor e.g.
programsrunningina number of embedded devices but not for programs that rely on floating pointarithmetic.thecurrentversionofesbmcencodes floating pointarithmeticeitherusingthesmttheoryoffloatingpoints fully available in z3 and partially in mathsat and cvc4 or using bitvectors which extends the floating point arithmetic support exceptfor floating point exceptions to all solvers that are currentlyintegrated.thisisamajorimprovementoverourprior work where we model most of the c11 standard functions .
currently mathsat does not support fp.rem remainder operator andfp.fma fusedmultiply add andcvc4doesnotsupport sortconversionfunctions.oursmtbackendfallsbacktothebitvector mode when an unsupported operation needs to be encoded it converts the arguments from floating points to bitvectors encodes the operation and returns the resulting bitvector encoded as a floating point.this isonly possible byusing the non standard smt libfunctions fp as ieeebv andfp from ieeebv toconvert to and from bitvectors.
this process is transparent to the user and effectivelymeansthatmissingoperationswillbecorrectlyencoded despite the lack of support by the underlying solver it allows us to use smt solvers as boolector and yices that do not have any built infloating pointtheory.mostofthefloating pointoperations inansi cprogramscanbedirectlyconvertedtosmt onlytwo operations needed special handling casttoboolean.
thesmtstandarddoesnotdefineconversions betweenbooleanandfloating pointtypes.inesbmc whencasting frombooleanstofloating points an iteoperatorisused suchthat the result of the cast is .
if the boolean is true otherwise it is .
.
we encode casts from floating points to booleans as conditional assignments the cast result is true when the floating is not .
otherwise it is false.
equality.
bitvector assignment and equality operations are encodedusingtheequalityoperator .however thesmtstandard defines a separate operator for floating point equalities the fp.eq operator where fp.eq x y evaluates to true if x evaluates to zero and y to zero or vice versa.
fp.eq and all the other comparison operatorsevaluatetofalseifoneoftheirargumentsisnan .the operator is defined to handle the special symbols from the ieee floating pointstandard inparticular signaledzerosand nans for this reason esbmc encodes all equality of floating points using thefp.eqoperator whileassignmentsremainencodedusingthe equality operator.
illustrative example wedescribehowtoverifyacprogramwithesbmcusingthecode fragment shown in fig.
.
here esbmc is invoked as follows esbmc file .c floatbv k induction where file .c isthecprogramtobechecked floatbv indicates that esbmc will use floating point arithmetic to represent the program s floatanddoublevariables and k induction selects the k induction proof rule.
the user can select the smt solver property and verification strategy esbmc help provides the full list of options.
esbmc unrolls the program in fig.
2and converts it into ssa form to produceverificationconditions vcs oneforeachassertionthatcannotbestaticallydetermined.equations and give candpduring the inductive step k .
include math.h 2intmain 3unsigned int n nondet uint 4double x nondet double 5if x isnan x return 7unsigned int i i nondet uint x nondet double inductive step only esbmc assume i n while i n 12x x assert x i esbmc assume !
i n inductive step only assert x return figure c code fragment.
here nondet uint and nondet double stand for non deterministic integer and double values respectively.
isnanchecks whether a given floating point is a not a number nan value.
the commentedlines 10and16arethetransformationsintroduced during the inductive step of the k induction algorithm.
note that isnan x1 in eq.
checks if the symbol is a nan which is translated to the fp.isnan smt operator.
esbmc also addsadditionalliteralsforeachclauseof ptoidentifytherespectivevcs.theresultingformula c pisthenpassedtoansmt solver where it is checked in less than one second.
we can also introduceabugbyremovingthe isnan x checkfromline 5infig.
s1 mapsto n s2 mapsto x nan s3 mapsto x .0f effectivelyremoving 2fromeq.
which would lead to the counterexample in the right hand side.
here states3leadstoanassertionfailure in line13 i.e.
i fx nan thenx .0fevaluates to false esbmc is also able to detect this violation in less than one second.
c n nondet uint1 x1 nondet double 1 x1 .0f 2 ite 1 true isnan x1 i1 nondet uint2 x2 nondet double 2 i1 n1 3 i1 n1 x3 .0f x2 2 3 x3 .0f i2 i1 4 i2 n1 x4 .0f x3 x5 ite 4 x3 x4 p 3 4 x4 .0f 2 3 4 3 x5 .0f fig.2alsoshowsthetransformationsintroducedbytheinductive step during k induction the transformations are commented out during the base case and the forward condition.
the transformations aim to prove that no property violation is reachable regardless of loop unwinding this is translated to assuming nondeterministicvaluestotheloopvariables lines assumingthat the loop body is evaluated line the assumption removes every state that does not satisfy the loop entry condition and terminates line16 theassumptionremoveseverystatethatdoesnotsatisfy the loop termination condition .
note that since the inductive step is an overapproximation only correctness can be proved i.e.
it might find spurious counterexamples.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france m. r. gadelha f. r. monteiro j. morse l. c. cordeiro b. fischer and d. a. nicole table results from sv comp .
2lscbmccpa seq depthkesbmc v1.
.
esbmc v5.
symbiotic uautomizer ukojakutaipan correct true correct false incorrect true incorrect false total correct results total incorrect results experimental evaluation we evaluated esbmc over the sv comp benchmarks which comprises verification tasks that check for property reachability tasks memory safety tasks reachability in concurrent programs tasks overflow tasks termination tasks and reachability in linux device drivers tasks .
table shows our experimental results a detailed description of the different tools and the experimental setup can be found in .
here a task counts as correct true if it does not contain any reachable error location or assertion violation and the tool reports safe however ifthetoolreports unsafe itcountsas incorrecttrue.similarly a task counts as correct false if it does contain a reachable violation and the tool reports unsafe together with a confirmed witness pathtofailure otherwise itcountsas incorrectfalse accordingly.
the difference between the grand total and the sum of the two sub totals gives the number of tasks for which the tool exhausted time or memory or failed otherwise.
k induction.
overall esbmc ranked third behind cpa seq anduautomizer with14incorrectfalseresults 10duetoinaccuracies in our concurrency and memory models plus due to bugs inthesimplifier and10incorrecttrueresults.however noneof theincorrectresultsarerelatedtothe k inductionalgorithm and the results show that esbmc is currently the best k induction tool.
esbmc outperformed cpa seq and uautomizer in the verification of reachability properties for arrays and memory safety issues.
cbmc also implements k induction requiring three different calls togeneratethecfg toannotatetheprogramandtoverifyit whereasesbmchandlesthewholeprocessinasinglecall.additionally cbmcdoes not havea forwardcondition to checkif all states were reached and relies on a limited loop unwinding .
cpa seq applies a number of different techniques when verifying a program so a direct comparison to their k induction is not possible however a pure k induction version cpa kind showed poor results in a previous competition.
depthkusesaninvariantgeneratortoinstrumentthecodewith invariants and uses k induction to verify the program .
althoughonewouldexpectbetterresults depthkusesanoldversion of esbmc to verify the programs this explains the poor results.
2ls integrates an abstract interpretation invariant generation between the base case and the inductive step in contrast to our k induction their version has no forward condition.
overall 2ls verifies22 fewerbenchmarksthanesbmc 2lsreturns33 fewer correct results although it also returns fewer incorrect results.
comparisonwithold k inductionschema.
inordertocomparewiththeold k inductionschemausedinesbmcv1.
.
we re ran it over the current sv comp benchmark set.
table 1shows a increase in correct results and a decrease in incorrect results butthisisslightlymisleading 168oftheincorrectresultsproducedbytheoldschemearefromtheconcurrencycategoryand are caused by the concurrent model used back then.
however the old scheme also produces incorrect results in the reachsafety eca andreachsafety recursive categories whicharerelated to its incorrect approximation of loop termination conditions.
floating point verification.
esbmc uses mathsat for tasks that involve floating point arithmetics.
this combination not only outperforms a z3 based esbmc but also all other tools in svcomp.esbmcachievedthehighestscoreinthereachsafety floats subcategory where it can verify of the tasks out of within the time and memory restrictions.
conclusion and future work we presented esbmc the first open source smt based contextbounded model checker to support full c programs .
esbmc is a mature tool here we focussed on three novel features of esbmcv5.
thenewclangfront end thenewfloating pointback end and inparticular ournewimplementationofthe k inductionproof rule.resultsoverthesv comp2018benchmarksuiteshowthat esbmc is the strongest k induction tool currently available.
we areextendingthe k inductionproofruletouseinformationfrom the inductive step to make bug finding more efficiently .