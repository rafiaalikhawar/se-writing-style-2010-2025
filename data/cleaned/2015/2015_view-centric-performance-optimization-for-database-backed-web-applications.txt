view centric performance optimization for database backed web applications junwen yang1 cong yan2 chengcheng wan1 shan lu1 alvin cheung2 1university of chicago junwen cwan shanlu uchicago.edu2university of washington congy akcheung cs.washington.edu abstract web developers face the stringent task of designing informative web pages while keeping the page load time low.
this task has become increasingly challenging as most webcontents are now generated by processing ever growing amountof user data stored in back end databases.
it is difficult fordevelopers to understand the cost of generating every web pageelement not to mention explore and pick the web design withthe best trade off between performance and functionality.
in thispaper we present panorama a view centric and database awaredevelopment environment for web developers.
using database aware program analysis and novel ide design panorama pro vides developers with intuitive information about the cost andthe performance enhancing opportunities behind every htmlelement as well as suggesting various global code refactoringsthat enable developers to easily explore a wide spectrum ofperformance and functionality trade offs.
i. i ntroduction a. motivation high quality web applications need to provide both good functionality informative and well displayed web page content and good performance lower than seconds of pageload time with every second s delay causing fewerpage views a decrease in customer satisfaction and loss in conversions .
these functionality and performancerequirements are increasingly difficult to satisfy simultaneously as modern web page content often requires processinga huge amount of user data to generate and the amount of userdata often increases by per year .
indeed real world web developers often don t understand the amount of dataprocessing required to render their web pages which resultsin numerous design changes to address performance issues .because of this tools that can help developers understandperformance implications of their web page design and exploredesigns with different performance functionality trade offs cangreatly improve the web development process.
to better understand the challenges faced by web developers consider tracks a popular task managementapplication constructed using the ruby on rails framework.tracks has a todos index page displaying all the to do s for a user.
at one point users complained that this page was un reasonably slow even though very few to do s were displayed .
after some debugging developers turned their attentionto a sidebar on this page which displayed all the projects theuser had been involved in.
as shown in figure the view fig.
performance understanding challenge filesidebar.html.erb which produces this sidebar renders these projects based on a ruby variable active projects embedded in the html file this variable is computed in a controller ruby file todos controller.rb through a seemingly straightforward assignment active projects user.projects.active.
it turns out that this code actuallyretrieves objects stored in a database and is translated intoa sql query by the rails framework at run time.
it was thelong time taken for the database to run this query that resultedin the poor performance observed by users.
after realizingthis developers decided to remove the sidebar and users cannow see the main content of this page the to do items muchquicker.
this performance functionality trade off represents one of the many challenges that web developers face understanding the performance cost behind every rendered web page element is challenging for developers andrequires cross stack knowledge as the above example shows.as shown in figure modern web pages commonly containdynamically generated contents.
consequently the cost of aweb page element includes not only browser rendering time but also web server computation time and backend databaseserver processing time.
as web applications are often con structed using the model view controller architecture it is difficult for users to manually search through multiplefiles across application modules to identify code that leads toperformance issues and it is even more difficult for developersto reason about what database queries could be issued as theirapplication executes and how much data would be retrievedfrom database for rendering.
existing profiling tools are insufficient in aiding with this regard.
some only account for the client side cost ofevery html tag but do not account for the server side cost others report database query cost but do not attributequeries to specific html tag and hence cannot provide direct ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
guidance to web page design.
furthermore all these profiling tools rely on workloads provided by developers and therefore cannot help predict performance problems that manifest from real world workloads.
exploring the performance functionality trade offs among different web page designs is also challenging for developers requiring cross module and cross language code refactoring.
for example to remove a web page element it is insufficient to just remove the corresponding html tag from the view file.
developers also need to check which variables are referred to by that html tag which controller code snippets generated those variables and whether removing those code snippets altogether will affect other parts of the application.
in addition there are also other web page design alternatives with different performance functionality tradeoffs.
unfortunately most require global code restructuring and are difficult to carry out without tool support.
worse yet recent work on detecting and fixing database related inefficiencies in web applications only focuses on inefficient orm api usage unnecessary data retrieval and redundant queries and is completely oblivious to web page designs.
in short existing techniques do not consider performance enhancing opportunities that require web page design changes which we refer to as view changes and hence cannot help developers explore the performance functionality trade off space.
indeed empirical studies have found that about a quarter of real world web application performance problems are solved by developers through view changes like pagination and view content removal.
these changes often bring much more performance improvement than the view preserving ones .
vs .
on average but involve more changes .
files vs. .
files .
they are difficult to perform manually and having good tooling support is hence crucial.
b. contributions in this work we present a framework called panorama that provides a view centric and database aware analysis for web developers to understand and optimize their database backed web applications.
panorama currently targets applications written using the ruby on rails framework and makes three major contributions as illustrated in figure .
panorama provides a view centric estimator that helps developers understand the data processing cost behind every html tag.
panorama both dynamically monitors database query performance using the test workload statically estimates data processing complexity independent of any specific workload and carefully attributes the cost to every html tag through its cross stack dependency analysis.
the details will be presented in section iv.
panorama provides a view aware performance optimizer that helps developers carry out view changing code refactoring to improve performance.
panorama suggests a variety of refactorings that change the manner of content rendering i.e.
pagination or asynchronous loading or change the accuracy of the rendered contents i.e.
approximation or remove certain web page contents from rendered contents.
fig.
panorama overview through static program analysis panorama not only identifies opportunities for applying such refactoring but also automatically suggests patches that complete such refactoring often involving modifications to multiple files in model view and controller components.
we present the details in section v. panorama provides a unique interface for developers to effectively exploring different web page designs with different performance functionality trade offs.
instead of separately presenting profiling information and refactoring suggestions panorama integrates them in the web browser while testing a page of their web applications the data processing cost for each html tag is presented as a heat map in the browser.
developers can right click on each html tag to see the different view changing options for performance enhancement they can choose any option and immediately see an updated web page with an updated heat map in the browser with all code refactoring automatically done by panorama in an accompanying ruby editor.
we evaluated panorama on popular open source ruby on rails applications.
panorama statically identifies performance enhancing opportunities through view changes.
we randomly sampled view changes suggested by panorama and found that by applying the patches automatically generated by panorama these view changes speed up end to end page load time by .
on average maximum using database workloads that are similar to those used in real world deployments.
we believe the benefits will increase with even larger workloads.
furthermore we conducted a thorough user study with participants from amazon mechanical turk.
the study shows that web pages with these view changes are considered as similar or better than the original web pages in most cases with more users preferring the design suggested by panorama than the original ones.
this user study result as well as the fact that these optimizations save computation resources on web servers and database servers justify the need for developers to explore the performance functionality trade off space in web application design with panorama being a first step towards that goal.
ii.
b ackground rails applications are structured based on the modelview controller mvc architecture.
we illustrate this in figure .
when a client requests for a url such as circlecopyrt a controller action projects index is triggered.
this action takes in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the parameters from the request e.g.
in the url as params and interacts with the dbms by calling the activerecord api implemented by the rails framework circlecopyrt.
rails translates the function calls into sql queries circlecopyrt whose results circlecopyrtare serialized into model objects e.g.
the project model and returned to the controller circlecopyrt.
then the returned objects are passed to the view circlecopyrt in order to generate a webpage circlecopyrtto send back to users circlecopyrt.
each model is derived from activerecord and is mapped to a database table by rails.
a view file ends with .erb or.haml usually involves multiple languages including html javascript and ruby.
the ruby code can dynamically generate the content of html elements or decide which element to show.
.
!
!
fig.
rails application architecture based on the mvc pattern iii.
s tatic analysis framework panorama leverages a database aware static analysis framework for rails applications that we briefly describe below.
a. action dependency graph panorama s static analysis centers around the actiondependency graph adg that is constructed for each controller action.
figure shows an example of adg.
an adg is a database aware extension of the traditional program dependence graph pdg .
every node nin the adg represents an intermediate representation ir statement in the corresponding action s jruby ir.
every edge erepresents either control dependency or data dependency.
edges shown in figure all represent data dependencies.
in contrast to the pdg every node in the adg that issues a sql query is associated with a query tag in adg such as node circlecopyrt and node circlecopyrt in figure .
information about sql queries that are issued and the tables they referenced are determined by analyzing activerecord function calls and recorded in the adg.
since view files may also contain ruby code to process or render data they are also analyzed during the adg construction.
specifically for every action like user show in figure its corresponding view file is identified based on an explicit render statement or implicit file name matching !
!
!
!
!
!
!
!
!
!
!
!
fig.
excerpt of an action dependency graph as in figure .
the corresponding view file is then parsed with all ruby code embedded inside ... extracted and inlined as part of the adg like the three statements inside show.html.erb and the adg shown in figure .
b. annotating the view component in order for panorama to attribute performance data correctly to each html tag panorama pre processes every view file in the input web application to assign every html tag a unique id.
that is for every tag tag that does not already have an id panorama turns it into tag id ti where ti is a unique id as shown in the span tags of figure .
the current prototype of panorama does not handle html tags that are programmatically generated by javascript code.
as mentioned the view file has ruby code embedded within it.
for every node in adg whose source code is in a view file panorama identifies its inner most surrounding html tag and associates it with the corresponding tag id.
panorama also checks whether its corresponding content is rendered or not by analyzing the html and assigns an isrendered property accordingly.
this information will help panorama attribute data processing cost to each html element and identify alternative view designs as we will explain in later sections.
iv .
p anorama view centric cost estimator there are two key tasks in panorama s cost estimation.
first given an html tag panorama determines which database queries are executed to generate the data that is rendered through that tag we refer to them as contributing queries .
second for each html tag panorama measures the data processing cost needed to render it.
while a web page s load time consists of client side rendering time network communication between client and server computation time on the server and database query cost panorama s estimator currently focuses on database query cost as query time often contributes a significant portion of the page load time.
this is particularly true as the data size increases and large query results lead to even more computation and rendering time.
query time complexity is also difficult for developers to estimate particularly given the orm abstraction.
as future work we will incorporate other profiling tools to measure the performance of the client code network and server computation as part of panorama.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a. identifying contributing queries panorama identifies contributing queries for an html tag by statically analyzing control and data dependencies in the adg.
given an html tag in a view file panorama first identifies all adg nodes nthat contain the tag s unique id these nodes contain the ruby code embedded in the html tag.
then panorama traces backward along the adg edges to identify all query nodes that any node in nhas control or data dependence upon.
all these queries each identified by its adg node id and ruby source code location are considered as contributing queries of this html tag.
for example in figure tracing dependency edges backward from node circlecopyrt which corresponds to html tag with id ti1 will identify two contributing queries nodes circlecopyrtand circlecopyrt.
panorama further conducts forward dependency checking in the adg to see how many other html tags each query node contributes to.
this number can be used as a weight in computing the data processing cost of an html tag if a query result is used to generate khtml tags e.g.
the query node circlecopyrtcontributes to three html tags in figure we could attribute kof the query cost to each html tag if the web developers choose so while by default panorama attributes the complete query cost to each tag .
b. cost analysis panorama offers two modes of cost estimation with or without relying on testing workload.
dynamic profiling if a testing workload is available panorama will measure the cost of each contributing query during a testing run.
however using the query execution log from the backend database engine as the testing workload does not work the database engine has no knowledge about frontend ruby and html code and hence does not allow panorama to connect the statement in the web application that issues the query and the html tag uses the query result.
panorama instead conducts its profiling through a hook api provided by rails infrastructure activerecordquerytrace .
this api allows its hooked code to be called before and after issuing each sql query.
using this mechanism panorama logs the amount of time of each query and the line of source code that issues this query during the testing run and attributes the time to the corresponding html tags using contributing query analysis as discussed above.
static estimation since a bottleneck exposing workload may not be available during in house testing panorama also uses static analysis to estimate the potential data processing cost in terms of its data complexity to render each html tag.
for ease of estimation panorama assumes that all tables in the database have the same size d. then for each contributing query panorama estimates its complexity i.e.
how its execution time might increase with d by considering the number of times this query might be issued and time taken to execute one query instance.
to estimate the first factor panorama analyzes loops.
if the query qis not contained in any loop or is only contained by a loop whose iteration number does not increase with d whichwe refer to as a bounded loop panorama then considers q to be executed for a constant number of times.
otherwise panorama considers qto be executed for dktimes with kbeing the number of unbounded loops containing q.t o identify the unbounded loops panorama analyzes the bound variable of all loops that contain q. if the loop iterates through a set of records returned by an unbounded database query panorama considers the loop to be unbounded.
specifically in rails a query is unbounded in all but the following three cases it always returns a single value like a sum query it always returns a single record by selecting on primary key it always returns a bounded number of records using thelimit keyword.
to estimate the second factor panorama first identifies all the query operators inside the query q. for example for the query node circlecopyrt in figure panorama would identify three query operators from the user.issues.active.count statement a select to get issues another select to get active and finally a count operator.
for most operators we estimate its execution complexity to be o d .
there are a few exceptions we consider the complexity of a join operator to beo d2 and the complexity of an operator that explicitly uses index such as find andfind byid to be constant.
putting these two factors together gives panorama the complexity estimation for one contributing query q. for example the estimated complexity of the query node circlecopyrtin figure is o d3 .
if it is enclosed in an unbounded loop its complexity would increase to o d4 .
panorama could choose to deliver the above performance information using either a detailed text description or a numeric score.
the current prototype uses the latter it uses the highest complexity among all contributing queries as the complexity score of an html tag.
for example in figure the complexity score of html node circlecopyrtis based on the o d3 complexity estimated for query node circlecopyrt and the complexity scores of html node circlecopyrtand circlecopyrtare both based on the o d complexity estimated for query node circlecopyrt.
of course this is just a best effort estimation from panorama.
there are several potential sources of inaccuracy that can be improved by future work.
for example some database tables may be much larger than others which we do not consider the database can also lower the query complexity than our estimation due to query optimization.
v. p anorama view aw are optimization panorama suggests three categories of view changing code refactoring to improve page load time display the same contents in a different style such as pagination and asynchronous loading.
display the same contents but with a different accuracy.
remove a subset of contents from display.
these code refactorings can be applied for different types of html tags and complement each other.
panorama code refactoring works independently from panorama cost estimator.
as we will see in section vi authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
fig.
refactoring so that the paginated page displays items at a time rather than the full list panorama interface will contain both features and help developers make informed refactoring decisions.
a. display style change pagination many web pages are designed to display alldatabase records satisfying certain conditions.
when the database size grows such pages will take an increasingly more time to load and eventually become unresponsive.
a widely used solution to this problem called pagination is to display only a fixed number of records in a page and allow users to navigate to other pages for more records.
although pagination is widely used in practice there are still many cases where it is not used out of realworld performance issues sampled by a previous study are due to lack of pagination either because developers are unaware of pagination or because they did not anticipate the data size will become a performance problem.
therefore we design panorama to automatically identify pagination opportunities and conduct corresponding refactoring for developers.
identifying opportunities to identify these opportunities panorama checks each loop in the program for whether the loop iterates through the result of an unbounded query and whether each loop iteration leads to some content being rendered in an html tag.
if a loop passes both checks the corresponding html tag will be reported as a pagination candidate.
for the first check panorama locates the array variable that a loop iterates through like products in the loop shown in the left column of figure and then checks the data flow edges in adg to determine whether this variable is produced by an unbounded database query as defined in section iv b2.
for example the adg would show that products is the result of product.all on line of in figure 5b and product.all will be translated to an unbounded database query at run time.
for the second check panorama searches for an adg node nvthat is associated with an html tag and an isrendered property inside the loop body how to compute isrendered is introduced in sec.
iii b .
if nvis found like line in figure 5a the html tag associated with nvis identified as a pagination candidate.
generating patches to carry out the refactoring panorama performs two changes to the source code using the will paginate library .
first in the controller panorama adds a .paginate call right after the code statement where the to be rendered database records are retrieved like line and in figure 5b.
the constant there which is configurable and 30by default determines how many records will be shown on every page.
second in view panorama adds a will paginate products statement right after the loop that renders these database records as illustrated in line in figure 5a.
the will paginate call inserts a page navigation bar into the web page allowing users to navigate to remaining records after seeing the records displayed on the current page.
b. display style change asynch loading asynchronous programming is widely used to support lowlatency interactive software .
for web applications when there is an html tag that takes much longer time to render than other tags on the same page we can instead compute and render the slow tag asynchronously allowing users to see other parts of the web page more quickly.
for example discourse is a forum application.
its topics show page mainly lists all the posts that belong to a topic.
at the bottom of that page after the listing of all the posts a list of suggested topics that are related to this topic are displayed.
in an issue users complained that this page is slow to load no matter a topic contains many or few posts.
developers then realized that the query to retrieve suggested topics is hurting the page load time.
making things worse these suggested topics are not the main interests of this page and often are not seen by users as they are placed below all the posts and require users to scroll down to the bottom of the page to see.
consequently developers created a patch that defers the display of suggested topics until all other content on the page is displayed.
identifying opportunities conceptually every html tag can be computed and rendered asynchronously.
we only need to pay attention to two issues.
first only tags that are among the slowest on a web page are worthwhile for asynchronous loading.
otherwise loading an originally fast tag asynchronously does not help shorten the page load time the panorama estimator section iv already provides information to help developers make this decision and hence we do not discuss this issue below.
second if too many html tags on a web page are rendered asynchronously the user experience could be greatly degraded.
furthermore if one html tag is rendered asynchronously other html tags may better be rendered asynchronously too if they share a common contributing query.
for example in figure once we decide to load html tag circlecopyrtasynchronously circlecopyrtand circlecopyrtwill be loaded asynchronously too as they share a common query circlecopyrt.
panorama considers this issue in identifying opportunities for asynchronous loading and we will describe how this is handled below.
generating patches given an html tag e making its content computed and rendered asynchronously requires multiple changes to the controller and view components of a web application as illustrated in figure creating a new view file that renders eonly separating efrom other tags on the same web page that will still be synchronously loaded adding a new controller action to compute all and only the content needed by eand render the new view file created above separated from the computation for other tags on the same web page that will still be carried out synchronously authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
!
!
!
!
!
!
!
fig.
refactoring for asynchronous loading replacing ein the original view file with an ajax request and adding a new routing rule so that the ajax request will invoke the new action in which then renders the view in asynchronously.
the first item is straight forward to automate.
panorama simply moves the html tag einto a newly created view file like iss cnt.html.erb figure where iss cnt corresponds to the name of the new controller action that panorama will generate.
the second item is implemented by panorama in three steps.
it first identifies all ruby variables used by e like count in figure and then applies static backward slicing to find all code statements cthat are used to compute those variables like count user.issues.active.count in figure .
specifically panorama starts from all the adg nodes associated with the specific html tag id and traces backwards in the adg to identify all nodes inside the corresponding controller that ehas control or data dependence on.
panorama next applies forward taint analysis to see if any statement c cis used to compute any other html tag e prime.
if such an e primeis found there is a dilemma about whether to render e primeasynchronously rendering e primeasynchronously could potentially cause many other html tags which share common backward slicing fragments with e prime to be rendered asynchronously and violate the design principle discussed in section v b1 yet rendering e primesynchronously incurs extra overhead as cnow needs to be computed twice once for e and once for e prime.
hence panorama currently considers eas unsuitable for asynchronous loading if e primeexists.
panorama finally moves the slice identified earlier to a new controller action like iss cnt in figure the deletion from the previous controller is not shown for simplicity and add a rendering statement at the end of the action like render partial iss cnt in figure to render the same content in the same format as the original web application using the newly created view file.
panorama conducts the third item leveraging the render sync library to replace the original html tag with render async path figure where render async is an api call that issues an ajax request for the specified action using jquery .
panorama then adds a new rule into the routing file to connect the ajax request with the action it just created.
as shown in figure this new routing rule follows the template get controller where action is the name of new action name and home is the controller holding the action .
!
!
!
!
!
!
fig.
refactoring for approximation c. display accuracy change approximation approximation is a widely used approach to improving performance and saving server resources .
past database research also proposed approximated queries .
however many techniques require changes to database engines and hence cannot be applied to web application refactoring.
panorama focuses on approximating aggregation queries whose results are displayed as numeric values on web pages as such approximation can be simply conducted by refactoring rails code and easily reasoned about by web viewers.
for example redmine is a project collaboration application like github.
its user index page lists all the recent activities of a user all projects a user is involved in with pagination as well as two counts showing how many issues are currently assigned to and have been reported by this user.
although these two numerical counts occupy tiny space on the web page they can take more time even more than second to render than the remaining page when a user is involved in hundreds of or more issues.
one way to keep the page responsive is to set an upper bound to such a count like and only shows the count to be more than when it is too big when a count is too big users probably does not care about the exact number anyway.
identifying opportunities panorama iterates through all aggregation including maximum minimum average and count queries in the application.
for each query panorama checks its corresponding adg node s out going data flow edges to see if the query result is only used in html tag rendering.
if so an approximation opportunity is identified for corresponding html tag s .
note that panorama does not suggest approximating an aggregation query if its result affects an html tag through control dependency as that type of approximation may cause program execution to take a different path and hence potentially leads to large deviation from original program behaviors.
generating patches an approximation refactoring includes two parts.
on the controller side panorama appends a limit n clause to the end of the aggregation query identified above with the constant nconfigured by web developers.
on the view side instead of directly displaying the numeric query result changes are made depending on the aggregation query type.
for a count query panorama inserts a conditional statement to check the aggregation result if the result is smaller than nthen the accurate numerical result is displayed otherwise more than n as shown in figure for an average query panorama adds about before the numeric query result rendered in the html tag for a maximum or authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
fig.
code change for removing minimum query panorama adds at least o r at most before the numeric query result.
d. display contents removal obviously one can remove an html tag to speed up the page loading.
this strategy is indeed used in practice as the tracks example discussed in section i. whether an html tag is worthwhile to display cannot be determined automatically.
instead what panorama can do is to make the removal easy and error free so that developers can easily try out different design options and eventually make an informed decision.
identifying opportunities removing an html tag e does not guarantee to save page loading time because if the expensive computation needed by eis also needed by other html tags removing ealone will not help performance much.
the current prototype of panorama only suggests removing an html tag eif its contributing query that is not fed to any other html tag.
this way removing ecan guarantee to save some data processing time.
of course future work can relax this checking criterion.
generating patches removing an html tag efrom the web page again involves changes to both the view component and the controller component of a web application.
on the view side panorama simply removes the specific html tag.
on the controller side panorama again analyzes controldependency and data dependency graph to remove code that was used only to help generate e. to do so panorama first identifies all the nodes in adg that are associated with e s id.
panorama deletes those nodes removes all condition checking whose two branches now execute exactly the same code because of those node deletions and then check if there are any other adg nodes that become useless and should be deleted a node is useless if it has no out going data dependency or control dependency edges.
panorama repeats this process for several rounds until no more nodes are identified as useless.
we use the view file code snippet in figure 8a as an example.
the html tag shown here corresponds to the sidebar that lists all projects in the tracks example discussed in figure .
given this tag panorama first identifies the ruby expression active projects and then checks the adg to see how active projects is computed in the controller figure 8b .
panorama also finds out that the active projects computed in figure 8b is not used in anywhere else.
consequently the content removal change will simply delete the sidebar tag in the view file and the corresponding computation in the controller file as shown in figure .
fig.
an example of panorama browser interface vi.
t hepanorama interface panorama comes with a new interface to present the cost estimation and optimization information and help developers explore different web page design options.
we discuss the panorama interface in this section.
a. information display in browser showing view centric cost estimation information.
panorama visualizes the performance information obtained by dynamic profiling or static estimation section iv through a heat map with the more costly html element having a more red ish background as illustrated in figure .
to generate this heat map panorama reads the output of its view centric cost estimation section iv and creates a javascript file interactive.js that sets the background color of every html tag through tag id .css background color color where tag id is the unique html tag id and color is computed based on the cost estimation for this html tag section iv .
web developers can choose to see different heat maps with buttons on the web page like real time dynamic profiling results and relative statically estimated results in figure .
we set the color using the hsl color scheme with more expensive tags rendered with smaller hue values i.e.
more red ish and cheaper tags with larger hue values i.e.
more blue ish .
showing view aware optimization suggestions.
interactive.js described above helps display not only data processing cost but also alternative view design options for various html tags.
users simply right click an html tag in the browser to get a list of design options as shown in figure .
the implementation is straight forward given the unique id of every html tag and the performance enhancing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
panorama interface implementation opportunities identified through panorama static analysis as discussed in section v. b. design space exploration in browser to help developers explore different performance functionality design trade offs panorama further connects the browser side information display and the ruby editor side refactoring together developers first understand the data processing cost of various html tags in the browser once developers choose an alternative design option for an html tag the corresponding code refactoring will be automatically applied and displayed in the accompanying ruby editor for developers to review once the source code is updated the heat map in the browser is updated accordingly.
developers can explore different design options and eventually pick the best ones that suit their need.
to support this interface panorama carefully uses javascript ide plugin and other mechanisms to help the communication between the browser and the ruby editor as illustrated in figure .
first panorama automatically instruments the web application under development to help communicate developers design choices to the ruby editor.
specifically panorama adds a controller pano handle request into the web application.
whenever developers click a design option button like one of those blue paginate async approximate remove buttons in figure panorama will send an http request to invoke the pano handle request controller action circlecopyrt in figure which then records the design option type and the corresponding html tag id into a web server side file request.log circlecopyrtin figure .
in the editor which we use rubymine panorama uses a thread to monitor the request.log file.
whenever this file is changed this monitoring thread will trigger the plugin to apply corresponding code refactoring in the ide with all the code changes generated using algorithms described in section v circlecopyrtin figure .
after the code change the data processing cost estimation will be updated automatically which results in updates to a performance profile and corresponding updates to interactive.js with changed background color settings circlecopyrt in figure .
the changes in interactive.js lead to an automated refresh in the browser with the updated heat map 1the current prototype of panorama assumes that the web application under testing is deployed on the same machine as the ruby editor.table i opportunities detected by panorama in apps app ds lo gi re sp ro fu tr da on ff os sum pagi.
approx.
remo v a l12070412220 asynch sum display as we use the ruby react rails hot loader to enable automated refresh at every change in the ruby source code or heat map display code circlecopyrtin figure .
vii.
e v aluation our evaluation focuses on three research questions rq1 can panorama identify view aware optimization opportunities from latest versions of popular web applications?
rq2 h o w much performance benefits can view aware optimization provide?
rq3 is the performance functionality trade off space exposed by panorama worthwhile for developers to explore?
rq4 does panorama estimator estimate the per tag dataprocessing cost accurately?
a. methodology applications.
we evaluate panorama using a suite of open source ruby on rails applications including top most popular ruby applications from major categories of web applications on github discourse ds and lobster lo are forums gitlab gi and redmine re are collaboration applications spree sp and ror ecommerce ro are ecommerce applications fulcrum fu and tracks tr are task management applications diaspora da and onebody on are social network applications openstreetmap os and fallingfruit ff are map applications.
they have all been actively developed for years with hundreds to tens of hundreds of code commits.
workload.
since we cannot obtain real world user data we use synthetic data generation scripts released by previous work that to populate the databases following real world data distribution and statistics.
similar to we use the number of records in a web application s main database table to describe the workload size.
by default we use a record workload unless otherwise specified.
to our best knowledge allthe database sizes used in our evaluation are similar or smaller than the sizes in real world web applications.
platform.
we profile the rails applications on aws cloud9 platform which has .5gb ram and a core cpu.
b. rq1 how many opportunities does panorama identify?
as shown in table i panorama can indeed identify many view aware optimization opportunities.
specifically panorama static analysis identifies performance enhancing opportunities from the current versions of our benchmark applications.
every type of optimization opportunities is identified from at least applications.
these opportunities apply to unique html tags.
for html tags only one view change suggestion is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii speed up of view changes pagination asynchronous approximation content removal id ro1 tr1 fu1 re2 on1 re1 lo2 on5 re2 on2 tr2 on3 lo1 re3 on4 server time speedup x .
.
.
.
.
.
.
.
.
.
.
.
.
.
server time speedup x .
.
.
.
.
.
.
.
.
.
.
.
.
.
every case is denoted by application short name id table iii database sizes and page load time of user study cases pagination asynchronous approximation content removal id re1 ro1 tr4 re4 tr3 lo1 re2 tr1 di1 lo2 tr5 tr6 db size k record .
base page load time s .
.
.
.
.
.
.
.
.
.
new page load time s .
.
.
.
.
.
.
red ids are cases from existing issue tracking systems the other cases are all in latest versions discovered by panorama.
every case is denoted in the same way as table ii with common cases.
made.
for the remaining panorama suggests two or three changes.
particularly there are html tags where removal and asynchronous loading both apply.
overall these four types well complement each other.
c. rq2 how much performance benefits?
to quantitatively measure the performance benefits of these alternative view designs we randomly sampled optimization opportunities identified above with and cases from pagination asynchronous loading approximation and content removal respectively in different applications.
for each application before and after optimization we run a chrome based crawler that visits links randomly for hours and measure the average end to end latency and server cost of every action.
we then compute speedup accordingly.
as shown in table ii the performance benefits of these view changes are significant.
by changing only one html tag these cases on average achieve .
speed up on the server side and .
speed up for end to end page load time.
among the four optimization types pagination asynchronous loading and content removal have cases where the end to end page load time achieves about or more than speedup.
d. rq3 are alternate view designs worthwhile?
we evaluate the quality of a web page from two aspects how much users like the performance and functionality of a web page how much resources are needed to generate the page on the server side.
allfour types of view changes suggested by panorama can help save server resources pagination approximation and content removal all reduce tasks that need to be done by web and database servers asynchronous loading provides more scheduling flexibility to servers.
therefore we believe an alternative web design is worthwhile for developers to explore as long as users feel pages under this new design is not worse than the original one.
to evaluate this we conduct a thorough user study.
user study set up we recruited participants on amazon mechanical turk mturk .
these participants are allmore than years old and living in the united states with more than mturk task approval rate.
our benchmark suite includes web pages from web applications.
for each of these baseline pages panorama automatically generates a new page with exactly one html tag changed.
we refer to the original page as base and the one optimized by panorama as new .
these web pages cover all four types of view changes with exactly cases in each type.
furthermore for every change type2 we cover one case from on line issue reports these changes were already adopted by developers to fix performance problems in previous versions of web applications and some cases discovered by panorama in current versions of these applications.
we also reuse cases from table ii as much as we can.
since the performance advantage of new pages depends on the database size to ease comparison we populate the database for each benchmark so that the load time difference between the base version and the new version is exactly .
seconds.
the detail settings are shown in table iii.
each participant is assigned tasks.
in each task they are asked to click two links one by one and then answer questions about which page they think is faster performance in table iv which page they think delivers more or better organized content functionality in table iv and which page do they like more with everything considered overall in table iv .
these two links are the base and new versions of one benchmark with random ordering between them.
user study results a summary of the user study results is shown in table iv and the questionnaire and raw data are available on panorama webpage .
in this table we show the percentage of users who think new is better minus those who think base is better which we refer to as the netbenefit of the new design for every type of refactoring and every question performance functionality and overall .
users are given the two pages in random order and are not aware of the view design difference between the two pages in advance.
a short answer to our research question is yes .
in fact 2except for approximation as we did not find performance issue reports in these web applications that are solved by approximation.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv net user perception enhancement by new design users who prefer new users who prefer base approximation asynch paginate removal performance .
.
.
.
functionality .
.
.
.
overall .
.
.
.
for all type of view changing optimization users think the new design is not worse than the base design.
particularly for asynchronous loading pagination and removal the new designs clearly win more users than the baseline designs.
in terms of performance the net win for the new design is clear.
many users indeed notice the .
second difference in the page load time.
in out of cases the new design has a net positive benefit on more than of the participants.
in terms of functionality the results are quite interesting.
for approximation and pagination many users did notice the content difference leading to the base design winning about of users.
however for asynchronous loading and content removal surprisingly many users neither notice the content difference nor think new design delivers worse contents.
it could be that removing contents made the page cleaner to some users.
for example after removing the sidebar in tracks tr5 in table iii some participants like it because adding the sidebar makes scrolling harder.
in terms of overall perception the new design has a net win.
among the four types of optimizations paginations and asynchronous loading are the most appealing to users while approximation is the least appealing.
we also conducted another set of user study with another participants where we use an even larger database size and hence make the page load time differences between new design and base design even bigger seconds .
we do observe that more participants noticed the performance advantage of the new design.
however we also observe that the overall perception only goes up a little bit more for the new design.
we skip the details for the space constraints.
e. rq4 how accurate is the panorama estimator?
we use the web page shown in figure as a case study.
html tags on this page render dynamically generated contents.
with database records dynamic profiling shows that the story tag is the top performance bottleneck followed by the guideline tag and then the message count the cheapest.
when the workload increases to and records dynamic profiling shows that the guideline tag is the top bottleneck followed by the story tag.
these results match the performance gains we can get by optimizing these three tags using records asynchronously loading or removing the guideline text can reduce the page end to end load time by more than second paginating the story tag can speed up the page load time by about milliseconds approximating the message count does not change page load time.
the static mode of panorama estimator can indeed predict performance bottleneck without running the application the guideline text gets the highest complexity score among all15 tags followed by the story tag and then the messagecount tag with the remaining tags getting points.
f .
threats to validity threats to the validity of our work could come from multiple sources.
internal validity the html tags that are dynamically generated through javascript can not be detected or analyzed by panorama.
external validity the applications in our benchmark suite may not represent all real world applications the synthesized databases may not represent real world workloads the machine and network settings of our profiling may differ from real users setting the participants of our user study from mturk may not represent all real world users.
overall we have tried our best to conduct an unbiased study.
viii.
r elated work a orm performance problems much previous work aimed to identify specific performance problems of web applications built with orm framework like unnecessary data retrieval in applications anti patterns like the so called n query problem sub optimal database physical design computation that is more efficient to compute inside the database and general database aware data flow optimization .
however all prior work focuses on view preserving optimization that does not change web page design.
we instead show that by changing the view design there are many performance enhancing opportunities and we build panorama to interactively help developers make such design performance trade off decisions.
b detecting and fixing performance bugs plenty of research aims to detect and fix performance problems of general purpose software such as loop inefficiency temporary object bloating inefficient data structure etc.
detecting and fixing performance bugs of cross stack web applications built upon orm frameworks requires different techniques.
ix.
c onclusion it is increasingly challenging to develop web applications that can deliver both good functionality and desired performance.
we present panorama a tool that helps web developers explore the performance functionality trade off space in their web application design.
the panorama estimator provides developers with data processing cost information for every html tag that renders dynamically generated data while the panorama optimizer identifies and automates viewchanging refactoring that can greatly improve performance.
the panorama interface integrates estimator and optimizer together to enable effective web application design.
x. a cknowledgement this work is supported in part by the nsf through grants ccf cns iis1546543 oac darpa award fa8750 doe award de sc0016260 the intelnsf capa center gifts from adobe google huawei and ceres research center for unstoppable computing.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.