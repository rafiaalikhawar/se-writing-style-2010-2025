straighttaint decoupled offline symbolic taint analysis jiang ming dinghao wu jun wang gaoyao xiao and peng liu college of information sciences and technology the pennsylvania state university university park pa usa jum310 dwu jow5222 gzx102 pliu ist.psu.edu abstract taint analysis has been widely applied in ex post facto security applications such as attack provenance investigation computer forensic analysis and reverse engineering.
unfortunately the high runtime overhead imposed by dynamic taint analysis makes it impractical in many scenarios.
the key obstacle is the strict coupling of program execution and taint tracking logic code.
to alleviate this performance bottleneck recent work seeks to o oad taint analysis from program execution and run it on a spare core or a di erent cpu.
however since the taint analysis has heavy data and control dependencies on the program execution the massive data in recording and transformation overshadow the bene t of decoupling.
in this paper we propose a novel technique to allow very lightweight logging resulting in much lower execution slowdown while still permitting us to perform full featured o ine taint analysis.
we develop straighttaint a hybrid taint analysis tool that completely decouples the program execution and taint analysis.
straighttaint relies on very lightweight logging of the execution information to reconstruct a straight line code enabling an o ine symbolic taint analysis without frequent data communication with the application.
while straighttaint does not log complete runtime or input values it is able to precisely identify the causal relationships between sources and sinks for example.
compared with traditional dynamic taint analysis tools straighttaint has much lower application runtime overhead.
ccs concepts security and privacy !software security engineering information ow control software reverse engineering keywords taint analysis decoupling o ine symbolic taint analysis .
introduction taint analysis as a special form of dataow analysis has a variety of compelling applications in securitytasks.
in addition to the runtime enforcement security policies taint analysis on the binary code is also broadly used in ex post facto security applications such as attack provenance investigation computer forensic analysis malware analysis and reverse engineering .
static taint analysis sta aims to reason the causal data ow relationships between sources and sinks prior to execution.
however static taint analysis is not precise enough when the source code is unavailable especially for the obfuscated binary code.
on the other hand dynamic taint analysis dta propagating taint tags along the program execution path is accurate in many scenarios wherein static taint analysis cannot achieve the needed precision.
however dynamic taint analysis typically su ers from a high performance penalty.
in general the state of the art dynamic taint analysis tools such as libdft typically impose more than a 6x slowdown.
in the worst cases the slowdown can easily go up to 30x .
the high runtime overhead imposed by dynamic taint analysis has severely limited its application scope.
the key obstacle to further improving the performance of dynamic taint analysis is the tight coupling of program execution and taint tracking logic code .
taint analysis has to maintain a shadow memory to map instruction operands to their corresponding taint tags.
to propagate one taint tag between di erent residences it typically takes additional instructions .
in addition since the taint tracking code is interleaved with the program execution the frequent context switches between the application and taint analysis code impose further pressure on both registers and data cache e.g.
register spilling and cache miss incurring substantial overhead.
to lower the high performance overhead multiple methods have been proposed to o oad taint tracking code to a separate core or a di erent cpu.
the existing work can be roughly classi ed into two categories.
the rst category relies on the pervasive multi core systems to parallelize dynamic taint analysis by logging runtime values that are needed for taint analysis in another core .
however since taint analysis has strong serial data and control dependencies on the program execution the parallelized taint analysis need to be frequently synchronized for data communication e.g.
control ow directions and memory addresses either through customized hardware or shared memory .
the second category rst records the application execution and then replay the taint analysis on a di erent cpu .
similar to the limitation of the rst category the large online logging data is also a barrier to achieving the expected performance gains.
in this paper we propose straighttaint a hybrid static permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
and dynamic method that achieves very lightweight logging resulting in much lower execution slowdown while still permitting us to perform complete o ine taint analysis with incomplete inputs.
in principle straighttaint belongs to the aforementioned second category of decoupling dta approaches.
therefore straighttaint is an ideal t for ex post facto security applications.
in straighttaint we do not log all runtime values.
instead we record control ow pro ling and execution state when taint seeds are rst introduced which can be very lightweight.
based on the logged branching information we construct a straight line code trace for the o ine taint analysis.
the taint seeds are marked as symbolic variables and taint propagation is like the symbolic execution on the constructed straight line code.
with the initial execution state and the straight line code most addresses of memory load and store operations are computable.
symbolic memory indices can be narrowed down to a small range by solving the path conditions.
compared to a pure static approach straighttaint can still deliver a similar level of precision as dynamic taint analysis.
for example we are able to correctly identify the complicated causal relationships among multiple sources and sinks see section while static taint analysis fails in such cases.
restricted by computing resources conventional dta exhibits several drawbacks in terms of incomplete taint propagation strategies.
first since multi tag taint propagation consumes more shadow memory and introduces much higher runtime overhead most dta tools choose single tag propagation as default .
however multi tag taint analysis is indispensable to many reverse engineering tasks such as recovering the structure of an unknown protocol format and detecting encoding functions in malware by counting di erent tainted input bytes .
second when handling the complicated x86 arithmetic and logic operation instructions e.g.
addand xor previous dta tools typically adopt some simple but conservative propagation strategies for better performance.
one example is the prevalent short circuiting method the destination operand is tainted if any of the source operands is tainted.
as we will show these conservative solutions will result in precision loss in many scenarios.
as straighttaint has completely o oaded the taint logic code to the o ine analysis another bene t becomes visible straighttaint s o ine taint analysis is exible to support full featured taint propagation strategies.
for example supporting bit level or multi tag taint analysis is straightforward in our approach.
each symbolic bit or variable can naturally represent a taint tag with negligible additional overhead.
also our symbolic execution style taint propagation can faithfully simulate the speci c semantics of an instruction.
furthermore based on symbolic taint analysis on the straight line code we introduce a new concept conditional tainting that is straighttaint is able to identify precisely the causal data ow relations between sources and sinks under what conditions .
in this way new inputs and runtime values can be mapped to the existing analysis results in certain scenarios so that the new analysis can be more proactive.
we have developed a prototype of straighttaint a hybrid taint analysis approach that completely decouples the program execution and taint analysis.
our implementation is based on pin for the e ective parallelization of runtime logging and bap for precise o ine symbolic taint analysis with incomplete inputs.
we have performed comparative studies on a number of applications such as common utility programs spec2006 and real life softwarevulnerabilities.
the results show that straighttaint can achieve a similar level of precision as dynamic taint analysis but with much lower online execution slowdown.
the performance experiments show that straighttaint imposes a small overhead on application execution performance with up to 25times improvements to spec2006 on average.
o ine taint analysis takes approximately the same amount of time as an advanced dta tool.
we also demonstrate straighttaint s value in supporting multi tag taint propagation and conditional tainting in an attack provenance investigation task.
such experimental evidence shows that straighttaint can be applied to various large scale ex post facto security applications.
in summary we make the following contributions .we propose straighttaint with a very lightweight logging method to construct straight line code and thus completely decouple dynamic taint analysis for o ine symbolic taint analysis.
straighttaint greatly reduces the program execution slowdown yet can compete with dynamic taint analysis with a similar level of precision.
.the limitation of previous decoupling taint work is ine ciently collecting and transferring data from the executing application to the analysis module.
we demonstrate that straighttaint o ine analysis does not require complete runtime data but can still achieve most tasks.
.the completely decoupled o ine taint analysis allows straighttaint to perform full featured taint propagation strategies.
the symbolic execution style taint propagation can accurately describe the intricate semantics of the x86 instructions and also naturally support multi tag and bit level taint analysis.
.we introduce a new concept conditional tainting based on the symbolic taint analysis of straight line code.
conditional tainting not only reports more precise and useful taint results but also opens many new important applications.
we also summarize the main bene ts associated with our proposed taint analysis method.
.once a log is captured it can be analyzed by straighttaint multiple times.
this feature is particularly useful when the exact analysis task is hard to anticipate.
in our multi tag taint propagation evaluation we vary the number of taint tags in each round.
straighttaint only needs to log the required online data once and performs the multiple propagation rounds o ine.
.straighttaint makes it possible to conduct ex post facto logging based taint analysis in the cloud .
service providers can deploy lightweight online logging in their services and cloud hosts provide storage space for the logged data.
users can require a service to audit their sensitive data ow o ine.
the rest of the paper is organized as follows.
section provides the background information and an overview of our approach.
section describes e cient online logging and our optimization.
o ine symbolic taint analysis is discussed in section .
section .
highlights a few of our implementation choices.
we present the evaluation of our approach in the rest of section and demonstrate its applications in section .
related work is presented in section .
we conclude the paper and discuss future work in section .
.
background and overview .
dynamic taint analysis optimization dynamic taint analysis dta is a form of information ow analysis to trace the tainted data along program execution path.
typically the data derived from untrusted sources are labeled as tainted i.e.
taint seeds .
the propagation of the tainted data will be tracked according to the taint propagation policy.
then the taint status will be checked at certain critical locations i.e.
taint sinks .
dta has been broadly employed in software security applications.
however an inherent limitation of conventional dta is that taint logic is strictly coupled with program execution.
figure illustrates a conventional dta tool built on dynamic binary instrumentation dbi .
the taint tracking code is interleaved with program execution leading to frequent context switches and resource competitions between the application and taint analysis code.
as a result the application under examination is signi cantly slowed down.
various advanced dta techniques have been proposed to achieve decent runtime performance .
for example minemu leverages the x86 sse registers to provide lightweight taint tracking for bit applications.
unfortunately they either rely on an ad hoc emulator or cannot work on commodity hardware .
decoupling taint analysis from program execution has been demonstrated as an e ective approach.
however due to the heavy data and controlow dependencies on the application execution decoupled taint analysis cannot run independently.
intuitively each memory address and control transfer target have to be delivered to the decoupled taint analysis.
therefore the large logged data is a barrier to further improving the performance.
as shown in figure our key insight is that taint analysis can be completely decoupled from program execution without frequent online communication and synchronization.
o ine taint analysis can be performed based on control ow information and very little runtime data e.g.
the initial execution state when taint seeds are introduced .
we notice that memory reference operations in x86 architecture are addressed through registers and constant o set calculations.
for example mov ebx loads the content stored at the address eax toebx.
with the initial execution state and the straight line code most memory reference addresses can be recovered.
the proposed straighttaint explores this idea.
note that the execution replay work which records required inputs and replays them on an o ine analysis can be applied to decouple taint analysis as well.
compared to straighttaint the logs are smaller and the online performance could be better.
however the logged data contains little information about execution making it impossible for direct taint analysis.
furthermore the o ine replay overhead is quite high.
for example aftersight replays a single tag taint analysis on a qemu based cpu simulator but the performance is as high as 100x slowdown.
our solution represents a middle ground that balances the performance between online logging and o ine taint analysis.
.
incomplete taint propagation strategies as conventional dta tools are subject to limited computing resources typically they have to adopt incomplete taint propagation strategies to achieve acceptable performance.
in many cases such conservative strategies lead to the precision loss.
the rst drawback comes from the singletag propagation.
most dta tools associate each variable online offline straight line code constructorsymbolic taint analyzerapplication dbilogging toolfigure the architecture of straighttaint.
with one shadow memory bit or byte to represent the taint status means tainted and means untainted.
although single tag works in some simple scenarios multi tag taint analysis has much broader security applications.
for example bitfuzz assigns di erent taint tags to input bytes and then detects encoding functions in malware by identifying high taint degree ibinhunt utilizes multi tag taint analysis to reduce the number of possible basic blocks to compare.
furthermore many arithmetic and logic operation results overlap the operands so that a taint tag may come from multiple sources.
therefore the multi tag attribute is essential for accuracy as well.
the second limitation is due to the conservative propagation strategies when dealing with the complicated x86 instructions.
these simple strategies are fast but neglect the particular instruction semantics that may a ect the taint propagation results.
in addition to the frequently used short circuiting solution some previous work tracks the taint ow only through unary operations the output of a binary operation is set as untainted to achieve better parallelization .
figure presents a snippet of an encoding function which is frequently used in malware .
figure a lists a straight line code with complicated arithmetic operations.
conventional dta performs the taint analysis on this code snippet with single tag and short circuiting strategies.
figure b shows the propagation results all variables are tainted.
look carefully at line in figure a the taint tag of variable wderives from two taint seeds but conventional dta just labels it as a single tag.
besides the variable dwill always be zero because cis the bitwise not ofa.
however the short circuiting propagation mistakenly label das tainted resulting in over tainting .
a nature bene t of straighttaint s o ine taint analysis is that supporting fullfeatured taint propagation strategies is straightforward such as multi tag and bit level taint analysis.
also our symbolic taint analysis on the straight line code can capture intricate details of the x86 instructions.
figure c shows the results of straighttaint multi tag symbolic taint propagation wand care correctly tainted the taint tags of dare cleaned as expected.
straighttaint avoids the imprecision and overtainting problems introduced by previous incomplete taint propagation strategies.
.
architecture figure illustrates the architecture of straighttaint which consists of two stages online logging and o ine analysis.
the rst stage as shown in the left part of figure involves very lightweight online logging to mainly record control ow information.
we built a logging tool using dynamic binary instrumentation dbi enabling straighttaint to work with unmodi ed program binaries directly.
the application under examination is executing over the dbi and our logging tool.
our logging tool dynamically instruments each executed basic block to record the execution using tags that are unique for each basic block.
the basic block tags are written to a trace 310dbidynamic taint analysisapplicationcontrol flow profilingapplication speedupconventional dta straighttaint symbolic taint analysistimeonline offline taint seeds initial statefigure conventional dta vs. straighttaint.
int a b c d w int low bits 0x 0000ffff int high bits 0x ffff0000 a read b read w a low bits b high bits c a d a c a b taint a taint b taint w taint c taint d taint a tag1 taint b tag2 taint w tag1 lo w bits tag2 high bits taint c tag1 taint d c figure conventional single tag taint propagation vs. straighttaint multi tag symbolic taint propagation a a sequence arithmetic operations b conventional single tag taint propagation results c straighttaint multi tag symbolic taint propagation results.
bu er and then stored in a disk storage when the bu er is lled up.
careful design of the online logging tool is crucial for achieving better e ciency.
therefore we propose three guidelines and the details will be discussed in section .
the generated log data is passed to the o ine taint analysis the right component of figure .
this stage rst reconstructs the straight line code trace from the log data and then lifts the x86 instructions to bil an risclike intermediate language.
the core of our symbolic taint analyzer is an abstract taint analysis processor.
similar to the shadow memory in dta straighttaint maintains acontext structure to store symbolic taint variables and concrete values.
our o ine taint analyzer is able to carry out both forward taint tracking to detect the e ect of an intrusion and backward tracing to identify attack provenance.
even without complete runtime data information straighttaint can achieve comparable precision as dynamic taint analysis which will be discussed in detail in section .
.
efficient online logging straighttaint applies a lightweight logging to lower the impact on application performance.
since not all the instructions executed are of interest we invoke online trace logging when pre de ned taint seeds are rst introduced.
in straighttaint a user can set the input data from keyboard le network or function return value as taint seeds.
to avoid symbolic taint variables explosion in the o ine analysis we leverage the concrete execution state when the taint seeds are introduced to constrain fresh symbolic taint variables.
we collect an execution state by performing a process dump.
beyond that the executed control ow information is logged to reconstruct the straight line code later.
nondeterministic variables e.g.
random numbers and time that may a ect control ow are recorded as well.
the logged data are rst stored in a memory bu erand then dumped to disk storage when the bu er is lled up.
three design goals guide us to achieving low online logging overhead the logged data representation should be compact so that trace bu er holds as much data as possible the application i.e.
producer should not be blocked when the full bu ers are being consumed that is processing the bu ers asynchronously instrumentation overhead should be minimized.
we meet the rst requirement by extending an advanced trace pro ling format .
to address the second challenge we propose an n way fast bu ering scheme on multi cores to parallelize pro le consumption.
at last we carefully design our instrumentation code to favor code inlining and avoid frequent context switches.
in section .
we will introduce other pin speci c optimizations we adopted to achieve enhanced performance gains.
.
trace profiling application s straight line trace can be represented as a sequence of basic blocks executed.
a basic block is a straightline sequence of code with one entry point and one exit.
a naive approach is to record each basic block s entry address.
on a bit machine a byte tag is needed to label a basic block.
however a full byte tag is an excessive use and would take up too much space.
zhao et al.
proposed an e cient method detailed execution pro le dep .
dep uses only byte tags to record most basic blocks and handles special cases with extra escape bytes.
dep splits a byte address into high bytes for h tag and low bytes for l tag .
during control ow pro ling if two sequential basic blocks share the same h tag only l tag of each basic block is logged into the pro le bu er.
if the two h tags are di erent an escape tag 0x0000 followed by the new h tag will be entered into the bu er.
our trace pro ling design is based on dep with a number of optimizations.
certain x86 string instructions movs lods stos cmps and scas with rep pre x execute repeatedly.
dbi tools usually treat rep pre xed instructions as implicit loops.
if arep pre xed instruction iterates more than once iterations after the rst will cause a single instruction basic block to be generated.
in such case we ll see much more basic blocks than we expect.
to address this issue we inspect the rst loop of rep pre xed instructions and con gure pin to disable unrolling following loops.
and then we encode rep pre xed instructions with two consecutive escape values 0x followed by an iteration number.
we justify here why we choose to encode the basic block executed rather than control ow branching decision or pin trace.
first it is possible to use a single bit to log a basic block by recording the binary decision of conditional jump which leads to a much denser log data.
however encoding bit does not favor pin code inline which introduces more instrumentation overhead.
also recovering straight line code from bit encoding is time consuming.
second the single entry multi exits property of pin trace makes the trace size cannot be uniquely decided.
third static program analysis can be used to remove the redundant instrumentation points.
however recall that straighttaint works in an adversarial environment in which the accurate static features such as control ow graphs are typically not available.
our design choice enables straighttaint to analyze obfuscated binaries.
.
multithreaded fast buffering scheme in this section we introduce our generic scheme that supports concurrent bu ering data on the multi core platform.
we exploit underutilized computing resources to alleviate the disk i o bottleneck.
the center of our design is a bu ering thread pool in which multiple bu ers enable the instrumented application to continue executing and lling up free bu ers while multiple pin tool internal threads process full bu ers asynchronously.
figure illustrates how the bu ering thread pool works and the processing steps are as follows.
when a program starts running the application i.e.
producer allocates a number of free bu ers 8bu ers in figure .
simultaneously multiple pin tool internal threads are spawned.
we call them worker threads worker threads in figure .
the worker thread takes a bu er from the fullbu er queue and dump bu er data to disk storage.
multiple worker threads access a full bu er exclusively by acquiring the bu er s lock.
the application rst lls one free bu er.
when this bu er becomes full a callback function bu erfull will be called to perform two tasks enqueue the full bu er to the global full bu er queue and wake up one worker thread to process it return the next available free bu er to the application.
we bias the implementation of our bu ering scheme to lower the impact on the application execution.
speci cally we create enough worker threads to ensure a full bu er can be processed immediately by worker threads.
besides we dynamically adjust the number of bu ers allocated and the number worker threads created to optimize the synchronization and load balancing.
the availability of unused cores and the size of a pro le bu er have a great impact on the runtime performance.
in section .
we will discuss how to tune these two factors.
1the maximum rep pre xed loop count in our evaluation comes from gccbenchmark which is far less than two byte number limit.
application producer free buffer queuewriting buffer enqueue worker thread worker thread worker thread worker thread full buffer queue worker threads enqueue free bufferfigure bu ering thread pool.
.
offline symbolic taint analysis .
reconstruction of straight line code given the trace collected from the online logging reconstructing a complete sequence of byte starting addresses of basic blocks is quite straightforward.
the beginning of the trace pro le should be a special value 0x0000 followed by an h tag.
each basic block byte entry address is the concatenation of its corresponding h tag and l tag.
then the x86 instructions of each basic block are extracted from the application s disassembly code.
an elaborate knowledge of the x86 isa is required to accurately track taint propagation at binary level.
however the cumbersome x86 isa makes it an extremely tedious work.
for example previous work such as libdft contains more than 000lines of code to handle the x86 isa complexity.
figure a shows such an example involving complicated arithmetic operations.
even worse some instructions with implicit side e ects only propagate taint conditionally according to the contents of eflags e.g.
cmovcc .
to get rid of the intricate details of the x86 isa we lift up x86 instructions to bil an risc like intermediate language.
bil leaves us only 25instructions that we need to analyze carefully for accurate taint tracking.
note that with control ow information we have resolved all indirect control ow targets and conditional jump directions in the straight line il code.
.
symbolic taint analysis by labeling the stream bytes of taint seeds as symbolic variables straighttaint o ine taint propagation is a kind of symbolic execution on the straight line code.
since each taint seed byte can be associated with a fresh symbol multitag taint propagation is natural for straighttaint.
the core of our symbolic taint analysis engine as shown in figure is an abstract processor which maintains a context structure as the execution state.
the context structure consists of a program counter pc a variable context vand a memory context m. for conciseness we represent the state of the abstract processor with the tuple s pc v m .
the variable context vcontains all symbolic register values e.g.
general purpose registers and bits of eflags and temporaries.
the temporaries are the expressions used in the static single assignment form of bil.
we also explicitly represent the return value of a function as a special variable to facilitate detecting bu er over ow vulnerabilities.
the memory context m with a structure analogous to the twolevel architecture of x86 virtual addressing is a mapping from memory addresses to their symbolic variables.
by interpreting the current il at pc a state of the abstract processor s pc v m is translated into a new state 312symbolic taint analysis engine straight line codeabstract processortaint logic constraintsz3 contexttaint seeds initial state sub trace cache virtual registers symbolic memorytemporariesfigure symbolic taint analysis engine.
neg r eg sbb r eg reg and r eg val1 val2 add r eg val2 a b if reg cf else cf reg reg reg cf reg reg val1 val2 reg reg val2 if reg reg val1 else reg val2 c figure example branchless logic code reg stands for register va1and val2 are two tainted variables .
s0 pc0 v0 m0 andv0andm0are updated according to the semantic of the il.
at the same time straighttaint checks whether a location of interest i.e.
taint sink is tainted by checking whether its value is a symbolic expression.
after the last il is simulated pcis set to halt andvand mare not updated anymore.
we start o ine taint analysis when the pre de ned taint seeds are rst introduced to the application.
besides the taint seeds there could be other uninitialized variables such as the stack pointer and memory contents.
in principle we can assign a fresh symbolic variable to each uninitialized variable.
however symbolic taint analysis with an unconstrained initial state can quickly reach the memory capacity and lead to the problem of over tainting as well.
our solution is to leverage a process dump to assign other uninitialized variables with concrete values only leaving the taint seeds as symbolic variables.
here we use another common example to show the value of symbolic execution style taint propagation.
to reduce the number of conditional jumps some compiler optimization options translate conditional instructions into a sequence of arithmetic operations.
figure a shows such an example we nd in our test cases.
figure b lists the semantics for each instruction.
the net result of the sequence of arithmetic operations is presented in figure c which is actually a branch condition.
the taint tag of regis either from val1 orval2.
straighttaint successfully propagate taint tags for this tricky case while previous tools such as temu libdft and flowwalker all fail.
.
memory reference address resolution another feature of straighttaint s o ine taint analysis is that we do not record memory reference addresses which are typically calculated through general registers and constant o sets.
our observation is that with the initial execution state and the straight line code most memory reference addresses can be decided along the symbolic taint analysis.
figure a shows how we resolve an indirect memory access.
since we have resolved each indirect jump target in the i read j read j j a ibb1 jmp eax bb2 mov ebx a indirect memory access b symbolic memory indexfigure example memory reference address resolution.
straight line code see section .
the memory indirect access through eaxinbb2can be determined.
to solve a memory address address a that is cannot be computed accurately e.g.
heap memory allocation we allocate memory on they.
inspired by micro execution we use return value of malloc asaddress a which guarantees that address a would not con ict with an existing address.
then we assign a symbolic variable to represent the content ofaddress a and subsequent reading at address a will return the same symbolic value.
a symbolic index happens when a symbolic variable is used as the index of a memory lookup such as the conversion function of ascii to unicode tolower and to upper.
intuitively a symbolic memory index could point to any memory slot.
we deal with this problem by solving path conditions.
as shown in figure b the path conditions along the straight line code restrict the range of symbolic memory index jwithin j .
then we conservatively label all the possible memory values as tainted.
for the example in figure b a a and a will be tainted.
.
conditional tainting as x86 conditional control transfer instructions typically depend on the value of the eflags register e.g.
jz and jo our virtual registers also keep track of bit level symbolic variables for eflags .
when a symbolic expression is used in a conditional jump instruction we collect it as a branch condition.
after a complete symbolic taint propagation run the conjunction of all branch conditions is the taint logic constraints .
thus the values that satisfy the taint logic constraints are the concrete taint seeds that would lead the program to execute the same taint tracking operations as the one symbolically tainted.
with taint logic constraints which are solved by a theorem prover e.g.
z3 previously taint analysis results can be mapped to new inputs and runtime values without dta again!
.
optimization like pin s block cache to save the overhead of frequently executed basic block retranslation we take a similar approach to speed up our o ine symbolic taint analysis.
we call it sub trace cache see sub trace cache component in figure .
we merge sequential basic blocks that have one predecessor and one successor as a sub trace which can be viewed as an extended basic block.
we represent the input output relations of a sub trace as a set of symbolic formulas and maintain a lookup table in the sub trace unit.
therefore the successive runs can directly reuse previous results without the need for recomputing them.
another 313primary optimization we adopt is function summary.
most well known library functions have explicit semantics e.g.
c strings manipulation functions de ned in string.h and many of them even do not a ect taint propagation e.g.
strcmp .
therefore we turn o symbolic taint analysis at the boundary of these functions and update context according to their semantics summaries.
for a sequence of adjacent memory access introduced by rep pre xed instructions we recover the number of repetitions from trace pro le and perform batch processing instead of byte by byte operations.
.
implementation and ev aluation .
implementation to demonstrate the idea of straighttaint we implemented a prototype including online logging based on the pin dbi framework version .
with 660lines of code in c c and o ine symbolic taint analysis engine on top of bap version .
with lines of ocaml code.
we rely on bap to convert assembly instructions to il and convert il expressions to cvc formulas.
we use z3 as our constraint solver.
the saving and loading of subtrace cache lookup table are implemented using the ocaml marshal api which encodes arbitrary data structures as sequences of bytes and then store them in a disk le.
when implementing the pin tool we create thread local storage tls slot to store and retrieve per thread bu er structure.
note that pin tools are unable to work with either pthreads library or win32 threading api.
we utilize the pin thread api to spawn worker threads and implement a counting semaphore using pin s own binary semaphore.
to make the best use of pin s code cache e ect we enlarge the maximum number of basic blocks per pin trace from 3to8.
we also use gcc s built in macro builtin expect to provide the compiler with the branch prediction.
furthermore we perform low overhead bu ering of data through pin s fast bu ering apis which support inlining a callback function when a bu er becomes full.
we also force pin to use fastcall calling convention to pass arguments via registers to avoid emitting stack access instructions i.e.
push and pop .
straighttaint s e cient multithreaded control ow pro ling pin tool is available at our testbed contains two machines.
one is a server machine which is equipped with two intel xeon e5 processors core with .9ghz and 128gb of ram.
another is a desktop consisting of intel core i7 processor quad core with .40ghz and 8gb memory.
both are running ubuntu .
.
the data presented throughout this section are all mean values.
we calculate them by running ve repetitions of each experiment case.
.
buffer size and worker threads we studied two factors that may a ect straighttaint online logging performance the bu er size of control ow pro le the number of available worker threads.
we rst survey the impact of various bu er size.
in order to achieve enough parallelism the number of worker threads is set to and respectively.
the total bu er sizes are therefore the number of worker threads single bu er size.
we choose spec cpu2006 with testworkload as the training set.
as shown in figure roughly the overhead decreases as the bu er size is increased.
this is mainly due to the reduction of free full bu er switches and worker threads spend less time on synchronization.
as the bu er size is beyond a certain s49 s50 s51 s52 s53 s54 s32 s32 s83 s108 s111 s119 s100 s111 s119 s110 s32 s40 s110 s111 s114 s109 s97 s108 s105 s122 s101 s100 s32 s101 s120 s101 s99 s117 s116 s105 s111 s110 s32 s116 s105 s109 s101 s41 s32 s49 s54 s45 s99 s111 s114 s101 s32 s32 s32 s52 s45 s99 s111 s114 s101 s50 s53 s54 s49 s50 s56 s54 s52 s51 s50 s49 s54 s56 s52 s50 s66 s117 s102 s102 s101 s114 s32 s115 s105 s122 s101 s32 s40 s77 s66 s41figure normalized slowdown on core and 4core systems when pro le bu er size varies.
point 64mb for the core system and 128mb for the core system the slowdown is increased a little.
we attribute this to the large total bu er sizes e.g.
256mb interfering with the application s working set.
then we x the bu er size to 64mb for the core system and 128mb for the core system and alter the number of worker threads.
in general the performance is better as more worker threads are added.
due to the maximum parallelism and the tuned bu er size worker threads with 64mb bu er size achieve the optimum result.
we set these two parameters as default con guration and conduct the following experiments on the core system.
.
straighttaint vs. libdft we rst compare straighttaint with libdft a state ofthe art inlined dta tool built on pin libdft bar .
in aid of evaluating the application performance slowdown imposed exclusively by straighttaint we develop a simple tool nullpin to measure pin s environment runtime overhead which runs a program under pin without any form of analysis nullpin bar .
we also measure the logging overhead without bu ering the pro le data to disk online no i o bar .
under this con guration the application never stalls to wait for free pro le bu ers which can represent the upper bound of performance improvement attainable by straighttaint.
viewed from a di erent angle online no i o bar also indicates the overhead introduced by pin s instrumentation.
all runtime data2presented in this section are normalized to application native execution time without running pin .
figure shows the normalized overhead of running spec cpu2006 int benchmark suite with reference workload.
since the reference workload is cpu intensive we expect that these results can estimate the worst case scenarios.
on average straighttaint s online logging exhibits a 06x slowdown to native execution while libdft lags behind as much as 96x indicating that straighttaint speeds up application execution by a factor of .
.
it is noteworthy that if taking nullpin as the baseline the slowdown exclusively introduced by straighttaint is only 97x while for libdft is 43x.
this number is in line with the observations by the previous work that is performing one taint propagation operation normally needs six extra instructions.
the overhead incurred by straighttaint s online instrumentation is 16x online no i o bar compared to pin s environment runtime overhead 2the online bar is calculated by counting wall clock time because we have to consider the i o time introduced by our bu ering scheme.
other bars are calculated by counting cpu time.
s48 s49 s50 s51 s52 s53 s54 s55 s56 s57 s49 s48 s49 s49 s49 s50 s49 s51 s49 s52 s49 s53 s49 s54 s49 s55 s49 s56 s49 s57 s50 s48 s32 s32 s32 s83 s108 s111 s119 s100 s111 s119 s110 s32 s40 s110 s111 s114 s109 s97 s108 s105 s122 s101 s100 s32 s101 s120 s101 s99 s117 s116 s105 s111 s110 s32 s116 s105 s109 s101 s41 s32 s110 s117 s108 s108 s112 s105 s110 s32 s108 s105 s98 s100 s102 s116 s32 s111 s110 s108 s105 s110 s101 s45 s110 s111 s32 s73 s47 s79 s32 s111 s110 s108 s105 s110 s101 s32 s111 s102 s102 s108 s105 s110 s101 s97 s118 s101 s114 s97 s103 s101 s120 s97 s108 s97 s110 s99 s98 s109 s109 s107 s97 s115 s116 s97 s114 s111 s109 s110 s101 s116 s112 s112 s104 s50 s54 s52 s114 s101 s102 s108 s105 s98 s113 s117 s97 s110 s116 s117 s109 s115 s106 s101 s110 s103 s104 s109 s109 s101 s114 s103 s111 s98 s109 s107 s109 s99 s102 s103 s99 s99 s98 s122 s105 s112 s50 s112 s101 s114 s108 s98 s101 s110 s99 s104figure straighttaint vs. libdft slowdown on spec cpu2006.
55x extra performance penalty added.
due to the cpu bounded test suite straighttaint has to put more e orts to deal with large amount of i o. therefore additional overhead to online no i o version is introduced.
on average straighttaint generates about 8gb of raw trace pro ling data for spec2006 s reference workload.
compared to the raw byte tag pro le size the relative size of straighttaint is only .
in general straighttaint outperforms dep s encoding by 5percentages in terms of smaller pro ling data size.
it is worth mentioning that we see a signi cant size reduction for the h264ref benchmark from dep s 8gb to 1gb.
the reason is h264ref intensively utilizes rep pre xed instructions which are very well handled by straighttaint s optimization.
the last bar for each application in figure presents the performance of symbolic taint analysis which is normalized to native execution as well.
since we have decoupled taint tracking from program execution o ine symbolic taint analysis avoids the overhead introduced by dbi s environment and computing resource competitions.
on the other hand symbolic taint analysis engine is in fact an interpreter for each il which is much slower than native execution.
to alleviate this issue we have applied a number of optimization methods discussed in section .
.
the net result is that our o ine symbolic taint analysis takes approximately the same amount of time as libdft 06x for straighttaint and 96x for libdft on average .
in several cases e.g.
perlbench and h264ref straighttaint s o ine part outperforms libdft.
considering that straighttaint is aiming to shift dynamic taint analysis cost to the o ine analysis phase this degree of slowdown is tolerable.
in section we will discuss several possible ways to further accelerate o ine taint analysis.
.
straighttaint vs. flowwalker flowwalker is perhaps the closest work to straighttaint in its goals we are both o ine taint analysis in record and replay style.
similar to straighttaint flowwalker also records limited cpu context on top of pin to calculate the memory address o ine.
however flowwalker lacks negrained optimizations in both online logging and o ine taint analysis see section .
in this experiment we evaluate straighttaint short for st and flowwalker short for fw s48 s49 s50 s51 s52 s53 s54 s55 s56 s57 s49 s48 s49 s49 s49 s50 s49 s51 s32 s32 s32 s83 s84 s45 s111 s110 s108 s105 s110 s101 s32 s70 s87 s45 s111 s110 s108 s105 s110 s101 s32 s83 s84 s45 s111 s102 s102 s108 s105 s110 s101 s32 s70 s87 s45 s111 s102 s102 s108 s105 s110 s101 s83 s108 s111 s119 s100 s111 s119 s110 s32 s40 s110 s111 s114 s109 s97 s108 s105 s122 s101 s100 s32 s101 s120 s101 s99 s117 s116 s105 s111 s110 s32 s116 s105 s109 s101 s41 s32 s32 s116 s97 s114 s97 s114 s99 s104 s105 s118 s101 s32 s32 s98 s122 s105 s112 s50 s100 s101 s99 s111 s109 s112 s114 s101 s115 s115 s32 s115 s99 s112 s49 s71 s98 s112 s115 s32 s116 s97 s114 s117 s110 s116 s97 s114 s32 s32 s103 s122 s105 s112 s99 s111 s109 s112 s114 s101 s115 s115 s32 s98 s122 s105 s112 s50 s99 s111 s109 s112 s114 s101 s115 s115 s32 s97 s118 s101 s114 s97 s103 s101 s32 s32 s103 s122 s105 s112 s100 s101 s99 s111 s109 s112 s114 s101 s115 s115figure straighttaint vs. flowwalker slowdown on common linux utilities.
on four common linux utilities that represent three kinds of workload.3the program taris i o bounded whereas bzip2 and gzip are cpu intensive program and scprepresents a middle level between these two cases.
we use tarto archive and extract gnu core utilities .
package s50mb .
and then we apply bzip2 and gzip to compress and decompress the archive le of core utilities.
for scp we copy the archive le of core utilities over 1gbps link.
we achieve a similar improvement with the spec cpu2006 experiment.
as shown in figure straighttaint imposes a average 48x slowdown to native execution with a 86times speed up to flowwalker.
besides straighttaint s o ine taint analysis is faster than flowwalker with a factor of .
we attribute this to our sub trace cache and function summary optimizations.
.
offline symbolic taint analysis next we evaluate the accuracy of our o ine symbolic taint analysis in the task of software attack detection.
to this end we test ten recent software vulnerabilities using a set of exploits listed in table .
these test cases are chosen from cve vulnerability data source4with two criteria it is easy to mark the locations of taint sinks in the binary code so that we can count the tainted bytes at the same place we have exploits that can trigger these vulnerabilities not all the cve vulnerabilities have related exploits .
all of these applications are compiled with the option gcc o2 .
taking these exploits as inputs we apply straighttaint on each application and check taint tags at various taint sinks e.g.
function return value .
in all cases straighttaint successfully detects the attacks without false negatives.
at the same time we count the number of tainted or symbolic bytes at the end of taint analysis.
we compared straighttaint with log all and pure se .
log all means recording complete runtime data e.g.
each memory address and control transfer target during online logging and then use the data for o ine taint analysis.
log all represents vanilla decoupled o ine taint analysis but its result is accurate.
pure se does symbolic taint analysis but without concrete execution state initialization see section .
and memory reference address 3spec2006 s reference workload is too huge for flowwalker to work out the result in reasonable time.
315table straighttaint successfully detects various intrusions with the listed exploits.
program vulnerability cve id taint symbolic bytes log all straighttaint pure se nginx validation bypass cve mini httpd validation bypass cve libpng denial of service cve gzip integer under ow cve tiny server validation bypass cve coreutils bu er over ow cve libti bu er over ow cve wavesurfer bu er over ow cve grep integer over ow cve regcomp validation bypass cve s49 s50 s51 s52 s53 s54 s55 s52 s48 s48 s32 s32 s83 s108 s111 s119 s100 s111 s119 s110 s32 s40 s110 s111 s114 s109 s97 s108 s105 s122 s101 s100 s32 s101 s120 s101 s99 s117 s116 s105 s111 s110 s32 s116 s105 s109 s101 s41 s78 s117 s109 s98 s101 s114 s32 s111 s102 s32 s116 s97 s105 s110 s116 s32 s116 s97 s103 s115 s32 s84 s97 s105 s110 s116 s80 s105 s112 s101 s32 s84 s101 s109 s117 s32 s68 s121 s116 s97 s110 s50 s48 s48 s49 s48 s48 s53 s48 s50 s48 s49 s48 s53 s50 s49 figure normalized slowdown when the number of taint tags varies.
resolution see section .
.
as shown in table the taint bytes added by straighttaint is quite close to the log all.
straighttaint introduces additional taint bytes to cases but no one is beyond .
most likely our conservative approach to dealing with symbolic memory indices results in the small additional taint bytes.
in contrast symbolic taint analysis with a completely unconstrained initial state pure se incurs taint variable explosion.
pure se fails in the last test cases due to quickly reaching the memory capacity.
note that we also identify code segments which can fail dta tools with incomplete taint propagation strategies.
one such example has been shown in figure .
in contrast straighttaint s full featured o ine taint analysis succeeds in all cases.
at last we show that straighttaint can support multi tag taint analysis naturally.
we test a lightweight web server thttpd 5with a byte size http request as input.
the x axis numbers in figure represent di erent taint tags we assigned taint tag indicates the whole bytes are labeled as a single taint tag taint tags means that the rst bytes are labeled as one taint tag and the next bytes are labeled as another one taint tags means each input byte is associated with a di erent taint tag.
following the similar style we vary the number of taint tags in each round.
at the same time we compare two dta tools temu and dytan which also support multi tag taint analysis.
the baseline for each tool is their singletag version.
as shown in figure it is apparent that as the number of taint tags increases both temu and dytan imposes high additional overhead while straighttaint only introduce 48x showdown in the worst case.
please note that this evaluation demonstrates straighttaint s another notable feature once a log is captured it can be analyzed multiple times .
in our multiple round testing straighttaint needs to record the required data once and performs the di erent multi tag propagation rounds on top on the straight line code.
by contrast both temu and dytan have to rerun at each round.
.
case study attack provenance analysis because of the o ine analysis property straighttaint is an ideal t for ex post facto security applications.
in this section we demonstrate the merit of straighttaint with a case study of attack provenance investigation.
the goal is to reveal the provenance of intrusions or suspicious events e.g.
information leaks .
the previous work did this by generating causal graph linking root causes and suspicious events.
certainly dta can be utilized to precisely generate causal dependence between taint source and taint sink.
we show that straighttaint is able to get a similar level of precision as dta with multi tag backward propagation.
the test case is wget 6an open source tool for retrieving les from web.
we execute wget with the command wget .
as shown in figure wget receives two urls as command line arguments and then downloads their respective index.html les index1.html is from and index2.html is from .
supposing we have already got these two downloaded les an interesting question is which exact url are they derived from?
google bing or both?
apparently dta can precisely identify such mappings by forward taint tracking with multiple tags.
please note the pseudo code of figure two les are generated subsequently when the loop is unrolling.
as a result static taint analysis without runtime information fails to identify causal relations between sources and sinks.
we take the input bu er of fwrite which is used to generate html le as symbolic taint sinks.
then we apply straighttaint for backward tainting along the straightline trace.
of course without runtime values and inputs straighttaint is unable to exactly correlate the concrete url to its corresponding le.
however compared to pure static approaches straighttaint catches conditional causal relationships between two sinks and sources the rst downloaded le is derived from the rst url input and the second one is related to the second url.
another bene t of straighttaint s conditional tainting is that we are possible to directly map previous taint analysis results to new inputs and runtime values.
for example supposing new command forwget is wget with the previous conditional causal relationship we can get the exact mappings immediately without running dta again.
index1.html index2.htmlwget convert links to local files int count sizeof downloaded set for i i count i convert links file url figure causal relationship between two sinks and two sources.
.
related work decoupling dynamic taint analysis.
to address the performance bottleneck of dynamic taint analysis dta two major approaches have been proposed to decouple taint analysis from program execution.
the rst category parallelizes dynamic taint analysis by delivering the needed runtime values to another core in which the taint analysis is running .
decaf extends temu to support asynchronous heavyweight taint propagation.
however decaf does not show the performance gains introduced by its asynchronous tainting.
taintpipe parallelizes dta in a pipeline style.
because of the strict synchronization requirement some tools in the rst category adopt incomplete taint propagation strategies to catch up the application execution.
the second direction like straighttaint rst records the application execution and then replay the taint analysis on a di erent cpu .
the most related work to straighttaint is flowwalker which also uses pin to record cpu context and then performs a multi tag assembly level taint propagation o ine.
however straighttaint reveals two distinct advantages.
first we design a more compact pro le structure and multithreaded fast bu ering scheme to parallelize the runtime data logging.
second our o ine taint analysis is performed on a side e ect free intermediate language instead of cumbersome x86 instructions.
as demonstrated in our evaluation straighttaint outperforms flowwalker with better performance and accuracy.
as we have pointed out due to the large amount data in exchange the two approaches mentioned above may not achieve the expected performance improvements.
recently shadowreplica alleviates such communication overhead by performing an advanced static analysis to remove redundant taint logic code.
as a result it achieves a decent performance in the evaluation.
our work di ers from shadowreplica in that straighttaint does not depend on ne grained static analysis of binary code.
therefore straighttaint can be applied to reverse engineering tasks such as malware analysis and code deobfuscation .
dynamic symbolic execution.
another related area to straighttaint s o ine taint analysis is dynamic symbolic execution namely concolic testing a method of combining concrete execution with symbolic execution.
straighttaint is similar to the concolic testing in that we map symbols to taint seeds and then perform the symbolic taint analysis along a recorded execution trace.
also straighttaintcan bene t from symbolic execution optimization work to speed up taint analysis such as memoized symbolic execution .
however we have di erent goals.
dynamic symbolic execution is mainly for automatic input generation to explore more paths while our primary interest lies in accurate taint analysis on the straight line code.
in addition concolic testing relies on complete runtime information while straighttaint only depends on limited runtime information.
the recent work hercules also mentions the idea of using symbolic execution for precise taint tracking.
however straighttaint has a strikingly di erent purpose with hercules.
hercules is for reproducing crashes in benign application binaries while straighttaint is designed to speed up reverse engineering tasks on binary code.
.
discussions and conclusion straighttaint is a prototype to demonstrate that completely decoupling dynamic taint analysis is feasible.
the performance of online logging and o ine taint analysis can be further improved.
currently the upper bound of online logging performance that we can achieve is restricted by pin s environment runtime overhead.
one of our future work is to leverage the advanced binary reassembling development toolkits such as uroboros so that we can insert the taint tracking code directly into the disassembled code and then compile it to the binary code again.
in this way we can remove dbi s environment overhead.
straighttaint s o ine taint analysis is as fast as but not faster than dta on average since in straighttaint the semantics of taint operations are simulated.
one future work to speed up o ine taint analysis is to construct a recompilable straightline program from execution trace.
as a result we can apply another round of dta directly on the straight line program.
currently straighttaint works on sequential programs.
to support taint analysis for multi threaded programs we have to carefully handle the complicated interthread taint propagation such as concurrent accesses to shared locations and corresponding taint tag updates.
we plan to explore these directions in future.
we have presented straighttaint a novel technique for completely decoupling dynamic taint analysis for o ine symbolic taint analysis.
unlike previous approaches straighttaint does not rely on complete runtime values or inputs which enables very lightweight logging and much lower online execution slowdown.
straighttaint can also support fullfeatured multi tag and bit level taint analysis with low extra overhead.
we have evaluated straighttaint on a set of applications such as utility programs spec2006 and real life software vulnerabilities.
the results show that straighttaint can rival dynamic taint analysis at a similar level of precision but with a much lower online execution slowdown and more exible functionalities.
the experimental evidence indicates that straighttaint can be applied to speed up various ex post facto security applications with full featured o ine taint analysis.
.