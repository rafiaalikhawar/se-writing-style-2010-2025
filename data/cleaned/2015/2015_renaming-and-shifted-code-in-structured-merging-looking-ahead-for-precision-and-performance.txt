renaming and shifted code in structured merging looking ahead for precision and performance olaf le enich sven apel christian k stner ygeorg seibt janet siegmund university of passau germany ycarnegie mellon university usa abstract diffing and merging of source code artifacts is an essential task when integrating changes in software versions.
while state of the art line based merge tools e.g.
git merge are fast and independent of the programming language used they have only a low precision.
recently it has been shown that the precision of merging can be substantially improved by using a language aware structured approach that works on abstract syntax trees.
but precise structured merging is np hard especially when considering the notoriously difficult scenarios of renamings and shifted code .
to address these scenarios without compromising scalability we propose a syntax aware heuristic optimization for structured merging that employs a lookahead mechanism during tree matching.
the key idea is that renamings and shifted code are not arbitrarily distributed but their occurrence follows patterns which we address with a syntaxspecific lookahead.
our experiments with 48real world opensource projects merge scenarios with over 400million lines of code demonstrate that we can significantly improve matching precision in 28percent of cases while maintaining performance.
i. i ntroduction due to the success of distributed version control systems merging software artifacts has become a common task for software developers.
however the state of the art technique used to perform merging in practice is basically still the same as thirty years ago unstructured line based merging of text files e.g.
using git merge .
the success of line based merging is based on the fact that it is easy to use applicable to all kinds of text files and cheap to compute.
however line based merging also has several shortcomings since it completely ignores the syntactic structure of the artifacts that it merges it is not able to either resolve or properly present conflicts to the developer conducting the merge.
it has been shown that merging at a structural level can improve the quality of the merged artifacts significantly .
instead of using text lines as a basic unit a structural merge tool operates on the abstract syntax trees asts of the input artifacts.
as in line based merging the key to merging artifacts is to identify matches and differences between these artifacts.
the shortcoming of structured merging compared to line based merging is that comparing asts is computationally expensive in general.
in previous work we have proposed an approach to achieve a balance between precision and execution time of merging using a simple but effective mechanism as long as no conflicts occur a line based merge strategy is used.
when a conflict is encountered one switches to structuredmerge and remerges the respective part to increase precision.
as a further performance optimization when computing the matching between two asts a top down approach is used that considers matches only between corresponding tree levels.
this optimization significantly reduces the runtime complexity from one that was only feasible for the smallest examples to one that is practical for real world software projects .
while comparing asts only top down and level wise does significantly improve performance and scales to real world projects it lowers precision in particular when program elements are renamed e.g.
methods and when code is shifted e.g.
shifting a code block into an exception handler .
as renamings and shifted code are not uncommon changes in practice this limitation is of practical importance.
to catch renamings and shifted code one could perform the matching only structurally ignoring identifiers and search also for embedded subtrees not only level wise both of which are known to be np hard and out of reach for a practical solution.
to gain precision without compromising performance we propose a syntax aware heuristic optimization for structured merging that employs a lookahead mechanism during tree matching.
the key idea is that renamings and shifted code are not arbitrarily used in software development but their occurrence follows patterns.
for example only few syntactic program elements have names that are relevant for matching and code is typically not shifted arbitrarily across the ast.
while it is reasonable to test whether a block of statements has been shifted into an ifortryblock it is highly unlikely and even invalid to shift a method declaration into a subexpression.
the main idea of our approach is employ a syntax aware lookahead mechanism that diverges from level wise tree matching depending on the kinds of syntax elements to be matched.
for example if level wise matching is not able to match a block of statements on both sides it searches for exception handlers and steps one level down i.e.
looks ahead to find a match within the block.
while this is more expensive than level wise matching it is still feasible as we will demonstrate.
interestingly both renamings and shifted code can be treated equally with this lookahead mechanism.
to demonstrate the practicality of our approach we implemented the lookahead mechanism in our open source structured merge tool jd ime1 and we conducted a series of experiments on4 merge scenarios of 48open source projects with over .
c ieeease urbana champaign il usa technical research543 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
million lines of code aggregated over the merge scenarios .
overall we found that we can significantly improve matching precision in percent of the cases without compromising performance i.e.
it scales to real world projects of substantial size .
in summary we make the following contributions we present a heuristic matching technique based on a syntax aware lookahead mechanism to precisely match asts in the presence of renamings and shifted code.
we provide a practical implementation of our approach on top of our open source tool jd ime.
we evaluate our approach on a substantial set of realworld merge scenarios 48projects merge scenarios million lines of code we found that our approach significantly improves matching precision in percent of cases while maintaining performance.
the implementation and a replication package are available on a supplementary web site.
ii.
p roblem statement a. structured merge structured merging is an advanced merging strategy that operates at the level of asts.
while a regular line based merge tool is limited to the granularity of lines a structured tool is aware of what kind of source code elements it is handling and therefore is able to present better solutions in terms of quality especially when it comes to conflict handling.
a typical example where structured merging is superior to line based merging is reordering of methods.
the matching result produced by a line based tool is limited by its capability of comparing just lines which in most cases fails to match the reordered methods.
a structured merge tool knows what methods are and that for example in j ava the order of their definition does not affect program semantics hence it is able to match method declarations independently of their order in the source code.
the improved matching precision of structured merging comes at a cost though beside technical overhead such as parsing and pretty printing matching of trees is per se more expensive as matching of sequences of text lines.
in general there are different algorithms for tree matching and merging with different degrees of precision and computational complexity.
to maximize precision one would need to handle cases where subtrees are shifted and nodes are renamed which corresponds to solving the tree amalgamation problem and the maximum common embedded subtree problem both of which are known to be np hard.
to reduce computational complexity to a practical degree a top down matching approach which compares corresponding tree levels only corresponds to the maximum common subtree problem is feasible see section viii .
in figure we illustrate an example in the base version method a has three statements stmt stmt and stmt .
while version a does not change method a version bshifts the statements a stmt stmt stmt method a if stmt stmt 2stmt 1method a stmt stmt stmt 7base version version a version b figure .
top down level wise ast matching stmt can be matched stmt andstmt can not be matched as they are not at the same level stmt andstmt into an ifblock.
as a result stmt can be matched across the versions aandb but both stmt and stmt cannot as they are at different levels in the two versions.
furthermore the matching procedure terminates recursion early when an element could not be matched.
these optimizations lead to quadratic for ordered elements or cubic for unordered elements runtimes which is still practicable for merging real world projects and has proved to provide practically relevant results .
there are however situations where structured merging is less precise than a line based approach.
in previous work we found that these less precise situations are a direct result of the two optimizations levelwise matching early return and often related to two common change scenarios which are also confirmed by our empirical data see section iv renaming andshifted code .
b. renaming almost any programming language contains syntax elements that are uniquely identified by their names.
this fact is exploited during structured merging but poses problems when program elements are renamed.
as an example of a renaming we present a scenario of merging two versions of a j ava stack implementation in figure .
the methods sizeandlength have the same implementation in version aandb and differ only in their names.
the bottom left listing shows the result of a structured merge with jd ime.
jd ime stops matching when the method declarations themselves cannot be matched instead of looking further for similarities inside the method bodies.
as a result jd imedoes not recognize the renaming and instead inserts both versions while merging clearly not the solution that is wanted in this scenario.
instead we would expect a conflict that prompts the developer to make a decision as illustrated in the bottom right listing.
this way the developer can select the correct version.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
base version class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i version a class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public int size return list.size version b class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public int length return list.size merge structured merge class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public int size return list.size public int length return list.size desired merge class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public int size length return list.size figure .
method renaming example stack.java c. shifted code program elements without unique names are structurally matched based on their code i.e.
equality of ast nodes .
if a program element is moved in one version but not the other they cannot be matched easily the matching algorithm needs to search for corresponding pairs.
as an example we show in figure a new piece of code that was introduced by both versions but wrapped by an ifstatement only in one version.
in version a the surrounding ifis missing in version b it is present.
performing a structured merge with jd imeresults in an unnecessary large conflict bottom left listing because the tool does not match the statement list.clear in the two versions.
this is due to the optimization that matching is limited tobase version class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public void clear version a class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public void clear list.clear version b class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public void clear if list.size list.clear merge structured merge class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public void clear list.clear if list.size list.clear desired merge class stack linkedlist integer list new linkedlist public int pop return list.pop public void push int i list.push i public void clear if list.size list.clear figure .
shifted code example stack.java corresponding tree levels only.
the ifstatement inserts an additional level in the tree which causes jd imeto miss the match between the list calls.
the desired output includes a smaller conflict i.e.
fewer lines involved in the conflict as illustrated in the bottom right listing.
d. discussion to produce the desired merge result for both examples we must improve the matching algorithm of the structured merge approach.
one option is to resort to established algorithms from graph theory.
in particular one could perform the matching authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
only structurally ignoring identifiers which corresponds to the tree amalgamation problem and search also for embedded subtrees not only level wise which corresponds to the maximum common embedded subtree problem however due to the sheer size of asts of real world programs this is not feasible in practice e.g.
for unordered trees the maximum common embedded subtree problem is np hard.
our key insight is that identifying arbitrarily renamed program elements and shifted code is not necessary in practice.
the reason is that renaming and shifted code are not arbitrarily used in software development but their occurrence follows patterns.
for example only few syntactic program elements have names that are relevant for matching and even less have substantial nested code that would lead to imprecise conflicts as in our example of figure .
thus we concentrate on renamed methods in our experiments see section iv .
furthermore code is typically not shifted arbitrarily across the ast.
while it is reasonable to test whether a block of statements has been shifted into an ifortryblock it is highly unlikely and even invalid to shift a method declaration into a subexpression or field initialization.
instead we aim for a syntax aware heuristic that for certain language specific elements in the ast allows the matching algorithm to descend a few levels in the subtree andlook ahead for a better match.
specifically we propose such a heuristic implemented on top of jd ime using a configurable lookahead mechanism that produces significantly better matches while still achieving a performance comparable to state of theart structured merging.
iii.
a s yntax aware lookahead mechanism in algorithm we show the existing top down matching approach used in jd ime which matches only corresponding tree levels and stops descending when two nodes do not match.
the algorithm starts matching at the root nodes of both asts and if the nodes match inspects their children to determine whether ordered or unordered matching is required line .
ordered matches between nodes are computed with an adaptation of the longest common subsequence algorithm unordered matches are computed using the hungarian method .
both subroutines for ordered and unordered matchings include recursive calls to the match function shown in algorithm .
for more details on the ordered and unordered matching in jd ime we refer the reader elsewhere .
one of the limitations that we discussed previously arises if two nodes cannot be matched even if one could be matched with a child of the other line .
as discussed in section ii we need to change this behavior in certain situations to achieve better overall matching results.
if a program element cannot be matched by name or structure we can still look ahead i.e.
further descend in the asts and search for potential matches.
so we have to 3more precisely the problem is apx hard apx is the set of np optimization problems that can be approximated with polynomial time algorithms with an approximation ratio bounded by a constant.algorithm ast m atching level wise early return function match node l node r ifl6 rthen return .nodes do not match early return end if l children of l r children of r ifisordered l isordered r then return ordered matching l r .considering order else return unordered matching l r .ignoring order end if end function alter the algorithm to continue the descent when specific ast nodes e.g.
two method declarations could not be matched.
a. looking ahead to prevent a combinatorial explosion of potential matchings and therefore exponential runtime complexity we add a parameter called lookahead distance to our matching algorithm that tracks the number of levels it has descended in each tree without matching a node.
as the influence of this parameter on runtime is quite high we have to explore the structure of our asts to infer a reasonable configuration.
for most syntax elements a maximum value of or should be sufficient to match the relevant code blocks in most situations this way identifying renamed program elements and shifted code.
while it is technically possible to use a generic lookahead distance i.e.
independent of the type of program element to match it is highly inefficient in practice as it leads to numerous matching calls that yield no better result.
for example it is highly unlikely to identify a matching of method declarations by descending into sub statement level.
instead we exploit structural knowledge of typical changes because the subtree structure of say method declarations and ifstatements differs this parameter has to be set specifically for each ast node type that is subject of our lookahead procedure to find an optimal balance between matching precision and algorithm performance.
in figure we illustrate the lookahead procedure for a renaming scenario.
in version a method a has been renamed tomethod b thus it cannot be matched with its counterpart in version b. looking ahead three levels on both sides they can be matched as their bodies are identical both containing stmt andstmt .
note that this example illustrates a further issue real world parse trees and asts typically contain various auxiliary nodes body andstmtlist in our case .
this needs to be taken into account when choosing the distance of the lookahead.
in figure we illustrate the lookahead procedure for an example with shifted code.
in the base version method a contains the statements stmt andstmt .4in version a stmt is shifted into an ifblock one level down in version b stmt is shifted into an tryblock which itself is wrapped by an if 4for simplicity we do not show auxiliary nodes such as body andstmtlist .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
method a stmt stmt method a stmt if try stmt 1method a if stmt 2stmt 1lh lh 3base version version a version b figure .
looking ahead to match shifted statements method a body stmtlist stmt stmt method a body stmtlist stmt stmt 1method b body stmtlist stmt stmt 1lh lh lh lh 3base version version a version b figure .
looking ahead to match a renamed method block two levels down .
while for matching stmt we need to look ahead two levels for stmt we need to look ahead only one level.
b. algorithm algorithm shows the whole procedure of ast matching with lookahead.
if two nodes do not match and the algorithm is allowed to look ahead lines and instead of an early return line we still compute the matches between thechild nodes.
first the algorithm descends the left ast line and then tries the right ast line .
the distance of looking ahead depends on the type of the nodes involved lines and .
the lookahead mechanism itself shown in algorithm is a straightforward recursive descent in the ast controlled by the given lookahead distance lines and .
to guarantee a certain matching quality the resulting matches are used only if the similarity between the subtrees is at least the value of a given threshold algorithm lines .
note that the threshold is not always i.e.
perfect match as in the case of a method renaming at least the names of the methods differ.
so the threshold depends on the type of the node to take that aspect into account.
in particular we are interested in cases where the nodes themselves do not match but their entire subtrees or the most relevant parts excluding some auxiliary nodes .
in these cases we optimize the lookahead by incorporating the identical subtree optimization proposed by dotzler et.
al not shown in algorithm .
in a nutshell prior to matching we create a hash for each node using its type label if available and children hashes as input for the hash function.
looking back at our method renaming example we can determine whether their subtrees are completely identical by comparing the hash values.
this optimization significantly reduced the number of matching operations for the renaming example because the identity of the method bodies can be detected in o by looking at the hash instead of o n2 using an ordered matching algorithm.
algorithm ast m atching with lookahead function match node l node r double threshold ifl6 rthen l dist lookahead dist l .depends on the node s type r dist lookahead dist r .depends on the node s type ifl dist r dist 0then return .nodes do not match early return else .perform lookahead l lookahead l r l dist .descending left r lookahead r l r dist .descending right ifl null r null then return .no matching nodes deeper in subtree else return match l r .recursive call end if end if end if l children of l r children of r ifisordered l isordered r then matching ordered matching l r else matching unordered matching l r end if ifmatching threshold then .maximum depth reached?
return matching else return end if end function authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm lookahead function lookahead node n node m int dist ifn mthen return n .match found end if ifdist 0then .maximum depth reached?
return null end if forcin children of ndo n lookahead c m dist .recursive call ifn6 null then .further children?
return n end if end for return null end function iv.
e valuation to evaluate our approach with respect to relevance precision and performance we conducted an empirical study on merge scenarios from 48projects.
in this section we describe the setup and the results of our experiments.
we provide a replication package on the supplementary web site.
a. research questions to learn about the precision and performance of matching with lookahead we address six research questions.
in particular we concentrate on renamed methods and statements shifted into if try and catch blocks as for the latter we limit our attention to shifts across one level.
to understand whether these types of changes are indeed relevant in practice i.e.
whether they occur frequently we determine how often they occur in real world merge scenarios as determined by our lookahead mechanism.
rq .1how often do renamings occur in real world merge scenarios?
rq .2how often does shifted code occur in realworld merge scenarios?
apart from the frequency of occurrences we also evaluate whether we can handle these situations better with the lookahead mechanism.
therefore we measure precision in terms of the percentage of matched nodes both with and without lookahead enabled.
we expect a significantly higher precision with the lookahead mechanism.
rq .1what is the precision of matching in the presence of renaming with and without lookahead?
rq .2what is the precision of matching in the presence of shifted code with and without lookahead?
in practice the time a merging algorithm needs to perform its task is relevant to the user.
to evaluate whether the lookahead mechanism is applicable in practice we determine what the cost of the additional matching operations induced by looking ahead is.
to this end we measure the runtime of the algorithm with and without lookahead.
rq .1what is the runtime cost of matching in the presence of renaming with and without lookahead?rq .2what is the runtime cost of matching in the presence of shifted code with and without lookahead?
b. subject systems and merge scenarios we selected 48popular g itprojects from various application domains from the collaboration platform g ithub including popular projects such as r xjava elasticsearch guava apache storm and a pache weex.
our main criteria for selecting subject projects were that they are written mainly in javaand have a substantial number of merge scenarios in their history.
we identified the merge scenarios by iterating over all commits in the version control history and by extracting those with more than one parent.
then we performed a two way diff between the competing versions of the merge.
of course for an actual merge a three way comparison would be done using the additional information from the common ancestor to decide which changes to select.
however as our goal is to evaluate the matching precision of the diff algorithms it is sufficient to use two way comparisons.
a list of all subject systems along with relevant information is available in table i. c. procedure in our experiments we compute a structured diff for each merge scenario with and without our lookahead mechanism.
then we compare the achieved matchings as well as the time needed to perform the diff.
to this end we let the g itclient use our extension of jd imeas an external diff tool.
based on the output of jd ime we measure whether we matched fewer or more ast nodes overall and aggregated per type of node.
furthermore we manually inspected about scenarios to estimate the quality of matchings produced by our tool see section vii .
this step is necessary to avoid that our approach simply matches more ast elements while producing wrong results that would be harmful as input for the actual merge.
our analysis framework is written in p ython it is available at the supplementary web site.
we executed all experiments on intel xeon e7 machines with gb of memory.
v. r esults a. rq .1and rq .
frequency in our experiments we found that renaming of methods occurs in of the considered merge scenarios.
on average these renamings were spread over files.
code shifted into if try and catch blocks occurred in of all merge scenarios in most cases located in just one file.
figure and figure show the distributions of numbers of files affected by renaming and shifted code.
while in both cases most occurrences concern only a single or few files there are outliers which point to major refactorings.
b. rq .1and rq .
precision by using our lookahead mechanism we matched additional ast nodes per affected scenario on average nodes by detecting renamings and 18nodes by detecting shifted code increasing our matching precision.
overall matching authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
number of files affected100101102frequency log scale figure .
files per scenario that contain renamings number of files affected100101102frequency log scale figure .
files per scenario that contain shifted code precision could be improved in of the evaluated merge scenarios.
figure and figure show the distributions of numbers of nodes additionally matched by looking ahead for renamed methods and shifted code.
in many cases the number is and below but there are cases with up to several hundreds and thousands of nodes.
as the number of nodes is a proxy of the amount of code these results show that code of substantial size could be matched which would be missed without lookahead.
c. rq .1and rq .
costs jdime without lookahead had a total runtime of min 383ms per scenario on average.
by enabling our lookahead mechanism we spent a total runtime of min 505ms per scenario on average.
figure and figure show the runtime per scenario with and without lookahead.5overall matching with lookahead is as expected slower than without but still reasonably close.
on average looking ahead is less than half a second slower per scenario.
5note that matching with lookahead is slightly faster in some cases in the figures which is just an artifact of measurement inaccuracy though.
additionally matched nodes100101102103frequency log scale figure .
number of additionally matched ast nodes by renaming detection additionally matched nodes100101102103104frequency log scale figure .
number of additionally matched ast nodes by shifted code detection vi.
t hreats to validity a. internal validity for our experiments we selected only merge scenarios actually committed to the g itrepositories this way ignoring scenarios where a merge was possibly too hard and the developers gave up instead of integrating the changes.
we deliberately made this decision to increase confidence in the practical relevance of our merge scenarios especially as there is no reliable way to identify and extract merge scenarios that failed.
likewise there is also no reliable way of identifying rebases so these are also excluded.
in our experiments we considered only on a few instances of renaming and shifted code method renaming shifting blocks of statements into if try and catch blocks .
the mechanism we propose here is much more general though so our results mark just a lower bound of its applicability.
still we were able to improve matching precision in a practical relevant number of situations.
we adjusted the lookahead distance parameter based on the structure of jd ime asts that we had at our disposal.
different ast implementations may require slightly different parameter settings but a deviation from our high level results are not to be expected.
we set the threshold for matching authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
merge scenarios sorted by runtimes with lookahead switched off 102103104105runtime in milliseconds log scale lookahead method lookahead offfigure .
runtimes in milliseconds with a lookahead for renamed methods switched on and off merge scenarios sorted by runtimes with lookahead switched off 102103104105runtime in milliseconds log scale lookahead shifted lookahead off figure .
runtimes in milliseconds with a lookahead for shifted code switched on and off similarity such that only perfect matches are obtained e.g.
equal method bodies and blocks of shifted code .
relaxing this requirement would produce more desired matches but possibly also undesired matches.
finally in our research questions we concentrated on the matching routine which is only one part of the overall merging procedure.
performing the actual merge based on the improved matching would add a further dimension of possible design decision and optimizations which is well beyond the scope of this paper.
b. external validity one has to be careful with generalizing our findings beyond our corpus.
we selected a substantial and diverse corpus of projects covering different development practices and application domains but other projects may have different characteristics.
likewise our implementation and experiments are limited to j ava.
while our findings do not necessarily translate to any language our results likely also apply to languages with similar syntactic structure especially with regard to method or function declarations and nesting of code blocks e.g.
c c and p ython .vii.
d iscussion summarizing the results of our experiments looking ahead pays off!
first of all renaming methods and shifting code are changes that happen in practice in of the merge scenarios methods are renamed in of the merge scenarios code is shifted .
this finding illustrates the relevance of targeting these changes in our lookahead mechanism.
furthermore pursuing a syntax aware lookahead mechanism improves precision considerably.
overall matching precision could be improved in of the considered merge scenarios.
finally the improvement in precision does not affect the practicality of the approach in terms of performance.
on average enabling the lookahead mechanism is less than half a second slower per merge scenario up to 23s .
matching is an automatic procedure and must be automatic to be practical.
to gain confidence in the correctness or quality of the computed matchings we manually inspected about samples of code that were matched differently by our lookahead compared to without using the lookahead.
for the manual inspection we compared both pretty printed diff outputs from jdimewith the output computed by a line based diff tool to judge whether our matching approach produced a correct result.
during this inspection we did not find any indication that our approach produces false positives.
the reason for this is very likely the threshold parameter that is used by the algorithm to decide whether or not two trees are similar in our evaluation this value was set to which leads to matches of mostly identical code fragments.
when reduced say to we assume that false positives will be produced along with correct matches but this is outside the scope of our study.
the other tunable parameters are the language specific lookahead distances they need to be high enough to find matching code but at the same time introduce a performance penalty due to the additional matching operations.
good values can be deduced from the structure of the ast to find shifted code a distance of or is sufficient.
for renaming a value of or is required to find better matches.
to learn more about the influence of the syntax specific lookahead distances we experimented with a generic unbounded lookahead variant that always tries to find matching code in subtrees irrespective of the type of node.
as expected this variant was much slower with average runtimes of up to compared to the unoptimized version of jd ime.
most of the shifted code that we looked at during our manual inspection appeared like bug fixes of some sort statements wrapped by a tryblock for better exception handling or code wrapped by an ifstatement to execute it conditionally.
we also observed the opposite situations tryblocks or ifstatements being removed.
typically only one file was affected by shifting code per merge scenario whereas renaming seems to be more common in practice.
viii.
r elated work after the seminal work of westfechtel and buffenbarger several of approaches of structured merging for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mainstream programming languages such as j ava have been proposed .
jdimeis a structured merge tool that merges j avaasts topdown and level wise .
it distinguishes between ordered and unordered nodes and treats them differently during matching which improves precision.
le enich et al.
proposed an auto tuning approach on top of jd ime which essentially switches between structured and unstructured merge based on the presence of conflicts if there are conflicts a more precise but also more costly structured merge is used otherwise only a line based merge .
without lookahead jd ime is not able to match renamed program elements and shifted code.
apel et al.
addressed problem of computational complexity of structured merging by treating individual artifacts only to some extent in terms of their syntactic structure e.g.
until the method level and the fine grained parts as plain text which is effectively a semistructured merging approach.
much like jd ime renamed program elements and shifted code cannot be matched.
asenov et al.
encode the tree structure of asts in plain text such that a line based merging tool can be used.
the matching algorithm relies on node identifiers though which must be supplied from an external source e.g.
from an editor which simplifies the matching problem.
however in many practical settings such as using version control systems this information is not available.
gumtree uses a two phase strategy for ast matching .
in the first phase it searches top down for nodes whose names match and whose subtrees are isomorphic.
in the second phase it revisits unmatched nodes and searches for pairs which have a significant number of matching descendants.
this way renamed program elements and shifted code can be detected.
in contrast to our lookahead mechanism their approach is not syntax specific thus searches for potential matches irrespective of syntactic categories of the program elements involved.
as discussed in section vii this incurs an overhead for searching matches that are very unlikely or even invalid.
dotzler et al.
discuss five optimizations that may be used as pre or postprocessing steps for tree matching algorithms with the aim of shortening the resulting edit scripts.
in particular they search for identical subtrees as a preprocessing step and target specific cases such as unmapped or moved leaf nodes.
much like g umtree they do not optimize for matching program elements of different syntactic categories.
jdiffgoes beyond the ast and matches at the level of control flow which changes the problem from tree matching to graph matching.
graph matching is in general np hard and not feasible for the scenarios that we addressed in our experiments.
malpohl et al.
developed a language independent detector of renamed program elements that operates on parse trees.
besides tree matching it considers also the static program semantics in the form of def use pairs which is more precise but harms performance unfortunately there is no evaluation on substantial programs available .
the detector is not syntaxaware in the sense that it incorporates the types of nodes to findbetter matchings as we do in our lookahead mechanism.
so it is not surprising that in a case study they had to calculate similarity measures for all possible pairs of identifiers to arrive at over identifier pairs about of which were renamings.
beside mainstream programming languages some approaches target model artifacts .
they are mostly based on graphs which allow precise merging but harm performance.
so it is unlikely that they scale to problem sizes in the order of our subject projects.
finally tracing which change operations give rise to the versions to be merged can help in the detection and resolution of conflicts .
however such an operationbased approach is infeasible when traces are not available or difficult to obtain which is common in practice.
dig et al.
proposed techniques to detect renamings in such scenarios.
other approaches require that the artifacts to be merged come with a formal semantics which is also rarely the case in practice e.g.
for mainstream programming languages .
another line of work attempts to detect refactorings by identifying semantic changes in a diff .
finally approaches that rely on model finders for semantic merge have substantial limitations with regard to performance .
ix.
c onclusion diffing and merging software artifacts are central tasks in software development.
while the state of the art still relies on an unstructured lined based approach to merging recent developments demonstrate the merits and prospects of structured merging approaches.
precise structured merging is computationally expensive though so practical approaches introduced a number of optimizations top down level wise matching and early return if nodes do not match .
while these optimizations improve performance to a degree that makes structured merging practical the imprecision induced touches two very relevant change scenarios renaming and shifted code.
to improve precision without compromising performance we have developed a syntax aware heuristic optimization of structured merging by devising a lookahead mechanism that based on the type of the program element to match descends the matching traversal efficiently.
this way we can handle renaming and shifted code uniformly.
in a series of experiments on 48real world open source projects merge scenarios with over million lines of code we demonstrate that a syntax aware lookahead mechanism can significantly improve matching precision in percent without compromising performance.
a qualitative analysis confirms the relevance and quality of the matchings produced.
x. a cknowledgements this work has been supported by the german research foundation ap ap and ap .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i subject projects and experiment data loc lines of code project scenarios first commit loc renamings pieces of shifted code action barsherlock android clean architecture android observable scroll view android pulltorefresh android universal image loader android swipe layout android utilcode event bus homemirror hystrix mpa ndroid chart material animations material design library material drawer photo view pocket hub rxandroid rxjava sliding menu viewpager indicator android ultra pull to refresh android universal music player android async http androidannotations butterknife dubbo elasticsearch fastjson fresco glide guava iosched java design patterns kotlin leakcanary lottie android material dialogs netty okhttp picasso plaid realm java retrofit spring boot storm tinker weex zxing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.