generating fixtures for javascript unit testing amin milani fard university of british columbia vancouver bc canada aminmf ece.ubc.caali mesbah university of british columbia vancouver bc canada amesbah ece.ubc.caeric wohlstadter university of british columbia vancouver bc canada wohlstad cs.ubc.ca abstract in today s web applications javascript code interacts with the document object model dom at runtime.
this runtime interaction between javascript and the dom is errorprone and challenging to test.
in order to unit test a javascript function that has read write dom operations a dom instance has to be provided as a test fixture.
this dom fixture needs to be in the exact structure expected by the function under test.
otherwise the test case can terminate prematurely due to a null exception.
generating these fixtures is challenging due to the dynamic nature of javascript and the hierarchical structure of the dom.
we present an automated technique based on dynamic symbolic execution which generates test fixtures for unit testing javascript functions.
our approach is implemented in a tool called c onfix.
our empirical evaluation shows that c onfix can effectively generate tests that cover dom dependent paths.
we also find that c onfixyields considerably higher coverage compared to an existing javascript input generation technique.
keywords test fixture test generation dynamic symbolic execution concolic execution dom javascript web applications i. i ntroduction javascript has grown to be among the most popular programming languages.
for instance javascript is now the most prevalent language in github repositories and a recent survey of more than 26k developers conducted by stack overflow found that javascript is the most used programming language .
to create responsive web applications developers write javascript code that dynamically interacts with the document object model dom .
the dom is a treelike structure that provides apis for accessing traversing and mutating the content and structure of html elements at runtime.
as such changes made through javascript code via these dom api calls become directly visible in the browser.
this complex interplay between two separate languages namely javascript and the html makes it hard to analyze statically and particularly challenging for developers to understand and test effectively.
as revealed in a recent empirical study the majority of reported javascript bugs are dom related meaning the fault pertains to a dom api call in javascript code.
moreover of the highest impact javascript faults are dom related.
in order to unit test a javascript function that has dom read write operations a dom instance needs to be provided in the exact structure as expected by the function.
otherwise a dom api method e.g.
var n getelementbyid news returns null because the expected dom node is not available any operations on the variable pointing to this non existent dom node e.g.
n.firstchild causes a null exception and the test casecalling the function terminates prematurely.
to mitigate this problem testers have to write test fixtures for the expected dom structure before calling the javascript function in their unit tests.
the manual construction of proper dom fixtures is however tedious and costly.
despite the problematic nature of javascript dom interactions most current automated testing techniques ignore the dom and focus on generating events and function arguments .
jseft applies an approach in which the application is executed and the dom tree is captured just before executing the function under test.
this dom tree is used as a test fixture in generated test cases.
this heuristicbased approach however assumes that the dom captured at runtime contains all the dom elements values and relations as expected by the function which is not always the case.
thus the code coverage achieved with such a dom can be quite limited.
moreover the dom captured this way can be too large and difficult to read as a fixture in a test case.
symjs applies symbolic execution to increase javascript code coverage with limited support for the dom i.e.
it considers dom element variables as integer or string values and ignores the dom structure.
however there exist complex dom structures and element relations expected by the javascript code in practice which this simplification cannot handle.
in this paper we provide a technique for automatically generating dom based fixtures and function arguments.
our technique called confix is focused on covering domdependent paths inside javascript functions.
it operates through an iterative process that dynamically analyses javascript code to deduce dom dependent statements and conditions collects path constraints in the form of symbolic dom constraints translates the symbolic path constraints into xpath expressions feeds the generated xpath expressions into an existing structural constraint solver to produce a satisfiable xml structure generates a test case with the solved structure as a test fixture or function argument runs the generated test case and continues recursively until all dom dependent paths are covered.
to the best of our knowledge our work is the first to consider the dom as a test input entity and to automatically generate test fixtures to cover dom dependent javascript functions.
our work makes the following main contributions a novel dynamic symbolic execution engine to generate dom based test fixtures and inputs for unit testing javascript functions 1function dg x 2return document.getelementbyid x 5function sumtotalprice 6sum 7itemlist dg items 8if itemlist.children.length dg message .innerhtml list is empty!
else for i i itemlist.children.length i p parseint itemlist.children .value if p sum p else dg message .innerhtml wrong value for the price of item i dg total .innerhtml sum return sum fig.
a javascript function to compute the items total price.
a technique for deducing dom structural constraints and translating those to xpath expressions which can be fed into existing structural constraint solvers an implementation of our approach in a tool called confix which is publicly available an empirical evaluation to assess the coverage of confix on real world javascript applications.
we also compare confix s coverage with that of other javascript test generation techniques.
the results of our empirical evaluation show that confix yields considerably higher coverage up to and percentage point increase on the branch and the statement coverage respectively compared to tests generated without dom fixtures inputs.
ii.
b ackground and motivation the majority of reported javascript bugs are caused by faulty interactions with the dom .
therefore it is important to properly test dom dependent javascript code.
this work is motivated by the fact that the execution of some paths in a javascript function i.e.
unique sequences of branches from the function entry to the exit depends on the existence of specific dom structures.
such dom structures have to be provided as test fixtures to effectively test such dom dependent paths.
a. dom fixtures for javascript unit testing a test fixture is a fixed state of the system under test used for executing tests .
it pertains to the code that initializes the system brings it into the right state prepares input data or creates mock objects to ensure tests can run and produce repeatable results.
in javascript unit testing a fixture can be a partial html that the javascript function under test expects and can operate on read or write to or a fragment of json xml to mock the server responses in case of xmlhttprequest xhr calls in the code.
running example.
figure depicts a simple javascript code for calculating the total price of online items.
we use this as div id qunit fixture form id items input id item1 value input id item2 value div id total fig.
a dom subtree for covering a path lines and of sumtotalprice in figure .
1test a test for sumtotalprice function qunit fixture .append form id items input type text id item1 value input type text id item2 value form div id total 3sum sumtotalprice 4equal sum function sums correctly.
fig.
a quint test case for the sumtotalprice function.
the dom subtree of figure is provided as a fixture before calling the function.
this test with this fixture covers the path going through lines and in sumtotalprice .
a running example to illustrate the need for providing proper dom structures as test input for unit testing javascript code.
lets assume that a tester writes a unit test for the sumtotalprice function without any test fixture.
in this case when the function is executed it throws a null exception at line figure when the variable itemlist is accessed for its children property.
the reason is that the dom api method getelementbyid line returns null since there is no dom tree available when running the unit test case.
consequently dg line returns null and hence the exception at line .
thus in order for the function to be called from a test case a dom tree needs to be present.
otherwise the function will terminate prematurely.
what is interesting is that the mere presence of the dom does not suffice in this case.
the dom tree needs to be in a particular structure and contain attributes and values as expected by the different statements and conditions of the javascript function.
for instance in the case of sumtotalprice in order to test the calculation a dom tree needs to be present that meets the following constraints a dom element with id items must exist line that element needs to have one or more child nodes lines the child nodes must be of a dom element type that can hold values line e.g.
input value ... the values of the child nodes need to be positive line integers lines a dom element with id total must exist line .
a dom subtree that satisfies these constraints is depicted in figure which can be used as a test fixture for unit testing the javascript function.
there are currently many javascript unit testing frameworks available such as qunit jsunit and jasmine .
we use the popular qunit framework to illustrate the running example in this paper.
qunit provides a qunit fixture variable to which dom test fixturescan be appended in a test case.
a qunit unit test is shown in figure .
the execution of the test case with this particular fixture results in covering a path lines and .
if the fixture lacks any of the provided dom elements that is required in the execution path the test case fails and terminates before reaching the assertion.
other dom fixtures are required to achieve branch coverage.
for example to cover the true branch of the ifcondition in line the dom must satisfy the following constraints a dom element with id items must exist line that element must have no child nodes line a dom element with id message must exist line .
yet another dom fixture is needed for covering the else branch in line a dom element with id items must exist line that element needs to have one or more child nodes lines the child nodes must be of a dom element type that can hold values line e.g.
input the child nodes values need to be integers lines the value of a child node needs to be zero or negative line a dom element with id message must exist line .
a dom element with id total must exist line .
b. challenges as illustrated in this simple example different dom fixtures are required for maximizing javascript code coverage.
writing these dom fixtures manually is a daunting task for testers.
generating these fixtures is not an easy task either.
there are two main challenges in generating proper dom based fixtures that we address in our proposed approach.
challenge dom related variables.
javascript is a weaklytyped and highly dynamic language which makes static code analysis quite challenging .
moreover its interactions with the dom can become difficult to follow .
for instance in the condition of line in figure the value of the variable pis checked.
a fixture generator needs to determine that pis dom dependent and it refers to the value of a property of a dom element i.e.
itemlist.children .value .
challenge hierarchical dom relations.
unlike most test fixtures that deal only with primitive data types dombased test fixtures require a tree structure.
in fact dom fixtures not only contain proper dom elements with attributes and their values but also hierarchical parent child relations that can be difficult to reconstruct.
for example the dom fixture in figure encompasses the parent child relation between form and input elements which is required to evaluate itemlist.children.length and itemlist.children .value in the code lines and in figure .c.
dynamic symbolic execution our insight in this work is that the problem of generating expected dom fixtures can be formulated as a constraint solving problem to achieve branch coverage.
symbolic execution is a static analysis technique that uses symbolic values as input values instead of concrete data to determine what values cause each branch of a program to execute.
for each decision point in the program it infers a set of symbolic constraints.
satisfiability of the conjunction of these symbolic constraints is then checked through a constraint solver.
concolic execution also known as dynamic symbolic execution performs symbolic execution while systematically executing all feasible program paths of a program on some concrete inputs.
it starts by executing a program with random inputs gathers symbolic constraints at conditional statements during execution and then uses a constraint solver to generate a new input.
each new input forces the execution of the program through a new uncovered path thus repeating this process results in exploring all feasible execution paths of the program.
iii.
a pproach we propose a dom based test fixture generation technique called confix.
to address the highly dynamic nature of javascript confixis based on a dynamic symbolic execution approach.
scope.
since primitive data constraints can be solved using existing input generators for javascript in this paper we focus on collecting and solving dom constraints that enable achieving coverage for dom dependent statements and conditions in javascript code.
thus confixis designed to generate dom based test fixtures and function arguments for javascript functions that are dom dependent .
definition dom dependent function a dom dependent function is a javascript function which directly or indirectly accesses dom elements attributes or attribute values at runtime using dom apis.
an instance of a direct access to a dom element is document.getelementbyid items in the function dg line figure .
an indirect access is a call to another javascript function that accesses the dom.
for instance the statement at line of figure is an indirect dom access through function dg.
overview.
figure depicts an overview of confix.
at a high level confixinstruments the javascript code block and executes the function under test to collect a trace blocks and .
using the execution trace it deduces dom dependent path constraints block translates those constraints into xpath expressions block which are fed into an xml constraint solver block .
the solved xml tree is then used to generate a dom based fixture block which subsequently helps in covering unexplored paths block .
finally it generates a test suite by adding generated test fixtures into a javascript unit testing template such as qunit block .
in the following subsections we discuss each of these steps in more details.dom based fixturejavascript code instrument code execute function deduce dom dependent pcsexecution trace collect execution trace generate test casegenerated unit tests generate fixture apply fixture to cover a new pathinstrumented code solve xpath expressions translate pcs to xpath expressionssolved xml treefig.
processing view of our approach.
algorithm.
algorithm demonstrates our dom fixture generation technique.
the input to our algorithm is the javascript code the function under test f and optionally its function arguments provided by a tester or a tool .
the algorithm concolically generates dom fixtures required for exploring all dom dependent paths.
a. collecting dom based traces we instrument the javascript code under test algorithm line with wrapper functions to collect information pertaining to dom interactions which include statements or conditional constructs that depend on the existence of a dom structure element attribute or value.
the instrumentation is non intrusive meaning that it does not affect the normal functionality of the original program.
the instrumentation augments function calls conditionals inifand loop constructs infix expressions variable initializations and assignments and return statements with inline wrapper functions to store an execution trace see subsection iii e for more details .
such a trace includes the actual statement type of statement e.g.
infix condition or function call list of variables and their values in the statement the enclosing function name and the actual concrete values of the statement at runtime.
confixcurrently supports dom element retrieval patterns based on tag names ids and class names such as getelementbyid getelementsbytagname children innerhtml parentnode and for jquery based code.
after instrumenting the source code the modified javascript file is used in a runner html page that is loaded inside a browser line algorithm and then a javascript driver e.g.
webdriver executes the javascript function under test line .
this execution results in an execution trace which is collected from the browser for further analysis line .
b. deducing dom constraints an important phase of dynamic symbolic execution is gathering path constraints pcs .
in our work path constraints are conjunctions of constraints on symbolic dom elements.algorithm test fixture generation input javascript code js the function under test f function arguments forf output a set of dom fixtures fixtureset forf 1negatedconstraints ?
2domreftracklist ?
procedure generate fixture js f begin jsinst instrument js fixtureset ?
fixture ?
repeat browser load jsinst fixture browser execute f t browser getexecution trace fixture solve constraints t fixtureset fixtureset fixture untilfixture6 ?
return fixtureset procedure solve constraints t begin domreftracklist getdomr eference tracks t pc getpathconstraint t domreftracklist fixture unsat while fixture unsat do fixture ?
c getlastnonnegconst pc negatedconstraint ifc6 null then negatedconstraint negatedconstraint c pc negate constraint pc c xp generate xpath pc domreftracklist so l v e xpa t hco n s t r a i n t returns unsat if xpis not solvable.
fixture solve xpathconstraint xp return fixture definition symbolic dom element a symbolic dom element dis a data structure representing a dom element in terms of its symbolic properties and values.
dis denoted by a tuple p c a t where pisd s parent symbolic dom element.
cis a set of child symbolic dom elements of d. ais a set ofhatt valipairs each pair stores an attribute att ofdwith a symbolic value val.
tis the element type of d. note that keeping the parent children relation for dom elements is sufficient to recursively generate the dom tree.
dom constraints in the code can be conditional or nonconditional.
a non conditional dom constraint is a constraint on the dom tree required by a dom accessing javascript statement.
a conditional dom constraint is a constraint on the dom tree used in a conditional construct.
example .
consider the javascript code in figure .
in line document.getelementbyid x is a non conditional dom constraint i.e.
an element with a particular id is targeted.
on the other hand itemlist.children.length line is a conditional dom constraint i.e.
the number of child nodes of a dom element is checked to be zero.
non conditional dom constraints evaluate to null or a not null object while conditional dom constraints evaluate to true orfalse .
for example if we execute sumtotalprice with a dom subtree void of an elementwithid items the value of itemlist at line will be null and the execution will terminate at line when evaluating itemlist.children.length .
on the other hand if that element exists and has a child the condition at line evaluates to false .
in this work the input to be generated is a dom subtree that is accessed via dom apis in the javascript code.
as we explained in subsection ii b due to the dynamic nature of javascript its interaction with the dom can be difficult to follow challenge .
tracking dom interactions in the code is needed for extracting dom constraints.
aliases in the code add an extra layer of complexity.
we need to find variables in the code that refer to dom elements or element attributes.
to address this challenge we apply an approach similar to dynamic backward slicing except that instead of slices of the code we are interested in relevant dom referring variables.
to that end we use dynamic analysis to extract dom referring variables from the execution trace by first searching for dom api calls their arguments and their actual values at runtime.
the process of collecting dom referring variables algorithm line is outlined further in subsection iii e. once dom referring variables are extracted constraints on their corresponding dom elements are collected and used to generate constraints on symbolic dom elements see definition .
dom constraints can be either attributewise orstructure wise .attribute wise constraints are satisfied when special values are provided for element attributes.
for example parseint itemlist.children .value line of figure requires the value of the i th child node to be an integer greater than zero.
the value is an attribute of the child node in this example.
structure wise constraints are applied to the element type and its parent children relations.
for example in itemlist.children.length line of figure to cover the else branch lines an element with id items is needed with at least one child node.
the conjunction of these symbolic dom constraints in an iteration forms a path constraint.
for instance the structure wise constraint in parseint itemlist .children .value line of figure requires the child nodes to be of an element type that can hold values e.g.
input type and the attribute wise constraint requires the value to be a positive integer.
our technique reasons about a collected path constraint and constructs symbolic dom elements needed.
for each symbolic dom element confix infers the type of the parent node determines the type and number of child nodes and generates through a constraint solver satisfied values that are used to assign attributes and values i.e.
hatt valipairs .
the default element type for a symbolic dom element is div the div is a placeholder element that defines a division or a section in an html document.
it satisfies most of the element type constraints and can be parent child of many elements unless specific attributes values are accessed from the element which would imply that a different element type is needed.
for instance if the value is read set for an element the type of that element needs to change to for instance input because per definition the div type does not carry a value attribute more detail in subsection iii e .
these path constraints with satisfied symbolic dom elements are used to generatea corresponding xpath expression as presented in the next subsection.
c. translating constraints to xpath the problem of dom fixture generation can be formulated as a decision problem for the emptiness test of an xpath expression in the presence of xhtml meta models such as document type definitions dtd or xml schemas.
these meta models define the hierarchical tree like structure of xhtml documents with the type order and multiplicity of valid elements and attributes.
xpath is a query language for selecting nodes from an xml document.
an example is the expression child store child item child price which navigates the root through the toplevel store node to its item child nodes and on to its price child nodes.
the result of the evaluation of the entire expression is the set of all the price nodes that can be reached in this manner.
xpath is a very expressive language.
we propose a restricted xpath expression grammar shown in figure which we use to model our dom constraints in.
hxpath i hpath i hpath i hpath i hpath i hpath i hpath i child hname i hname i hqualifier i hqualifier iand hqualifier i hpath i hname i hname i hhtmltag i hattribute i hvalue i hhtmltag i a b button div form frame h1 h6 iframe img input i li link menu option ol p select span td tr ul hattribute i id type name class value src innerhtml title selected checked href size width height fig.
restricted xpath grammar for modeling dom constraints.
we transform the deduced path constraints with the symbolic dom elements into their equivalent xpath expressions conforming to this specified grammar.
these xpath expressions systematically capture the hierarchical relations between elements.
types of common constraints translated to expressions include specifying the existence of a dom element attribute value properties of style attributes type and number of child nodes or descendants of an element or binary properties such as selected not selected.
example .table i shows examples of collected dom constraints that are translated to xpath expressions for the running example.
for example in the first row the dom constraint document.getelementbyid items null is translated to the xpath expression div which expresses the desire for the existence of a div element with id items in the fixture.
the second row shows a more complex example including six dom constraints in a path constraint which are translated into a corresponding xpath expression.
d. constructing dom fixtures next the xpath expressions are fed into a structural xml solver .
the constraint solver parses the xpath expressions and compiles them into a logical representation which is testedtable i examples of dom constraints translated xpath expressions and solved xhtml instances for the running example.
dom constraints corresponding xpath expressions solved xhtml document.getelementbyid items null div div id items document.getelementbyid items null div div id items and div id items itemlist.children.length child input and input id confix1 value itemlist.children.length child div and div parseint itemlist.children .value child div div id message document.getelementbyid message null div id total document.getelementbyid total null for satisfiability.
if satisfiable the solver generates a solution in the xml language.
since an xhtml meta model i.e.
dtd is fed into the solver along with the xpath expressions the actual xml output is an instance of valid xhtml.
the last column of table i shows solved xhtml instances that satisfy the xpath expressions for the running example.
these solved xhtml instances are subsequently used to construct test fixtures.
each newly generated fixture forces the execution of the javascript function under test along a new uncovered path.
this is achieved by systematically negating the last non negated conjunct in the path constraint and solving it to obtain a new fixture in a depth first manner.
if a path constraint is unsatisfiable the technique chooses a different path constraint and this process repeats until all constraints are negated.
in the main loop of algorithm lines fixtures are iteratively generated and added to the fixtureset .
in the solveconstraints procedure a fixture is initialized to unsat the loop lines continues until the fixture is set either to a solved dom subtree1 line or to ?
line if there exist no non negated constraints in the pcs.
when a ?fixture returns from solveconstraints the loop in the main procedure terminates and the fixtureset is returned.
example .table ii shows the extracted path constraints and their values as well as the current and next iteration fixtures at each iteration of the concolic execution for the running example.
since there is no fixture available in the first iteration the constraint obtained is document.getelementbyid items null .
this means the execution terminates at line of the javascript code figure due to a null exception.
our algorithm negates the last non negated constraint docume nt.getelementbyid items null and generates the corresponding fixture div id items to satisfy this negated constraint.
this process continues until the solver fails at producing a satisfiable fixture in the sixth iteration.
unsat is returned because the constraints itemlist.chi ldren.length6 0and the newly negated one iteml ist.children.length require that the number of child nodes be negative which is not feasible in the dom structure.
it then tries to generate a fixture by negating the last nonnegated constraint without applying any fixtures i.e.
the path constraint extracted in the sixth iteration.
however in this case there are no non negated constraints left since the last one itemlist.children.length had already been negated and the result was not satisfiable.
consequently the algorithm terminates with an empty fixture in the last iteration.
the table 1note that solvexpathconstraint returns unsat when it fails to solve the given path constraint.also shows which paths of the running example are covered in terms of lines of javascript code.
e. implementation details confixcurrently generates qunit test cases with fixtures however it can be easily adapted to generate test suites in other javascript testing frameworks.
to parse the javascript code into an abstract syntax tree for instrumentation we build up on mozilla rhino .
to collect execution traces while executing a function in the browser we use webdriver .
xml solver.
to solve structure wise dom constraints using xpath expressions we use an existing xml reasoning solver .
a limitation with this solver is that it cannot generate xml structures with valued attributes i.e.
attributes are supported but not their values .
to mitigate this we developed a transformation technique that takes our generic xpath syntax figure and produces an xpath format understandable by the solver.
more specifically we merge attributes and their values together and feed them to the solver as single attributes to be generated.
once the satisfied xml is generated we parse and decompose it to the proper attribute value format as expected in a valid xhtml instance.
another limitation is that it merges instances of the same tag elements at the same tree level when declared as children of a common parent.
we resolved this by appending an auto increment number to the end of each tag and remove it back once the xml produced.
handling asynchronous calls.
another challenge we encountered pertains to handling asynchronous http requests that send retrieve data e.g.
in json xml format to from a server performed by using the xmlhttprequest xhr object.
this feature makes unit level testing more challenging since the server side generated data should also be considered in a test fixture as an xhr response if the function under test in directly uses the xhr and expects a response from the server.
existing techniques address this issue by mocking the server responses but they require multiple concrete executions of the application to learn the response.
this is however not feasible in our case because we generate javascript unit tests in isolation from other dependencies such as the server side code.
as a solution our instrumentation replaces the xhr object of the browser with a new object and redefines the xhr open method in a way that it always uses the get request method to synchronously retrieve data from a local url referring to our mocked server.
this helps us to avoid null exceptions and continue the execution of the function under test.
however if the execution depends on the actual value of the retrieved data and not merely their existence our current approach can not handle it.
in such cases a string solver may be helpful.table ii constraints table for the running example.
the next to negate field refers to the last non negated constraint.
iterationcurrent fixture current dom constraints negated next to negatefixture for the next iteration paths covered ?
document.getelementbyid items null div id items lines div id items document.getelementbyid items null div id items lines itemlist.children.length div id message document.getelementbyid message null div id items document.getelementbyid items null div id items lines and div id message itemlist.children.length div id confix1 document.getelementbyid message null div div id message div id items document.getelementbyid items null div id items lines div id confix1 itemlist.children.length div id confix1 and div itemlist.children.length div div id message parseint itemlist.children .value div id message document.getelementbyid message null div id total document.getelementbyid total null div id items document.getelementbyid items null div id items lines div id confix1 itemlist.children.length input id confix1 value and div itemlist.children.length div div id message parseint itemlist.children .value div id message div id total document.getelementbyid message null div id total document.getelementbyid total null div id items document.getelementbyid items null unsat negate last non negated lines input id confix1 value itemlist.children.length constraint and div itemlist.children.length div id message parseint itemlist.children .value div id total document.getelementbyid message null document.getelementbyid total null div id items document.getelementbyid items null no non negated constraint exists input id confix1 value itemlist.children.length fixture ?
div itemlist.children.length div id message parseint itemlist.children .value div id total document.getelementbyid message null document.getelementbyid total null tracking dom referring variables.
to detect dom referring variables used to generate constraints on symbolic dom elements definition we automatically search for dom api calls their arguments and their actual values at runtime in the execution trace.
algorithm keeps track of dom