leveraging program analysis to reduce user perceived latency in mobile applications yixue zhao marcelo schmitt laser yingjun lyu nenad medvidovic university of southern california pontifical catholic university of rio grande do sul los angeles ca usa porto alegre rs brazil yixue.zhao yingjunl neno usc.edu marcelo.laser gmail.com abstract reducing network latency in mobile applications is an effective way of improving the mobile user experience and has tangible economic benefits.
this paper presents paloma a novel clientcentric technique for reducing the network latency by prefetching http requests in android apps.
our work leverages string analysis and callback control flow analysis to automatically instrument appsusingpaloma srigorousformulationofscenariosthataddress what and when to prefetch.
paloma has been shown to incur significant runtime savings several hundred milliseconds perprefetchablehttprequest bothwhenappliedonareusable evaluation benchmark we have developed and on real applications.
introduction inmobilecomputing user perceivedlatencyisacriticalconcernas it directly impacts user experience and often has severe economic consequences.arecentreportshowsthatamajorityofmobileusers would abandon a transaction or even delete an app if the response timeofatransactionexceedsthreeseconds .googleestimates thatanadditional500msdelaypertransactionwouldresultinupto loss of traffic while amazon estimates that every 100ms delay would cause annual sales loss .
a previous study showed that network transfer is often the performance bottleneck and mobile apps spend of their time fetching data from the internet .
a compounding factor is that mobile devices rely onwirelessnetworks which can exhibit high latency intermittent connectivity and low bandwidth .
reducing network latency thus becomes a highly effective way ofimprovingthemobileuserexperience.inthecontextofmobile communication wedefine latencyastheresponsetimeofanhttp request.
in this paper we propose a novel client centric technique for minimizing the network latency by prefetching http requests inmobileapps.prefetchingbypassestheperformancebottleneck inthiscase networkspeed and maskslatencybyallowingaresponse to a request to be generated immediately from a local cache.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
has been explored in distributed systems previously.
existingapproachescanbedividedintofourcategoriesbasedon whatthey prefetch and whenthey do so.
server based techniquesanalyzetherequestssenttotheserverandprovide hints totheclientonwhattoprefetch .however mostoftoday smobileappsdependextensivelyonheterogeneousthird party servers.thus providingserver side hints isdifficult notscalable orevenimpossiblebecauseappdevelopersdonothavecontrolover thethird partyservers .
human based approachesrelyon developerswhohavetoexplicitlyannotateapplicationsegments that are amenable to prefetching .
such approaches are error prone and pose significant manual burden on developers.
history based approaches build predictive models from prior requeststoanticipatewhatrequestwillhappennext .
suchapproachesrequiresignificanttimetogatherhistoricaldata.
additionally buildingaprecisepredictivemodelbasedonhistoryis moredifficultintoday ssettingbecausethecontextofmobileusers changesfrequently.
domain based approachesnarrowdownthe problemtoonespecificdomain.forexample approachesthatfocus onthesocialnetworkdomain onlyprefetchtheconstant urls in tweets based on user behavior and resource constraints.
these approaches cannot be applied to mobile apps in general.
to address these limitationsof current prefetching approaches we have developed paloma program analysis for latency optimizationofmobileapps anoveltechniquethatis client centric automatic domain independent andrequiresnohistoricaldata.in this paper we focus on native android apps because of android s dominant market share and its reliance on event driven interaction which is the most popular style used in mobile apps today.
our guiding insight is that an app s codecan provide a lot of useful information regarding whathttp requests may occur and when.inaddition amobileuserusuallyspendsmultipleseconds decidingwhateventtotriggernext aperiodknownas userthink time providinganopportunitytoprefetchhttprequests in the background.
by analyzing an android program we are able toidentifyhttprequestsandcertainuser eventsequences e.g.
onscroll followed by onclick .
with that information we can prefetch requests that will happen next during user think time.
user eventtransitionsarecapturedascallbackcontrol flow relationships in paloma and we only perform very targeted short term prefetching a singlecallback ahead.
there are several reasons we opted for this strategy.
first short term prefetching minimizes the cache staleness problem that is commonly experiencedbylonger termprefetchingbecausethenewlyupdatedcache acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg swedenyixue zhao marcelo schmitt laser yingjun lyu nenad medvidovic will be used immediately when the user transitions to the next event.
second the information needed to send the http requests e.g.
a parameterin anhttp requestthat dependson userinput is more likely to be known since the prefetching occurs very close intimetotheactualrequest.third short termprefetchingtakes advantage of user think time between callbacks which has been showntobesufficientforprefetchinghttprequests .by contrast prefetching withinthesamecallback wouldnotprovide a performance gain since the relevant statements would execute within a few milliseconds of one another.
paloma comprises four major elements.
string analysis identifies the prefetchable requests by interpreting each url string.
callbackanalysis determines theprefetching points for the prefetchable requests by analyzing callback control flow relationships.
appinstrumentation modifiestheoriginalappbased on the information extracted in the previous phases and outputs anoptimizedappthatprefetchesthehttprequests.
runtime prefetching involves the optimized app and a local proxy that is in charge of prefetching http requests and managing the responses.
paloma sfirsttwoelementsareadaptationsandextensionsofexisting techniques while the latter two have been newly developed.
palomahasbeenevaluatedforaccuracyandeffectivenessin two different ways.
first we developed a microbenchmark mbm that isolates different prefetching conditions that may occur in an android app.
the mbm can be reused for evaluating similar futureapproaches.second weappliedpalomaon32realandroidapps.ourevaluationshowsthatpalomaexhibitsperfectaccuracy in terms of precision and recall and virtually eliminates userperceived latency while introducing negligible runtime overhead.
thispapermakesthefollowingcontributions paloma a novel client side automated program analysis basedprefetching techniqueformobileapps arigorousformulationofprogram analysis based prefetching scenarios that addresses what and when to prefetch a comprehensive reusable mbm to evaluate prefetching techniques for android apps and the implementation of an open source extensible framework for program analysis basedprefetching.paloma ssourcecodeandsupporting materials are publicly available .
the paper is organized as follows.
section motivates the problem and defines the terms used by paloma.
sections and describe paloma s approach and implementation.
sections and detail paloma s evaluation using a benchmark and real apps.
section presents related work and section concludes the paper.
background and motivation inthissection weuseaconcreteexampletointroducethefundamental building blocks and execution model of mobile apps with a particular focus on android.
we then introduce our insights and motivation followed by the definition of several key terms.
.
mobile app example mobile apps that depend on network generally involve two key concepts eventsthatinteractwithuserinputsand networkrequests that interact with remote servers.
we explain these concepts via listing1 ssimplifiedcodefragmentofanandroidappthatresponds to user interactions by retrieving weather information.
events in mobile apps user interactions are translated to internalappevents.forinstance ascreentapistranslatedtoan onclickevent.
each event is in turn registered to a particular application uiobjectwithacallbackfunction thecallbackfunctionisexecuted when the event is triggered.
for instance in listing the button objectsubmitbtn isregisteredwithan onclick event line9 and thecorrespondingcallbackfunction onclick line10 willbeexecuted when a user clicks the button.
similarly the drop down box objectcitynamespinner is registered with an onitemselected event that has an onitemselected callback function lines .
networkrequests withinaneventcallbackfunction theapp often has to communicate with remote servers to retrieve information.thecommunicationisperformedthroughnetworkrequests overthehttpprotocolinmostnon realtimeapps .eachhttp request is associated with a url field that specifies the endpoint of therequest.forinstanceinlisting1 the onclickeventcallback sends three http requests eachwith a unique url lines12 .
therearetwotypesofurlvalues dependingonwhenthevalue is known staticanddynamic.
for instance favcityid in listing isstaticbecauseitsvalueisobtainedstaticallybyreadingtheapplication settings lines .
similarly getstring domain reads the constant string value defined in an android resource file line12 .incontrast cityname isdynamicsinceits valuedependsonwhichitemauserselectsfromthedrop downbox citynamespinner duringruntime lines7 .similarly cityid is also a dynamic url value lines .
1classmainactivity 2string favcityid cityname cityid 3protected void oncreate 4favcityid readfromsetting favcityid static 5citynamespinner.setonitemselectedlistener new onitemselectedlistener public void onitemselected cityname citynamespinner.getselecteditem .tostring dynamic 9submitbtn.setonclicklistener new onclicklistener public void onclick cityid cityidinput.gettext .tostring dynamic url url1 newurl getstring domain weather?
cityid favcityid url url2 newurl getstring domain weather?cityname cityname url url3 newurl getstring domain weather?cityid cityid urlconnection conn1 url1.openconnection parse conn1.getinputstream urlconnection conn2 url2.openconnection parse conn2.getinputstream urlconnection conn3 url3.openconnection parse conn3.getinputstream startactivity displayactivity.class listing code snippet with callbacks and http requests .
motivation and challenges themotivationforpalomaisthatonecansignificantlyreduce theuser perceivedlatencybyprefetchingcertainnetworkrequests.
for instance listing corresponds to a scenario in which a userselects a city name from the drop down box citynamespinner line then clicks submitbtn line to get the city s weather informationthroughanhttprequest.toreducethetimetheuser willhavetowaittoreceivetheinformationfromtheremoteserver a prefetching scheme would submit that request immediately after the user selects a city name i.e.
before the user clicks the button.
prefetching http requests is possible for two reasons.
first an httprequest sdestinationurlcansometimesbeknownbefore theactualrequestissentout suchasthestaticurl url1 line12 in listing .
second there is often sufficiently long slack between the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
leveraging program analysis to reduce user perceived latency in mobile applicationsicse may june gothenburg sweden time a request s url value is known and when the request is sent out duetoothercode sexecutionandthe userthinktime .
prefetching in effect hides the network latency by overlapping the network requests with the slack period.
the key challenges to efficiently prefetching http requests involve determining which http requests to prefetch what their destination url values are and when to prefetch them.
priorworkaddressedthesechallengesbyrelyingonvariousserver hints developer annotations and patterns of historical user behaviors .
our goal is to avoid relyingonsuchexternalinformationthatmaybedifficulttoobtain and instead to use only program analysis on the app.
.
terminology we define several terms needed for describing our approach to program analysis based prefetching of network requests.
url spot is a code statement that creates a url object for an http request based on a string denoting the endpoint of the request.
example url spots are lines and in listing .
definition spot m nis a code statement where the value of a dynamicurlstringisdefined suchaslines7and11inlisting1.
m denotesthe mthsubstringintheurlstring and ndenotesthe nth definition of that substring in the code.
for example line would containdefinitionspot l73 1forurl2becausecityname isthethird substringin url2andline7isthefirstdefinitionof cityname .a singlestatementofcodemayrepresentmultipledefinitionspots each of which is associated with a dynamic string used in different urls.
fetchspot is a code statement where the http request is sent to the remote server.
example fetch spots are lines and .
callback is a method that is invoked implicitly by the android framework in response to a certain event.
example callbacks from listing include the onitemselected line and onclick line methods.
these are referred to as event handler callbacks in android as they respond to user interactions .
android also defines a set of lifecycle callbacks that respond to the change of an app s life status such as the oncreate method at line .
call graph is a directed graph representing the explicitinvocation relationships between procedures in the app code.
target method is a method that contains at least one fetch spot.
it is named that because identifying methods that contain oncreate mainactivity wn1 onclick button onitemselected spinner oncreate displayactivity1 callback class legend figure ccfg extracted from listing by gator fetch spots is the target of paloma s analysis see section .
for example the onclick method is a target method because it contains three fetch spots.
a target method may or may not be a callback.
targetcallback isacallbackthatcanreachatleastonetarget method in a call graph.
if a target method itself is a callback itisalsoatargetcallback.forexample the onclick callback defined at lines of listing is a target callback.
callbackcontrol flowgraph ccfg representsthe implicitinvocationflowinvolvingdifferentcallbacks .inaccfg nodes represent callbacks and each directed edge f sdenotes that sis the next callback invoked after f. figure illustrates the ccfg extracted from listing1 using gator a recently developedanalysis technique .
await node in a ccfg e.g.
wn1in figure indicatesthattheuser sactionisrequiredandtheeventshetriggers will determine which one of the subsequent callbacks is invoked.
trigger callback is any callback in the ccfg that is an immediate predecessor of a target callback with only a wait node between them.
for instance in listing the trigger callbacks for the target callback onclick areoncreate path and onitemselected path .
note that onclick cannot be thetriggercallback for displayactivity soncreate method path because there is no wait node between them.
triggerpoint istheprogrampointthattriggerstheprefetching of one or more http requests.
aproach thissectionpresentspaloma aprefetching basedsolutionforreducing user perceived latency in mobile apps that does not require anydevelopereffortorremoteservermodifications.palomais motivatedbythefollowingthreechallenges whichhttprequestscanbeprefetched whattheirurlvaluesare and when to issue prefetching requests.
our guiding insight is that static program analysis can help us address all three challenges.
to that end palomaemploysanoffline onlinecollaborativestrategyshownin figure .
the offline component automatically transforms a mobile app into a prefetching enabled app while the online component issues prefetching requests through a local proxy.
palomahasfourmajorelements.itfirstperformstwostatic analyses it identifies http requests suitable for prefetching viastringanalysisand detectsthepointsforissuingprefetching requests i.e.
trigger points for each identified http request via callback analysis.
paloma then instruments the app automaticallybasedontheextractedinformationandproducesanoptimized prefetching enabled app.
finally at runtime the optimized app will interact with a local proxy deployed on the mobile device.
the figure high level overview of the paloma approach authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yixue zhao marcelo schmitt laser yingjun lyu nenad medvidovic figure paloma s detailed workflow.
different analysis toolsemployedbypalomaandartifactsproducedbyitare depicted with a distinction drawn between those that are extensions of prior work and newly created ones.
local proxy issues prefetching requests on behalf of the app andcachesprefetchedresourcessothatfutureon demandrequestscan be serviced immediately.
we detail these four elements next.
.
string analysis thegoalofstringanalysisistoidentifytheurlvaluesofhttp requests.prefetchingcanonlyhappenwhenthedestinationurlof anhttprequestisknown.thekeytostringanalysisistodifferentiatebetweenstaticanddynamicurlvalues.astaticurlvalue is the substring in a url whose concrete value can be determined usingconventionalstaticanalysis.incontrast adynamicurlvalue is the substring in a url whose concrete value depends on user input.
for this reason we identify the definition spots of dynamic url values and postpone the actual value discovery until runtime.
asfigure3shows theoutputofstringanalysisisaurlmapthat willbeusedbytheproxyatruntime section3.
andthedefinition spot in the url map will be used by the app instrumentation step section .
.
the url map relates each url substring with its concrete value for static values or definition spots for dynamic values .
in the example of listing the entry in the url map that is associated with url2would be url2 wenowexplainhowtheurlmapiscreatedforstaticanddynamic url values.
staticvalue analysis to interpret the concrete value of each staticsubstring wemustfinditsuse definitionchainandpropagate the value along the chain.
to do that we leveraged a recent string analysisframework violist thatperformscontrol anddataflow analyses to identify the value of a string variable at any given programpoint.violistisunabletohandleimplicituse definition relationships that are introduced by the android app development framework.
in particular in android string valuescan be defined in a resource file that is persisted in the app s internal storage and retrievedduringruntime.forinstanceinlisting1 allthreeurls have a substring getstring domain lines which is defined in the app s resource file .
paloma extends violist to properlyidentifythiscaseandinclude theapp sresourcefilethat isextractedbydecompilingtheappinthecontrol anddata flow analysis.intheend theconcretevalueofeachstaticsubstringin each url is added to the url map.dynamic value analysis dynamic url values cannot be determinedbystaticanalysis.instead palomaidentifiesthelocations where a dynamic value is defined i.e.
its definition spots.
the definitionspots are later instrumented see section .
such that the concrete values can be determined at runtime.
the key challenge in identifying the definition spots is that a url string may be defined in a callback different from the callback where the url is used.
recall that due to the event driven execution model callbacks are invoked implicitly by android.
therefore the control flow between callbacks on which the string analysis depends cannot be obtained by analyzing the app code statically.
solvingtheinter callbackdata flowproblemisoutsidethescope of this paper.
this is still an open problem in program analysis because of the implicit control flow among callbacks as well as the complex and varied types of events that can trigger callbacks at runtime such as gui events e.g.
clicking a button system events e.g.
screen rotation and background events e.g.
sensor data changes .researchefforts onunderstandingcallbacksarelimited to specific objectives that prevent their use for string analysis in general.sucheffortshaveincludedafocusrestrictedtogui related callbacks whichwedouseinourcallbackanalysis detailed in section .
assumption thatcallback control flow can be inany arbitraryorder andanalysisoftheandroidframework level but not app level code to construct callback summaries .
tomitigatetheseshortcomings wedevelopedahybridstatic dynamic approach where the static part conservatively identifies all potentialdefinitionspots leavingtotheruntimethedetermination of which ones are the actualdefinition spots.
in particular we focusonthedefinitionspotsofclassfieldsbecauseafieldisacommon wayto passdata between callbacks.we identifyall potential definition spots in two ways.
first if a string variable is a private memberofaclass weincludeallthedefinitionspotsinsidethat class such as constructor methods setter methods and definitions in the static block.
second if a variable is a public member of a class that variable can be defined outside the class and we conduct a whole program analysis to find all assignments to the variable that propagate to the url.
at the end of the analysis all substring definition spots for a urlareaddedtotheurlmap.itisworthnotingthatalthoughthe staticanalysisisconservativeandmultipledefinitionspotsmay berecordedin theurlmap the truedefinitionspotwillemerge at runtime because false definitions will either be overwritten by a later true definition i.e.
a classic write after write dependency or will never be encountered if they lie along unreachable paths.
.
callback analysis callback analysis determines where to prefetch different http requests i.e.
thetriggerpointsintheappcode.theremaybemultiplepossibletriggerpointsforagivenrequest dependingonhowfarinadvancetheprefetchingrequestissentbeforetheon demand requestisactuallyissued.themostaggressivestrategywouldbe toissueanhttprequestimmediatelyafteritsurlvalueisdiscovered.however thisapproachmayleadtomanyredundantnetwork transmissions theurlvaluemaynotbeusedinanyon demand requests i.e.
it may be overwritten or the callback containing the httprequest i.e.
thetargetcallback maynotbereachedatruntimeatall.incontrast themostaccuratestrategywouldbetoissue authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
leveraging program analysis to reduce user perceived latency in mobile applicationsicse may june gothenburg sweden algorithm identifytriggercallbacks input ccfg ecg app output triggermap 1instrumenttimestamp app 2networkmethodlo s profile app 3si nature getfetchsignature networkmethodlo s 4requests getreqests si nature 5tri ermap 6foreachreq requestsdo 7tarmethod gettargetmethod req 8tar etcallbacks findentries tarmethod ecg 9foreachtarcallback targetcallbacks do tri ercallbacks getimdiatepredecessors tarcallback ccfg foreachtri callback triggercallbacks do tri ermap .add tri callback req .url 13returntri ermap the prefetching request right before the on demand request is sent.
however this strategy would yield no improvement in latency.
ourapproachistostrikeabalancebetweenthetwoextremes.
specifically paloma issues prefetching requests at the end of the callbackthatis theimmediatepredecessorofthetargetcallback.
recallfromsection2thatwerefertothetargetcallback simmediatepredecessorastriggercallback becauseittriggersprefetching.
thisstrategyhasthedualbenefitof takingadvantageofthe user thinktime betweentwoconsecutivecallbackstoallowprefetching to take place while providing high prefetching accuracy as the trigger point is reasonably close to the on demand request.
asfigure3shows palomacreatesatriggermapattheendof callback analysis that is used by app instrumentation section .
.
the trigger map maps each trigger callback to the urls that will beprefetchedattheendofthatcallback.intheexampleoflisting1 the trigger map will contain two entries becauseboth oncreate andonitemselected aretriggercallbacksthataretheimmediatepredecessorsofthetargetcallback onclick which in turn contains url1 url2 and url3.
algorithm1detailshowpalomaidentifiestriggercallbacks and constructs the trigger map.
in addition to the app itself the algorithmreliesontwoadditionalinputs bothobtainedwiththehelp ofoff the shelf tools thecallbackcontrol flowgraph ccfg and the call graph cg .
note that the ccfg we use in our callback analysis is restricted to gui callbacks that are triggeredby user actions recall section .
however this fits paloma s needsgivenitsfocusonuser initiatednetworkrequests.theccfg captures the implicit invocation flow of callbacks in android and thus allows us to find the trigger callbacks of a given target callback.ontheotherhand thecg whichisextractedbysoot captures the control flow between functions and thus allows usto locate the callbacks that contain any given method.
however the cg does not include the direct invocations that are initiated from the android framework.
we identified such invocations from android s documentation and extended the cg with the resultingdirect edges.
an example is the execute edgefromthe asynctask class thatiswidelyusedfornetwork operations in android.
we refer to the thus extended cg as ecg.
giventheseinputs palomafirstidentifiesthesignatureofa fetch spot i.e.
the method that issues http requests by profiling theapp lines1 3ofalgorithm1 .wefoundthattheprofilingis needed because the methods that actually issue http requestsunder different circumstances can vary across apps.
for example the getinputstream method from java s urlconnection library may consume hundreds of milliseconds in one app but zeroinanotherappwhere e.g.
the getresponsecode method consumesseveralhundredmilliseconds.1thus weobtainthesignatures by instrumenting timestamps in the app and select the most time consuming network operations according to our profiling results.
using the signatures we then identify all http requeststhat the app can possibly issue line .
in the example of listing1 thesignaturewouldbe getinputstream andtherequests would be conn1.getinputstream conn2.getinputstream andconn3.getinputstream .
we iterate through each discovered request and identify the method in which the request is actually issued i.e.
the target method line .
using the control flow information that the ecg provides we locate all possible target callbacksofatargetmethod line8 .wetheniteratethrougheach target callback and identify all of its immediate predecessors i.e.
triggercallbacks accordingtotheccfg line10 .finally weadd each trigger callback url pair to the trigger map lines .
.
app instrumentation paloma instruments an app automatically based on the information extracted from the two static analyses and produces an optimized prefetching enabled app as figure shows.
at runtime the optimized app will interact with a local proxy that is in charge of issuing prefetching requests and managing the prefetched re sources section .
.
while paloma s app instrumentation isfully automated and it does not require the source code of the app paloma also supports appdevelopers whohave theknowledge and the source code of the app to further improve runtime latencyreductionviasimpleprefetchinghints.wedescribethetwo instrumentation aspects next.
.
.
automated instrumentation palomaperformsthreetypesofinstrumentationautomatically.
each type introduces a new api that we implement in an instrumentationlibrary.listing2showsaninstrumentedversionofthe app from listing with the instrumentation code bolded.
we will use this example to explain the three instrumentation tasks.
.
update url map this instrumentation task updates the url map as new values of dynamic urls are discovered.
recall thatthevaluesof staticurlsarefullydeterminedandinsertedinto theurlmapoffline.thisinstrumentationisachievedthrougha newapi senddefinition var url id whichindicatesthat varcontains the value of the idthsubstring in the url named url.theresultingannotationisinsertedrightaftereachdefinition spot.
forinstance atline 8of listing paloma will updatethe 1in this paper we focus on urlconnection a built in java standard library widely used by android developers.
if the developer is using a different library and or knows which method s to optimize then paloma s profiling step may not be needed.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yixue zhao marcelo schmitt laser yingjun lyu nenad medvidovic thirdsubstringin url2withtheruntimevalueof cityname .this ensuresthattheurlmapwillmaintainafreshcopyofeachurl s value and will be updated as soon as new values are discovered.
.
trigger prefetching this instrumentation task triggers prefetching requests at each trigger point.
a trigger point in paloma is at the end of a trigger callback.
we made this choice for two reasons on one hand it makes no discernible difference in terms of performance where we prefetch within the same callback on the other hand placing the trigger point at the end is more likelytoyieldknownurls e.g.
whenthedefinitionspotisalso within the trigger callback .
paloma provides this instrumentation via the triggerprefetch url1 ... api.
the urlsthat aretobeprefetchedareobtainedfromthetriggermapconstructed in the callback analysis recall section .
.
for instance paloma triggers the proxy to prefetch url1 url2 andurl3at the end of onitemselected line9 and oncreate line26 oflisting2 which is consistent with the trigger map built in section .
.
.
redirect requests this instrumentation task redirects all on demand http requests to paloma s proxy instead of the origin server.
this allows on demand requests to be served fromtheproxy scache withoutlatency inducingnetworkoperations.
thecaseswheretheproxy scachedoesnotcontaintheresponse to a request are discussed in section .
.
the request redirection is achieved through the fetchfromproxy conn api where conn indicates the original url connection which is passed in case the proxystillneedstomaketheon demandrequesttotheoriginserver.
thisinstrumentationreplacestheoriginalmethodsateachfetch spot callstothe getinputstream methodatlines16 and20 oflisting 1arereplacedwith callstothe fetchfromproxy conn method at lines and in listing .
.
.
developer hints althoughpalomacanautomaticallyinstrumentmobileappswithout developer involvement it also provides opportunities for developers to add hints in order to better guide the prefetching.
in particular palomaenablestwowaysfordeveloperstoprovide 1classmainactivity 2string favcityid cityname cityid 3protected void oncreate favcityid readfromsetting favcityid static citynamespinner.setonitemselectedlistener new onitemselectedlistener public void onitemselected cityname citynamespinner.getselecteditem .tostring dynamic senddefinition cityname url2 triggerprefetch url1 url2 url3 submitbtn.setonclicklistener new onclicklistener public void onclick cityid cityidinput.gettext .tostring dynamic senddefinition cityid url3 url url1 newurl getstring domain weather?
cityid favcityid url url2 newurl getstring domain weather?cityname cityname url url3 newurl getstring domain weather?cityid cityid urlconnection conn1 url1.openconnection parse fetchfromproxy conn1 urlconnection conn2 url2.openconnection parse fetchfromproxy conn2 urlconnection conn3 url3.openconnection parse fetchfromproxy conn3 startactivity displayactivity.class triggerprefetch url1 url2 url3 listing example code of the optimized apphints by using its instrumentation apis and by directly modifying its artifacts.
these two approaches are described below.
apisupport paloma sthreeapifunctionsdefinedintheinstrumentationlibrary senddefinition triggerprefetch andfetchfromproxy can be invoked by the developers explicitlyintheappcode.forinstance ifadeveloperknowswherethe true definition spots are she can invoke senddefinition at those locations.
developers can also invoke triggerprefetch at any program point.
for example prefetching can happen fartheraheadthanisdoneautomaticallybypalomaifadeveloperknows thattheresponsestoaprefetchingrequestanditscorresponding on demand request will be identical.
artifact modification using paloma s instrumentation apis in themanner described aboverequires modifications to the appsourcecode.analternativeistodirectlymodifytheartifacts generated by paloma s static analyses trigger map fetch spot signature anddefinitionspot recallfigure3 withoutaltering the code.
for example a developer can add an entry in the trigger map as a result paloma s instrumenter will automatically insert a call totriggerprefetch at the end of the trigger callback specified by the developer.
we now introduce two frequently occurring instances where developers are well positioned to provide prefetching hints with verylittle manualeffort.
thesehints canbe providedusing either of the above two approaches.
prefetching at app launch launching an app may take several seconds or more because many apps request remote resources typically toward the end of the launch process.
the urls of the launch time requests are usually statically known but the ways in whichtheurlvaluescanbeobtainedarehighlyapp dependent.
for instance apps may retrieve the request urls from a configurationfileoralocaldatabase.supportingthosecasesinpaloma s string analysis would mean that paloma must understand the semanticsofeachindividualapp whichisnotareasonablerequirement.
however a practical alternative is for developers to provide prefetching hints because they understand their own apps behavior.
one way developers could implement this is to insert into the urlmapadditionalstaticurlsandthencall triggerprefetch at the beginning of oncreate which for paloma s purposes can be treated as the app entry point in most android applications.
prefetching for listview thelistview class is commonly used in android apps to display the information of a list of items.
the app jumps to another page to display further informationbasedontheitemauserselectsinthelist.theurlfetchedfor the page to which the app jumps is typically only known after theuserselectstheiteminthelist.ordinarily thiswouldprevent prefetching.
however android apps tend to exhibit two helpful trends.
first the list view usually displays similar types of informa tion.
second the further information obtained by selecting an item is related to the information displayed in the list itself.
based on these observations we identified and are exploiting in palomasimilarpatternsintheurlsforthelistandthesubsequentpage.
considera wallpaperappforillustration theurlthatis fetched to render an item in the list view may be image1url small.jpg while the url that is fetched after the user selects image1may be image1url large.jpg .
based on this pattern we have explored manuallyaddingdefinitionspotsoftheurlsthatarefetchedin authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
leveraging program analysis to reduce user perceived latency in mobile applicationsicse may june gothenburg sweden algorithm triggerprefetch input requests 1foreachreq requestsdo 2ifisknown req .url and iscached req then setwaitflag req response req .fetchremoteresponse cache .put req response unwait req the list view and sending modified values to the proxy such as replacing small with large in the wallpaper example.
.
runtime prefetching paloma s first three phases are performed offline.
by contrast this phase captures the interplay between the optimized apps and paloma sproxytoprefetchthehttprequestsatruntime.the instrumented methods in an optimized app trigger the proxy to performcorrespondingfunctions.wenowusetheexamplefrom listing to show how the three instrumented functions from section .
.
interact with the proxy.
.updateurlmap whentheconcretevalueofthe dynamic urlisobtainedatruntime theinsertedinstrumentationmethod senddefinition var url id isexecutedandtheconcreteruntime value is sent to the proxy.
in response the proxy updates the correspondingurlvalueintheurlmap.forinstanceinlisting2 whenauserselectsacitynamefromthe citynamespinner line7 the concrete value of cityname will be known e.g.
gothenburg .
thencityname issenttotheproxy line8 andtheurlmapentryforurl2willbeupdatedto url2 weather?
cityname gothenburg .
.
trigger prefetching whentheinsertedinstrumentation methodtriggerprefetch url1 ... isexecuted ittriggersthe proxy to perform triggerprefetch as shown in algorithm .for each request that is sent to the proxy by triggerprefetch url1 ... the proxy checks if the whole url of the request is knownbuttheresponsetotherequesthasnotyetbeencached line .ifbothconditionsaremet a wait flagissetinthecacheforthat request line3 .thisensuresthatduplicatedrequestswillnotbe issuedinthecasewhentheon demandrequestismadebytheuser beforetheresponsetotheprefetchingrequesthasbeenreturned fromtheoriginserver.intheexampleoflisting2 whentheapp reaches the end of oncreate line it triggers the proxy to performtriggerprefetch url1 url2 url3 .onlyurl1meetsboth conditionsatline2ofalgorithm2 theurlvalueisconcrete itis infact astaticvalue andtheresponseisnotinthecache.theproxy thussetsthe wait flagfor url1inthecache prefetches url1from theoriginserver storestheresponseinthecache andfinallysends an unwait signal to the on demand request that is waiting for the prefetched request line .
thereafter when the user selects a city name from the dropdown box onitemselected line of listing2 willbetriggered.attheendof onitemselected line9 triggerprefetch url1 url2 url3 is invoked again and url2 will be prefetched because its url is known its dynamic value obtained at line and has not been previously prefetched.
in contrast thevalueof url1isknownatthispointbut url1wasalready prefetched at line so the proxy will not prefetch url1.algorithm replacedfetch input req requests output response responses 1ifiscached req then 2ifgetwaitflag req istruethen wait req 4returncache .getresponse req 5else 6response req .fetchremoteresponse 7cache .put req response 8returnresponse .
redirect requests whentheon demandrequestissent at the fetch spot the replaced function fetchfromproxy conn will be executed and it will in turn trigger the proxy to perform replacedfetch as shown in algorithm .
if the request has a corresponding response in the cache the proxy will first check the wait flag for the request.
if the flag is set the proxy will wait for the signal of the prefetching request line and will return the response of the prefetching request when it is back from the origin server line4 .ifthe wait flaghasnotbeenset theresponseis alreadyinthecacheandtheproxyreturnstheresponseimmediately with no network operations involved line .
otherwise if the cachedoesnotcontaintheresponsetotherequest theproxyissues anon demandrequestusingtheoriginalurlconnection connto fetchtheresponsefromtheoriginserver storestheresponseinthe cache andreturnstheresponsetotheapp line6 .forinstancein listing if a user clicks submitbtn fetchfromproxy conn will beexecutedtosendon demandrequestsfor url1 url2 url3tothe proxy lines and of listing .
the proxy in turn returns theresponsesto url1andurl2fromthelocalcacheimmediately becauseurl1andurl2areprefetchedatlines26and9respectively as discussed above.
url3is not known at any of the trigger points sotheresponseto url3willbefetchedfromtheoriginserveron demand as in the original app.
note that if a user did not select a city name from the dropdown box before clicking submitbtn onitemselected will not be triggered meaning that lines and of listing will not be executed.
in this case only the response for url1will be returned from the cache prefetched at line while the on demand requests for url2andurl3will be routed to the origin server.
implementation paloma has been implemented by reusing and extending several off the shelf tools and integrating them withnewly implemented functionality.paloma sstringanalysisextendsthestringanalysis framework violist .
the callback analysis is implemented on top of the program analysis toolkit gator and by extending gator s ccfg analysis .
paloma s instrumentation componentisastand alonejavaprogramthatusessoot toinstrument an app.
the proxy is built on top of the xposed framework that provides mechanisms to hook method calls.
the proxy interceptsthemethodsthataredefinedinpaloma sinstrumentationlibrary andreplacestheirbodieswithcorrespondingmethodsimplemented intheproxy.thetotalamountofnewlyaddedcodetoextendexistingtools implementthenewfunctionality andintegratethem together in paloma is java sloc.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yixue zhao marcelo schmitt laser yingjun lyu nenad medvidovic microbenchmark evaluation inthissection wedescribethedesignofamicrobenchmark mbm containingasetoftestcases whichweusedtoevaluatepaloma s accuracy andeffectiveness.
mbmthoroughlycoversthespaceofprefetchingoptions wherein eachtestcasecontainsasinglehttprequestanddiffersinwhether and how that request is prefetched.
the mbm is restricted to individualhttprequestsbecausetherequestsareissuedandprocessed independently of one another.
this means that paloma will process multiple http requests simply as a sequence of individual requests anyconcurrencyintheirprocessingthatmaybeimposed bythenetworklibraryand ortheosisoutsidepaloma spurview.
inpractice thelook uptimeformultiplerequestsvariesslightly from one execution of a given app to the next.
however as shown insection5.
thelook uptimerequiredbypalomawouldnotbe noticeabletoauserevenwithalargenumberofrequests.aswe willshowinsection6 thenumberofhttprequestsinrealapps istypicallybounded.moreover palomaonlymaintainsasmall cache that is emptied every time a user quits the app.
intherestofthissection wewillfirstlayoutthegoalsunderlyingthembm sdesign section5.
andthenpresentthembm section5.
.ourevaluationresultsshowthatpalomaachieves perfectaccuracywhenappliedonthembm andleadstosignificant latency reduction with negligible runtime overhead section .
.
.
microbenchmark design goals the mbm is designed to evaluate two fundamental aspects of paloma accuracy andeffectiveness.
paloma s accuracy pertainstothe relationshipbetween prefetchable and actually prefetched requests.
prefetchable requests arerequests whoseurlvalues areknownbefore thetriggerpoint and thus can be prefetched.
quantitatively we capture accuracy via the dual measures of precision andrecall.
precision indicates howmanyoftherequeststhatpalomatriestoprefetchatagiven trigger point were actually prefetchable.
on the other hand recall indicates howmany requestsare actuallyprefetched bypaloma out of all the prefetchable requests at a given trigger point.
paloma s effectiveness is also captured by two measures the runtime overhead introduced by paloma and the latency reduction achieved by it.
our objective is to minimize the runtime overheadwhilemaximizingthereductioninuser perceivedlatency.
.
microbenchmark design the mbm is built around a key concept prefetchable a request whose whole url is known before a given trigger point.
we refer to the case where the request is prefetchable and the response is usedbytheappasa hit.alternatively arequestmaybeprefetchable but the response is not used because the definition of the url is changedafterthetriggerpoint.wecallthisa non hit.thembm aimstocoverallpossiblecasesof prefetchable andnon prefetchable requests including hitandnon hit.
therearethreefactorsthataffectwhetheranhttprequestis prefetchable the number of dynamic values in a url the number of definition spots for each dynamic values and the locationofeachdefinitionspotrelativetothetriggerpoint.we nowformallydefinethepropertiesof prefetchable andhitconsideringthethreefactors.theformaldefinitionswillletussuccinctly describe test cases later.
figure the test cases covering all configurations involvingdynamicvalues.thehorizontaldividerdenotesthe trigger point while the vertical divider delimits the two dynamic values.
the circles labeled with ds i j are the locations of the definition spots with respect to the trigger point.
h denotes a hit nh denotes a non hit and np denotes a non prefetchable request.
formaldefinition.
letmbe the set of definition spots before thetriggerpointand nthesetofdefinitionspotsafterthetrigger point which is within the target callback recall sections and .
.
let us assume that a url has k dynamic values.
the case where k i.e.
the whole url is static is considered separately.
furthermore let us assume that the dynamic values are the first k valuesintheurl.2theithdynamicvalue i k has di definition spots in the whole program.
a request is prefetchable iff i j defspoti j m every dynamic value has a defspot before trigger point hitiffprefetchable j defspoti j m all dynamic value defspots are before trigger point non hitiffprefetchable j defspoti j n some dynamic value defspots are after trigger point non prefetchable iff j i defspoti j n all defspots for a dynamic value are after trigger point without loss of generality mbm covers all cases where k anddi .wedonotconsidercaseswhere k 2ordi 2because we only need two dynamic values to cover the non prefetchable case where some dynamic values are unknown at the trigger point and twodefinition spots tocover the non hitcase where some dynamic values are redefined after the trigger point.
2thisassumptionisusedonlytosimplifyourformalization.theorderofthevalues in a url has no impact on whether the url is prefetchable and can thus be arbitrary.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
leveraging program analysis to reduce user perceived latency in mobile applicationsicse may june gothenburg sweden there are a total of possible cases involving configurations with k and di .
the simplest case is when the entire url is knownstatically werefertoitascase0.theremaining24cases are diagrammatically encoded in figure the two dynamic url valuesaredepictedwithcirclesanddelimitedwiththeverticalline thelocationofthetriggerpointisdenotedwiththehorizontalline andtheplacementofthecirclesmarksthelocationsofthedynamic values definitionspots ds i j inthefigure withrespecttothe trigger point.
these cases can be grouped as follows single dynamic value cases two dynamic values one definition spot each cases twodynamicvalues onewithasingledefinitionspot the other with two cases and two dynamic values two definition spots each cases .
eachcaseislabeledwithits prefetchable hit property h for hit nh for non hit and np for non prefetchable .ofparticularinterestarethesixcases and16 thatrepresentthe hits that should allow paloma to prefetch the corresponding requests and hence significantly reduce the user perceived latency.
.
results we implemented the mbm as a set of android apps along with the remoteservertotesteachofthe25cases.theserverisbuiltwith node.jsanddeployedontheherokucloudplatform .theapps interact with the server to request information from a dataset in mongodb .theevaluationwasperformedonthe4gnetwork.
thetestingdevicewasgooglenexus5xrunningandroid6.
.overall our evaluation showed that paloma achieves precision andrecallwithoutexception introducesnegligibleoverhead and can reduce the latency to nearly zero under appropriate conditions thehitcases discussed above .
table shows the results of each test case corresponding to figure as well as case in which the entire url value is known statically.eachexecutionvalueistheaverageofmultipleexecutionsof the corresponding mbm apps.
the highlighted test cases are the hitcases that should lead to a significant latency reduction.
the columns sd tp and ffp showtheaveragetimesspentinthecorrespondingpalomainstrumentationmethodsintheoptimized apps senddefinition triggerprefetch andfetchfromproxy respectively recallsection3.
.the orig columnshows the execution time of the method invoked at the fetch spot in the original app such as getinputstream .
thefinalcolumninthe table labeled red oh showsthepercentagereductionin executiontimewhenpalomaisappliedon eachmbmapp.thereductionismassiveineachofthesix hitcases .itwasinterestingtoobservethatapplyingpalomaalso resulted in reduced average execution times in of the non hit andnon prefetchable cases.themoreexpectedscenariooccurredin theremainingeightofthe non hitandnon prefetchable cases applyingpalomaintroducedanexecutionoverhead shownasnegative values in the table .
the largest runtime overhead introduced by palomawas149msincase11 wheretheoriginalresponsetime was 668ms.
this value was due to a couple of outliers in computingtheaverageexecutiontime anditmaybeattributabletofactors inourevaluationenvironmentotherthanpaloma suchasnetwork speed the remaining measurements were significantly lower.
however even this value is actually not prohibitively expensive recallthatpalomaisintendedtobeappliedincasesinwhichatable results of paloma s evaluation using mbm apps covering the cases discussed in section .
.
sd tp and ffp denotetheruntimesofthethreepalomainstrumentation methods.
orig is the time required to run theoriginal app.
red oh represents the reduction overhead in execution time when applying paloma.
casesd ms tp ms ffp ms orig ms red oh 0n a .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
useralreadytypicallyspendsmultiplesecondsdecidingwhatevent to trigger next .
third party app evaluation wealsoevaluatedpalomaonthird partyandroidappstoobserve its behavior in a real world setting.
we used the same execution setup as in the case of the mbm.
we selected apps from the googleplaystore .we madesurethattheselectedappsspana rangeofapplicationcategories beauty books reference education entertainment finance food drink house home maps navigation tools weather news magazines andlifestyle and vary in sizes between 312kb and .8mb.
the only other constraints in selecting the apps were that they were executable relied on the internet and could be processed by soot.
we asked two android users to actively use the subject apps for two minutes each and recorded the resulting usage traces.
we then re ran the same traces on the apps multiple times to accountforvariationscausedbytheruntimeenvironment.then weinstrumentedtheappsusingpalomaandrepeatedthesame steps the same number of times.
each session started with app re installation and exposed all app options to users.
as in the case of the mbm we measured and compared the response times of 3sootisoccasionallyunabletoprocessanandroidappforreasonsthatwewereunable to determine.
this issue was also noted by others previously.
4while the average app session length varies by user and app type e.g.
two minutes was sufficiently long to observe representative behavior and if necessary to extrapolate our data to longer sessions.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yixue zhao marcelo schmitt laser yingjun lyu nenad medvidovic table2 resultsof paloma sevaluationacrossthe32thirdparty apps.
min.
max.
avg.std.
dev.
runtime requests .
.
hit rate .
.
.
latency reduction .
.
.
.
the methods at the fetch spots between the original and optimized apps.
unlikeinthecaseofthembm wedonothavetheground truth data for the third party apps.
specifically the knowable urls at thetriggerpointswouldhavetobedeterminedmanually whichis prohibitivelytime consuminganderrorprone.infact thiswould boildowntomanuallyperforminginter callbackdata flowanalysis recall section .
.
for this reason we measured only two aspects of applying paloma on the third party apps the hit rate i.e.
thepercentage ofrequests thathave been hitoutof alltriggered requests and the resulting latency reduction .
table depicts the averages outliers min and max values as well as the standard deviations obtained across all of the runs of the apps.
overall the results show that paloma achieves a significant latency reduction with a reasonable hit rate.
there are several interestingoutliercases.theminimumhit rateisonly7.
.the reason is that the app in question fetches a large number of ads at runtime whose urls are non deterministic and only a single static url is prefetched outside those.
there are four additional apps whosehit rateis below20 becausethose appsare list view apps such as a wallpaper app recall section .
and they fetch largenumbersofrequestsatthesametime.inpaloma wesetthe threshold for the maximum number of requests to prefetch at once tobe5.thisparametercanbeincreased butthatmayimpactdeviceenergyconsumption cellulardatausage etc.thisisatrade offthat will require further study.
similarlytothembmevaluation palomaachievesareduction in latency of nearly on average for hit cases.
given the average execution time for processing a single request across the unoptimizedappsofslightlyover800ms prefetchingtheaverageof .28requestsatruntimewouldreducethetotalappexecutiontime by nearly 11s or of a two minute session.
note that the lowestlatencyreduction was87.
.thiswas caused byon demand requests that happen before the prefetching request is returned recallthediscussioninsection3.
.inthosecases theresponse time depends on the remaining wait time for the prefetching request s return.
however there were only such wait requests among425totalrequestsinthe32apps.thisstronglysuggeststhat paloma schoicefortheplacementoftriggerpointsiseffective in practice.
related work prefetching of http requests has been applied successfully in the browser domain .
unfortunately approaches targeting page load times cannot be applied to mobile apps.
the bottleneckforpageloadtimesisresourceloading becauseone initialhttprequestwillrequirealargenumberofsubresources e.g.
images whichcanonlybediscoveredafterthemainsourceis fetched and parsed.
thus existing research efforts have focused onissues such as prefetching subresources developer support for speculative execution and restructuring the page loadprocess .inmobileapps thehttprequestsarealwayslightweight one request only fetches a single resource that does not require any further subresource fetching.
therefore our work focusesonprefetching thefuturerequeststhat ausermaytrigger rather than the subresources within a single request.
researchers have recently begun exploring prefetching in the mobile app domain.
one research thread has attempted to answer how much to prefetch under different contexts e.g.
network conditions while assumingthat what toprefetch is handledbytheappsalready.anotherthreadofworkfocusesonfast prelaunchingbytryingtopredictwhatapptheuserwillusenext .bycontrast ourworkaimstoprovideanautomatedsolution to determine what and when to prefetch for a given app in a generalcase.asdiscussedpreviously othercomparablesolutions server based human based history based anddomain based havelimitationswhich we directly target in paloma.
to the best of our knowledge paloma is the first technique to apply program analysis to prefetching http requests in mobile apps in order to reduce user perceived latency.
bouquet has applied program analysis techniques to bundle http requests in order to reduce energy consumption in mobile apps.
bouquet detectssequential http requests sessions shrs in which the generationofthefirstrequestimpliesthatthefollowingrequests willalsobemade andthenbundlestherequeststogethertosave energy.
this can be considered a form of prefetching.
however this work does not address inter callback analysis and the shrs arealwaysinthesame callback.therefore the prefetching only happensafewstatementsahead withinmillisecondsmostofthe time and has no tangible effect on app execution time.
conclusion and future work wehavepresentedpaloma anovelprogramanalysis basedtechnique that reduces the user perceived latency in mobile apps by prefetching certain http requests.
while paloma cannot be applied to all http requests an app makes at runtime it provides significant performance savings in practice.
several of paloma s current facets make it well suited for future work in this area both byusandbyothers.forinstance palomadefinesformallythe conditions under which the requests are prefetchable.
this can leadtoguidelinesthatdeveloperscouldapplytomaketheirapps more amenable to prefetching and lay the foundations for further program analysis based prefetching techniques.
we have also identifiedseveralshortcomingstopalomawhoseremedymust include improv ements to stringanalysis and callback analysistechniques.anotherinterestingdirectionistoimprovetheprecision and reduce the waste associated with prefetching by incorporating certain dynamic information e.g.
user behavior patterns runtime qosconditions .finally paloma smicrobenchmark mbm forms afoundationforstandardizedempiricalevaluationandcomparison of future efforts in this area.
acknowledgment we would like to thank william g.j.
halfond atanas rountev yuhaozhu andtheirresearchgroups.thisworkissupportedby theu.s.nationalsciencefoundationundergrantsno.ccf and ccf u.s. office of naval research under grant no.
n00014 and by huawei technologies co. ltd. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
leveraging program analysis to reduce user perceived latency in mobile applicationsicse may june gothenburg sweden