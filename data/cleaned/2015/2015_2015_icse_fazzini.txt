autocsp automatically retrofitting csp to web applications mattia fazzini prateek saxena alessandro orso georgia institute of technology usa mfazzini orso cc.gatech.edu national university of singapore singapore prateeks comp.nus.edu.sg abstract web applications often handle sensitive user data which makes them attractive targets for attacks such as crosssite scripting xss .
content security policy csp is a contentrestriction mechanism now supported by all major browsers that offers thorough protection against xss.
unfortunately simply enabling csp for a web application would affect the application s behavior and likely disrupt its functionality.
to address this issue we propose a utocsp an automated technique for retrofitting csp to web applications.
a utocsp leverages dynamic taint analysis to identify which content should be allowed to load on the dynamically generated html pages of a web application and automatically modifies the serverside code to generate such pages with the right permissions.
our evaluation performed on a set of real world web applications shows that a utocsp can retrofit csp effectively and efficiently.
i. i ntroduction web applications are extremely popular easily accessible and often handle personal confidential and even sensitive data.
these characteristics together with the widespread presence of vulnerabilities in such applications make them an attractive target for attackers.
cross site scripting xss in particular is one of the most commonly reported security vulnerabilities in web applications and often results in successful attacks whose consequences range from website defacing to theft of sensitive information.
the most common defense mechanisms against xss are based on input filtering which can be an effective approach but is also error prone and often results in an incomplete protection.
content security policy csp conversely is a contentrestriction scheme that is currently supported by all major browsers and offers comprehensive protection against xss attacks.
in fact the popularity of csp is increasing and companies such as facebook and github have started to move csp to production.
in a nutshell web developers can use a csp header to provide for an html page a declarative whitelist policy that defines which content should be allowed to load on that page.
unfortunately simply enabling a default csp for a web application can dramatically affect the application s behavior and is likely to disrupt the application s functionality.
on the other hand manually defining a policy can be difficult and time consuming.
to support an effective use of csp while both reducing developers effort and preserving functionality we propose autocsp an automated technique and tool for retrofitting csp to web applications.
given a web application a utocsp operates in four main phases.
first it marks as trusted all known values in the web application s server side code e.g.
hardcoded values and exercises the web application while performing dynamic taint tracking.
the result of this phase is a set of dynamically generated html pages whose content is annotated with positive taint information.
second it analyzes the annotated html pages to identify which elements of these pages are trusted.
basically the tainted elements are those that come only from trusted sources.
third autocsp uses the results of the previous analysis to infer a policy that would block potentially untrusted elements while allowing trusted elements to be loaded.
fourth autocsp automatically modifies the server side code of the web application so that it generates web pages with the appropriate csp.
to assess the usefulness and practical applicability of autocsp we developed a prototype that implements our technique and used it to perform an empirical evaluation.
in our evaluation we applied a utocsp to seven real world web applications and assessed whether it can protect web applications without disrupting their functionality.
overall the results of our evaluation are encouraging and show that autocsp can effectively retrofit csp to existing web applications so that the applications are actually protected against xss attacks their functionality is either not affected or minimally affected and their performance incurs a negligible overhead.
our results also show that automating this approach is cost effective as the number of changes to perform to the server side code to retrofit csp is large enough to make a manual approach expensive and error prone.
this work makes the following contributions the definition of a utocsp a general approach to retrofit csp to web applications.
a prototype implementation of a utocsp that can operate on php based web applications and is available at http .
an empirical evaluation of a utocsp that shows the effectiveness and the practicality of our approach.
ii.
b ackground and motivating example this section provides an overview of the security related concepts needed to understand our approach and an example that we use to motivate our work.
a. cross site scripting xss web applications are complex multi tier applications that include a client and a server sides.
through a browser onthe client side users can issue http requests to access functionality running on the server side or backend.
the server side code processes the inputs contained in the http requests and generates web pages with the content requested by the user.
these dynamically generated web pages usually consist of basic html entities together with javascript css and other resources.
when the browser receives these pages it renders their content and executes the code they contain.
xss attacks are injection attacks that take advantage of the dynamically generated content in a web page to insert malicious scripts into otherwise benign and trusted web pages.
in these cases malicious code coexists and executes together with benign code as the web browser is unable to discern between the two.
xss vulnerabilities can be divided into different types based on the methodology used to exploit them.
xss vulnerabilities of persistent type are those whose attacks are performed by injecting and permanently storing malicious script content within a resource of the targeted web application.
subsequently when a user requests that resource the malicious code executes as if it were generated by the web application itself i.e.
as if it were trusted .
this type of vulnerability is widespread because the web application logic allows for the possibility of using inline scripts and inline style directives within the dynamically generated html e.g.
using the script ... script construct .
xss vulnerabilities can also be of reflected type when the corresponding attacks are built by having the server side code processing the content of an http request and attaching it verbatim to the requested web page.
this type of vulnerability is also widespread as application logic usually permits inline scripts and inline style constructs.
the dom based type identifies vulnerabilities in which the attacks are created by injecting malicious payload directly into the dom of the victim s web browser.
because of the way this type of exploits are constructed the serverside of the application never sees the malicious script content.
this class of vulnerabilities is exploitable due to a combination of javascript and html features.
one of the most important among these features is the ability of javascript to execute code from strings i.e.
eval .
another feature is that javascript code while executing can create new elements in the dom such as inline event scripts and inline attribute styles.
finally resource based xss vulnerabilities can be exploited by placing malicious scripts within resources being fetched by the web browser while rendering a requested html page.
examples of these attacks are malicious script content injected into svg files and chameleon attacks .
this type of vulnerability is common in web applications because these applications generally do not restrict the sources from which dynamic web pages can fetch their content.
b. content security policy content security policy csp is a declarative mechanism that can be used to protect web applications against several classes of xss attacks.
csp can be seen as a content restriction scheme that web developers can use to specify what content can be included and how thiscontent operates within dynamically generated pages of a web application.
csp is enabled by adding on the server side acontent security policy header and corresponding content to the http response that contains the protected resource.
when a web browser receives the policy it enforces it on the content of the web page being rendered.
a csp is a set of directives in the form directive name source list where directive name is the name of the directive and source list is the set of domains to which the specific directive applies.
these directives define many aspects of a dynamic web page s content which scripts are enabled from where plugins can be loaded which styles are allowed from where media content can be retrieved which resources can be framed to which hosts the page can connect through scripts and from where it is possible to load fonts.
there are two special keywords that can be used in a policy unsafe inline and unsafe eval .
the first keyword enables inline scripts and inline style constructs in the protected web page.
the second keyword enables the generation of code from string elements in the client side code.
these keywords can be very useful but if allowed may void the protection offered by csp.
several instances of xss attacks can be blocked if csp is properly added to the html pages of a web application.
persistent xss attacks in particular can be blocked if unsafe inline is not in the policy and the policy only whitelists scripts and style content that were created by the developer of the web application.
reflected xss attacks can be blocked if unsafe inline is not excluded from the policy.
the probability of dom based xss attacks can be highly reduced if both unsafe eval and unsafe inline are excluded from the policy.
finally resource based xss attacks can be prevented by csp in two different ways.
first the attack can be blocked by preventing the resource that contains the malicious payload from being fetched i.e.
the domain of the resource must not be whitelisted in the policy .
alternatively if the resource needs to be fetched and is located on the host where the web application is running the developer can specify a csp that states that no script can be executed in the context of the resource.
given the whitelist nature of csp in order to take full advantage of the protection mechanism it offers web application developers need to identify a policy for each of the web pages dynamically generated by the web application and rewrite parts of the web application s server side code to make sure they generate pages with the right policy.
such a manual process is not only time consuming but also error prone.
our approach aims to remove most of this burden from the developers shoulders by automating this process.
c. motivating example to motivate our work we provide an example from a real world web application called s choolmate a school management system that has been downloaded over times.
figure shows the server side code for the functionality that allows students to visualize the assignments related to one1 ?php 2print html ... 4print script 5function grades document.student.page2.value document.student.submit script ... 11print a class menu href javascript grades grades a ... 15while assignment mysql fetch row query ... print tr td style text align left assignment td tr ... ... 25print html ?
fig.
.
s choolmate server side code snippet.
html head ... head body ... script function grades document .student.page2.value document .student.submit script ... aclass menu href javascript grades grades a ... tr td style text align left script alert xss script td tr ... body html fig.
.
s choolmate original web page snippet.
html head ... script src uri.js script link rel stylesheet type css href sty.css ... head body ... script src external.js script ... aid uri class menu href grades a ... tr td id sty script alert xss script td tr ... body html fig.
.
s choolmate csp enabled web page snippet.
of their classes slightly modified to make it self contained and more readable .
figure shows the html web page generated by this server side code.
after generating the html page header the server side code adds an inline script to the html page code lines html lines .
this script contains the functionality necessary to navigate the menu of the web application and is encoded as a constant string in the original program.
lines 13print a link for accessing the functionality offered by the previous script html lines .
also in this case the element is encoded as a constant string in the program.
lines 23consist of a loop that creates a table in the html page containing the assignments for a given class html lines .
in this case the code prints a row and a column of a table by using a constant string for its structure and a variable for its content line .
the value of this variable is read from a database and represents comments of the class instructor.
this makes the web application vulnerable to persistent xss attacks see section ii a .
assume for instance that the value retrieved from the database is script alert xss script .
when this value is added to the generated html it is interpreted as an inline script.
at line an inline style is applied to the column of the table but this value is hardcoded in the program so it cannot be modified by an attacker.
finally the server side code closes the html page at line 25and terminates its execution.
this example lets us show why blindly enabling csp on the generated web page would either affect its normal functionality or add inadequate protection against xss attacks.
simply using csp to block all executions of script and style content i.e.
using content security policy default src none as the policy header would block the xss attach but would also prevent normal users from accessing the menu functionality on the page.
this is because both the inline script and javascript uri respectively at lines 11and 15of figure would be blocked.
conversely enabling the inline script javascript uri andinline style without modifying the web application with policy header content security policy default src none script src unsafe inline style src unsafe inline would preserve the page s functionality but would allow the xss attack to succeed.
figure shows the csp enabled web page that would preserve the functionality of the web application while blocking the xss attack.
the correct csp would be content security policy default src none script src domain style src domain where identifier domain represents the host on which the external javascript and css files linked in the html reside.
as figures and show there are significant changes between the two html pages.
the inline script at lines 11in figure is transformed into the script at lines 12in figure .
the content of the script is moved to an external file called external.js which is enabled by thescript src csp directive.
the javascript uri at lines 15of figure is also moved to an external file uri.js line 4in figure and linked using the newly introduced id uri expression at line 14in the new web page.
a similar transformation occurs for the inline style attribute of line 18in figure .
the style content is moved to file sty.css enabled using the style src csp directive and activated through the newly introduced id sty expression lines and 19of figure respectively .
the inline script that contains the malicious payload appears unchanged in figure at lines 22and would be blocked by the browser as the csp associated with the web page does not allow inline scripts.
as this example shows defining a suitable csp can be a difficult time consuming and error prone task.
in the next sections we show how a utocsp can automate this process.
iii.
t heautocsp a pproach in this section we present our approach for retrofitting csp to web applications.
we first provide an overview of autocsp and then discuss its different phases in detail.as we discussed in section ii b csp offers a whitelist based content restriction mechanism that is csp blocks by default the loading execution of any web page node that is not specified in the policy but allows for specifying which nodes are trusted and can thus be loaded executed.
the basic idea behind our approach is to automatically find trusted nodes in a dynamically generated web page by analyzing the execution of the server side code that generates such page nodes that are generated using only trusted sources are marked as trusted whereas all other nodes are conservatively considered untrusted.
figure provides a high level overview of our approach and shows its main phases.
given a web application and a set of test inputs in its dynamic tainting phase a utocsp marks as trusted all hardcoded values in the web application server side code plus optionally additional whitelisted sources specified by the developer and performs dynamic taint analysis as the server side code executes and generates web pages.
then in theweb page analysis phase a utocsp analyzes a dynamically generated html page and the associated taint information to determine which parts of the page can be considered as trusted.
in the csp analysis phase of the approach a utocsp processes an html page and its associated taint information to infer a policy that would block potentially untrusted parts while allowing trusted parts to be loaded in the browser.
this phase also computes how html pages should be transformed in order to conform to the inferred policy.
finally in its source code transformation phase a utocsp modifies the source code of the web application so that it generates suitably transformed html pages according to what it computed in the previous phase in which the inferred csps are enabled.
in the remainder of this section we describe a utocsp with the help of algorithm which represents the approach in pseudo code.
the inputs to a utocsp are a web application waand a set of test inputs ts.
for every test input tiints autocsp performs its dynamic tainting web page analysis and csp analysis phases lines .
after processing every test input the approach moves to its source code transformation phase lines which produces the final result the transformed web application wacsp.
we now describe the four phases of a utocsp in detail.
a. dynamic tainting this phase aims to determine given a test input to the web application which parts of the generated web page are trusted and which parts are untrusted using a whitelist approach.
we consider a dom node of the generated html as trusted if it is defined by the developer or it is in full control of the developer.
we consider all remaining content untrusted.
specifically we use an approach called positive dynamic tainting which we used successfully in previous work to counter sql injection vulnerabilities .
positive dynamic tainting marks the trusted data within an application in this case html fragments and propagates taint marks as the application executes.
positive tainting in contrast to morealgorithm autocsp input wa web application ts set of test inputs for wa output wacsp web application using csp 1begin setes foreach input ti2tsdo dynamic tainting buffer hb tb sb map tm wa.set ti while wa.finish do instr i wa.next i.execute taint i tm ifi print then hb.add i.result tb.add tm sb.add i.line web page analysis dom doma parse hb tb sb csp analysis policy csp strict foreach node n2domado ifn.positive then ifn scr obj sty img med frm then node nnew tocsp doma n ifnnew6 nthen edit en en line n doma n n nnew es.add en csp.allow nnew edit ecsp ecsp line csp doma csp es.add ecsp source code transformation webapp wpcsp wa foreach edit e2esdo ife ecspthen transform csp wpcsp e else if e enthen transform n wpcsp e return wpcsp traditional negative tainting approaches is a more conservative approach and fits naturally the whitelist approach behind csp.
there are three main aspects that characterize a dynamic taint analysis taint introduction propagation policy and taint checking.
taint introduction identifies and labels specific data within the program called taint sources using suitable taint marks.
a taint propagation policy governs how taint marks propagate while the program is executing.
taint checking is the step in which particular actions are performed when taint marks reach special locations of the program called taint sinks .
we present now the instance of positive dynamic taint analysis that we implemented in a utocsp.
this part of a utocsp is covered by lines 14in algorithm .
taint sources we introduce a taint mark for a given piece of data hence marking it as positively tainted whenever such data is hardcoded in the program.
the rationale is that server code normally uses hardcoded data and in particular strings to generate the different parts of an html page and hardcoded data are defined by the developer and thus trusted.
in addition our approach also allows developers to specify additional data that should be marked as trusted i.e.
whitelisted such as content originating from a specific column in a database or return values of specific functions.
autocsp keeps track of this taint information using a taint map tmvariable in the algorithm .
taint propagation a taint propagation policy determines how the different instructions affect the taint marks associated with their operands.
to compute accurate results itweb page analysisdynamic taintingcsphtmlcsp analysissource codetransformationwebapplicationhtml scriptscriptstylehtmlti2i1c1stylefilescriptfile webapp webapp csptransformedweb application testinputscspsource codescriptfilestylefilefig.
.
high level overview of a utocsp.
is important to precisely model the semantics of such instructions.
for each type of instruction our taint propagation policy determines three aspects the data defined by the instruction i.e.
its output data the data used by the instruction i.e.
its input data and a mapping function i.e.
how the input data affects the output data .
after executing an instruction i execute function at line a utocsp updates the taint marks associated with i s output data based on the taint data associated with i s input data and i s mapping function taint function at line .
taint sinks taint sinks are relevant instructions for the taint analysis being performed.
for this reason when executed they trigger checking actions on the taint marks associated with their input data.
in a utocsp taint sinks consist of print instructions as the data printed by the server side code is what constitutes the web page that is then sent back to the client.
by checking these sinks a utocsp can check the taint marks associated to the different parts of the html pages dynamically generated by the application.
in the server side code there are normally multiple places in which different parts of an html page are generated and therefore multiple taint sinks.
for each sink line a utocsp performs the following actions.
first it stores the characters in the generated html page line in an html buffer hb .
a utocsp also populates two other buffers the taint buffer tb and the source buffer sb .
for each element in the html buffer autocsp creates a corresponding entry in the taint buffer line that specifies whether that element is trusted if it has a taint mark or untrusted otherwise .
similarly the approach stores into the source buffer the source code location of the statements that generated the content in the corresponding position of the html buffer line .
these three buffers are used by the subsequent phases of the approach.
b. web page analysis the second phase of our approach represented by line in algorithm analyzes the html taint and source buffers.
in this phase a utocsp parses parse function at line the html generated by the previous phase to build and then operate on its dom representation as a browser would do.
in fact using the same underlining model dom a utocsp can better mimic the csp enforcement mechanism that web browsers would apply.
a utocsp actually produces an enhanced version of the dom tree that we call the annotated dom tree dom a .
a utocsp s parsing algorithm which is based on the whatwg specification operates primarilyon the html buffer which contains the actual html content.
the other two buffers are used to annotate the nodes of the resulting dom tree.
basically each of the tokens generated while parsing the html content contains two annotations the first one indicates whether the token is trusted whereas the second one indicates the locations in the server side code of the statements that generated the token.
after identifying all tokens a utocsp produces a corresponding annotated dom tree.
because each dom node can correspond to multiple html tokens to be conservative a utocsp marks a node as trusted only if all of its corresponding tokens are.
c. csp analysis this phase takes as input the annotated dom tree infers the csp for it and identifies how trusted dom nodes should be transformed to comply with the inferred policy.
the highlevel algorithm for this phase corresponds to lines of algorithm .
for each annotated dom tree this phase produces a set of html transformations and a csp for the document.
the html transformations and the csp are then converted to source code edits lines 22and25 and are passed to the final phase of the approach as the edit set es .
this phase starts by associating the strictest csp possible to the html of the annotated dom tree line .
this choice ensures the most effective protection offered by csp against xss.
the initial csp corresponds tocontent security policy default src none .
this policy does not allow the protected html resource to use inline scripts eval constructs and inline styles.
in addition the policy does not allow the guarded resource to fetch any content from the web.
once the initialization step terminates a utocsp starts processing nodes in the annotated dom tree lines .
the key idea of this phase is to incrementally add to the csp trusted html elements.
in addition a utocsp transforms each such element if necessary so that the element s behavior is not disrupted by csp s enforcement mechanism.
to do this autocsp identifies which elements in the annotated dom tree relate to csp and if necessary suitably transforms them.
our approach identifies whether nodes of the annotated dom tree relate to csp according to what is stated in the csp specification .
specifically there are six classes of elements that a utocsp identifies as related to csp line nodes that enable scripting load plugins define the style of the web page fetch images connect to media content and frame other resources.if a dom node that relates to csp is trusted positive function at line 18returns true it is enabled in the csp and if necessary a utocsp identifies how to transform it to make it conform to the inferred csp.
the transformation process tocsp function at line is dependent on the type of node considered.
if a transformation is necessary a new node edit en is added to the edit set line .
the node edit contains three pieces of information the source code location of the statement that generated the node result of function line nat line22 the original node n and the modified node nnew .
after processing every node a utocsp also creates a csp edit ecsp and adds it to the edit set line .
a csp edit contains two pieces of information the source code location where the csp header should be added result of function line cspat line and the inferred csp for the web page considered csp .
in the reminder of this section we provide details on the transformations performed on specific kinds of dom nodes.
script nodes there are different types of script nodes that can appear in the dom and that must be handled in different ways.
the first type of node is represented by inline script elements that is script nodes in the form script ... script .a utocsp transforms this type of node to a script node in the form script src ... script .
the new node fetches an external file stored on the web application server whose content is the original script.
in this case the csp of the protected document gets extended by allowing the web page to fetch the script resource from the application server using the script src host directive.
the second type of node consists of event handlers attributes such as html elements having attributes in the form button onclick ... button .
in this case a utocsp replaces the original element with an element that does not declare the event handler and creates a script that adds the same event handler to that element.
the new script code is placed in an external script file that is linked to the corresponding html document and such that the script is activated when the dom is loaded and the domain in which the file is stored is allowed in the csp.
the third type of node consists of elements having attributes that invoke a script using a javascript uri such as a href javascript ... a .
the transformation applied to this node is similar to the one applied for event handlers.
first the new script is placed in an external script file linked to the html document and activated when the dom is loaded.
then the domain where the file is stored is allowed in the csp.
the final type of script node is a node that links to an external script file in the form script src ... script .
in this case no change is applied.
however the domain of the script file is added to the csp.
style nodes also for style nodes a utocsp treats different types of nodes differently.
the first type of node are inline style elements that is style nodes in the form style ... style .autocsp transforms this type of node to a node in the form link rel stylesheet type text css href ... .
the new node fetchesan external style file that is stored on the web server and has the same content as the original style node.
in this case the csp gets extended by allowing the document to fetch the style resource from the server using the style src host directive.
the second type of nodes are style attributes such as html elements with attributes in the form p style ... p .
the approach replaces this type of node with a node without the style attribute and moves the style content to an external file.
it then links the file to the corresponding html document and allows the domain where the file is stored in the csp.
the last type of style node consists of style elements that link to an external style file that is elements in the form link rel stylesheet type text css href ... .
in this case no transformation is applied but the domain of the linked style file is added to the csp.
other nodes the remaining nodes that relate to csp are discussed together in this section as a utocsp applies a similar analysis to all such nodes.
this part of the approach analyzes classes of elements that load plugins fetch images connect to media content and frame other resources.
a utocsp identifies the resource to be fetched by the nodes and adds the domain where the resource is located to the csp directive corresponding to the node being analyzed.
in addition if the whitelisted resource is coming from the same host of the web application the approach attaches a content security policy default src none header to the resource being fetched.
this is done to avoid xss attacks that could piggyback on the resource being loaded .
the policy used for this resources is as strict as possible to avoid weakening the protection offered by a utocsp.
section v shows that this choice did not affect the functionality of the web applications in our evaluation.
d. source code transformation autocsp s source code transformation phase modifies the server side code of the web application so that it generates html pages with the inferred csps enabled and conforming to such csps.
this phase takes as input the content of the edit set that was produced in the previous phase across multiple executions of the web application and returns a transformed csp enabled web application.
in the rest of this section we illustrate the two main parts of this phase which correspond to lines 33in algorithm .
enabling csp this part of a utocsp processes csp edits created across multiple executions of the web application function transform cspat line .
as mentioned in section iii c a csp edit contains the inferred csp and the source code location where the inferred csp header needs to be added.
this latter is normally the code that generates the initial html content as the csp header needs to be sent to the web browser before any other html content.
because our approach collects information across different executions it is possible to have different csps associated to a single statement in the source code.
in this case our technique takes the superset of the policies and uses thenewly generated policy for all the web pages whose initial html content is generated at the current location.
it is worth noting that combining the policies corresponding to different executions may result in a more permissive policy for a specific execution.
however we believe and our experience confirms that whitelisted content in one execution is unlikely to harm other related executions of the same web application.
html generation this part of a utocsp processes the dom level transformations identified by the third phase of the approach and changes the server side code of the web application to reflect these transformations in the generated web pages function transform nat line .
it does so by analyzing the node edits in the edit set.
for each edit autocsp first extracts the source code location stmt o .
it then modifies the code as follows.
first a utocsp introduces a new variable out and adds to the code a statement that assigns to that variable the html content generated by stmt o. second a utocsp adds a statement stmt rthat replaces in outthe original dom content with the new one.
stmt rtakes into account the fact that outmight not contain the value corresponding to the original node because reached by an execution different from the one for which we generated the node edit.
finally a utocsp adds a statement that prints the modified html content contained in out.
if the new content links to new external scripts or style files introduced by a utocsp this part of the analysis also creates the files with the proper content.
iv.
i mplementation our implementation of a utocsp can analyze php based web applications and supports csp .
.
we implemented our general approach specifically for php because it is a language used for over 244million applications and installed on over .1million servers .
a. dynamic tainting the dynamic tainting module consists of two main components.
the first one is an extension to the z end engine version .
a php interpreter written in c code.
the engine translates php scripts into opcodes and calls to c implementations of php libraries.
in the version that we used there are1064 opcodes and library functions.
we analyzed the semantics of all of the engine s opcode handlers but to minimize our implementation effort only analyzed the library functions used by our experimental benchmarks.
specifically we analyzed how values flow through them and implemented hooks to read relevant values during the taint process.
extracted input and output values together with the opcode and function details are passed to the dynamic tainting component which handles taint introduction taint propagation and taint checking.
the dynamic tainting component is written in java and introduces taint marks for hardcoded values in the serverside code and for values originating from trusted locations specified by the developer in an xml configuration file.
for each opcode and library function analyzed the component implements the function that maps taint marks of valuesaffecting the opcode computations to the values produced as a result of the computation.
when the component processes print and echo opcodes taint sinks it fills the three buffers produced by a utocsp s dynamic tainting phase as described in section iii a. b. web page analysis our tool implements the parsing phase of a utocsp by extending jsoup .
an open source java parser able to handle real world html.
it provides an easy to use flexible and efficient api for extracting and manipulating elements of the dom.
this module extends jsoup so that the output of the parsing process is the annotated dom tree.
our tool modifies the classes that implement the tokenization and tree construction stages to operate as discussed in section iii b. c. csp analysis this module implements the third phase of a utocsp.
it analyzes the annotated dom tree computes the csp that applies to it finds the transformations to generate html that complies to the inferred csp computes the csp and node edits as mentioned in section iii c and stores them in an xml file.
the code that handles the transformations computed by this module leverages the api added to jsoup .
it also uses freemarker .3template technology to create scripts and style code that host the original content of transformed inline script and style nodes.
d. source code transformation this module parses the xml file produced by the csp analysis module and creates a version of the web application that uses csp.
to do so the module adds and modifies statements in the source code of the application see section iii d .
the module uses e clipse spdt library to create an abstract syntax tree for the code and applies changes to the application by modifying the ast.
this module also creates the external script and style files introduced by a utocsp.
v. e mpirical eva l uat i o n to determine the practicality and effectiveness of our approach we performed an empirical evaluation of a utocsp on a set of real world web applications and targeted the following research questions rq1 can a utocsp retrofit csp to web applications and offer an effective protection against xss attacks without disrupting the applications functionality?
rq2 what is the effect of a utocsp on the performance of the retrofitted web applications?
rq3 how dependent is a utocsp s performance on the input used for its taint analysis?
rq4 is automation actually needed to retrofit web applications?
the rest of this section presents our experimental benchmarks and setup and discusses our results.table i experimental benchmarks used in our ev aluation .
benchmark type version kloc gallery photo sharing .
.
linpha photo sharing .
.
mybb forum .
.
openemr medical management .
phplist newsletter management .
.
schoolmate school management .
.
serendipity blogging .
.
a. experimental benchmarks and setup for our empirical evaluation we used real world php web applications that were also used in previous work on xss .
among the applications used in these papers we selected those that were either used in more than one paper or had a larger code base.
this resulted in nine web applications among which we had to discard two p horum and phpbb because they dynamically create the serverside code that is in these applications html pages are dynamically created by code that is also dynamically created which is something that a utocsp does not currently handle.
table i provides a summary description of the seven applications we considered.
columns benchmark version and type provide name version and type of the web application.
the last column kloc reports the number of thousand lines of php code in the benchmark.
we deployed our benchmarks on a server machine with 3gb of memory two intel pentium d cpu .00ghz processors and running ubuntu .
.
we used z end .4as the php application server.
to answer our research questions we ran our benchmarks against a set of representative inputs.
because the benchmarks did not include a test suite and our dynamic taint analysis needs inputs we deployed our benchmarks and asked five graduate level students unfamiliar with a utocsp to explore the functionality of the web applications.
the students s sessions were recorded by a google chrome extension we created.
these recordings are available together with another chrome extension for replaying them on our tool s website provided in the introduction.
b. results a rq1 to answer the part of rq1 about a utocsp s effectiveness we applied our approach to the benchmarks considered and ran a set of attacks against the retrofitted applications.
specifically we created an initial set of seven attack vectors i.e.
inputs that exploited seven known vulnerabilities in our benchmarks one input per vulnerability .
in addition to evaluate a utocsp s effectiveness in more general terms we also considered a set of additional vulnerabilities and inputs as follows we first randomly selected a set of three times the number of applications considered for lack of a better number xss attack vectors from various sources we then instantiated and injected vulnerabilities to enable the attack vectors in our seven benchmarks finally we added the 21attack vectors to our set of inputs.table ii browser sc o n s o l ee r r o r st h a to c c u rw h i l er u n n i n gt h e benchmarks under different csp schemes .
benchmark ti none self autocsp gallery linpha mybb openemr phplist schoolmate serendipity at this point we assessed the effectiveness of a utocsp by using it to protect the vulnerable web applications and running the protected applications against the input vectors on four different browsers chrome v firefox v opera v and safari v .
all exploits were successfully blocked.
for the second part of rq1 which is about the effects of a utocsp on the applications functionality.
we ran the retrofitted web applications against the inputs we described in section v a and checked whether that resulted in errors in the browser.
unfortunately we could not compare autocsp to any existing tool as the most related existing approach dedacota only works on applications written in asp.net.
however in order to have a baseline we decided to implement two simple approaches n one which simply enables on all generated html pages the strictest possible csp policy content security policy default src none and s elf which employes a policy that allows guarded resources to fetch content only from their same domain of origin content security policy default src self .
these simple baselines can give us an idea of what would happen if developers would simply apply csp to a web application without analyzing it.
table ii reports for each benchmark the number of test inputs used ti and the number of unique based on the client side code location client side errors occurring when using approaches none self and a utocsp and not present when executing the original web applications without csp .
as expected all benchmarks generate the largest number of errors with approach n one which prevents the web browser from executing any script applying any style and loading any external resource in a web page.
the number of errors is significant also when using s elf.
this is because all the benchmarks extensively use inline scripts and style directives in their html pages and s elfprevents their execution.
autocsp significantly reduces the number of errors compared to the other two approaches but it does not completely eliminate them.
more precisely it transforms three of the web applications g allery linpha and s chool mate without introducing any error and causes a limited number of errors in the other four applications.
we investigated the reasons for these errors and found that they are of three types e1 executions of eval e.g.
var x eval ... e2 client side creation of inline script nodes in the dom e.g.
document.write input onclick ... and e3 client side creation oftable iii performance and modification data for the retrofitted applications in our empirical study .
benchmark to ms tt ms ecsp en f gallery linpha mybb openemr phplist schoolmate serendipity style nodes in the dom e.g.
document.write td style ... .
in the applications we considered there are four instances of e1 five of e2 and 11of e3.
these errors could be easily removed by adding policies unsafe eval and unsafe inline to csp.
so however would reduce the protection offered by our approach against xss.
to avoid that a more sophisticated analysis of the semantics of the javascript code in the html pages would be needed which is something that a utocsp does not do at the moment.
in future work we plan to extend a utocsp with an approach similar to the one proposed by jensen and colleagues to remove errors of type e1 and automated script analysis to remove errors of types e2 and e3.
currently a utocsp simply reports such issues to the web application developers.
based on these results we can answer rq1 as follows autocsp is able for the cases considered to retrofit csp to the web applications and effectively protect them against xss attacks.
it may generate false positives that require manual intervention in some cases but the number of such false positives is significantly lower than if csp were applied using a straw man approach.
b rq2 to answer rq2 we compared the execution time of the retrofitted web applications with that of the original applications when run against our set of test inputs.
for each input we measured the time from when the web browser issued an http request to the time when the requested page was fully loaded in the browser.
the first part of table iii reports for each application the average execution time in milliseconds over one run of all inputs for the given application.
column toshows the average time for the original applications while ttshows the average time for retrofitted applications.
as the results show the overhead is mostly negligible in practice.
moreover it appears that the larger the subject the lower the relative overhead which is in fact not measurable for o penemr our largest application.
we can therefore say for rq2 that the transformations introduced by a utocsp do not seem to significantly affect the performance of the retrofitted web applications.
c rq3 to answer rq3 we compared the number of source code edits performed by a utocsp as more inputs are considered for its taint analysis.
for each application considered we computed the total number of edits when considering and of the inputs of a server side php file where means running that file against all of its inputs in the input set.
because we randomly fig.
.
source code edits made by a utocsp as more inputs are considered.
selected the subset of inputs we repeated the experiment times and reported the average of these results in figure .
in the figure a utocsp shows a similar trend for all of the web applications considered.
in most cases the number of edits converges after only of the inputs have been considered and in two cases after are considered for o penemr and mybb which are the two largest applications in our pool .
overall these results provide initial evidence that the approach is not strongly dependent on the specific inputs used.
d rq4 the second part of table iii lets us investigate rq4.
it shows the number of modifications performed by autocsp on the benchmark applications the number of csps added to the web applications ecsp the distinct number of dom node edits en and the overall number of serverside source code files modified by a utocsp f .
for five out of the seven applications considered our approach finds more than one csp to apply in the server side code and it finds 31in the worst case.
the number of dom node edits per web application is significant and could be in the order of a few hundreds even for a small web application e.g.
schoolmate .
the number of source code files affected by the changes is significant as well.
these results indicate that automation is necessary to retrofit csp to existing web applications.
vi.
c urrent limitations our current prototype tool does not fully support in its source code transformation phase web applications that can dynamically generate server side code.
more precisely the tool cannot apply changes to source code statements that are dynamically generated by server side code.
in this case however the prototype could still be used as a reporting tool the generated report would help developers understand how to retrofit the computed csp to the analyzed web application.
in addition a utocsp currently performs only a superficial analysis of the javascript code in the generated html pages.
as a consequence it may generate a csp that is too strict and disrupts the application s functionality.
despite these limitations our empirical evaluation shows initial evidence that our approach can be practical effective and produce a low rate of false positives.vii.
r elated work dedacota is the work most closely related to ours.
it differs however in the nature of the approach as it statically rewrites a web application to separate data and code in the generated web pages and applies csp on the transformed version of the application.
specifically it performs static dataflow analysis to approximate the html output of a web page and then rewrites the html such that inline javascript is stored in a separate javascript file.
dedacota does not deal with the problem of rewriting css code and inline event handlers although it could probably be extended to do so .
in our evaluation we found that inline event handlers are a conspicuous part of the content that needs to be rewritten.
we also found that rewriting inline event handlers strictly depends on the dom node in which they appear and that this information can be better determined with a dynamic approach.
p ixy is a technique for detecting xss vulnerabilities based on static data flow analysis of php scripts.
p ixyand a utocsp have similar goals but operate differently p ixyaims to find vulnerabilities in web applications whereas a utocsp aims to protect them using csp.
server side protection mechanisms e.g.
range from techniques that provide defenses based on input sanitizer to methods that can differentiate between legal and illegal scripts.
di lucca and colleagues propose a mixed static and dynamic approach to find xss vulnerabilities.
static analysis identifies web pages that might be vulnerable to xss attacks whereas dynamic analysis verifies whether such web pages are actually vulnerable.
s aner statically tracks unsafe information from sources to sinks and applies input sanitization.
subsequently the technique tests for proper sanitization along the analyzed paths.
this technique performs the opposite type of information flow tracking than autocsp i.e.
untrusted vs trusted .
s cript gard performs context sensitive sanitization to match the browser s parsing behavior.
in a similar fashion our approach tries to emulate browser parsing behavior when building the dom tree for an html web page.
xss guard learns legal scripts generated by html requests and removes illegal content from the output of dynamically generated html pages.
similarly our approach tries to identify legal scripts but whitelists them instead of removing the untrusted one from generated web pages.
in general many of these techniques rely on some form of negative tainting and sanitization which is error prone and can lead to false negatives.
researchers also explored xss protection mechanisms based on data flow analysis e.g.
.
among those dynamic tainting techniques e.g.
are most closely relate to our work.
nguyen tuong and colleagues presented a technique that replaces the standard php interpreter with a modified one to track taint marks of string values.
based on the computed taint information they check whether elements of the dynamically generated html pages were created from untrusted sources if found these elements are suitably removed or sanitized.
the kind ofdynamic tainting implemented by this technique differs from ours.
we propagate taint marks associated to every type of data in the program independently from its type.
in addition we create an extension of the php engine and do not modify the interpreter which enables portability across multiple versions of php.
csse is a method to detect and prevent injection attacks .
their technique assigns metadata to user inputs propagates and checks metadata based on the concepts of metadata string operations and context sensitive string evaluation.
the technique also modifies the core of the php engine which hinders portability.
in addition the technique might suffer from imprecision because it deals only with metadata of string values.
finally the authors mention that their technique can protect against xss attacks and provide one example for one class of such attacks.
a utocsp conversely by relying on csp can protect against different classes of xss attacks.
client side protection mechanisms e.g.
aim to enhance the client side code.
beep in particular whitelists scripts on the server side and specifies a security policy for every web page.
the security policy enables or disables execution of scripts and is similar to csp .
however csp handles more classes of html elements and provides better guarantees of protection on the client side as it is a w3c standard implemented by all major web browsers.
viii.
c onclusion we presented a utocsp a novel approach for retrofitting csp to existing web applications.
given a web application autocsp first performs positive dynamic tainting on the serve side code of the application.
it then uses the computed taint information to find trusted elements of dynamically generated html pages and infer a policy that would block potentially untrusted elements while allowing the trusted ones.
finally it automatically modifies the server side code of the web application so that it generates web pages with the appropriate csp.
to assess precision practicality and effectiveness of a utocsp we implemented it in a tool that targets php web applications and performed an empirical evaluation on a set of real world web applications.
the results of our evaluation show that for the cases considered a utocsp was effective in retrofitting csp to the existing applications while either preserving their functionality or minimally affecting it.
in future work we will address the limitations of our current implementation.
we will also extend a utocsp so that it automatically updates the computed csps for a web application as developers modify the application during evolution.