a demonstration of simultaneous execution and editing in a development environment steven p. reiss and qi xin department of computer science brown university providence ri usa spr qx5 cs.brown.edu abstract we introduce a tool within the code bubbles development environment that allows for continuous execution as the programmer edits.
the tool seede shows both the intermediate and final results of execution in terms of variables control flow output and graphics.
these results are updated as the user edits.
the user can ex plore the execution to find or fix bugs or use the intermediate values to help write appropriate code.
a demonstration video is available at index terms continuous execution integrated development environments debugging live coding.
i. m otiv ation programmers often think in concrete terms while writing and debugging more abstract code.
they start with an example and write code that handles th at example generalizing the code as they go.
they debug with a particular example in mind.
the ability to see intermediate results and understand and check code as it is written is central to spreadsheet programming and is used in interactive environments such as matlab and in dynamic languages such as smalltalk or python.
for example sharp notes that for smalltalk a useful technique for writing new code is to write most of thecode in the debugger .
bret victor claims this type of livecoding is the preferred way to code .
programmers can do this to a very limited extent with today s traditional java programming environments using live update the ability to reload a class and continue execution.
our prototype tool seede pr ovides the ability to see immediately the effect of code changes on execution in a java environment for real programs and a wide range of different edits essentially providing cont inuous execution.
it does this within the code bubbles progr amming environment letting the programmer start a new session at any breakpoint andshowing the updated execution as the programmer edits.
it also lets the programmer select a test case and view the results of executing it.
a system that does continuous execution while editing needs to meet certain requirements.
these include performance .
the evaluation needs to be fast enough to be run potentially on each keystroke and to provide feedback within seconds.
if feedback is slower it can either confuse the programmer by showing older val ues or cause unnecessary delays.
non obtrusive .
execution feedback should not require substantial work on the part of the programmer.
currently to use java live update programmers need to save error free code and then either step or continue from wherever the save placed execution which might be the start of the method or the start of some previous method up to the point where they wereediting.
as a first approximation we wanted to show the new values at about the same point without requiring any extra work by the programmer.
idempotent .
continuous execution should not actually change any values in the execution or the external environment.
any such changes would make runningthe code multiple times problematic.
for example a java method that starts with or contains the code if !done.add input return can only be executed once since the next execution would just return.
java live update does not work in these cases.
error tolerant .
the intermediate code created by the user will contain both syntactic errors and semantic faults.
note that especially when creating code there are likely to be errors later in the method even while the code up to the point of interest where the user is editing is correct.
continuous execution must be able to work in such an environment providing output at least up to the first error.
complete .
the system needs to be able to handle a large fraction of the underlying language.
this means being able to handle files graphics as well as all the routines that involve native code.
it also means handling a wide variety of edits.
our approach is based on three insights into how to build a practical continuous ex ecution environment.
the first is that it is generally sufficient to consider only the execution of a single method within an execution.
if seede is used for writing code then the method to be written should be thefocus of attention.
if the system is used for debugging then the user is generally look ing at a particular method for example a unit test case .
concentrating on a particularmethod rather than the full execution makes the notion ofinterpreting and saving all values practical.
the second insight is that the execution should be triggered from a breakpoint in an actual run.
the environmentneeded to run a method i.e.
all the associated data structures .
c circlecopyrt2017 ieeease urbana champaign il usa t ool demonstrations895 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
current values etc.
can be large and complex.
associating a seede run with a debugger session lets seede query thedebugger to access the current environment something thatcould be difficult for the user to manually specify.
the third insight is that the system needs to convey the complete execution including all intermediate results and make it easy for the programmer to navigate within these results.
this is primarily for debugging where the programmer will need to follow the execution and understand where and when problems occurred but is also useful in writing newcode.
our approach operates by combining three interpreters into a single system.
this is outlined in section iv .
it includesa viewer as part of code bubbles that is automatically updatedas edits occur.
this can be seen in the example shown insection iii.
limitations of the approach are discussed in section v .
we are currently working on a formal evaluation ofthe system as described in section vi.
ii.
r elated work the idea of providing immediate execution feedback while coding was central to spreadsheet programming introduced by visicalc.
the idea was picked up for procedural programming by visiprog and more recently in the eg extension toeclipse .
these are both illust rated on simple programs and do not scale to real systems nor do they address the much more complex problems posed by real systems with complex data structures external methods and concurrency.
victor in his talk on live coding demonstrated a sample framework and challenged the audience to create a real one .
a moreextreme version of usin g examples to help coding can be seen in the various programming by example systems that have been developed over the years .
the approach is also being used effectively for datab ase interactions using continuous queries and in interactive data exploration tools.
there have been several studies on how programmers debug and on what tools and techniques might be helpful .
these tend to show that the type of informationand assistance provided by seede can be helpful.
since many of the examples cited for continuous execution are effectively test cases this work is also related to earlyefforts to integrate testing with code writing as in tinker and more recent efforts involving continuous testing .
thework is also related to incremental execution and con tinuous and incremental program analysis .
java and hence various java programming environments support live update of compiled code .
this lets the pro grammer effectively write code wh ile debugging using the full capabilities of the debugger to examine program state and seethe effect of the changes.
this facility can be helpful but is also very limited.
one of our goals is to provide an implementation framework that can provide the benefits of live update without thelimitations.
java live update requires the programmer to savethe edited code without errors and then re execute thecurrent function possibly stepping through the execution toget to the appropriate point of interest.
our approach tracksthe current position in the execution and automaticallyrestores it after an edit.
live update fails completely undermany common circumstances including adding or removing afield or method changing method or field signatures recur sive executions changes to data structures changing declaredconstant values or compiler errors.
our approach handles allof these either automatically or with minor user intervention for example when a new field needs a non defa ult value for existing objects .
live update is not idempotent so code in the method that changes the environment cannot be cleanly reexecuted.
again our approach of executing outside the originalenvironment handles this cleanly.
live update does not handle external i o causing multiple occurrences of output andrequiring the user to reenter input each time.
we address thesecorrectly for the terminal and files .
live update also has problems with synchronization.
si nce live update while holding a lock does not rele ase the lock.
with our approach locks are only maintained within the simulation not in the original program.
a number of systems over the years have been capable of showing a full execution and letting the user move backward or forward in time within that execution.
exdams was perhaps the earliest example .
early graphical environments such as pecan let the user step either forward or back ward .
the algorithm animation system balsa provideda time slider similar to the one we offer .
among the manymore recent debuggers that include similar features are totalview elm s time traveling debugger the traceoriented debugger and others.
ko s whyline providedsimilar capabilities in a que stion answering framework .
dynamic updating has been used for maintaining longrunning applications.
a number of techniques have been developed that take updates an d modify the exis ting system to use the new code .
these require the programmer to identify safe points and concentrate on migrating objectimplementations.
while some of these technologies are useful most of it is too heavy weight to be used continually while theprogrammer is editing.
dynamic object updating has also beenat the center of schema updates for object oriented databasesystems .
our approach uses appropriate techniques fromthese system to simulate object migration where necessary.
sandboxing of files is used extensively for providing security to applications that might be unsafe and served as a moti vation and guideline for modeling external events in ourframework .
iii.
u se the code bubbles tutorial program is a simulation of the romp toy .
the tutorial includes several tasks involv ing fixing the display output notably to change the color of the magnets and to center the output on the magnet cor rectly.
to use seede on the tutorial example we start bysetting a breakpoint at the start of the drawing routine for the board and then start a debugging run up to that breakpoint.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the breakpoint can be at any point in the method as long as the method is idempotent up to that point.
then we right clickto bring up the default pop up menu and select start contin uous execution .
this creates the uninitialized output display bubble shown in figure 1a.
and starts the continuous execution process.
selecting continuous execution for a test case does this allautomatically for that test case creating a launch setting abreakpoint running the code and then starting seede.
seede monitors changes to all editors in the same working set as the seede bubble.
if the user opens new editors they are monitored as well.
other code is interpreted in its original state from byte code.
continuous execution onedits is triggered automatically by messages from code bubbles that indicate edits.
the display only shows methods from the set of editors that are available.
other calls for example to library routines are hidden.
the first execution can take significant time since values need to be loaded from the running process and binary filesneed to be loaded from the class path.
both of these are cachedby the seede back end so that subsequent runs are faster.
the actual performance depends on a variety of factors suchas the amount of data that is retrieved the amount of data being passed back to the front end and the number of instructions executed.
in this case the time is about seconds.
oncethe initial execution has completed the system populates thevarious components of the co ntinuous execution bubble with the resultant values as shown in figure 1b.
the default view provided by the evaluation bubble is a tree containing the variables and their values that were com puted during the simulated execution.
for objects and arrays the user can expand the tree to see the sub values.
the variables are displayed one frame method at a time.
the scroll bar at the bottom of the variable display lets the user scrollover the execution by time.
green areas in the scroll bar repre sent code in the current method gray areas represent code incalled methods.
as the user scrolls the variable values change to reflect their values at that point of the execution.
a specialvariable line shows the current line number at that point.
this line is also highlighted in any editor that is open thatincludes the method.
in addition hovering over a variable inthe open editor will show the history of values of that variable up to the current time.
this can be seen in figure 1j.
at the upper right of the wind ow the system displays the execution status.
this can be pending waiting for an execution to complete return routine successfully returned compiler error execution stopped with a compiler error exception execution stopped with an exception error a problem in seede typically a call to a native method or timeout execution stopped because it was taking too long e.g.
with an infinite loop .
in addition to the variable window the seede display can show a graph of the lines executed figure 1c or the call treeor graph figure 1d .
the call tree can also be displayed as a linear view of the stack over time figure 1g .
the user canselect a value and ask for the data dependence graph for thatvalue.
the result is a display of the values leading to it figure 1h .
in addition if the program does any file output the result is shown in an output panel figure 1i .
experience using seede demonstrated the importance of being able to navigate over time to understand the overall execution especially when using the tool for debugging.
as aresult we have added a variety of navigation options.
one canright click on the time scroll bar to go to an inner context.
onecan go to the next or previous call or the next or previous line.one can click on a value in the call tree or the stack view tosee that particular instantiation.
one can select a variable andgo to the context where it was written.
in addition the callgraph stack and data dependence views provide navigation options.
in the example because the breakpoint was set at the start of the paint routine the continuous execution bubble includes a graphics panel showing the window output as computed by interpreter in figure 1e.
this is generated automatically by seede once it detects that the routine being inte rpreted is a painting routine.
users can also point to other variables thatreflect graphical components and request a drawing windowfor those as well.
at this point we can attempt to edit the code and see the result.
we first bring up the drawmagnet routine in a separate bubble and then change the color setting for drawoval from color.green to color.red .
in under a second the graphical output view updates to reflect the change.
next we try center ing the or over the magnet by changing the position passedto drawstring .
after each change we see the result and can quickly settle the proper change to the coordinates.
the final result is shown in figure 1f.
iv .
i mplementation overview seede runs as a separate process talking to both the front end application and to code bubbles eclipse based back end through the code bubbles messaging interface as shown in figure it takes requests from the application and sendsexecution updates back to it as they become available.
it uses the back end to query the value of variables to understand the java environment and to detect changes both to the execution and to files being edited.
the actual system has several major components.
first there is a value cache.
this holds the value of any variable that is accessed by the code that is being run.
moreover it tracksthose values over time so that it actually stores all the valueseclipse plugin code bubbles bicexseede controller interpreter modelervalue cache fig.
.
overview of the seede architecture.
file manager authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
views of the continuous execution display bubble.
a initial view before initialization b variable view showing time slider and values c graph of line number based execution d call graph view of execution e initial graphical output window f graphical output after editing g stack view h data view showing variable dependencies i file output view j editor view showing highlighted line and tool tips authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that were saved in that variable with a clock indicating when the changes occurred.
the cache lets the system accessmemory at any point in the execution.
this structure whilecreated in the interpreter is duplicated for variables that aredisplayed by the front end allowing the user to see theirvalues over time.
the second component is a file manager responsible for tracking the current state of all active files and buildingresolved abstract syntax trees for each execution environmentas the files change.
the third component is a co mbination of three interpreters that work off the same value base and the same global clock.the first is an interpreter for abstract syntax trees that is usedfor code that the user can change.
the second is an interpreterfor byte codes that is used for library methods as well as partsof the system which are not being edited.
the third is an inter preter for native code.
this simulates many of the java librarymethods that use native code by executing equivalent code in the interpreter or by invoking routines in the debugged process.
strings are handled by this interpreter for efficiency.
the fourth component of seede is a set of output models that reflect the effect of the code on the external environment.the current implementation includes two basic models.
onehandles graphical output maintaining the set of graphics com mands that are executed for a given window over time.
thisallows the front end to show the effect of changes on graphicaloutput something that cannot be done using java live update.the second is a model of files and the file system.
this modelessentially provides a shadow file system where the applica tion can read and write without affecting actual files or theenvironment.
outputs are recorded by time and passed to thefront end for appropriate display.
the third is a synchroniza tion model that handles locking between threads assuming thatall the threads are being interpreted.
the final component is the controller.
this understands the debugger session that the user is evaluating from obtains and caches values from that session for use by the interpreters tracks multiple threads handles stopping and rerunning exe cution when the user makes changes in the editor handles any interactions between the front and back end i.e.
requests foruser console input made by the code or requests to display the result of drawing a particular window after the code has exe cuted and passes back complete execution information when executions have finished.
v. l imitations since the code is being interpreted and being interpreted potentially on each keystroke performance of the interpreter can be a major concern.
however since the system is targeted toward developing and debugging a single routine at a particular point in the program the amount of interpretation may notbe that great.
currently we are processing about variable updates a second the interpreter clock ticks each time a value is written .
for the examples we have been looking at response other than the initial run has not been a problem.the second limitation involves determining what the system can and cannot do.
there are obvious limits in terms of the interfacing with the outside world when the interpreter issupposed to ensure that nothing external is changed.
forexample using sockets to communicate with an externalprogram is problematic.
database access is not handled butcould be added with some caveats.
other limits are based onthe current prototype implementation.
for example we do nothandle all possible file system changes.
handling synchronization and multiple threads is complicated and seede does not necessarily do it correctly.
theproblems arise because some of the threads that need to besynchronized might not be simulated.
it is difficult to synchronized running threads with the threads being simulated or to detect lock changes in the running threads and propagate themto the threads being simu lated.
moreover the notion of caching values from the running program only works if thosevalues are static.
other limitations involve what edits can and cannot be supported by the system.
some such as deleting the routinebeing interpreted are difficult to accommodate.
others suchas adding new methods are relatively easy.
the interesting ones involve changes that affect the environment before thecall.
for example adding a new field to a class requires allobjects of that class to have that field and for that field to have a value for those obj ects.
our current approach handles this but requires either a default or user defined value to be usedfor all such instances.
vi.
p roposed ev aluations while we originally developed seede to assist in writing new code we have also noted its potential for debugging.
we are currently starting a user study to look at two hypotheses seede helps programmers when writing new code.
seede can make debugging fast and accurate.
our user study will look at these two questions.
after instructing the participants on the use of code bubbles and seede we will have them do both a debugging and a code writing task.
we are considering standard debugging tasks e.g.
from parnin and orso and creation tasks such as thebinary search example of victor .
for each task we will have participants do the task using code bubbles with and without seede.
we will measure time and accuracy of the solutions.
we will also get the user s opinions on the utility and appropriateness of the tool.
vii.
a v ailability seede is integrated into currently available code bubbles environment.
code bub bles is available as a binary distribution from codebubbles.
the current source di stribution is available from sourceforge.
the seede execution engine is available from github.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.