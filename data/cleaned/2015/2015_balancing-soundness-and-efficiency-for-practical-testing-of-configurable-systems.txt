balancing soundness and efficiency for practical testing of configurable systems sabrina souto state university of para ba para ba brazil sabrinadfs gmail.commarcelo d amorim federal university of pernambuco pernambuco brazil damorim cin.ufpe.brrohit gheyi federal university of campina grande para ba brazil rohit dsc.ufcg.edu.br abstract testing configurable systems is important and challenging due to the enormous space of configurations where errors can hide.
existing approaches to test these systems are often costly or unreliable.
this paper proposes s splat a technique that combines heuristic sampling with symbolic search to obtain both breadth and depth in the exploration of the configuration space.
s splat builds on splat our previously developed technique that explores all reachable configurations from tests.
in contrast to its predecessor s splat sacrifices soundness in favor of efficiency.
we evaluated our technique on eight software product lines of various sizes and on a large configurable system gcc.
considering the results for gcc s splat was able to reproduce all five bugs that we previously found in a previous study with splat but much faster and it was able to find two new bugs in a recent release of gcc.
results suggest that it is preferable to use a combination of simple heuristics to drive the symbolic search as opposed to a single heuristic.
s splat and our experimental infrastructure are publicly available.
keywords sampling testing configuration.
i. i ntroduction configurable systems are those that can be adapted from a set of input options reflected in code in the form of variations.
these systems are prevalent .
the firefox web browser the linux kernel the gcc compiler infrastructure and the deals recommendation web service groupon are some well known examples of configurable systems.
unfortunately configuration related errors are not rare .
some of these errors have been widely publicized in the media given the volume of users or data they affected .
a configuration space consists of all combinations of input options that can be used to configure a system.
configuration errors are often manifested in a small fraction of such space.
finding an adequate set of configurations for testing is therefore challenging.
in one limit testing exhaustively against all configurations is unacceptably expensive.
in another limit testing against one default configuration albeit popular leads to high chances of escaped defects .
these approaches to testing make strong commitments to either cost or reliability.
combinatorial interaction testing cit has been popularized to balance probability of finding configuration errors i.e.
efficacy and efficiency .
several sampling heuristics have been proposed in the past to support cit.
for example pairwise testing adequacy i sobtained when the sample set of selected configurations covers all possible pairs of input options.
the intuition is that bugs are uniformly distributed in the configuration space a more uniform search will then have higher chances of finding bugs.
sampling heuristics are typically black box they do not take code test or app into account.
this is an important source of imprecision that can lead to error misses and higher cost.
more recently sound testing techniques have been proposed they assure that all configuration errors that can be captured with a given test will be captured.
these techniques dynamically explore all reachable configurations from a given test.
the hypothesis is that when each test is analyzed separately configuration complexity is much lower compared to the theoretical combinatorial complexity.
this is the case for example when test execution dynamically accesses a relatively small number of configuration variables .
unfortunately reaching soundness without compromising cost is challenging.
recent empirical studies indicate that scalability depends on many factors including the subjects and tests used .
in summary the inability to reason about test cases constitutes an important limitation of sampling techniques and the potential high execution cost is an important drawback of dynamic sound techniques.
this contrasting set of limitations motivated us to explore the synergistic integration of these approaches with the goal of finding a better balance between reliability as to miss fewer errors and cost as to find errors faster .
in this study we used splat a sound technique previously developed by the authors that monitors variable accesses in one execution and based on that decides which configurations should be executed next.
our goal is to understand the effects of combining sampling heuristics with a sound technique for testing configurable systems.
we propose s splat a variant of splat that selects configurations according to a given sampling heuristic.
note that tension between soundness and tractability has a long history in program analysis.
recently the static analysis community acknowledged the importance of making and documenting conscious unsound design choices in favor of practical soundy solutions .
a similar tension exists in the context of dynamic analysis techniques such as splat .
we analyzed s splat with five basic heuristics that have demonstrated promising results in different studies ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and eleven combinations of these basic heuristics.
we considered eight relatively small software product lines and one large configurable system gcc in the evaluation.
results confirm expectations that regular splat often does not scale i.e.
it is unable to explore the space of reachable configurations completely within a long time budget.
this situation occurs even on smaller subjects where splat did not complete exploration in two of eight cases.
for gcc splat could finish exploration of only .
of of the tests after one week of execution.
considering s splat results indicate that compared to splat techniques dramatically reduce the number of configurations explored yet retaining their ability to reveal failures and crashes.
the heuristic variants of s splat were able to find all five crashes that we previously documented on gcc release .
.
and uncovered two new crashes on release .
one of which was reported to the gcc team and was already fixed.
overall considering our experimental setup results suggest that it is preferable to combine some heuristics that demand a relatively low number of test requirements e.g.
one enabled and one disabled than using heuristics that solicit more test requirements e.g.
pairwise .
this paper makes the following contributions idea w e propose a hybrid approach to test configurable software that integrates sampling with systematic exploration of configurations section iv .
our approach is similar in spirit to hybrid concolic execution implementation w e implemented s splat a variant of our previously developed technique splat .s splat selects test reachable configurations according to a given sampling heuristic evaluation we evaluated s splat on a number of subjects of various sizes and sources section v .
results indicate that the approach is promising reducing cost and retaining ability to find failures and crashes prototype we implemented a prototype of our technique.
the code datasets containers and scripts are all accessible from our website .
ii.
b ackground this section introduces concepts and terminology to support the discussion along the text.
a. configurable systems configurable systems css are systems that can be adapted or configured according to a set of configuration input options represented at the code level by configuration variables also known as feature variables .
to simplify definitions we assumed that configuration variables are boolean and that every input option maps to a single variable.
our definitions extend to any range types booleans being a special case.
if a configuration option is enabled it means that the corresponding variable is set to true.
otherwise it means that the variable is set to false .
we make no distinction between software product lines spls and other kinds of configurable systems.
let be a set of boolean variables denoting the configuration variables of the system.
a configuration c arrowrighttophalf fa ls e true is a partial function from variables to boolean values cmaps some not necessarily all configuration variables to valuesclass notepad void toolbar if toolbar ... if wordcount ... if menubar ... ... void test toolbar config t !w !m config !t w !m config !t !w m one enabled config !t w m config t !w m config t w !m one disabled config !t !w !m config t w m most enabled disa bled config !t !w m config !t w !m config t !w !m config t w m pair wisevoid constructmenu constructmenu fig.
.
excerpt of notepad and sampling sets for testing.
false ortrue.
a configuration can be encoded as a boolean formula fc logicalandtextpi where pi xi xi for xi .
we denote with fc the number of variables referenced in fc.
we say that a configuration ciscomplete iff fc i.e.
all variables had their values assigned to true orfalse i ti s partial otherwise when only a subset of the variables had their values assigned.
example let a b c d e .
configuration fc1 a b c d eis complete.
configurations fc2 a band fc3 a b c eare incomplete.
c2can be also written as ?
??
where the ithposition corresponds to the ithconfiguration variable according to a given total order on variables.
we use numbers 1and 0to indicate respectively the true orfalse values and the symbol ?to indicate undefined it means that no value was assigned to a given variable during test execution.
afeature model fm distinguishes which combinations of variables are legal from those that are not.
a complete configuration is valid if it satisfies the constraints of the feature model.
a partial assignment is satisfiable if it can be extended to a valid complete assignment.
in practice the fm may not be always documented or available.
b. sampling heuristics notepad is a visual text editor implemented as a configurable system that has been previously used in related studies .
figure 1shows an excerpt of notepad to illustrate sampling heuristics.
function constructmenu creates the menu on screen whereas the corresponding test checks if the menu has been properly created.
note that the call to constructmenu accesses the configuration variables toolbar t wordcount w and menubar m which are relevant for the presentation of both the toolbar and menubar on screen.
the names in parentheses denote corresponding input configuration options.
among the various sampling heuristics proposed in the literature related to testing configurable systems we considered those that have been recently evaluated and are applicable in our context .
the heuristic one disabled samples configurations that have only one option disabled and all other options enabled whereas one enabled samples configurations that have only one option enabled and all the rest disabled.
the heuristic most enabled disabled combines two sample authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sets independently one set with most options enabled and one set with most options disabled.
in case feature constraints are not considered this heuristic will only check two configurations the one with all options enabled and the one with all options disabled.
finally t wise samples all combinations of t configuration options.
in particular pairwise t wise with t checks all pairs of configuration options and it selects four configurations of the example of figure .
considering options tand w we can see that there is a configuration where both options are disabled config two other configurations with only one of them enabled config and config and another configuration where both configuration options are enabled config .
the same situation occurs for configuration options tand mand options wand m. figure 1shows at the right hand side sampling sets for each of these heuristics.
notepad has a total of variables however to simplify illustration we focused only on variables m t and w. for example a sample set for one enabled can be obtained with only three configurations each configuration corresponding to the selection of one variable.
it is important to note that these heuristics are blackbox they do nottake into consideration test and code.
all tests will be executed against the same set of pre computed configurations.
this means that this approach can miss relevant configurations leading to error misses and can also include irrelevant configurations leading to additional cost .
again note that we used three variables on figure 1to simplify illustration.
had all variables of notepad been considered the size of the sample set would be significantly larger.
c. splat in a nutshell splat works as follows.
it executes the test on one configuration observes the values of configuration variables that have been accessed during the execution and uses these values to determine what other configurations should be considered in subsequent test executions.
for example if a test execution accessed only one configuration variable f with value false then splat re executes the test with fset to true.
if that second execution accesses no other configuration variables the search stops.
otherwise it continues to explore the combinations of values of other accessed variables.
splat repeats this process until it explores all dynamically reachable configurations or until it reaches a specified bound on number of configurations.
as output splat returns for each test the configurations explored and the respective results pass or fail .
splat only explores configurations which are reachable through tests.
in contrast to sampling splat does not explore configurations unrelated to the test and cannot miss configurations that would otherwise reveal failures.
however splat can access several variables through a test leading to high execution cost a factor that can be controlled through sampling.
iii.
e xample this section presents an example comparing three approaches to testing sampling with one enabled sound exploration with splat and a combination of sampling and sound exploration.we used the notepad test from figure 1in this comparison.
figure 2shows the sample sets obtained.
the values corresponding to variables toolbar wordcount and menubar appear in the initial positions of the configuration vectors see section ii a in these sample sets.
config ?
?
?????????????
config ?
?
?????????????
config ?
?????????????
config ?
?????????????
config ?
?????????????
config ?
?????????????
splat config config config config config g2 g1 g2 g1 g2 config config 1regular sampling one enab led config ?
?
?????????????
config ?
?????????????
s splat one enabled fig.
.
configurations generated with one enabled splat ands splat for the notepad test from figure .
notepad has configuration variables.
ignoring constraints a sampling set adequate to one enabled includes configurations one for each configuration variable to be enabled.
note however that the function under test constructmenu accesses only three of these variables see figure .
there are configurations in this set that produce the same output as they do not access any variable reachable through the test.
in contrast to sampling splat runs the test only on reachable configurations i.e.
configurations that relate to accessed variables.
for this case splat runs the test against six configurations as shown in figure .
furthermore note that variable wordcount is only accessed if variable toolbar is accessed such conditional accesses enable further reduction of the search space.
to provide soundness guarantees splat needs to explore all reachable configurations it assumes that tests reach a relatively small number of variables.
unfortunately we observed that for a large system such as gcc with hundreds of configuration options exploring all reachable configurations is impractical for several tests .
this paper proposes s splat for sampling with splat to mitigate the individual limitations of sampling and splat .
s splat uses the set of reachable configurations from splat see section ii c to sample those configurations that satisfy a given sampling heuristic.
s splat is by definition unsound.
the intuition is that the use of heuristics can provide a better balance between cost and reliability and that balance is essential for practicality in this domain .
figure 2shows results of s splat with one enabled .
the corresponding sample set includes only two configurations.
note that it is not possible to build a one enabled configuration with variable wordcount set as it is not possible to access wordcount without also accessing variable toolbar .
s splat proceeds as follows to explore these two configurations.
in its first iteration on this test s splat assigns default values to every variable it accesses as splat does reaching the partial configuration t m which clearly does not satisfy one enabled .
at this point s splat looks for neighbor configurations to t mthat satisfy one enabled and it finds t m which corresponds to the first configuration vector in the figure ?
... .
after executing the test on configuration ?
... s splat backtracks.
note that at that point variable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mwas fully explored under t. then s splat initiates a new iteration from a partial configuration where tholds.
at the end of execution of the corresponding path s splat explores the configuration t w m which also satisfies one enabled .
at that point s splat cannot find any other reachable configurations that satisfy one enabled and the execution finishes reporting two configurations.
iv .
s ampling with spl at this section describes s splat for sampling with splat a modified version of the splat algorithm .s splat samples configurations from the set of dynamically reachable configuration from a given test that splat explores.
in the following we present the workflow of s splat highlighting key modifications made to the original splat algorithm.
a complete version of splat can be found elsewhere .
a. basic workflow figure 3shows the pseudo code of s splat .
it takes as input a test tfor a configurable system and an optional feature model fm.
to drive the search the algorithm uses a map that stores the values of feature variables variable state at line and a stack of feature variables accessed during the test run variable stack at line .
an object of type assign encodes an assignment of boolean values to feature variables.
it denotes a partial configuration see section ii a .s splat supports different sampling heuristics line .
the algorithm first initializes the values of feature variables lines using the feature model.
mandatory features are set to true the only value they can hold and optional features are initially set to false .
we omit details of the feature model interface for brevity.
it is important to note that the steps related to the feature model are optional.
we did not show this variant for brevity.
when present feature models enable consistency checks on configurations reducing the explored search space.
after this initialization step s splat automatically instruments the code under test to track variable read accesses line .
the main loop of the algorithm lines looks for a partial configuration lines and runs a test against that configuration line .
whenever test execution is about to read a feature variable it calls back the method notifyfeatureread line and if the variable has not been visited before it is pushed onto the stack and a new value is assigned to it.
when s splat finishes the execution of a test on one configuration line it has effectively covered a set of complete configurations extensions of the corresponding partial configuration.
splat determines the next configuration to execute by backtracking on the stack lines .
if the last read feature has value true then s splat has explored both values of that feature and it is popped off the stack lines .
if the last read feature has value false then splat has explored only the false value and the feature value should be set to true lines .
this process repeats until the stack becomes empty and all dynamically reachable partial configurations are covered.
data structures 2class featureva r ... 3class assign map featurevar boolean state 4enum mode random one enabled ... pairwise state 7map featurevar boolean state 8stack featurevar stack 9static boolean checkfm false static mode heuristic mode.random 12void s splat test t featuremodel fm initializes features state new map for featurevar f fm.getfeaturevariables state.put f fm.ismandatory f instruments the code under test instrumentoptionalfeatureaccesses do repeatedly run the test stack new stack run test with configuration in state line t.runinstrumentedtest assign pa g etpartialassignment state stack print configs covered fm.getvalid pa look for next configuration to run test at line while !stack.isempty featurevar f stack.top if state.get f state.put f false restore stack.pop else state.put f true pa getpartialassignment state stack check if satisfying vector is reachable from stack if heuristicissatisfied pa checkfm break success!
while !stack.isempty called back from test execution 47void notifyfeatureread featurevar f featuremodel fm if !stack.contains f stack.push f state.put f fm.ismandatory f 54boolean heuristicissatisfied assign pa boolean checkfm boolean res false switch heuristic case one enabled res checkoneenabled pa checkfm break .
.
.
return res fig.
.
s splat algorithm splat algorithm modified .
b. sampling the method heuristicissatisfied lines called at line checks if the partial configuration pa passed as parameter satisfies the selected sampling heuristic.
this method delegates to a checking function the decision of whether or not the configuration should be sampled.
if a relevant configuration is found execution proceeds to that configuration line .
if not s splat keeps searching for a configuration on the stack.
if no configuration can be found the stack becomes empty and splat terminates line .
checking functions.
test requirements vary with the sampling heuristic.
a boolean checking function answers positively authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
checks if pa covers a one enabled test requirement 2boolean checkoneenabled assign pa boolean checkfm boolean shouldsample false int oneenabledcounter for boolean b pa.state.values oneenabledcounter b?
if oneenabledcounter shouldsample true if !shouldsample return false if checkfm return issat pa return true fig.
.
example of a checking function for s splat algorithm whenever an input configuration satisfies a test requirement that has not been yet covered.
figure 4shows an example checking function checkoneenabled for deciding if the input configuration should be sampled according to one enabled .
this function is called at line 58from figure .
for this heuristic the configuration will be considered for sampling only if the number of variables set in the partial input configuration pa is exactly one.
if the parameter checkfm is set this function will also check if the configuration is satisfiable line according to the input feature model.
note that this check is only performed after a test execution completes producing a partial configuration line not during test execution.
other sampling heuristics are implemented similarly.
we chose this function for brevity.
c. handling non boolean variables non boolean variables are common in configurable systems.
we describe in the following how s splat handles variables with integer ranges which are relatively common in gcc.
one option to handle range types is to incorporate range values in the s splat algorithm.
with that instead of making a binary choice where the algorithm assigns a boolean value to a variable s splat would make a multi valued choice.
we disconsidered that design choice as it would create too many very similar configurations by construction.
instead we applied the ostrand and barcer s category partitioning method treating range types as boolean types.
more precisely we partitioned the input domain in two categories enabled and disabled selecting one and only one element in the range to belong to the disabled category if in the range .
v. e v aluation we evaluated s splat in two scenarios.
in the first scenario we considered relatively small software product lines with the goal of identifying patterns of performance across different sampling heuristics.
in the second scenario we evaluated the techniques on a large configurable system gcc manifesting different characteristics compared to spls.
the goals of this experiment are to validate whether results obtained on gcc are consistent with those observed on spls and to assess the ability of s splat s heuristics to find real faults.
furthermore we evaluated the influence of feature constraints in our techniques.
we pose the following research questions rq1.
which heuristics maximize efficiency?
rq2.
which heuristics maximize efficacy?table i. software product lines used.
subject tests conf.
variables confs.
v alid confs.
loc 101companies desktopsearcher email gpl jtopas notepad sudoku zipme rq3.
which heuristics basic or combination maximize efficiency and efficacy?
a. software product lines spls subjects.
we selected eight spls previously used in other studies .
all these spls provide tests and their feature variables are dynamically bound to code.
table icharacterizes these subjects.
column tests and features show respectively number of tests and feature variables.
columns confs.
and valid confs.
denote respectively the number of configurations and the number of configurations which are valid according to the feature model.
finally column loc shows code size.
techniques.
we considered six basic techniques the baseline splat and the following heuristics for selecting configurations with splat random ran one enabled oe one disabled od most enabled disabled med and pairwise pw as defined in section ii b. we also considered combinations of these basic heuristics to answer rq3.
we set a global timeout of 48h on splat and random per subject as these techniques can potentially take too long to finish.
answering rq1 efficiency we used the average number of configurations explored per test that a technique selects as metric for efficiency.
using wall clock time could bias results in favor of heuristics that select configurations exercising short paths.
in addition results are more vulnerable to measurement noise for small subjects and short running tests.
to note that previous studies used similar metrics for similar reasons .
figure 5shows the distribution of results per technique as boxplots.
a point in the boxplot indicates a measurement i.e.
the average number of configurations that a basic technique explores on a given test .
g gg gggg ggg g gg gg gg gg ggg g gggg gg gg gg gg med oe pwo dg gg gg g g gg ggg050100150200 ran s plat fig.
.
average number of samples per technique.
as expected the number of configurations that splat and random explore is much higher compared to alternative techniques.
on average random sampling on s splat explores half of the configurations that splat explores i.e.
every configuration that s splat reaches when using random selection has fifty percent chance of being selected.
intuitively if splat s exploration blows up s splat with random exploration should authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
also blow up.
we considered different rates of sampling as to assess its effects on results see section v e .
splat and random selected sample sets with average sizes of and respectively.
recall that we configured random to explore on average half of the configurations that splat explores.
furthermore it is important to note that the distributions of splat and random do not include results for desktopsearcher and notepad .
these techniques timed out on these subjects because of the cost of exploring a high number of configurations on long running gui system tests.
this case sheds light to the inherent limitation of these techniques.
considering all basic techniques but splat and random the size of the sample sets i.e.
average number of configurations explored per test ranged from to .
.
overall most enabled disabled explored the smallest sample sets whereas one disabled explored the largest sample sets.
answering rq2 efficacy in this experiment we used the average number of failures per test as metric to assess efficacy of each technique.
we considered distinct failures as opposed to faults as proxy for efficacy because documented faults are scarce for these programs.
we ignored repeated manifestations of failures i.e.
failures of a given type that have been already reported with a given pair of test and technique.
gggg g g gggg g ggg g g g g g g ggg ggg ggg ggg g gg ggg gg gg g gg ggg g1234 med ran oe pw od splat fig.
.
average number of failures per technique.figure shows the distributions of number of distinct failures found per technique.
we observed that one disabled and pairwise found on average more failures than any other technique except splat .
given the number of configurations that random selects we found surprising that it performed poorly in several cases.
this result indicates that the use of heuristics to explore the search space more uniformly is important.
we also observed that splat s distribution of results ignoring outliers is not very different compared with the distributions of other heuristics.
finally considering the subject email we observed that all techniques revealed the same failures.
that happened because the failure density ratio was high on this subject indicating perhaps as expected that high failure density ratio favors more aggressive heuristics.
answering rq3 efficiency and efficacy the goal of this experiment is to better understand the relationship between efficiency and efficacy which are conflicting optimization dimensions.
a technique can optimize one dimension but perform poorly with respect to the other s .
splat for example optimizes efficacy but perform poorly relative to others with respect to efficiency.
in addition to the basic heuristics discussed we also considered combinations of heuristics in this experiment.
the intuition is that unexpected combinations could provide a better overall balance between these dimensions.
we implemented combinations referred with the following ids symbol indicates combination c1 oe od c2 oe med c3 oe pw c4 od med c5 od pw c6 med pw c7 oe od med c8 oe med pw fig.
.
comparison of efficiency x axis versus efficacy y axis .
the pareto front shows non dominated data points is highlighted with filled circles.
c9 od med pw c10 oe od pw c11 oe od med pw .
we obtained results for these combinations by taking for each test the union of the sample sets and failure sets generated by the corresponding basic heuristics.
for example let us consider technique c6 which combines most enabled disabled med with pairwise pw .
suppose medselected two configurations on a given test namely ?
and ?
and found one failure whereas pwselected three configurations for the same test namely ?
?
and ?
?
and found two failures with one of those also detected by med.
for this case c6 produces four configurations and two failures duplicates are ignored.
note that the set of combinations are partially ordered by inclusion e.g.
c1 subsetsqequalc10 subsetsqequalc11 .
figure 7shows results with each plot focusing on one subject.
the x axis shows average number of configurations per test and the y axis shows average number of failures detected.
a point in the plot denotes the result of a heuristic basic or combination on a given subject.
to facilitate visualization the plots show the pareto fronts of measurements as solid circles.
a point that belongs to the front is not dominated by any other point.
the front helps one to make an informed decision on which technique should be selected provided she decides on the importance of one dimension over the other.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
note that as a sound technique splat appears in the front of all plots with the exception of desktop and notepad due to timeouts .
the plots also show that splat and medare in almost all cases at two opposing extremes in the optimization scale see corner positions these techniques optimize one dimension at the expense of the other dimension.
furthermore we found that combination techniques appeared consistently at the front or close to it.
note that the fronts serve as reference of dominance not to draw general conclusions about performance the distance from a non dominated point to dominated point i.e.
technique can be minor in several cases.
for example combination c7performed consistently well in both dimensions but only appeared at the front in three cases.
summary results indicate that the heuristics studied dramatically reduce the number of configurations explored bysplat yet retaining their ability to reveal failures.
in particular the basic heuristic one disabled and the combination heuristic c11performed consistently well with respect to efficiency and efficacy in all cases.
b. gcc we also evaluated s splat against the gnu compiler collection gcc a large configurable system with hundreds of options .
the primary goal of this experiment is to assess how the heuristics perform on a large system with hundreds of input options.
we considered three different setups in this experiment.
in one setup we measured ability to find test failures in the gcc release .
section v b1 .
then we evaluated how the basic heuristics perform to find unknown crashes also using release .
section v b2 .
finally we used an older release of gcc .
.
to evaluate ability of the basic heuristics to find known crashes section v b3 .
we focused on crashes that the authors found in a previous study .
tests analyzed.
gcc uses dejagnu as testing framework.
the test artifact typically includes some code fragment to be compiled a number of compilation tasks and required options.
for example compilation tasks include preprocessing compiling assembling linking and running code .
we analyzed a total of tests from the gcc dg test suite.
we focused on that suite because previous study has shown a higher incidence of bugs found with it .
a gcc test runs by default against a single default configuration.
splat runs the same test on multiple configurations but respecting mandatory test options.
options analyzed.
we limited the number of options to analyze see given the long execution times found in some test cases.
we used the most frequently cited options in the gcc bug reports from the period of april to may .
the rationale was that more bugs could be found close to where existing bugs have been recently reported.
we noticed that the top options do not change much across months.
techniques.
this experiment considered all basic and combination heuristics of splat .
we did not consider splat itself because of its high execution cost.
for example considering this setup splat could finish execution of only tests .
ggg ggg g g gg g g g g g gg g gggggggg g g g g ggg ggggg g g g g gg g gggggggg g g gg gg gggggg ggg g gggg g ggg g ggggg g g g gg ggg gggggg ggggg g ggggggg ggg gggggg gg gggg g gg gg g g g gggg g gggg gggg g g gg gggg ggg g ggggggg g g g g ggggg gggg gggggg ggg gggggg g g g g g g g g ggg gg g gggggggggg g g gggg g ggggg gg gg g gg g g gg g gg g g ggg gg g g gg gggg g g g gggg gggg g g g g gggggggg gg gg gggggg g g gg g g ggggggggg ggg ggg ggggg ggg ggggg g gggggg g ggg gggggg gg g gggggggg g gg gg gggg g g gg g g g ggg ggg gg gg g g ggggg gggggg gggggg gg gggg ggg g gggg g g ggg g g ggg g ggggggg g gggg g gg g g g g ggg gggg g gg g ggg g g gg gggg g g gggg g g g g ggg gg g g g g g gg g ggg g gggggg gg g ggg ggg gg gggg gg g g gg gg gg ggggg g g gg g g ggg ggggg g g gggg ggggggg g ggg g ggg g g gg gggg gggg gggg g g gggg gggg g g gg ggg ggggggg g ggg g gg g gg gg g gg ggg g g g gggg g g g ggg g g gg g ggg g gg ggggg g g g ggg ggg g g ggg gg g ggggggg ggg gg g gg gggg g g ggg gggg g g g gg g g g g ggg g g g ggg g ggggg gg g g g g g gg gggggggggggg g gg g g gg g g gggggggg gg g g ggg ggg g g g gggg g gggggggg g gggg g g gg g gg ggg ggg gg gg gg g g g gggggg ggg g gggg gggggg g gg gg gggg g g g g gggggggggg g ggg gg gg gggg gg g ggggggggg gg g g g ggg g ggg ggggggggg ggg g g g g ggg g gg g gggg gggg ggg gggggg g ggg ggggg g ggg g ggggg ggg g gg gggg gggg g g gg gggg gggg g gggg gg ggg ggggggg g g gggggggg g gg ggg g gg g gggg g g gg g gg g gggg g g ggggg gg gg gggg g ggggggg ggg g gg g gg g gg ggg g g gg ggg gg g g ggg ggg g gggg gg g g ggg g g g ggggg ggg gg ggggg g gg gg gg g g g g ggg ggg ggggg g gg ggg g gg ggggg gggg gggg ggg gg g gggg gg gg g gggggggg g g g g ggg ggggg gg gg g gg g g ggg g gg gg g gg gg g g g g g g ggg g gg g g gg ggg g gg g g g gggggg g ggg ggggg ggg g g gggg g ggg g ggg g g ggg ggg g ggggg gggg g g g g gg gggg g g gg g g gg g g g ggggg g g g g gg gggg g gggg gg gg gg g ggg gg gggg g g g gg g ggg gggg g gg gggggg g g ggg g ggg g gggg gggggg g ggg gg g g g g g g gg gg ggg ggg gggg gg ggggg g ggggg ggg gg gggg g g g ggg ggg g ggg gg gggggg g g g gg g ggg g ggg gg g g g gg gggg gggggg gg ggggg g ggg g gggg ggg g g ggg gg g gggg ggg gg gggg g g g ggggg ggggg gg ggggg gg g ggggg g ggg gggg gg g ggg ggg g gggg gg gg ggg gg g gg g ggg ggg gg g g g g gg g g ggg g gg g gg g g ggggggg ggg gggg g gg gg gg g g ggg g g g g gg gggg gg g gggg g gg ggggg g gg gg g gggggggggg gggg g gg g gg ggggg gg gg ggg g gg gggg g gg g gggg g gggg gg g ggg g ggg ggg ggg g gggggg g g gg ggg gggg ggg g g gggg g gggg ggggg ggg g g gg gggg ggggg g ggg g g g ggggg g g gg gg gg gg gg gg ggg gg g gggg gg gggg ggg g g gg gg ggggg gg ggg gg ggg g g gg g ggg g gg gg gg gg ggg g gg gg gg gg g gg gg gg ggg g gg gg g gg g gg g gg g g gg gg gg gg gg g ggg gggg gg gggggg gg ggg gg ggg ggg gg g gg gg gggg ggg gg gg g g gggg g g g gg ggg g g gg g gg g g ggg g g ggg gg ggg ggg ggg gg g g gg ggg gg g gg ggg gg gg g ggg ggg g gg gg gg ggg ggg gggg ggg gg g gg g ggg ggg g gg gg gggg g gg g g gggg gg ggg g g gggg ggg g ggg gg ggg gggg gg gg ggggg g gg gg gggggg gg ggg g g g gg gg g gg gggggg g gggg g g gg gg g gg ggg g gggg gg g gggg g g g gggggg ggggg ggg ggg gg g ggg g g g gggggg gg gg g g gg g g ggg gggggg g gggggggg gg gggg gggg gg gggggg ggg gg g g ggg gg ggg g gg g g gg gg gg g med oe od pw ran a efficiency.
distributions of number of configurations each technique explores per test.gg g g g g gg g gg gg g g g g g g g g g gg g gg g g g g g g g g g g g g gg g g g g gg g g g g g g g g g g g g g g g gg g g g g g g g g gg g gg gg g g g gg g g g g g g g g g g g g gg ggggg ggg g ggg g ggg g ggg ggg gg ggggg gg ggg ggg gggg gggggggg gggg gggggggggggggggggg g ggggg gg gggggg g ggg gg gggggggg gg ggggggggg gg gg ggg ggggggggggggggg gggggg gg gg g gggg g gggggg g g gg gg ggggggggggggggggg gg ggg ggg ggg ggg g ggg gg g ggg g g gg gggg ggg gg g gg ggg g gggggggggg ggggg g gggggg gg gggg g g g gggggggg ggg g ggg g gg g ggggggg gggg ggg gg gggg gg gggg gg gg ggggg g gg gg gggg gggggggggggg gggggg g gggg g g gg g gggg g g ggggg ggggg ggg gggggg g g ggggg ggggggg ggg ggggggggg gg g gggg gggggg g g g gg ggg gg gggggg ggggg ggg ggg gg gg gggggggggggggggg ggggggggggg g g ggggggg gggggg g g g gg ggg g ggg ggggg gg g gggggg gggg gg ggg ggggg ggg ggg ggg gg ggggg gg ggggggg gg gggg g g ggg gg g ggg gggggggg g ggggg ggg ggg g gg gg gggggggggg g g gg g ggg ggggggg ggg ggg gg g gggggggggg g gggggggg ggggg gg gg gggg gg ggg g ggg ggggggg gggggggggggg gg gg gg gg gg gg ggg gggggggg ggg ggggg gggg g gggg gggggggg ggg g gg ggg ggg g gg ggggggggg ggg ggg gg g gggg gggg g gg gg gggg g gg gggg gg gg ggg g gg gg gg g ggg gg gggggg gg gggggg g gggggg gggg ggg ggg g ggggg gg gggggg g g gggg gggg ggg ggggggg ggg ggg gggg gggggg gg g ggg gg gg gg g g ggg gg ggggg gg gg gg g ggg gg ggg ggg g gg gggggg gg gg g gg gggg ggggggggg ggg gg g gggg ggggg g ggg g gggg gg gg g g ggg g ggg gg gg g g gggg gg ggg gg g gg g ggggg gg ggg ggggg ggg gggggggg ggg g g ggg gg gggg gggg gggggggggg gggg ggg g gg g g gg g g g ggggg gg gggg gggg gg ggg gg ggg g ggg gg gg gggg g g gg g ggggggg g ggggg gggg g g ggg gggggggggggggggggg ggg gg ggg gggg gg g ggg ggg gggg gggggggg gg gggg ggg gg g g g gggggg gg gggggggggggg gggg ggg ggg gg ggg g gg gg gggg gg g gg g ggggggggg g ggggggg g gg gg gggg ggg ggg ggggggg ggggg ggg gggg ggggggggg g g gg ggg gg g g ggg ggggg gg g ggg gggggggg g gg g gggg ggggg ggg gg gg g ggg gg gg gg g ggg gg g ggg ggg ggggg ggggg g g g ggggg gg g gg gg gg ggggggg gggg gggg gggggg g gggg gg g g ggg gggg gggggg ggg ggg gg ggg gg gg gggggg ggg gggg g g g gggggg gggg gg ggggg ggg gg ggggg ggggg gggggggg ggg ggg gg ggg gggggg g gg gggg gg g ggg g gggg gg gg ggg gg gggg gg gg g ggg ggg gggggg ggggg gg ggggggg gggggggg g gg gg g ggggggg gg ggg ggg ggggg ggg gg g gggg g gg ggg gggg ggggggg ggg gg gg ggg g ggggggggggggggggg g gg ggggggggg g gggggggggg ggg ggg ggggg gg ggggg gg ggggg g ggg ggg g gggg ggg g gg gggggg gggggg ggg gg g gg gggggg gg gg gggggg ggggggg gggg g gg gggg gg gggg g gg gggggggggggg g ggg gggg gg ggg ggg gg gg ggggggg gggggggggg gg ggg g ggg gg gg g g gggggg ggggg gggg ggg gggg ggggg gggg ggggg g ggg gggggggg ggg ggggg gggg gg gg gg ggg ggg g ggggggg ggg g gg ggggg gggggggg gggg ggg g gggggggg ggg gg g ggg gggg gggg gggggg g ggggg g gg gg gggggg ggggg g gg ggg ggg g g2.
.
.
med oe od pw ran b efficacy.
distributions of number of failures revealed by each technique per test.
gggg g gg gg g ggg gg med oeodpw c1 c2c3 c4c5 c6c7c8c9 c10c11 gggg gggg .
.
.
c efficiency x axis versus efficacy y axis .
fig.
.
failures in gcc version .
.
after one week of execution.
recall that this inherent limitation ofsplat motivated this work.
for random which samples configurations reachable from splat s execution we used a bound of configurations per test.
this number is twice the average number of configurations explored by pairwise which is the heuristic that explores more configurations amongst the basic heuristics we considered.
finding failures in the gcc version .
this experiment uses test failures to measure efficacy of the techniques.
these failures are not necessarily fault revealing they may be manifestations of undocumented preconditions in dejagnu tests which are still important to report .
we used the gcc release .
available since april in this experiment.
figures a and b show respectively efficiency and efficacy results.
figure c shows the relationship between these two metrics.
considering each dimension in separate results indicate that the heuristic pairwise found more failures than any other technique in absolute numbers however it was also one of the most expensive techniques only behind random .
more importantly the heuristics one enabled andone disabled found almost as many failures as pairwise but required much fewer configurations.
this observation indicates that pairwise performs relatively worse in gcc compared to spls.
one hypothesis for this is that the number of variables accessed in gcc was higher compared to spls.
the intuition is that pairwise is more sensible to that factor than other techniques.
figure 9shows a histogram of variables accessed per test in gcc.
indeed note that most of the tests in gcc often access more variables than the total number of variables in spls.
figure c relates efficiency and efficacy.
the arrangement of two groups of techniques in opposing corners of the plot is noticeable.
observe that although the range of the x axis is wide the range of the y axis is relatively narrow going from .
to .
failures detected per test.
conceptually it means that it is preferable to pick the best performing heuristics in the leftmost group as cost savings are high and failure loss is low.
within that group the combinations c1and c7 which builds onone enabled and one disabled reported more failures per test.
this observation is consistent with the results reported in figure 8and the results involving spls.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
frequency of variables accessednumber of tests fig.
.
frequency of variables accessed per test.
we obtained data by randomly sampling configurations over all tests.
a total of variables model the options considered in this study.
summary results show that one enabled and one disabled found the higher number of failures per test exploring a relatively low number of configurations.
finding crashes in the gcc version .
in this experiment we looked for crashes in the test suites gcc dg and dg torture .
considering the suite gcc dg most enabled disabled did not find crashes one enabled found two crashing configurations on different tests pr44545.c and pr47086.c one disabled found two crashes but on the same test pr47086.c and pairwise found multiple crashing configurations but on the same two tests that one enabled found crashes.
we filed one bug report1for all these cases given the similarity of the configurations and the similarity of the crash reports.
the gcc team confirmed and fixed the bug.
considering the suite dg torture only one enabled found a crash in one configuration and on a single test pr48953.c .
we also filed a bug report2to for this case the gcc team confirmed it was a bug that had been recently fixed and marked the report as duplicate.
finding crashes in the gcc version .
.
next we evaluated the techniques on bugs found in a study previously conducted by some of the authors of this paper on release .
.
of gcc .
the primary goal of this experiment is to evaluate the techniques in finding real known bugs3that splat was able to find when given a large time budget.
in this setup we used tests that we knew a priori would reveal crashes in specific configurations.
overall these crashes exposed five distinct bugs.
on a crash the gcc testing infrastructure reports an internal compiler error ice message followed by a specific error description which includes the statement that manifested the crash.
we used these messages to identify the crash as to avoid counting multiple times the same one.
considering efficiency we observed that the heuristic most enabled disabled was the most efficient followed byone enabled one disabled and pairwise .
the same pattern was observed in the experiment with gcc release .
see section v b1 .
considering efficacy at least one technique detected each bug with all five bugs detected.
furthermore all four basic techniques found the first and 3all bugs were confirmed by the gcc team show bug.cgi?id x where x 62141basic crash id technique med check check check check oe check check check od check check check pw check check check a distribution of crashes found.
g gg ggg g g gg g gg gg med oe od pwc1c2 c3c4 c5c6 c7 c8c9 c10c11 gg .
.
.
.
.
b number of samples x axis vs. number of bugs y axis .
fig.
.
crashes in gcc version .
.
.
second bugs both one enabled and pairwise found the third bug only most enabled disabled found the fourth bug and most enabled disabled and one disabled found the fifth bug.
figure a summarizes these results.
overall we observed that most enabled disabled found four of the five bugs and each other basic technique found three bugs.
we found surprising that most enabled disabled revealed more crashing while exploring few configurations per test.
in particular it was the only technique that found crash number four.
it is also worth noting that pairwise explored many more configurations but could only reveal three crashes.
figure b shows results relating number of bugs found and number of samples required to find those bugs.
similar to the plot from figure c techniques form clusters based on the number of configurations explored per test.
in addition the clusters are very similar across these two experiments.
this plot shows that most enabled disabled and c2are not dominated by any other technique filled circles indicate the pareto front .
we also observed that c2found all bugs with a relatively small number of samples.
finally analyzing configurations associated with each bug we observed that crashes were manifested with only few options enabled.
this can explain why one enabled and most enabled disabled performed well.
these results confirm previous observations that configuration related errors are often manifested in configurations involving a small number of input options .
summary results shows that all five bugs were captured by at least one basic heuristic and each heuristic captured at least three of the bugs.
considering combination techniques the combination of oeand medfound all bugs with a relatively small number of configurations.
c. handling constraints feature constraints add a new dimension to this study.
an error report manifested by a test on an invalid configuration is considered a false positive.
for space limitations we summarized here results we obtained validating constraints.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iprovides an indication of the complexity of the feature models of spls from the proportion of configurations which are valid per subject.
for those subjects we observed that most configurations selected without constraint validation are invalid reflecting the complexity of the models.
for example considering one disabled of the selected configurations are invalid and of failures are false positives.
despite these numbers we observed that techniques perform consistently with and without feature models results discussed in previous sections .
considering the crash scenarios of gcc we observed that all crashes found manifested in valid configurations indicating that the use of validation is not beneficial.
we used gcc constraints documented in a previous study we conducted .
considering the scenarios of failures of gcc we also observed that the techniques performed consistently with and without feature constraints.
d. threats to v alidity and limitations the main threats to validity are as follows.
external v alidity the selection of subjects we used may not generalize to other cases.
to mitigate this threat we used subjects from a variety of sources including a large configurable system with hundreds of options.
internal v alidity eventual errors in our implementation could invalidate results.
to mitigate this threat we thoroughly checked our implementation and our experimental results looking for discrepancies that would signal potential errors.
our datasets and implementations are publicly available .
one limitation of the study relates to the fact that splat currently only supports systems with dynamically bound feature variables e.g.
groupon web and gcc .
it remains to investigate how splat and s splat would perform on systems with ifdef variability.
e. discussion while combination c2was the only technique that found all crashes with a relatively low number of configurations it seems that the combination c7performs even better considering all the experiments we analyzed including those with spls.
this combination detected most failures and crashes through a relatively small number of configurations.
recall that this is the combination that includes all basic techniques but pairwise and random .
this confirms results obtained by medeiros et al.
showing the superior performance of this combination.
overall the results we obtained suggest that it is preferable to combine different simple heuristics instead of using one that entails a larger number of test requirements.
we remain to explore alternative heuristics not considered in this study.
however our initial results indicate that the hybrid search proposed by s splat is promising to reveal errors in potentially large configuration spaces.
in addition to the experiment documented above we run two other experiments whose results we summarize below.
we compared s splat toregular sampling and we evaluated s splat with random sampling using different sampling rates and in addition to the default rate of .
for the first experiment regular sampling detected the same bugs ass splat but it required more configurations.
recall that regular sampling techniques are black box they explore precomputed configurations regardless if they are reachable by test executions or not whereas s splat only explores configurations that both satisfy sampling heuristics and are reachable from tests.
in the second experiment we found that the results obtained are proportional to the change in the sampling rates of random .
additional results can be found on our website .
vi.
r elated work sound techniques.
sound techniques can be divided in two categories according to their execution mode.
multi execution approaches such as deltaexecution sharedexecution and varex execute a given test simultaneously against sets of configurations they leverage the similarities that exist across configurations to reduce the total number of paths explored in a test and the overall amount of computation.
one multi execution is typically more expensive than a regular execution but the overall execution compensates provided that enough similarity exist across each regular execution.
single execution approaches such as splat in contrast execute a test once for each reachable configuration that they discover while building a decision tree from configuration variables accessed during execution.
several aspects need to be taken into consideration for choosing one approach or the other.
for example a tension between engineering related limitations and computational cost exists between these approaches.
on the one hand building and maintaining such interpreters is challenging especially for statically typed languages .
implementations for dynamically typed languages exist but still suffer from important limitations e.g.
.
on the other hand single execution approaches can be expensive as they are unable to detect potential redundancies in computations across configurations.
this paper focused on the single execution technique splat but in principle sampling could also be combined with multi execution approaches.
sampling.
abal et al.
analyze the linux kernel software repository to study configuration related faults fixed by developers.
they manually analyze the characteristics of configuration related faults and suggest using the one disabled sampling algorithm to find bugs.
perrouin et al.
and marijan et al.
use the t wise sampling algorithm to cover all t configuration option combinations.
tartler et al.
propose the statement coverage sampling algorithm and applied a perfile analysis to detect bugs in the linux kernel.
however none of them perform a comparative study to understand the faultdetection capability and effort size of sample set of sampling algorithms different from our work using s splat .
liebig et al.
perform studies to detect the strengths and weaknesses of variability aware and sampling based analyses single configuration pair wise and code coverage .
they considered two analysis implementations type checking and liveness analysis and applied them to a number of subject systems such as busybox and the linux kernel.
the variability aware analysis outperforms most sampling heuristics with respect to analysis authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time while preserving completeness.
we do not evaluate runtime of our algorithms.
song et al.
propose interaction tree discovery algorithm itree to support the testing of highly configurable systems.
itree selects a subset of configurations in which the execution of the system s test suite will achieve high coverage.
they found that itree can identify high coverage sets of configurations more effectively than traditional combinatorial interaction testing or random sampling.
apel et al.
h a v e developed a model checking tool for c and java product lines.
they compare sample based and family based strategies with regard to verification performance and the ability to find defects.
they found that triple wise outperformed pairwise sampling and that the family based strategy outperformed all sampling based strategies in terms of detection efficiency.
later medeiros et al.
conducted an extensive comparative study of sampling algorithms variations of t wise statement coverage random one disabled one enabled and most enabled disabled regarding their fault detection ability and size of sample sets in the linux kernel apache and other real c program families.
they also analyzed combinations of these algorithms.
they found that in most cases most enabled disabled is the most efficient.
in our work we observed that considering spls one disabled and the combination heuristic c11offered the best balance between efficiency and effectiveness in most cases.
considering gcc most enabled disabled and the combinations of one enabled and one disabled e.g.
c7 offered the best balance.
static analysis.
kim et al.
previously developed a static analysis to determine which features are relevant to the outcome of a test.
conceptually it enables one to run a test only on all valid combinations that involve relevant configuration variables.
despite the positive results reported by kim et al.
caveat evaluation involved large subjects but tests cover only a small fraction of the code it is important to note that obtaining reachability information for these systems per test is challenging as i the analysis needs to re run for each test ii the analysis needs to run whenever the program changes and iii often tests are designed to statically reach the entire codebase e.g.
system tests i.e.
only the test input data can discriminate which parts of the code will be actually executed .
it is important to note that obtaining dynamic reachability information efficiently is the key feature of splat which built upon the ideas of kim et al.
.
note also that the use of static or dynamic reachability analysis is an orthogonal aspect of this work.
in the future we plan to empirically evaluate other methods to compute reachability information.
other .
recent empirical study found evidence that practical configuration complexity is often much lower compared to theoretical configuration complexity .
the intuition is that even if multiple variables are accessed in a given test configuration complexity may not be unacceptably high.
for example variables may not interact with each other or may interact according to specific patterns.
the observation of this phenomenon enables techniques that leverage the similarities across executions of a test to reduce dimensionality of the search space and test execution to scale.
the contribution ofvariability aware execution is orthogonal to ours it is possible to combine sampling even with variability aware execution sound by definition as to explore more exhaustively only certain parts of the decision tree.
hybrid concolic execution is a variant of concolic execution that aims to explore the state space more broadly and deeply compared to a regular concolic execution which conceptually can get stuck e.g.
as observed with saturation in coverage in dense branches of the symbolic tree.
the principle of seeking more uniform search has various manifestations in software testing it is motivated by the assumption that bugs are uniformly distributed in the state space.
note that the goal of hybrid concolic execution is test input data generation whereas our goal is configuration selection.
furthermore the heuristic component of their hybrid search only uses randomization as to make jumps during symbolic execution whereas we evaluated different sampling heuristics.
despite these difference both techniques approach the problem of searching a large search space by dropping guarantees of a systematic search for the sake of practicality.
vii.
c onclusion we presented s splat a technique for testing configurable systems that blends heuristic sampling and symbolic search to obtain both breadth and depth in the exploration of the configuration space.
s splat builds on splat our previously developed technique that explores all reachable configurations from tests.
results obtained on several subjects are encouraging.
for example s splat could find all the bugs that splat previously found on gcc release .
.
but faster.
furthermore it found new bugs in a newer release of gcc.
implementation and experimental infrastructure can be found on our website .
acknowledgment we would like to thank the anonymous reviewers and leopoldo teixeira who provided insightful comments on prior versions of this paper.
this material is based upon work partially supported by the cnpq and capes brazilian research agencies and by a microsoft seif award.