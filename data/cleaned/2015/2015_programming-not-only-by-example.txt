programming not only by example hila peleg technion hilap cs.technion.ac.ilsharon shoham tel aviv university sharon.shoham gmail.comeran y ahav technion yahave cs.technion.ac.il abstract recent years have seen great progress in automated synthesis techniques that can automatically generate code based on some intent expressed by the programmer but communicating this intent remains a major challenge.
when the expressed intent is coarse grained for example restriction on the expected type of an expression the synthesizer often produces a long list of results for the programmer to choose from shifting the heavy lifting to the user.
an alternative approach successfully used in end user synthesis is programming by example pbe where the user leverages examples to interactively and iteratively refine the intent.
however using only examples is not expressive enough for programmers who can observe the generated program and refine the intent by directly relating to parts of the generated program.
we present a novel approach to interacting with a synthesizer using a granular interaction model.
our approach employs a rich interaction model where i the synthesizer decorates a candidateprogram with debug information that assists in understanding theprogram and identifying good or bad parts and ii the user is al lowed to provide feedback not only on the expected output of a program but also on the program itself.
after identifying a program as partially correct or incorrect the user can also explicitly indicate the good or bad parts to allow the synthesizer to accept or discard parts of the program instead of discarding the program as a whole.
we show the value of our approach in a controlled user study.
our study shows that participants have a strong preference for granular feedback instead of examples and can provide granular feedback much faster.
introduction in a development ecosystem where programmers often carry out tasks involving unfamiliar apis and complex data transformations program synthesis is both a tool to shorten development times and an aid to small api programming tasks.
synthesis tools for end users are available for many purposes from creating formulae in microsoft excel to formulating sql queries .
tools for expert users who can encode full specifications have also matured enough to be practical .
expressing intent despite significant progress in synthesis expressing the user s intent remains a major challenge.
expert users can permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn .
.
.
.
full specifications and express their intent fully but end users and programmers trying to solve small tasks often use partial specifications.
partial specifications are available in different forms depending on the synthesizer source and target types input output pairs tests and logical specifications.
coarse grained models such as type driven synthesis present the user with all possible results that satisfy the coarse grained crite ria e.g.
.
this leads to a challenging task the user must compare a large number of similar programs to select a solution.
expressing intent with examples a very useful alternative for endusers is to use examples to express intent.
programming by example pbe is a form of program synthesis where the desired behavior is generalized from specific instances of behavior most often input output example pairs.
this allows an iterative process where if the synthesized program is not acceptable additional examples are provided until the target program is reached.
this technique is often used either on its own in synthesizers such as or as a way to refine the results of type driven synthesis .
insufficiency of examples for programmers pbe is geared towards end users but is also useful for more advanced users when the behavior is more difficult to describe than its effect.
however in this interaction model a user can only do one of two things accept the program after inspection or reject it with a differentiating example which will rule it out in the next iteration of synthesis.
but some synthesized programs are not all bad parts of them might be overfitted to the examples while other parts will be on the right track.
allowing only a full accept or full reject ignores the ability of a programmer to read and understand the program and to express a more directed granular feedback deeming parts of it as desirable or undesirable rather than the program as a whole.
in fact we hypothesize that in some cases it is easier for a programmer to explicitly indicate what is good or bad in a candidate program than to try to express this information implicitly throughinput output examples.
moreover we prove that it is sometimes impossible to express such information through examples.
programming not only by example motivated by the insufficiency of examples we present a new granular interaction model that allows a programmer to interact with the synthesizer not only by example but also by providing feedback on parts of the synthesized program.
our interaction model is granular in both directions from the programmer to the synthesizer and back synthesizer programmer a candidate program is presented together with debug information showing execution values at different program points.
this helps the programmer understand whether the candidate program behaves as expected at intermediate states instead of relying only on its final output.
programmer synthesizer a programmer can provide i inputoutput examples as in pbe and ii granular feedback on the candidate program by explicitly accepting rejecting parts of its code.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hila peleg sharon shoham and eran y ahav we tested the granular interaction model by a controlled userstudy with 32developers from both academia and industry.
to conduct this study we developed a synthesizer that interacts with the user in three different ways holistic pbe granular or both.
our synthesizer also measures interaction times and records the userinteraction for later analysis.
our implementation synthesizes functional programs in scala a popular functional and object oriented programming language used in many big data processing frameworks e.g.
spark akka .
functional compositions are considered the scala way to approach coding tasks and so we aim to synthesize them.
the same approach also applies to any language that uses functional compositions which are becoming a standard in modern languages.
notably such con structs are supported by java onwards and javascript onwards in js5 in the popular library lodash .
advantages of granular interaction the user study strongly supports the hypothesis that it is beneficial to let programmers communicate their understanding of the program explicitly to the synthesizer by marking parts of it as desirable or undesirable rather than implicitly through examples .
several participants in our user study faced with the inability to rule out an undesired operation in theprogram using only examples expressed extreme frustration.
we indeed show that this is more common than one would imagine due to the introduction of redundant or superfluous operations by thesynthesizer.
as a result an undesirable operation may be part of several candidate programs along the process but the holistic pbe model does not allow ruling it out.
we further show that our granular interaction model gim is easier to use as supported by i a strong preference of participants for granular feedback over examples and ii a significantly shorter iteration time when using granular feedback.
it is important to note that granular feedback does not completely replace examples.
participants who were restricted to granular feedback were sometimes forced to use a larger number of iterations and were more prone to error when accepting the program.
we therefore conclude that future synthesizers should integrate both interaction models.
main contributions the contributions of this paper are a synthesis framework with a granular interaction model gim that allows the programmer to approve or reject specific parts of the code of the candidate program rather thanjust respond to it as a whole and allows a synthesizer to present candidate programs with debug information.
a theoretical result showing that examples are sometimes insufficient for reaching the desired program.
we further show that real pbe sessions exhibit this problem.
a controlled user study showing that programmers strongly prefer granular feedback instead of examples and can provide granular feedback much faster.
outline in section we show why examples are not only inconvenient but insufficient to communicate the intent of the programmer.
to allow more expressive power we introduce three additional granular operations in section in addition to examples.
in section .
we also introduce debug information for every example provided by the user.
section details our experiments on the number of iterations necessary to solve a set of benchmarks with different interaction models.
we also present the result of a controlled usertask find the most frequent bigram in a string initial example abdfibfcfdebdfdebdihgfkjfdebd mapsto bd questionq11input .takeright problem takeright will just take the right of a given string idea the frequent bigram needs to be placed in the middle answer 1 cababc mapsto ab question q21input .drop .take problem this program crops a given input at a constant position idea vary the position of the frequent bigram between examples answer 2 bcaaab mapsto aa question q31input .zip input.tail .drop .map p p. 1.tostring p. 2 .min problem in all examples the output is the lexicographical minimum of all bigrams in the string e.g.
aa bc aa ca aa ab idea have a frequent bigram that is large in lexicographic order answer 3 xyzzzy mapsto zz table the difficulty of finding a differentiating example.
study of 32programmers from academia and industry that shows the benefits of our approach.
overview in this section we provide an overview of our granular interaction model gim for synthesis using a simple example.
we start by showing the interaction model of programming by example pbe and its shortcomings and then describe how gim overcomes these shortcomings by using a richer interaction model.
motivating example consider the task of writing a program that finds the most frequent character bigram in a string.
assume that the program is constructed by combining operations from a predefined set we refer to as the vocabulary v. for now assume that the vocabulary contains standard operations on strings characters and lists.
in addition assume that an initial partial specification is provided in the form of an input output example 0 abd fibfcfdebd fdebd ihgfkjfdebd mapsto bd .
in this example the bigram bd is the most frequent appears times and is thus the expected output of the synthesized program.
.
interaction with a classic pbe synthesizer table shows the interaction of a programmer with a pbe synthesizer to complete our task.
the synthesizer poses a question to the programmer a candidate program that is consistent with all examples.
the programmer provides an answer in the form of an accept or additional input output examples to refine the result.
based on the initial example the synthesizer offers the candidate programq1 which consists of a single method from the vocabulary takeright which returns the 2rightmost characters applied to the input.
the programmer then responds by providing the ex ample 1 which is inconsistent with the candidate program and therefore differentiates it from the target program.
at this point the synthesizer offers a new candidate program q2 which is consistent with both 0and 1. the interaction proceeds in a similar manner.
each additional example may reduce the number of candidate programs as they are authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
programming not only by example icse may june gothenburg sweden task find the most frequent bigram in a string initial abdfibfcfdebdfdebdihgfkjfdebd mapsto bd specifications question q11input abdfibfcfdebdfdebdihgfkjfdebd .takeright bd problem takeright will just take the right of a given string idea takeright will never be useful since we always want to consider every element.
remove takeright from the result program.
answer remove takeright question q21input abdfibfcfdebdfdebdihgfkjfdebd .drop bdfibfcfdebdfdebdihgfkjfdebd .take bd problem this program crops a given input at a constant position idea we don t want to crop anything out so these functions have no place in the result program.
answer remove drop .take question q31input abdfibfcfdebdfdebdihgfkjfdebd .zip input.tail list a b b d d f ... .take list a b b d .map p p. 1.tostring p. 2 list ab bd .max bd problem while the beginning of this program is actually good dividing the program into bigrams and so is the mapping of a tuple to a string take truncates the bigram list.
idea preserve what is good in the program and remove take on its own and not just as part of a sequence.
answeraffix zip input.tail remove take retain map p p. 1.tostring p. 2 table providing granular syntactic feedback.
required to satisfy all examples .
if the user chooses the examples carefully the process terminates after a total of 4examples.
finding differentiating examples may be hard consider the candidate program q3.
to make progress the user has to provide an example that differentiates q3from the behavior of the desired program.
to find a differentiating example the user must i understand the program q3and why it is wrong and ii provide input output examples that overrule q3 and preferably also similar programs.
by examining the code of q3 it is easy to see that min is a problem calculating a minimum should not be part of finding a most frequent bigram.
even after understanding the problem the programmer muststill find a differentiating example that rules out q3.
because the min inq3takes the lexicographical minimum from a list of the bigrams in the input the programmer comes up with an example where the desired bigram is the largest one as in 3. in this interaction the programmer had to express the explicit knowledge do not use min implicitly through examples.
coming up with examples that avoid min requires deep understanding of the program which is then only leveraged implicitly through examples .
even then there is no guarantee min will not recur as we will show in section it cannot be removed completely in this model.
in this case since the programmer already knows that programs using min should be avoided this information is best communicated this information explicitly to the synthesizer.
.
interaction through a granular interaction model gim improves pbe by employing a richer granular interaction model.
on the one hand the synthesizer supplements the candidate programs by debug information that assists the programmer in understanding the programs and identifying their good and bad parts.on the other hand the user is not restricted to providing semantic input output examples but can also mark parts of the program code itself as parts that must or must not appear in any future candidate program.
this allows the user to provide explicit syntactic feedback on the program code which is more expressive and in some cases allows the synthesizer to more aggressively prune the search space.
the gim interaction for the same task of finding the most frequent bigram is demonstrated in table .
question is as before the synthesizer produces the candidate program input.takeright .
in contrast to classic pbe the granular interaction model provides additional debug information to the user showing intermediate values of the program on the examples.
this is shown as comments next to the lines of the synthesized program.
for q1 this is just the input and output values of the initial example.
in the next steps this information will be far more valuable.
givenq1 the programmer responds by providing granular feedback.
using gim it is possible to narrow the space of programs using syntactic operations.
presented with input.takeright the user can exclude a sequence of operations from the vocabulary in this instance takeright ruling out any program where takeright appears.
this also significantly reduces the space of candidate programs considered by the synthesizer.
the synthesizer responds with q2.
note that in such cases the debug information assists the programmer in understanding the program determining whether it is correct or as in this case identifying why it is incorrect.
to rule out q2 the user rules out the sequence drop .take as the debug information shows the effect take the second and third character of the string and the user deems it undesirable at any point in the computation to truncate the string as all characters should be considered.
the synthesizer responds with q3.
this candidate program contains something the programmer would like to preserve the debug information shows that the prefix input.zip input.tail creates all bigrams in the string.
the user can mark this prefix to affix or to make sure all candidate programs displayed from now on begin with this prefix.
this removes all programs that start with any other function inv effectively slicing the size of the search space by v .
another option multiple operations stemming from the same program are not only allowed but encouraged is to exclude take since the resulting truncation of the list is undesirable.
eventually the synthesizer produces the following program 1input abdfibfcfdebdfdebdihgfkjfdebd .zip input.tail list a b b d d f f i i b b f ... .map p p. 1.tostring p. 2 list ab bd df fi ib ... .groupby x x map bf list bf ib list ib ... .map kv kv.
1 kv.
2.length map bf ib gf ... .maxby .
2 bd .
1 bd which does not discard any bigram counts the number of occurrences and retrieves the maximum.
this program is accepted.
below we summarize the key aspects of gim as demonstrated by the above example.
key aspects granular feedback the programmer can provide feedback keep discard on parts of the program in addition to inputoutput examples.
the ability to give explicit feedback on the code itself provides an alternative and complementary authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hila peleg sharon shoham and eran y ahav way to interact with the system without crafting potentially complicated differentiating examples.
assisting the user with debug information the synthesizer provides debug information on intermediate states of the program in order to assist the user.
candidate programs are supplemented with debug information that helps the programmer understand the good and bad parts of a candidate program.
insufficiency of examples examples are both inconvenient and insufficient to communicate a programmer s intent.
other operations are needed to allow a programmer to filter programs not only according to semantic equivalence but also according to additional criteria such as readability best practices and performance.
background in this work we address synthesis of functional programs.
below we provide the necessary background.
notation of functions we interchangeably use the mathematical notationh f x for the functional composition called on object xand the scala notation x.f.
.h in scala a function application with no arguments does not require parentheses .
for a functional program m we denote dblbracketleftm dblbracketrightas the function that the program computes.
formally dblbracketleftm dblbracketright d d maps every elementiin the domain d either to the element in dthat the program outputs on i or to an error compilation or runtime nelementd.
v ocabulary and the candidate program space the candidate program space consists of programs of the form input.f .....fn .fn in scala notation or fn fn ...f1 input ... in mathematical notation where each fiis a method from a predefined vocabulary v. object methods that accept arguments are handled by partially applying them with predefined arguments such as constants lambda functions or variables in the context leaving only the self reference as an argument.
generally the candidate program space includesevery program in v but we notice that for some programs there are compilation errors as not all f v are applicable to all objects.
programming by example pbe programming by example is a sub class of program synthesis where all communication with the synthesizer is via examples.
the classic pbe problem is defined as apair e l of initial examples eand target language l where each example ineis a pair i o of inputi dand expected output o d. the result of the pbe problem e l is a program m which is a valid program inlthat satisfies every example in e i.e.
dblbracketleftm dblbracketright i o for every i o e .
since there might be more than one program min the languagelthat matches all specifications the iterative pbe problem was introduced.
in the iterative model each candidate programmiis presented to the user who may then accept miand terminate the run or answer the synthesizer with additional examples eithat direct it in continuing the search.
the insufficiency of examples in this section we show the importance of extending the user s answer model beyond input output examples.
we examine more formally the scenario described in section .
where the user has seen an undesirable program component and would like to exclude it specifically.
we will show that this is not always possible i.e.
that examples are insufficient to communicate the user s intent.as seen in section .
the user wishes to rule out the function min but simply providing an example to rule out the current program might not be enough to remove min from allcandidates to ensure it never recurs.
we now formally prove it is impossible to completely remove methods like min from the search space using examples.
we recall the definition of equivalence between programs.
programsm1andm2are equivalent if dblbracketleftm1 dblbracketright dblbracketleftm2 dblbracketright.
we use this to prove the following claim claim .letv v be a letter such that there exists a program mthat is equivalent to m and contains v. then examples alone cannot rule out the letter v v from candidate programs.
the proof follows since examples can only distinguish between programs that compute different functions.
next we show that claim is applicable to methods that are prevalent in programming languages and extremely useful in some contexts and therefore are likely to find their way into the vocabular ies used in synthesis.
we consider two classes of methods invertible methods and nullipotent methods.
invertible methods are methods with an inverse that when applied in sequence lead back to the initial input.
for instance reverse on a list is invertible and its own inverse as in.reverse.reverse will be identical to in.
an invertible method can always be added to the target program along with its inverse resulting in an equivalent program.
hence it will never be ruled out by examples.
nullipotent methods are methods that when applied lead to the same result as not being applied.
while this is often context sensitive e.g.
calling tolist on a list or mkstring on a string there are calls that will always be nullipotent such as takewhile true .
because some methods are nullipotent only in a certain context they may be in a synthesizer s vocabulary and end up in the program space in contexts where they are nullipotent.
it is easy to construct a program that contains nullipotent methods and is equivalent tothe target program.
hence similarly to invertible methods these methods cannot be eliminated by examples.
furthermore since many existing pbe synthesizers prune very aggressively based on observational equivalence or equivalence based only on the given examples programs that do not include the undesired component may not be available anymore as they have been removed from the space.
these properties leave us with the need to define a more expressive granular model.
the practical implications of claim are discussed in section .
which examines the existence of method sequences deemed undesirable by users in candidate programs.
the data as well as opinions collected from users show that the inability to remove an undesirable letter from the alphabet has real world consequences which add to the user s frustration with the synthesizer see table .
the granular interaction model in this section we describe the granular interaction model gim which extends the pbe model with additional predicates.
namely predicates in gim include examples but also additional predicates.
the key idea is to add a broader form of feedback from the user to the synthesizer than has been available in pbe.
we begin bydescribing the operations and the type of feedback that each such authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
programming not only by example icse may june gothenburg sweden predicate allows the user to provide the synthesizer with and discuss the observed uses of each.
.
granular predicates in the setting of functional compositions we present gim with three syntactic predicates.
we refer to these predicates as granular since they impose constraints on parts of the program rather than on its full behavior as captured by the function it computes or its input and output types.
we will also discuss other possible predicates.
given a candidate program m fn fn ...input... we introduce the following predicates to be tested against other programs m prime f primem f prime m ...input... remove fi ... fj wherei j will hold only for programs m primewhere k.f prime k fi f prime k i j fj retain fi ... fj wherei j will hold only for programs m primewhere k.f prime k fi f prime k i j fj affix f0 ... fi will hold only for programs m primewhere j i.fj f prime j. the remove operation rules out a sequence of one or more method calls as undesirable.
for the example in section to rule out min the user would simply add the predicate remove min .
however should the user rule out a sequence longer than a single method this would apply to the sequence as a whole using the predicate remove reverse reverse does not exclude the reverse method only two consecutive invocations of it that cancel out.
the retain operation defines a sequence that must appear in the target program.
it is similarly defined for sequences when applied to a single method it forces the method and when applied to a sequence it forces the sequence in order.
it can be viewed as creating a procedure and then deeming it as desirable.
however since retain is not dependent on the location of the procedure in the program we add an additional predicate for not only setting a procedure but forcing its location to the beginning of the program.
the affix predicate will essentially narrow the search space to sub programs that come after the desired prefix.
additional predicates as these three operations are highly expressive and easy to understand we have focused our experiments on them but they are by no means the only possible predicates.
many other granular operations exist.
for instance the user can reasonabout intermediate states of the program by demanding or exclud ing certain intermediate states for a given input.
a user can also require an error or an error of a certain kind for a given input.
section .
will expand on the reasons to select certain expansions to the interaction model over others.
.
adding a debugging view of the code gim assumes an interaction with users who are comfortable reading code.
this means not only that more can be expected from them but that they can be assisted in ways currently not offered by synthesizers.
just as the interaction from the user to the synthesizer can be granulated so can the interaction from the synthesizer to the user.
pbe tools like flashfill only show the user the output of running the program on an input.
other tools that do show code show the program while guaranteeing that it satisfies all examples in e.i na functional concatenation it is possible to show the user the result of each subprogram on each e e .
this means that even for some figure program with debug information a sequence selected for removal unfamiliar f v the user can still gauge its effect and determine by example whether that effect is desired.
example .let us consider the case where input is a list of strings and the user is presented with the candidate program input.sliding .map l l.mkstring .
while familiar with themkstring method which formats a list into a string and with mapping a list the user has never encountered sliding .
the user could look up the method and read up on its behavior .
however oftentimes its behavior will be simple enough to understand by its operation within the program.
consider for example the following intermediate program states 1input list aa bb cc dd ee .sliding list list aa bb cc list bb cc dd ... .map s s.mkstring list aabbcc bbccdd ccddee provided with these states the user can understand that sliding returns a list of sublists of length nbeginning at each position in the list a sliding window of size n. .
enabling the user having introduced the formal framework for predicates we now wish to leverage it to create a user interaction model.
we suggest the following iterative process which we have implemented for the user study in section .
.
a candidate program is displayed to the user alongside the debug information.
the top image in fig.
shows this in our ui.
the user is now able to study the program and accept or reject it.
the goal is to allow a user who is dissatisfied with the program to directly express the source of dissatisfaction as easily as possible using predicates.
towards this end we let the user point out a portion of the program e.g.
by right clicking it and mark it as desirable or undesirable as seen in the bottom image in fig.
.
this process of easily providing feedback on the program turns predicates into a convenient tool for feedback to the synthesizer.
.
enabling the synthesizer as we have seen the choice of predicates is crucial from the user s perspective.
however it is also important for the synthesizer to be able to use them in maintaining and updating a representation of the search space.
to complete this section we show how the predicates described in section .
are naturally utilized by a synthesizer for the domain of linear functional concatenations.
enumerating synthesizer the state of the art in program synthesis hinges on enumerating the program space in a bottom up fashion .
for the domain considered in this paper bottom up enumeration consists of concatenating method calls to prefixes already enumerated starting with the program of length input .
this authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hila peleg sharon shoham and eran y ahav enumeration is restricted by types i.e.
by compilation.
the search space in this synthesizer can be represented as an edge labeled tree where the root is the program input and each edge is labeled by a method name from v. each finite length path in the tree represents the program that is the concatenation of every label along the path.
the tree is initially pruned by compilation errors i.e.
if f v does not exist for the return type of m it will be pruned from the children of the node representing m .
it now represents the candidate program space for an unconstrained synthesizer state.
we can see that every program deemed undesirable by the operations affix and remove cannot be extended into a desirable program.
therefore these extensions can be discarded and the tree representing the candidate space can be pruned at the nodes of these programs.
this is an example of predicates that are well suited to the representation of the state of the synthesizer in that they not only aid the user but also help guide the search of the space.
since the combination of the enumeration and these predicates is monotone a program that was pruned from the search space will never have tobe considered in a future more constrained iteration.
this meansthat the synthesizer does not need to be restarted across iterations.however even if it is these predicates will allow it to construct a much smaller search space to begin with.
evaluation to evaluate our approach we compared three interaction models pbe replicating the state of the art in synthesis the user can communicate with the synthesizer via input output pairs.
syntax testing the new operation set proposed in section the user can communicate with the synthesizer via syntactic predicates on the program.
gim testing the full model the user can communicate via both sets of predicates.
we limited the test of the granular interaction model to three operations that are relevant to functional compositions and are easyto understand.
therefore we selected the operations detailed in section .
as our basic set of granular operations.
we conducted two studies a study of ideal sessions with different operations i.e.
families of predicates for a set of benchmarks.
a controlled user study which tests the usability of a gim synthesizer for programmers and the benefits when measured against a control group using pbe.
synthesizer we implemented a simple enumerating synthesizer described in section .
in scala using the nsc interpreter used to implement the scala repl .
the vocabulary vis provided to the algorithm and programs are compiled and evaluated on the inputs.
in order to support the study in section .
the synthesizer accepts input of additional examples rejection of the current program or of affix remove and retain predicates.
in order to support the user study in section .
it also precomputes the space of valid programs.
.
problem set we conducted the studies using a set of functional programming exercises from three different domains strings lists and streams.
the exercises were collected from scala tutorial sites and examples for using mapreduce.
the tasks described in tab.
were each paired with a vocabulary and an initial set of examples.discussion as seen in tab.
the set of valid programs is significantly smaller than v m but in many cases the space still contains thousands or tens of thousands of programs.
there is also a fair amount of inherent ambiguity over the initial example set einit a s can be seen in the reject only column representing the set of all programs up to length m that matcheinit .
this means that even when limiting the search space to the known length of the target program we would start with hundreds or thousands of matching programs that need to be filtered by the user.
.
ideal synthesis sessions experimental questions for each task in the problem set we answered the following under the ideal conditions of an expert user and knowledge of the target program how many questions i.e.
candidate programs are posed to the user for each predicate family?
test setup in order to answer these questions each task in the problem set was run in four settings reject only no operations except rejecting the current program.
this essentially enumerates programs that match the initial example set.
pbe syntax and gim as described above all with the addition of a reject operation.
examples and other predicates were selected by an expert user author of this paper making an effort to create a run with fewer iterations and more aggressive pruning of the space in each iteration.
results tab.
shows the results for each of the programming tasks.
as can be seen from the table in ideal i.e.
thoroughly optimized expert user runs the number of questions produced by the synthesizer for a pbe run was lowest.
this was not unexpected carefully selected examples are a fast way to differentiate between programs.
examples selected in less ideal conditions are left to the follow ing section.
but we also see that in a run allowing all predicates substantially fewer questions were asked than when using syntactic predicates only with no more than one example.
the synthesizer and its outputs are available at org hilap scala enumerating synthesizer .
.
user study to test the interaction between programmer and synthesizer we conducted a user study where we compared the interaction of programmers with the synthesizer using the three families of operations pbe control syntax and gim.
research questions we examined the following questions are answers consisting of syntactic predicates easier or faster to generate than example predicates?
this question was examined first by comparing for each task the average and median iteration times with the synthesizer for the control group pbe and the syntax group.
second when users were allowed both gim the time spent on iterations where they provided examples was measured against their average time.
is the total time to solution improved by adding or exchanging the available predicates?
are users able to reach a correct program using each of the predicate sets?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
programming not only by example icse may june gothenburg sweden number of candidates candidate reject benchmark v e init m space size only pbe syntax gimstringsdropnthletter drop every 5th letter in a string freqbigram most frequent bigram in a string frequword most frequent word in a string linesinfile number of lines in file nonemptylines number of non empty lines in file listsanagrams group words that are anagrams histogram create a histogram of number list median find the median of a list of numbers posinlist get all positive numbers from list sudokusquare v alidate a square in sudoku sumsquares sum of squares of a list of numbers streamsbitstream next integer from a stream of bits numhashtags count hashtags in a stream of tweets slidingavg average next three values from every index table the test setup of 14synthesis experiments showing the ambiguity inherent in einit and the number of iterations to the target program in an ideal synthesis session with each available set of operations.
parentheses indicate examples used.
do users prefer examples?
this question examined the choices made by the participants in the gim group who could choose between all predicates.
we tested how often examples were chosen and whether the task being solved affected this preference.
are users in pbe sessions distracted by undesirable sequences that cannot be removed?
we tested pbe sessions for recurrence of sequences deemed undesirable by users in the syntax and gim groups to try to determine whether these recurred enough to distract users.
we also checked for acceptance of equivalent programs with superfluous elements as mentioned in claim .
anecdotal opinions offered by participants are also presented.
most questions were examined on all participants.
we show data for the small set of users experienced in scala against those new to scala when the difference is of interest.
test setup 32developers participated in the study.
they consist of undergraduates in their final year of a cs degree 9graduate students in cs most with a history as developers outside academia and industry developers employed by four different companies.
of the 8had prior experience with the scala programming language.
the participants in the study were evenly distributed between three test groups pbe syntax and gim.
each participant was randomly assigned to one of the test groups.
not all participants performed all tasks scheduling constraints were cited for the most part .
the order of the tasks was randomized for each user.
the reject operation was not allowed in any group forcing users to provide the process with new information as they would in any state of the art synthesizer rather than just iterate the program space.
each participant was asked to use the synthesizer to solve three programming questions.
the three problems frequword nonemptylines and histogram were selected from the tasks tested in section .
because of their high level of ambiguity based on the initial example and their requiring no additional libraries or definitions outside the scala standard library to solve i.e.
the programs could be run in a scala console with no imports or definitions .
participants were given a short introduction to scala if they were not already familiar with it and assisted themselves with a scala repl but no online sources or documentation.
correctness of a participant s solution was defined functionally using predetermined tests and including no nullipotent calls these were equivalent .
there might be several correct programs in the space e.g.
when counting non blank lines solutions allowing for crlf line ends were accepted as long as they correctly handled lf.iteration number of correct no.
of time sec iterations target equiv.
task group sessions avg med avg med finished answer answer histogrampbe .
.
.
.
syntax .
.
.
.
gim .
.
.
.
no.
lines with textpbe .
.
.
.
syntax .
.
.
.
gim .
.
.
.
most frequent wordpbe .
.
.
.
syntax .
.
.
.
gim .
.
.
.
table summary of the three tasks performed in the user study all users .
implementation participants performed the tasks using the ui shown in figure .
the space of programs was precomputed by the enumerating synthesizer from section .
and over the same initial inputs up to a program length of .
in each iteration a program that upholds all predicates given by the user was selected from the set of programs.
selection used a hash based criterion to prevent lexicographical ordering and favoring of short programs in order to also show the user complex programs.
at the end of every iteration the user s answers were added to the synthesizer s state and the programs are filtered accordingly.
if the precomputed set was exhausted the user was given the option of starting over or abandoning the current task.
.
user study results we address each question individually.
question are answers consisting of syntactic predicates easier or faster to generate than example predicates?
the average and median times per iteration are shown in table .
medians are also shown in fig.
.
we examined the distributions of data using the mann whitney test.
the threshold for statistical significance was chosen as p .
.
a significant difference was found in the time per iteration between the control pbe group and the syntax only group for all tests histogram .97s .97s p .
nonemptylines .17s .56s p .
and frequword .27s .34s p .
.
a significant difference was found between the control group and the gim group for two of the three tests histogram .97s .18s p .
nonemptylines .17s .
s p .
but not for frequword .27s .84s p .
.
additionally a significant difference was found between the syntax only group and the gim group for one test histogram .97s .18s p .
but not for nonemptylines .56s .78s p .
or frequword .34s .84s p .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hila peleg sharon shoham and eran y ahav sessions no.
of used percent examples per user task sessions examples avg med min max all usershistogram .
.
.
.
nonemptylines .
.
.
.
frequword .
.
.
.
users histogram .
.
.
.
familiar nonemptylines .
.
.
.
with scala frequword .
.
.
.
users histogram .
.
.
.
unfamiliar nonemptylines .
.
.
.
with scala frequword .
.
.
.
table proportional part of examples in the predicates provided by gim group users.
some used no examples at all none used only examples.
these results imply that with the exception of the frequword test for the gim group iteration time is faster when using either syntax only or both syntax and example predicates than when solving the same problem using pbe alone.
additionally with the exception of the histogram task the slowdown in iteration time between syntaxonly and gim seems to be coincidental.
in addition we looked only at the session for users in the gim group and within each session examined the time to create an example against the average iteration time.
there is a slowdown of .
in iteration time with an example and we see that this difference is statistically significant .03s .11s p .
.
we can therefore answer question in the affirmative on both counts syntactic predicates are faster to generate than examples both when examining the test groups against the pbe group and when examining the users with access to both against themselves.
question is the total time to solution improved by adding or exchanging the available predicates?
we noticed a change in the median total time between the control pbe and the other groups syntax and gim indicating a possible slowdown.
however this change was not statistically significant for any of the individual tests or for the unification of all tests p .25for all .
therefore while we do not answer question in the affirmative as the total time was not improved in either of the test groups we can also say that the evidence of a slowdown may be coincidental.
question are users able to reach a correct program using each of the predicate sets?
the correctness results in table are visualized in fig.
.
aside from the histogram task completed by all users all other tasks had some users stopping without accepting a program.
the success percentage in reaching any functionally correct response is highest for pbe lowest for syntax and rebounds with gim t ol e v e l s close to the control even overtaking it for the nonemptylines task.
question do users prefer examples?
a summary of how often users chose examples appears in table and fig.
.
we can see a distinction between users familiar with scala and users who are not.
while users familiar with scala used examples in every task users unfamiliar with scala did not in every task at least one user and as many as 3of the users avoided them altogether.
the proportional part of examples out of the total predicates used in the task is fairly low for the entire test group ranging from to37.
median .
we compared users familiar and unfamiliar with scala and found that the preference for examples is inverse between the two groups users familiar with scala selected far more examples all over examples for the histogram task and preferred other predicates forpbe gim syntax times seen distracting users saw in session occurrences users removed sequence and removed min max average distractednum of linestail .
.
.
takewhile c c !
n .
.
.
filternot c c r c n .
.
.
filter !
.isempty .
.
.
tail.takewhile c c !
n .
.
.
most frequent wordtakeright .
.
drop .
.
drop .
.
.
takeright .
.
.
dropright .
.
.
take .
.
.
last .
.
drop .drop .
.
takeright .takeright .
.
histogramtomap .
.
map .
1 .
.
zipwithindex .
.
map .
1.toint .
.
table frequently removed method sequences in the syntax and gim groups and their occurrence in the pbe group.
the frequword task.
conversely those unfamiliar with scala preferred examples but not as overwhelmingly half the participantsusing over examples for frequword and favored other predicates half the participants using under examples for histogram.
this seems to suggest a relationship with the difficulty of the task histogram is harder to solve than frequword.
despite this even when examples were favored they were never the only tool used.
question are users in pbe sessions distracted by undesirable sequences that cannot be removed?
we first identified such sequences by counting how many users who could remove them i.e.
had access to a remove predicate actually did so then tested sessions of users from the pbe group for their appearance.
table shows the results.
it is important to note that not all commonly removed sequences appeared in pbe sessions itself an indicator of the extent to which syntax operations change the traversal of the search space.
these undesirable sequences appeared up to 7times in a single user session.
some of these sequences distracted i.e.
kept reappearing up to 3of the users performing a task and on average .
of the users.
furthermore a distracting sequence appeared on average about 3times in each session.
this shows that the inability to remove a letter or sequence discussed in claim is neither a purely theoretical problem nor a problem leading only to equivalent rather than correct programs as seen in table but a real distraction from the ability to synthesize over an expressive vocabulary.
figure also shows that in two of the tasks histogram and nonemptylines most or all pbe users ended up accepting a program with superfluous elements.
for example in many histogramsessions a program was accepted with a call of tomap on a map and in many nonemptylines sessions a program was accepted thatcalled filternot c c r c n on a list of strings.
both are nullipotent elements tomap creates a map from a map and filternot c c r c n compares strings to characters and so always filters nothing.
in addition when pbe users stopped at an equivalent program rather than the target program we tested the number of iterationsspent in the same equivalence class i.e.
presented with the same candidate program before accepting the program.
while most users accepted equivalent programs immediately one user performing the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
programming not only by example icse may june gothenburg sweden figure median iteration time per task in each test group.
significant change from pbe is indicated by .
figure examples used med min max by gim users all operations .
none used examples.
figure no.
users that reached the target program or an equivalent nonfunctional differences result.
histogram task tried an additional iteration and one user tried two additional iterations.
for nonemptylines two users tried an additional iteration and one tried two additional iteration.
altogether in of the sessions users tried unsuccessfully to improve upon the program they already had either trying to get rid of a nullipotent element or not realizing it has no influence before finally accepting it.
we chose not to tackle the questions of user preference and measures of distraction with a questionnaire sticking instead only to empirical results.
despite that we wish to recount several anecdotes from the course of the experiment that may help shed light on the behavior observed.
users in the pbe test group expressed very specific frustration on several occasions such as it insists on using take no matter what i do while solving the frequword task or i couldn t get rid of these nonsense functions i just wanted to shake it after solving the nonemptylines task.
the user study ui and recorded user sessions are available at .
discussion and conclusions in this section we discuss the results of the study.speed and ease of use we see a speedup of iteration time when using examples versus other predicates.
the change is greatest between the pbe and syntax groups with a smaller speedup when examining the gim group against itself.
we may attribute this difference between the two tests to the fact that the users in the gim group resort toexamples only when examples are convenient or readily apparent and therefore take less time to create.
we conclude that when combined with a low preference for examples syntax predicates are easier for the user in general.
in addition considering the shorter iteration time the increased number of iterations itself statistically significant and the lack of significance in the change in total time we conclude that changing the predicates does not change time spent on synthesis tasks.
it simply leads to using more but shorter and easier iterations.
distracting elements and user frustration much of the frustration users in the pbe group expressed had to do with recurring pro gram elements they thought were useless.
recurring undesirablesequences were experienced by up to two thirds of the users andrecurred on average 3times during the session certainly explains their frustration.
in addition some pbe users wasted time and effort trying to remove elements that cannot be removed.
we thereforeconclude that avoiding this distraction by giving users more tools would at the very least make for more content users.
helpfulness of debug information we attribute the success rate and relatively short use times of a set of developers who have never seen scala to the guidance offered by debug information.
we did not target this specifically in the experiment but 9separate users told us that it was anywhere from helpful to lifesaving in understanding unfamiliar methods and keeping track of examples.
correctness with syntax operations the syntax group reached fewer functionally correct programs than the pbe group and the gim group did almost as well as the pbe group.
we attribute this to the helpfulness of debug information it seems to be easier to make a correct decision about a program when presented with its breakdown over additional examples rather than just the single initial example available to the syntax group.
preferred operations when considering all users in the gim group there appears to be a very strong preference for syntactic predicates over examples for all tasks.
however for a sub group preferences may be reversed users familiar with scala preferred more examples than those unfamiliar with scala and preferred examples over other predicates in the harder task histogram and predicates overexamples in the easier task frequword.
this may have to do withtheir ability to better understand candidate programs savvier programmers read the programs more easily and so prefer to break the observed behavior with examples while inexperienced programmers focus on individual program elements.
this remains a conjecture as there were only 2users familiar with scala in the gim group.
threats to validity cross validation the study was not cross validated i.e.
having each user perform tasks in several groups .
because the predicatefamilies include each other we felt it would create a bias toward some operations based on order.
as cross validation should not be used when it creates bias we decided against it.
we tried to negate some of the differences between individual programmers by drawing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hila peleg sharon shoham and eran y ahav participants from similar backgrounds same year in university developers in the same department and then dividing them evenly.
sampling of population an external validity issue mentioned in section .
is the relatively small percentage of participants familiar with scala only of the participants in the study and as small as in some groups due to random assignment.
as mentioned this prevents us from making general claims about differences between programmers based on their familiarity with scala.
however we can still generalize our claims with regard to programmers working in a language they have not encountered before the majority of the participants.
in addition our sample of undergraduates is not random but consists of students who felt familiar enough with functional programming to agree to participate.
this may skew the ability togeneralize.
we hope this will not significantly affect the compiled results as undergraduates comprise less than of the participants.
related work syntax based synthesis is the domain of program synthesis where the target program is derived from a target programming language according to the syntax rules.
all fall within this scope.
the implementation of gim presented in this paper is syntax based where the target language is a functional subset of scala as specified by v. syntax based synthesis algorithms often use a user driven interaction model which gim extends.
programming by example in pbe the interaction between user and synthesizer is restricted to examples both in initial specifications and any refinement.
flashfill is a pbe tool for automating transformations on an excel data set and is included in microsoftexcel.
it does not show its users the program only its application on the data set.
because the resulting program is never inspected it might still suffer from overfitting to the examples and is not reusable.
escher is a pbe tool for synthesizing recursive functions.
like flashfill escher decomposes the task based on the examples searching for programs that could be used as sub programs in condition blocks.
escher is parameterized by the operations used in synthesis and like flashfill allows refinement only by re running the process.
type directed synthesis is a category of synthesis algorithms that perform syntax based synthesis mainly driven by the types of variables and methods and the construction of the program is performed through type derivation rules.
while type directed methods tend to be user driven many of them require only initial specifications and the user manually chooses from multiple candidate programs that match the specification.
the philosophy behind gim is that a user should not consider many programs there could be dozens or more at a time with no additional data.
rather programs should be considered one at a time with additional information that can help the user consider the program in depth and direct the search.
adding examples to type directed synthesis recent work connects pbe with type driven synthesis .
these tools accept examples and their inherent type information as initial specifications use type derivations to produce candidates and verify them with the examples.
big synthesizes mapreduce processes via sketching and type derivations over lambda calculus and a vocabulary.
examples are also used to verify determinism.
sypet is a typedirected component based synthesis algorithm that uses petri netsto represent type relationships and finds possible programs by reach ability.
candidates are tested using tests provided by the user.
sypet requires full test cases rather than examples which while moredescriptive still require the user to learn a lot about the library in order to program the test case an effort that may be equal to learning about the methods required to solve the programming task at hand.
sketching the user can restrict the search space via sketches structural elements e.g.
conditions or loops which includes holes to be synthesized.
sketching is a way to leverage a programmer s knowledge of expected syntactic elements and when usedin conjunction with restrictions on the syntax can allow very intricate synthesis.
however since the most general sketch a pro gram with only a single hole is usually too unconstrained for the synthesizer the user must come armed with at least some knowledge of the expected structure rather than iteratively build it as in gim.
enriching user input several existing works have enriched the specification language or the interface for specifying program behavior.
adding examples to type directed synthesis is an example of such enrichment.
another approach by polikarpova et al.
with synquid is to use refinement types instead of types which encode constraints on the solution program which can be imposed on the candidatespace.
while these constraints are mainly semantic unlike gim ssyntactic predicates this embodies the same ideal of passing offsome responsibility to a user who can understand code or in this case write code.
likewise barman et al.
suggest an interactive user dependent extension of sketching intended to synthesize the sketch itself by leveraging the user to decompose the specifications and examine the results.
angelic programming leverages programmer knowledge by an expanded interface from synthesizer to user the user is shown a synthesized program with a nondeterministic angelic operation and execution traces for that operation to make the program correct and it is their responsibility to identify the necessary operation to replace the angelic operator.
conclusion we presented a novel granular interaction model gim for interacting with a synthesizer.
this interaction model extends common pbe approaches and enables a programmer to communicate more effectively with the synthesizer.
we prove that using only examples is insufficient for eliminating certain undesired operations in a program where these undesiredoperations are easy to eliminate when using syntactic operations made available by gim.
we further show the effectiveness of gim by a controlled user study that compares gim to standard pbe.
our study shows thatparticipants have strong preference of the time for granular feedback instead of examples and are able to provide granular feedback up to times faster and .
times faster on average .