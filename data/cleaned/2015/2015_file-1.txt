supporting selective undo in a code editor youngseok yoon institute for software research carnegie mellon university pittsburgh pa usa youngseok cs.cmu.edu brad a. myers human computer interaction institute carnegie mellon university pittsburgh pa usa bam cs.cmu.edu abstract programmers often need to revert some code to an earlier state or restor e a block of code that was deleted a while ago.
however support for this backtracking in modern programming environments is limited.
many of the backtrac king tasks can be accomplished by having a selective undo feature in code editors but this has major challenges there can be conflicts among edit operations and it is difficult to provide usable interfaces for selective undo.
in this paper we present azurite an eclipse plug in that allows programmers to selectively undo fine grained code changes made in the code editor.
with azurite programmers can easily perform backtracking tasks even when the desired code is not in the undo stack or a version cont rol system.
azurite also provides novel user interfaces specifically designed for selective undo which were iteratively improved through user feedback gathered from actual users in a preliminary field trial .
a formal lab study showed that programmers can successfully use azurite and were twice as fast as when limited to conventional features .
index terms selective undo backtracking i. introduction since programmer s are human they often make mistakes while writing program code.
in other cases programmer s may intentionally make temporary changes to the code either as an experiment or to help with debugging.
as a consequence programmer s often need to backtrack while coding.
we define backtracking as going back at least partially to an earlier state eithe r by removing inserted code or by restoring removed code .
previously we conducted a lab stud y a survey of backtracking practices of programmer s and a longitudinal study of hours of actual code editor use from programmers .
the results confirmed that backtracking is in fact prevalent and programmers often report having problems when they want to backtrack .
the programmers in the longitudinal study backtracked .
times per hour on average and of all the detected backtracking instances were performed manually without using the undo comman d or any other tool support .
others have also shown that programmer s frequently backtrack while coding.
from a high level view programmers often do exploratory programming they build quick prototypes see how they work and then backtrack and refine the program and the requirements .
also backtrac king becomes important in a situation where alternative solutions need to be managed for a given task.
several variation management tools have been developed but these are limited in that users cannot easily backtrack and add a new alternative from there if they did not plan ahead where they would need new alternatives.
however backtracking support is limited in modern interactive development environments ides .
the restricted linear undo model which is used in most text and code editors is not suitable for all situations.
the most significant problem is that users can only undo the most recent edits.
this can be very inconvenient wh en users realize that they made a mistake after making some other changes that they want to retain.
in addition programmer s may intentionally make changes to the code that they later want to remove.
another option is to use a version control system vcs such as subversion or git to revert some code to a previous version.
however this approach relies on the assumption that the desired code is already committed to the vcs which may not always be the case.
these problems can be resolved by having a select ive undo feature in code editors.
users could select specific edit operations performed in the past and invoke the selective undo command to revert only the code affected by the those operations.
our study showed that .
of all the backtrack ings performed by the participants were selective meaning that they could not have been handled by the conventional undo command .
selective undo has been well researched in the area of graphical editors .
however this technique has not been used with text or code editors due to the many text specific challenges which we address here .
first as berlage pointed out existing selective undo mechanisms are designed to work best when the system has identifiable objects that are affected by operations but text does not have the notion of objects but rather has a stream of characters .
second there can be many regional conflicts among the fig.
.
the interactive selective undo dialog of azurite .
the user can mark some code in the left panel and ask to keep th is code unchanged .
this can be repeated until the preview in the right panel matches what is desired.
edit operations.
a regional conflict can occur when the region of a later edit overlaps the region of the earlier edit which the user wants to selectively undo .
when there is a regional conflict among the edit operations the result of a selective undo may not be well defined.
to illustrate this point consider the following example.
an edit operation e1 changes the code from myfontsize to myrectangle size and sometime later another operation e2 changes it to myregionarea .
this is an example of regional conflict because the affected ranges of the two operations are overlap ping and the rectangle text inserted by e1 is only partially available in the current code.
in this case it is not clear what the result of selectively un operation e1 alone should be.
the system should be able to detect such cases and provide an appropriate approach to resolving them .
a final challenge of providing selective undo for code is that it is difficult to provide intuitive user interfaces for the user to find what to selective undo.
many existing selective undo user interfaces for graphics present a list of edit operations performed in the past along with human readable descriptions of individual operations .
however text editing operations are much more fine grained than graphical editing so it is hard for the users to interpret the high level edit intent just by looking at the indivi dual text edits.
in addition graphical applications can use a thumbnail to represent a snapshot of the graphics at a certain point of time which makes it easier to present the edit history to the user .
in contrast a thumbnail of a piece of a large text file does not give much information to the users.
to resolve these problems and complement the existing tools we devised a novel selective undo mechanism and applied it to the code editor .
the system takes fine grained code edits as input and maintains the mapping between the different segments of the current source file and the edit operations that introduced those segments.
the system also keeps track of regional conflict relat ionships among edit operations section iii .
the system then uses this information to provide selective undo in code editors section iv .
our tool is called azurite1 and is an eclipse plug in that provides a new algorithm and new user interfaces for selective undo.
we previously published an overview of the initial user interfaces of azurite but the curren t paper is the first to present the selective undo mechanism capable of handling regional conflicts and many new user interface features for selective undo based on user feedback from a preliminary field trial with t he version described in the previous pa per section v .
we also present here the performance feasibility analysis section vi and our new formal user study which shows that azurite is effective and usable section vii .
we discuss the design space of selective undo tools and their trade offs and future work directions section viii .
then we discuss the related work section ix and conclude the paper section x .
azurite is a blue mineral and here stands for adding zest to un and restoring improves textual exploration.
the plug in is available open source for general use at .
ii.
motivating example imagine a scenario where a programmer working on a graphical user interface gui in java swing wants to implement a simple panel with three vertically arranged buttons as shown in fig.
.
there should be a fixed amount of padding inside the entire panel and between the buttons.
first she starts out with having a stub method that returns an empty panel.
she then makes the following changes in order.
.
she creates three button objects and adds them to the panel see fig.
3a .
.
running the application shows horizontally laid out buttons so she looks for some layout manager to use.
she tries gridbaglayout .
.
the in termediate code seems too complicated for just a simple vertical layout.
she looks for a simpler layout manager and discovers boxlayout .
she uses undo command multiple times to get rid of all the gridbaglayout code backtracking to fig.
3a .
.
she writes some code with boxlayout resulting in much simpler code and vertically laid out buttons fig.
3c .
.
she changes some properties of the buttons such as the background color and button text .
she now tries to polish the layout and add some spacing between the buttons before moving further.
however she realizes that boxlayout does not support spacing while gridbaglayout does.
therefore she wants to restore the gridbaglayo ut code she wrote in step while keeping the changes from step .
at this point the undo command cannot be used because she had previously used the undo command to remove the gridbaglayout code and then she made some new changes from there so the neede d operations have been eliminated from the undo stack.
even if she had not used the undo command in step the undo command would still be inappropriate for this situation because it will necessarily revert the changes made in step which is not desire d. moreover it would be very unlikely that the gridbaglayout code had been committed to a version control system because the code was still an intermediate state.
the only option she now has is to reproduc e the gridbaglayout code from scratch which is i nefficient.
it would be much more convenient for her if there was at least a semi automatic way of restoring the desired code from fig.
3b while keeping the subsequent desired edits from fig.
3d.
to addre ss these problems we developed a tool called azurite which allows programmer s to selectively undo finegrained code changes made in the code editor.
in th is example the programmer with azurite can restore the deleted gridbaglayout code without losing the changes related to buttonorange with the following steps .
find the point in time in the past where the text gridbaglayout existed in the createbuttons method using azurite s history search.
fig.
.
a sketch of the desired ui .
select all the edit operations within the createbutt ons method per formed since the point found in step .
.
launch the interactive selective undo dialog fig.
.
then from the left panel indicate the parts of the current code that should be kept unchanged.
.
after checking the prev iew of the selective undo result shown in the right panel press the ok button to actually perform the selective undo.
azurite provides a rich set of user interfaces designed to help users complete various backtracking tasks.
the list of steps described ab ove is just one example and there are several different ways to achieve the same result using azurite as will be described below.
users can use azurite in the way that they feel the most comfortable.
iii.
edit history management in this section we explain th e technical details of the edit history management algorithm used for selective undo.
a. definitions in text editing there exist only a few types of primitive edit operations.
here the following three operations are considered as primitive insert delete and replace .
by primitive operation we mean that these operations are the basic undoable units in the system.
a replace operation is a primitive operation even though it can be considered as a delete followed by an insert with the same offset because a r eplace operation should be undoable as an atomic unit.
all of the higher level editing commands that change the text such as find and replace and cut and paste result in one or more of these primitive operations.
note that t he history records every opera tion that happens and new operations are always added to the end of the history.
in particular regular undo commands and our selective undo commands are also included in the history using these primitives.
for example the undo of a delete operation is added to the end of the history as an insert operation .
however it is not enough to simply keep the edit history to provide the selective undo feature.
when performing undo on some past operations the system must be able to determine which locations in the current state correspond to the locations where the operations were originally performed .
this is not trivial because the offsets change whenever some text is inserted or removed above the location in the file of the past edit .
this problem has been iden tified by others e.g.
and arises from the requirement that code be stored as plaintext without embedded meta information like bookmarks .
thus before a selective undo can be per formed offsets of previous operations in the file may need to be adjusted dynamically.
we will refer to these adjusted offsets as dynamic offsets .
the idea of dynamic offsets here is similar to the notion of dynamic pointers introduced by abowd and dix in the collaborative editing context .
our approach differs in that we keep track of dynamic segments instead of pointers.
we introduced our dynamic segment management technique at an abstract level in our previous paper but here we provide full technical details.
a dynamic segment is defined as a tuple k o r where the value of k is either ins or del o is the dynamic offset of this segment is the deleted or inserted text and r is a relative offset value can be nil which will be explained in section iii.d .
there are two types of dynamic segments insert segments k ins and delete segments k del a replace will use both .
let be the set of all possible primitive edit operations.
an edit operation e can then be defined as a tuple t d i where t is the time the operation was performed d is the delete segment associated with the edit operation can be nil and i is the set of insert segments can be nil .
each dynamic segment is always associated with an edit operation.
the segment information is updated whenever a new operation is added to the history.
i is a set rather than a single insert segment because an insert segme nt can be split by some later performed operation as will be explained below in section iii.c .
finally the edit history is then defined as a chronological history list of edit operations h e1e2...en where n is the number of all edit operations performed so far and en is the last newest edit operation.
b. regional conflicts of edit operations a selective undo operation may not be well defined when there are regional conflicts among the edit operations.
recal l the example from section i where a replace operation e1 changes the code from myfontsize to myrectanglesize and at some time later another operation e2 changes it to myregionarea .
what shoul d be the re private jpanel createbuttons jpanel p new jpanel jbutton button1 new jbutton button jbutton button2 new jbutton button jbutton button3 new jbutton button p.add button1 p.add button2 p.add button3 return p a private jpanel createbuttons jpanel p new jpanel p.setlayout new gridbaglayout gridbagconstraints c new gridbagconstraints ... omitted multiple lines of code ... omitted for configuring c. jbutton button1 new jbutton button jbutton button2 new jbutton button jbutton button3 new jbutton button p.add button1 c p.add button2 p.add button3 return p b private jpanel createbuttons jpanel p new jpanel p.setlayout new boxlayout p boxlayout.
y axis jbutton button1 new jbutton button jbutton button2 new jbutton button jbutton button3 new jbutton button p.add button1 p.add button2 p.add button3 return p c private jpanel createbuttons jpanel p new jpanel p.setlayout new boxlayout p boxlayout.
y axis jbutton button orange new jbutton orange buttonorange.setbac kground color.
orange jbutton button2 new jbutton button jbutton button3 new jbutton button p.add button orange p.add button2 p.add button3 return p d fig.
.
the code changes for the motiva ting example.
the green highlight shows newly inserted lines and the blue highlight shows updates to the existing code.
the omitted code is partially shown in fig.
.
sult of selectively un operation e1 alone?
there are multiple options a1 selectively undo e1 while leaving in the parts changed by e2 resulting in myfontgionarea a2 also undo the conflicting operation e2 and revert the code to the way it was before operation e1 was performed resulting in myfontsize a3 tell the user that there is a regional conflict and do not allow the selective undo so the code stays as myregionarea unfortunately since it is not ent irely clear what the user wants it would not be appropriate for the system to choose arbitrarily without user intervention.
throughout the paper we will use the notation ei ej to represent a regional conflict where the edit region of ej tj dj ij overlaps with the region of ei ti di ii at least partially and ti tj.
for example e1 e2 holds in the example above.
note that these two operations need not necessarily be consecutive in time and there may be arbitrarily many edit operations in between.
as the arrow between the two operations implies a regional conflict is always one directional the arrow starts from some earlier performed operation and points to a later performed operation .
for convenience when there is ei ej conflict we will call ei the conflictee and ej the conflictor .
c. types of regional conflicts regional conflict detection happens at the segment level.
since there are only two types of dynamic segments insert and delete we get a total of four combinations of possible regional conflicts fig.
4a d .
insert insert conflict this occurs when the second insertion is performed somewhere in the middle of an existing insert segment .
when the user tries to selectively undo the first insert operation it is not clear whether the user really wants to remove only the text inserted by the first operation or to remove them both together.
when an inse rt insert conflict is created that is when the user performs the conflictor edit our algorithm splits the conflictee s insert segment into two pieces.
insert delete conflict an insert delete conflict occurs when the dele tion range overlaps at least partially with an existing insert segment which can happen in four different ways .
fortunately there is no ambiguity when the user wants to selectively undo the conflictee all the remaining text that came from th at insert operation should be removed.
delete delete conflict a delete delete conflict occurs when the second deletion range encloses the first deletion range .
similar to the insert insert case when the us er tries to selectively undo the first delete operation it is not clear if the user really wants to restore only the text deleted by the first deletion or restore the whole text deleted by both operations.
delete insert conflict as shown in fig.
4d there can never be a delete insert conflict because the range of deletion becomes a single point and insert operations also only happen at a single point and two points cannot conflict.
d. segme nt closing reopening when managing the dynamic segment information a na ve implementation may lose some of the required information for selective undo.
suppose that there was originally xyz in the code at offset and two delete operations ea and eb are performed whose delete segments are da del oa a ra and db del ob b rb respectively.
first ea deletes y in the middle resulting in oa .
next eb deletes xz which results in ob and a delete delete conflict.
in addition oa is adjusted to so that selectively un just ea would put y at the correct offset.
what would happen if we undo both ea and eb at this point?
since undo has to be performed backwards to avoid messing up dynamic segments while performing the selective undo eb would be undone first and xz would be put back at offset .
next ea would be undone and it would put back y at offset which is the current value of oa.
the resulting code would look like yxz instead of xyz which is clearly not what the user wanted.
this happens because the dynamic segment for the conflictee ea loses the offset information relative to the conflict or ea s offset when a delete delete conflict occurs.
to solve this problem we need to store this relative offset and restore the offset when the conflictor is undone.
we call these two processes segment closing and segment reope ning which work as follows close ra oa ob reopen oa ob ra ra nil in the previous example closing da will store oa ob into ra right before oa is adjusted to .
when un db da will be reopened which will restore the offset oa to ob ra and make ra be nil.
once a segment is closed r nil then its r value is never updated unless the segment is reopened.
the same applies to insert delete conflicts.
e. time complexity of edit history management each new operation can add at most dynamic segments delete segment insert segment and up to more segments fig.
4b3 if it happens to spli t an existing insert segment.
since the system iterates through all the segments in the history and fig.
.
types of regional conflicts illustrated performs constant time update work for each segment whenever a new edit is performed the worst case time complexity of updat ing the entire history is o n where n is the total number of edit operations in the current history h this potential performance issue is discuss ed in section vi.b .
iv.
selective undo mechanism provided that the system has all the dynamic segments inform ation for the entire history it can perform any selective undo.
the user selects some edit operations see section v and invokes the selective undo command.
our selective undo is performed in two phases determining code chu nks and performing selective undo for each chunk .
a. phase determining code chunks unlike the conventional undo our selective undo allows the user to select multiple operations to be undone together.
since there is no guarantee that all the selected ope rations were performed at the same place the selective undo mechanism must first find the different code chunks affected by the selected operations.
a code chunk consists of one or more operations and their dynamic segments which constitute a continuous area in code.
we use three rules to determine the code chunks all the segments associated with a same operation must be added to the same chunk all the segments located between two segments in a same chunk must also be added to that chunk all abutting chunks are merged into a single chunk.
b. phase selective undo for each chunk once the chunks are determined selective undo is performed for each chunk independently.
for convenience this is done from the bottommost chunk within the file so a s not to affect the dynamic offsets of the segments of the other chunks while performing selective undo.
selective undo is performed in two different ways depending on the existence of regional conflicts outside of the chunk which is defined as follow ing rcexists ei ej such that ei ej ei ej where is the set of all edit operations and is the set of all the selected operations in the chunk.
the point is that regional conflict s can be automatically resolved if the conflictor is also selected ej while user intervention is required when the conflictor is not selected ej .
if rcexists false in this case selective undo can always be performed without user intervention by applying the inverse changes of all the operations involved in this chunk working backwards from the most recent operation to the oldest one.
the inverse changes should be applied to each dynamic segment when there are multiple segments associated with an operation.
when applying the inverse change of a delete segment all the segments closed by this segment should be reopened see section iii.d .
if rcexists true when there are conflicts the users should be provided with the different alternatives of possible resulting code so that they can choose one of them or cancel the selective undo .
using the font size example from section iii.b all three alternatives a1 a2 and a3 should be provided to the user.
a3 is simply the same code as it is so the system only need s to calculate a1 and a2.
a1 is obtained by selectively un the conflictees while leaving in the parts changed by the conflictors.
it turns out that a1 can be obtained by applying the same algorithm for conflict free chunks used when rcexists false without extra work.
in order to get a the chunk needs to be expand ed to include i ts conflicting operations.
however there might be other operations conflicting with the ones just included in the chunk.
for instance in our example there could be another later operation e3 which changes the code from myregionarea to myregionbreadth which conflicts with operation e2 but not with e1.
currently azurite includes all of these transitive conflictors to get the expanded chunk2.
once the expanded chunk is obtained a2 is calculated by applying the selective undo a lgorithm as for non conflicting chunks.
v. user interface design the selective undo algorithm described in sections iii iv requires that the user select the correct set of edit operations to be undo ne.
however from the user s point of view this can be a difficult task when the history gets bigger.
there needs to be intuitive ways for users to express what they want to revert and or what they want to get as the result of the selective undo.
a. initial design we first summarize the initial user interfaces of azurite designed to work with our selective undo mechanism presented earlier to provide enough contex t to understand our new user interfaces.
the timeline visualization lets users see and interact with the edit history fig.
5a shows the updated version of the timeline .
the horizontal axis represents time and the edit history of each file is shown in a corresponding row.
each edit opera2 in edge cases such as if the user replace s an entire file with an older version azurite extracts the diffs between the two versions and log s the diffs as separate operations to minimize the potential future regional conflicts.
fig.
.
the updated timeline visualization a and the code history diff view b of azurite .
the code corresponding to the selected rectangles yellow outlined in the timeline are highlighted in the editor by the box es c the small icons on the left ruler d and the markers on the scrollbar on the right side e .
the colors of the boxes match the rectangle colors in the timeline.
tion is represented as a rectangle which are color coded according to the type of edit inserts are green deletes are red and replacements are blue.
the user can click or drag to select one or more rectangles .
once some of the operations are selected the user can invoke a popup context menu containing various commands including selective undo .
the code history diff view fig.
5b is a code compare view with two panel s. users can select an arbitrary region of code from the regular code editor and launch this view to see how the selected region has evolved over time or to revert the code to an earlier version .
users can drag the orange vertical marker in the timeline back and forth to move between different versions of the code snippet while this view is open.
to leverage the observation that programmers remember some characteristics of the code that they want to backtrack azurite provides a history search feature where users can search back wards through time not through the current code meaning that even deleted code can be found.
all of t hese search results are also highlighted in the timeline and the user can further investigate the selection or invoke selective undo.
b. field trial with the initial design after implementing the initial user interfaces section v.a we conducted a field trial by deploying azurite to the students in masters of software engineering program at carnegie mellon.
we asked them to tr y using azurite while working on their studio projects in summer .
we then interviewed two of the active users to get more detailed feedback.
they both described that it was difficult to determine what the resulting code would look like just by lookin g at the selected rectangles.
for this reason one of them used the code history diff view instead because it worked as a preview of the selective undo result for him.
he mentioned that he use d the code history diff view instead of using the regular und o command because it was convenient to see a preview before un he also mentioned that he often wanted to keep some comments and selectively undo only the nearby code because for him the comments were usually the high level description of a certain a lgorithm and only the code may be wrong.
both users wanted a feature to tag a point in time in the timeline.
the following subsections present the new user interfaces which address these concerns.
c. regional undo shortcut we have found that the most popula r form of selective undo is reverting a specific region of code to an old version which has been referred to as regional undo .
in the current version of azurite users can select some region in the regular code editor and use a keyboard shortcut ctrl r by defau lt r on a mac one or more times to perform selective undo on that region directly within the code editor.
d. improvements to the timeline view we made some significant improvements to the timeline visualization see fig.
5a .
one of the common ways of backtracking is to go back to a certain point in the past when a specific event happened.
as beck says in his book it would be great if the programming environment helped me with this working as a checkpoint for the code every time all of the tests run .
to support this azurite detects significant coding events and displays them in the timeline view.
currently the displayed events include running junit tests that pass or fail running the application under development saving files and version control system related commands such as commit .
an event is displayed on the timel ine as a vertical line with an icon representing that event at the bottom .
further event types can be trivially added in the future.
users can also tag the current or any previous point in time which was one of t he most requested features from the field trial.
a tag also shows an icon fig.
at which can be name d shown on mouse hover or stay anonymous.
users can left click on any icon to move the orange marker to that point to see how the code looked then.
right clicking any of the icons shows a context menu providing useful commands such as undo all files to this point which can be viewed as a lightweight automatic versioning feature.
another requested addition is that w hen one or more rectangles are selected in the timeline the corresponding area s of code are highlighted in the code editor fig.
5c e .
this mitigates the users reported problem that it can be difficult to mentally associate the rectangles with the code.
e. interactive selective undo we created another new user interface called the interactive selective undo dialog in response to feedback from the field trial .
the design was inspired by eclipse s refactoring wizard which shows a preview of all changes to be made before actually changing the code.
similar to a typical refactoring wizard our interactive selective undo dialog shows a side byside diff view where the left panel shows the current co de and the right panel shows the preview of the selective undo based on the currently selected rectangles in the timeline.
on the top panel is the list of all the affected files.
the interactive selective undo dialog is modeless and the rectangles can be added to and or removed from the selection while the dialog is open which immediately update s the preview result shown in the dialog.
by allowing this users need not worry about selecting the exact set of rectangles on their fig.
.
the interactive selective undo dialog when there is a chunk with regional conflicts.
the user can choose one of the provided options to resolve regional conflicts.
here the second option fontsize is chosen by the user.
first attempt.
users can mani pulate the selection until the preview shows the desired result.
this dialog is also capable of dealing with regional conflicts.
when there is a chunk which contains regional conflicts the dialog shows a red x icon beside the chunk and the ok button is disabled temporarily .
once the user selects the chunk from the top panel the dialog shows the three alternative options described in section iii.b so that users can choose which one they want .
once an option is chosen the chunk is marked as resolved with a green check icon fig.
and the ok button becomes enabled when the user resolves all existing regional conflicts .
note that in most use cases of azurite regional conflicts will not come up since rectangles will be selected with the aid of azurite features such as history search and the code history diff view.
the conflict resolution interface is provided for the sake of soundness.
additionally users can select an arbitrary region of the code in the left panel right click to bring up the context menu and select keep this code unchanged .
this searches for all operations affect ing that selected region of code and exclude s those operations from what will be undone .
this feature provides a significant usability improvement compared to requiring users to select the exact set of operations because users can easily get the desired results by roughly over specifying the selected operations and then marki ng all the code fragments desired to be in the resulting code.
vi.
performance feasibility a. size of the logs azurite uses the fine grained code change history generated by fluorite which is a recording plug in that captures all of the low level editor commands and edit operations.
fluorite keeps the history as log files and azurite uses the log files when the user wants to bring an old history back into the timeline.
the total size of fluorite log data from programmer s contain ing hours of active coding activities collected for our previous study was 377mb which gives a log size growth rate of about .5kb hr during active editing .
given the spacious hard drives used nowadays we believe this will not be a critical issue for most user s. moreover the same study discovered that of the backtracking instances are performed within editing sessions implying that purging old editing histories would be safe enough in most cases.
b. edit history management performance as described in section iii.e the edit history management algorithm gets slower as the history gets bigger because its time complexity is o n where n is the number of all operations in the current history.
we measured3 the actual time it takes to add a new operation which would usually contain one or more tokens not just a single character to the history under varying size s of n and it took .93ms when n and .58ms when n .
according to the log data we collected operations is approximate one week of coding work avg.
of edits .
hour .
this shows that the edit history management algorithm even un optimized will work in measured on a pc running windows with a .60ghz cpu.
practice without causing significant delay.
future work includes optimiz ing the edit history s scalability for example by using a tree based data structure with relative offsets.
vii.
user study we conducted a small controlled study to evaluate the usability and usefulness of azurite after implementing all the new user interfaces described in sections v.c e. we used a between subjects design with two groups azurite and eclipse only as the control .
all the tasks were performed using the eclipse .
ide on a macbook pro machine running os x .
.
the study took about .
to hours for each participant.
a. participants we recruited programmers at carnegie mellon males and females median age who were randomly assigned to either group .
all participants reported that they ha d at least years of programming experience in general median yrs and at least years of java experience median yrs .
no one had pre viously seen or used azurite before the study .
b. tasks there were a total of java programming tasks performed in the same order for all participants table i .
a separate code base was provided for each task.
for tasks through each task was composed of a series of steps a number of normal non backtracking programming steps described in table i followed by a backtracking step which is always the last step to rever t the changes made in the underlined step while keeping the changes from the other steps .
this was because we wanted to have the participants create the edit history themselves and wanted to use backtracking situations that are not trivial to perform using regular undo.
for example for t1 participants were asked to revert the factorial method back to the for loop version after finishing step .
for task the participants were provided with an existing code edit history and then perform ed backtracking from there.
this allowed us to test if users can effectively perform selective backtrack ing when the code changes are scattered in multiple files and locations without needing to require the users to spend time creating a long and complex edit history.
beca use it would be impossible to gather backtracking timing data if the participant becomes stuck in one of the nonbacktracking steps we set up a minute limit for each step and the experimenter helped the participant after the time limit.
no help was pro vided for the backtracking steps from which the reported results are measured .
c. study procedure after obtaining the informed consent and demographic information for both groups we alternated between one tutorial session and two programming tasks resulting in a total of tutorial sessions and tasks.
the tasks were designed in a way that they can be effectively performed by using the feature they learned from the previous tutorial session but the participants were told that they were free to use any stra tegies.
in the tutorial sessions the azurite group learned how to use the regional undo shortcut section v.c the undo all files to this point feature from the timeline view section v.d and the interactive selective undo dialog section v.e .
the control group learned about the local history feature of eclipse which is a built in feature that keeps a per file local history of every saved version of the source cod e and is the closest existing feature that can help with the tasks .
in the three tutorial sessions this group learned how to manually perform selective undo using the local history how to replace the entire source code with one of the saved revisions and how to perform selective undo in multiple files.
all participants in both groups were familiar with and were able to use the regular linear undo as well.
after each tutorial the participants were given a written document explaining the feature they learned during the tutorial with screenshots so that they could refer to it later.
d. results all the participants in both groups successfully completed all the backtracking steps so we compared the completion time of the backtracking step of each task.
an independent samples t test was conducted to compare the backtracking completion time between the two groups.
over all tasks the azurite group took significantly less time mean .
s to perform all the backtracking steps than the control group mean .8s p .
which is roughly twice as fast .
fig.
shows the average backtracking completion time for the individual tasks for the participants in each group .
for tasks and the azurite group was significantly faster compared to the control group p .
.
for t1 the azurite group was faster but this was not statistically significant p .
mainly because one participant in the azurite group mistyped the shortcut key twice so he started over and took much longer 173s .
t3 t4 were non selective backtracking tasks meaning that they could have been performed with multiple invocations of the regular undo command .
one participant in the contr ol group in fact used the regular undo command instead of using the local history feature.
still the azurite group was generally faster because they could quickly skim through the timeline to find the last successful unit test run and then undo all files to that point with a single command.
there was one participant in the azurite group who did not use azurite for t3 and took 167s reproducing the code manually which heavily affected the mean value and made the average time difference statistically non significant p .
for t3 .
the azurite group did not perform better for t5 p .
and the completion time varied much more sd .
than the control group sd .
.
this task was meant to be completed using the interactive selective undo dialog but the participants had to also manually edit the resulting code after using the dialog due to the difference between the two layout managers they were using.
two participants quickly realized th is and roughly performed selective undo with the dialog and man ually edited the resulting code.
one participant used the regional undo instead.
the other participants tried to complete the backtracking using only the interactive selective undo dialog which resulted in much longer time because the current interactive selective undo dialog does not support manual editing within the dialog itself.
on the other hand the compare view of the eclipse local history supports manual editing and resulting code can be manually edit ed within the compare view.
so this is a fe ature we will add to azurite in the future.
t6 was also meant to be completed with the interactive selective undo dialog but in this case everything could be done solely with the dialog and thus the azurite group dramatically outperform ed the control gro up mean .
s v. .
s p .
.
after finishing all the tasks we asked whether the tool they used was useful for them with a point likert scale.
a wilcoxon rank sum test showed that azurite was more useful median than the eclipse local history median .
p .
.
e. limitations in order to focus on whether the tool helps in various backtracking situations we provided specific steps of tasks without the surrounding exploratory programming context .
to prevent the tasks from being too artificial we designed the tasks based on actual backtracking situations observed from previous studies .
in addition at the end of the study we gave a point likert question asking if the given scenarios were plausible in that similar situations come up when they are programming.
out of participants agreed or strongly agreed but the other two participants did not median .
another limitation is that the control group was not trained to use any vcs such as git.
this was primarily because the step by step nature of the task table i. summary of tasks task individual steps sel mf t1 implement factorial method with a loop modify factorial method to use recursion make a few more independent changes t2 delete some existing sorting code make a few more independent changes t3 implement a simple number class unit tests given modify number to be an immutable class t4 implement a stack with inheritance unit tests given modify stack to use composition instead t5 layout gui controls using gridlayout change the layout manager to gridba glayout add another gui control t6 remove all the debugging specific code e.g.
println in multiple places while keeping the actual bug fix code.
an edit history is provided to begin with.
sel selective backtracking cannot be done with re gular undo mf multi ple files are involved task t5 is similar to the motivating example of section ii.
fig.
.
the average backtracking completion time for each task.
the error bars indicate the standard deviations.
differences are statistically significant.
instruction s could bias the behavior of the participants towards commit ing a version after each step even when they do not usually make such small frequent commits in their real environments .
carefully c omparing azurite and vcss on the backtracking tasks remain s as future work.
the participants were all recruited from the local university not from industry.
however g iven that our previous study found that programmers backtrack frequently and out of participants had previous industry experience we believe that azurite would be useful in real environments as well.
viii.
discussion and future work a. linear vs. tree graph based history we intentionally chose to use a linear history model instead of a tree or graph model as used in us r or git .
in our history model all the code changes including the undo commands themselves are added to the end of the timeline for two reasons .
first although several text editors and plug ins have provide d tree structured visualization s that allow users to move among different nodes it is difficult to understand the tree as the history gets bigger.
this is because the nodes do not provide useful information for the user to navigate the tree which is why we believe these have not caught on in popularity .
in contrast the linear history model and timeline visualization of azurite would match programmers episodic memory and have been shown to be understandable in our studies.
second it is not trivial to represent a selective undo operation in a tree structured history.
un like the regular undo selectively un some changes does not result in one of the previously visited nodes in the history tree.
rather it creates a new node that has never existed before.
also a graph based history as provided in git would be inappro priate because a selective undo operation is not used for merging.
b. granularity of edit operations having different approaches for merging dividing edit operations might affect the usability of a selective undo tool.
on the one hand i f each character level edit is logged individually the tool could be less usable because all of the individual operations would have to be tediously identified and selected character by character.
to mitigate this problem azurite combines consecutive typing performed within seconds configurable similar to the way typical text code editors do.
on the other hand if the operations are too coarse grained then there would be many more regional conflicts among the operations .
this would also give less control to the users which was a real problem observed during the pilot for the user st udy.
based on our observation that users want ed to control the undo range at least at the line level we decided to prevent a single operation from spanning across multiple lines.
for exampl e when the user types multiple lines or paste s a large block azurite divides the operation into multiple insert operations each having one line of code.
this approach worked very well during the actual user study.
c. using textual vs. structural changes as input while there are development tools which use the abstract syntax tree ast level changes of the code as input azurite uses the textual code changes instead .
there are trade offs between these two choices.
on the one hand b y using textual changes as input the mechanism becomes language agno stic as is the conventional undo command and most commercially available merge tools .
besides there are certain types of edits that cannot be captured at the ast level such as reformatting code or changing a comment se ction.
by using the textual input our system can capture and undo these types of changes as well.
on the other hand by using ast level changes the selective undo mechanism could use the additional information and better handle semantic conflicts .
a sema ntic conflict can occur when a set of edit operations are semantically related to each other in the code.
for example when a method is renamed its definition and all the call sites must change together.
s electively un only one of these rename operat ions would not cause any regional conflicts because the changes were all made in totally different locations.
however this would result in inconsistent code containing compile errors and thus could be considered to result in semantic conflicts.
since thes e edits are likely to have been performed close together in time users may be able to easily select them together in the timeline.
however if not w e believe the compile errors would catch these kinds of problems and users would be able to perform the re maining backtracking steps to complete what they wanted to achieve.
we observed this situation occurring during the user study especially in the backtracking step of t5.
in order to keep the added gui control correctly the users had to keep both the memb er field declaration and the code for creating the object and adding it to the panel.
some participants only kept the creation code and forgot to keep the declaration resulting in a compilation error.
all of them immediately realized their mistake by read ing the error message and went to the field declaration location and performed selective undo there to restore the code.
even though we found these kinds of conflicts to be easy to detect and fix we plan to investigate adding features to azurite to handle them directly by augmenting the structural information of the changes .
in fact as we showed in our previous study of backtracking the textual changes can easily be transformed into ast level changes with a parser which means that we could use both the textual and the structural changes as input.
d. scalability of azurite as it stands now azurite has only been tested with visualizing less than a week of coding histories .
we believe this is an appropri ate level of scalability for its purpose given that we found of the programmers backtracking is performed within the same editing session .
however because there was a general consensus from the users that the rectangles displayed in the timeline are too fine grained we will enhance the timeline by applying semantic zooming and coalescing the edits for the same task or those related to a working set.
ix.
related work a. selective undo in other contexts selective undo has been extensively studied for graphical interactive editors.
berlage introduced the selective undo model implemented in gina which adds the reverse operation of the selected command to the current context .
the amulet and topaz systems had a similar selective undo feature but these allowed repeating a selected command even on a new object.
selective undo was applied in spreadsheets by allowing users to select a region in the spreadsheet and perform regional undo.
dwell and spring is a recent selective undo mechanism for direct manipulation.
it provides an interface for un any press drag release interaction.
all of these approaches assume t hat there is an object on which the operations can be performed primitive graphical objects such as shapes in graphical editors and individual cells in spreadsheets.
in contrast there is no clear notion of objects in text editors since edit operations typically affect ranges of text and the text itself moves around and is changed.
there are other undo models that support selective undo by providing additional command s beyond undo and redo.
the us r model allows users to skip re an operation using a complicated tree based data struct ure.
users can selectively undo an isolated operation by un multiple steps until the target operation gets undone skipping the redo command once and then re the rest of the operations.
the triadic model uses a simpler str ucture composed of a linear history list and a circular redo list which can be rotated by users.
un an operation puts the operation at the beginning of the redo list and rotating the redo list takes one operation at the beginning of the list and put s it at the end.
since the rotate command can be used to skip a redo command users can selectively undo a certain operation in a similar way.
however both models require deep understanding of the underlying history structure to correctly perform selectiv e undo.
in addition selective undo cannot be done in one step which can be cumbersome for users.
b. regional undo in text editors some text editors such as emacs and distedit support regional undo where the user und oes the most recent operation that affected a specific selected region of text .
regional undo is useful and also relatively easy to implement compared to the generic selective undo because it always undoes the most recent operation performed in the select ed region which guarantees that there are no regional conflicts with the target operation see section iii.b .
regional undo is directly supported in azurite using the keyboard shortcut by searching for all edits for the regi on of code and invoking selective undo on the last one or by using code history diff view and using the revert button .
in regional undo however there can be an ambiguity if the user selects a region which partially overlaps with an operation s effective region.
li and li refer to this problem as region overlapping and introduce the idea of partial undo as a solution which undoes only overlapped part of the operation when an operation partly falls in the given undo region .
in this situation azurite would do the same when using the code history diff view or the regional undo shortcut to revert a certain region of code to one of the previous versions .
c. variation management tools version control system s vcs s can be seen as temporal variation management system s. however there are many cases where a vcs cannot directly help with backtracking as discussed in section i. git provides fea tures related to selective undo such as reverting a whole commit and selectively committing local code changes .
however selectively reverting changes from an existing commit is a very involved process.
moreover these features cannot be used for restoring deleted code that is neither in the commit history nor in the local code.
most ide s support automat ic local history keeping features but they are limited in that the history is shown in a linear list without any human readable descriptions or cues history search is not supported and selective undo is not directly supported so users must compare the local and the desired old er versions to merge the wanted changes manually.
similar to ides cloud based text editors such as google docs support linear revision history with the same limitations.
there are a few other systems such as juxtapose and parallel pies which facilitate design exploration by providing ways of adding alternatives at any time and moving among the alternatives.
however users must know in advance when they want to add variations in juxtapose and parallel pies works only in the graphical editing context.
other work has studied ways to manage source code variations.
choice calculus provides a generalized representation for software variations at the source code level and provides theoretical f oundations of variation management .
however the choice calculus cannot handle region al conflicts.
barista had an alternative expressions tool which allows select ing an alternative by clicking on one of the listed choices but it was restricted to the expression level.
x. conclusion although selective undo can be a powerful way to backtrack this idea has not previously been implemented in any popular code editors due to the challenges of selective undo for text editing.
azurite overcomes these chall enges and provides a practical and usable system which our formal user study suggest s can make programmers more effective and efficient by allowing them to backtrack more easily.
we expect that the tool would give programmers more confidence while explori ng because they can back out of incorrect edits at any time.
azurite is available for general use as an eclipse plugin for java and we invite your feedback .
acknowledgment s we thank sebon koo for helping us implement the early version of the timeline and the participants of our studies .
funding for this research comes in part from the korea foundation for advanced studies kfas and in part from nsf grants iis and iis .
any opinions findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect those of kfas or the national science foundation.