efficient data model verification with many sorted logic ivan boci c and tevfik bultan department of computer science university of california santa barbara usa fbo bultang cs.ucsb.edu abstract misuse or loss of web application data can have catastrophic consequences in today s internet oriented world.
hence verification of web application data models is of paramount importance.
we have developed a framework for verification of web application data models via translation to first order logic fol followed by automated theorem proving.
due to the undecidability of fol this automated approach does not always produce a conclusive answer.
in this paper we investigate the use of many sorted logic in data model verification in order to improve the effectiveness of this approach.
many sorted logic allows us to specify type information explicitly thus lightening the burden of reasoning about type information during theorem proving.
our experiments demonstrate that using many sorted logic improves the verification performance significantly and completely eliminates inconclusive results in all cases over real world web applications down from an inconclusive rate.
i. i ntroduction modern software applications have migrated from the desktop onto to the cloud.
benefits of web applications over desktop applications include accessibility on multiple devices anywhere and anytime higher availability due to redundant systems easier upgrades and patching etc.
however these benefits come at the cost of increased complexity as web applications are complex distributed systems.
web applications typically serve to store and manage user data.
for applications such as healthcare.gov gmail and facebook loss or corruption of data would have dire consequences.
hence verification of how applications manage data is of paramount importance.
we focus on a specific but widespread type of web application that is enforced by many popular web application frameworks ruby on rails for ruby spring for java play for scala and java django for python sails for nodejs etc.
.
these web applications employ the modelview controller mvc pattern to make web application development easier and modular.
the data model defines the data the application manages as well as the methods that are used to modify the data.
the controller accepts requests queries and or updates the data and invokes the view to synthesize the response.
these operations are defined as actions .
these web applications have the following characteristics they are restful meaning that actions can be invoked any number of times and in any order actions are or should be atomic meaning that they update the data in one this material is based on research sponsored by nsf under grant ccf1423623.
part of this research was conducted while tevfik bultan was visiting koc university in istanbul turkey supported by a research fellowship from t ub itak under the b ideb program.step and revert any changes if an error is encountered the data is manipulated only by actions meaning that there is no way to modify the data outside of actions the data model is implemented using object relational mapping orm libraries that help bridge the semantic gap between object oriented languages and relational databases.
based on these characteristics we can verify invariants about the data model by analyzing the object oriented code that defines the actions and verifying that each action preserves the invariants.
previously we developed a framework for verification of web application data models by automatically translating verification queries to logic formulas and then using an automated theorem prover to check these automatically generated formulas .
in this framework we first statically extract a semantic data model from the web application by analyzing the data model schema and the methods that implement the actions.
we ask the user to write data model invariants to be verified using our invariant specification library that provides constructs for quantification.
for each action invariant pair we synthesize a first order logic fol theorem that is valid if and only if the action preserves the invariant.
assuming that the invariant is true before the action starts executing and specifying the way the action modifies the data the theorem posits that the invariant must hold after the action ends its execution.
we send this theorem to an off the shelf fol theorem prover to verify.
using this method on several real world web applications we discovered several previously unknown bugs that the developers acknowledged and repaired .
since fol is undecidable an automated theorem prover may never terminate deducing continuously producing new deductions without reaching a proof of the theorem.
this is especially the case in the presence of complex constructs in actions such as loops .
our approach results in one of three outcomes for each action invariant pair a proof that the action preserves the invariant a proof that the action can violate the invariant or an inconclusive result caused by the theorem prover not reaching a conclusive answer in a specified time period.
minimizing the ratio of inconclusive results is a necessary step for making our approach usable in practice.
in order to understand the causes of inconclusive results we investigated the logs of the theorem prover we used in our experiments spass .
we noticed that the theorem prover did an excessive number of deductions solely to reason about the types of quantified variables and objects.
since fol does not have a notion of type our fol translation generates predicatesthat encode all the type information and the theorem prover was spending a lot of time deducing about these predicates.
in order to address this problem we looked into using many sorted logic for data model verification.
in many sorted logic sorts i.e.
types are explicitly associated with all variables functions and predicates.
our intuition was that using sorts will benefit verification because it mitigates the necessity of deducing type information.
on the other hand the semantics of sorts and the semantics of data model classes do not match and this semantic mismatch makes the translation of data models challenging especially if inheritance is present in the data model.
in addition to dealing with inheritance there is one more complication in translation to many sorted logic.
classical fol i.e.
fol without sorts defines structures instances that may or may not satisfy a given set of formulas as strictly non empty.
in our data model encoding empty structures represent the possibility of a particular class having no objects and we want to allow empty structures since this might be a possible behavior of the data model.
unfortunately most theorem provers do not allow empty structures.
this problem was not a significant issue with our translation to unsorted fol since we were encoding types with predicates and it is possible to define a predicate that never evaluates to true which would encode an empty class .
however when we map classes to sorts the issue of empty structures must be handled during translation which introduces extra complexity further distancing sorts from the data model type system.
in order to compare the performance of the unsorted fol i.e.
fol without sorts translation with the many sorted logic translation we used spass and z3.
we compared the performance between spass using the unsorted fol translation and z3 using the many sorted logic translation by extracting a total of verifiable action invariant pairs and translating them to formulas for spass and z3.
we observed that verification results for z3 were significantly better.
we found that z3 outperformed spass in all cases successfully verifying all the action invariant pairs whereas spass had an inconclusive result rate of .
in addition we observed a speedup of two orders of magnitude over spass.
this performance difference was beyond our expectations.
however looking just at these results it is not possible to attribute the performance improvement to the benefits of many sorted logic translation over the unsorted fol translation.
spass and z3 use different deduction methods which could be the cause of the performance difference.
or the performance difference could even be due to differences in the implementations and optimizations of the different provers.
in order to determine the cause of the performance difference we developed a translation of the data model to manysorted logic that effectively bypasses the sort system.
we reran our experiment suite on z3 with this unsorted translation.
we found that the unsorted translation induced a .
inconclusive result rate and slowed down verification by two orders of magnitude.
while z3 and spass use fundamentally different approaches to theorem proving we posit that sorts are inherently useful in data model verification.
the rest of the paper is organized as follows.
section ii presents an overview of our approach through examples.
account contact taggable commentable tag comment0.. taggings .. tags1 commentable .. comments0.. account0.. contacts a data model schema.
1class commentscontroller ... def destroy comment comment.find params comment.destroy respond with comment end ... 9end b destroy comment action.
fig.
.
a data model example based on fatfreecrm .
section iii defines fol focusing on the differences between unsorted many sorted and empty logics.
section iv defines the type system of data models.
section v explains the translation of data models into different variants of first order logic.
in section vi we evaluate how use of these different logics affect verification feasibility and performance.
section vii discusses related work and section viii concludes the paper.
ii.
o verview fatfreecrm is an open source web application for customer relationship management written in ruby on rails.
figure contains an excerpt from the data model of this application.
figure a defines a portion of the data model schema.
in fatfreecrm account objects can have any number of contacts.
both accounts and contacts are taggable and commentable.
even though taggable and commentable are implemented using mixins we treat them as normal classes in our abstraction.
commentable objects have any number of comments and every comment is attached to a commentable.
taggable objects can have any number of tags and tags can be attached to any number of taggables.
data models also specify behaviors via actions i.e.
they specify how the data are modified.
figure b shows an example action from the fatfreecrm.
this action is taken from the commentscontroller and it deletes the comment whose idis provided by the user.
line reads this identifier from the request params looks up the comment for this id using comment.find ... and assigns the return value to a variable called comment .
line deletes this comment and line synthesizes the response.
in our framework data models are verified by synthesizing formulas in first order logic fol in order to answer the following question after defining the model schema and assuming that all invariants about the data model hold before the action and taking into account all possible behaviors of the action do the invariants still hold after the action s execution?
the generated fol formula is valid if and only if the answer to this question is affirmative.for example figure presents a translation of the data model schema from figure a to fol.
we define predicates for this purpose account contact taggable commentable tag and comment.
we define that all accounts are taggable and commentable formula and that all contacts are taggable and commentable formula .
it is useful to define a predicate that denotes that an object is precisely of a class and not of a subclass.
this is not trivial to express since for example accounts are simultaneously taggable but the reverse might not be the case.
to that end we introduce predicates taggable xandcommentable x. we define these predicates in formulas and .
with these predicates we can define that every object is an instance of at most one class formulas .
these formulas imply that for example an object could be simultaneously taggable and commentable but not commentable and a comment.
predicates account contact taggable commentable tag comment taggable x commentable x.
8o account o !taggable o commentable o 8o contact o !taggable o commentable o 8o taggable x o taggable o account o contact o 8o commentable x o commentable o account o contact o 8o account o !
contact o taggable x o commentable x o tag o comment o 8o contact o !
account o taggable x o commentable x o tag o comment o 8o taggable x o !
account o contact o commentable x o tag o comment o 8o commentable x o !
account o contact o taggable x o tag o comment o 8o tag o !
account o contact o taggable x o commentable x o comment o 8o comment o !
account o contact o taggable x o commentable x o tag o fig.
.
axioms defining the class diagram in figure a in classical unsorted first order logic.
the fact that these formulas need to be explicitly stated just to implement these types in fol demonstrates the semantic gap between the object oriented paradigm and fol.
generating these formulas from a data model is doable however they indicate a potential performance problem during theorem proving.
since the theorem prover does not treat types of variables as integral parts of them every formula that the theorem prover deduces will need to be additionally processed to deduce the possible types of involved entities.
and indeed upon inspecting the deduction logs of the theorem prover we use spass we found that the theorem prover frequently takes steps to deduce types of entities.
deduction about types is largely unnecessary in our case.
when constructing formulas that define actions and invariants we have specific types in mind.
we would be able to provide this type information explicitly if the underlying logic supported type declarations.
this would lessen the burden of the theorem prover and possibly drastically reduce the number of deductions necessary.
many sorted logic is a variant of fol that supports explicit type information.
in addition there exist automated theorem provers that accept many sorted logic and as our experiments demonstrate can use the sort information to increase verification performance and viability.
many sorted logic supports sorts or types that are associated with all predicates functions and variables.
sorts implymutually disjoint sets of elements e.g.
an element of sort a and an element of sort b can never be equal .
many sorted logic does not support subsorts and every domain element is always of a single sort.
a formal definition is given in section iii.
we developed a translation of data models to manysorted logic.
figure shows the specification of the data model in figure a within the many sorted logic.
since sorts imply mutually exclusive types and classes account contact commentable and taggable are related through inheritance we cannot use sorts alone to define this data model.
instead we introduce a single sort called cluster and four unary predicates account contact commentable and taggable that accept an argument of this sort.
we use these predicates to refer to these classes directly.
on the other hand tag and comment are classes that are unrelated to others through inheritance and as such we can use sorts alone to denote their types.
formulas and specify that all cluster objects are commentable and taggable.
note that this could have been specified in a simpler way but the example corresponds to the result of our method presented in section v. formulas and define predicates taggable xand commentable x. formulas define that within the cluster no object can be an instance of more than one type.
sorts cluster tag comment .
predicates account cluster contact cluster taggable cluster taggable x cluster commentable cluster commentable x cluster .
8cluster o account o !taggable o commentable o 8cluster o contact o !taggable o commentable o 8cluster o taggable x o taggable o account o contact o 8cluster o commentable x o commentable o account o contact o 8cluster o account o !
contact o taggable x o commentable x o 8cluster o contact o !
account o taggable x o commentable x o 8cluster o taggable x o !
account o contact o commentable x o 8cluster o commentable x o !
account o contact o taggable x o fig.
.
axioms defining the class diagram in figure a in many sorted logic.
the translation in figure may not seem like an improvement over the translation in figure .
however not only is the part defining exact type exclusivity shorter in case of many sorted logic instead of axioms but these axioms are also shorter instead of conjuncts implied .
also the difference between the two translations increases if inheritance is rarely used.
in case of no inheritance in the data model no axioms are necessary to model the data model schema.
out of most starred ruby on rails applications on github only employ inheritance and on average only of classes inherit or are inherited from other classes.
we further discuss these differences in section v. there exists another problem with data model verification using fol.
in fol a structure can loosely be defined as an instance that may satisfy a given fol formula.
classical fol is defined in such a way that the structure cannot be empty more precisely defined in section iii c .
this is not suitable for our purposes.
an empty structure corresponds to no objects existing in the data store which is a possible state that we want to be considered by the theorem prover.
we remedy thisby introducing new predicates that enable us to define a type system that allows empty domains discussed in section v b .
iii.
f irst order logic in this section we give an overview of first order logic fol .
definitions in this section are based on but simplified where possible for brevity.
after discussing classical fol we describe two variants of fol called many sorted logic section iii b and empty logic section iii c .
a. first order logic a fol language lis a tuplehf p viwhere fis a set offunction symbols pis a set of predicate symbols vis a set of variable symbols.
all function and predicate symbols are associated with their arities which are positive integers denoting the number of arguments they accept1.
given a fol language l hf p vi aterm is a variable v2vor a function invocation f t1 t2 tk where f2f andt1 tkare terms and kis the arity of function f. a well formed fol formula is defined as either p t1 t k where p2pis a predicate of arity kand t1 tkare terms v f where v2vandfis a formula f1 f1 f2 f1 f2where f1andf2are formulas t1 t2 where t1andt2are terms.
given a fol language l astructure sis an instance that may or may not satisfy a formula expressed in this language.
more formally it is a tuple hu fs ps vsiwhere uis a nonempty set of elements called the universe .fsis a mapping offonto a set of functions such that for every f2fof cardinality kthere exists an fs2fssuch that fsis a function that maps uk!u.
similarly for every predicate p2pof arityk there exists a pu2pusuch that pu uk.
we can test whether a structure ssatisfies a formula whether the formula is true within this structure .
to do this we assign elements of uto all terms in the formula.
each variable v2vis assigned an element vs2u.
term f t1 tk is mapped to the return value of fuwhen using elements of uassigned to terms t1 tkas arguments.
similarly p t1 t k is considered to be true if and only if elements corresponding to t1 tkform a tuple that is in pu.
boolean connectives and equality are interpreted in a standard way.
universal quantification is a bit more involved 8v fis satisfied by sif and only if for every structure s vje that is identical to sexcept that vwas assigned a potentially different element eofu fis satisfied by s vje .
a formula that is satisfied by one structure may not be satisfied by another.
for example x yis true for all structures that happen to map variables xandyto the same element.
a formula 8x 8y x y is true if and only if u is a singleton set.
if a formula is satisfied by all structures we call this formula valid .
e.g.
x xis a valid formula.
1we may extend this to introduce constants as functions of arity and propositional variables as predicates of arity .
2although classical fol does not include equality since the theorem provers we use operate on fol with equality we include equality in our definition of fol.we take note of free variables variables that are not quantified outside the term in which they appear.
for example 8x x yhas one free variable y. since the theorem provers we use do not allow free variables from this point on we will only consider formulas without free variables.
b. many sorted logic sometimes it is useful to divide the universe of a structure using types with mutually exclusive domains.
this is especially true if the functions and predicates make sense only within a specific domain.
types in many sorted logic are called sorts .
many sorted logic allows us to explicitly declare the types of all function and predicate arguments function return values and variables.
it also gives us the ability to quantify over elements of a given type instead of over the whole universe.
formally many sorted logic is very similar to classical fol.
in addition to everything discussed previously lincludes a set of sorts s. functions and predicates in fand prespectively define the sorts of their arguments functions define the sort of their return value and all variables are associated with a sort from s. we also require all formulas to be well typed e.g.
a predicate can only accept a term as an argument if the term s sort matches the predicate s declaration .
a structure sin many sorted logic does not contain a single universe u. instead it contains a non empty universe usfor each sort s2s.
for each predicate pof sorts s1 s kand arityk we define psas a subset of us1 usk.
the setfuis defined analogously and vuassigns an element of a variable s sort to each variable.
quantification is always done over a specific sort s universe.
for clarity we explicitly declare the sort sof a variable vwhen quantifying by using the notation8s v f. note that many sorted logic and unsorted logic have equivalent expressive power .
given a set of many sorted formulas a similar set of unsorted formulas is equisatisfiable if we introduce predicates used to denote sorts and conjoin the formulas that partition the universe to these sorts.
unsorted logic can be translated to many sorted logic by introducing a single sort that applies to all language elements.
c. empty logic fol universes are usually defined to be non empty.
allowing the special case of an empty universe makes definitions more complicated.
treatment of variables and function return values becomes problematic because terms are expected to take a value of one element of the universe.
this is not possible in empty universes.
furthermore the possibility of an empty universes breaks certain fundamental rules about fol.
e.g.
8x x6 xis normally an unsatisfiable formula.
if we define quantification over an empty universe to be vacuously true as there does not exist an assignment of the variable that does not satisfy the subformula this example formula is satisfied by a structure with an empty universe.
empty universes are a useful concept for data model verification.
in general a data model state may contain noobjects.
this is an important consideration for data model verification e.g.
does the application behave properly even if there exist no users or accounts?
.
for this reason it is necessary to consider empty universes as a possibility during verification.
as one would expect other data model verification tools such as alloy support empty domains.
empty logic is a variant of fol that allows empty universes.
the treatment of empty universe in empty logic is defined by quine universal quantification over an empty set is considered vacuously true since there exists no counterexample variable assignment and existential quantification over an empty set is considered vacuously false since there exists no satisfactory variable assignment .
this interpretation of quantification over empty sorts is in concordance with an alternative definition of universal quantification given a universe u quantification8v fcan be unrolled into a conjunction of all formulas that result from replacing vinfwith an element of u. in case of an empty universe this list of quantified formulas is empty and the neutral element of conjunction is the boolean true .
in combination with many sorted logic empty logic allows a sort s universe to be empty.
although theorem provers we use during verification do not support empty logic in our translation of data models to fol we simulate the empty logic semantics so that the resulting translation covers the data model behaviors where data classes can be empty i.e.
without any instances .
we discuss our formalization of the data models and how we deal with many sorted logic and empty universes in our translation to fol in the following sections.
iv.
d ata models in this section we formally define our data models.
this definition is an extension of the model defined in our previous work .
this extended formulation supports multiple inheritance among data model classes.
a data stores a data store is a structure ds hc r a iiwhere cis a set of classes ris a set of relations ais a set of actions and iis a set of invariants.
the set of classes cidentifies the types of objects that can be stored in the data store.
each class can have any number of superclasses from c superclass c c and transitively no class can be a superclass of itself.
we use c1 c2 c1 c2 to denote that c1is a subclass of or equal to c2.
a relation r hn co ct cardi2ris defined by a name n origin class co2c a target class ct2cand a cardinality constraint card such as one to one one to many etc.
.
b data store states given a data store ds hc r a ii the set of all possible data store states is denoted asds.
a data store state is a structure ho ti2ds where ois a set of objects andtis a set of tuples .
objects are instances of classes whereas tuples are instances of relations.
each object o2ois an instance of a class c2cdenoted by c classof o .
each tuple t2tis in the form t hr oo oti where r hn co ct cardi2randclassof oo coand classof ot ct. for a tuple t hr oo otiwe refer to oo as the origin object and otas the target object.
cardinality constraints of each relation r2rmust be satisfied by every data store state in ds.c actions given a data store ds hc r a ii a denotes the set of actions.
each action a2acorresponds to a set of possible state transitions ho ti ho0 t0i ds ds.
actions characterize updates to the data store states such as creation or deletion of a set of objects or creation or deletion of a set of tuples.
for example the action in figure b could be defined as follows.
we would define that there exists a comment that is going to be deleted this comment will not exist in the post state regardless of whether it existed in the pre state.
all associations of this deleted comment are deleted as well.
this alone is insufficient as this definition allows a behavior where any other object is created or deleted as well.
in order to define that this one comment is the only object affected by the action we explicitly define that all other comments exist in the post state if and only if they existed in the pre state.
similarly for all objects of other types we define that they exist in the post state if and only if they existed in the pre state.
d invariants given a data store ds hc r a ii iis the set of invariants.
an invariant i2icorresponds to a boolean function i ds!f false truegthat identifies the set of data store states which satisfy the invariant.
we allow the user to specify invariants in ruby on rails directly using a library that we provide that supports quantification.
invariants are translated to fol almost verbatim.
v. l ogics and the translation in this section we present the translation of data models as defined in section iv into different variants of first order logic fol .
the specifics of the underlying logic many sorted or not empty or non empty are closely related to the way we encode type system in fol as well as the way we quantify over objects in the translation.
discussing how we handle the data model schema and quantification is sufficient to explain and differentiate our translation to different fol variants.
the rest of the fol translation is described in detail in our earlier work and will not be repeated here due to space constraints.
for brevity we restrict the following discussion to classes only.
although the definition of relations does differ based on the underlying logic they are handled in a way analogous to how we handle classes.
furthermore in this section we frequently conjoin or disjoin a set of formulas.
when a set of conjoined or disjointed formulas is empty we substitute the conjunction or disjunction with their neutral elements true and false respectively .
a. unsorted vs. many sorted in order to define the class system for both unsorted and many sorted logics we define three groups of axioms inheritance axioms that define superclass relationships instance axioms that define predicates that we can use to denote that an object is an instance of a given class specifically not of a subclass and membership axioms that define that every object is an instance of at most one class.
in this section we assume to be given a data store ds hc r a ii.a unsorted logic inheritance axioms for unsorted logic are defined as follows.
for each class c2cthat has a non empty superclass set superclass c fp1 p2 p kgwe generate an axiom 8o c o !p1 o p2 o pk o for example given the model in figure a this method produces formulas and in figure .
instance axioms constitute one axiom per class c2cand serve to define instance predicates cx.
these predicates are used to express that an object is an instance of class c or more explicitly of class cbut not of any of c s subclasses.
given fs1 s kg the set of all direct subclasses of c all classes s for which c2superclass s we generate an axiom 8o cx o c o s1 o sk o note that if chas no subclasses this axiom defines equivalence between candcx.
if this is the case as an optimization we omit defining cxand use cinstead.
given the model in figure a this creates formulas and in figure .
membership axioms define that each object represents an instance of exactly one class.
assuming that c fc1 c kg for every class ci2c we create an axiom in order to constrain that if an object is an instance of class ci it cannot be an instance of any other class 8o cix o !
c1x o ci 1x o ci 1x o ckx o these formulas correspond to formulas in figure .
the resulting number of generated formulas is linear in the number of classes and so is the size of these formulas.
b many sorted logic within our translation where universe elements correspond to objects sorts naturally serve the purpose similar to classes.
however sorts imply disjoint object sets which is only suitable for classes that do not employ inheritance.
classes that employ inheritance cannot be directly mapped to sorts because a subclass s object set is a subset of a parent s. to work around this problem we partition the set of all classes into inheritance clusters .
an inheritance cluster is a maximal set of classes such that for any two classes c1and ckin the cluster there exists a list of classes c1 c2 c k where each consecutive pair of classes constitutes a childparent or parent child relationship.
in other words in the class graph where vertices are classes and edges correspond to inheritance an inheritance cluster is a maximally connected component.
note that all classes that do not employ inheritance are members of singleton clusters.
for each inheritance cluster we introduce a sort that is common to all classes in the cluster.
in case of an inheritance cluster with multiple classes we introduce predicates and axioms in order to differentiate classes within the cluster.
these predicates and axioms are similar in purpose to the predicates used in the unsorted logic translation.
for each class cin a nonsingleton inheritance cluster we introduce unary predicates c andcxof the cluster s sort and introduce axioms that resemble the ones defined for unsorted logic the key distinction being these axioms refer to classes of that cluster only.
specifically inheritance axioms are defined as follows for each class cthat belongs to an inheritance cluster of sort sand whose superclass set is superclass c fp1 p2 p kg 8s o c o !p1 o p2 o pk o for the model presented in figure a inheritance axioms are formulas and in figure .an instance axiom is generated for each class c. let fs1 s kgbe the set of c s subclasses and let sbe the sort of c s inheritance cluster 8s o cx o c o s1 o sk o given the model presented in figure a instance axioms are formulas and in figure .
finally membership axioms are generated for each nonsingleton inheritance cluster individually instead of for the entire set c. given an inheritance cluster that consists of classesfc1 c kgwhere k 1we generate an axiom for each class ciinside this cluster 8s o ci o !
c1 o ci o ci o ck o formulas in figure correspond to membership axioms for the model in figure a .
the number of introduced predicates and axioms is highly dependent on the data model in question.
with no inheritance no additional predicates and axioms are introduced.
the number and size of formulas introduced by each inheritance cluster are linear in the number of classes in the cluster.
however most classes do not employ inheritance in data models of real world applications out of most starred ruby on rails applications do not employ inheritance at all with an average of classes involving inheritance making most classes part of singleton inheritance clusters.
furthermore if multiple non singleton inheritance clusters exist in the data model the size of generated axioms is relatively small when compared to those generated by the unsorted logic translation.
b. empty structures our treatment of empty structures is dependent on whether the underlying theory is unsorted or many sorted.
in fact our translation to unsorted logic as presented above allows empty structures by default.
this becomes clear when we change the interpretation of all type predicates cto imply that the universe element in question is of the given type but in addition it exists semantically.
notice that our encoding does not require that all universe elements are of a class type.
for example we use universe elements to represent tuples.
whenever we define functions and predicates in unsorted logic we constrain argument values and the return value if applicable to be of expected types.
as a corollary of our expanded interpretation function return values objects exist semantically if and only if arguments exist semantically and are of corresponding types.
similarly predicates may accept a set of domain elements under the condition that they exist semantically and are of corresponding types.
as for quantification whenever quantifying over a class type we introduce a condition that the subformula is relevant only for domain elements that represent objects of the given type.
for example in order to universally quantify over elements of class cusing the variable vand a subformula f we generate a formula 8v c v !f.
in case of existential quantification we would instead generate 9v c v f. predicates prestate poststate atcomment .
8x atcomment x comment x 8x 8y atcomment x atcomment y x y 8x atcomment x poststate x 8x atcomment x prestate x poststate x fig.
.
unsorted action translation example.for example the action presented in figure b can be translated to fol as defined in figure .
for brevity we omit listing all predicates and axioms that define the type system.
in this translation the atcomment predicate denotes values that are saved in the comment variable.
first we constrain type specific predicates to refer to their actual types formula .
note that as part of our interpretation of class type predicates any entity accepted by the atcomment is also accepted by comment and therefore exists semantically.
next in formula we constrain that there exists at most one element in variable atcomment as the find method in ruby on rails line in figure b returns at most one object.
formulas and define the delete statement.
formula defines that the objects in the comment variable no longer exist after the statement regardless of their existence before .
formula defines that all objects outside this variable existed before if and only if they exist after the statement has finished executing.
this particular translation allows for an empty universe.
such a structure would have no elements accepted by predicates comment andatcomment .
this problem becomes more complicated with the manysorted logic translation.
if we were to define a comment sort alone then the universe of this sort would be non empty meaning that at least one comment would exist for every sort.
to go around this problem for each such class c we introduce a predicate cthat accepts a single argument of c s sort.
we do not introduce any axioms.
we use these predicates to define object sets of these classes implying that object sets are subsets of their corresponding universes.
predicates prestate cluster cluster prestate comment comment prestate tag tag poststate cluster cluster poststate comment comment poststate tag tag atcomment comment comment p comment tagp tag .
8comment x atcomment x comment p x 8comment x 8comment y atcomment x atcomment y x y 8comment x atcomment x prestate comment x poststate comment x 8comment x atcomment x prestate cluster x poststate cluster x fig.
.
many sorted action translation example.
given the example action in figure b a many sorted translation can be defined as in figure .
note that once again we omit declaring all sorts predicates and axioms from figure for brevity.
notice that we introduce predicates comment pandtagp in addition to previously defined sorts comment andtag.
in formula we define that all elements accepted by atcomment are also accepted by comment p. this is necessary to express since without this axiom there could be an element accepted by atcomment that is not accepted by comment p. formula defines that there exists at most one element accepted by atcomment .
formulas and define how the delete statement transitions between the pre state and the post state.
these formulas are analogous to formulas and in the unsorted translation.
note that however these formulas are constrained to the comment sort.
all other sorts are handled implicitly we do not differentiate between their pre and post states .
this demonstrates the benefit of introducing sorts as the theorem prover does not need to reason at all about other types by default.table i. w eb applications used in our experiments application kloc of model of action classes invariant pairs copycopter .
fatfreecrm .
fulcrum .
kandan .
lobsters .
redmine .
tracks .
empty structures are handled by this translation.
for example a structure that represents this case would have no entities of sort comment be accepted by predicates comment pand atcomment .
without introducing a predicate comment p this would not be the case.
vi.
e xperiments we conducted two sets of experiments.
both these experiments involved data store verification of real world web applications copycopter fatfreecrm fulcrum kandan lobsters redmine and tracks .
we extracted the data models from these applications fully automatically and we wrote the invariants to be verified manually.
statistics about these applications are summarized in table i. note that kloc refers to the number of lines of code in ruby excluding javascript and domain specific languages.
in addition to these applications we separately tested our tool on applications and actions that employ loops.
in our experience loops are the most difficult construct to verify where even the presence of loops with empty iteration bodies may cause timeouts .
this data set is useful to test how sorts help with highly complex problems.
we included all action invariant pairs from this data set that used applicationspecific invariants and not the trivially preserved false invariant .
in total we had action invariant pairs.
we refer to these pairs as verification cases or verification instances.
we translated these cases into different fol variants in order to evaluate the performance using different provers heuristics and translations a total of fol theorems.
for each of these cases we ran verification with a time limit of minutes.
if the theorem prover did not deduce a result within minutes we treated the result as inconclusive.
given that most verification cases terminate in a few seconds we believe that this is a reasonable time limit.
a. fol theorem provers as an unsorted logic theorem prover we used spass .
spass is a fol theorem prover based on superposition calculus.
while spass supports multiple input formats we translated the verification cases to spass s own input format .
spass tries to prove that a conjecture follows from a set of axioms by negating the conjecture and attempting to deduce a contradiction.
if this contradiction is found then the conjecture is proven to follow from the axioms.
note that spass supports soft sorts which are different than the sorts in many sorted logic we discussed earlier and any other sort system we encountered.
soft sorts do not imply mutually exclusive universes.
in a soft sort system any universetable ii.
v erification performance summary method of verification time sec smt unit propagations memory mb timeouts average median average median average median maximum spass soft sorts on .
.
.
n a n a .
.
.
spass soft sorts off .
.
.
n a n a .
.
.
z3 many sorted .
.
.
.
.
.
.
.
z3 unsorted .
.
.
.
.
.
.
.
fig.
.
verification time distribution.
element may be of a sort of no sort or of multiple sorts.
semantically these sorts are indistinguishable from unary predicates.
furthermore spass by default infers soft sorts even if none are explicitly specified.
spass provides a command option that allows us to disable the soft sort system in which case the theorem prover treats soft sorts as unary predicates.
the differences between these soft sorts and sorts as defined in many sorted logic have been observed before .
in the following discussion whenever we refer to sorts we refer to sorts defined by many sorted logic.
we will use soft sorts to refer to spass s version of sorts specifically.
we used z3 to evaluate effectiveness of data model verification using many sorted logic.
z3 is a dpll t based smt solver that deals with free quantification and uninterpreted functions using e matching .
smt solvers tend to support many different theories such as arithmetic arrays or bitarrays.
these theories are combined in propositional logic which serves to tie the underlying theories without interpreting them.
instead predicates in underlying theories are treated as propositional variables and left to the underlying provers to be solved.
partial conclusions from these underlying theories may be propagated to other underlying provers in dpll t in order to reach other conclusions.
when used only with free quantification free sorts and uninterpreted functions which is denoted as the problem group uf smt solvers behave like many sorted logic theorem provers.
smt solvers try to find instances that satisfy the specification so in order to prove that the conjecture follows from axioms we negate our conjecture and state it as an additional axiom.
the conjecture follows from the axioms if and only if this resulting set of axioms is unsatisfiable.
b. spass vs. z3 performance our first set of experiments compare the performance of spass and z3 for the purpose of data model verification.
these experiments were done solely to detect whether z3 can sometimes outperform spass either by reaching results thatspass could not or occasionally reaching them faster.
if so our efforts in translating data models to smt would increase the performance and or reduce the ratio of inconclusive results in our data model verification efforts and therefore increase the viability of data model verification in the real world.
our results are summarized in table ii and figure and the performance difference was beyond our initial expectations.
note that the z3 unsorted entries are only relevant for the experiment discussed in the next subsection and can be disregarded for now as is the case for smt unit propagations columns.
with soft sorts enabled spass produced inconclusive results .
.
with soft sorts disabled spass produced inconclusive results .
.
interestingly the set of inconclusive results caused by disabling soft sorts is a strict subset of the inconclusive results caused by enabling soft sorts.
spass performed similarly regardless of the soft sorts setting.
for both settings excluding timeouts verification took an average of over seconds per case.
the median case is just under seconds.
the memory consumption averaged at around 70mb with the median case of .45mb.
disabling soft sorts caused a peak of .6gb memory used whereas with soft sorts enabled the peak was at .30mb.
in only cases did verification with disabled soft sorts exceed .30mb.
z3 performed far better than spass with either heuristic.
z3 produced no inconclusive results .
on average z3 took .
seconds to verify an action invariant pair.
in no case did spass outperform z3 in terms of verification time performance.
furthermore z3 s average and median memory consumption was under 4mb peaking at .
.
only for cases did z3 consume more memory than spass with or without soft sorts and the difference is negligible.
figure shows the distribution of the verification cases over the verification time ranges for each theorem prover.
for example the leftmost column labeled .
shows that z3 produced a verification result in less or equal than .
seconds times.
spass never achieved a result within this time.
the next time range is labeled .
and shows that z3 produced a verification result in more than .
seconds but less or equal to .
seconds times.fig.
.
distribution of the slowdown factor compared to many sorted z3.
table iii.
o bserved slowdown compared to many sorted z3 method average median interdecile range spass soft sorts on .
.
.
.
spass soft sorts off .
.
.
.
unsorted z3 .
.
.
.
we wanted to compare the performances of different provers on case by case basis.
for each action invariant pair we calculated the relative slowdown factor induced by a prover compared with z3.
so for example if an action invariant pair was verified times slower using spass with sorts enabled when compared with z3 this counts as a slowdown factor of .
figure and table iii summarize this data.
figure contains the distribution of slowdown factors per prover.
for example spass with and without soft sorts is most frequently 29times slower than z3.
table iii contains additional information about this slowdown.
on average z3 was .
times faster than spass with soft sorts on and .
times faster with soft sorts off.
in the median case z3 was and times faster respectively.
in order to estimate a range of performance increase factor for the majority of cases we calculated interdecile ranges of these distributions.
the interdecile range is the range of values ignoring the lowest and highest of values in the sample.
the interdecile ranges of performance increases of z3 over spass with soft sorts on and off are .
.
and .
.
respectively.
this means that of the time spass was one to two orders of magnitude slower than z3.
in summary our translation to smt and use of z3 for verification increased the performance of verification of our method by two orders of magnitude and removed all inconclusive results down from an inconclusive rate of around .
c. many sorted vs unsorted performance we observed a drastic improvement in our method s performance by utilizing z3 instead of spass.
however this difference was beyond our expectations and we wanted to investigate the reason behind the performance difference.
this is hard to pinpoint since spass and z3 are fundamentally different.
they utilize a different approach to theorem proving and have different optimizations and heuristics.
during manual investigation of spass s deduction logs we noticed that spass was taking a significant amount of time reasoning about types of quantified variables.
this is true regardless of whether soft sorts are enabled or not.
this reasoning about types would not be necessary or would bedrastically reduced if the theorem prover supported non soft sorts.
even if the model contains a larger number of classes that inherit from one another causing us to introduce predicates and axioms that resemble the ones generated for unsorted logic this type reasoning is constrained to a smaller scope of an inheritance cluster instead of the set of all classes.
we implemented an unsorted translation to smt in order to observe the benefit of using sorts.
because smt lib requires all predicates and functions to be sorted we defined a single sort called sort that we used for all language elements.
since this single sort represents everything we effectively provide no explicit type information.
on top of this sort less system we enforce the type system using predicates and axioms using the unsorted translation presented in section v aa.
thereby we specify the type system in a way that requires type reasoning in a way that corresponds to the amount of information we provide to spass.
we ran the same suite of application models and actioninvariant pairs using the many sorted and unsorted translations to smt.
table ii summarizes the performance of many sorted and unsorted z3 verification.
unsorted z3 did not produce a conclusive result in cases .
.
on average manysorted z3 took .
seconds per case whereas unsorted z3 took .
seconds.
median values are .
for the many sorted logic and .
for the unsorted translation.
the smt propagations columns in table ii refer to the number of dpll t unit propagations done by the prover.
on average the many sorted translation required .
unit propagations before terminating with a median number of .
the unsorted translation required .
propagations on the average with a median number of .
if we were to for each case calculate the ratio between unit propagations taken by the unsorted translation over the number of unit propagations taken by the many sorted translation we get an average of .
and a median of .
.
this means that on average the unsorted translation took .
more unit propagations to terminate when compared to many sorted translation.
finally the memory footprint of verification suffered as well.
the many sorted translation used an average of .12mb of memory per verification case with a median of .47mb and peaking at .16mb.
the unsorted translation was drastically more demanding with an average of .02mb median of .04mb and peaking at .
megabytes.
figure contains data for the unsorted z3 translation in addition to many sorted z3 and spass results.
similarly figure and table iii show the distribution of case by case slowdown factors when comparing unsorted z3 to many sorted z3.
on average the many sorted translation resulted in .
times faster verification compared to the unsorted translation.
the median case is .
and the interdecile range is .
.
.
these results imply a large performance difference between many sorted and unsorted logic verification in z3.
while this does not imply that implementing proper many sorted logic in spass would increase spass s performance by a similar factor it does indicate that the reduction of reasoning induced by many sorted over unsorted logic plays a significant role in the performance gain we observed.
finally in our experiments a large majority of actions preserve invariants.
this is expected as most actions do not affect data in a way that would invalidate invariants.
this is relevant because z3 is optimized to find satisfying instances corresponding to falsification in our encoding and spass is optimized to prove valid theorems corresponding to verification in our encoding .
there were verification cases that were proven to be invalid i.e.
falsified by at least one prover.
in all z3 many sorted proven the case to be invalid successfully and in all z3 unsorted failed to deduce a result.
spass soft sorts on failed to prove of these and spass soft sorts on failed to prove of these.
vii.
r elated work this paper s goal is improving the performance and viability of our previous work on data model verification using theorem provers .
our more recent paper looks into verification of loops using a fol theorem prover spass and how loop verification can be made more viable and better performing.
that branch of research is orthogonal to this work.
coexecutability is applicable to both many sorted and unsorted logic representations regardless of the solution to the empty universe problem.
verification of software using theorem provers has been explored before in projects such as boogie dafny and esc java .
these projects focus on verification of languages such as c c and java whereas we focus on data model verification.
the underlying type systems are largely different as their work focuses on manipulating basic types and pointers whereas our model is based on manipulating sets and relations.
alloy is a formal language for specifying object oriented data models and their properties.
alloy analyzer is used to verify properties of alloy specifications using bounded verification.
since alloy was designed specifically for data model verification it supports sorts and single inheritance.
however it does not support multiple inheritance which would have to be implemented.
furthermore the alloy analyzer uses sat based bounded verification techniques as opposed to our fol based unbounded verification technique.
idaver represents a set of techniques for verification of data model schemas.
among other features it is able to translate data model schemas into smt for unbounded verification.
our models focus on behaviors in data models even they encompass the static data model schema.
in addition our solution supports multiple inheritance.
their solution does not address the problem of sorts and empty universes makingtheir verification unsound.
finally their work does not delve into the difference between logics and their implied encodings.
as part of a research effort to use spass as the theorem prover engine for interactive theorem proving spass was modified to support many sorted logic.
this was done in order to make deduction logs sort aware which in turn makes it possible to reconstruct readable proofs from these logs and show them to the user for the purpose of interactive theorem proving.
they observed an increase in the number of theories spass could solve.
however this modification was done for performance reasons making it reasonable to expect an even larger performance gain from sorts in spass.
the source of this spass modification is not available and so we could not include it as part of our experiments.
there are other theorem provers that can be used for data model verification.
vampire is a high performance fol theorem prover that supports sorts.
snark is another fol theorem prover also supporting sorts.
we plan to as part of our future work implement automatic translation of data models into tptp syntax the syntax of the test suite that is used by the annual world championship for automated theorem proving .
this language is readable by many theorem provers including spass and z3.
however given that many sorted logic has only recently been added to tptp we expect that the highest performing theorem provers are optimized for unsorted logic.
unless the theorem prover integrates sorts within its resolution engine we can expect many sorted logic to perform no better than unsorted logic.
support for many sorted logic is possible to implement syntactically e.g.
by treating sorts as predicates and implicitly introducing axioms that define disjoint universes however this would not result in the performance gains we observed.
in addition to unsorted and many sorted logic there exists order sorted logic .
order sorted logic defines a partially ordered set of sorts and the universes that correspond to these sorts are such that universe of class c1is a subset of the universe of class c2ifc1 c2.
while order sorted logic is highly similar to our data models involving multiple inheritance we are not aware of theorem provers that support it in first order logic with free quantification.
viii.
c onclusion we investigated the differences between first order logic fol variants used by theorem provers and the implications of these differences on data model verification.
we identified two major differences the treatment of the type system and the possibility of empty structures satisfying a given fol theorem.
we formally defined these differences and devised encodings that reconcile them for the purposes of data model verification.
after implementing translations based on these encodings we observed that z3 an smt solver outperformed spass a fol theorem prover on almost all fronts.
using a many sorted logic translation that targets z3 we were able to increase the verification performance by two orders of magnitude while decreasing the number of inconclusive results by one order of magnitude.
with further experiments we showed that encoding our type system using sorts is the cause of this improvement.