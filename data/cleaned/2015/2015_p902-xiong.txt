inner oracles input specific assertions on internal states yingfei xiong dan hao lu zhang tao zhu muyao zhu tian lan key laboratory of high confidence software technologies peking university moe china school of eecs peking university china xiongyf04 haod zhanglu zhutao10 zhumy12 lantian12 sei.pku.edu.cn abstract traditional test oracles are de ned on the outputs of test executions and cannot assert internal states of executions.
traditional assertions are common to all test execution and are usually more di cult to construct than on oracle for one test input.
in this paper we propose the concept of inner oracles which are assertions on internal states that are speci c to one test input.
we rst motivate the necessity of inner oracles and then show that it can be implemented easily using the available programming mechanisms.
next we report two initial empirical studies on inner oracles showing that inner oracles have a signi cant impact on both the fault detection capability of tests and the performance of test suite reduction.
finally we highlight the implications of inner oracles on several research and practical problems.
categories and subject descriptors d. .
testing and debugging keywords testing test oracles assertions .
introduction the capability of a test suite to detect faults is decided by two factors how well the test inputs trigger faults and how well the oracles catch the triggered faults.
traditional research e orts such as test generation and test coverage criteria focus on test inputs.
recently staats et al.
show test oracles are as important as test inputs in deciding the capability of a test suite to detect faults.
traditionally test oracles are de ned on the outputs of test executions .
however there are cases where the faults are triggered but not propagated to the outputs and in these cases we cannot capture the faults using traditional test oracles.
for example a fault may result in an erroneous value in a temporary variable but the later execution may happen to produce the correct result with this wrong value.recently staats et al.
demonstrate that test oracles dened on internal states of the software under test can further improve the power of testing systems.
however the main existing mechanism for checking the internal states is to use the assert statement within production code which is usually de ned to check properties common to all inputs.
such an assertion is not always easy to construct because we need to consider all possible inputs.
in this paper we propose a novel concept inner oracle which is an assertion declared on the internal state and is speci c to one test input.
we show that this concept can be conveniently implemented using existing programming mechanisms is easier to construct than traditional assertions and is useful in many aspects of testing.
we also report two initial empirical studies on inner oracles.
first we performed the rst quantitative study on how much inner oracles can improve the fault detection capability of existing tests and analyzed the reasons why inner oracles outperformed traditional oracles on output.
these results give a direct empirical evidence that supplements the theory of testing .
second we also evaluated how inner oracles help reduce the size of a test suite.
the result indicates potential usefulness of inner oracles in practice.
.
motivation we motivate inner oracles with an example.
the following portion of code de nes a method of determining whether the number of positive elements in a list is larger than that of negative elements.
in particular the method returns 1if the number of positive elements is larger 1if the number of negative elements is larger and 0if the list contains equal numbers of positive and negative elements.
however line is incorrect because it wrongly treats zeros as negatives.
public static int count list integer a int positive negative iterator integer i a.iterator while i.hasnext if i.next positive else negative incorrect if positive negative return else if positive negative return else return this error is obvious but many tests may fail to reveal this error if only the actual output is checked.
the reason is that an incorrect value of negative may not always result in an incorrect output.
for example if the input list isf 4g the preceding code would calculate an incorrect value of negative before executing line but permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
902still can correctly output .
it is not convenient to check the value of negative using an input unspeci c assertion because at least before java another round of iteration over the input list may be unavoidable to obtain the correct number of negative elements in the list.
on the other hand checking with inner oracles is relatively easy given the inputf 4g it is quite convenient to have the assertion assert negative before executing line .
.
approach given that inner oracles can sometimes be more convenient to de ne in this paper we argue that inner oracles should be taken into consideration in both real world testing and research in test generation.
more concretely given a test input and a point of execution with the input an inner oracle asserts whether the actual internal state at that particular point of execution satis es certain properties related to the given test input.
we rst demonstrate that an inner oracle can be easily de ned using the existing mechanisms.
to declare an inner oracle in our running example we can introduce a guard variable when we declare an assertion.
in the running example instead of directly declaring assert negative we can insert the statement as shown in line 6a below else negative incorrect 6a assert !counttest.testguard1 negative if positive negative return the variable testguard1 is a boolean variable declared in the test class counttest .
initially this variable is assigned false so that this assertion is disabled in all tests.
to enable this test for a speci c test input we assign true to testguard1 as shown in the following code.
class counttest public static boolean testguard1 false test public void test1 list integer a ... construct list testguard1 true count a testguard1 false variable testguard1 is assigned true only within the context of the speci c test and thus the guarded assertion is only enabled for the speci c test input while asserting on an internal state of the test execution.
if there is a large number of tests this direct implementation may introduce a lot of guarded assertions into the production code breaking the understandability of the code and causing extra runtime overhead.
to overcome this problem we have built a specialized supporting mechanism for inner oracles borrowing the idea of aspect oriented programming .
in our supporting mechanism inner oracles are declared within test code and are woven into production code at compilation time.
this supporting mechanism is implemented as an open source tool.
more information about this mechanism and the tool can be found at the tool website2.
1in java it is possible to get the value of negative by the high level method filter but this requires advanced knowledge of the language.
enhancing fault detection capability based on the theory of testing adding inner oracles to existing tests should improve fault detection capability.
in this section we try to empirically understand the upper bound of this improvement in practice.
in particular we focus on how much extra improvement can be obtained by adding inner oracles on top of traditional oracles.
in our evaluation we used four java programs as subjects jodatime v1.
.
timeandmoney v0.
barbecue v1.
.
andxmlsec v1.
.
which have been widely used in the literature of software testing and analysis .
we ran javalanche to generate mutants as injected faults.
since the generated mutants are more than we randomly selected .
of mutants as our subjects.
we also manually reviewed the mutants to remove the equivalent mutants.
as a result we got mutants on the programs.
each test and each mutant form a test fault pair and thus we got test fault pairs.
table lists the statistics about the subject programs and the generated faults.
next we classify the test fault pairs by whether the test triggers the fault or not.
the untriggered pairs can be identi ed by examining two causes the test does not cover the mutation the test covers the mutation but the mutation does not change the runtime state.
an example of the second case is mutating a 2toa but ais when evaluating the expression.
the untriggered part in table shows the number of untriggered pairs based on the two causes.
the more interesting category is the triggered pairs.
we further classify these test fault pairs into four categories the original test detects the fault if not adding more traditional oracles on the output can detect the fault if not adding inner oracles can detect the fault none of the above.
the rst category is easy to identity.
to identify the other three categories we try to manually add assert statements to the test code and to the production code as inner oracles.
we constrain that within an assert statement we can only invoke observer methods which do not change the state of the software such as get methods.
we avoid nonobserver methods because in theory we actually changed the test input by calling them.
the classi cation result is shown as detected o detected a detected i undetected in table .
from the result we can see that there are .
.
pairs where the fault is triggered but cannot be detected by traditional oracles on output and these pairs can all be detected by inner oracles.
that is inner oracles may signi cantly boost the faultdetection capability of tests.
to further understand why traditional oracles cannot detect the faults we manually investigated the code and found two main reasons.
the rst one is that the fault results an error in an intermediate state but this error is not propagated to the nal state.
in total of the pairs are caused by this reason.
our running example is also caused by this reason.
the second one is that the fault results an error in the nal state but this error is not visible to the test code due to the accessibility rules e.g.
a private member of an object may contain an erroneous value but this value is 903table statistics of subjects subject kloc method class test mutant pairs jodatime .
timeandmoney .
barbecue .
xmlsec .
table fault triggering capability and fault detection capability of tests subject total untriggered triggered total uncovered equiv total detected o detected a detected i undetected jodatime timeandmoney barbecue xmlsec not accessible by the test code.
on the other hand inner oracles can access such members as they can be declared within the target class.
in total out of pairs are caused by the second reason.
.
reducing test suites since adding inner oracles enhances the fault detection capability of tests it would be interesting to see whether inner oracles help further reduce the size of test suites.
by performing study i in section we had two test suites for each subject project one augmented with traditional oracles and the other one augmented with inner oracles.
then we perform test suite reduction on the two suites to cover the mutants we used in the subjects.
since the test suites with traditional oracles are not able to kill all mutants we only consider the subset of mutants that can be killed by the test suite with traditional oracles.
in particular for jodatime we had mutants for timeandmoney we had mutants for barbecue we had mutants and for xmlsecurity we had mutants.
the test suite reduction algorithm we used is the greedy algorithm by zhang et al.
.
table presents the reduced test suites with and without inner oracles.
row with traditional oracles shows the number of tests in the reduced test suite with added traditional oracles and row with inner oracles shows the number of tests in the reduced test suite with added inner oracles.
since we used a small set of mutants due to the limitation of manual investigation in previous study the reduced test suites are very small.
this result is consistent with existing studies where the size of the test suite shrinks dramatically after reduction.
from the table the test suites with inner oracles are further reduced by .
.
.
that is when inner oracles are used test suites may be signi cantly further reduced.
.
discussion versus test inputs.
in the running example besides adding an inner oracle we can also add a new test with a di erent test input to capture the fault.
this observation leads to the question whether inner oracles are necessary at all.
here we list a few scenarios that inner oracles are more useful than new tests.
first some type of bugs do not a ect the nal state such as the optimization bug discussed later in this section.
adding more test inputs and traditional oracles cannot help catch these bugs.
second additional test inputs lead to longer execution time of the test suite which is one of the main problems in testing large softwaresystems.
third test inputs may not be easily constructible.
in a complicated case a method may depend on a nontrivial global state which requires creating a set of objects and mock objects in case the state of the objects are not easily manipulatable.
versus code refactoring.
another point of view is that when it is di cult to test some part of software it is a smell of bad code and we should refactor the code to enhance testability rather than writing complex testing code or seeking new test mechanisms.
this view is often advocated in text books by practitioners.
for example we can extract two methods from the running example one counting the number of positives and one counting the number of negatives and then we can test the two methods individually without using inner oracles.
however testability is just one quality attribute of the code and there are many other quality attributes that are often contradict with testability.
the above method extractions require to traverse the list twice rather than once which may lead to performance penalty unacceptable in critical code.
a further optimization is that when the number of positives or the number of negatives is larger than half of the list we can directly return the result without looking at the rest of the elements and this optimization is impossible to apply when the methods are extracted.
in those cases inner oracles help maintain the desirable fault detection capability without sacri cing performance.
test optimization.
a common task in programming is optimization.
since optimization does not change the output of the program it would be di cult for a test to check whether the optimization is e ective or not.
on the other hand an inner oracle can easily assert on the internal state to check the existence of an optimization.
for example the following code shows a typical optimization where shift is used instead of multiplication when the parameter bis two.
int times int a int b if b return a else return a b it is di cult to test the existence of the optimization using traditional oracles.
to test the program using inner oracles we can easily add an assertion false right before line for an input where b .
debugging.
during debugging inner oracles usually provide more information for localizing a fault than traditional 904table reduced test suites with and without inner oracles subject jodatime timeandmoney barbecue xmlsec with traditional oracles with inner oracles oracles on the output only the statements executed before the inner oracle may contain the fault rather than all statements executed.
note the information for fault localization is available for tools the same as for human developers so inner oracles also provide opportunities for improving automated debugging techniques.
mutation testing.
our methodology may also have implications on mutation testing .
the long execution time is one of the biggest weakness of mutation testing.
an existing study has found out using weak mutation in which whether a test detects a mutant is decided by whether the mutant results in an incorrect internal state can signi cantly shorten the execution time by sacri cing precision.
with inner oracles the sacri ced precision may be much smaller and research e orts on mutation can put more weight on weak mutation testing.
regression test generation.
a lot of research e orts have been devoted into the generation of regression tests and in particular the generation of test oracles in regression testing .
in the generation of test oracles a major challenge is to know what part of the nal state is a ected by the current test execution and how to access the part of the state using the public members.
with inner oracles considered we can directly generate oracles at the places where internal states are changed without the need to analyze its e ects on the nal state.
furthermore we do not need to construct the access path using the public members because we can directly obtain the path from the statement changing the internal state.
as a result regression test generation can be greatly simpli ed and the generated tests are probably stronger based on our empirical results.
maintainability.
since inner oracles are declared within the implementation of components but not their interfaces inner oracles are likely to be more fragile than traditional oracles on output during the evolution of source code.
as a result further investigation is needed to clarify the maintainability of inner oracles.
however this problem is probably not serious in practice.
first traditional assertions share the same fragility of inner oracles and no maintenance problem is reported for them.
second pinto et al.
demonstrated changing test oracles accounts for only a small portion of test evolution.
although inner oracles is more fragile than traditional oracles on the output the increased maintenance cost on oracles may still be small compared to the overall maintenance cost.
.