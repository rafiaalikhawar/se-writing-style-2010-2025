an industrial experience report on performance aware refactoring on a database centric web application boyuan chen and zhen ming jack jiang york university toronto canada chenfsd zmjiang eecs.yorku.capaul matos and michael lacaria copywell inc. toronto canada paulm michael 2ics.com abstract modern web applications rely heavily on databases to query and update information.
to ease the development efforts object relational mapping orm frameworks provide an abstraction for developers to manage databases by writing in the same object oriented programming languages.
prior studies have shown that there are various types of performance issues caused by inefficient accesses to databases via different orm frameworks e.g.
hibernate and activerecord .
however it is not clear whether the reported performance anti patterns common performance issues can be generalizable across various frameworks.
in particular there is no study focusing on detecting performance issues for applications written in php which is the choice of programming languages for the majority o fw e b applications.
in this experience paper we detail our process on conducting performance aware refactoring of an industrial web application written in laravel the most popular web framework in php .
we have derived a complete catalog of performance anti patterns based on prior research and our experimentation.
we have found that some of the reported anti patterns and refactoring techniques are framework or programming language specific whereas others are general.
the performance impact of the anti pattern instances are highly dependent on the actual usage context workload and database settings .
when communicating the performance differences before and after refactoring the results of the complex statistical analysis may be sometimes confusing.
instead developers usually prefer more intuitive measures like percentage improvement.
experiments show that our refactoring techniques can reduce the response time up to .
and .
for the industrial and the open source application under various scenarios.
i. i ntroduction many of the modern web applications are database centric systems which extensively use the databases in order to accomplish users tasks.
there are many existing databasecentric web applications ranging from enterprise e.g.
content management and enterprise resource planning to consumer applications e.g.
e commerce and discussion forums .
to ease the development processes object relational mapping orm has been introduced as a middle layer between the application code and the database.
it enables developers to manage the database using the same object oriented programming languages and automatically translate the application source code into underlying sql queries.
on one hand the orm layer provides a nice conceptual abstraction andimproves code readability so that developers can focus on their application logic instead of the underlying database accesses.
on the other hand the translation process is not transparent and can often lead to sub optimal performance in both open source and commercial applications .
software performance is one of the crucial factors related to the success of web applications as failing to do so would result in customers abandonment and loss of revenue .
there have been many prior studies that focus on detecting and deriving performance anti patterns a.k.a.
common performance issues in the orm layer.
however they are generally focused on a particular framework e.g.
hibernate for java spring framework or activerecord for ruby on rails .
it is not clear whether the reported performance antipatterns can be generalizable across different frameworks or programming languages as there are many orm frameworks available.
in particular there are no studies focusing on applications written in php which is the choice of programming languages for of web applications .
instead of writing php code from scratch developers usually prefer building their applications based on existing web frameworks which have a set of features e.g.
orm task scheduling and message queues implemented already.
among all the php web frameworks laravel is currently the most popular one .
the orm framework inside laravel is called eloquent .i t is important to study the performance issues across different orm frameworks due to the following three reasons different default behavior depending on the frameworks the default orm behavior can be very different.
for example to find the first object which satisfies a predicate the default behavior for activerecord where .first is to sort the results by their primary keys followed by fetching the first object whereas the default eloquent behavior where first i s to only retrieve the first object without sorting.
hence to ensure the quality of various database centric web applications we need to not only detect general performance anti patterns but also framework specific ones .
different orm configurations some orm configurations are related to the representation e.g.
mapping 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
specific classes to database tables and others are related to their runtime behavior e.g.
caching or data loading .
different frameworks have different ways to specify these configurations.
for example hibernate uses configuration files and annotations whereas laravel uses api calls.
the differences in the configurations would require different detection and optimization techniques.
different analysis tools all the existing orm performance anti pattern detection works e.g.
leveraged program analysis.
such techniques are generally framework and programming language dependent.
to support a different programming language a new parser would be needed for the static analysis.
similarly a different instrumentation framework is needed for the dynamic profiling tools.
in this paper we report our experience on conducting performance aware refactoring on a database centric industrial application written in laravel.
it is performance aware refactoring as our approach detects and refactors performance issues without altering the functional behavior of the applications under study.
the contributions of this paper are this is the first research work which focuses on performance aware refactoring in laravel and php.
we built a catalog of performance anti patterns by studying the prior research works on other programming languages or frameworks and by experimentation on our industrial application.
among them two new antipatterns were discovered by us.
certain anti patterns were framework programming language specific whereas others are general.
the performance impact of the individual anti pattern instance may vary significantly based on the actual usage context workload and database settings .
we have applied our performance aware refactoring approach to the industrial and one popular open source application.
the results show that we can reduce the response time up to .
for these two applications.
the developed techniques have already been adopted and used daily by our industrial partners.
our process and experience will be useful for researchers and practitioners who are interested in optimizing the performance of database centric applications.
paper organization.
the rest of this paper is structured as follows.
section iiexplains the laravel framework and provides some background information about our industrial application.
section iiiexplains our approach using a running example.
section ivexplains the refactoring techniques for detected anti patterns.
section vevaluates the performance improvement.
section vidiscusses lessons learnt.
section vii surveys related work.
section viii describes the threats to validity.
finally section ixconcludes the paper.
ii.
b ackground in this section we provide a background about laravel section ii a and our studied industrial application section ii b .a.
laravel laravel is a very popular web framework for php.
it contains various libraries like an orm framework eloquent and a packaging system.
the applications developed under laravel follows the model view controller mvc pattern.
figure 1shows an example laravel application.
in this example the user makes a request to the orders page.
once the web server receives this request it looks through the routing file web.php to locate the corresponding method the method show in the controller ordercontroller .
the controller ordercontroller then interacts with the model by invoking the order activecount method.
this method accesses the database through eloquent apis e.g.
where andcount which will translate the php code into the corresponding database query and pass it to the database.
the query is executed and the eloquent orm passes the result back to the model class and subsequently to the controller.
the result is stored in the active orders variable in the controller.
this variable is then rendered to the view file index.blade.php as the active variable.
the computed response is sent back and displayed in the user s browser.
in addition to the orm apis from eloquent laravel also provides developers with the choice of querying the database using raw sql queries in the code.
b. our industrial application under study sp is a complex web based consumer relational management crm written in laravel.
it is used for stream lining the process of quoting and ordering printing jobs for consumers.
depending on the jobs many different configuration options e.g.
choice of ink colour of the paper types of printers are needed and specified.
pricing of orders also vary depending on the configured values e.g.
paper and ink costs as well as due dates .
once jobs are created proofs are generated and sent to customers for approval.
historical jobs and their configurations are also stored so that recurrent customers or orders can be conveniently made.
currently the database of sp is around gb and consists of more than tables and over a million records.
one of the main issues with sp is that some pages take a long time to load.
this problem is getting even worse over time since the size of the database is constantly growing every month .
in the next two sections we will discuss about our approach to detecting and refactoring the reported performance issues.
iii.
d etecting performance issues in this section we explain our approach to detecting performance issues in sp.
it is also applicable to other databasecentric web applications written in laravel.
as illustrated in figure our approach consists of five steps literature study dynamic analysis static analysis filtering and deriving new performance anti patterns.
in the remaining part of this section we will explain these steps using a running example which has two page requests activeorders and outsources .
both requests are routed to the same controller ordercontroller.php authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
class ordercontroller public function show active orders order activecount return view index with active active orders request page orders class order extends model public static function activecount return this where status active count p there are active active orders.
p ordercontroller.php index.blade.phporder.phproute get orders ordercontroller show select count from orders where status active database queryeloquent ormroutes web.phprouting controller view model dbms route to appropriate laravel controller interact with model invoke view render response in browser sp fig.
an example of a laravel based web application written in php.
redundant and inefficient dbms accesses orm api misuses static analysis dynamic analysis filteringapplications performance issuesperformance anti patterns source code deriving new performance anti patterns research works literature study fig.
our process of detecting performance issues in laravel based database centric web applications.
but are handled by two different functions showactive andshowoutsource .
the showactive function in the controller subsequently calls the active function from the model order.php .
to save space we only showed the code snippets for the controller ordercontroller.php and the model order.php in figure a .
for the first page request the active function in the order.php retrieves all theorders withactive status and sorts them by the order id id at line .
then it retrieves three particular attributes from the sorted orders price cost and progress at line and .
the above data retrieval processes invoke several eloquent apis where orderby and pluck and the third column of figure b shows the resulting sql queries.
in eloquent line only returns a builder object.developers need to invoke api calls like get executing the query or pluck retrieving a column to execute this query.
hence calling pluck at lines and result in three similar sql queries except selecting different fields in the table.
for the second page request the showoutsource function from ordercontroller.php checks whether there are any outsourced orders at line .
since the where api call is followed by the get call executing this line result in aselect query as shown in the later part of figure b .
step literature study we went through the existing works which focus on detecting performance anti patterns in the database centric applications.
we did not include as it focuses on view centric performance optimization which alters the functional behavior whereas our focus is on performanceaware refactoring.
as a result we compiled a list of performance anti patterns their generalizability and the suggested refactoring techniques.
step dynamic analysis some of the reported anti patterns need to be detected by dynamic analysis.
there have been different approaches to collecting the runtime traces from the applications.
most ofthem areframework e.g.
the rails active support instrumentation apis or programming language specific e.g.
aspectj .
in addition the detection methods vary from dynamic taint analysis to threshold checking .
however all the existing dynamically detected anti patterns authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
2ughu rqwuroohu sks public function showactive activenumber order active orders public function showoutsource if count outsource where type order get this countoutsource 2ughu sks class order extends model public static function active allstats order where status active orderby id asc price allstats pluck price cost allstats pluck cost progress allstats pluck progress d 6rxufh frgh 3djh uhtxhvwhg rgh sdwk xudwlrq dfwlyhrughuv 2ughu rqwuroohu sks vkrz fwlyh !
2ughu rqwuroohu sks !
2ughu sks select price from orders where status active order by id asc pv 2ughu rqwuroohu sks vkrz fwlyh !
2ughu rqwuroohu sks !
2ughu sks select cost from orders where status active order by id asc pv 2ughu rqwuroohu sks vkrz fwlyh !
2ughu rqwuroohu sks !
2u g h u s k s select progress from orders where status active order by id asc pv rxwvrxufhv 2ughu rqwuroohu sks vkrz2xw6rxufh !
2ughu rqwuroohu sks select from outsources where type order pv e 3urfhvvhg gdwd iurp orfnzrun fig.
our running example.
share one common theme focusing on locating inefficient or redundant database computations.
we encoded the user usage using jmeter which is an open source performance testing tool so that the same tests can be replicated and compared across different versions of the application.
to avoid measurement bias and errors each scenario is repeated at least times.
jmeter records the endto end response time for each scenario.
however the timing for each scenario can be broken down into various components like the network transmission time the time spent on loading and displaying the results i.e.
page rendering time the web server processing time and the database query processing time.
to further isolate the timing between these components we used a open source profiler called clockwork .
clockwork is a profiler for laravel based php applications.
clockwork collects various dynamic information e.g.
the request urls the executed source code the invoked database queries and their durations for each page request.
clockwork can be installed as a browser plugin so that the profiling data can be viewed within a browser.
it also stores the profiled information in the web server as a json file for each individual request.
in this paper we leverage the recorded json files as they can be automatically processed.
we used another open source tool called page load time to track the end to end response time and the page rendering time.
for each scenario we correlated the timing results frompage loading time and the profiling data from clockwork .
based on our analysis we found that most of the time consuming steps for sp were about processing the application logic a.k.a.
within the controller the model and the database side .
the time spent on the network transmission and the page rendering was generally very small.
some of the function calls may be time consuming.
but they were actually performing the necessary computation for the complex user requests and should not considered as performance issues.
we would like to only identify problematic areas which are either redundant i.e.
the same php methods or database queries are executed multiple times back to back or inefficient i.e.
very similar database queries are executed multiple times .
we processed the clockwork data to recover the call paths for each database query.
we grouped them based on the requested pages.
figure b shows the processed clockwork data for our running example.
the first column refers to the pages requested.
under the same page request different code paths are executed.
they are shown in the second column of that table.
the resulting sql queries and their execution time are shown in the third and fourth column.
for the activeorders page request there are three queries executed due to the pluck calls at line and .
this is inefficient as the only differences among these queries are the selected columns.
a more efficient solution is to add get at the end of line as it will execute a query to select all columns and store them in the variable allstats .
in this way the following three pluck calls will only retrieve the values of the attributes from the memory.
no further database queries are invoked.
step static analysis the remaining performance anti patterns derived from the prior research are detected statically.
these anti patterns are mostly orm api misuses and complement nicely with the results of our dynamic analysis.
as our dynamic analysis is focusing on redundant or inefficient database queries spanning over multiple lines or even source code files static analysis can pin point other code specific issues.
in our running example from figure a line in ordercontroller.php contains an anti pattern related to the orm api misuses.
the if statement is to check whether there are any outsourced orders.
calling the get api will cause the database to return all the records in the outsource table which has the type value to be order .
this query can be slow if there are many records which match this criteria.
a more efficient approach would be to replace the get method with the first method which only returns the first matching record.
since such static anti patterns were originally studied and specified in other programming languages e.g.
ruby and java we searched for the corresponding problematic eloquent apis from the laravel documentation.
in order to automatically detect these issues we implemented a static code checker which scans through the php code.
our static checker first parses the source code files into abstract syntax trees asts by using a popular open source tool php authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
parser .
then we detected these static anti patterns by traversing through asts and matching them with various regular expressions.
in our running example our checker will extract the condition checks for every ifstatement by analyzing the asts.
among all the condition checks this code snippet is flagged in our tool as it matches with a regular expression count.
get .
s t e p4 f iltering we found that some of the reported code snippets especially the ones detected using our static analysis are dependent on the actual usage context and may not cause performance problems for the end users.
for example some of the detected code snippets might not be executed or the amount of computing e.g.
of database records involved is very small in the actual customer usage context.
since developers have limited time we would like to only pin point the problematic areas which really impact the user experience.
hence in this step we only included the issues existed in the problematic scenarios.
similar to we considered a scenario as problematic if the end to end response time exceeds two seconds.
in our running example the page activeorders takes .
second and the page outsources takes .
seconds.
hence the issue flagged at line of ordercontroller.php was filtered out.
we only reported the issue at line of order.php to the developers.
step deriving new performance anti patterns we reported a set of user impacting performance issues to the developers in step .
for issues which are not detected by the existing static anti patterns we added them into our catalog of performance anti patterns.
the reported performance issue in our running example did not belong to any of the existing performance anti patterns.
we classified them as a new antipattern mid result misuse and added it to our catalog.
for the dynamically detected anti patterns we also encoded them into our static analysis tool so that we can automatically categorize all the reported issues and apply the same suggested refactoring techniques on them.
as shown in the third column of table i we ended up with performance anti patterns in total.
for each anti pattern we assigned them a category an id and a name.
we intentionally used the name of the eloquent apis e.g.
eloquent get in ap in some of the anti pattern names if they are related to the api misuses.
we used the eloquent apis if the antipatterns are general or specific to eloquent as that s the focus of this paper.
for other anti patterns we labeled the applicable orm frameworks to avoid confusion.
among the anti patterns two ap andap are newly discovered in this paper.
there are general anti patterns which are applicable across different orm frameworks.
there are five anti patterns only applicable for activerecord in ruby and one anti pattern only applicable for eloquent in php .
these orm specific anti patterns correspond to some particular api calls in the framework.
among all performance anti patterns there are applicable to !
.
d inefficient !
.
e efficient fig.
an example of loop invariant queries.
laravel.
for the ones that are not applicable to laravel it is mostly due to differences in the apis across frameworks.
for example ap is related to the default behavior of first in activerecord.
this api automatically sorts the results using the primary key and only returns the first row as the result.
such api does not exist in eloquent.
we also showed the refactoring techniques for each anti pattern as well as their origin a.k.a.
the prior research works which reported them .
using the approach described above we were able to detect all of the performance anti patterns applicable to php.
the next section describes the refactoring techniques.
iv .
p erformance awa r e refactoring although there are various techniques to improve the performance of these detected performance issues we only focused on the performance aware refactoring techniques as we intended to minimize the risks of functional behavior changes for the end users.
we used the following process to synthesize the refactoring suggestions for anti patterns which were originally studied in the prior research we tried to apply the same refactoring techniques to the problematic php code.
if the refactoring technique involves api changes we tried to look for similar apis in laravel.
if the refactorings technique involves algorithm changes we tried to re implement them in php.
for newly discovered anti patterns we consulted the developers of sp on how to refactor them.
we verified the validity of all the refactoring techniques by comparing the performance before and after the refactorings.
different frameworks may require different refactoring techniques.
for example in hibernate ap can be refactored by adding annotations or changing settings in configuration files .
in laravel such refactoring technique does not apply due to differences in the orm configurations.
in the rest of this section we will describe the refactoring technique for the performance anti pattern shown in table i. we will skip ap toap as they are not applicable to php.
loop invariant queries description this anti pattern is about repeatedly executing the same queries which return the same results.
these queries are redundant.
figure a shows such an example.
the loop iterates through all tasks.
during each iteration it always queries the total number of orders whose results never change.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i the complete catalog of performance anti patterns.
category id anti patterngeneral orm specificrefactoring origin unnecessary computationap loop invariant queries generalintroducing intermediate variable ap dead store queries generaldeleting unnecessary statement ap queries with known results generalinvolving default behavior ap redundant condition check generalintroducing intermediate variablenew ap mid result misuse eloquentincurring queries in advancenew inefficient data accessingap inefficient lazy loading generalchanging loading configuration ap inefficient eager loading generalchanging loading configuration ap inefficient updating general applying batch updating unnecessary data retrievalap eloquent map general eloquent pluck inefficient computationap eloquent get general eloquent first ap eloquent array sum.
pluck general eloquent pluck.
sum ap eloquent orderby.
count generaldeleting unnecessary ordering ap activerecord where.first activerecord activerecord find by ap activerecord pluck pluck activerecord activerecord union ap activerecord if exists?
activerecordactiverecord find or create by ap activerecord .count activerecord activerecord .size inefficient renderingap activerecord link to activerecord activerecord gsub !
!
d inefficient !
e efficient fig.
an example of dead store queries.
refactoring the refactoring technique for this anti pattern is to move the query out of the loop and assign the queried result to an intermediate variable as shown in figure b .
the performance after the refactoring should improve due to the removal of the redundant queries.
dead store queries description this anti pattern is about storing the results of multiple queries into the same variable some of which are never accessed.
this causes redundancy in the computation.
figure a shows such an example.
the count value computed from the first query is never used.
refactoring the refactoring technique for this anti pattern is to remove the query whose results are used in the subsequently computation.
the performance after the refactoring should improve as the redundant queries no longer exist.
queries with known results description this anti pattern checks if there are redundant queries whose results are known to be empty before computation.
figure a shows such an example.
it invokes take to !
a inefficient b efficient fig.
an example of queries with known results.
return only a pre specified number of records by the variable setting number from the query.
this query will be redundant if setting number is set to be zero.
refactoring the refactoring technique for this anti pattern is to add a condition check as shown in figure b .
the database query will be executed if the value of setting number is larger than zero.
the performance after the refactoring should improve as it prevents unnecessary queries.
redundant condition check new description this anti pattern is about introducing redundant queries in condition checks.
it is a new anti pattern that we have found.
figure a shows one such example.
the if statement checks whether an order has any related customers.
if the condition is true the variable cus will be assigned with the name of the first customer.
under the true branch of the condition check the same queries are executed twice which is unnecessary.
refactoring the refactoring technique for this anti pattern is to assign the query result to an intermediate variable tmp authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
.
d inefficient !
!
.
e efficient fig.
an example of redundant condition check.
a d ordglqj b djhu ordglqj fig.
an example of inefficient lazy eager loading.
shown in figure b .
the performance after the refactoring should improve due to the removal of the duplicated query.
mid result misuse new description this anti pattern is about applying redundant queries on the same builder object.
it is a new anti pattern that we have found.
line in figure a shows one such example.
in eloquent method where does not incur the actual query.
it only generates an instance of builder object.
developers need to invoke apis like get executing the query or pluck retrieving a column to invoke and execute the query.
in this example the three pluck invocations are not needed as they can leverage the results from the same query.
refactoring the refactoring technique for this anti pattern is to add the get api call after where to invoke and execute the query.
the performance after the refactoring should improve as only one query is needed to retrieve the results.
inefficient lazy loading description this anti pattern is about not eager loading the relational data when needed.
figure a shows one such example.
it first retrieves all the records from book .
then it iterates through each book to retrieve the names of the authors.
it will result in n queries query for extracting all the books n queries for extracting the names of the authors for each book.
such computations can be done more efficiently by eager loading all the related data.
refactoring there are three ways to refactor this antipattern to eager load the related data in the first query by adding with call inline as shown in figure b or to eager load the related data by adding a class attribute with or to conduct a left join on thebooks table with the authors table.
the performance !
!.
d inefficient !
e efficient fig.
an example of inefficient updating.
a inefficient b efficient fig.
an example of map .
after the refactoring should improve as only two queries are executed instead of n .
inefficient eager loading description this anti pattern is the opposite of ap .i f the associated objects are too large eager loading everything will create memory bloat which can lead to the slow down of the web applications due to memory paging.
this may also cause the application to be unresponsive.
refactoring the refactoring technique for this anti pattern is to delay the eager loading till later.
as shown in figure a we should not use the with call if the associated author objects are too large.
the performance of the application should improve as the data intensive computation is delayed.
inefficient updating description this anti pattern is about updating records in a loop.
figure a shows one such example.
it iterates through all the orders to update the status to becomplete .
this would cause performance issues as it would incur nqueries where nis the number of records.
refacotring the refactoring technique for this anti pattern is to update records in a batch as shown in figure b .
the performance after refactoring should improve as the number of queries is reduced to one instead of n. eloquent map description this anti pattern is about using map method in php to apply a function on a collection of objects.
if this function involves with database queries this might result in unnecessary computations.
figure a shows one such example.
it first retrieves all the records from the user table.
then it gets their names by invoking the map method.
refactoring the refactoring technique is to use pluck to get specific columns as shown in figure b .
the performance authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a inefficient b efficient fig.
an example of array sum.
pluck .
after refactoring should improve as the database query will only return the specified column s instead of the entire rows.
eloquent get description this anti pattern is about checking whether one or multiple rows exist in the database with certain predicates.
line of ordercontroller.php in figure a shows such an example.
it checks whether there are outsourced orders.
this can cause performance issues as the get method will have the database return all the records in the outsources table with type order .
refactoring the refactoring technique for this anti pattern is to replace the get api call with first which only returns the first record from the result set.
if there are records in the outsource table with order as their type .
calling first will only return one record compared to returning all records by calling get .
eloquent array sum.
pluck description this anti pattern is about using pluck to retrieve the attributes from the queried results and computing the sum on the web server.
large amount of data will be sent from the database to the web server for computing the sum.
this will cause unnecessary overhead as the database can perform the addition efficiently on their end.
figure a shows such an example.
the inefficient code first retrieves the total column of all the records from the bill table.
the results are transmitted to the web server which subsequently computes the sum.
refactoring the refactoring technique for this anti pattern is to apply sum directly after pluck in the code snippet as shown in figure b .
the performance after the refactoring should improve as the web server does not need to receive the large volume of the queried results and perform the computation afterwards.
eloquent orderby.
count description this anti pattern is about counting the total number of sorted entries in the queried results.
the sorting step is unnecessary as it has nothing to do with the counting.
figure a shows an example.
the count method is called after the orderby method.
refactoring the refactoring technique for this anti pattern is to remove the orderby method call in the code snippet as shown in figure b .
the performance after the refactoring should improve due to the elimination of the sorting process.
!
!
a inefficient !
b efficient fig.
an example of orderby.
count .
table ii the evaluation results for sp.
due to page limitation we only showed the anti patterns if they existed in sp.
we marked one anti pattern in bold if p value .05and the effect size is medium or above.
id of effect instances size reduced time ap medium large .
.
ap large .
.
ap large .
.
ap large .
.
ap n a n a ap n a n a v. e v aluation in this section we evaluate the effectiveness of our performance aware refactoring approach.
a. approach for each anti pattern instance a.k.a reported performance issues we compared the performance of sp before and after applying the suggested refactoring technique.
jmeter w a s used to automate the performance benchmarking process.
it executes the pre defined user workload and records the endto end response time for each scenario.
we used jmeter to repeatedly executed each scenario for at least times to avoid measurement bias and errors .
to assess the impact of the refactoring technique each time we only applied refactoring on one anti pattern instance.
we reset the database and rebooted the web server to restore the test environment before each jmeter test.
we performed the non parametric wilcoxon rank sum test wrs to compare the response time before and after refactoring.
in addition to quantify the magnitude of the performance improvement we calculated the effect sizes using a non parametric technique called the cliff s delta cd .
b. result although wrs and cd techniques provided a statistical rigorous view of the performance differences the developers of sp prefer a more intuitive representation.
in particular they would like to know how much faster the performance improves after the refactoring.
hence we just calculate the percentage of improvement before and after refactoring.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iishows the performance assessment results for all the performance anti patterns that we detected and refactored in sp.
fixing instances from ap did not have much performance impact.
it is meaningless to fix the one instance from ap as it was dead code.
in total four out of the six detected anti patterns were considered as impactful in sp.
ap is the most common anti pattern in sp with over one hundred occurrences.
more than ten occurrences of ap andap were also reported.
there were two occurrences of ap .
due to confidentiality concerns we did not show the exact number of anti pattern instances here.
the differences in response time before and after refactoring are statistically significant for all four anti patterns with medium to large effect sizes.
however the performance improvement across different instances of the anti patterns vary significantly.
for example the biggest improvement .
comes from refactoring one instance of ap .
the response time was .
seconds and .
seconds before and after the refactoring.
the impact of refactoring on some other instances of ap is not as big.
for example refactoring another instance of ap only yields .
improvement .
seconds vs. .
seconds .
the smallest performance improvement is from ap reducing .
.
response time after refactoring.
we have reported the above anti pattern instances and their refactoring suggestions to the developers of sp.
they happily accepted our suggestions and applied the changes in their code base.
after applying these changes the response time of sp has been reduced from .
to .
across different scenarios.
one of the comments we received from the developers of sp said you have definitely hit the nail on the head with what you have found so far .
.
this clearly demonstrated the impact of our approach.
summary the statically and dynamically detected antipatterns can have large performance impact on sp.
although some anti patterns are pervasive they may not impact the performance much based on the actual usage context.
the performance improvement due to refactoring may vary significantly across instances of the same anti patterns.
vi.
d iscussion and lessons learned in this section we discuss the lessons learned during our process on detecting and refactoring performance anti patterns.
lesson techniques on detecting and refactoring antipatterns in database centric web applications.
we derived the catalog of performance anti patterns based on prior works in other programming languages and our experience while working on sp.
based on our experience the exsiting technique on detecting and refactoring anti patterns in database centric web applications can be applied to a language and orm framework which have not been applied to.
to demonstrate the generalizablility of this catalog we also applied our approach on another laravel based web application cachet .
it is the open source project with the most stars in github written in laravel.
cachet is a statuspage application which is used to communicate downtime and system outages to users.
since there are no databases which provide the realistic usage context we varied the size of different tables while keeping the same number of records in the database to be .
we chose in this study as a previous work found that it is a realistic setting for many database centric open source applications.
we found five types of anti pattern instances ap ap ap ap and ap which are reported in at least one of the database settings.
we measured the performance impact after refactoring the anti pattern instances.
as a result we achieved up to .
improvement in cachet.
lesson the importance of the usage context for detecting and refactoring anti pattern instances.
for the cachet experiment mentioned above we found if we distributed the contents among the tables differently the performance will vary significantly even if the overall size of the database kept constant.
here we describe the experiments we have conducted on the homepage of cachet.
using our approach there are four types of anti patterns detected.
however by varying the number of records in these two tables components andcomponent groups some antipatterns did not impact the experience of the end users.
we kept the sum of the records in these two tables as .
in one experiment we set the number of records in these two tables as each while in another experiment we changed them to and .
we tried many combinations and measured the resulting performance.
figure 13shows the distribution of the response time for these experiments.
under some experiments the homepage is fast .
seconds whereas for other experiments the response time can be as high as .
seconds.
the above experiments and our experience on sp clearly demonstrate the importance of the usage context workload and database setting while detecting and refactoring antipattern instances.
the developers of sp provided us with a sanitized version of the production database and the user workload.
for applications e.g.
open source or newly developed applications which do not have such information it is important to include the experimented workload and database settings when reporting detected anti pattern instances.
lesson filtering and presenting anti pattern instances to the developers.
since there can be many anti pattern instances and developers have limited time we only kept the detected anti pattern instances if the scenarios under test impact the end user experiences.
same as in we chose two seconds as our threshold.
since we believe if the performance of certain scenarios were poor refactoring any or all the reported anti pattern instances should be helpful.
however based on our experiments in sp and cachet refactoring some anti patterns may have little or even negative performance impactfor example after refactoring some instances of ap in cachet we received negative performance impact .
vs. .
seconds .
therefore one of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dfkhwresponse time vhfrqgv fig.
response time distribution for the homepage of cachet by varying the number of records in different tables while keeping the total number of records the same.
the common questions we got from the developers of sp was on the anticipated performance impact of these anti pattern instances.
there is currently one technique which executes and times the anticipated sql queries after the refactoring .
we are currently incorporating this technique in our approach.
we will first get the estimated timing for various anti pattern instances after refactoring.
different scenarios may invoke code snippets which correspond to the same antipattern instances.
we intend to compute a subset of suggested anti pattern instances using search optimization techniques.
this subset would only contain the smallest number of antipattern instances which have the biggest anticipated performance improvement.
lesson assessing the impact of the refactoring technique.
when evaluating the performance impact of various refactoring techniques the developers of sp found that there is a gap between the perceived differences by human and the statistical differences.
wrs test and cd have been used quite often in the past research works to compare and quantify the differences between two distributions of data.
however in our study we have found that in some cases even an improvement of 30msec can lead to a medium or large effect sizes.
for example refactoring one instance of ap can reduce the average response time from .
seconds to .
seconds.
although the effect size for such change is large the differences can hardly be noticed by users.
therefore we also calculated the percentage of improvement as a way to capture performance changes perceived by humans.lesson static versus dynamic analysis.
we detected performance anti patterns using both the static and the dynamic techniques.
static analysis is easy to apply to the whole code base but not all of the reported issues from them are relevant.
in sp the static analysis reported over instances of ap .
however only a handful really impacted the user experience.
dynamic analysis is more expensive as we need to set up test environments and analyze the profiled information.
however it can be used to discover new anti patterns.
the two new anti patterns ap and ap reported in this paper were discovered via dynamic analysis.
after we discovered the new anti pattern we encoded them into our static detection.
in addition to detecting antipattern instances another objective of the static analysis in our approach is to automatically categorize the dynamically detected performance issues.
the corresponding refactoring techniques can be suggested subsequently instead of manually analyzing the individual code snippets and thinking of ways to improve them.
vii.
r elated work in this section we discuss two areas of the prior research related to our work performance issues in database centric applications and testing database centric applications.
a. performance issues in database centric applications.
smith et al.
were the first to propose a catalog for various performance anti patterns.
some of these antipatterns were related to the ways how the applications performed the database queries.
the database centric applications were implemented differently by then as raw sqls queries were usually specified in the application source code.
to characterize and detect orm anti patterns chen et al studied the performance anti patterns for applications implemented under the hibernate framework in java.
yang et al.
analyzed the bug reports and executed performance tests for open source ruby on rails applications.
they have synthesized nine types of orm level anti patterns.
they also developed an ide plugin to automatically detect and fix these anti patterns .
different from the prior works our work analyzed the applications written in laravel.
our catalog of orm level anti patterns was built by studying these prior works and applying them to laravel based open source and industrial applications.
during this process we also found two additional performance anti patterns.
we also reported a series of lessons learned based on the challenges that we have faced and the feedback gathered from the developers.
b. testing database centric applications mcminn et al.
and kapfhammer et al.
proposed a set of test coverage and adequacy criteria to assess the quality of test suites for database centric applications.
grechanik et al.
proposed new approaches to preventing database deadlocks and automatically reproducing deadlocks for testing purposes.
our work is related to taneja et al.
in which they discussed the obstacles and challenges authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of anonymizing the production databases for the outsourced testing teams.
they showed that the application s functional behavior code coverage can vary if the database fields were not properly sanitized.
our work is focused on the performance aspects related to the different settings of the database.
while keeping the same number of records in the database we have shown that the application performance can vary significantly by changing the number of records among different tables.
viii.
t hreats to validity a. external v alidity we have only demonstrated the generalization of our approach to laravel based applications by applying it on one industry and one open source application.
there maybe additional performance anti patterns unreported and our refactoring techniques can be just one of the many solutions to improve the performance of these anti patterns.
b. construct v alidity during the anti pattern detection phase we leveraged the clockwork data to find the mappings between the source code and their corresponding database queries and to gather the response time on invididual database queries.
such information is accurate as the monitoring overhead for clockwork although high is mainly imposed on the web server and has little impact on the database processing and the page rendering.
we turned off clockwork and only collected the end to end response time from the jmeter when assessing the performance impact of various refactoring techniques.
c. internal v alidity one scenario may contain multiple anti pattern instances.
the performance of the same anti pattern instances may vary significantly based on the usage context.
when assessing the performance impact of different refactoring techniques each time we only fixed one anti pattern instance and measured its response time.
we restored the database and restarted the web server for each experiment.
this process was repeated for all the anti pattern instances.
ix.
c onclusions databases play a key role in modern web applications.
many developers leverage orms to access databases to avoid directly interacting with them.
however such setup may not yield optimal performance.
in this paper we reported our experience on conducting performance aware refactoring on database centric web applications written in laravel.
our complete catalog of performance anti patterns which consists of existing and new anti patterns were derived from existing research literatures and dynamic analysis on sp.
experiments show that refactoring these anti pattern instances may result in up to .
response time reduced in sp and cachet.