what change history tells us about thread synchronization rui gu3guoliang jin4linhai song1linjie zhu1shan lu2 1university of wisconsin madison usa2university of chicago usa 3columbia university usa4north carolina state university usa abstract multi threaded programs are pervasive yet di cult to write.
missing proper synchronization leads to correctness bugs and over synchronization leads to performance problems.
to improve the correctness and e ciency of multi threaded software we need a better understanding of synchronization challenges faced by real world developers.
this paper studies the code repositories of open source multi threaded software projects to obtain a broad and indepth view of how developers handle synchronizations.
we rst examine how critical sections are changed when software evolves by checking over revisions of four representative open source software projects.
the ndings help us answer questions like how often synchronization is an afterthought for developers whether it is di cult for developers to decide critical section boundaries and lock variables and what are real world over synchronization problems.
we then conduct case studies to better understand how critical sections are changed to solve performance problems i.e.
over synchronization issues and how software changes lead to synchronization related correctness problems i.e.
concurrency bugs .
this in depth study shows that tool support is needed to help developers tackle over synchronization problems it also shows that concurrency bug avoidance detection and testing can be improved through better awareness of code revision history.
categories and subject descriptors d. .
testing and debugging general terms reliability keywords locks empirical study repository mining concurrency bugs performance bugs multi threaded software supported in part by nsf ccf grants and an alfred p. sloan research fellowship.
.
introduction .
motivation multi threaded programs are pervasive yet di cult to write.
in particular thread synchronization is challenging.
missing proper synchronization causes correctness bugs such as data races and atomicity violations while over synchronization causes performance problems .
better understanding of real world synchronization challenges is needed to ease the development process and improve the correctness and e ciency of multi threaded programs.
to achieve such an understanding previous studies often resort to open source bug databases .
these databases contain detailed information of reported bugs including diagnosis discussion source code and patches.
such information has enabled previous studies to motivate and guide a wide variety of concurrency bug research.
unfortunately since many real world software projects are complicated and quickly evolving a lot of important information such as the following is buried in the code revision history and cannot be obtained from bug databases alone information that goes beyond bug reports.
developers conduct synchronization related code development and maintenance for performance enhancement functionality changes readability improvement and others.
these tasks are all important and e ort consuming.
they rarely if ever get re ected by bug databases.
even for correctness bugs some of them may be xed in the code repository but are never reported in bug databases.
information that is scattered over multiple versions of source code.
how is a concurrency bug introduced by code revision?
di erent patterns could imply di erent short cuts for bug avoidance detection and testing.
how is a critical section formed is the lock and unlock typically introduced together with or after the critical section body?
these two di erent scenarios would demand di erent tool support for developers.
how often are the lock variable and boundaries adjusted for a critical section?
specialized tools may be needed for these adjustments.
none of these questions can be answered by checking one version of source code alone or by checking the bug databases alone.
information that hides within the whole revision history.
we have to study a long history to understand trends like whether the synchronization problem is getting more di cult with software getting more mature and whether a critical section is more likely to change when it ages.
permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for third party components of this work must be honored.
for all other uses contact the owner author.
copyright is held by the owner author s .
esec fse august september bergamo italy acm.
the above information can provide insights for the design of new language features analysis tools run time systems and code development tools.
it can also shed light on new research directions such as incremental bug detection synchronization change impact analysis synchronization change prediction over synchronization detection and xing and others.
unfortunately collecting the above information is challenging.
revision histories of large projects are di cult to study due to their huge volumes.
for example each version of mysql database contains about four million lines of code.
its repository contains about code versions facing these many lines of code a lot of program analysis cannot scale not to mention manual inspections.
without careful planning and trade o s the study will fail.
.
contributions we study the code repositories of open source multithreaded software along several directions to better understand synchronization challenges encountered by developers.
general study we study how lock protected critical sections are changed when software evolves.
for this study we design a hierarchical taxonomy for all critical section changes based on their structural patterns and purposes.
with this taxonomy in mind we look at allthe code changes in the publicly available code repositories of four representative open source c c software projects.
these repositories contain more than revisions in total and have years of code development history.
while studyinghow many changes are there under each category why these changes are made and when these changes are made we have made interesting observations for a notable portion of critical sections in our study the surrounding lock and unlock is introduced after the enclosed code body.
in many cases the lock synchronization and the code body should have been introduced together but developers forgot the synchronization.
in other cases software changes bring new and unsafe way of data sharing and hence demand extra synchronization in old code regions.
more than three quarters of critical sections in mysql and apache code repositories are modi ed or removed.
more than a quarter of critical sections in our study have synchronization adjustments such as critical section boundary movement and lock variable changes.
developers need tool support to gure out synchronization details and to keep the synchronization correct and e cient during constant code changes.
the number of critical section changes remain stable when software ages but decreases signi cantly when a critical section ages.
changes that improve performance or x bugs often happen at a much older age of a critical section than other types of changes.
fixing correctness bugs is one of the most common reasons for critical section changes.
enhancing performance is not as common but still non negligible leading to nearly of critical section changes sampled by us.
this study provides motivations guidelines and benchmarks for several lines of research such as synchronizationrelated change impact analysis performance andcorrectness oriented synchronization maintenance i.e.
adjusting existing synchronization locations and variables over synchronization detection and xing etc.
more details are presented in section .
all the scripts and results from our study will be released.
in depth case study following the above general study we conduct case studies to better understand oversynchronization issues i.e.
unnecessary synchronization degrades execution performance and concurrency bug issues i.e.
lack of or incorrect synchronization hurts execution correctness .
for over synchronization issues we manually studied randomly sampled critical section changes that are used to improve synchronization performance.
our study shows that over synchronization is a real issue in practice and is cared by real world developers.
when developers change critical sections to alleviate over synchronization they struggle with synchronization correctness reasoning lockvariable management and code refactoring.
tool support is needed to help tackle these problems.
more details are in section .
for concurrency bug issues we manually studied the origins of concurrency bugs to see how they are introduced by code revisions.
since this study often requires much deeper understanding of bugs than what change logs provide some of these bugs are sampled from the change history study mentioned above and some are from real world bugs widely used by previous concurrency bug research .
this study reveals interesting ndings that can help improve the scalability and accuracy of concurrency bug detection including the following with more details in section .
over half of these bugs are introduced under old synchronization contexts i.e.
surrounding locks preceding barriers waits etc.
that are completely unchanged by bug introducing revisions.
this indicates that synchronization analysis can be greatly simpli ed in concurrency bug detection and testing when exploiting code history information.
about half of these bugs only involve shared variables and memory access instructions that are newly introduced by the bug introducing revision.
this indicates that memory access analysis can be greatly simpli ed in concurrency bug detection and testing when exploiting revision information.
.
methodology this section presents the methodology of our general study about critical section changes.
software and bug sources we study four representative c c open source software projects as shown in table .
they are all large and mature projects under active development with millions lines of code in each version and years of repository history.
our study looks at allthe publicly available revisions2from their version control systems svn for apache and mplayer mercurial for mozilla and bazaar for mysql .
duplicate revisions mainly caused by revision merging are pruned out.
1we will refer to critical section as cs.
2we will use revision and version interchangeably.
427table applications used in the study all cs all unique cses in the repository each of which could live through many revisions added cs cses added since the rst version all csare more than added cs as some cses exist in the initial code image section discusses how we count cses.
application repository info.
latest version period rev.
rev.
size avg.
loc all cs added cs size loc apache httpd web server 258k mozilla browser suite .17m mplayer media player 448k mysql database server .91m table taxonomy of changes body the code region enclosed by lock and unlock in a cs synchronization variable lock variable synchronization primitive di erent types of lock operations structural patterns add adding cses add all synchronization and body added together add syn synchronization introduced after body rem removing cses rem all synchronization and body removed together rem syn synchronization removed alone mod modifying existing cses mod body critical section body modi ed mod syn critical section synchronization modi ed mod synv synchronization variable modi ed mod synp synchronization primitive modi ed mod synb critical section boundary moved mod syns critical section split mod synu adding unlock operations purpose patterns correctness fixing functional bugs functionality adding or changing code functionality maintainability code refactoring performance improving performance robustness adding sanity checks taxonomy our categorization follows two dimensions structure and purpose as shown in table .
study mechanisms accurate categorization requires inter procedural controlow and pointer alias analysis which unfortunately cannot scale to large code repositories.
we choose to use regular expression based python scripts as it o ers us the best balance between complexity and accuracy.
alternative approaches like ast based analysis o ers little accuracy increase while more sophisticated analysis would not scale.
given the complexity constraints we only consider cses that start and end in the same function.
for each version in the code repository our script conducts three step analysis for each line ithat appears in the di between this version referred to as new below and the previous version referred to as oldbelow.
the di is obtained through commands like svn diff .
first identifying the innermost enclosing csofi denoted asc.
this is achieved by searching backward and forward from iwithin the function that contains i examining every lock acquisition statement lock release statement as well as the lock variables used by these statements.
if no csis found to enclose i the next two steps are skipped.
second identifying cses corresponding to cin the other version i.e.
old or new version depending on which ver sioniis from .
to achieve this we identify all unchanged statements in cand nd each such statement s innermost enclosing csin the other version.
if multiple unique cses are found we discover a cssplit mod syns acsremoval rem or an adding unlock mod synu .
if no csis found we discover a csaddition add or removal rem depending on iis from the new or the old version.
if exactly one csc0is found we go to the third step.
third checking the lock and unlock operations of cand c0to identify body changes boundary changes synchronization primitive changes lock variable changes and so on.
due to space constraints some analysis details such as more detailed categorization and comments handling are skipped.
manually checking randomly sampled categorization results from our script shows that the false positive rate of our script is below .
our script makes the least accurate categorization for add synand rem syn when insigni cant statements appeared before the synchronization enclosing them were added or remained after the synchronization enclosing them were removed.
we use the identity of lock acquisition function to uniquely identify each cs.
one lock acquisition followed by multiple releases is counted as one cs.
we also use the di mechanism to connect the same lock acquisition function in di erent versions so that we can track the changes of one csthroughout the software change history.
the lock and unlock primitives considered by our script are obtained by key word search lock latch and mutex in the four software projects under study.
about half of mozilla cses are protected by autolock a scope lock that releases at the end of its current scope.
we handle it slightly di erent from basic locks and hence have no information about csbody change mod body cssplit mod syns and adding unlocks mod synu for autolock .
we will discuss mozilla results with and without considering autolock separately in section .
threats to validity due to the huge amount of code under study we intentionally trade o some analysis accuracy for analysis speed and hence could miss some cs changes.
first cses that start in one function and end in another are not identi ed.
second if two pointers p1 and p2 point to the same lock a cssurrounded by lock p1 and unlock p2 is not recognized heap based locks may also cause inaccuracy when we count lock variable changes mod synv .
third changes inside functions called by a cs are not considered for that cs.
furthermore like all empirical studies our study cannot cover all software projects in the world.
it also cannot cover code changes not committed to the code repository.
3global and heap locks are similarly common in our study.
428even with the above caveats we believe our study will provide valuable observations and guidelines for future synchronization related research for two reasons.
first our counting is mostly accurate.
the rst two issues mentioned above are rare for cses in real world software.
our manual checking of randomly sampled script results shows that our script has lower than false positive rate.
second the inaccuracy does not a ect the main observations and implications of our study.
for example since we focus on synchronization challenges the inaccuracy in counting cs body changes e.g.
not considering callee changes or not considering body changes in autolock cses does not a ect our main observations.
we could miss some mod synv cases due to heap locks but this does not invalidate our observations such as synchronization adjustments are common.
overall our study represents our best e ort of understanding csrelated changes in widely used c c opensource software projects.
our methodology takes a trade o that is suitable for our goal.
all results from this study are cross checked by multiple people.
all ndings below should be interpreted with the above methodology in mind.
we will release all our scripts and results together with the paper.
.
critical section changes .
observations .
.
how many changes are there?
how many changes for each pattern?
the total number of changes ranges from in mplayer to in mysql as shown in table .
the three major patterns add rem and mod are about equally common.
all sub patterns except for removing synchronization alone rem syn and cs split mod syns each contributes to at least .
of all changes and a ects at least .
of all cses as shown in table and .
we discuss most common patterns below and some interesting but less common patterns in section .
.
.
add add all vs add syn adding cses contributes to of cschanges in four projects.
the ratio between add alland add synare around to .
introducing lockand unlock after thecsbody is not rare.
rem rem all vs rem syn csremovals are about as often as additions.
di erent from add syn removing synchronization separately from the csbody rem syn is rare.
mod mod body vs mod syn modi cations happen more frequently to the body of a csthan to the lock unlock synchronization.
however modi cations to synchronization are non negligible contributing to of all modi cations and involving of all cses in our study.
mod synp changing synchronization primitives are quite common in apache mozilla and mysql.
they are mainly due to three reasons functionality enhancement that allows lock pro ling and deadlock monitoring which happens in both mysql in mysql mutex and mozilla in autolock performance enhancement such as replacing regular 4as mentioned in section we will present mozilla results with and without considering autolock separately in table table and figure .
for consistency all the numbers presented in the text of this section consider basic locks only all the qualitative observations presented here are true for both considering and not considering autolock .
we will also discuss autolock changes at the end of this sub section.table number of changes with certain pattern subscripts in mozilla column are autolock numbers apache mozilla mplayer mysql add add all add syn rem rem all rem syn mod mod body n a mod syn mod synv mod synp mod synb n a mod syns n a mod synu n a all changes table number of cses w speci c modi cations the subscripts in mozilla column are autolock numbers apache mozilla mplayer mysql mod mod body n a mod syn mod synv mod synp mod synb n a mod syns n a mod synu n a allcses locks with reader writer locks xing bugs introduced by earlier primitive changes which happens in mysql readability enhancement through wrapper functions.
how many changes for each cs?change is the norm.
as shown by figure only about of cses have encountered no changes after being added to apache.
this ratio is around for mysql and mplayer and higher for mozilla likely because mozilla has the youngest code repository.
the majority of cses that have been changed modi ed or removed are changed for times throughout the revision history as shown in figure .
of course highly changed cses do exist.
mysql and apache each has more than ofcses changed for more than times.
for example a line csin mysql was changed for times in years.
statistical correlation test we use spearman s rank correlation coe cient to explore what features are most correlated with the number of changes to a csc.
we consider three sets of features features re ecting the property of citself including length and age features re ecting the le fholding c including the number of revisions that involves f the number of cses inside f and the total number of changes to other cses in f features re ecting the lock vthat protects c including the total number of cses protected by v and the total number of cschanges to other cses protected by v. our data set includes all cses protected by global locks5in the latest version of mysql.
results show that among all the features under comparison 5we cannot accurately know which cses share a heap lock.
a mysql b mozilla c apache d mplayer figure cumulative distribution of changes encountered by each cs csadditions are not counted the dashed line also considers autolock table purposes of cschanges apache mozilla mplayer mysql tot.
correctness functionality maintainability performance robustness total the number of mod body changes and the number of mod synb changes to a cscare most correlated with c s size the number of changes of other patterns and the total number of all changes to care most correlated with the number of total revisions involving le f. these are all statistically strong correlations.
autolock in mozilla about half of the cses in the latest version of mozilla use autolock .
since autolock was introduced later than the basic lock in mozilla the code repository contains many more activities associated with it than basic lock as shown in table and .
as we can see from the tables and gures above the observations discussed above apply to both basic lock cses and autolock cses.
specifically for autolock cschanges the ratio between add all and add synis about csremovals are common as well ascsadditions synchronization changes are common for autolock cses.
these are all similar with non autolock cschanges.
in comparison an even larger portion of autolock cses went through changes in mozilla.
due to the similarity between the change patterns of basic cses and autolock cses we will not separately discuss them for the remainder of this paper.
.
.
why did changes happen?
to understand change purposes we manually investigate randomly sampled changes.
general purposes table shows the purpose breakdown of randomly sampled changes with from each software project.
as we can see correctness xes functionality changes and code refactoring are almost equally common each leading to about of all changes.
performance enhancement is not negligible leading to .
of changes.
pattern speci c purposes due to space constraints we only discuss the purpose break downs of ve structural patterns in table and below.
we sampled cases for patterns that have more than changes add synand mod synv cases for patterns that have fewer than total changes mod syns and for the other two patterns.table purposes of changes w di erent patterns robu.
main.
func.
correct.
perf.
tot.
add syn mod synv mod synb mod syns mod synu add syn when lock and unlock synchronization is added around a code region it is always for avoiding concurrency bugs.
to understand why the lock and unlock was not added earlier we further studied the code change history for cases.
in cases synchronization was not needed when the code region was rst introduced but was demanded later due to software changes.
in all other cases not adding lockand unlock together with the csbody is buggy.
mod synv interestingly more changes are made for performance reasons where ne granularity locks replace coarse granularity locks than for correctness reasons.
mod synb boundary adjustments are quite common affecting almost of all cses.
they are mainly used for xing concurrency bugs where code regions right outside a csshould be moved inside to avoid atomicity violations.
mod syns splits are not common maybe because they are complicated to reason about which will be discussed more in section .
in out of examined cases splits are conducted to avoid blocking competing threads for too long and hence to improve performance.
in one case the csis split to x a deadlock bug in another case the split moves part of the csearlier to x an order violation bug.
mod synu adding unlocks have happened to .
of cses.
more than half of these are simply because developers forgot to release a lock particularly on error handling paths right before function returns.
.
.
when did changes happen?
regarding software age as we can see in figure the number of changes is relatively stable over the time not getting signi cantly more or less with software getting older.
probably not surprisingly the number of cschanges and the lines of changed code roughly follow the same trend over time as shown in figure .
based on spearman s rank correlation coe cient and z test these two sequences indeed have strong correlation in all four projects with statistical con dence.
regarding csage as we can see in figure the change frequency of a csdoes drop with the csgetting older.
of changes to a cshappen within the a mysql b mozilla c apache d mplayer figure number of cschanges shown by solid red lines and lines of changed code shown by dashed lines over software ages.
we compute software age by counting how long the software has lived since its rst publicly released version the dotted blue line in mozilla gure also considers autolock .
a mysql b mozilla c apache d mplayer figure percentage of cumulative changes over the age of cses csadditions not counted the dashed curve in mozilla also considers autolock .
rst two months of the csbirth in mozilla apache and mplayer.
among the changes that happen after two years of acs s birth the most common pattern is csbody modi cation followed by csremovals.
performance vs. correctness one might wonder whether performance enhancement changes tend to happen at older ages of a csthan correctness bug xing changes.
after checking changes sampled from each type t test shows that the di erence between these two is notstatistically signi cant.
in fact the average csages for both types of changes are around years much larger that of all changes which is around year.
.
discussion to lock or not to lock?
that is a di cult question.
for as many as of csadditions in the studied projects lock and unlocks are added after cs bodies.
according to our manual check many of these csbodies should have been protected from the very beginning out of sampled cases while developers ignorance of synchronization needs caused concurrency bugs.
in other cases where locks were not needed at the beginning out of cases developers had to track software changes and add extra synchronization to previously implemented code regions.
making things more complicated csremovals are almost as common as additions.
this further burdens developers with synchronization decisions.
this part of study further motivates concurrency bug avoidance and detection research it is very common for developers to forget locks when they implement newcode.
it also calls for tool support that can analyze software changes and infer changing synchronization needs on oldcode regions which will guide developers to add or remove locks in old code regions.
this has not been well studied in the past.
to un lock here or there?
to lock aorb?
these are di cult questions.
our study shows that af ter recognizing the need to synchronize deciding the details of synchronization is di cult.
adjusting lock and unlock locations mod syns mod synb mod synu lock variables mod synv and lock primitives mod synp of existing cses are common tasks for developers.
altogether they contribute to more than of all csmodi cations and a ect about a quarter of all cses mod synin table and .
this part of study calls for tool support to decide synchronization details a tool that can automatically adjust the boundaries and lock variables of existing cs es with both correctness and performance in mind.
this is di erentfrom generic concurrency bug detection or xing tools.
speci cally synthesizing all the synchronization in a large software project from scratch is probably unfeasible.
however automating the adjustment process is not only feasible but also very helpful.
it can leverage the common adjustment patterns taken by developers as well as previous work on concurrency bug detection xing and lockinsertion .
it will relieve developers burden of synchronization changes i.e.
mod synb mod synp mod syns mod synu mod synv .
how common are correctness and performance problems?
correctness is behind a signi cant portion of all changes .
performance changes are also not rare .
and are a big part of synchronization modi cations and removals as shown in table .
furthermore the real problem could be more than what re ected by changes because developers may not realize problems in their software.
this results further indicate that research support for both synchronization correctness and synchronization performance is needed.
more studies along these two directions will be presented in section and .
are synchronization problems getting harder or easier with software evolving?
our study shows that synchronization problems are a common theme for an evolving software.
inevitably functionality changes robust431ness enhancement and others would happen inside existing cses.
even when existing cses become stable new cses are introduced with software evolving.
fortunately the four projects under study have shown no sign of synchronization problems getting worse with software getting larger older.
how about other types of synchronization?
apart from locks condition variables are the second most popular synchronization primitive in c c programs.
we studied all changes to condition variable signal wait operations in these four software projects.
we brie y discuss main observations below.
first signal wait changes are common especially considering the number of signal s and waits in each code version.
for example the latest version of mysql contains signal wait operations fewer than1 10th of lock unlock operations while the code repository contains changes to signal s and waits.
second many changes are made to adjust existing signal wait pairs.
across these four projects of signal orwait changes are made without accompanying wait orsignal changes.
we consider a signal change and await change to accompany each other if they are from the same revision and use the same condition variable.
third a big portion of changes are made due to correctness issues.
among the randomly sampled cases about of them are made for avoiding concurrency bugs.
overall developers have to frequently adjust synchronization details such as where to signal for given waits or where to wait for given signal s to avoid concurrency bugs.
tool support will be useful.
summary the study above shows that good tools are needed to help judge whether there is a need for adding for both newly written code and already existing code or removing lock synchronization adjust synchronization details for performance and correctness concerns which applies to both lock synchronization i.e.
adjusting cs boundaries and variables and condition variable synchronization i.e.
adjusting signal s and waits tackling over synchronization issues and others.
.
over synchronization study over synchronization happens when unnecessary synchronization is added to the software.
it would overly constrain software interleaving and lead to performance degradation.
although many empirical studies have looked at realworld concurrency bugs almost nostudy has focuses on how developers handle over synchronization problems in real world.
it will be the focus of this section.
table over synchronization related changes apache mozilla mplayer mysql mod synv mod synb mod syns total .
methodology and threats to validity following the study in section .
.
we focus on three types of cs changes with dense population of oversynchronization issues mod synv mod syns and mod synb.lock lock thread count while tmp it if ... expensive operation tmp lock tmp lock delete break unlock lock thread count if ... expensive operation tmp unlock tmp lock delete figure a cssplit from mysql r1233 among the cases in table these three patterns provide changes that x relieve over synchronization issues as shown in table .
note that over synchronization goes far beyond these cases which are collected from and randomly sampled mod synv mod syns and mod synb changes.
they do not cover all over synchronization issues xed by these three types of changes not to mention over synchronization issues xed by other types of changes.
there are also oversynchronizations not xed yet which might be many given the preliminary support for over synchronization detection and xing.
these cases serve as a starting point of understanding real world over synchronization issues.
.
observations where to apply the changes naturally these three types of over synchronization xes are typically applied to cses with highly contended locks and time consuming operations such as system calls and the processing of big datastructures.
for example three mysql split cases relieve the contention on lock thread count which is a hot lock used by more than cses including four sections invoked during every iteration of busy loops.
as another example mozilla r166150 helps relieve the contention on globalmutex a default lock shared by cses in mozilla icu component.
how to conduct mod syns conceptually a split cuts acscprotected by lock linto at least two parts c1and c2 each protected by a lock.
conducting a split involves several challenges how to protect the split out code how to protect the newly created gap between c1andc2 how to re structure the code to complete the split.
for the rst issue in about half of the cases every split is still protected by the original lock such as that shown in figure in the other cases the split out code is protected by a di erent lock that is more specialized such as the perobject tmp!lock delete replacing the original global lock lock thread count shown in figure .
for the second issue in about half of the cases c1andc2 do not need to be put inside one cs.
they were put together due to code structure readability bene ts as shown in figure .
in other cases c1andc2were intended to be atomic together.
the developers had to play some tricks such as making the lock protecting c2 which is di erent from l also protect part of c1 mysql r4591 or copying the values of some shared variables used by both c1andc2into local variables e.g.
ncell in figure .
sometimes developers made semantic sacri ces to enable the split.
for example 6throughout the paper denotes lines added by a revision denotes lines deleted by a revision the code shown in gures is simpli ed for demonstration purpose all comments are added by authors.
432lock btr search latch ncell hash get n cells hash index for i i ncell i for i i hash get n cells hash index i if i!
i chunk size unlock btr search latch os thread yield lock btr search latch ... unlock btr search latch figure a cssplit from mysql r2121 after the cssplit in mysql r4591 show global status can no longer guarantee to aggregate the status information of all active threads.
the third issue is surprisingly tricky.
naively if a csonly contains straight line code it can be split by simply inserting an unlock and a lock.
the reality is more complicated due to control ows particularly loops surrounding the cs as demonstrated in figure .
how to conduct mod synv changing lock variables mainly involve two challenges selecting a new lock nding all cses that need lock variable replacement.
surprisingly in all cases under study the original lock is replaced by a brand new lock newly declared and introduced into the software in the corresponding revision.
in about half the cases the newly introduced lock is only used to protect one static code region making this region safe to be executed by multiple threads in parallel.
in ve cases a global lock is replaced by per object locks.
in other cases global locks are replaced by more specialized global locks.
finding all cses that need lock variable replacement is an error prone process.
although not related to oversynchronization apache httpd once tried to rename a lock from proxy module mutex toproxy mutex .
developers kept missing cses and took four revisions to nally nish all the needed replacement which introduced bugs.
how to conduct mod synb the key challenge in boundary change is to identify a code region near the boundary of a csthat can be moved out without introducing concurrency bugs or damaging data dependency.
sometimes this reasoning is easy.
for example mysql r300moves a condition variable broadcast out of a cs.
sometimes this requires more program semantics knowledge.
for example in mysql r152 developers realize that their code only reads one log entry instead of multiple and hence can be conducted outside the cs.
.
discussion over synchronization is a real problem and is cared by developers.
developers change synchronization primitives to enable lock contention pro ling in mysql and mozilla and sometimes relieve over synchronization at the cost of code readability or functionality figure and .
our study demonstrates that discovering and xing oversynchronization take a lot of manual e ort and are error prone.
all three types of changes xes discussed above can potentially introduce concurrency bugs and demand non trivial synchronization correctness reasoning.
many new lock variables are introduced during these xes mod syns and mod synv .
the ad hoc way of introducing these variables can easily lead to correctness and or maintenance problems.
the code movement during these xesis often non trivial and could break single thread semantics mod syns and mod synb .
our study also shows that it is feasible to develop tools to automate part of the over synchronization detection and xing process.
some common patterns of mod syns mod synv and mod synb discussed above can help build such tools.
a large part of over synchronization reasoning is about synchronization correctness which is shared by previous research on concurrency bugs.
language and run time techniques may also help transparently address some of these issues.
.
concurrency bug origins .
methodology and threats to validity software and bug sources concurrency bugs used by this study come from two sources.
the rst includes all28 real world concurrency bugs coming from more than ten widely used c c software projects repeated and evaluated in four recent concurrency bug papers .
this is our main source because the root cause of these bugs are well understood which allows us to accurately identify their origins and these bugs have been widely used as benchmarks in state of the art concurrency bug literature .
in our work for each bug we manually checked the user reported buggy version and all the related previous versions to identify at which version the bug was introduced.
the second source is our critical section change study.
we check the origins of randomly sampled concurrency bugs whose root causes are described in the revision log.
we did not use more cases from this source because revision log often does not describe bug root causes in detail and hence is not a good source for our in depth bug origin study.
taxonomy our categorization is based on three key ingredients of a concurrency bug shared variable s instructions accessing these shared variables and synchronization contexts such as surrounding locks and preceding barriers that fail to enforce correct ordering among these instructions.
the code revision that introduces a concurrency bug referred to as buggy revision must bring some or all of these ingredients into the software.
our categorization is based on which ingredients are introduced.
study mechanisms none of the bugs studied here have their origins mentioned in the bug reports or revision logs.
for each bug we rst understand its three key ingredients and then manually search through the corresponding code repository for the rst version that contains all ingredients.
threats to validity due to di culty of identifying bug origins we choose to focus on bugs that have been repeated and hence can be thoroughly understood in order to provide accurate results.
the trade o is that there are not many real world c c concurrency bugs that have been repeated and discussed in research literature.
we checked allreal world c c concurrency bugs used by a set of recent work without any bias.
we also complement the above bug suite with randomly sampled bugs whose xes are mentioned in the revision logs.
one possible and uncontrollable bias is that bugs with complicated root causes may be less likely to get repeated by previous research or discussed in logs.
having said that we believe our study is a necessary step in understanding concurrency bug origins.
our suite of 433table how concurrency bugs are introduced the subscripts represent b ug ids or r evision ids.
the superscripts a o d a m represent common root cause patterns single variable atomicity violations order violations deadlocks and multi variable atomicity violations.
td represents thread.
new new instruction new context variable td td td td type 1agetam apached b42031 mozillad r996770 x mysqla b791 mysqlam r1810 mysqld r1110 type apachea b25520 clicko mysqla b3596 x x type 3httracko b20247mozillad b79054 mozillaa o b142651 mozillad b679524 x x x mplayerd r30851mysqla r703 sqlited b1672 transmissiono b1818 x264o type 4apached r88671 apachea r103588 apachea r1201146 cherokeea b326 x x x x mozillao b61369 mysqlam o b2011 zsneso b10918 log thread log status was open ... close old log log status closed ... open new log log status open query thread log after transaction if log status open ... log update else failure transaction not logged figure how the mysql 791bug was introduced bugs come from a representative set of open source multithreaded c c software cover a wide variety of rootcause patterns and failure patterns and have been widely used in the research community.
the two di erent sources of bugs in our study end up showing consistent trends of origins as shown below.
.
observations among the bugs that we studied from previous papers and from revision logs have unknown origins as they exist in the rst publicly available version of their respective projects.
the remaining bugs are introduced in four di erent ways as shown in table .
in the discussion below we will call the items introduced by the buggy revision as new and the ones that exist prior to the buggy revision as old.
type one thread new instructions in old contexts a concurrency bug is introduced by changes in a single thread where some new memory instructions are inserted in old synchronization contexts.
this happens to both atomicity violation bugs and deadlocks in our study.
for example figure explains how a single variable atomicity violation was introduced in mysql.
in one revision developers decide to update logstatus to be closed shown by in figure .
this change makes perfect sense for the semantics of the logging thread.
however it could cause the query thread to skip transaction logging a severe security vulnerability if the query thread reads logstatus after it is set to closed and before it is set back to open .
note that the old version had no logging related problems because the logging code in the query thread denoted by in figure can handle temporarily unavailable logs.
type one thread new instructions in new contexts the buggy revision introduces a new code region with a new synchronization context which is not well synchronized with some old code in another thread.
we observe both atomicity violations and order violations in this cate static httrackp g opt null main thread int main ... pthread create child ... mutexlock g opt s.l ... child thread void child ... ... initialize g opt g opt create opt ... figure how httrack b20247 was introduced gory.
speci cally the buggy revisions of click x264 and mysql b3596 all create new threads that do not synchronize well with old threads.
click s new thread could read shared variables after they are destroyed by old threads x264 s new thread could read shared variables before they are initialized by old threads mysql b3596 s new thread accesses shared variables without using the proper lock used by old threads.
type multiple threads new variables accessed in old contexts there exists code regions r1 andr2that can execute concurrently in the old version.
the buggy revision introduces a new variable accessed by both regions.
the lack of synchronization between these two regions leads to concurrency bugs.
in transmission b1818 and httrack b20247 concurrent accesses from two concurrent regions cause a new shared variable to be read before initialization i.e.
order violations in apache b25520 mozilla b142651 and mysql r703 the concurrent read andwrite accesses from two concurrent regions lead to atomicity violations.
in several other cases two threads can request lockaconcurrently in the old version.
inserting lock bacquisitions to be before and after the lock aacquisitions in these two threads causes deadlocks.
type multiple threads new instructions in new context s this typically happens when the revision introduces new multi threaded components into the software or signi cant re implementation for many threads e.g.
cherokee b326 .
the shared variables involved in these bugs are mostly new variables except for apache r1201146 .
.
discussion facing large real world multi threaded software it is critical to improve the performance and accuracy of existing concurrency bug analysis techniques.
this could be helped through history change awareness an approach that has notbeen well explored.
our study shows how this approach can help two critical and time consuming compo434nents of concurrency bug analysis analyzing which instructions access same variables i.e.
memory access analysis and analyzing what are the synchronizations around these instructions i.e.
synchronization analysis .
first synchronization analysis can be signi cantly simpli ed for many bugs through history awareness.
with old synchronization context information about half of the studied bugs would require nonew synchronization analysis to be detected because their buggy code is inside completely old synchronization contexts.
furthermore another of the studied bugs involve old synchronization context in one thread and hence could also bene t from history awareness.
second memory access analysis can be signi cantly simpli ed for many bugs through history awareness.
about half of the studied bugs only involve new variables accessed by new instructions with pointers propagated through new instructions.
therefore detecting them only requires memoryaccess analysis for the changed code instead of the whole program.
this simpli cation is huge as the size of a revision is often less than .
of the whole software.
for the remaining bugs detecting them can leverage incremental pointer alias analysis as they involve old memory instructions or old shared variables or both.
third about a quarter of the studied bugs can bene t from both almost no synchronization analysis and revisionlocal memory access analysis discussed above and hence would require extremely simple analysis to discover.
figure illustrates such a case for httrack b20247.
the revision introduces a new global pointer variable gopt which is initialized by the child thread and dereferenced by the main thread.
the code regions of the initialization and the dereference have been concurrent since the old version.
with history revision aware analysis we can easily tell that the dereference of goptcould happen before its initialization.
the above features can help improve not only analysis performance but also analysis accuracy as some saved analysis time can be used for improving accuracy.
furthermore knowledge about false positives in analyzing old versions can help prune false positives in new versions.
the above features can help not only concurrency bug detection and testing but also prevention.
since half of the examined bugs happen in code regions that can execute concurrently with each other in the old version an ide that highlights concurrent code regions could help prevent many bugs.
furthermore lightweight history change aware analysis can provide developers instant feedback about concurrency bugs introduced by revisions.
of course there are also challenges.
for example reusing synchronization information e.g.
time stamps and locksets from old versions requires extra storage.
it is also di cult to judge whether concurrency bugs are introduced based on the revision alone as about three quarters of the studied bugs involve synchronization contexts or memory accesses inherited from old versions.
overall our origin study of concurrency bugs coming from di erent sources has delivered a consistent message the awareness of history can help improve the performance and accuracy of many concurrency bug related techniques.
.
related work many characteristics studies have been conducted to understand general software bugs .
recently studies also looked at concurrency bugs andevaluate new synchronization primitives based on bug databases and student researcher experiences.
our study complements them by checking software code repositories which reveals real world code development information unavailable in bug databases.
a recent study checks performance bugs in bug databases .
it found synchronization related bug reports among all its sampled performance bugs with no details about these cases.
none of the over synchronization x changes discussed in section can be found from bug databases.
many studies have looked at software code repositories in the past most of which did not focus on synchronization issues.
some recent studies look at parallel programs written using java concurrent programing constructs mpi and c task parallel library .
the study by xin et al.
looks at the frequencies of some lock usage patterns over three versions of four software projects such as using lock after an if check and checking the return value of a lock acquisition.
the study by sadowski et al.
looks at how data races evolve over time in two java programs.
speci cally they made two ndings the number of racy variables remains high over time variables may go in and out of being racy over the course of a project.
as we can see although all looking at multi threaded software our study has di erent goals from previous studies.
consequently our study collects di erent types of software change information and answers di erent types of questions including over synchronization issues and concurrency bug origin issues from previous work.
many concurrency bug detection tools have been proposed .
almost all of them focus on one software version at a time and hence can bene t from our study of concurrency bug origins.
tools have been built recently to detect performance bugs detect false sharings and pro le locks .
our study provides motivation and guidance for future research to tackle over synchronization issues.
new constructs have been designed to partly replace locks and ease synchronization .
although locks are still the most commonly used synchronization constructs in open source c programs our study shows that developers indeed face challenges of using locks.
our concurrency bug origin study is inspired by traditional revision impact analysis designed for sequential bugs .
previous results cannot be applied to concurrencybug research because concurrency bugs involve multiple threads and synchronization.
.
conclusion this paper studies code repositories to understand synchronization challenges encountered by real world developers.
we rst check over code revisions in the code repositories of four representative c c software projects to gure out how many critical section related changes are there why the changes are made and when they are made.
we then conduct thorough case studies to better understand how concurrency bugs are introduced by code changes and how developers handle over synchronization problems.
our ndings provide insights and motivation for future research on tackling synchronization problems both lack ofsynchronization and over synchronization problems.
.