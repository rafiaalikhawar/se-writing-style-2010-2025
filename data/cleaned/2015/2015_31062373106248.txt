a compiler and verifier for page access oblivious computation rohit sinha uc berkeley usa rsinha berkeley.edusriram rajamani microsoft research india sriram microsoft.comsanjit a. seshia uc berkeley usa sseshia eecs.berkeley.edu abstract trusted hardware primitives such as intel s sgx instructions provide applications with a protected address space called an enclave for trusted code and data.
however building enclaves that preserve confidentiality of sensitive data continues to be a challenge.
the developer must not only avoid leaking secrets via the enclave s outputs but also prevent leaks via side channels induced by interactions with the untrusted platform.
recent attacks have demonstrated that simply observing the page faults incurred during an enclave s execution can reveal its secrets if the enclave makes data accesses or control flow decisions based on secret values.
to address this problem a developer needs compilers to automatically produce confidential programs and verification tools to certify the absence of secret dependent page access patterns a property that we formalize as page access obliviousness .
to that end we implement an efficient compiler for a type and memory safe language a compiler pass that enforces page access obliviousness with low runtime overheads and an automatic modular verifier that certifies page access obliviousness at the machine code level thus removing the compiler from our trusted computing base.
we evaluate this toolchain on several machine learning algorithms and image processing routines that we run within sgx enclaves.
ccs concepts security and privacy side channel analysis and countermeasures logic and verification software and its engineering compilers keywords enclave programs secure systems confidentiality side channels acm reference format rohit sinha sriram rajamani and sanjit a. seshia.
.
a compiler and verifier for page access oblivious computation.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction a typical computing platform contains large software layers e.g.
os hypervisor firmware in its trusted computing base tcb where numerous exploits have allowed privileged malware to execute permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn .
.
.
.
recognizing this problem processor vendors are now shipping cpus with hardware primitives such as intel sgx enclaves for isolating sensitive code and data within protected memory regions which are inaccessible to all other software running on the machine.
amongst recent applications of sgx vc3 runs map reduce analytics on an untrusted cloud by computing map and reduce functions on sensitive data within enclaves while the rest of the hadoop stack comprising over million lines of code is untrusted sees only encrypted data and is developed using legacy software toolchains.
in this new paradigm enclaves are the only trusted hopefully tiny components of an application providing us the luxury of programming them with greater rigor and stronger defenses.
nevertheless developing enclaves that guarantee confidentiality of sensitive data is non trivial.
enclaves rely on the compromised host os for i o interactions with remote parties scheduling and resource management and such interactions can reveal secrets either directly or via side channels.
in addition to protecting the enclave s outputs e.g.
by encrypting them before writing to unprotected memory the developer faces the burden of programming the enclaves correctly against privileged attacks.
recently xu et al.
demonstrated a side channel exploit that extracts secrets from an enclave by observing its access pattern to code and data pages to observe page accesses the attacker controls the valid bit in page table entries to the effect of inducing a page fault on each memory access.
practical defenses against a privileged adversary is an open research problem.
in this paper we consider the problem of defending against an adversary that can observe page access patterns of an enclave program.
we formalize a confidentiality property termed page access obliviousness pao that asserts that the adversary s observation of page accesses must be independent of the enclave s secrets.
our key contribution is a method for compiling high level source programs to machine code containing x86 and sgx instructions such that the machine code satisfies pao and a method for efficiently verifying that the enclave binary provably satisfies pao.
this is a first step towards making the developer blissfully unaware of the sophisticated attacks that can be mounted by a privileged adversary allowing them to focus entirely on application logic.
to that end we implement pao enforcement within a compiler for enclang a general purpose language for programming enclaves.
the rationale for developing enclang is two fold memory accesses in mainstream languages such as c rust are determined by the compiler implementation which offers us no control over the placement of objects and code in memory thus hindering a static scheme for enforcing pao a dynamic scheme for llvm bytecode has been proposed but with prohibitively high performance overheads because enclaves do not trust nonenclave software they cannot use legacy software toolchains and thus present a rare opportunity for clean slate programming and verification.
our compiler accepts arbitrary programs in enclang andobliviates the page accesses in the compiled x86 program i.e.
satisfies pao by making page access pattern independent of esec fse september paderborn germany rohit sinha sriram rajamani and sanjit a. seshia secrets.
for instance the compiler ensures that secret dependent branches fetch instructions from the same sequence of pages in both branches.
the compiler also performs stack allocation and lays out data structures in the enclave s heap so that a memory access via a secret address e.g.
array access with a secret index generates a deterministic page access sequence in all executions.
during this process the compiler instruments dummy memory accesses or inserts padding space between objects in memory to obliviate the page accesses.
for performance the compiler performs stochastic optimization based on markov chain monte carlo sampling to reduce the increase in code and data size of compiled programs.
although we implement these techniques in a compiler forenclang the ideas are generally applicable to mainstream languages.
moreover we use enclang to only program the enclave components of an application which we empirically observe to be a small fragment of the entire application e.g.
map and reduce functions in vc3 .
next we develop a separate verifier that proves that the output machine code satisfies pao.
the gains are two fold the compiler is no longer trusted thereby freeing us to implement aggressive optimizations without inadvertently sacrificing pao and the verifier is significantly simpler and shrinks the size of our tcb which now includes only the cpu hardware and our verifier.
furthermore to alleviate the complexity of verifying arbitrary machine code we engineer the compiler to supply untrusted but useful hints to the verifier we follow the typed assembly language paradigm of having the compiler output typing annotations along with the machine code and create a set of simple typing judgments for efficient verification.
this paper makes the following novel contributions we formalize pao for enclave programs which execute in the presence of a privileged adversary.
we present a toolchain consisting of a type system and compiler that automatically enforces pao while compiling to machine code and implements a stochastic optimization to reduce runtime and memory overheads.
to minimize our tcb we develop a verifier that analyzes the compiled machine code to prove pao.
to further simplify the verifier we design a typed assembly language where the typing annotations accompany the machine instructions and reduce the verification task to efficient type checking.
we evaluate the toolchain on several machine learning algorithms and image processing routines for which attacks have been demonstrated in .
overview enclaves .an enclave is a protected region in memory containing code and data that can only be accessed by the code running within the enclave.
the trusted cpu implements instructions for the untrusted software to launch enclaves after launch any nonenclave software is prohibited from accessing the enclave s memory the cpu implements measurement and remote attestation primitives to ensure launch time integrity .
an enclave e.g.
hadoop reducer in vc3 occupies a virtual address space contained within the hosting application s e.g.
hadoop process address space the enclave s code runs at the lowest ring privilege level.
an enclave is not allowed to make system calls since the os cannot be trusted to modify the enclave s memory safely.
however theenclave can access the hosting application s memory but not the other way around which allows for efficient i o between the enclave and the external world all system calls are proxied by the hosting application.
the host application can invoke code inside the enclave via a statically defined entry point and the enclave code can transfer control back via an exit instruction.
control may also transfer out of the enclave asynchronously due to interrupts faults and exceptions in which case the cpu protects sensitive state e.g.
by saving context in the enclave s memory and zeroing out the registers.
a typical enclave follows a stylized idiom where it copies encrypted inputs from the host application s memory decrypts the input using a key known only to the enclave computes and encrypts the output and copies the encrypted output to the host application s memory.
to support this programming idiom we emulate the design of and supply a runtime library with send andrecv apis whose specification is formalized in which provide the only means for communicating with the external world send encrypts the message and writes out the ciphertext whereas recv decrypts the incoming ciphertext and provides the plaintext message to the caller.
threat model .we assume a software adversary that has full control of all system software os hypervisor system management mode firmware and bios.
as a result of these privileges the adversary has full control over non enclave memory i o peripherals disks and network it may record replay or modify network messages and disk contents.
the adversary may force the cpu to transfer control from the enclave to the untrusted os at any time during execution by generating an interrupt for example .
once the cpu transfers control to the adversary the adversary may execute an arbitrary adversarial operations before transferring control back to the enclave.
to allow an os autonomy over memory paging decisions intel sgx places the page tables under the os control.
for security the cpu implements an inverse page table mapping to ensure that the os cannot change the physical mapping for any address in enclave s region.
however at any point the attacker may modify the page table entries to the effect of inducing a page fault on each enclave memory access e.g.
by clearing the valid bit .
that being said the os page fault handler only needs to know the accessed page and not all bits of the address hence the cpu clears the page offset bits from the faulting address least significant bits for 4kb sized pages prior to delivering the page fault exception.
this reveals the enclave s memory access patterns only at the page level granularity.
recent attacks on enclaves have extracted secrets via this channel and preventing such leaks is a key contribution we make.
defenses against hardware attacks are out of scope for this paper.
for instance we assume that the adversary cannot physically attack the cpu package to extract secrets nor snoop on the hardware bus connecting the cpu and dram.
the latter assumption prevents the adversary from learning access patterns at the byte level granularity which would necessitate a more sophisticated defense.
we also don t defend against timing leaks which may result from timing of page accesses cache timing attacks which the attacker uses to infer access patterns at a cache line granularity.
650a compiler and verifier for page access oblivious computation esec fse september paderborn germany challenges in guaranteeing page access obliviousness .we choose a simple notion of confidentiality the adversary s observations of page accesses during enclave execution must be independent of the enclave s secrets.
consider a sample enclave in figure which evaluates a decision treeto classify an input instance .
the decision treeand the evaluate algorithm are known to the adversary whereas the input instance and output decision must be kept confidential to that end we invoke the runtime s send api to encrypt the output before writing to non enclave memory.
to classify the instance the procedure traverses the tree stored as a flattened array starting from the root node until it reaches a leaf node which is any node with a non zero value in the decision field the evaluation uses an index variable to record the current node in the traversal.
at each interior node the procedure compares the value of a decision variable with a threshold value and recurses on either the left or right subtree based on the outcome.
the path taken through the tree reveals predicates that hold on the secret instance which the attacker infers by monitoring the enclave s accesses to code and data pages.
therefore amongst other measures the enclave developer must ensure that the page accesses are independent of the path a property entailed by pao.
guaranteeing pao for the evaluate procedure has the following challenges in the case of an unbalanced decision tree evaluate terminates after varying number of iterations based on secret and the attacker may infer the path length by counting the number of page accesses.
in other words each invocation ofevaluate leaks at most log2kbits of secret where kis the height of our decision tree.
we have a secret dependent conditional statement line .
monitoring the enclave s accesses to the code pages allows the attacker to infer which branch is taken if any of the instructions implementing the ifbranch line is placed in a different page than the instructions implementing the elsebranch line .
mainstream compilers often optimize for code size and performance but make no effort to control the layout of instructions.
we find several data accesses where the address depends on a secret value.
for instance in lines the array access tree computes a reference to a node within the tree where index is a secret this makes the address evaluate to a secret value.
in the case that treeis stored across multiple pages because the treesize is larger than a single page or due to layout decisions made by the compiler the attacker infers some bits of the secret index by monitoring the enclave s accesses to data pages.
compilation for page access obliviousness .we develop a compiler for producing pao satisfying x86 code from arbitrary enclang programs.
first a type system described in .
flags violations where the enclave leaks secrets in ways that an automatic compiler cannot fix without developer intervention loops with secret dependent condition i.e.
secret number of iterations explicit leaks via assignment of secret values to public state and implicit leaks via assignment to public state within a secret conditional branch these typing restrictions are common for type systems for non interference and side channel mitigations.
in the evaluate procedure in figure the developer replaces the secret dependent loop condition line with a loop that executes for fixed number of iterations line thus trivially satisfying the typing rule that1global tree array struct left idx k public index of left subtree right idx k public index of right subtree decision uint64 public !
for leaf node dvar idx d public decision variable threshold uint64 public threshold value void evaluate instance ref array secret uint64 local decision uint64 secret evaluation result local index idx k secret values to k index start traversal at root decision terminates when non while decision for .. k if decision decision tree decision if instance dvar tree threshold index tree left recurse left else index tree right recurse right send decision figure decision tree evaluation loop exit conditions must only depend on public values.
the type checker finds no other violations.
the compiler described in then compiles to x86 code listed in figure a while also enforcing pao by controlling the layout of data structures and instructions in memory where necessary it generates dummy page accesses to obliviate the access patterns as discussed below.
it takes the following necessary measures for our sample enclave.
even with the fix on line the enclave remains vulnerable the program effectively stops computing and does not perform data accesses once the traversal reaches a leaf node i.e.
condition on line evaluates to false thus allowing the adversary to infer the path length by counting the accesses to the data pages.
to correctly conceal this leakage the compiler places dummy accesses in the else branch corresponding to the ifon line to account for the imbalance in the tree.
as seen in figure a the dummy accesses are performed using instructions within the address range 0x96 to0xbe and they target the same sequence of pages as the two program paths in the input program this is achieved via dummy reads from the same object and by controlling the placement of objects.
second to prevent secrets from leaking via data accesses e.g.
tree where the address depends on a secret the compiler must either layout the treeto fit entirely within a page if possible causing all accesses to the tree to target the same page or allow the tree to span multiple pages and introduce dummy accesses to all pages except the page containing tree .
for a simpler presentation the compilation in figure assumes that thetreeobject fits within a single page .
presents a general scheme.
despite this simplifying assumption we must generate dummy accesses to treein the else branch corresponding to the 651esec fse september paderborn germany rohit sinha sriram rajamani and sanjit a. seshia a compiler safely lays out code and data pages and instruments dummy accesses b verifier constructs cfg and computes aliases for all memory accesses figure compiling and verifying evaluate to guarantee page access obliviousness ifon line .
a dummy read e.g.
instruction 0x9e which mimics0x35 is performed by fabricating an address within the tree.
a dummy write e.g.
instruction at 0xa6 which mimics 0x3d is performed by first issuing a dummy read instruction 0xa2 which we compensate by adding instruction 0x39 in the original path and then writing the read value back at the same address thus preventing dummy accesses from modifying state.
finally to hide control decisions based on secret input line the compiler lays out the instructions from both branches onto the same page when possible.
inevitably to handle cases where the cumulative code within the branches of a secret conditional cannot be fit onto a single page the compiler partitions code across pages such that the sequence of code page accesses is equivalent in the two branches the compiler splits each branch into snippets and maps snippets to pages such that the nth chunk of both branches have equal number of instructions and occupy the same page.
finally the compiler instruments nopinstructions to equalize the number of instructions code accesses in the two branches.
further details are presented in .
.
for simplicity we elide the nopinstructions in figure and also manage to place all of the compiled machine code for evaluate within one page.
verifying page access obliviousness .an enclave violates pao if executions with different secret values produce different sequences of page accesses.
we verify that the output machine code satisfies pao thus removing the compiler s implementation from the trusted computing base.
in this paper we show that verifying pao requires sound but necessarily incomplete algorithms for alias analysis and control flow analysis in practice we are able to implement a simple yet precise algorithm for these analyses because our compiler produces idiomatic code and supplies hints to the verifier following the paradigm of typed assembly language.
first our verifier takes the enclave program as input and computes its control flow graph cfg as shown in figure b .
next our verifier performs an alias analysis annotating each memory access with a set of objects thatthe access may target.
we show the aliases within curly braces in figure b the verifier also annotates the aliases for the dummy accesses along the else branch shown within the dotted box in the cfg corresponding to the ifin line .
the verifier uses these analyses to prove pao for any pair of executions of the enclave binary that only differ in secret values the sequence of page accesses must be equivalent where two accesses are equivalent if they target the same page and have same type read write execute .
the machine code in figure satisfies pao trivially because the alias analysis computes only one object for each memory access and all paths have equivalent sequence of accesses to code and data pages.
page access obliviousness .
formal modeling of enclave code instructions.
an enclave program is a partial map from bit addresses in enclave memory to user mode instructions with a unique entrypoint.
in addition to standard x86 instructions the cpu enables sgx instructions in enclave mode to perform cryptography e.g.
ereport egetkey and exit to non enclave code eexit .
on the other hand certain instructions such as system calls are disabled because the enclave cannot trust the os to update enclave s memory.
for simplicity of our implementation rather than the methodology we assume that the compiler produces enclave programs that only contain a subset of x86 instructions it includes mov for loads and stores conditional jumps such as jl call andretfor procedure calls and several arithmetic and relational operators.
our methodology assumes single threaded enclaves.
state.
the enclave program s state consists of variables denoted byvars regs flags and mem.regs are cpu registers e.g.
rax r8 rsp etc.
each being bits wide.
cpu flags e.g.
cf zf etc.
are bit values.
the instruction pointer rip regs stores the address of the next instruction to be executed and is incremented automatically after every instruction except in those that change the control flow jumps call and ret.
memory mem is modeled as 652a compiler and verifier for page access oblivious computation esec fse september paderborn germany a map from bit addresses to bit data.
although the machine s state may consist of other elements such as control register cr4 etc.
we omit them from the enclave s state even though they impact its execution.
there are two main reasons for this modeling choice we assume the isa defined operational semantics of each instruction which the cpu must fulfill in enclave mode regardless of how the adversary modifies the unprotected state elements and we would like to abstract away from the specifics of a particular isa implementation and we find that our abstraction of machine s state i.e.
regs flags and mem applies to other trusted hardware platforms.
semantics.
we define a concrete state to be a valuation of all variables in vars.
let v be the value of a variable v vars in state .
let instr be the instruction executed in state computed from the instruction pointer ripand the contents of mem .
the semantics of an instruction i instr is given by the relation where i if and only if i instr and there is an execution of istarting at and ending in as per the operational semantics .
due to space constraints we define the operational semantics for a subset of instr in the technical report .
a sequence is called an execution trace if instr k k k 1for each k .
.
.
n .
.
modeling adversary s effect on enclave execution our formal model of an active adversary s operations is similar to moat we only extend moat s adversary with observations of page level accesses.
the adversary may force the cpu to transfer control from the enclave to the untrusted os at any time during execution by generating an interrupt for example .
from then on the adversary executes an arbitrary sequence of instructions before transferring control back to the enclave.
the adversarial operations include modifications to non enclave memory privileged state accessible to the os and hypervisor layers e.g.
page tables and devices.
moat proves a theorem that an unbounded sequence of these privileged operations can be simulated by an adversary that is only allowed to modify non enclave memory in other words the cpu ensures that the adversary can only impact the enclave s execution when the enclave loads inputs from non enclave memory.
for sound analysis our model of the enclave program havocs the output of recv which is the only mechanism for fetching inputs from non enclave memory.
.
page access obliviousness we first define confidentiality for enclave programs and then instantiate this definition to attain pao.
an execution trace starts in the initial state of the machine following a power cycle at some point in the trace the adversary launches the enclave program.
from then on consists of alternating sequences of adversarial and enclave instructions.
we use seqa i andseqe i to denote the i th subsequence of adversarial and enclave instructions respectively figure illustrates these functions.
let the projection function a denote the component of enclave observable machine state that the adversary is allowed to control we define a mem enc where mem encdenotes non enclave memory.
note that the adversary may invoke privileged instructions that modify state beyond mem enc e.g.
control register cr4 .
however we omit these state variables from abecause they are not included in the enclave s stateor the operational semantics and the trusted cpu must guarantee the operational semantics during enclave execution regardless of how the adversary manipulates this additional machine state.
figure illustration of confidentiality definition.
definition .
.
confidentiality for any pair of execution traces of the machine if the adversary s operations along the two traces are equivalent then the adversary s observations along the two traces must also be equivalent.
1 2 .
1 a 2 1 o 2 where 1 a 2 i.instr seqa 1 i instr seqa 2 i a seqe 1 i a seqe 2 i confidentiality a hyper property defined over pairs of executions is violated when the enclave produces observationally different traces for equivalent adversarial operations.
equivalence is defined using relations aand o. the equivalence relation a over pairs of adversarial subsequences seqa 1 i andseqa 2 i only includes traces that have equal lengths have the same instructions and produce the same sequence of states where equivalence is defined modulo the projection function a .
equality of states modulo ais naturally defined to be bitwise equivalence for all locations in mem enc with the caveat that encrypted values can differ.
specifically using the approach of cryptographically masked flows we treat all valid ciphertexts to be equivalent this ensures that calling recv will succeed and produce different secret inputs in both 1and 2. without this restriction definition .
would force all encrypted inputs to have equivalent bitwise values thereby forcing secrets to have the same values in 1and 2 which may hide information leaks.
for checking that the enclave s observed behaviors are equivalent we use an equivalence relation o defined below.
definition .
.
page access obliviousness an enclave is page access oblivious if it satisfies confidentiality with observation functionoset to the following pafunction.
1 o 2 pa seqe 1 i pa seqe 2 i pa 0 .
.
.
n pac execute rip 2p pad read rega 2p instr mov reg d write rega 2p instr mov regd read rsp 2p instr pop reg ret write rsp 2p instr push reg call otherwise 653esec fse september paderborn germany rohit sinha sriram rajamani and sanjit a. seshia thepafunction permits the adversary to observe all memory accesses at the page level granularity enforced by the division by page size 2p .
the value of p is architecture specific a page has size bytes in intel sgx cpus which makes p .
as dictated by pa for each instruction executed in enclave mode the attacker records access to a code page at address ripto fetch the instruction and access to a data page if the instruction triggers a data access e.g.
push performs a write access to a data page at address rsp .
this definition of parepresents the x86 isa semantics even in the presence of optimizations such as prefetching and caching because the cpu evaluates the page permission check for each memory access.
the adversary also observes the type of memory access read write or execute.
pao enforcing compilation this section presents an algorithm for obliviating data accesses at the machine code level .
a stochastic optimization step for lowering runtime overheads of this defense .
and an algorithm for obliviating code accesses .
.
we also present enclang .
and its compiler .
.
which implements these algorithms to produce pao satisfying machine code.
.
obliviating data accesses consider the following secret dependent conditional branch if s s bool secret b a a array uint8 public else b array uint8 secret c c uint64 secret with different values of the secret sin executions 1and 2 from definition .
the attacker observes different data accesses in 1 and 2 1 if branch rjsk rja k wjb k 2 else branch rjsk wjck here rjkandwjkindicate read and write operation respectively we defer the treatment of code accesses for fetching instructions to section .
.
a strawman pao enforcement scheme obliviates page accesses in the two branches by introducing dummy read rjek and dummy write wjek operations which are guaranteed to target the same page as the real read rjek and write wjek operations that they mimic and not cause any side effect on the program s state.
this approach results in the following data accesses along the two branches of the above program 1 if branch rjsk rja k wjb k wjck 2 else branch rjsk rja k wjb k wjck the implementation of dummy operations rjkand wjk which execute in a different code path than the real operations they mimic must compute the same address or at least an address to the same page.
this is trivial for scalar objects e.g.
variable c which has a fixed location on the program stack .
in the case where the object spans multiple pages e.g.
larger than page array ainrja k we cannot statically identify a unique page targeted by a read write operation in general the address may be computed using a secret e.g.
secret kina and secrets may evolve to different values within the two branches of a secret dependent conditional.
therefore the dummy operation rja kmust access each page that contains some part of the object which also forces us to accessthe same pages to implement the real rja klest we violate pao.
in other words the rjk rjk wjk and wjkoperators defined in figure and described below may perform multiple memory accesses for each read write operation.
first given a rjekorwjekoperation to mimic we perform a best effort analysis to identify the object being targeted by the reference e hereby called the statically identifiable object.
the statically identifiable object or si e denotes a contiguous region of memory that is guaranteed to contain the address e in all executions of the program.
enclang provides two constructs for computing