towards api specific automatic program repair sebastian nielebock chair of software engineering faculty of computer science otto von guericke university magdeburg germany sebastian.nielebock ovgu.de abstract the domain of automatic program repair apr had many research contributions in recent years.
so far most approaches target fixing generic bugs in programs e.g.
off byone errors .
nevertheless recent studies reveal that about of real bugs require api specific fixes e.g.
adding missing api method calls or correcting method ordering for which existing apr approaches are not designed.
in this paper we address this problem and introduce the notion of an api specific program repair mechanism.
this mechanism detects erroneous code in a similar way to existing apr approaches.
however to fix such bugs it uses api specific information from the erroneous code to search for api usage patterns in other software with which we could fix the bug.
we provide first insights on the applicability of this mechanism and discuss upcoming research challenges.
index terms automatic program repair api specific bugs specification mining i. r esearch problem of automatic program repair the burden to fix bugs in software development is both time consuming and costly.
even though automation of bug localization is common e.g.
automated testing or software profiling bug fixing still requires the programmer s interaction.
even worse automatic program repair apr is undecidable in general .
however in recent years many approaches were published to perform apr.
martin monperrus classifies these approaches as behavioral and state repair .
behavioral repair approaches directly modify the source code to fix the bug.
a list of well known approaches are the genpatch algorithm bugmem pachika genprog par autofix nopol rsrepair leakfix searchrepair qacrashfix angelix historicalfix prophet and deepfix .
in contrast state repair approaches change the surrounding environment of the erroneous program e.g.
by changing input data or the memory state.
some representatives are mircoreboots diehard assure bolt input rectification armor rcv and ares .
the prevalent trend of these apr approaches is to be applicable for generic bugs i.e.
bugs that may occur in every kind of software e.g.
off by one errors.
in a recent study on manual bug fixes the authors revealed that of all bugs fall in this category which explains the success of existing apr approaches.
in the other half at least one apispecific fix was necessary.
as an example of an api specific fix one may consider the lang bug from the defects4j benchmark in listing .this benchmark represents a collection of real word bugs from six open source projects and their manually created fixes.
p u b l i c s t r i n g b u f f e r f o r m a t c a l e n d a r vcalendar s t r i n g b u f f e r buf f i f mtimezoneforced f v c a l e n d a r .
gettime v c a l e n d a r c a l e n d a r v c a l e n d a r .
c l o n e v c a l e n d a r .
settimezone mtimezone 9g listing bug fix lang from the defects4j benchmark produced with diff.
the fix was an addition of the gettime method at line .
the issue with lang is that the vcalendar object is not being properly updated before being cloned for further reuse.
thus an outdated time is formatted.
this bug was fixed by adding the gettime method at line .
according to the api documentation of the calendar api1 the call of get gettime and three other methods causes an update of the vcalendar variable and thus fixes the bug.
here the intrinsic knowledge to call the gettime method before cloning the vcalendar object was necessary to fix the bug.
in general it is recommended to leverage such api knowledge for apr .
in this paper we introduce the idea of representing api knowledge as api usage patterns .
these patterns represent common structures of interface application of an api.
however these patterns are not always available especially if programmers are not familiar with the api.
thus to fix api specific bugs automatically we mine usage patterns which directly relate to the erroneous code and modify the code base so that it complies with the usage pattern.
this means that our approach represents a behavioral repair method.
in addition to monperrus s classification we introduce the domain of api specific and generic repair in fig.
.
note that this classification does not represent a holistic picture of apr but rather reveals the need for api specific repair mechanisms.
some approaches partially address the topic of api specific repair or use similar ideas bold and underlined in the classification scheme .
in the following we reveal their limitations for api specific repair and the main differences according to the proposed approach.
related behavioral generic repair methods use patterns only to improve their results or to find api specific fixes with .
c ieeease urbana champaign il usa doctoral symposium1010 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
behavioral repair state repairgeneric repair api specific repairqacrashfixbugmemhistoricalfixprophet searchrepair armorgenprog rsrepair angelixpar genpatchpachikadeepfix autofixleakfix nopolmicroreboot assure boltinput rectificationrcv ares diehardfig.
classification with the dimension of api specific repair methods a different method.
historicalfix and prophet use knowledge from bug fix patterns to assess their synthesized patches.
nevertheless their patterns consider generic bugs rather than api specific ones.
searchrepair finds patches by searching code that has the same behavior with regard to passing test cases.
in contrast to our proposed mechanism it directly applies found code snippets from other applications to produce patches.
deepfix conducts deep learning of code samples with a recurrent neural network.
however this approach usually targets syntactic instead of semantic bugs.
existing behavioral api specific repair methods either do not represent a fully automated approach or show other limitations to find api specific fixes.
genpatch describes an algorithm that creates patches by compensating differences between a specification pattern e.g.
an api usage pattern among others and the actual code.
this algorithm expects that the specification patterns are already known posing the question of how to find related patterns.
bugmem memorizes bug fixes from the project s history to be reapplied if the same error occurs again.
extensions of this approach infer common bug fix patterns for apr .
pachika analyzes objects state flows during the program execution and detects anomalies from these flows.
it produces a patch according to the usually observed behavior.
due to the monitoring overhead it only considers anomalies in the erroneous software.
qacrashfix uses the information of q a webpages like stack overflow to find possible patches for bugs.
here the approach benefits from api specific error messages to find relevant q a pages.
however the approach struggles to extract code changes from embedded code in natural language texts whereby the solution space is restricted.
within the state repair mechanisms only armor is known to address api specific apr.
armor leverages existing redundancy in the implementation so that some method calls can be substituted in case of an error.
however developers have to manually define redundant method calls.
our mechanism addresses these limitations.
in the next section we explain the overall structure of our mechanism present first results based on the example from listing and discuss methods for validating our approach.ii.
a utomatic program repair by mining api usage patterns the thesis addresses the topic of api specfic automatic program repair by automatic mining of bug related usage patterns and applying these patterns to overcome api misuses.
fig.
depicts the general workflow of the mechanism and its main contributions.
similarly to other apr approaches we conduct bug localization a by running automatic test cases to extract those statements that most likely cause the bug e.g.
by spectrum based approaches like tarantula ochiai or dstar .
this is promising as many software projects apply automatic testing and thus have test suites.
as we require only an erroneous code section for patch generation other localization methods may work as well.
next we extract api information b e.g.
imported classes or used methods from the erroneous code section.
this information is used to find similar code snippets from other software projects that apply the same apis as used in the erroneous code.
in particular we assume that the bug is caused by a misuse of an api and can be fixed with api usage patterns found in other correct applications.
with respect to our example in listing we can extract the information that the erroneous code uses the classes stringbuffer andcalendar.
afterwards we search for source files that also utilize these apis e.g.
via the github search api2 .
these files serve as input for the mining process.
recent publications in the domain of specification mining introduce various approaches to mine api usage patterns c .
so far specification mining was mainly used for automatic documentation inference or bug detection.
instead we plan to use usage patterns for patch generation.
in the proposed mechanism we perform a shepherded specification mining by restricting input source files to several usages of one particular api the specification mining task is more likely to find a usage pattern for this particular api as these appear more frequently in the input data.
thereby the resulting usage patterns are more closely related to the particular bug.
in a preliminary experiment we applied frequent sequential pattern mining fspm from the spmf library for source files that also imported the calendar class.
we analyzed .
source files from projects acquired from github and obtained .
sequences from these files.
here a sequence represents a string of nodes from an abstract syntax tree ast of each method in the source code file.
in order to deal with block statements such as if then else constructs we add special nodes indicating the start and the end of statements.
to increase the number of frequent sequences we anonymized variable names in method calls and assignments and restricted the ast nodes to method calls assignments loops and conditional statements.
so far the results obtained appear to be promising.
in detail we achieved the best results with the clospan algorithm which aims to find closed frequent sequences .
we set the minimal support to and found frequent sequences.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
erroneous programbug localizationsimilar api usagestest suite api extraction api pattern detectionspecification mining api usage patternserrorneous code section s patch patch generationtest suite validation correct programa b c d efig.
workflow of our api specific program repair mechanism.
contributions of the thesis are highlighted red bold and underlined .
here the get and the gettime methods original fix were the 4th and 18th most frequently applied sequences respectively.
thus selecting patterns for apr due to their frequency would quickly result in patterns whose insertions at line in listing would eventually fix the bug.
based on mined patterns the mechanism synthesizes a patch d .
so far we conducted this step manually.
to automate it weimer s genpatch algorithm is applicable.
genpatch finds the minimal edit operations i.e.
insertions and deletions which modify the erroneous code so that it complies with the api usage pattern.
however if the patterns contain methods with input parameters genpatch requires manual insertion of these parameters.
for entire automation we need a mapping to the existing variables e.g.
variable vcalendar and a mechanism to infer parameter values e.g.
application of theget method requires an integer value as parameter.
we propose to use static analysis of the ast to infer global as well as local variables and to check them exhaustively if they can call the missing method.
for example the calendarspecific methods get andgettime can only be called via the vcalendar variable.
to infer parameters a naive approach is to insert the default values of the data types i.e.
we manually insert the value 0inget.
this fixes the bug as calling the get method with an arbitrary parameter triggers the required update of the vcalendar object.
finally we validate found patches by re running the whole test suite e .
we consider a patch valid if all test cases pass.
so far we introduced the notion of api specific apr on the lang example from the defects4j benchmark.
in order to provide evidence for the approach s applicability to other bugs and apis we are currently working on a larger study.
apr is usually validated on existing bug benchmarks .
we plan to evaluate our mechanism with the mubench benchmark which contains real world api specific bugs .
the following section highlights further challenges.
iii.
f urther work even though the approach of api specific apr is promising we identify three different research challenges.
extracting api specific information api specific information is crucial to mine meaningful api usage patterns.
if we use too coarse api information for the code search we may find many api usages and thus patterns which are extraneousto the bug.
in contrast with too detailed information we may struggle to find related code samples for the mining step at all.
even though api usage pattern recommender systems like mapo give first insights from whose information specification mining benefits we suggest further investigation of whether this is applicable to apr.
automating patch generation as discussed before the algorithm by weimer enables us to create fixes automatically based on api usage patterns.
nevertheless this process is not fully automated as for example method parameters cannot be automatically inferred.
next to the previously mentioned approach of using default values for unknown parameters further work will consider more sophisticated approaches.
for instance we can use frequent itemset mining to find frequently applied method parameters from other applications.
dealing with false positive patterns a common problem of specification mining algorithms is that they find many false positive patterns.
these false positives represent relations between statements that do not exist.
thus applying the complete pattern may either not fix the bug or introduce new ones.
as false positives usually represent a false combination of true patterns we suggest accepting partial compliance with a pattern as patch candidates.
we will address these challenges in ongoing research.
in addition as specification mining can be too time consuming in practice storing and combining usage patterns for later reuse can avoid repetitive mining.
iv.
c onclusion in this paper we introduced the idea of an api specific repair mechanism.
most existing approaches focus on creating fixes for generic bugs such as off by one errors.
nevertheless recent publications reveal that of programming bugs require at least one api specific repair action.
thus the thesis addresses the topic of automatic repair of api specific bugs e.g.
false method order missing method calls .
the proposed approach captures the intrinsic knowledge of how to use an api in the form of api usage patterns.
to get these patterns algorithms from the domain of specification mining are the most promising.
in particular we search in other applications which also use a particular api for api usage patterns which if applied are likely to fix the bug.
within this paper we give an example of an api specific bug for which we are able to find usage patterns by frequent authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sequence mining which would eventually fix the bug.
finally we highlighted our further research directions.
acknowledgment i would like to thank my advisor frank ortmeier for his support and guidance.