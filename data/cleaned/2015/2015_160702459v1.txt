why we refactor?
confessions of github contributors danilo silva universidade federal de minas gerais brazil danilofs dcc.ufmg.brnikolaos tsantalis concordia university montreal canada tsantalis cse.concordia.camarco tulio valente universidade federal de minas gerais brazil mtov dcc.ufmg.br abstract refactoring is a widespread practice that helps developers to improve the maintainability and readability of their code.
however there is a limited number of studies empirically investigating the actual motivations behind speci c refactoring operations applied by developers.
to ll this gap we monitored java projects hosted on github to detect recently applied refactorings and asked the developers to explain the reasons behind their decision to refactor the code.
by applying thematic analysis on the collected responses we compiled a catalogue of distinct motivations for well known refactoring types.
we found that refactoring activity is mainly driven by changes in the requirements and much less by code smells.
extract method is the most versatile refactoring operation serving di erent purposes.
finally we found evidence that the ide used by the developers a ects the adoption of automated refactoring tools.
ccs concepts software and its engineering !software evolution maintaining software software maintenance tools keywords refactoring software evolution code smells github .
introduction refactoring is the process of improving the design of an existing code base without changing its behavior .
since the beginning the adoption of refactoring practices was fostered by the availability of refactoring catalogues as the one proposed by fowler .
these catalogues de ne a name and describe the mechanics of each refactoring as well as demonstrate its application through some code examples.
they also provide a motivation for the refactoring which is usually associated to the resolution of a code smell.
for example extract method is recommended to decompose a large and complex method or to eliminate code duplication.as a second example move method is associated to smells like feature envy and shotgun surgery .
there is a limited number of studies investigating the real motivations driving the refactoring practice based on interviews and feedback from actual developers.
kim et al.
explicitly asked developers in which situations do you perform refactorings?
and recorded code symptoms that motivate developers to initiate refactoring.
wang interviewed professional software developers about the major factors that motivate their refactoring activities and recorded human and social factors a ecting the refactoring practice.
however both studies were based on general purpose surveys or interviews that were not focusing the discussion on speci c refactoring operations applied by the developers but rather on general opinions about the practice of refactoring.
contribution to the best of our knowledge this is the rst study investigating the motivations behind refactoring based on the actual explanations of developers on speci c refactorings they have recently applied .
to ll this gap on the empirical research in this area we report a large scale study centered on refactorings identi ed in commits from popular java based projects hosted on github.
in this study we asked the developers who actually performed these refactorings to explain the reasons behind their decision to refactor the code.
next by applying thematic analysis we categorized their responses into di erent themes of motivations.
another contribution of this study is that we make publicly available1the data collected and the tools used to enable the replication of our ndings and facilitate future research on refactoring.
relevance to existing research the results of this empirical study are important for two main reasons.
first having a list of motivations driving the application of refactorings can help researchers and practitioners to infer rules for the automatic detection of these motivations when analyzing the commit history of a project.
recent research has devised techniques to help in understanding better the practice of code evolution by identifying frequent code change patterns from a ne grained sequence of code changes isolating non essential changes in commits and untangling commits with bundled changes e.g.
bug x and refactoring .
in addition we have empirical evidence that developers tend to interleave refactoring with other types of programming activity i.e.
developers tend to oss refactor .
therefore knowing the motivation behind a refactoring can help us to understand better other related changes in a commit .
in fact in this study we found jul 2016several cases where developers extract methods in order to make easier the implementation of a feature or a bug x. second having a list of motivations driving the application of refactorings can help researchers and practitioners to develop refactoring recommendation systems tailored to the actual needs and practices of the developers.
refactoring serves multiple purposes such as improving the design understanding the code nding bugs and improving productivity.
however research on refactoring recommendation systems has mostly focused on the design improvement aspect of refactoring by proposing solutions oriented to code smell resolution.
for example most refactoring recommenders have been designed based on the concept that developers extract methods either to eliminate code duplication or decompose long methods .
in this study we found di erent reasons behind the application of extract method refactorings.
each motivation requires a di erent strategy in order to detect suitable refactoring opportunities.
building refactoring recommendation systems tailored to the real needs of developers will help to promote more e ectively the practice of refactoring to the developers by recommending refactorings helping to solve the actual problems they are facing in maintenance tasks.
.
related work refactoring is recognized as a fundamental practice to maintain a healthy code base .
for this reason vast empirical research was recently conducted to extend our knowledge on this practice.
studies on refactoring practices murphy et al.
record the rst results on refactoring usage collected using the mylar monitor a standalone framework that collects and reports trace information about a user s activity in eclipse.
murphy hill et al.
rely on multiple data sources to reveal how developers practice refactoring activities.
they investigate nine hypotheses about refactoring usage and conclude for instance that commit messages do not reliably indicate the presence of refactoring that programmers usually perform several refactorings within a short time period and that of refactorings are performed manually.
negara et al.
provide a detailed breakdown on the manual and automated usage of refactoring using a large corpus of refactoring instances detected using an algorithm that infers refactorings from ne grained code edits.
as their central ndings they report that more than half of the refactorings are performed manually and that of the applied refactorings do not reach the version control system.
studies based on surveys interviews kim et al.
present a eld study of refactoring bene ts and challenges in a major software organization.
they conduct a survey with developers at microsoft regarding the cost and risks of refactoring in general and the adequacy of refactoring tool support and nd that the developers put less emphasis on the behavior preserving requirement of refactoring definitions.
they also interview a designated windows refactoring team to get insights into how system wide refactoring was carried out and report that the binary modules refactored by the refactoring team had a signi cant reduction in the number of inter module dependencies and post release defects.
wang interviews professional software developers and nds a list of intrinsic i.e.
self motivated and external i.e.
forced by peers or the management factors motivating refactoring activity.studies on refactoring tools vakilian et al.
reveal many factors that a ect the appropriate and inappropriate use of refactoring tools.
they show for example that novice developers may underuse some refactoring tools due to lack of awareness.
murphy hill et al.
investigate the barriers in using the tool support provided for the extract method refactoring .
they report that users frequently made mistakes in selecting the code fragment they want to extract and that error messages from refactoring engines are hard to understand.
murphy hill et al.
show that of con guration defaults in refactoring tools are not changed by the developers.
as a practical consequence of these studies refactoring recommendation systems have been proposed to foster the use of refactoring tools and leverage the bene ts of refactoring by alerting developers about potential refactoring opportunities .
studies on refactoring risks kim et al.
show that there is an increase in the number of bug xes after api level refactorings.
rachatasumrit and kim show that refactorings are involved in almost half of the failed test cases.
wei gerber and diehl show that refactorings are sometimes followed by an increasing ratio of bug reports .
however existing studies on refactoring practices do not investigate in depth the motivation behind speci c refactoring types i.e.
why developers decide to perform a certain refactoring operation.
for instance kim et al.
do not di erentiate the motivations between di erent refactoring types and wang does not focus on the technical motivations but rather on the human and social factors a ecting the refactoring practice in general.
the only exception is a study conducted by tsantalis et al.
in which the authors themselves manually inspected the relevant source code before and after the application of a refactoring with a text di tool to reveal possible motivations for the applied refactorings.
because they conducted this study without asking the opinion of the developers who actually performed the refactorings the interpretation of the motivation can be considered subjective and biased by the opinions and perspectives of the authors.
in addition the manual inspection of source code changes is a rather tedious and error prone task that could a ect the correctness of their ndings.
finally the examined refactorings were collected from the history of only three open source projects which were libraries or frameworks.
this is a threat to the external validity of the study limiting the ability to generalize its ndings beyond the characteristics of the selected projects.
in this study we collected refactorings from di erent projects and asked the developers who actually performed these refactorings to explain the reasons behind their decision to refactor the code.
.
research methodology .
selection of github repositories first we selected the top java repositories ordered by popularity in github stargazers count that are not forks.
from this initial list we discarded the lower quartile ordered by number of commits to focus the study on repositories with more maintenance activity.
the nal selection consists of repositories including well known projects likejetbrains intellij community apache cassandra elastic elasticsearch gwtproject gwt and springprojects spring framework .
figure shows violin plots with the distribution of20 all active studied age months a age all active studied100 000number of commits log scale b commits all active studied1101001 000number of java files log scale c source les all active studied1 000number of contributors log scale d contributors figure distribution of a age b commits c java source les and d contributors of repositories age in months number of commits size number of java les and number of contributors of the selected repositories.
we provide plots for all systems labeled as all for the systems with at least one commit during the study period labeled as active and for the systems e ectively analyzed in the study labeled as studied which correspond to the repositories with at least one refactoring detected in the commits during the study period days along with answers from the developers to our questions about the motivation behind the detected refactorings.
we can observe in figure that the active systems tend to have a higher number of commits source les and contributors than the initially selected systems all .
the same holds when comparing the studied systems with the active systems.
these observations are statistically con rmed by applying the one tailed variant of the mann whitney utest.
.
refactoringminer tool in the study we search for refactorings performed in the version history of the selected github repositories by analyzing the di erences between the source code of two revisions.
for this purpose we use a refactoring detection tool proposed in a previous work .
the tool named refactoringminer in this paper implements a lightweight version of the umldi algorithm for di erencing object oriented models.
this algorithm is used to infer the set of classes methods and elds added deleted or moved between successive code revisions.
after executing this algorithm a set of rules is used to identify di erent types of refactorings.
unlike other existing refactoring detection tools such as reffinder and jdevan refactoringminer provides an api and can be used as an external library independently from an ide while ref finder and jdevan can be executed only within the eclipse ide.
the strong dependency of reffinder and jdevan to the eclipse ide prevented us from using these tools in our study since as it will be explained in section .
our study required a high degree of automation and this could be achieved only by being able to use refactoringminer programmatically through its api.
in the study we analyze well known refactoring types detected by refactoringminer as listed in the rst column of table .
the detection of rename class method field refactorings is not currently supported by refactoringminer because it requires a more advanced source code analysis that examines changes in usage patterns i.e.
changes in class instantiations method call sites eld accesses respectively to verify the consistency of the renaming operation.
typically these refactorings are performed to give a more meaningful name to the renamed code element.
previousstudies show that they are usually performed automatically using the refactoring tool support of popular ides .
.
.
refactoringminer precision and recall as we rely on refactoringminer to nd refactorings performed in the version history of software repositories it is important to estimate its recall and precision.
for this reason we evaluated refactoringminer using the dataset reported in a study by chaparro et al.
.
this dataset includes a list of refactorings performed by two ph.d. students on two software systems argouml and atunes along with the source code before and after the modi cations.
there are refactoring instances in total from which we selected all instances corresponding to of the refactoring types considered in this study instances per type .
the dataset does not contain instances of extract superclass interface move class and rename package refactorings.
we compared the list of refactorings detected by refactoringminer with the known refactorings in those systems to obtain the results of table which presents the number of true positives tp the number of false positives fp the number of false negatives fn the recall and precision for each refactoring type.
in total there are true positives i.e.
existing refactoring instances that were correctly detected and false negatives i.e.
existing refactoring instances that were not detected which yield a fairly high recall of .
.
besides there are false positives i.e.
incorrectly detected refactoring instances which yield a precision of .
.
the lowest observed recall is for pull up method .
while the lowest observed precision is forextract method .
.
in conclusion the accuracy of refactoringminer is at acceptable levels since ref finder the current state of theart refactoring reconstruction tool has an overall precision of according to the experiments conducted by its own authors while an independent study by soares et al.
has shown an overall precision of and an overall recall of for ref finder.
.
study design during days between june 8thand august 7th2015 we monitored all selected repositories to detect refactorings.
we built an automated system that periodically fetches commits from each remote repository to a local copy using the git fetch operation .
next the system iterates through each commit and executes refactoringminer to nd refactorings and store them in a relational database.
as in a previous study we compare each examined commit with its parent commit in the directed acyclic graphtable refactoringminer recall and precision refactoring tp fp fn recall prec.
extract method .
.
inline method .
.
pull up attribute .
.
pull up method .
.
push down attribute .
.
push down method .
.
move attribute .
.
move method .
.
total .
.
dag that models the commit history in git based version control repositories.
furthermore we exclude merge commits from our analysis to avoid the duplicate report of refactorings.
suppose that commit cmmerges two branches containing commits caandcb respectively.
suppose also that a refactoring refis performed in ca and therefore detected when we compare cawith its parent commit.
because the e ects of refare present in the code that resulted from cm refwould be detected again if we compared cm with cb.
therefore we assume that discarding merge commits from our analysis does not lead to any refactoring loss but rather avoids duplicate refactoring reports.
on each working day we retrieved the recent refactorings from the database to perform a manual inspection using a web interface we built to aid this task.
in this step we lter out false positives by analyzing the source code di of the commit.
in this way we avoid asking developers about false refactorings.
additionally we also marked commits that already include an explanation for the detected refactoring in the commit description to avoid asking an unnecessary question.
for instance in one of the analyzed commits we found several methods extracted from a method named oncreate and the commit description was refactored aimsicddbadapter dbhelper oncreate for easier reading thus it is clear that the intention of the refactoring was to improve readability by decomposing method oncreate .
therefore it would be unnecessary and inconvenient to ask the developer.
this process was repeated daily to detect the refactorings as soon as possible after their application in the examined systems.
in this way we managed to ask the developers shortly after they perform a refactoring to increase the chances of receiving an accurate response.
we send at most one email to a given developer i.e.
if we detect a refactoring by a developer who has been already contacted before we do not contact her again to avoid the perception of our messages as spam email.
the email addresses of the developers were retrieved from the commit metadata.
in each email we describe the detected refactoring s and provide a github url for the commit where the refactoring s is are detected.
in the email we asked two questions .
could you describe why did you perform the listed refactoring s ?
.
did you perform the refactoring s using the automated refactoring support of your ide?
with the rst question our goal is to reveal the actual motivation behind real refactorings instances.
with the second question we intend to collect data about the adequacy and usage of refactoring tools previously investigated in otherempirical studies .
in this way we can check whether the ndings of these studies are reproduced in our study.
we should clarify that by automated refactoring we refer to user actions that trigger the refactoring engine of an ide by any means e.g.
through the ide menus keyboard shortcuts or drag and drop of source code elements .
during the study period we sent emails and received responses achieving a response rate of .
.
each response corresponds to a distinct developer and commit.
the achieved response rate is signi cantly larger than the typical rate found in questionnaire based software engineering surveys .
this can be attributed to the rehouse interview nature of our approach in which developers provide their feedback shortly after performing a refactoring and have fresh in their memory the motivation behind it.
additionally we included in our analysis all commits whose description already explained the reasons for the applied refactorings totaling a set of commits.
this set of commits covers di erent projects and contains refactoring instances in total.
after collecting all responses we analyzed the answers using thematic analysis a technique for identifying and recording patterns or themes within a collection of documents.
thematic analysis involves the following steps initial reading of the developer responses generating initial codes for each response searching for themes among codes reviewing the themes to nd opportunities for merging and de ning and naming the nal themes.
these ve steps were performed independently by the rst two authors of the paper with the support of a simple web interface we built to allow the analysis and tagging of the detected refactorings.
at the time of the study the rst author author had years of research experience on refactoring while the second author author had over years of research experience on refactoring.
after the generation of themes from both authors a meeting was held to assign the nal themes.
in cases both authors suggested semantically equivalent themes that were rephrased and standardized to compose the nal set of themes.
the refactorings with divergent themes were then discussed by both authors to reach a consensus.
in cases one author accepted the theme proposed by the other author.
in the remaining cases the nal theme emerged from the discussion and was di erent from what both authors previously suggested.
figure shows a case of an extract method refactoring instance that was required to reach a consensus between the authors.
the developer who performed the refactoring explained that the reason for the refactoring was to support a new feature that required pagination as described in the following comment educational part of pycharm uses stepic.org courses provider.
this server recently decided to use pagination in replies.
by inspecting the source code changes we can see that a part of the original method getcourses left hand side of figure was extracted into method addcoursesfromstepic right hand side of figure .
after the refactoring the extracted method is called twice once before thewhile loop added in the original method and once inside the while loop.
for this reason author labeled this case as avoid duplication since the extracted method is reused two times after the refactoring.
however the extracted method contains additional new code to compute properly the url based on the page number passed as apublic static list?courseinfob getcoursesz2 try list?courseinfob result k new arraylist?courseinfobz21 finallist?courseinfob courseinfos k getfromstepicz courses h coursescontainerm class 2mcourses1 for zcourseinfo info h courseinfos2 final string coursetype k infomgettypez21 if zstringutilmisemptyorspaceszcoursetype22 continue final list?stringb typelanguage k stringutilmsplitzcoursetypeh if ztypelanguagemsizez2 kk ee pycharm prefixmequalsztypelanguagemgetzx222 resultmaddzinfo21 return result1 catch zioexception e2 logmerrorz cannot load course list y emgetmessagez221 return collectionsmemptylistz21 public static list?courseinfob getcoursesz2 try list?courseinfob result k new arraylist?courseinfobz21 int pagenumber k x1 boolean hasnext k addcoursesfromstepiczresulth pagenumber21 while zhasnext2 pagenumber yk q1 hasnext k addcoursesfromstepiczresulth pagenumber21 return result1 catch zioexception e2 logmerrorz cannot load course list y emgetmessagez221 return collectionsmemptylistz21 private static boolean addcoursesfromstepiczlist?courseinfob resulth int pagenumber2 throws ioexception final string url k pagenumber kk x v courses h coursesvpagek y final coursescontainer coursescontainer k getfromstepiczurlh coursescontainerm class final list?courseinfob courseinfos k coursescontainermcourses1 for zcourseinfo info h courseinfos2 final string coursetype k infomgettypez21 if zstringutilmisemptyorspaceszcoursetype22 continue final list?stringb typelanguage k stringutilmsplitzcoursetypeh if ztypelanguagemsizez2 kk ee pycharm prefixmequalsztypelanguagemgetzx222 resultmaddzinfo21 return coursescontainermmetamcontainskeyz has next ee coursescontainermmetamgetz has next kk booleanmtrue1 stringmvalueofzpagenumber21extracted code added code call to the extracted methodfigure example of extract method refactoring that was required to reach a consensus.
parameter rst line in the extracted method and to return a boolean indicating if there exists a next page last line in the extracted method .
for this reason author labeled this case as facilitate extension since the extracted method also helps to implement the new pagination requirement.
after deliberation the authors reached a consensus by keeping both theme labels since the extracted method serves both purposes of reuse and extension.
.
examined refactorings we monitored java projects during the study period and found commits in projects i.e.
projects remained inactive.
we also found projects with refactoring activity as detected by refactoringminer including false positives .
in these projects refactoring instances were detected in commits and were manually inspected by the rst author of the paper to con rm whether they are indeed true positives.
table refactoring activity refactoring tp fp prec.
com.
proj.
extract method .
move class .
move attribute .
rename package .
move method .
inline method .
pull up method .
pull up attribute .
extract superclass .
push down method .
push down attribute .
extract interface .
total .
table shows the number of true positives tp false positives fp and precision prec.
of refactoringminer by refactoring type as computed after the manual inspection of the detected refactorings.
in general our tool achieves very high precision for rename package pull up push down attribute method refactorings over94 and relatively high precision for extract method andmove attribute refactorings over while the precision for move method andextract superclass is .
however for some refactorings the precision is closer to namely extract interface inline method and move class .
we observed several cases of inner classes falsely detected as moved because their enclosing class was simply renamed.
by supporting the detection of rename class refactoring we could improve move class precision.
it should be emphasized that we asked the developers only about the true positives detected by refactoringminer.
in comparison to the results presented in section .
.
the precision is lower because the commits analyzed from github projects may include tangled changes while the commits analyzed in section .
.
include only refactoring operations.
tangled changes make the detection of refactorings more challenging thus resulting in more false positives.
finally table shows the number of distinct commits com.
and projects proj.
containing at least one true positive refactoring out of commits and out of projects with detected refactorings contain at least one true positive refactoring .
.
why do developers refactor?
in this section we present the results for the rst question answered by the developers regarding the reasons behind the application of the refactorings we detected.
based on the results of the thematic analysis process section .
we compile a catalogue of distinct motivations.
we dedicate section .
to discuss extract method which is the most frequently occurring refactoring operation in our study and also the one with the most observed motivations .
section .
presents the motivations for the remaining refactorings.
.
motivations for extract method table describes motivations for extract method refactoring and the number of occurrences for each of them.
the most frequent motivation is to extract a reusable method instances .
in this case the refactoring is motivated bytable extract method motivations theme description occurrences extract reusable method extract a piece of reusable code from a single place and call the extracted method in multiple places.
introduce alternative method signatureintroduce an alternative signature for an existing method e.g.
with additional or di erent parameters and make the original method delegate to the extracted one.
decompose method to improve readabilityextract a piece of code having a distinct functionality into a separate method to make the original method easier to understand.
facilitate extension extract a piece of code in a new method to facilitate the implementation of a feature or bug x by adding extra code either in the extracted method or in the original method.
remove duplication extract a piece of duplicated code from multiple places and replace the duplicated code instances with calls to the extracted method.
replace method preserving backward compatibilityintroduce a new method that replaces an existing one to improve its name or remove unused parameters.
the original method is preserved for backward compatibility it is marked as deprecated and delegates to the extracted one.
improve testability extract a piece of code in a separate method to enable its unit testing in isolation from the rest of the original method.
enable overriding extract a piece of code in a separate method to enable subclasses override the extracted behavior with more specialized behavior.
enable recursion extract a piece of code to make it a recursive method.
introduce factory method extract a constructor call class instance creation into a separate method.
introduce async operation extract a piece of code in a separate method to make it execute in a thread.
the immediate reuse of a piece of code in multiple other places in addition to the place from which it was originally extracted.
we often observe a concern among developers to reuse code wherever possible by extracting pieces of reusable code.
this is illustrated by the following comments these refactorings were made because of code reusability.
i needed to use the same code in new method.
i always try to reuse code because when there s a lot of code redundancy it gets overwhelmingly more complicated to work with the code in future because when something change in code that has it s duplicate somewhere it usually needs to be changed also there.
the reason for me to do the refactoring was don t repeat yourself dry .
the second most frequent motivation is to introduce an alternative method signature for an existing method instances e.g.
with extra parameters.
to achieve that the body of the existing method is extracted to a new one with an updated signature and additional logic to handle the extended variability.
the original method is changed to delegate to the new one passing some default values for the new parameters.
the following comment illustrates this case the extracted method values names list string values list object could be of help for some users using lists instead of arrays and because the implementation already transformed the provided arrays into lists internally.
decomposing a method for improving readability instances is the third most frequent motivation.
typically this corresponds to a long method code smell as illustrated in this comment the method was so long that it didn t t onto the screen anymore so i moved out parts.
the next two motivations are to facilitate extension instances and to remove duplication instances .
in the rst case a method is decomposed to facilitate the implementation of a new feature or the x of a bug by addingcode either in the extracted or in the original method as illustrated in this comment i was xing an exception in order to do that i had to add the same code to di erent places.
so i extracted initial code replace duplicate with the extracted method and add the x to the extracted method.
in the second case i.e.
remove duplication a piece of duplicated code is extracted from multiple places into a single method as illustrated in the following comments i refactored shared functionality into a single method.
i checked how other test methods create testing user objects and noticed that it takes two lines of code that were repeated all over the test class.
so i abstracted these two lines of code into a method for better readability and then reused the method in all the places that had the same code.
finally two other important motivations are to improve testability instances and to replace a method by preserving backward compatibility instances .
in the rst case the decomposition enables the developer to test parts of the code in isolation as illustrated in this comment i wanted to test the part of authenticate which veri es that a member is element of a set and that would have been more complex using authenticate directly.
in the second case the goal is to introduce a method having the same functionality with an already existing one but a di erent signature e.g.
improved name or removed unused parameter and at the same time preserve the public api by making the original method delegate to the new one.
this motivation is best illustrated in the following comment i did that refactoring because essentially i wanted to rename the functions involved you ll see the old functions just forward straight to the new ones.
but i didn t just rename because other code in other projects might be referring to the old functions so they would need to still be present i guess they should have been marked as deprecated then but i was a bit lazy here .
table motivations for move class attribute method mc ma mm rename package rp inline method im extract superclass interface es ei pull up method attribute pum pua push down attribute method pda pdm type theme description occurrences mc move class to appropriate container move a class to a package that is more functionally or conceptually relevant.
mc introduce sub package move a group of related classes to a new subpackage.
mc convert to top level container convert an inner class to a top level class to broaden its scope.
mc remove inner classes from deprecated containermove an inner class out of a class that is marked deprecated or is being removed.
mc remove from public api move a class from a package that contains external api to an internal package avoiding its unnecessary public exposure.
mc convert to inner class convert a top level class to an inner class to narrow its scope.
mc eliminate dependencies move a class to another package to eliminate undesired dependencies between modules.
mc eliminate redundant sub package eliminate a redundant nesting level in the package structure.
mc backward compatibility move a class back to its original package to maintain backward compatibility.
ma move attribute to appropriate class move an attribute to a class that is more functionally or conceptually relevant.
ma remove duplication move similar attributes to another class where a single copy of them can be shared eliminating the duplication.
rp improve package name rename a package to better represent its purpose.
rp enforce naming consistency rename a package to conform to project s naming conventions.
rp move package to appropriate containermove a package to a parent package that is more functionally or conceptually relevant.
mm move method to appropriate class move a method to a class that is more functionally or conceptually relevant.
mm move method to enable reuse move a method to a class that permits its reuse by other classes.
mm eliminate dependencies move a method to eliminate dependencies between classes.
mm remove duplication move similar methods to another class where a single copy of them can be shared eliminating duplication.
mm enable overriding move a method to permit subclasses to override it.
im eliminate unnecessary method inline and eliminate a method that is unnecessary or has become too trivial after code changes.
im caller becomes trivial inline and eliminate a method because its caller method has become too trivial after code changes so that it can absorb the logic of the inlined method without compromising readability.
im improve readability inline a method because it is easier to understand the code without the method invocation.
es extract common state behavior introduce a new superclass that contains common state or behavior from its subclasses.
es eliminate dependencies introduce a new superclass that is decoupled from speci c dependencies of a subclass.
es decompose class extract a superclass from a class that holds many responsibilities.
pum move up common methods move common methods to superclass.
pua move up common attributes move common attributes to superclass.
ei facilitate extension introduce an interface to enable di erent behavior.
ei enable dependency injection introduce an interface to facilitate the use of a dependency injection framework.
ei eliminate dependencies introduce an interface to avoid depending on an existing class interface.
pda specialized implementation push down an attribute to allow specialization by subclasses.
pda eliminate dependencies push down attribute to subclass so that the superclass does not depend on a speci c type.
pdm specialized implementation push down a method to allow specialization by subclasses.
.
motivations for other refactorings table presents the motivations for the remaining refactorings studied in the paper.
we found nine di erent motivations for move class .
the two most frequent motivations are to move a class to a package that is more functionally or conceptually related to the purpose of the class instances and to introduce a sub package instances .
the rst one is illustrated by the following comment this refactoring was done because common interface for those classes lived in org.neo4j.kernel.impl.store.
record while most of it s implementors lived in org.neo4j.
kernel.impl.store which did not make sense because all of them are actually records.
formove attribute the most common motivation is also to move the attribute to an appropriate class that is more functionally or conceptually relevant instances as in the example below in this case each of these elds was moved as their relevance changed.
as userservice already handles the login process it makes sense that changes to the login process should be encapsulated within userservice .
remove duplication is another motivation for moving an attribute as illustrated by the following comment the attributes were duplicated so i moved them to the proper common place.
forrename package the most common motivation is to update the name of a package to better represent its purpose instances as in the example below this was a simple package rename.
test seems to t better than tests here as a single test can be executed too.
we found three main reasons for a move method refactoring move a method to an appropriate class instances move a method to enable reuse instances and move a method to eliminate dependencies instances .
the most frequent motivation for inline method is to eliminate an unnecessary or trivial method as illustrated in the comment since the method was a one liner and was used only in one place inlining it didn t make the code more complex.
on the other hand it allowed to lessen calls to getvirtualfile .
extract superclass is usually applied to introduce a new class with state or behavior that can be shared by subclasses instances .
pull up method attribute is performed to move common code to an existing superclass and instances respectively .
extract interface and push down attribute method are less popular refactorings and thus their motivations have at most two instances.
.
refactoring automation in this section we discuss the results drawn from the second question answered by the developers regarding the use or not of automatic refactoring tools provided by their ides to apply the refactorings we presented.
first in section .
we present how many of the interviewed developers applied the refactoring s automatically.
we also present which refactoring types are more frequently applied with tool support.
in section .
we discuss some insights drawn from developers answers that explain why refactoring is still applied manually in most of the cases.
last in section .
we present additional details regarding which ide developers most often used for refactoring.
.
are refactoring tools underused?
table shows the results for this question.
developers of valid answers answered that the refactoring was performed manually without tool support developers answered that the refactoring engine of an ide was used developers answered that the refactoring was partially automated.
in summary refactoring is probably more often applied manually than with refactoring tools.
table manual vs. automated refactoring modi cation occurrences manual automated not answered partially automated we also counted the percentage of automated refactorings by refactoring type as presented in table .
rename package is the refactoring most often performed with tool support followed by move class .
three other refactorings are performed automatically in around a quarter of the cases extract method move method and move attribute .
inline method follows with of automatic applications.
finally for the remaining refactorings we do not have a large number of instances to draw safe conclusions maximum instances but there is a consistent trend showing that inheritance related refactorings are mostly manually applied.
table refactoring automation by type refactoring type occurrences automated extract method move class move attribute move method inline method rename package extract superclass pull up method pull up attribute extract interface push down attribute push down method .
why do developers refactor manually?
developers explained in their answers why they did not use a refactoring tool.
table shows ve distinct themes we identi ed in these answers.
table reasons for not using refactoring tools description occurrences the developer does not trust automated support for complex refactorings.
automated refactoring is unnecessary because the refactoring is trivial and can be manually applied.
the required modi cation is not supported by the ide.
the developer is not familiar with the refactoring capabilities of his her ide.
the developer did not realize at the moment of the refactoring that he she could have used refactoring tools.2lack of trust instances was the most frequent reason.
some developers do not trust refactoring tools for complex operations that involve code manipulation and only use them for renaming or moving i don t trust the ide for things like this and usually lose other comments notation spacing from adjacent areas.
i d say developers are reluctant to let a tool perform anything but trivial refactorings such as the ones you picked up on my commit.
on the other hand some developers also think that tool support is unnecessary in simple cases instances .
sometimes the operation may involve only local changes and is trivial to do by hand.
thus calling a special operation to do it is considered unnecessary as illustrated by this comment automated refactoring is overkill for moving some private elds.
additionally developers also mentioned lack of tool support for the speci c refactoring they were instances not being familiar with refactoring features of the ide instances and not realizing they could use refactoring tools at the moment of the refactoring instances .
.
what ides developers use for refactoring?
when answering to our emails developers spontaneously mentioned which ide they use.
therefore we decided to investigate these answers specially because our study is not dependent on any ide and thus di ers from previous studies which are usually based only on eclipse data .
table shows the most common ides mentioned in these answers and the percentage of refactorings performed automatically in these cases.
developers did not explicitly mention an ide when answering this question.
considering the answers citing an ide intellij idea is the most popular one.
it also has the highest ratio of refactorings performed automatically .
since jetbrains intellij community and related plug ins developers answered to our questions we also investigated the answers separately in two groups namely answers from intellij idea developers and from intellij idea users.
we observed that the ratio of automated refactorings in both groups is very similar vs. .
therefore the responses from these intellij idea developers do not bias the percentage of automated refactoring reported for intellij idea.
table ide popularity ide occurrences automated editor not mentioned intellij idea eclipse netbeans android studio text editor .
discussion in this section we discuss the main ndings of our study.
refactoring motivations our study con rms that extract method is the swiss army knife of refactorings .
it is the refactoring with the most motivations in total .
in comparison to there is an overlap in the reported motivation themes for extract method .
we found some new themes such as improve testability andenable recursion butwe did not nd any instances of the themes encapsulate eld and hide message chain reported in which are related to code smell resolution.
we assume these di erent themes are due to the nature of the examined projects since examined only three libraries and frameworks while in this study we examined projects from various domains including standalone applications.
by comparing to the code symptoms that initiate refactoring reported in the study by kim et al.
we found the readability reuse testability duplication and dependency motivation themes in common.
most of the refactoring motivations we found have the intention to facilitate or even enable the completion of the maintenance task that the developer is working on.
for instance extract reusable method introduce alternative method signature and facilitate extension are among the most frequent motivations and all of them involve enhancing the functionality of the system.
therefore extract method is a key operation to complete other maintenance tasks such as adding a feature or xing a bug.
in contrast only two out of the motivations we found decompose method to improve readability andremove duplication are targeting code smells.
this nding could motivate researchers and tool builders to design refactoring recommendation systems that do not focus solely on detecting refactoring opportunities for the sake of code smell resolution but can support other refactoring motivations as well.
we also observe that developers are seriously concerned about avoiding code duplication when working on a given maintenance task.
they often use refactorings especially extract method to achieve this goal as illustrated by the following comments i need to add a check to both the then and the else part of an if statement.
this resulted in more duplicated code than i was comfortable with.
there was already code duplication but the bug x required another cut and paste which made it code triplication.
that was above my pain level so i decided to group the replicated code out into bail .
the other refactorings we analyzed are typically performed to improve the system design.
for example the most common motivation for move class move attribute and move method is to reorganize code elements so that they have a stronger functional or conceptual relevance.
automated vs. manual refactoring in a eld study with eclipse users negara et al.
report that most refactorings are manually performed.
in our study involving developers using a wider variety of ides we found that of refactorings are manually performed.
however we also found that intellij idea users tend to use more the refactoring tool support than other ide users.
moreover the results for automated extract method refactorings are very similar in both studies in our study against in their study.
while the total percentages of manually performed refactorings are very similar we should keep in mind that negara et al.
counted simple refactorings like renamings which are more often applied with tool support.
compared to the study by murphy hill et al.
where they report that of refactorings are performed manually considering also renamings we detected signi cantly more automated refactorings.
we suspect this di erence may be due to two reasons.
first automated refactoring tools may have become more popular and reliable over the last years.second our study involves developers using a broader range of ides which may also in uence how developers use refactoring tool support.
regarding the reasons for not using automated refactoring our results are in line with the three main factors found in the study by murphy hill et al.
awareness opportunity and trust.
the exception is the argument that tool support is unnecessary in simple cases which is not closely related to any of the three aforementioned factors.
however the same argument can be observed in the study by kim et al.
in which some developers mention that they do not feel a great need for automated refactoring tools.
refactoring popularity in this study we detected refactorings in of the monitored repositories in a time window of days.
given that only out of the monitored repositories were active during that period we found refactoring activity in .
of the repositories with at least one commit.
this shows that refactoring is a common practice especially considering that frequent refactorings such as rename class method field were not considered.
the top most popular refactorings detected in our study areextract method move class move attribute rename package and move method .move method is the third most popular refactoring in the study by negara et al.
.
the top refactorings in this study rename local variable andextract local variable are lowlevel refactorings which have not been considered in our study.
we focused on high level refactorings because they can be motivated by multiple factors.
using a sample of commits with manual and automated refactorings murphy hill et al.
report that the two most popular refactorings are rename constant and push down .
however push down refactorings are among the least popular ones in our study.
this di erence may be related to the number of commits analyzed in the studies vs. commits in our study and the specialized nature of the software i.e.
the eclipse ide examined in .
.
threats to validity external validity this study is restricted to open source java based github hosted projects.
thus we cannot claim that our ndings apply to industrial systems or to systems implemented in other programming languages.
however we collected responses from developers contributing in di erent projects which is one of the largest samples of systems used in refactoring studies.
internal validity first we use in the study a tool that detects refactorings by comparing two revisions of the code.
we evaluated the recall of this tool using a sample of documented refactoring operations.
we achieved a recall of .
.
however we cannot guarantee a similar recall in the studied github projects because some commits might contain tangled changes making more di cult to isolate or untangle the changes related to refactorings.
in addition it is known that this kind of detection approach may miss refactorings that do not reach the version control system e.g.
sequences of overlapping refactorings applied to the same piece of code .
we claim this threat should be tolerated in large scale studies where we cannot assume that the developers would be willing to install an external monitoring tool in their ides .
furthermore as we showed in this study developers nowadays use ides from multiple vendors.in order to cover as many ides as possible and strengthen the external validity a study based on monitoring would require to develop a separate version of this tool for each ide.
second we cannot claim that the catalogue of motivations we propose is exhaustive.
notably we have a limited number of motivation themes for less frequent refactoring types such as push down method attribute andextract interface .
third to mitigate inconsistencies in the proposed themes we rely on an initial classi cation performed independently by two authors of the paper followed by a consensus building process.
we also make publicly available the responses collected from the developers and the proposed refactoring motivation themes to provide a means for replication and veri cation.
.
conclusions in summary the main conclusions and lessons learned are .
refactoring activity is mainly driven by changes in the requirements i.e.
new feature and bug x requests and much less by code smell resolution.
only out of the motivations for extract method were related to code smell resolution remove duplication decompose method covering only of the motivation instances.
.extract method is a key operation that serves multiple purposes specially those related to code reuse and functionality extension.
it is also used to improve the testability of code and deprecate public api methods.
.
the elimination of dependencies is the most common motivation among the move abstract related refactorings.
.
manual refactoring is still prevalent of the developers refactored manually the code .
in particular inheritance related refactoring tool support seems to be the most under used only done automatically while move class andrename package are the most trusted refactorings over done automatically .
.
the ide plays an important role in the adoption of refactoring tool support.
intellij idea users perform more automated refactorings done automatically than eclipse users and netbeans users .
.
compared to the study by murphy hill et al.
it seems that developers apply more automated refactorings nowadays.
our ndings con rm negara et al.
who collected data only from eclipse ide users but our study covers developers using more ides.
based on our ndings we propose that future research on refactoring recommendation systems should refocus from code smell oriented to maintenance task oriented solutions.
this could be achieved by leveraging the recent advancements in feature location and requirements tracing to automatically locate the code associated with a feature or bug x request or a requirement change and recommend suitable refactorings that will make easier the completion of the maintenance task.
we strongly believe this will boost the adoption of recommendation systems by the developers.