contract based program repair without the contracts liushan chen y u pei carlo a. furia department of computing the hong kong polytechnic university china cslschen csypei comp.polyu.edu.hk department of computer science and engineering chalmers university of technology sweden bugcounting.net abstract automated program repair apr is a promising approach to automatically fixing software bugs.
most apr techniques use tests to drive the repair process this makes themreadily applicable to realistic code bases but also brings therisk of generating spurious repairs that overfit the availabletests.
some techniques addressed the overfitting problem bytargeting code using contracts such as pre and postconditions which provide additional information helpful to characterizethe states of correct and faulty computations unfortunately mainstream programming languages do not normally includecontract annotations which severely limits the applicability ofsuch contract based techniques.
this paper presents jaid a novel apr technique for java programs which is capable of constructing detailedstate abstractions similar to those employed by contract basedtechniques that are derived from regular java code without anyspecial annotations.
grounding the repair generation and valida tion processes on rich state abstractions mitigates the overfittingproblem and helps extend apr s applicability in experimentswith the defects 4jbenchmark a prototype implementation of jaid produced genuinely correct repairs equivalent to those written by programmers for bugs improving over the stateof the art of comparable java apr techniques in the numberand kinds of correct fixes.
i. i ntroduction every general software analysis technique based on a finite collection of tests is prone to overfitting them.
automated program repair apr is no exception in particular overfitting is likely to cripple the performance of apr tools followingthe generate then validate paradigm that was pioneered by genprog where each heuristically generated candidate repair a source code patch undergoes testing and only thecandidates that pass all available tests for the method beingrepaired are classified as valid and returned as fix suggestions.
since validation is against a finite often small number oftests there is no guarantee that a valid repair is genuinelycorrect against a complete and implicit specification of the method.
indeed experiments have repeatedly confirmed that automated program repair techniques are proneto producing a significant fraction of valid but incorrectrepairs which merely happen to pass all available tests butare clearly inadequate from a programmer s perspective.
the autofix technique for apr mitigated the overfitting problem by using contracts made of assertions such as pre and postconditions as additional information to improvethe precision of repair generation and validation.
even if thecontracts used by autofix are far from being detailed letalone complete method specifications they significantly helpincrease the fraction of correct fixes that can be generated .unfortunately even such simple contracts are hardly everavailable in the most widely used programming languages.
can we still generalize some of the techniques used forcontract based program repair to work effectively without userwritten contracts?
in this paper we describe jaid a technique and tool for automated program repair of java programs that is based on detailed state based dynamic program analyses akin those employed by contract based techniques such asautofix but working on regular java code without anycontracts .
state abstractions drive both the generation and thevalidation stages of jaid and help construct high quality fixes in experiments targeting bugs from the defects 4j curated collection jaid produced repairs passing all available tests for of the bugs and correct repairs equivalent to those written by programmers for of the bugs.
these resultsare close to or outperform other comparable tools for theautomated program repair of java programs in terms of totalnumber of correct repairs and precision and include thefirst automatically produced correct repairs for bugs of defects 4j that were previously outside the capabilities of apr.
jaid is also the first apr technique that achieves high levels of precision without relying on additional input other than tests and faulty code in contrast other recent high precision apr techniques analyze a large numberof project repositories to collect additional information thatguides fixing.
this paper s key contributions which bolster jaid s performance include techniques to build a rich abstraction of object state.
in turn the state abstraction relies on a purity analysis of functions only functions that are pure that is withoutside effects can be safely used to characterize state.
whereastechniques such as autofix that use programmer writtencontracts can easily rely on the functions used as predicatesin the contracts jaid has to extract similar information from regular code without annotations.
to curb the number ofcandidate fixes that are generated and validated jaid relies on fault localization and ranking heuristics which help identify program states that are likely to be implicated with faultybehavior both fault localization and ranking are cruciallyinformed by jaid s detailed state based abstractions.
thanks 1autofix targets the eiffel programming language where contracts are embedded in the program code and routinely written by programmers.
.
c ieeease urbana champaign il usa technical research637 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to these techniques jaid can generate correct fixes that are based on a more semantic analysis of how to modify the object state to avoid a failure beyond just working aroundthe existing implementation by syntactically modifying it asmost other apr tools do.
terminology.
in this paper we use the nouns defect bug fault and error as synonyms to indicate errors ina program s source code and the nouns fix patch and repair as synonyms to indicate source code modificationsthat ought to correct errors.
for simplicity jaid denotes both the apr technique and the tool implementing it.
a vailability.
jaid and all the material of the experiments described in this paper is available as open source at ii.
a nexample of jaid inaction apache commons is a widely used java library that extends java s standard api with a rich collection of utilities.
class wordutil of package org.apache.commons.lang includes a method abbreviate to simplify strings with spaces given a string str lower and upper indexes lower and upper and another string appendtoend the method returns a string obtained by truncating str at the first index between lower and upper where a space occurs and replacing or abbreviating the truncated suffix with appendtoend .
for example abbreviate apache commons library returns the string apache commons .
lst.
shows the implementation of abbreviate at commit cfff06bead of the library which is also part of defects 4j s curated collection of defects bug lang .
the implemen tation begins by handling a number of special cases but unfortunately it misses the case when lower is greater than str s length the index of the first occurrence of a space from lower will then be corresponding to a failing search for such a space in the call at line and upper will be greater than or equal to lower possibly after being adjusted at lines and thus also greater than str.length in these conditions the call to method substring at line throws an indexoutofboundsexception .
the maintainers of apache commons fixed this fault in a later version of the library by resetting lower tostr.length to ensure that the case lower str.length never occurs as shown in the patch of lst.
to be inserted right beforeline in lst.
.
defects 4jincludes a test that triggers this fault in abbreviate to avoid reintroducing the same mistake in future revisions of the code.
after running for about minutes jaid produces a number of fix suggestions for the fault of abbreviate including the fix in lst.
this fix is equivalent nearly identical tothe programmer written fix and thus completely removes thesource of error by handling the special case correctly.
togenerate fixes for abbreviate jaid only needs the source code of the faulty implementation as well as the programmer written tests that exercise the method.
defects 4j actually includes only one test the test triggering the fault for this1public static string abbreviate string str int lower int upper string appendtoend if str null return null if str.length return stringutils.empty if upper upper str.length upper str.length if upper lower upper lower stringbuffer result new stringbuffer int index stringutils.indexof str lower if index throws indexoutofboundsexception if lower str.length result.append str.substring upper if upper !
str.length result.append stringutils.defaultstring appendtoend else if index upper result.append str.substring upper result.append stringutils.defaultstring appendtoend else result.append str.substring index result.append stringutils.defaultstring appendtoend return result.tostring listing .
faulty method abbreviate from class stringutils in package org.apache.commons.lang .
8a10 if lower str.length lower str.length listing .
programmer written fix to the fault in abbreviate .8a10 if lower str.length lower str.length listing .
jaid s correct fix to the fault in abbreviate .
bug jaid can produce a correct fix even with such limited information.
to our knowledge jaid is the first apr tool that can correctly repair the fault of abbreviate no other existing tools even provided so called test suite adequate fixes which spuriously pass all available tests avoiding the failure butdo not correctly fix the behavior in the same way thatthe developers did.
key to jaid s success is its capability of constructing rich state based abstractions of a program sbehavior which improves the accuracy of fault localizationand guides the creation of state modifying fixes in responseto failing conditions.
iii.
h ow jaid works jaid follows the popular generate then validate approach which first generates a number of candidate fixes and thenvalidates them using the available test cases fig.
givesan overview of the overall process.
inputs to jaid are a java program consisting of a collection of classes and testcases that exercise the program and expose some failures.one key feature of jaid is how it abstracts and monitors program state in terms of program expressions all stages of jaid s workflow rely on the abstraction derived as described in sec.
iii a. fault localization sec.
iii b identifies statesand locations snapshots that are suspect of being implicated authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in the failure under repair.
fix generation sec.
iii c and sec.
iii d builds code snippets that avoid reaching suchsuspicious states and locations by modifying the program state the control flow or by other simple heuristics.
generated fixesare validated against the available tests sec.
iii e the fixesthat pass validation are presented to the user heuristicallyranked according to how likely they are correct sec.
iii f .
the rest of this section describes how jaid repairs a generic method fixme of class fc with tests tthat exercise fixme in a way that at least one test in tis failing.
java program test cases fault localization fix generation fix validation fix ranking ranked valid fixessuspicious snapshots candidate fixes valid fixes jaid fig.
.
an overview of how jaid works.
given a java program and a set of test cases including at least one failing test jaid identifies a number of suspicious snapshots each indicating a location and an abstraction of the program state at that location that may be implicated in the failure based onthe snapshot information jaid generates a number of candidate fixes which undergo validation against all available tests for the method under repair fixesthat pass all available tests are considered valid jaid finally heuristically ranks the valid fixes and presents the valid fixes to the user in ranking order.
a. program state abstraction jaid bases its program analysis and fix generation processes on a detailed state based abstraction of the behavior of method fixme .
for every location lscriptinfixme uniquely identifying a statement in the source code the jaid records the values of a setm lscriptof expressions during each test execution the exact value of expressions of numeric and boolean types the object identifier or null of expressions of reference types so that it can detect when a reference is aliased or is null .
jaid selects the expressions in m lscriptas follows.
expressions.
a type is monitorable if it is a reference type or a primitive type numeric types such as int and boolean .e lscriptdenotes the set of all basic expressions of monitorable types at lscript namely local variables including fixme s arguments declared inside fixme that are visible at lscript attributes of class fcthat are visible at lscript expressions anywhere inside fixme that can be evaluated at lscript that is they only involve items visible at lscript and that don t obviouslyhave side effects namely we exclude assignments used asexpressions self increment and decrement expressions andcreation expressions using new .x lscriptdenotes the set of all extended expressions of monitorable types at lscript for each basic expression of reference type r e lscript x lscriptincludes r.f for every argumentless function fof the class corresponding tor s type that returns a monitorable type and is callable at lscript only if risthis r.a for every attribute aof the class corresponding to r s type that is readable at lscript.
for example the extended expressions x9at line in method abbreviate of lst.
include lower an argument ofabbreviate str.length a call of function length onabbreviate s argument str and upper lower and str null both appearing in abbreviate .
purity analysis.
one lesson that we can draw from the experience of contract based apr is that constructing arich set of expressions that abstract the program state can helpsupport more accurate fault localization and fix generation andultimately the construction of higher quality semantic fixesthat are less prone to overfitting.
however monitoring a richset of expressions extracted from the program text does notwork as well in languages such as java as it does in languagesthat support contracts.
in the latter programmers specificallyequip classes with public query methods that are pure they are functions that return a value without changing the state oftheir target objects and can be used in the contracts to char acterize the program state in response to method calls thesemethods are thus easily identifiable and natural candidatesto construct state abstractions reliably.
in java in contrast programmers need not follow such a discipline of separatingpure functions from state changing procedures and methodsthat return a value but have side effects are indeed common.clearly a function that is not pure is unsuitable for abstractingand monitoring an object s state.
to identify which expressions can reliably be used for state monitoring jaid performs a dynamic purity analysis on all expressions that include method invocations.
givenan expression rof reference type the set w rofr swatch expressions consists of all subexpressions srofrthat do not include method invocations for each subexpressions s r s.afor every attribute aof the class corresponding to s s type.
note that watch expressions are constructed so that they are syntactically free from side effects.
an expression rof reference type is then considered pure if evaluating it does not alter the value of its watch expressions.precisely at every location lscriptin the method fixme under repair first jaid records the value angbracketleft 1 ... m angbracketrightof all watch expressions where kis the value of wk wr for k m before evaluating r then jaid evaluates r finally jaid records again the value prime angbracketleft prime ... prime m angbracketrightof all watch expressions where prime kis the value of wk wr for k m after evaluating r.i f primeat every lscriptin every test exercising fixme we call rpure.
state monitoring.
jaid collects in m lscriptall extended expressions inx lscriptthat are pure according to this analysis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. fault localization the goal of fault localization is to identify suspicious snapshots indicating locations and states that are likely to be implicated with a fault.
a snapshot is a triple angbracketleft lscript b ?
angbracketright where lscriptis a location in method fixme under repair bis a boolean expression and ?is the value true orfalse o fb at lscript.
boolean abstractions.
the setb lscriptincludes all boolean expressions that may appear in a snapshot at lscript it is constructed by combining the monitored expressions m lscriptto create boolean expressions as follows for each pair m1 m2 m lscriptof expressions of the same type b lscriptincludes m1 m2and m1!
m2 for each pair k1 k2 m lscriptof expressions of integer type b lscriptincludes k1 triangleleft k for triangleleft for each expression b m lscriptof boolean type b lscriptincludesb and!b for each pair b1 b2 m lscriptof expressions of boolean type b lscriptincludesb1 b2andb1 b2.
continuing the example of method abbreviate in lst.
b9includes expressions such as lower str.length and !
str null .
snapshot suspiciousness.
jaid computes the suspiciousness of every snapshot s angbracketleft lscript b ?
angbracketrightbased on wong at al.
s fault localization techniques .
the basic idea is that the suspiciousness of scombines two sources of information a syntactic analysis of expression dependence which givesa higher value ed stosthe more subexpressions bshares with those used in the statements immediately before andimmediately after lscript this estimates how much sis relevant to capture the state change at lscript a dynamic analysis which gives a higher value dy stosthe more often bevaluates to ?
at lscriptin a failing test and a lower value to sthe more often b evaluates to ?at lscriptin a passing test this collects the evidence that comes from monitoring the program during passing andfailing tests .
the overall suspiciousness ed s dy s is the harmonic mean of these two sources but the dynamicanalysis has the biggest impact because ed sis set up to be a value between zero and one whereas dysis at least one and grows with the number of passing tests.
this approach is similar to autofix s which is also based on but conspicuously excludes informationabout the distance between lscriptand the location of failure on the control flow graph of the faulty method.
autofix identifiesfailures as contract violations which tend to be happen closerto where the program state becomes corrupted by contrast in jaid s setting using tests without contracts in java failures normally happen when evaluating an assert statement insidea test method and thus the distance to the location of failurewithin the faulty method is immaterial and hardly a reliableindication of suspiciousness.
in the running example of method abbreviate in lst.
the snapshot angbracketleft9 lower str.length true angbracketrightreceives a high suspiciousness score because low and str.length appear prominently in the statements around line and mostimportant lower str.length holds in all failing and in no passing tests.c.
fix generation fix actions a snapshot s angbracketleft lscript b ?
angbracketrightwith high suspiciousness indicates that the program is prone to triggering a failure when theprogram state in some execution is such that bevaluates to ?
at lscript correspondingly jaid builds a number of candidate fixes that try to steer away from the suspicious state in the hope of avoiding the failure.
to this effect jaid enumerates four kinds of fix actions modify the state directly by assignment affect the state that is used in an expression mutate astatement redirect the control flow.
each fix action is a pos sibly compound statement that can replace the statement at lscript.
actions of kinds and are semantic they directly target the program state actions of kind are syntactic they tinkerwith existing code expressions according to simple heuristics actions of kind are the simplest they are independent ofthe snapshot s information.
we outline how jaid builds fix actions in the following paragraphs based on a definition ofderived expressions.
sec.
iv discusses which fix actions werethe most effective in the experimental evaluation.
derived expression.
given an expression e lscript e denotes all derived expressions built from eas follows if ehas integer type lscript e includes e e ande i fe has boolean type lscript eincludeseand!e lscript ealso includes t andt.f for every t m lscriptof reference type where fis a function of the class tbelongs to possibly called with actual arguments chosen from the monitored expressionsm lscriptof suitable type.
given an expression e its top level subexpressions seare the expressions corresponding to the nodes at depth in e s abstract syntax tree namely the root s immediate children.
for example the top level subex pressions of a b c.d area b and c.d .
then prime lscript e uniontext s s e lscript e denotes all expressions derived from e s top level subexpressions.
modifying the state.
for every top level subexpression e ofb i fe is assignable to jaid generates the fix action e for each prime lscript bwhose type is compatible with e s. in the running example of method abbreviate in lst.
jaid includes the assignment lower str.length among the fix actions that modify the state at line .
modifying an expression.
for every top level subexpressioneofbthat is not assignable to but appears in the statement sat lscript jaid generates the fix action tmp e s for each prime lscript bwhose type is compatible with e s tpm e is a fresh variable with the same type as e ands is the statement at lscriptwith every occurrence of ereplaced by tmp e which has just been assigned a modified value.
mutating a statement.
semantic fix actions based on the information captured by the state in suspicious snapshots are usefully complemented by a few syntactic fix actions based on simple mutation operators that capture commonsources of programming mistakes such as off by one errors.following an approach adopted by other apr techniques jaid generates mutations mainly targeting conditional expressions.
precisely if the statement sat lscriptis a conditional or a loop jaid generates fix actions for every boolean subex640 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pression eofbthat appears in the conditional s condition or in the loop s exit condition if eis a comparison x1 triangleleft x for triangleleft jaid generates the fix actions for every comparison operator triangleleft prime negationslash triangleleft jaid also generates the fix actions s ands whereeis replaced by a boolean constant.
in addition to targeting boolean expressions if the statement sat lscriptincludes a method call t.m a ... an jaid generates the fix action s which calls any applicable method x on the same target and with the same actual arguments as m ins.
modifying the control flow.
even though fix actions may indirectly change the control flow by modifying the state or abranching condition a number of bugs require abruptly redi recting the control flow.
to achieve this jaid also generates the following fix actions independent of the snapshot information if method fixme is a procedure its return type is void jaid generates the fix action return if method fixme is a function jaid generates the fix action returne for every basic expression of suitable type available at lscript i f lscript is a location inside a loop s body jaid generates the fix action continue .
d. fix generation candidate fixes each fix action built by jaid as described in the previous section is a statement that modifies the program behaviorat location lscriptin a way that avoids the state implicated by some suspicious snapshot s angbracketleft lscript b ?
angbracketright.
in most cases a fix action should not be injected into the program under repairunconditionally but only when state bis actually reached during a computation.
a conditional execution would leaveprogram behavior unchanged in most cases and only addressthe failing behavior when it is about to happen.
to implement such conditional change of behavior jaid uses the schemas in fig.
to insert fix actions into the method fixme under repair at location lscript.
first jaid instantiates every applicable schema with each fix action action in addition to the fix action schemas include the statement oldstatement at location lscriptin the faulty fixme and the condition suspicious which isb ?as determined by the snapshot s abstract state.
then jaid builds fix candidates byreplacing the statement at lscriptinfixme by each instantiated schema.
continuing the running example of method abbreviate in lst.
one of the fix candidates consists of the fix action lower str.length instantiating schema b the action is executed only if lower str.length from the suspicious snapshot whereas the existing statement at line as well asthe rest of method fixme is unchanged by the fix.
two of the five schemas currently used by jaid to build fix candidates inject the fix action unconditionally.
on theother hand different fix actions may determine semanticallyequivalent fixes when instantiated.
jaid performs a lightweight redundancy elimination based on simple syntactic rules such 2since each fix generated by jaid combines one fix action and one schema it adds at most new lines of codes to a patched method.action oldstatement listing .
schema aif suspicious action oldstatement listing .
schema bif !suspicious oldstatement listing .
schema c if suspicious action else oldstatement listing .
schema d oldstatementaction listing .
schema e fig.
.
schemas used by jaid to build candidate fixes class being repaired class fc u fixme t1a1 t2a2 ... throws illegalstateexception switch session.getactivefixid case return fixme a a2 ... call faulty method case return fixme 1 a1 a2 ... call fix candidate ... case n return fixme n a a2 ... call fix candidate n default throw new illegalstateexception listing .
how multiple fix candidates are woven into a single class.
as that x y is equivalent to !
x !
y .
in future work we plan to introduce a more aggressive redundancy elimination for example as done in related work .
e. fix v alidation even if jaid builds candidate fixes based on a semantic analysis of the program state during passing vs. failing tests the candidate fixes come with no guarantee of satisfyingthe tests.
to ascertain which candidates are suitable a fixvalidation process which follows fix generation runs all teststthat exercise the faulty method fixme against each generated candidate fix.
candidate fixes that pass all tests tare classified asvalid also test suite adequate and retained other candidates which fail some tests are discarded as they donot fix the fault they introduce a regression or both.
in the example of method abbreviate in lst.
the fix candidates if lower str.length lower str.length passes validation since it fixes the fault and introduces noregression error.
since jaid commonly generates a large number of candidate fixes for each fault validation can take up a very large timespent compiling and executing tests which may ultimatelyimpair the scalability of jaid s apr.
to curtail the time spent compiling jaid deploys a simple form of dependency injection.
all candidate fixes for a method fixme become members offixme s enclosing class fc candidate fix number kbecomes a method fixme kwith signature the same as fixme s. then as shown in lst.
a method fixme also with the same signature dispatches calls to any of the candidate fixes basedon the value returned by static method getactivefixid of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
class session which supplies the dependency.
this scheme only requires one compilation per method under repair thus significantly cutting down validation time.
f .
fix ranking like most apr techniques jaid s process is based on heuristics and driven by a finite collection of tests and thus is ultimately best effort a valid fix may still be incorrect passing all available tests only because the tests are incomplete piecesof specification.
jaid addresses this problem by ranking valid fixes using the same heuristics that underlies fault localization.every fix includes one fix action which was derived from asnapshot s the higher the suspiciousness of s the higher the fix is ranked fixes derived from the same snapshot are rankedin order of generation which means that semantic fixes modifying state or expressions appear before syntactic fixes mutating statements or modifying the control flow and fixes of the same kind are enumerated starting from thesyntactically simpler ones.
when the ranking heuristics works the user only inspects few top ranked fixes to assess their correctness and whetherthey can be deployed into the codebase.
the experimentalevaluation in sec.
iv comments on the effectiveness of jaid s ranking heuristics.
iv .
e xperiment al ev alua tion we evaluate the effectiveness of jaid on defects 4j a large curated collection of faults and programmer written fixesfrom real world java projects.
this choice also enables us toquantitatively compare the results of jaid s evaluation to most state of the art tools for apr of java programs which havealso targeted defects 4jin their experiments.
t able i the bugs in defects 4j for each project indefects 4j how many thousands of lines of code kloc and tests tests it includes how many bugs it includes in total and how many were selected for our experiments.
project kloc tests bugs selected chart jfreechart closure closure compiler lang apache commons lang 22math apache commons math 42time joda time total a. subjects our experiments target revision a910322b of defects 4j which includes bugs in projects chart bugs closure bugs lang bugs math bugs andtime bugs .
each bug in defects 4jhas a unique identifier corresponds to two versions buggy and fixed by aprogrammer of the code which may span multiple meth ods or even multiple files and is accompanied by someprogrammer written unit tests that exercise the code in par ticular at least one test triggers a failure on the buggy version.in the following if kis the identifier of a bug in defects 4j kdenotes the buggy version of the code corresponding to bugk kdenotes the code of the programmer fixed version of k andtkdenotes the tests accompanying k. the bugs included in defects 4jare a representative sample of real world bugs and as such they include several that admitsimple fixes as well as several others that require sweepingchanges to different parts of a project.
in order to focusthe experiments on the bugs that have a chance of being in jaid s purview we selected a subset of all bugs kthat satisfy the following criteria the programmer written fix konly modifies java executable code no other artifacts like config uration files or compilation scripts the programmer writtenfix kmodifies no more than consecutive lines of code and no more than statements with respect to k as reported by the changedistiller tool the bug is reproducible atleast one test in t kfails on k and all tests in tkpass on k. a total of bugs satisfy these criteria these are the subjects of our experiments with jaid .
tab.
i shows the size of and the number of bugs in each defects 4jproject among our experimental subjects.
b. research questions our evaluation addresses research questions in different areas effectiveness how many bugs can jaid fix?
performance how much time does jaid take?
design which components of jaid s are the most important for effectiveness?
comparison how does jaid compare to other apr techniques for java?
c. setup since jaid ranks all generated snapshots according to their suspiciousness see sec.
iii b and depends on the ranking to guide the following stages setting an arbitrary cutoff time mayprevent from generating a complete ranking.
instead we limitthe search space in our experiments by configuring jaid so that it uses at most snapshots in order of suspiciousness then the following stages all run to completion.
each experiment targets one bug kindefects 4j and runs jaid on buggy code kusing the tests tk the output is a ranked list of valid fixes for the bug.
we manually inspect thetop fixes in order of ranking to determine which are correct if all fixes are incorrect we continue the manual inspectionof the other fixes and stop when we find a correct one or nomore valid fixes are available.
we classify a fix as correct onlyif it is semantically equivalent to the programmer written fix kindefects 4j.
this is a high bar for correctness which provides strong confidence that a fix is high quality enough tobe deployable.
all the experiments ran on a cloud infrastructure with each run of jaid using exclusively one virtual machine instance configured to use one core of an intel xeon processor e5 v2 gb of ram ubuntu .
and oracle s java 3the number was chosen heuristically.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
jdk .
.
in this section averages are measured using the median by default with exceptions explicitly pointed out.
other tools for java apr.
we quantitatively compare jaid to all other available tools for apr of java programs thathave also used defects 4jin their evaluations jgenprog is the implementation of genprog which workson c for java programs we refer to jgenprog s evaluationin jkali is the implementation of kali whichworks on c for java programs we refer to jkali s evalu ation in nopol focuses on fixing java conditionalexpression we refer to nopol s evaluation in xp aris a reimplementation of p ar which is not publiclyavailable discussed in and hda implements the history driven technique of acs implements the precise condition synthesis of .
experiments with apr tools often target a different subset ofdefects 4jthat is amenable to the technique being evaluated.
comparing the number and kinds of fixed bugs amongtools remains meaningful because bugs that are excluded apriori from an evaluation can normally be considered beyonda tool s current capabilities.
d. results effectiveness.
jaid was able to produce valid fixes for the bugs of defects 4j listed in tab.
ii.
more significant it produced correct fixes equivalent to those written by programmers for of these bugs integer rank in tab.
ii .
this indicates that jaid is applicable to realistic code and when it runs successfully it often produces fixes of high quality.
as we discuss in more detail below the number ofcorrectly fixed bugs is on par with or above the state of theart of java apr techniques.
unsurprisingly jaid produces fixes that tend to be small in size .
lines of code changes per valid fix on average.this is a result of its fix generation process which is basedon state based information targets simple fix actions and thensharpens their precision by injecting them into the code usingconditional schemas.
when it is successful jaid often produces a significant number of valid fixes per fixed bug on average in ourexperiments and a much smaller number of correct fixes 1per fixed bug on average in our experiments which all aresemantically equivalent.
in jaid s output for the bugs that were correctly fixed the median position of the first correctfix in the list of all valid fixes was from the top for 15bugs that jaid correctly fixed a correct fix appears among the top valid ones in order of ranking for bugs it appearsat the top position.
these results indicate the importance ofranking to ensure that the correct fixes are easier to spot amongseveral valid but incorrect ones.
for bugs the correct fixappears further down in the output list in of these cases thecorrect fix turns out to be a syntactic one but several valid incorrect semantic fixes are generated and ranked higher.
4we ascertained that the version of defects 4jused in our experiments does not differ substantially from those used in the other tools experiments in particular all bugs analyzed by jaid were also available to the other tools.this suggests that improving the precision of ranking may benefit from mining additional information about commonfeatures of programmer written fixes as done by hda and acs .
jaid can correctly fix even bugs that include only one failing test and no passing tests ranking the correct fix first intwo cases.
these results showcase how jaid can be successful at mitigating the baneful problem of overfitting.
performance.
as shown in tab.
ii jaid runs in .
minutes per bug on average median whereas the meanrunning time is .
minutes .
jaid is unsurprisingly significantly slower than tools based on constraint solving andother symbolic techniques for example nopol takes around22 minutes per bug on average on what we assume iscomparable hardware.
they are however in line with otherapr techniques mainly based on dynamic analysis such asjgenprog which takes about one hour per bug.
looking more closely into how much time each stage of jaid takes it is clear that validation is by far the most time consuming fault localization takes .
of the median timeper bug fix generation takes .
and fix validation takes92.
.
v alidation time tends to be proportional to the numberof available tests and to the number of fix candidates which in turn is proportional to the number of snapshots that areactually analyzed.
the approach outlined in sec.
iii e stillhelps save a significant amount of compilation time as futurework we plan to further improve the performance of validationby running multiple concurrent instances on the same jvm.
design.
which of the fix actions and schemas are the most useful to build correct fixes?
regarding fix actions we distinguish three kinds sfor actions modifying the state or an expression semantic actions that are built on jaid s rich state based abstractions mfor actions mutating a statement syntactic actions that correct common errorsand are commonly used in apr systems cfor actions modifying the control flow terminating actions that canstill have a significant impact on program behavior.
jaid uses all three kinds of actions with similar frequencies in correctfixes which indicates that they are largely complementary andall contribute to jaid s effectiveness.
the five fix schemas of fig.
which jaid uses to inject a fix action into the method under repair also all feature in correctfixes.
this suggests that both conditional and unconditionalapplications are required to target a wide choice of bugs.
comparison correct fixes.
tab.
iii compares jaid to jaid hda acs14 fig.
.
number of bugs correctly fixed by each of the main apr tool.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able ii summary of the experimental results.
for every bug bug id k that jaid fixed with a valid fix the lines of code loc of the method under repair how many tests tests passing and failing exercise the method under repair the number of suspicious snap shots that are analyzed capped at the number of cand idate fixes that undergo validation the mean size in lines of code changes of a valid fix the total number of v alid fixes the number of correct fixes among the top valid fixes the position of the first correct fix in ranking order rank the total running time in minutes and the breakdown into time for fault localization fix generation and fix validation the kinds of actions sfor state and expression modifying actions mfor mutation actions andcfor control flow actions see sec.
iii c and the kinds of schemas see fig.
used in correct fixes.
tests genera tion fixes time bug id k loc pf snap cand size v alid correct rank total l g v actions schemas chart .
.
.
.
.
m e chart .
.
.
.
.
s a b chart .
.
.
.
.
c s b e chart .
.
.
.
.
s e closure .
.
.
.
.
closure .
.
.
.
.
m e closure .
.
.
.
.
m e closure .
.
.
.
.
m e closure .
.
.
.
.
c b closure .
.
.
.
.
m e closure .
.
.
.
.
closure .
.
.
.
.
m e closure .
.
.
.
.
m e closure .
.
.
.
.
m e closure .
.
.
.
.
m e lang .
.
.
.
.
lang .
.
.
.
.
c s c d b lang .
.
.
.
.
s a b lang .
.
.
.
.
lang .
.
.
.
.
s b lang .
.
.
.
.
c b lang .
.
.
.
.
s c lang .
.
.
.
.
math .
.
.
.
.
math .
.
.
.
.
s e math .
.
.
.
.
c b math .
.
.
.
.
s c m e c d math .
.
.
.
.
c b math .
.
.
.
.
s b a math .
.
.
.
.
m e math .
.
.
.
.
m e median .
.
.
.
.
t able iii a comparison of apr techniques on bugs in defects 4j.
this paper s jaid is compared to acs hda xp ar jgenprog and jkali.
for each tool the table reports the number of bugs that were fixed with a v alid fix the number of bugs that were fixed with a correct fix among any of those outputed by the tool only among the top positions in the output and only in the first position in the output and the resulting precision correct va l i d and recall correct where is the total number of bugs in defects 4j .
question marks represent data not available for a tool.
any position top positions first position tool v alid correct precision recall correct precision recall correct precision recall jaid .
.
.
.
.
.
acs .
.
.
.
.
.
hda ?
?
.
?
.
?
.
nopol .
.
.
.
.
.
xpar ?
?
.
?
.
?
?
?
jgenprog .
.
.
.
.
.4jkali .
.
.
.
.
.
six other apr tools for java.
in terms of number of bugs fixed with a correct fix jaid outperforms all other tools.
note that both runners up hda and acs crucially rely on mining additional information from other sources hda mines frequency information about bug fixes from 800popular github projects whereas acs searches for predicates in all open source projects in github .
theimplementation of hda additionally requires fault localization information as part of the input.
thus both tools use aricher input than just a buggy program and its accompanyingunit tests which indicates that jaid s performance is highly competitive and arguably improving the state of the art in itsown league.
jaid fares very well also in terms of precision fraction of bugs with a valid fix that have a correct fix and recall percentage of all bugs in defects 4j that have a correct fix .
since different approaches and different experimentalevaluations deal differently with bugs that admit multiple authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
valid fixes we measure three variants of precision and recall relative to the number of bugs that were correctly fixedby any of the valid fixes regardless of the correct fix s rank relative to the number of bugs that were correctly fixed bya fix ranked among the top in a tool s output relative tothe number of bugs that were correctly fixed by a fix rankedfirst in a tool s output.
jaid achieve the best precision5and recall if we disregard ranking and the second best precisionand third best recall in the other two cases.
again note thatthe only tools that outperform jaid rely on additional input information to sharpen their precision and recall.
comparison kinds of fixes.
fig.
zooms in on the bugs that are correctly fixed by jaid hda and acs and shows how many bugs each tool can fix that the others cannot.
thetools are mainly complementary in the specific bugs they are successful on jaid fixes bugs that no other tool can fix hda fixes and acs fixes .
among the tools not in fig.
nopol fixes bugs that no other tool can fix plus bug also fixed by jaid and of which also fixed by hda jgenprog fixes bug that no other tool can fix plus bugs also fixed by hda of which jaid can also fix jkali fixes bug that jgenprog nopol hda and jaid can also fix.
these numbers indicate that each technique is successful in its own domain.
the complementarity alsosuggests that combining techniques based on mining such as hda and acs with jaid s techniques is likely to yield further improvements in terms of precision and effectiveness.
comparison other tools.
we refrain from quantitatively comparing apr tools that target other programminglanguages and thus were evaluated on different bench marks .
nevertheless just to give an idea angelix and prophet 6achieve a precision of .
and .
and a recall of .
and on bugs in the c genprogbenchmark autofix 7achieves a precision of .
and a recall of on bugs from various eiffel projectswith contracts.
e. threats to v alidity construct validity indicates whether the measures used in the experiments are suitable.
we classify a fix as correct if it is semantically equivalent to a programmer written fix.
since we assess semantic equivalence manually different programmersmay provide different assessments to mitigate this threat wewere conservative in evaluating equivalence if a fix does notclearly produce the same behavior as the fix in defects 4j for the same bug we classify it as incorrect.
this approachis consistent with what done by other researchers.
a moredetailed analysis of patch correctness belongs to future work.
we measured and compared precision and recall relative toall bugs in defects 4j even if most apr techniques including jaid only run experiments on a subset of the bugs whose features have a chance of being fixable.
usingthe largest possible denominator ensures that measures are 5the precision of hda is not reported in .
6v alid fixes are called plausible in .
7correct fixes are called proper in .comparable between different tools and is consistent with theultimate ambition of developing apr techniques that are aswidely applicable as possible.
tools and their experimental evaluations often differ in how they deal with multiple valid fixes for the same bugs.
inthe tool comparison we counted all correct fixes generatedby each tool that were reported in the experiments and wereported separate measures of precision according to howmany valid fixes are inspected.
this gives a nuanced pictureof the results which must however be taken as usual witha grain of salt different tools may focus on achieving a betterranking vs. correctly fixing more bugs and we do not implythat there is one universal measure of effectiveness.
anyway our evaluation is widely applicable including to papers thatmay not detail this aspect and is in line with what done inother evaluations .
internal validity indicates whether the experimental results soundly support the findings.
comparing the performance running time in particular of different apr techniques is aparticularly delicate matter because of a number of confound ing factors.
first of all the experiments should all run on thesame hardware and runtime environment using comparableconfigurations e.g.
in terms of timeouts .
techniques usingrandomization such as jgenprog require several repeatedruns to get to quantitative results that are representative ofa typical run .
some techniques such as acs and hda rely on a time consuming preprocessing stage that mines coderepositories and is crucial for effectiveness and hence it isunclear how to appropriately compare them to techniques suchas jaid that do not depend on this auxiliary information.
fault localization is also an input to hda s main algorithm.
in all we used standard clearly specified settings for the experimentswith jaid and we relied on the overall results in terms of correct fixes reported in other tools experiments.
in contrast we refrained from qualitatively compare tools in measuresof performance which depend more sensitively on having acontrolled experimental setup and which we therefore leaveto future work.
external validity indicates whether the experimental findings generalize.
the defects 4jdataset is a varied collection of bugs carefully designed and maintained to support realisticand sound comparisons of the effectiveness of all sorts ofanalyses based on testing and test case generation it has alsobecome a de facto standard to evaluate apr techniques forjava.
these characteristics mitigate the risk that our exper iments overfit the subjects.
as future work we plan to run jaid on other open source java projects we see no intrinsic limitations that would prevent jaid from working reliably on different projects as well.
v. r ela ted work automated program repair has become a bustling research area in the course of just a few years.
the first apr tech niques used genetic algorithms to search the spaceof possible fixes for a valid one.
genprog pioneeredthe generate and validate approach where many plausible authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fixes are generated based on heuristics and then are validated against the available tests.
more recently others have pursued the constraint based approach where fixes are constructed to satisfy suitable constraintsthat correspond to their validity.
the two approaches arenot sharply distinct in that fixes generated by constraint based techniques may still require validation if the constraintsthey satisfy by construction are not sufficiently precise toensure that they are correct as it often happens when dealingwith incomplete specifications.
nevertheless the categoriza tion remains useful we devote more attention to generate and validate techniques since jaid belongs to this category and thus is more directly comparable to them.
for a broader list ofapr techniques see monperrus s annotated