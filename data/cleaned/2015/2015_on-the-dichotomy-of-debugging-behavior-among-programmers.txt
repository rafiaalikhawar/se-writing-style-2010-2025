on the dichotomy of debugging behavior among programmers moritz beller niels spruit m.m.beller tudelft.nl spruit.niels gmail.com delft university of technology the netherlandsdiomidis spinellis dds aueb.gr athens university of economics and business greeceandy zaidman a.e.zaidman tudelft.nl delft university of technology the netherlands abstract debugging is an inevitable activity in most software projects often difficult and more time consuming than expected giving it the nickname the dirty little secret of computer science.
surprisingly we have little knowledge on how software engineers debug software problems in the real world whether they use dedicated debugging tools and how knowledgeable they are about debugging.
this study aims to shed light on these aspects by following a mixed methods research approach.
we conduct an online survey capturing how developers reflect on debugging.
we augment this subjective survey data with objective observations on how developers use the debugger included in their integrated development environments ides by instrumenting the popular e clipse and i ntelli j ides with the purpose built plugin w atch dog2.
.
to clarify the insights and discrepancies observed in the previous steps we followed up by conducting interviews with debugging experts and regular debugging users.
our results indicate that ide provided debuggers are not used as often as expected as printf debugging remains a feasible choice for many programmers.
furthermore both knowledge and use of advanced debugging features are low.
these results call to strengthen hands on debugging experience in computer science curricula and have already refined the implementation of modern ide debuggers.
ccs concepts software and its engineering software testing and debugging acm reference format moritz beller niels spruit diomidis spinellis and andy zaidman.
.
on the dichotomy of debugging behavior among programmers.
in proceedings of icse 40th international conference on software engineering gothenburg sweden may june icse pages.
.
.
introduction debugging the activity of identifying and fixing faults in software is a tedious but inevitable activity in almost every software permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse gothenburg sweden copyright held by the owner author s .
publication rights licensed to acm.
.
.
.
.
.
.3180175development project .
not only is it inevitable but according to kernighan and plauger and zeller so difficult that it often consumes more time than creating the bogus piece of software in the first place.
during debugging software engineers need to relate an observed failure to its underlying defect .
to complete this step efficiently they often need to acquire a deep understanding and build a mental model of the software system at hand .
this is where modern debuggers come in they aid software engineers in gathering observing the system s dynamic behavior.
however they still require them to select the parts on which to focus and to perform the deductive reasoning to pinpoint the fault from the observed behaviors.
while the scientific literature is rich in terms of proposals for automated debugging approaches e.g.
there is a gap in knowledge of how practitioners actually debug.
debugging has thus remained the dirty little secret of computer science .
how and how much do software engineers debug at all?
do they use modern debuggers?
are they familiar with their capabilities?
which other tools and strategies do they know?
the lack of knowledge regarding developers debugging behavior is in part due to an all too human characteristic admitting demonstrating and letting others do research on how one approaches what are essentially one s own faults is a precarious situation for both a developer and a researcher.
nevertheless by continuing to keepdebugging practices secret we miss an important opportunity for advancing software engineering theory and for delivering efficiency improvements in software development practice.
knowledge on how developers debug can help researchers to invent more practice relevant techniques educators to improve their debugging curricula and tool builders to tailor debuggers to the actual needs of developers.
to open up the art of debugging we conducted a large scale behavioral field study on what developers think about debugging and how they debug in their ides.
the following main questions steer our research rq1 what do developers know about debugging and how do they reflect on it?
rq2 how do developers debug in their ides?
rq3 how do individual debugger users and experts interpret our findings from rq1 and rq2?
the key contributions of this paper are a triangulated large scale empirical study of how developers debug in reality using a mixed methods approach supported by a replication package.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden moritz beller niels spruit diomidis spinellis and andy zaidman figure research design overview.
the addition of debugging features in w atch dog2.
an opensource multi platform infrastructure that allows detailed tracking of developers debugging behavior.
improvement suggestions for current ide debuggers that have in part already been implemented in practice.
research design to answer these research questions we employed a multi faceted research approach outlined in figure .
circlecopyrtwe conducted an online survey to capture developers opinions on debugging and obtained an overview of the state of the practice see section survey results sr .
circlecopyrtsimultaneously we began using the automated w atch dog .
infrastructure to track developers fine grained debugging activities in the ide see section w atch dogresults wr .
by instrumenting the ide we obtained objectively measured data which we can compare against subjective but richer data from the survey.
we came up with a list of several sometimes conflicting observations that needed further explanation.
circlecopyrtto help us explain the findings in depth we conducted interviews with developers some of whom are actively developing debugging tools see section interviews .
related work work related to our study comprises debugging tools processes techniques empirical debugging evidence and ide instrumentation.
debugging tools.
by debuggers we usually mean symbolic debuggers such as the gnu project debugger gdb .
these debuggers allow developers to specify points in the program where the execution should halt breakpoints.
a typical symbolic debugger supports different types of breakpoints such as line method data access or more advanced exception orclass prepare breakpoints and options to refine the breakpoint .
examples include specifying a conditional breakpoint ahit count asuspension policy o r whether the entire program or one thread should pause upon hitting a breakpoint.
once a program halts developers can use the symbolic debugger to permanently watch or ad hoc inspect memory entities such as variables work through the call stack line wise step through the code or evaluate arbitrary expressions .
graphical debuggers like the early dbxtool and ddd evolved from command line symbolic debuggers such as v ax debug dbx and gdb .
most symbolic debugging features have since been integrated in the integrated graphical debuggers of ides such as e clipse visual studio netbeans and i ntelli j. this study focuses on how developers use ide debuggers.debugging process.
researchers have developed systematic process descriptions of debugging and recommendations to reduce the time programmers have to spend on finding and fixing a defect that a program failure.
we investigate whether developers explicitly or implicitly use debugging strategies inspired by the scientific method for example zeller s traffic approach comprises seven steps that cover every action in the debugging process from the discovery of a problem until the correction of the defect.
three of the steps regard the most time consuming find focus isolate loop as developers often need to follow them iteratively to find the root cause of a failure.
therefore much research has gone into techniques to at least partially automate this loop to reduce debugging effort .
in gilmore suggested a new psychological model to understanding debugging .
component of his model namely that debugging is a flexible incomplete comprehension process according to task demands tools and skill provides a theory grounded description of our observations.
automated debugging techniques.
arguably the most researched debugging technique is delta debugging which can be used to systematically narrow down possible failure causes by comparing a successful and an erroneous program execution .
other types of debugging technique include slicing focusing on anomalies mining dynamic call graphs statistical debugging spectrabased fault localization angelic debugging data structure repair relative debugging automatic breakpoint generation automatic program fixing using contracts and combinations thereof .
orso presents a detailed overview of some of these automated debugging techniques .
however as our study shows automated debugging techniques have not yet reached the mainstream debugging practices and are not part of ide debuggers.
as such we do not discuss them further.
empirical debugging evidence.
only few studies exist that empirically evaluate how developers debug.
perhaps most closely related to our study perscheid et al.
and siegmund et al.
studied debugging practices of professional software developers via a survey and manual observations of each of their eight participants over some hours during one workday through think aloud protocols and short interviews.
despite the fact that our studies differ significantly in population length and methodology we could replicate most of their key results the wide use of printf a lagging adoption of advanced debugging tools and features and developers generally low education on debugging.
we partly refined these observations showing that there is a strongdichotomy on printf use among developers which debuggingfeatures are empirically used and that the complexity of operat ing debuggers is a main reason for these usage patterns.
as in our survey concurrency issues and external libraries seem to be the root causes of the hardest bugs.
however we also partly refuted our developers did not run the debugger in of ide sessions and they did not spend a huge amount of their daily work i nt h e debugger but less than .
in a general study on how developers use eclipse murphy et al.
found that of their studied developers used the debugger .
this is similar to our debugger use rate in wr1 when only considering the top of users.
parnin and rugaber observed that of their recorded sessions included debugging compared to an ide debugger use in of the sessions in our study wr1 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the dichotomy of debugging behavior among programmers icse may june gothenburg sweden despite differences in study populations and methods layman et al.
found similar challenges and improvement wishes such as concurrency sq13 and back in time debugging .
however they do not mention some of the critical challenges found in this paper such as debugging across languages.
piorkowski et al.
studied qualitatively how programmers forage for information .
they found that developers spent half of their debugging time foraging for information.
this complements our study as it shows what parts of the ide are often used for finding information during debugging.
b hme et al.
studied individual steps in the debugging process i.e.
how developers localize diagnose and fix faults .
through an experiment with professional software engineers they observed that fault localization is complex due to errors from an interactions of several statements.
they also found that participants diagnosedbugs in a remarkably similar way.
however when fixing a fault while the patches submitted by the participants were plausible only were correct.ide instrumentation.
petrillo et al.
developed the swarm debug infrastructure sdi which provides tools for collecting sharing and retrieving debugging data .
developers can use the collective knowledge of previous debug sessions to navigate sequences of invocation methods and find suitable breakpoints.
sdi was evaluated in a controlled experiment involving developers.
our e clipse instrumentation for rq2 is technically similar to sdi but focuses on understanding current behavior.
to increase generalizability we also support i ntelli j and performed a longitudinal study of how dozens of developers debug in the wild.
while several w atch dog like plugins for ide instrumentation exist none of them have been used to study the debugging behavior of developers manifesting our knowledge gap of empirical debugging.
ko and myers showed the practical usefulness of the live ide wish expressed in sq13 with their whyline prototype which helps developers reason about assumed program behavior.
debugging survey in this section we describe our online survey.
.
research methods survey design.
to investigate developers self assessed knowledge on debugging for rq1 we set up a survey consisting of short questions sq1 sq13 organized in four sections the first gathers general information about the respondents such as programmingexperience and favorite ide.
the second asks if and how respon dents use the ide provided debugging infrastructure.
developers who do not use it were asked for the reason why while others got questions on specific debugging features thus assessing how well the respondent knows and uses several types of breakpoints.
in addition we asked questions about other debugging features ranging from stepping through code to more advanced features like editing atrun time hot swapping .
the third part presented to all respondents assessed the importance of codified tests in the debugging process we gauged whether the participant uses tests for reproducing bugs checking progress or to verify possible bug fixes.
sq13 was an open non mandatory question about participants opinion on thestatement the best invention in debugging was printf debugging inspired by brian kernighan s quote he most effective debugging tool is still careful thought coupled with judiciously placed printstatements .
we included the question because research on survey design has shown that posing a concrete controversial statement that evokes strong opinions leads to more insightful answers .
before publicly releasing the survey we sharpened it in several iterations and ran six trials with outsiders.
card sort.
to gain an overview of the topics that concern developers we performed an open card sort o n sq13.
the first two authors individually built and then mutually agreed on a set of 33tags from a sub sample of responses.
after labeling all responses possibly with multiple labels the fourth author sampled of the tagged responses re tagged them independently and compared them to the reference tag set.
we then converged our tag sets into a homogeneous classification with tags agreed upon by all authors.
dependency analysis.
to gain insights into the correlation between survey answers we performed statistical tests.
for sq7 w e had to convert each categorical answer to an ordinal scale using alinear integer transformation on its rank.
this was sound becauseour predefined answer options have a naturally ranked order idon t know i know .
.
.
.
we then computed a pairwise pearson chi squared 2 test of independence as we are dealing with categorical variables.
if variables depended on eachother .
we calculated the strength of their relationship with a spearman rank order correlation test for non parametric distributions .
for interpreting the results of dependency analyses we use hopkins guidelines .
they call .3no .
.5weak .
.7moderate and .
a strong correlation.subject recruitment.
to attract survey participants sp we spread the link to the survey through social media especially twitter and via an in ide w atch dogregistration dialog advertising a raffle with three euro amazon vouchers.
study subjects.
we attracted 176software developers who completed our survey.
the majority of them have at least three years of experience in software development with a third over years year .
years .
.
.
10years .
.
.
indicated that they use java followed by .
for javascript and .
for python.
the languages php c c and c were each selected by around of participants followed by r .
swift .
and objective c .
.
finally 44developers indicated the use of another language 24different in total of which scala and ruby prevail.
the most used ides are eclipse .
intellij .
and visual studio .
.
we asked for the language to understand whether we can compare the survey results to our java based field study and because certain language features define their debugging possibilities for example the availability of a virtual machine in java or pharo s introspection design concept which lends itself to debugging .
.
results analysis of survey answers.
in this section we describe key results of our survey and rq1.
sr1 most developers use ide debuggers in conjunction with log files and print statements.
in our first question developers authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden moritz beller niels spruit diomidis spinellis and andy zaidman .
indicated that they use the ide provided debugging infrastructure .
that they do not and .
that their selected ide does not have a debugger.
besides using the ide debugger respondents indicated they examine log files .
followed closely by using print statements .
.
other answers included the use of an external program .
or additional other internal or non generalizable techniques .
.19developers indicated the use of a complementary method of which adding or running tests and using web development tools built into the browser were mentioned most both four times .
sr2 developers not using the ide debugging find external programs tests print statements or other techniques more effective or efficient.
of the 15developers not using the debugging infrastructure eight think that print statements and six that techniques other than print statements are more effective or efficient.
six use an external program while four do not know how to use a debugger.
sr3 line breakpoints are used by the vast majority of developers.
more advanced types are unknown to most.
the143developers using an ide debugger were asked more detailed questions on whether they know and use specific debugging features.
the likert scale plots in figure show that most developers are familiar with line exception method and field breakpoints while temporary line breakpoints and class prepare breakpoints are known by fewer developers.
the vast majority of developers also uses line breakpoints but other breakpoint types are used by less than half of the respondents class prepare breakpoints are used by almost none.
sr4 most developers answered to be familiar with breakpoint conditions but not with hit counts and suspend policies.
figure indicates that the majority of developers specify conditions on breakpoints.however specifying the hit count or setting a suspend policy are both known and used less.
the results in figure show that over of the developers seem to know all major debugging features found in modern ides strengthening siegmund s findings .
the more advanced features like defining watches or a suspend policy seem to be known and used less.
sr5 survey answers indicate testing is an integral part of the debugging process especially at the beginning and end.
figure shows the use of codified tests throughout the debugging process based on all176responses.
it indicates that tests are often used at the start and end of the debugging process for reproducing bugs and verifying bug fixes but slightly less during the process.
sr6 experience has limited to no impact on the usage of the ideprovided debugging infrastructure and tests.
examining our survey answers for dependencies allows us to understand how certain an swers relate for example whether and how strongly programmer experience correlates with the use of debugger features like breakpoints watches or the use of testing to guide debugging.
we find that there is no correlation between the use of an ide debugger or unit tests for debugging and experience in software development.
there is a weak correlation between experience and specifying hit counts and a moderate correlation between experience and the usage of watches during debugging.
sr7 developers who use tests for reproducing bugs are likely to use them for checking progress and very likely to use them for verifying1 line breakpoint temporary line breakpoint class prepare breakpointmethod breakpointexception breakpoint field watchpoint specifying a condition specifying hit pass count setting the suspend policy stepping through the codeinspecting variable values inspecting the call stack defining watchesevaluating expressions modifying variable values editing code at runtime percentage response i don t know i know i know and i use figure answers in sq7 on breakpoint types breakpoint options and debugging features n .
reproducing bug checking debugging progressverifying possible bug fixes percentage response no y es figure answers in sq10 on unit tests n .
bug fixes.
we also find that there is a moderate correlation between the use of tests at the beginning and end of the debugging process to reproduce and verify bug fixes and a weak to moderate correlation between using tests at the beginning or end and throughout the process for checking progress.
card sorting.
in total 108respondents gave a response to the statement that the best invention in debugging still was printf debugging.
in the open card sorting process we identified 34different tags.
to understand important topics and their co occurrence we use an intuitive graph based representation of the tag structure.
vertices correspond to the tags and undirected weighted edges to the strengthof relation between two tags.
the size of the vertices in is determined by the occurrence frequency of the tag while the weight of the edges is determined by the relative number of co occurrences.
to ease the interpretation the graph we normalized the weights of the edges based on the occurrence frequencies of its end points we filtered out all edges with a very low normalized weight cleaning the graph from background noise and we removed vertices that did not have any outgoing or incoming edge removing unrelated concepts .
the resulting graph in figure allows us an intuitive understanding and overview of responses and how they relate to each other without having to read hundreds of responses .3the tags abbreviate concepts given as answers by survey respondents and are self explanatory.
the tags debugger jittery debugger overhead and debugger interference mean that respondents think debuggers have too much impact on the thinking process performance or program execution respectively.
first printf means that developers first use printf debugging and before debugger indicates that 3we explicitly avoided statistical tests.
given open ended survey answers the meaning of such tests is unclear or might convey a false sense of statistical precision at worst.
the graph conveys our understanding having intensely worked with survey answers.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the dichotomy of debugging behavior among programmers icse may june gothenburg sweden figure intuitive visualization of the tag network in sq13.
developers use some other technique s before using the debugger.
as the two main strongly connected subgraphs circlecopyrtand circlecopyrtin figure suggest there was a strong dichotomy between survey respondents many enthusiastically agreed with our statement totally agree!
sp13 sp23 while others rejected it stating that eople saying that never learned how to use a debugger sr54 .
developers mostly seemed to agree that ide debuggers are methodologically superior to print statements explaining the strong link circlecopyrt.
independently reasons for resorting back to printf are when no debugger is available or when the presence of the debugger interferes with the program execution order circlecopyrt.
many of the respondents who agreed with the statement also saw drawbacks of printf debugging like sp10 print is often most flexible but often least efficient.
developers indicated to use printf debugging as an ad hoc universal technique that is easy to do and often the first step in a possibly longer debugging strategy.
however sometimes it is not enough circlecopyrt as a combination of techniques is required.
the answers also pointedto problems with ide debuggers they are sometimes too jittery provide too many features and are not suited for concurrent debugging as they interfere too much.
moreover their complicated graphicaluser interface gui can get in the way of working fast .
instead of printf debugging developers seemed to prefer a live ide with a console that has a read eval loop repl circlecopyrt.
summarizing this discussion sp75 concluded that printf is travelling by foot a gui debugger is travelling plane.
you can go to more places by foot but you can only go that far.
few developers also tried to avoid debugging by testing better circlecopyrt.
ide field study in this section we describe our field study with w atch dog2.
.
.
study methods data collection.
to investigate the debugging habits of developers in the ide we extended our w atch doginfrastructure to also track developers debugging behavior for rq2 resulting in watch dog2.
for both e clipse and i ntelli j. we had previously used w atch dogas a research vehicle to verify common expectations and beliefs about testing .
w atch dogis technically centered around the concept of intervals that capture the start and end of common development activities like reading andwriting code as well as running ju nittests.
we extended its interval concept to cover debugging sessions and introduce a new orthogonal concept singular events that unlike intervals have no end date.
such events track when developers add change or remove breakpoints for example.
an ide session is an uninterrupted sequence of watch dogintervals in which the developer does not close the ide or suspend the computer.
a debugging session is an ide session in which the developer used the debugger at least once.analysis methods.
to analyze the data collected with w atch dog .
we created an open source data processing pipeline.
the pipeline which comprises lines of code extracts the data from w atch dogs m ongo db and loads it into r for further analysis.
the analysis methods we used for some of these research questions require some more explanation detailed below.
for rq2.
and rq2.
we assessed activity measured via watch dogintervals.
for rq2.
we assessed the intervals that occur before a debugging session is started.
we chose a search range of16seconds before matching the interval inactivity timeout of seconds in w atch dog.
this means that activity based intervals like reading or typing intervals are automatically closed after thisperiod of inactivity to account for e.g.
coffee breaks.
a timeout length of seconds is standard in ide plugins .
for rq2.
and rq2.
we consider a file under debugging if we receive reading or typing intervals during a debugging interval on it i.e.
for all the files the user steps through reads or otherwise modifies during a debugging session.subject recruitment.
to attract participants to our field study we relied on w atch dog s recruitment processes .
users could join or leave the field study at any time.study subjects.
since the release of w atch dog2.
on april we collected user data for a period over two months until june .
of the users come from china from india from the us from brazil from germany and the remaining from other countries.
users could opt to share their programming experience and did had up to two years of programming experience between three to six years and seven years and more.
nine users were running macos x linux windows and chose not to answer.
our study includes a heterogeneous mix of private open source and commercial projects with sizes ranging from green field projects to several lines of code the median study participation was days mean days the maximum the full days.
in this period we received intervals from 458users in 603projects.
of these were debug intervals from 132developers.
in total we recorded hours in which the ide was open which amounts to .
observed developer years based on the average working hours for oecd countries .
we also collected debugging events from users 218projects and 723ide sessions.
only users top10 are responsible for of the sessions but they represent a globally diverse population with varying experience and companies working in different domains consultancies tool creators financial institutions mobile application development .
in total we recorded both at least one debug interval and one event for users.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden moritz beller niels spruit diomidis spinellis and andy zaidman .
results in this section we describe key results of our w atch dog2.
observational field study for rq2.
rq2.
how prevalent and frequent is ide debugging?
wr1 the majority of developers does not use the ide provided debugging infrastructure.
table presents the number of occurrences of the different event types.
only 132of the 458users .
started a debugging session during the data collection period with no significant difference between e clipse .
and i ntelli j .
users.
of these 108study subjects .
have used the debugger and at least one of its features transferred both intervals and events .
in top10 every user had at least one debugging session debugger use .
no debugger use is therefore likely a result of little transferred data.
however it is not contradictory to use the debugger and not transfer any of the events listed in table since the debugger provides several other benefits like hot swapping of code.
in total we observed a debugger run in of all idesessions.
in the onward analyses we only take into account data from users who used the debugger.
wr2 about of the developers are responsible for over of the debugging intervals in our sample.
for rq2.
we are interested in knowing the frequency and length of debugging sessions.
we first analyzed the number of debug intervals per user for the developers that have used the debugger during the collection period.
the resulting numbers range from a single debug interval to debugging intervals with an average of .
and a median of debug intervals per user.
next we analyzed the duration of the debug intervals and found values ranging from 3milliseconds to .
hours with an average and median duration of .
minutes and42.
seconds respectively.
about half of the users using the ide provided debugging infrastructure have launched the debugger four times or less during the data collection launched their debugger more than times.
rq2.
how much time is spent in ide debugging?
wr3 debugging consumes on average less than of the active in ide development time.
for rq2.
we first computed the total duration of all intervals of a particular type and based it on the total duration of ide open intervals .
hours i n the collection period.
we recorded .
hours of running unit tests .
.
hours of debugging intervals .
.
hours of reading .
and .
hours of typing .
.
these intervals are the main contributors of how developers spend their time inthe ide included in the ide active intervals .
.
next we analyzed the duration and percentages on a per user basis.
for the users with at least one debug interval table shows the descriptive statistics of the interval duration and percentages.
from the results in table and the fact that the total recorded active ide time was .
hours we conclude that debugging consumes .
of the total active in ide development time while reading or writing code and running tests take .
.
and .
.
wr4 most debugging sessions consume less than minutes.
furthermore about half of the debugging sessions take at most seconds while about of them last more than minutes.
rq2.
which ide debugger features do developers use?wr5 line breakpoints are used most and by most developers other breakpoint types are used less and by fewer developers.
the results in table show that line breakpoints are by far the most used breakpoint type.
the other more advanced types account for less than of all breakpoints set during the collection period.
furthermore line breakpoints are used by most developers using the debugging infrastructure while the other types of breakpoints are used by only .
.
of these developers.
wr6 breakpoint options are not used by most watchdog .
users the most frequently used option is changing their enablement.
when considering how breakpoints evolve over their lifetime the breakpoint change type frequencies in table second column indicate that almost all of these changes are related to the enablement or disablement of the breakpoints.
the other change types account for only .
of all breakpoint changes.
furthermore the number of users that generated these events range from .
t o12 .
.
moreover events related to specifying a hit count on the breakpoint have not been recorded during the collection period.
wr7 setting breakpoints and stepping through code is done most other debugging features are far less used.
table shows that most of the recorded debugging events are related to the creation removal or adjustment of breakpoints hitting them during debugging and stepping through the source code.
the more advanced debugging features like defining watches and modifying variable values have been used much less.
furthermore the same holds for the number of users generating these events the majority of users have added and or removed breakpoints and stepped through thecode while only .
.
modified variable values evaluated expressions and or defined watches.
rq2.
what is the relation between testing and debugging?
wr8 most debugging sessions start after reading or changing the code not after running tests.
regarding rq2.
we assessed the intervals that occur immediately before a debugging session starts.
the resulting frequencies and their percentages of all intervals occurring before any debug interval are .
for running unit tests .
for other debug intervals .
for reading and .
for typing intervals.
about of the debugging sessions start after reading or writing code only .
of them start after a failing or passing test run.
wr9 developers who spend more time executing tests are likely to proportionally debug more.
next we investigated the relation between the total duration of running unit tests and debug intervals per user.
we only considered the 25developers with at least one debug interval and one unit test execution.
at .
we find a moderate correlation between the two duration spans.
wr10 developers who read or modify test classes longer are not likely to debug less.
to complete rq2.
we studied the relation between the amount of time the user spends inside test classes i.e.
either reads or modifies tests and the debugging time.
for the developers with at least one debug interval or one opened test class we find no correlation at .
.
furthermore we find no correlation .
when focusing on the 84users with both at least one debug interval and one opened test class.rq2.
how are file length and debugging effort related?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the dichotomy of debugging behavior among programmers icse may june gothenburg sweden table frequencies of breakpoint types modifications and w atch dog2.
debugging events.
breakpoint type frequency breakpoint modification frequency event type frequency event type frequency class prepare change condition add breakpoint continued exception disable condition change breakpoint resume client field enable condition remove breakpoint suspend by breakpoint line disable define watch suspend by client method enable evaluate expression step into undefined change suspend policy inspect variable step over modify variable value step out 4 247 continuing ... 54 table descriptive usage statistics for key interval types relative to total observed time .
variable unit min median mean max log histogram debugging hours .
.
.
.
.
.
.
.
.
.
.
.
reading hours .
.
.
.
.
.
.
.
.
.
.
.
typing hours .
.
.
.
.
.
.
.
.
.
.
.
running ju nittests hours .
.
.
.
.
.
.
.
.
.
.
.
wr11 smaller classes are debugged more than larger classes.
here we examined whether there is a correlation between the file size of a class in source lines of code and the number of times the developer visits it in the source code editor in a debugging session.
at .
we find a strong negative correlation.
we also investigated the relation between the file sizes and the duration of the debug intervals in which they are opened and found no apparent correlation .
.
for rq2.
we aggregated and compared the number of classes in single debug intervals to the total number of classes we observed with w atch dogfor this project also through other intervals such as reading writing or running tests and the number of different classes that have been debugged during any debug interval of the project.
for we found that on average only .
median .
o f all project classes we observed in w atch dogintervals were ever debugged.
the value ranges from .
to100 where the cases possibly stem from small projects with only one or two classes.
for the results range from .
to100 with an average of .
median .
.
both results seem to indicate that debugging is focused on a relatively small set of classes in the project.
in of debugging sessions at most of the project s classes are debugged.
rq2.
do developers often step over the point of interest?
wr12 developers might step over the point of interest and have to start over again in of debugging sessions.
to answer rq2.
we first computed the total duration of all debug intervals per user.
then we performed a spearman rank order correlation test using these values and the programming experience the user entered during w atch dog2.
s registration process by applying a linear integer transformation see section .
.
for the 58users that have entered their experience and generated at least one debug interval this resulted in a weak correlation .
i.e.
more experienced developers are more likely to spend more time in the ide debugger.
during our research into debugging we sometimes heard anecdotal reports of frustrated developers stepping over the point of interest while debugging.
to this end we sought objective data to support how severe the problem is by identifying possible cases of steppingover the point of interest.
stepping over means that the developer steps one time too far and has to start debugging all over again.
reasons for this include pressing the proceed key too fast or realizing too late that the actually interesting location was in a past step.
to model this with our interval and event concept we look for a set of debug intervals that satisfy the following conditions the last event occurring within the debug interval is a stepping event and the interval is followed by another debug interval in the same ide session.
we then created subsets of these debug intervals by imposing a maximum time tmaxbetween two consecutive debug intervals.
figure shows the possible cases of stepping over the point of interest for the subsets with tmax minutes.
the trend line in figure shows that the amount of new possible cases of stepping over the point of interest starts to decrease significantly after about four minutes.
at this point about 150possible overshoot cases can be identified which corresponds to .
of the debugging intervals.
maximum time between debu g intervals in seconds number of possible overshoot cases figure possible cases of stepping over the point of interest per maximum time period between consecutive debug intervals.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden moritz beller niels spruit diomidis spinellis and andy zaidman table interviewed developers and debugging experts id occupation dev.
experience country area i1 freelancer years germany rich client platforms i2 developer years india e commerce i3 developer years usa real time systems i4 developer years uk data scraping e1 eclipse debugging project leaders switzerland india eclipse development e2 professor years greece software engineering e3 debugger developer years russia ide development interviews in this section we describe how we conducted developer interviews forrq3 and merge and discuss results from rq1 and rq2.
.
study methods interview design method.
to validate and obtain a deeper understanding of our findings from rq1 and rq2 and to mitigate apparent controversies we ran the combined observations from survey objective ide measurements and anecdotal interview insights across two sets of debugging experts.
a question sheet helped us steer the semi structured interviews which we conducted remotely via skype and took from minutes to minutes.
in one case e3 we performed the interview asynchronously via email.
subsequently we transcribed the interviews and extracted insightful quotes.
study subjects.
table gives an overview of our nine interviewees.
we sampled the set of regular developers from our survey population to gain insights into what hinders the use of debuggers why printf debugging is still widely used and whether they regularly step over the line of interest.
we chose the experts based on their industrial and academic position in the debugging field.
.
results this section juxtaposes survey rq1 and ide study rq2 results and discusses them with the qualitative insights from rq3.
use of the ide debugger.
inwr1 we found that two thirds of the watch dog2.
users were not using the ide provided debugger in our observation period an obvious contradiction to sr1 in which of respondents claimed to use it.
moreover no single user spent more than of his development time debugging.
there might be several reasons for the discrepancy the study populations aredifferent and the survey respondents were likely self selecting on their interest in debugging resulting in a higher than real use of the debugger.
as often observed in user studies most relevant datastems from a relatively small percentage of users.
w atch dog users were free to start and stop using the plugin at any time in the observation period.
hence for some users the actual observation period might be much shorter perhaps coinciding with not having to debug a problem.
almost equally many developers conceded to use printf statements for debugging in sr2.
we have anecdotal evidence from rq3 that they might use them even more when we asked i3about printf debugging he was very negative about it.
later in the interview he still conceded to use printf very rarely.
we believe a similar observation might hold for many w atch dog users.
as we cannot capture printf debugging or debugging outside the ide with w atch dog our finding does not mean two thirds of developers did not debug.
the phenomenon of a discrepancy between survey answers and observed behavior is not new.
belleret al.
observed a similar phenomenon with developers claimingto spend more time on testing than they really were .
as a consequence we emphasize their finding that survey answers always be cross validated by other methods.
printf debugging.
from rq1 and rq2 it seemed that developers were well informed about printf debugging and that it is a conscious choice if they employ it often the beginning of a longer debugging process.
interviewees praised printf as a universal tool that one can always resort back to helpful when learning a new languageecosystem in which one is not yet familiar with the tools of the trade.
about left over print statements that escape to production i2 was not worried at all because we have a rigorous code review process.
while frequently used developers are also aware of its shortcomings saying that you are half way toward either telemetry or toward tracing and that it is insufficient for concurrent programs primarily because the interleave in strange ways i3 .use of debugging features.
sr3and sr4indicated that most developers use line breakpoints but do not use more advanced breakpoint types like class prepare breakpoints.
while many developers knew and used conditional breakpoints they were widely ignorant of hit counts and the debugger s other more advanced functions.
wr5 to wr7 support this result finding that conditional breakpoints are indeed the second most feature in the ide debugger.
a similar result is visible in other debugging features like stepping through code.
in both cases we found that these features get used less as they become more advanced.
however the observed numbers on the use of these features are much lower than the claimed usage visualized in figure .
for example while of the survey respondents indicated to define watches during debugging only .
of the w atch dog .
users who use the debugger have defined a watched expression.
through our interviews with the debugging experts we identify three possible causes for this.
more advanced debugging features are seldom required.
i1 and i2said that specifying conditions or hit counts is often fuzzy is it going to happen the 16th 17th or 18th time?
and that once one knows the condition one almost automatically understands the problem.
then there is no need for the conditional breakpoint anymore.
moreover the types of problems where you need a conditionalbreakpoint happen very rarely i2 .
for example when we pre sented the breakpoint export feature of e clipse toi2 he replied i did not know such a feature exists.
others said it is a very esoteric thing and that they have used it maybe once or twice i3 .
this strengthens our intuition that debugging is an internal thought process not usually shared and that breakpoints are like a one shot.
ideally i wouldn t like them to be but i just set them anew i4 .
debuggers are difficult to use.
another reason given by interviewees even though seasoned engineers was that the debugger is a complicated beast i2 and that debuggers that are available now are certainly not friendly tools and they don t lend toward self exploration.
given our results on the use of features we asked interviewees whether it might simply be enough to reduce the feature set.
both developers and e1toe3emphatically declined arguing that once you get into these crazy cases they are really useful i2 .
there is a lack of knowledge on how to use the debugger .
when we asked developers where their knowledge of debugging comes from many said that big chunks are self taught and picked authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the dichotomy of debugging behavior among programmers icse may june gothenburg sweden up various bits and pieces on the internet i4 .
even i3 the only interviewee who indicated that debugging was explicitly covered said it is partly self taught partly through key mentor ships.
making a case for hands on teaching he elaborated that one of the engineers that mentored me was some kind of wizard with gdb.
i think when you meet someone who knows a very powerful tool it s very impressive and their speed to resolving something is much faster but it takes a lot of time toget to that point.
since we measured experience to have limited to no impact on which debugging features developers used sr6 this hints at a lack of education on debugging that is pervasive from beginners and computer science students to experts.
new computer science curricula that put debugging upfront could be an effective way to steer against it .
time effort for debugging.
our study results wr3 towr4 point to the fact that debugging in most cases is a short get it done i1 type of activity that with only of active ide time wr3 w e found to consume significantly less than the for testing and debugging reported by beizer and the estimations by our interviewees who gave a range of to of their active work time.
one reason why our measured range is so much lower might be that developers and humans in general have a tendency to overestimate the duration of unpleasant tasks as previously observed with testing .
another is that developers included debugging tasks such as printf and the use of external tools which we cannot measure.
we need more studies to quantify this initial surprising finding.
a common intuition in software engineering is that small is better since it is easier to manage and understand see for ex ample the recommendations to micro services small commits or short files.
contrary to this claim we found that short classes need considerably more debugging wr11 and that the longer amount of time developers spend in larger classes does not nearly compensate for it.
our interviewees agreed in unison that the hardest problems todebug are ones where interfaces or transactions between components are involved.
interfaces are typically short since they contain little logic but represent a common source of integration problems andthus the answers suggest debugging effort.
then longer classes are likely to have increased locality of features which makes them often easier to understand and thus probably also easier to troubleshoot.
we need more research on this interaction between file length and debugging probability.
future studies could try to exploit the finding to recommend optimal system designs as a compromise between modularity and the ability to debug them.use of tests for debugging.
in the survey most respondents think unit testing is an integral part of the debugging process especially for reproducing bugs at the beginning of the process sr5 sr7 .
however there is mixed evidence on this in rq2 as shown by wr8 wr9 and wr10.
on the one hand failing tests do not seem to be a trigger for the start of debugging sessions.
on the other hand running tests in the ide seems to be correlated with debugging more while reading or modifying tests is not.
two factors can play a role developers who are more quality concerned execute their tests more often and therefore also debug more.
this is contrary to intuition and the answers of some of our interviewees who claimed that as testing goes up the debugging effort should decrease e2 debugging is born of unknowns and effective testing reduces these i3 .
an explanatory finding might be that the creation of tests itself adds code and complexity that might need to be debugged.
we need more studies to research this interesting discovery.stepping over the point of interest.
we found that in less than about of the debugging sessions the developer might have stepped over the point of interest and had to start debugging anew wr12 .
this indicates that there is a limited but existent gap in current debuggers process that might be filled by back in time debuggers .
back in time debuggers allow developers to step back in the pro gram execution in order to arrive at the point of interest withouthaving to completely restart the debugging process.
all our interviewees could relate to situations in which this occurred to them stating that it happens all the time i1 to back in time debugger would be wonderful i3 .
however wr12 indicates that it might not be as frequent as some stated.
while the drop frame feature allows developers to go to the beginning of the current method it does not revoke side effects that already occurred and was therefore only found to be helpful in a limited way i3 .
currently mainstream ides do not support back in time debugging.improvements in ide debuggers.
we asked our interviewees how debugger creators could better support them.
their answers fallinto two categories make the core features easier to use while preserving all existing functionality.
create tools that capture the holistic debugging process better.
elaborating on i1denotes if you re in java and have to debug across language boundaries you really get to a point where you feel helpless.
other wishes included the ability to do back in time debugging similar to c hronon to have a live repl a feature the ide xcode introduced .
to improve the design of existing ide debuggers with findings from our study we arranged a meeting with three debugging project leads from e clipse e1 and an ide developer from a commercial company e2.
the e clipse leads said that while they had sporadic evidence on how some individual developers use their debugger they were unaware of the debugging behavior of a large population and the usage detail our study could provide.
they started or updated six feature requests for the debugger based on our study commencing work on bugs that had been dormant since .4in the following we focus on two already implemented features that are scheduled to roll out as part of eclipse release .
.
in our field study and interviews we identified left over breakpoints as a recurrent annoyance which developers have to removemanually with i1saying that suspending on old breakpoints unexpectedly interrupts his flow and that every so often once a week or so i just delete all of them.
after making the eclipse leads aware of this problem they implemented age deprecation for breakpoints.
it lets developers remove old breakpoints with one click.
although often referred to as a dirty hack since it interferes with and pol lutes production code our study found that printf debugging alsoprovides an advantage over the debugger s watch view in that it preserves the history of past logs for example of memory entities in the watch view .
conversely developers cannot enrich third party libraries for which no source code is available with printf statements but they can place debugger breakpoints in e.g.
their java byte code.
to keep a history of logs when using the debugger before our study eclipse and intellij users had to set up an artificial construction of 4see umbrella bug .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden moritz beller niels spruit diomidis spinellis and andy zaidman placing a conditional breakpoint that would print the information and always return false thus never suspend.
this hack of a conditional breakpoint that is not conditional bugtracker description required intimate familiarity with the idiosyncrasies of the debugger and had bad performance since code embedded in conditional breakpoints runs via the java debugging infrastructure which adds unnecessary overhead for a simple printout.
by offering the new breakpoint type tracepoint developers can now conveniently produce fast logs of debug traces.
the eclipse project implemented this simplified solution in bug which had been in hibernation since and on which work commenced after our discussion.
threats to v alidity in this section we examine threats to the validity of our study and show how we mitigated them.
construct validity.
the manual implementation of new functionality such as the addition of the debug infrastructure to w atch dog is prone to human errors.
to minimize these risks we extended watch dog s automated test suite.
furthermore we use this test suite to make sure we introduced no regressions.
in addition we tested our plugins manually.
finally we performed rigorous codereviews before we integrated the changes.
debug sessions mightnot correspond to actual debug work e.g.
a user might have inadvertently left the debugger in the ide running explaining our hour outlier.
however such outliers are expected in an observational study of several months .
similarly we approximate the number of classes in a project by the number of different classes we observe with w atch dog.
due to privacy reasons we cannot mine the repositories of projects to gain an entirely correct figure.internal validity.
since our survey in rq1 dealt with debugging participation might have been self selecting i.e.
developers more interested and knowledgeable in debugging are more likely to have responded.
we tried to contrast this with objective w atch dog observations which is not advertised specifically as a debugging tool.
an important internal threat is that the populations for rq1 and rq2 are different and their intersection is small six users participated in both studies .
however we are confident we only encounter a small sampling or comparison bias because key characteristics ofboth populations are similar as of respondents answeredthe survey for java which both plugins work with in rq2 the majority in rq1 used one of the ides supported in rq2 t h e experience distributions of both populations are similar and both populations should be large enough to even out individual influences.
due to the fact that w atch doggathers data automatically it is harder for potentially evil minded users to fabricate data than in surveys.
moreover that the majority of data comes from a relatively small power user population developers in our case top10 in wr1 is both normal in service use for example on twitter and other observational studies .
discrepancies between some survey answers and the objective ide observations have previously been observed in other studies .external validity.
during our data collection period of more than two months we collected intervals with a total duration of over ten developer years spread over 458users.
the fact that over of the survey respondents stem from the java community means that little survey data is available about other communities.
the sameholds for the analysis of the w atch dog2.
data which is restrictedto the java programming language and to the e clipse and i ntelli j ides.
other ides are not included in our analysis and the results with them might deviate.
however at least imperative statically typedlanguages similar to java like c c c or objective c would likely yield similar results and are so widespread that researching them alone impacts many if not the majority of developers.
conclusion we set out to obtain a first cross validated understanding of developers debugging knowledge and contrasted it with their real world ide debugging behavior.
we found strong dichotomies in developers opinions knowledge and behavior many believe modern debuggers to be superior to printf debugging yet still employ it for many good reasons.
ideobservations confirmed this finding as only a third of developers ever invoked the debugger.
we found that debugging is a technique defined by necessities it is a relatively fast paced and short lived activity that is by nature so complicated that the tools around it should be as simple as possible.
consequently developers use only basicfeatures and seldom resort to more advanced breakpoint types or debugging techniques.
developers spend surprisingly little time in the debugger only of their total development time on average in stark contrast to previous findings claiming more than .
as developers become more experienced they seem to use the debugger slightly more possibly because they educated themselves on its advanced affordances over printf debugging.
we also found that having more tests in the code generally does not reduce the debugging burden possibly because test code adds to the overall code that needs debugging.
in general developers theoretical knowledge and practical use of specialized debugging features are relatively shallow just theamount that is seemingly sufficient for their debugging problems.
most developers said debugging was self taught and not part of their curriculum.
we believe that more educators can include practical hands on teaching start in first year courses.
astonishingly althoughbugs are inevitably linked with software and students learn programming in their introductory courses they are only taught to properly debug much later if ever.
adding to this lack of debugging education even experienced developers admitted that debuggers are not easy to use.
apart from the wish for back in time debuggers developers never expressed the wish for more debugging features.
instead of introducing ever more esoteric features we therefore call to make using the already existingdebugger features easier to use and more accessible.
with the help of three e clipse project leads we identified several areas of improvement in the e clipse debugger leading to new simplified debugging features.
one example is the introduction of a new breakpoint type in eclipse that combines the advantages of debugger instrumentation with the flexibility of printf debugging.
other ide and debugger creators could follow this example and use our findings to further improve their debuggers.