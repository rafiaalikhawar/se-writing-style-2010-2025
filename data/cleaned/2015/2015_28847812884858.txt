understanding and fixing multiple language i nteroperability issues the c fortran case nawrin sultana justin middleton jeffrey overbey munawar hafiz auburn university department of computer science and software engineering auburn al usa nzs0034 jam0058 joverbey auburn.edu munawar.hafiz gmail.com abstract we performed an empirical study to understand interoperability issues in c and fortran programs.
c fortran interoperability is very common and is representative of general language interoperability issues such as how interfaces between languages are defined and how data types are shared.
fortran presents an additional challenge since several ad hoc approaches to c fortran interoperability were in use long before a standard mechanism was defined.
we explored applications automatically analyzing over million lines of code.
we found that only of interoperability instances follow the iso standard to describe interfaces the rest follow a combination of compiler dependent ad hoc approaches.
several parameters in cross language functions did not have standards compliant interoperable types and about one fourth of the parameters that were passed by reference could be passed by value.
we propose that automated refactoring tools may provide a viable way to migrate programs to use the new interoperability features.
we present two refactorings to transform code for this purpose and one refactoring to evolve code thereafter all of these are instances of multiple language refactorings.
categories and subject descriptors d. .
coding tools and techniques d. .
metrics d. .m miscellaneous keywords c fortran language interoperability polyglot refactoring .
introduction modern programs are often polyglot written in multiple languages.
the need for multiple languages arises because each language may be specifically designed for a problem domain.
a recent study reported that about of programs in github were written using at least two languages .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c circlecopyrt2016 acm.
isbn .
.
.
.
and colleagues identified six multiple language interoperability patterns.
five are about variants of interaction in which one of the languages represents data e.g.
anidentifierinanxmlconfigurationfilecontainingthe qualified name of a java class shared id an xml file containingconfigurationdatathatisusedbyajavaprogram data loading etc.
the survey of github repositories identified these five kinds of interactionsto be the most common .
however the sixth kind of interaction in which a program written in one language executes another program written in a different language execution raises more issues about comprehending analyzing and evolving programs.
this paper concentrates on this specific interoperability pattern of polyglot programs.
although a common phenomenon issues of multiple language interoperability have not been explored in detail.
tan and croft studied java and c interoperability using jni java native interface and identified categories of security problems.
the interoperability issues were studied manually with the support of simple lexical search of the results were false positives .
most problems identified in the study originate from misunderstanding the semantics of interoperability.
several papers have explored the program comprehensionburdenofpolyglotprograms and proposed ways to improve the situation by linking artifacts across the language boundaries.
this paper describes a case study on interoperability issues considering c and fortran programs.
interoperability between c and fortran is featured in many legacy programs because of the popularity of those programming languages in specific problem domains.
it manifests the typical issues arising in general multiple language interoperability scenarios issues such as interface discovery datatype sharing and memory management data sharing semantics etc.
additionally the fortran language has evolved through several versions fortran and are the most recent thus interoperable programs have had the opportunity to evolve as well.
the ad hoc style of interoperability used in older fortran programs depends on the compiler.
c interoperability was standardized in fortran finally making it possible to write c interoperable fortran code that was also portable between platforms and between compilers.
this was a reactive change to the iso standard made specifically because the fortran community had demonstrated a need for it.
unfortunately this means the language was fixed long after developers encountered the problems involved.
this motivates the need for a tool that can reliably upgrade legacy code to make it standards2016 ieee acm 38th ieee international conference on software engineering compliant since large scale rewrites are often not feasibl e. we studied polyglot programs automatically analyzing over million lines of code to understand the issues of c and fortran interoperability.
we found that very few programs use the portable c interoperability mechanism introduced in fortran out of programs out of cross language function calls .
we also found that some datatypes supported by the ad hoc interoperability mechanisms are not supported by the current fortran interoperability standard.
for example unsigned datatypes are shared between programs in an unsafe manner that may lead to subtle bugs or even security problems .
finally we found that parameters of many cross language function calls are passed by reference even though they are only used in a read only manner parameters out of thus creating the potential for security problems by violating the principle of least privilege .
the findings from the case study guide the design of a refactoring based approach to fix the interoperability issues.
we introduce three refactorings.
two of them modify programs that follow old c and fortran interoperability conventions to take advantage of the new interoperability standards introduced in the iso fortran standard .
a convert to standard data type csdt refactoring identifies variables that are shared between c and fortran and converts the fortran declarations to use interoperable types compliant with the iso standard.
a transform to standard interface tsi refactoring identifies a c function called from fortran and introduces an interface block into the fortran code which provides a prototype for the function and allows the fortran compiler to type check the arguments at its call sites.
the third refactoring is a variation of the change function signature cfs refactoring that applies to multiple languages.
it helps evolve the interface between c and fortran programs after they have been updated to follow the iso fortran standard.
these three are examples of multiple language program transformations.
researchers have explored similar program transformations primarily for renaming identifiers .
in contrast our refactorings are more complex they require a tool capable of parsing and analyzing types in both the host and foreign languages they depend on data flow and dependence analysis to determine a safe transformation option and they ultimately help programmers convert programs using ad hoc compiler dependent and potentially unsafe interoperability conventions into programs that rely only on features supported by the iso standard.
this paper makes the following contributions to the best of our knowledge this is the first paper to presentempirical data studying the interoperability issues of multiple language programs .
the paper explores how the evolution of interoperability features affects legacy code and introduces a refactoringbased solution to evolve programs .
the paper introduces multi language program transformations based on syntax and semantics aware analyses of both the host and foreign languages .
.
motiv ating example one set of programs in our test corpus is a repository of networking and data structure code from the numerical algorithms group nag .
it contains c and fortran in teroperable functions in its c files and fortran files total kloc .
the following interoperability example is based on the tcpconnect function defined in clientc.c a nd called from client.f90.
the clientconnect s ubroutine in the fortran program calls the c function subroutine c lient connect handle host name host port error integer i ntent out handle character intent in host name integer i ntent in host port logical i ntent out error ... call tcp connect fd table handle fd socket host name host port error ... return end subroutine c lient connect the corresponding c function definition is in client.c.
define tcp connect tcp connect ... void tcp connect sock host name port error host name len int s ock port error char h ost name int h ost name len ... there are several issues with this code.
first the defi nition in c has a trailing underscore defined through the macro.
adding a trailing underscore is an ad hoc mechanism of specifying an interoperable c function.
shenkin calls this convention bind we will adopt that terminology in this paper.
the fortran compiler adds an underscore for the foreign function to be called the c definition matches that.
but this may not be portable for another compiler.
second the function call in the fortran code has four parameters but the c function definition has five parameters.
the fortran compiler adds the additional parameter host name len in general it adds one parameter for each string parameter that is passed.
again this is compilerdependent.
if the passed parameter is a string literal the length parameter may not be passed.
the fortran standard removes the need for the extra parameter.
third the portparameter is passed as a reference.
although it is not shown here the tcpconnect function uses it in a reado nly manner.
passing it as a reference violates the least privilege principle which may lead to subtle bugs and even security problems .
the case study presents empirical data on c fortran interoperability issues.
then we describe three refactorings to fix the interoperability issues .convert to standard data type updatestheshareddatatypestofollow the standard.
transform to standard interface updates the interface description and fixes the parameter passing styles.
once updated change function signaturecan be used to evolve the interoperable code.
.
background this section describes previous work on understanding languageinteroperabilityissues creatinginteroperabilitystandards comprehending and analyzing multi language programs and transforming programs written in multiple programming languages.
.
understanding multiple language issues r esearchershaveidentifiedtheimportanceofmulti language programs in software evolution research yet there has not been any empirical study to understand the issues in interoperability semantics.
vetro and colleagues studied commits in the apache hadoop repository.
they distinguished commits that touched translation units of multiple programming languages cross language commit .
they foundthatmostcommoncross languagecommitsin hadoop are between c java and a language for data representation xml .
however they reported that a commit affecting c and java is more likely to be error prone perhaps because of the underlying complexity.
tomassetti and colleagues reported that the most common multi language interoperability patterns are between a high level programing language and a language for data representation these were featured in five out of their six interoperability patterns.
they also found that the interaction between two high level languages is more complex.
tan and croft studied a portion of the native code in sun s jdk .
to understand the security issues in java and c interoperability.
they distinguished seven categories of security problems.
most of these problems originate because developers misunderstand interoperability issues that may lead to buffer overflows.
however some of these security problems may arise from the issues of multi language interoperability.
for example c pointers are often casted to java integers so that they can be passed through java code but this may cause security problems if an attacker can inject arbitrary integer values that will be interpreted as pointers .
our study reports similar problems but its scope is broader we wanted to explore how the interfaces are described and how the data types are shared in general.
.
interoperability standards many programming languages provide a foreign function interface ffi that allows programs to call routines or use services written in another language.
java has the java native interface jni which allows java code to interoperatewithcodewritteninlanguageslikecandc .
this paper focuses on interoperability between c and fortran.
before the fortran standard c and fortran programs interacted in ad hoc ways that depended on the specific c and fortran compilers.
the names of interoperable c functions needed to be changed according to the fortran compiler s naming convention a popular convention bind was for the compiler to append a trailing underscore to a fortran function s name .
parameters were usually passed by reference but some compilers provided a non standard function val that allowed parameters to be passed by value.
passing character strings added additional complexity.
most fortran compilers passed the string length byvalue usinga hiddenargument whichhad to be explicitly added to the corresponding c function .
fortran standardized interoperability with c. it provides a bind c attribute to specify c linkage and a module called iso c binding .
fortran introduced kindparameters to select different machine representations for each of the intrinsic data types e.g.
vs. byte integers fortran s iso c binding module includes named constants used to specify kindparameters for c interoperable types.
the standard also eliminated the need for c function names to have a trailing underscores appended and it in troduced an attribute valuefor passing parameters by value.
finally it also resolved the issues with character strings eliminating the need for hidden length arguments.
chivers and sleightholme reported in that most compilers supported the fortran standard but code writtenfollowingtheadhocc fortraninteroperabilitymechanisms caused unexpected runtime errors when compiled by fortran compilers.
in this paper we introduced two automatedrefactoringsthattransformprogramswritten following the old ad hoc c and fortran interoperability mechanism to fortran standard interoperability.
.
comprehending polyglot programs several researchers have aimed to reduce the program comprehension burden for developers of multi language programs.
their general approach is to use a model for representing facts about different programming languages and link facts between the host and foreign languages.
linos created an early prototype to show the dependencies among multiple programming paradigms.
linos and colleagues later explored a more sophisticated prototype to demonstrate host to foreign language dependencies between java and c source code.
a later work explored an intermediate representation to determine the dependencies more efficiently .
mayer and schroeder not only captured the dependencies between languages semantic links in an explicit structure xll acronym for cross language links but also demonstrated how such links can be used to perform simple refactorings.
a somewhat different approach to facilitate multiple language comprehension is dsketch.
cossette and colleagues used a pattern matching approach to link artifacts among languages.
however developers have to write these pattern specifications as an overlay on the underlying code.
the models created to represent different programming languages are mostly different since different languages follow different programming paradigms object oriented vs. functionalvs.database specific etc.
.
tocreatethemodels researchers had to separately analyze the programs written in different languages then link them at a later stage.
in contrast our empirical study analyzes c and fortran programs together to extract facts a similar approach is required to support complex multi language refactorings.
.
multiple language refactorings strein and colleagues first explored refactoring multilanguage programs.
interfaces were described using a common meta model the transformations were performed by separate language adapters.
they later explored how to efficiently store and evolve the common meta model to support the transformations .
they implemented a renamerefactoring on a combination of visual basic c and j .
the renaming mechanism was based on searching identifiers and matching their semantics with the identifier toberenamed.
theworkoncreatingacommonmeta model for multi language refactorings followed from prior work by tichelaar and colleagues .
chen and johnson extended eclipse s java rename refactoring to support the refactoring of xml identifiers usedbythestruts hibernate andspringframeworks.
their work was not based on a common meta model of the two languages.
they pointed out that finding a general solu774tion based on a common meta model for multiple language r efactorings is a hard problem instead researchers should focus on how to support the common refactorings individually.
kempf and colleagues followed a similar approach to support the rename refactoring in eclipse for java and groovy.
both of these works are based on the refactoring participant mechanism introduced in eclipse .
which follows the observer pattern .
the subject role is played bytherefactoringoperationonjavafiles whiletheobservers are refactoring operations to be performed on the xml files.
schink and colleagues implemented multiple language versionsofthe rename method andpush down method refactorings for java hibernate and sql.
they also introduced a specific refactoring for relational databases .
they concluded that following a common meta model is not feasible across all combinations.
mayer and schroeder used their analysis mechanism for polyglot programs .
to support renaming across java ruby and xml.
the multi language refactorings in this paper are more complex than a rename like refactoring.
they require type analysis as well as data flow and dependence analysis in the host and foreign languages.
.
interoperability study .
research questions in our empirical study of c fortran interoperability we explore how the interface between the languages is defined which data types are shared and how the data types are shared.
since the interface between fortran and c was standardizedin fortran2003 weexplorewhetherdevelopers have been following this approach.
we ask three research questions rq1 interface.
how are interfaces declared in the test programs?
how often are ad hoc interoperability mechanisms used?
rq2 shared data types.
whatdatatypesareshared between c and fortran code in our corpus?
how are data types supported by ad hoc interoperability mechanisms handled differently by the fortran standard?
rq3 parameter passing mechanism.
howoftenare arguments passed by reference vs. by value?
how often are arguments passed by reference when they could be passed by value instead?
.
test corpus we explored applications that contain c and fortran functionscallingeachother.
fiveapplicationswerecollected from the test suite of photran which provides fortran support in eclipse.
we selected applications that contained c and fortran code.
nine applications were collected from a paperonglobalclimatemodels .
finally sixapplications were collected by searching github for fortran applications then selecting the ones that also contain c. table lists the applications along with the number of c and fortran files and the size of the applications.
we automatically analyzed over million lines of code from over files.
of the applications modeled global climate systems for use in research and forecasts ccsm4 cesm cfs cmcc g and model are from the coupled model intercomparison project cmip5 .
three other projects were scientific simulations elegant ele nwchem .
nwc and magneticmodel mag .
elegant began as atable applications used in the study name of applications of of id used to refer to it c files fortran kloc files asteriods ast .
ccsm3 ccsm3 .
ccsm4 ccsm4 .
cesm cesm .
cfsv2 cfs .
cm2.5andflor cm .
cmcc cesm cmcc .
compiledexamples com .
elegant ele .
geosagcm eros g .
loop with bitmask lp .
magneticmodel mag .
mechanic mech .
modele2 model .
nwchem .
nwc .
rimbaud rim .
solsys sol .
wrfv3 wrf .
www .
yoda yod .
total .
particle generator and tracker and has since grown to inc lude much more we found a version which included tools written as polyglot programs in the mid 1990s.
nwchem is a computational chemistry package we used the release.
magneticmodel was a repository of utilities for the world magnetic model in which are simulation programs for the earth s magnetic field.
this project had been steadily updated between and .
the other collected applications are from github and other repositories on the web and as such their functions are not closely related.
the interoperable functions in com and rim both authored in were intended explicitly as small examples exploring interoperability in c fortran and in some cases r. mech released around also follows this pattern being a task management system for simulations it allows extensibility with other languages and includes examples of c fortran interoperability to illustrate it.
ast is a implementation of the asteroids video game using both c and fortran to demonstrate an interface with the x window system whereas yod is a deconvolution algorithm released around for the yorick language.
lp is a 2012accumulationoperatorfor sparsearrays.
sol includes code to identify and remove radio interference for telescopes with some parts of the code dating to the late 1990s.
www is miscellany from the numerical algorithm group s repository.
it contains networking and data structure code written throughout the 1990s.
.
data collection mechanism for rq1 we had to search for four different ways of describing the interfaces appending an underscore to interoperable c function names known as the bind convention using external using a macro and using the c binding interface described in fortran .
we used a combination of grepandctagstools for this.
thectagstool generates an index file of names including functions found in source and header files.
to find the interface definition following the bind convention we collected all the function names with a trailing underscore from the 775table interoperability interfaces app.
using using usingusing id bind external macroother standard convention declaration ast ccsm3 ccsm4 cesm cfs cm cmcc com ele g lp mag mech model nwc rim sol wrf www yod total c side and then looked for matching function calls from the f ortran side.
for the other three approaches we started on the fortran side.
we used grepto look for the externalkeyword patterns describing the macros and the iso c binding and bind c keywords.
then we searched for the same binding label in c code for each of the matching entities.
this process was run by automated scripts.
rq2 focuses on the data types shared between c and fortran.
we used the type analysis support in openrefactory c to determine the types of all function parameters.
for rq3 we explored whether the c function definitions expect the parameters to be passed by value or by reference.
again using openrefactory c we used type analysis to distinguish pointer types and performed a reaching definitions analysis on the parameters and their aliases to determine if the passed parameters were redefined inside the function.
we used these results to determine which parameters could be converted to pass by value on the fortran side.
we only considered basic i.e.
intrinsic types like integers.
we assumed complex types such as arrays and structures would always be passed by reference.
.
understanding c fortran interoperability this section describes the results from our study and how theresultscontributetodesigndecisionsfortherefactorings.
.
rq1 interface how are interfaces declared in the test programs?
how often are ad hoc interoperability mechanisms used?
key result m ost applications containing interoperable code use ad hoc interoperability mechanisms making the code compiler dependent.
design decision code using the bind and externalconventions can be refactored to follow the interoperability mechanism proposed in fortran .
table lists four approaches to describe the interfaces ofi nteroperable functions.
the most up to date approach is to follow the interface specification mechanism described in the iso fortran standard .
one ad hoc compilerdependent approach is to append an underscore to the c routine name for interfacing with a fortran routine bind convention.
.
another approach is to use an external declaration in the fortran code while the c routine uses the compiler specific underscore.
finally a programmer can use a macro in c code to define interoperable functions.
there were interoperable procedures in the applications.
most of them followed the bind convention for interfacing.
about used external.
only a few instances followed the fortran interoperability standard.
most of the applications were written and or evolved after the fortran standard .
.
yet only four applications contain some instances following the fortran standard.
alloftheseapplicationscontainmanyotherinteroperability instances that follow a combination of old techniques.
in fact nine applications contain interoperable c and fortran functions that follow multiple interoperability approaches.
perhaps the code was written by different programmers and evolved through a long period of time.
the fortran standard requires that an elaborate interface be declared for interoperable procedures.
the following listing from mech shows an interface definition for a function named cfunc.
fortran interface and call interface function cfunc n x result cval bind c use iso c binding implicit none integer c int intent in value n real c double intent inout dimension x integer c int cval end function cfunc end interface ... pstatus cfunc n x c function int c func int n double x ... the same declaration can be made more concisely using t hebind convention or the externalkeyword but it comes at the cost of portability.
for example the bind approach for specifying the previous example may look like this fortran interface and call integer cfunc pstatus integer n real kind dimension x ... pstatus cfunc n x c function int c func int n double x ... table shows that many interoperableroutines were writt en using c macros.
this convention was used to call external library routines for specific libraries e.g.
performance application programming interface papi message passing interface mpi etc.
the programmers of applications inourcorpususedtwotypesofmacros fort name and f77 func .
776table shared data types only parameters in functions foll owing ad hoc interoperability standard app.
idshared intrinsic type shared c har typeshared a rray typeshared pointer shared d erived typeshared l ogical typeint float d ouble typeunsigned t ypesingle p ointerdouble p ointerfunction p ointer ast ccsm3 ccsm4 cesm cfs cm cmcc com ele g lp mag model nwc rim sol wrf www yod total add disallow remove add add c ptr our use add b ind add fortran compatible potentially extra compa for void transfor c funptr attribute compa2003 name unsafe length tible pointer mation not and name tible conversion constant cast to from c name cast to don t support constant c bool approach and signed function constant integer support ed yet for type attribute intrinsic members macros were typically used to call external library rout ines.
only in two instances in the compiledexamplesmaster com application were macros were used to call a user defined routine in fortran from c. we distinguished these instances in the other category.
program interfaces following the bind convention or the externalkeyword can be transformed to fortran style interface definitions.
interfaces defined by macros could also be converted to fortran style interface definitions but we did not implement this since the macros were specific to a single application.
this leads to two variants of the transform to standard interface refactoring .
.
rq2 shared data types what data types are shared between c and fortran code in our corpus?
how are data types supported by ad hoc interoperability mechanisms handled differently by the fortran standard?
key result m any data type interoperability issues were resolved by the fortran standard although some data types are not supported by the standard.
design decision treat each of the types separately and convert them to interoperable types.
functions that use non interoperable types are not refactored.
when a function is defined in one language and called by c ode written in another language it is important that the argument and return types be compatible.
consider passing afloatvalue from c to fortran.
fortran s equivalent type isreal and in the case of fortran real kind c float .
if a programmer wants to change c fortran legacy code to follow the fortran interoperability standard she must use the correct data types in each context.
sometimes the data types may be incompatible.
for ex ample fortran and fortran allow a logical type to be of various kinds distinguished by the kindparameter .
but fortran only allows one interoperable logical type c bool the kindvalue implicitly defined to be which corresponds to the booldatatype of c. if a program uses data types not supported by fortran they cannot be refactored automatically.
table shows the data types of function parameters for the functions that communicate using ad hoc interoperability mechanisms functions from table .
we analyzed the compatibility issue of the shared data types across different interoperability standards.
as expected intrinsic data types integerand realtypes in fortran are shared most commonly.
however not all intrinsic types are interoperable depending on the interoperabilityconventionused.
therewere50 unsigneddatatypes1 passed from c to fortran via ad hoc interoperability mechanisms but fortran does not support the unsignedtype.
in these cases the fortran code treats the c unsigneddata as a signed type.
consider the mpassigntocpufunction mpassigntocpu.c line from g c parameter uint32 t r elative cpu fortran data integer nowcpu here fortran assumes that the passed data is a signed integ er.
thisisunsafe itmayleadtoasignednessproblem even a security vulnerability if the assumption is not right.
the programmers have to ensure that the code is not dependent on the data type change.
some fortran compilers support unsigned types e.g.
the sun studio fortran compiler but it is not widely adopted we did not find 1this excludes unsigned char types.
they are supported in fortran .
however there were no such instances in our corpus.
777any instances of unsigned intrinsic types in the corpus.
gu ided by the empirical data our convert to standard data type csdt refactoring operates in two modes.
in the aggressive mode the refactoring converts the unsigned type to a signed type on the fortran side.
in the safe mode csdtdoes not refactor the interface following ad hoc standard.
when a string i.e.
character pointer data type is shared typically extra parameters are optionally added at the end of the c function to denote the length of the strings that are passed from fortran.
table lists string data types that were shared.
in instances extra integer parameters denoting length are added to the interoperable c functions.
consider the extra host name len parameter in the tcpconnect function from www as shown in the motivati ng example .
in the remaining instances the string length was fixed since a string literal was passed so it was not passed explicitly.
the extra length parameter creates an issue when parameter orders are changed in a change function signature cfs refactoring the corresponding length parameters have to change as well for the reordered string parameters.
however fortran removes the need for the extra parameter.
a cfsrefactoring design is more clean for code following this standard.
we implemented cfsso that it only supports fortran compliant code.
array variables are frequently shared between c and fortran instances in table .
most of the shared arrays containedbasicdatatypes.
wefoundonly2instanceswhere an array of structs is passed.
this makes the fortran interfacedefinitionmorecomplicated sincethedetailsofthe struct have to be included.
the convert to standard data type csdt refactoring supports arrays with complex data types.
table lists pointer variables2that were shared.
the fortran convention is to create an integerwide enough to hold the pointer passed from the c side although there is apointerattribute.
in instances the pointer types from the c side were cast to integer data types.
only www has instances that used the pointerattribute it also uses the cast to integer approach in instances .
the two code snippets are from www showing two different ways to share pointers.
c parameter v oid sub fortran datatype integer intent in sub c parameter v oid calc handle fortran datatype integer pointer calc handle thec onvert to standard data type csdt refactoring supports functions that share a single pointer data type.
out of single pointers listed in table are nonvoid pointers they are converted to integers.
void pointers are converted to type c ptr and passed by value usingthe valueattribute according to fortran standard.
csdt does not support function pointers since there were few instances of those.
however this can be added easily using the type c funptr type introduced in fortran .
pointers with multiple indirection levels can be supported by using type c ptr and casting them to void pointers.
however this maybeunsafebasedonhowmemoryismanaged.
therefore csdtdoes not handle multiple pointers.
2this excludes character pointers strings .
character pointers are listed separately in column of table .table parameter passing mechanism fortran routines calling c functions app.
i dpassed b y valuepassed by reference value d efined in cintrinsic u nchanged in cother u nchanged in c ast ccsm3 ccsm4 cesm cfs cm cmcc g mech model nwc wrf www total there were derived types struct types shared bet ween c and fortran in the applicationsin our corpus .
the convert to standard data type refactoring supports derived types using an explicit bindattribute as introduced by the fortran standard.
finally table lists logicaltypes in our corpus.
none of them used a kindparameter so there were no compatibility issues converting them to follow the fortran standard.
the logicaltype instances in fortran used an int type in c code to share data.
the convert to standard data type csdt refactoring converts them to use c s booltype.
.
rq3.
parameter passing mechanism how often are arguments passed by reference vs. by value?
how often are arguments passed by reference when they could be passed by value instead?
key result t here are many instances that a variable is passed by reference but it is sufficient to pass it by value.
design decision use data flow analysis to find if a parameter is used in a read only manner pass such parameters by value from fortran to c. pass other parameters by reference.
fortran only supports call by reference while c supports b oth call by value and call by reference.
thus when a c function calls a fortran routine the parameters have to be passed by reference while a fortran routine can pass parameters to c following both styles.
if a variable can be passed by value passing it by reference violates the principle of least privilege .
table lists how parameters are passed from fortran to call c functions.
only parameters were passed using the valueattribute in their declaration statement i.e.
passed by value following the fortran standard.
an example is in the cfieldlistf unction call in model systemtools.c the n lparameter is passed by value.
c parameter i ntnl fortran call integer c int value nl all applications using ad hoc interoperability mechanisms a s well as some following the fortran standard passed 778all parameters by reference while calling c routines from f ortran.
there were instances of parameter passing by reference.
table shows that out of were modified inside the called c routine therefore they ought to be passed by reference.
about one fourth of these parameters were passed by reference but could have been passed by value.
these are parameters with intrinsic types e.g integer real logical and unsigned types.
consider syssleepfrom www sysdepc.c fortran parameter integer intent in secs c function s uspend execution for a specified time void s ys sleep secs int s ecs sleep s ecs here the c function suspends the execution for the specified t ime.
the value of secsnever gets changed.
so it can be passed by value.
in contrast some of the character array and intrinsic array types were not modified inside the called c function.
however they are passed by reference .
since there were many instances of parameters unnecessarily passed as reference we performed a reaching definitions analysis on the parameter and its aliases and used this to properly pass a parameter as a value or a reference inside theconvert to standard data type andtransform to standard interface refactorings.
.
refactoring to fix c fortran interoperability issues since very few programs follow the iso interoperability standard rq1 there is a need for an automated approach to assist programmers in updating to the new standard.
we describe two refactorings csdt andtsi for this purpose.
we also describe a multi language version of change function signature to evolve c fortran interoperable functions.
.
convert to standard data type csdt theconvert to standard data type refactoringconverts data declarations to use standardized c interoperable types introduced in fortran .
motivation to standardize interoperability it is necessary that fortran data shared with c functions be interoperable with a c type as described in the iso fortran standard.
the types that are not supported should be left alone.
without automated tooling a programmer has to manually transform such interoperability instances.
precondition a programmer selects a c function name or definition and invokes the csdt transformation.
the following precondition is checked the function is an interoperable one it calls a fortran subprogram or is called by a fortran subprogram.
mechanism therefactoringmodifiesthetypestofollow the fortran standard.
csdtmaintains a mapping between interoperable fortran types and their equivalent c types some strategies are described in table .
for each shared variable csdtdetermines the c type and the equivalent fortran type and type parameter.
it performs a data flow and dependenceanalysis on the c side to determine whether any parameter is passed by reference but is used in a read only manner.
if such a parameter is passed by reference from the fortran code csdtconverts the fortran type declaration into its standard form.
if the type is not interoperable with c an error is raised.
example consider the motivating example from extracted from www.
the following shows the updated data types integer c int sock character c char intent in host name integer c int intent in value port logical c bool intent out error csdt maps the data types of the parameters passed to foll ow the fortran standard e.g.
c boolis used to represent logical types.
the data flow analysis identifies that the variable portis only used as read only value.
csdt suggests that it should be passed by value.
.
transform to standard interface tsi thetransform to standard interface refactoring introduces a fortran interface block corresponding to a c function.
the parameter and return type declarations use the c interoperable types defined in the fortran standard.
motivation fortran provides syntax that makes the names and types of interoperable procedures explicit.
this transformation ensures that the interface between c and fortran follows this standard.
precondition a programmer selects a c function name or definition and invokes the tsirefactoring.
the following preconditions are checked the function is an interoperable one it calls or is called by a fortran procedure.
the selected interoperable function uses a legacy mechanism for interfacing.
mechanism the refactoring introduces a fortran 2003compliant interface block to explicitly describe the interoperable interface.
tsifirst determines all the function call expressions both in c and in fortran code that refer to the selected function.
it removes the trailing underscore from the name of the function and all the function call expressions on the c side.
on the fortran side tsiadds a reference to the iso c binding module and an interface block with appropriate bind c declaration for the procedure based on the c functionprototype.
tsicallsthe csdtrefactoringtoconstruct parameter declarations in the interface that is introduced.
if fortran passes any character string data to c and the c code adds an extra length parameter the c function signature must be changed to drop that parameter and instead introduce a local variable inside the function to refer to the string length.
finally if there is an externaldeclaration for the selected c function in the fortran code tsiremoves it.
example consider the running example from .
the tcpconnect function in the c program used the appendedu nderscore naming convention.
tsidefines an interface on the fortran side.
779interface subroutine tcp connect sock host name port error bind c use iso c binding integer c int sock character c char intent in host name integer c int intent in value port logical c bool intent out error end subroutine end interface ... ... subroutine c lient connect handle host name host port error bind c use iso c binding ... call tcp connect fd table handle fd socket host name host port error ... return end subroutine c lient connect the parameter types are determined by calling the c sdt refactoring.
on the c side the trailing underscore for the function can be removed.
void tcp connect sock host name port error int s ock port error char h ost name int host name len strlen host name ... also the h ost name len parameter from the function definition has been removed from the c function signature and a local variable has been introduced instead.
this is because the fortran compiler no longer passes hidden string length parameters.
.
change function signature cfs thechange function signature refactoring allows a function s interface to be changed with all call sites updated accordingly.
a typical use is parameter reordering.
for an interoperable function this requires updating the function definition declarations and call sites in both c and fortran code.
motivation aftermakinganinteroperablefunctioncompliant with the fortran standard perhaps using the previous two refactorings there may be a need to evolve its interface in the future e.g.
swapping the parameter order.
this affects both c and fortran code.
precondition a programmer selects a c function name or definition and invokes the cfsrefactoring.
the following preconditions are checked the function is an interoperable one it calls a fortran routine or any fortran routine calls it.
the selected interoperable function uses the standard interfacing mechanism by using a binding label match.
mechanism the refactoring modifies the interface definition on the fortran side if needed the function definition on the c side and call sites on both c and fortran sides.
currently the refactoring supports swapping parameter order only other features such as adding and deleting parameters could be added in the future.
example consider the running example from updated to follow the fortran interoperability standard by applying the csdtandtsirefactorings.
suppose aopenrefactory c fortran filec filephotran1.
invoke refactoring on a c function2.
search for corresponding function .
precondition check3.
precondition check4.
analysis name binding type dataflow5.
modify source5.
modify source4.
analysis name binding type figure refactoring steps p rogrammer wants to apply cfson this updated program to reorder the first two parameters of the tcpconnect f unction.
the modified c code shows the parameters sockand host name in swapped order.
void t cp connect host name sock port error int sock p ort error char host name ... similar changes are made on the fortran side.
the following s hows the modified function call.
call tcp connect host name fd table handle fd socket host port error .
ev aluation w e prototyped the three refactorings by building on the c and fortran refactoring infrastructures in openrefactory c and photran respectively.
both are eclipse plug ins each has its own abstract syntax tree and its own mechanisms for resolving name bindings variable types etc.
we created a new plug in to automate the refactorings dependent on both that analyzes code in each language separately.
when a user invokes a refactoring on a c function the openrefactory c module passes the information to the photran module and searches for corresponding interoperable routines and the files that contain the routines.
then the refactoring engines perform the precondition checking analyses and transformations separately figure .
we tested the refactorings manually on our test corpus.
we did not test all the interoperable function calls.
we randomly selected the refactoring targets in all the programs.
however we covered someinstancesfor each typeof interoperable issue.
moreover the code coverage of our refactoring shows that we cover a major part of the refactoring implementation while we were testing statement coverage for the c side implementation and statement coverage for the fortran side implementation for tsi bind refactoring and for the c and fortran implementations fortsi external refactoring .
after the refactoring we validate that our refactoring did not introduce syntactic errors.
table shows the number of function calls that were tested for each of the programs.
we also ran four programs lp mag rim and wrf before and after applying tsiand csdtrefactorings .
lp mag and rim ran with the same input for wrf we ran the accompanying testsuite.
the programs executed the refactored code segments and generated the same output before and after the refactorings.
other programs were not tested because they required special hardware or libraries to be present.
780table testing the implemented refactorings program of f n calls t estedcsdt tsi bind tsi external cfs co mpleted p revented co mpleted p revented co mpleted p revented co mpleted p revented ast ccsm3 ccsm4 cesm cfs cm cmcc com ele g lp mag model nwc rim sol wrf www yod total not all function calls could be refactored.
for example w hencsdtis applied to a function that has an unsigned integer parameter the type is not cast to a signed integer to be safe .
the refactoring does not make any changes to the program this is the correct behavior.
table shows that when csdtwas applied to g it allowed the refactoring to continue for cases and prevented case unsigned parameter .
again when we applied tsion the same instances it prevented the refactoring in case because of the problem mentioned above.
finally we applied cfsto our standardized interface and it prevented the refactoring for instances.
this is because those functions had one or zero parameters the parameters could not be swapped.
we expected a few other cases where refactoring was prevented.
we did not support interoperability with macros e.g.
f77 func attempts to refactor those procedures were blocked.
another common reason for blocking a refactoring was the presence of functions on the c side that would be identically named if not for the underscore such as foo and foo.
updating the former would create a naming conflict and as such were avoided.
note that preventing these refactorings during the precondition step is the correct behavior.
more details about the project are available online at .
threats to v alidity themainconcernabouttheempiricaldatainthispaperis whether the corpus is representative of interoperable c and fortran programs at large.
the authors of this paper have years of experience of working with fortran programmers and provide refactoring tool support for them.
many applications in the corpus were derived from the corpus used to test the photran infrastructure an eclipse project that supports fortran specific refactorings.
additionally the programs represented different application domains and were written and or evolved over a period of time so that they were exposed to several interoperability standards .
.
most importantly our intention was not to present the empirical data to reflect the general state of c and for tran interoperability but to use the data as a case study to motivate the need for a refactoring based solution and to guide the design decisions of these refactorings.
.
future work and conclusion the area of cross language analysis and refactoring has significant potential for future work.
most vendors for fortran compilers also produce c compilers type checking fortran procedure calls against declarations in c headers is feasible at least in theory.
lint tools could identify problematic uses of data passed from another language e.g.
c code iterating through a fortran array in row major order .
checking and inferring restrict qualifiers for function parameters e.g.
is more complex in a multi language setting.
pushing the idea of cross language refactoring to its limits one could pursue cross language function extraction and inlining recognizing of course that this could only be successful in limited scenarios .
the world is increasingly moving toward polyglot programming and tools that support polyglot programs are inevitable.
in this paper we considered c fortran interoperability as a case study and presented empirical data exploring applications totaling more than million lines of code.
our results show that most of the programs still use legacy compiler dependent techniques to achieve interoperability.
while interoperability was incorporated into the fortran standard it may have come too late many programs never adapted to the new standard.
automated refactoring tools could prove to be a solution to this problem we prototyped three cross language refactorings demonstrating that automated refactoring may be a viable means to help programmers eliminate the use of legacy interoperability mechanisms from their code in the future.
.