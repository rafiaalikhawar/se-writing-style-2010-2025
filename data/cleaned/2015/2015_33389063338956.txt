binaryreduction ofdependency graphs christiangram kalhauge kalhauge cs.ucla.edu computersciencedepartment universityof california losangeles ucla losangeles ca usajens palsberg palsberg ucla.edu computersciencedepartment universityof california losangeles ucla losangeles ca usa abstract deltadebuggingis atechniqueforreducingafailure inducinginputtoasmallinputthatrevealsthecauseofthefailure.thishas been successful for a wide variety of inputs including c programs xml data and thread schedules.
however for input that has many internaldependencies deltadebuggingscalespoorly.suchinput includes c java and java bytecode and they have presented a major challenge for input reduction until now.
in this paper we showthatthecorechallengeisareductionproblemfordependency graphs andwepresentageneralstrategyforreducingsuchgraphs.
wecombinethiswithanovelalgorithmforreductioncalledbinary reductioninatoolcalledj reduceforjavabytecode.ourexperimentsshowthatourtoolis12xfasterandachievesmorereduction than delta debugging on average.
this enabled us to create and submitshort bugreports for three java bytecode decompilers.
ccs concepts software and its engineering software testing and debugging.
keywords debugging dependencies reduction acmreference format christian gram kalhauge and jens palsberg.
.
binary reduction of dependency graphs.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august 26 30 tallinn estonia.
acm new york ny usa 11pages.
introduction delta debugging automates a process that programmers otherwise do by hand.
whena program crasheson aninput the programmer tries to understand the cause of the crash by reducing the input.
intuitively the programmer can cut the input in half and see if one ofthetwohalvescausesthecrashaswell.aftersomerepetitions of this step the input may be small enough for the programmer to spotthecauseoftheproblem.deltadebuggingexecutesamoreadvancedversionofthis automatically.forexample deltadebugging permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse august 26 30 tallinn estonia copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
map the original input to a nonconsecutive subsequence.
thus deltadebuggingrelievesprogrammersfromthetediumofreducing andexecuting andletsthemfocusonimprovingtheir programs.
in their seminal paper on delta debugging zeller and hildebrandt showed successful experiments in which the inputs werecprograms mozillauseractions andunixcommands.other papershavereportedonexperimentswithxmldata thread schedules andeventsequences .theproblemofreducing failure inducinginputtoaminimalsizeisnp complete and foraninputwith ncharacters tryingall2nsubstringsmaybefutile.
instead the delta debugging algorithm ddmin trieso n2 substrings.
this led to massive success but when most natural subsets of the input are invalid most iterations of ddmin fail and are of no help towards reduction.
as a step towards scalability zeller andhildebrandtshowedhowddmindoesbetterwhenappliedto a list oflines.
this is better than a character oriented approach because often a line of code represents a syntactic element such as a statement.
misherghi and su went further and introduced hierarchical delta debugging hdd that works with the syntactic structure of the data.
for example for reduction of a method body hdd represents the body as a list of statements and runs ddmin onthelist.thisisbetterthanaline orientedapproachbecausea statementcanspanmultiplelines.useofthesyntacticstructureensuresthateachinputissyntacticallyvalidandincreasesthechance that eachrun produces useful information.
inthispaperweconsiderthenextlevelofdifficulty whicharises when elements of the syntactic structure have many internal dependencies .
such input includes c java and java bytecode where a class may depend on other classes and where compilation and bytecodeverificationrequirealldependenciestobepresent.wecan represent such a program as a list of classes and run ddmin on the list yetmostrunswillfailbecausetheinputisinvalid.wesolvethis bymodelingtheinternaldependenciesintheinputasa dependency graphand then running reduction on a list of transitive closures in thedependencygraph.wewillshowexperimentswithreduction byboth ddminandanovel algorithm calledbinary reduction.
intheremainderofthepaper section 2introducesthechallenge indetail after whichsections 3 6present our contributions we show that dependency graphs are a convenient data structure for reduction particularlybyddmin section .
we present a new reduction algorithm called binary reductionthat runsonly o nlogn iterations section .
we evaluate on java bytecode programs that induce failures in three decompilers.
binary reduction on graphs is 12xfasterandreduces more thanddmin section .
we submittedbugreports for the decompilers section .
finally section 7discussesrelatedwork andsection 8concludes.
esec fse august tallinn estonia christian gramkalhauge andjens palsberg the challenge we will explain the challenge of reducing input with dependencies viaanexample.theexampleconcernsthejavabytecodedecompiler calledcfr .cfrtakesas inputa valid java bytecode program and decompiles it to a java source program.
thisis useful for programmers who want toinspect and reasonaboutlibrariesthathavebeenshippedasbytecode.ideally a decompiler produces source code that can be compiled to bytecode such that the input bytecode and output bytecode are behaviorally equivalent.
when we look for bugs we will use a more modest quality measure a decompiler should produce source code that compiles.ifcfrmapsavalidbytecodeprogramtoasourceprogram that doesn tcompile we say that cfr fails.
wedefineavalidbytecodeprogramasasetofclass filesthateach individually verifies and depends only on classes in the program itself or in the standard library.
a class adepends on another class bifamentions banywhere in its bytecode.
this can happen in many places such as in an extends clause in a type annotation in anew expression orinatype cast.
our example begins with the discovery of a bug in cfr.
we ran cfr on a valid java bytecode program with classes and then we ranjavaconthe producedsourceprogram which ledtothis error messagefrom javac ... error illegal start of expression if var2 3.hasnext break now we would like to send a bug report to cfr but it can be hard tolocatethebugin17classes.
inthispaperwe focuson reducing thebytecodeprogramtoonewith asubsetoftheclassesthatstill induces cfr to fail with the same bug report.
thus the reducer picksclasseswithout changing them.
the task of reducing a set of classes to a smaller set of classes isofthekindforwhichdeltadebuggingusuallyexcels.weimplementedthedeltadebuggingalgorithmcalled ddminbyzellerand hildebrandt such that it works on a list of classes.
however theresultofreducingourjavabytecodeprogramwith17classes wasdisappointing the result wasaprogram with14 classes.
figure1illustrates our run of ddmin.
the boxes and s show whichclasseswereinputtoaniterationof ddmin whilethecolumn labeledfailshowswhethercfrfailed markedwith yes succeeded marked with no or whether the bytecode program was invalid marked with ?
.
in most cases the input bytecode program is invalidsotohighlightthefewstepswithvalidinputs weuseboxes inthosesteps.specifically whencfrreproducesthebugweuse andinallothercaseswithvalid inputswe use .
the many iterations with invalid bytecode programs inputs are of no help towards reduction.
additionally each invocation of cfr andjavaccan take between a couple of seconds and multiple minutes whichdecreasesscalability.
regehr et al.
identified this kind of problem in and called it the test case validity problem .
they also identified two kindsofsolutions namely detectinvalidinputsor avoid invalidinputs.
inthecontextofc regehretal.
usedtwotoolsto detectinvalid code whichledtoanexcellentreducer.however theyleft avoiding invalidcode as an open problem.
fail ?
?
?
?
?
?
?
?
?
yes ?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
no ?
?
?
?
?
?
no ?
?
?
?
?
?
?
yes ?
?
?
?
?
?
no ?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
figure a detailed run of the example using unmodified deltadebugging ddmin .therowsaretheiterationsof ddmin.
the columns identifies classes represented using a number in the input of each iteration if a class is included it ismarked with or .
557binary reductionof dependency graphs esec fse august tallinn estonia figure the dependency graph of our example program.
thenodesareclassesintheprogramandtheedgesrepresent