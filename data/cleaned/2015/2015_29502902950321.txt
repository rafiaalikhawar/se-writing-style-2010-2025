code relatives detecting similarly behaving software fang hsiang su jonathan bell kenneth harvey simha sethumadhavan gail kaiser and tony jebara columbia university west 120th st mc new y ork ny usa mikefhsu jbell cs.columbia.edu kh2333 caa.columbia.edu simha kaiser jebara cs.columbia.edu abstract detecting similar code is useful for many software engineering tasks.
current tools can help detect code with statically similar syntactic and or semantic features code clones and with dynamically similar functional input output simions .
unfortunately some code fragments that behave similarly at the ner granularity of their execution traces may be ignored.
in this paper we propose the term code relatives to refer to code with similar execution behavior.
we de ne code relatives and then present dyclink our approach to detecting code relatives within and across codebases.
dyclink records instruction level traces from sample executions organizes the traces into instruction level dynamic dependence graphs and employs our specialized subgraph matching algorithm to e ciently compare the executions of candidate code relatives.
in our experiments dyclink analyzed million prospective subgraph matches in only 43minutes.
we compared dyclink to one static code clone detector from the community and to our implementation of a dynamic simion detector.
the results show that dyclink e ectively detects code relatives with a reasonable analysis time.
ccs concepts software and its engineering !software maintenance tools assembly languages information systems !nearest neighbor search keywords code relatives runtime behavior link analysis subgraph matching code clones .
introduction code clones which represent textually structurally or syntactically similar code fragments have been widely adopted to detect similar pieces of software.
however code clone detection systems typically focus on identifying staticpatterns in code so relevant code fragments that behave similarly at runtime though with di erent structures are ignored.
detecting code fragments that accomplish the same tasks or share similar behavior is pivotal for understanding and improving the performance of software systems.
for example with such functionality it may be possible to automatically replace an old algorithm in a legacy system with a new one or to detect commonly repeated tasks to create apis semi automatically.
it may allow quick search and understanding of large codebases and de obfuscation of code.
towards detecting similarly behaving code previous work observed code fragments that yield the same output for the same input or that share similar identi ers and structural concepts .
a signi cant challenge in detecting similar but not equivalent code fragments by comparing input and output pairs a technique also known as nding simions is judging how similar two outputs need to be for the two code fragments to be considered simions.
particularly with object oriented languages this problem may be more complex the same data can be designed with di erent project speci c data types between projects .
our key insight is to shift this similarity comparison to study how each code fragment computes its result rather than simply comparing those output results or comparing what that code looks like.
that is we can gauge how similar two code fragments are without even looking at the respective inputs and outputs.
to represent runtime similarity i.e.
how the code fragment computes its result we introduce the term code relatives .
code relatives are continuous or discontinuous code fragments that exhibit similar behavior but may be expressed in structurally or even conceptually di erent ways.
the key relationship between these code fragments is that they are performing a similar computation regardless of how similar or dissimilar their outputs may be.
our key contribution is an e cient system for detecting these code relatives that is agnostic to the output format or identi ers used in the code.
our system dyclink traces each program s execution creating a dynamic dependency graph that captures behavior at the instruction level.
these dependency graphs encode rich and dense behavioral information more than would be found simply observing the outputs of parts of a program or obtained from a static analysis of that program.
code relatives are isomorphic sub graphs via fuzzy matching that occur repeatedly between and within these pro led execution graphs.
dyclink detects code relatives at any granularity a code relative may be a part of a single method or instead be composed of several methods that are executed in a sequence.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
artifact evaluated by fse the resulting graphs are large containing a single node for every instruction plus edges representing dependencies.
hence typical approaches for detecting isomorphic sub graphs are time prohibitive requiring expensive comparisons between each potential set of code relatives.
in our evaluation we examined projects for code relatives containing a total of 244di erent dynamic dependence graphs which represented a total of over million subgraphs that would be compared for similarity.
to e ciently identify code relatives in these graphs we have developed a new algorithm linksub that leverages the pagerank algorithm to compare subgraphs and to reduce the number of pairwise comparisons needed between subgraphs to e ciently detect code relatives in our evaluation ltering away over of the comparisons .
we built dyclink targeting java programs but our methodology applies to most high level languages.
we evaluated dyclink on a corpus of java programs that were known to contain clusters of similar programs.
dyclink e ectively reconstructed the clusters of programs with very high precision .
we compared dyclink with one state of the art static clone detector plus one dynamic simion detector input output similarity checker nding it to be more e ective at clustering similarly behaving software.
.
background before discussing the details of dyclink we rst de ne the key terms used in this paper and discuss some use cases of code relatives.
.
basic definitions when discussing the notion of similar code it is important to have a clear de nition of what similar means.
for our purpose two code fragments are similar if they produce similar instruction level runtime behavior which is witnessed by execution traces dynamic dependency graphs that are roughly equivalent.
code fragment either a continuous or discontinuous set of code lines.
code clone a code fragment cf2is a clone of another code fragment cf1if they are similar by some given de nition of similarity .
we express this as follows.cf1andcf2are code clones if fsim cf1 cf stat wherefsimis a similarity function and statis a prede ned threshold for static code fragments.
code relative an execution of a code fragment generates a trace of that execution exec cf .
we denote the set of a code fragment s traces as fexec cf g. given a similarity function fsimand a threshold dyn for code execution two code fragments cf1andcf2 are code relatives if fsim fexec cs1 g fexec cs2 g dyn in this work we capture execution traces as dynamic program dependency graphs and we model the similarity between two code fragments as a subgraph isomorphism problem described further in x4.
code relatives are distinct from simions in that simions are code fragments that show similar outputs given an input while code relatives show similar behavior regardlessof their outputs .
moreover code relatives may consider discontinuous code fragments and include cases in which their intermediate results but not outputs are similar.
code relatives are not tied to a particular programming abstraction a code relative may be a portion of a method or may represent computation that is performed across several methods.
all code relatives are behavioral code clones given that the de nition of similarity is limitless for clones in general.
we use the term code relative rather than a variant of code clone or simion to make their distinctions clear and avoid ambiguity.
.
motivation detecting similar programs is bene cial in supporting several software engineering tasks such as helping developers understand and maintain systems identifying code plagiarism and enabling api replacement .
although code clone detection systems can e ciently detect structurally similar code fragments they may still miss some cases for optimizing software and or hardware that require information about runtime behavior .
programs that have syntactically similar code fragments usually have similar behavior however programs can still have similar behavior even if their code is not alike .
moreover programs may have similar behavior even if their outputs for the same or equivalent inputs are not identical.
in fact in many cases it may be di cult to judge that two outputs are equivalent or even similar due to di erences in data structures.
on detecting functionally equivalent code fragments in java deissenboeck et al.
reported that of the studied program chunks across ve open source projects referred to project speci c data types .
hence it is impossible to directly compare inputs and outputs for equivalence across many projects.
to get around these dissimilar data types developers would have to specify adapters to convert from project speci c datatypes to abstract representations that could be compared.
by ignoring the outputs of code fragments and observing only their behavior we can avoid this output equivalence problem.
consider for example the two code examples shown in figure taken from the libraries apache commons math1 and jama2 both of which perform the same matrix decomposition task.
in the case of figure 1a all computation is done in a single method and the result is stored as instance elds of the object being constructed.
in the case of figure 1b computation is split between several methods solve which invokes several methods to compute the result which is returned as a matrix object a type de ned by the library .
a simion detector comparing inputs and outputs would have di culty to compare the inputs and outputs when the data structures do not match exactly and there may not be clearly de ned outputs.
a typical clone detector using the abstract syntax tree of this code would also nd it hard to detect the multi method clone.
it would need to compute callgraph information to consider valid multi method clones which again have many subtle di erences in code structure.
in fact clone detection tools may not consider these two code listings to be clones while we argue that they are code relatives and are indeed detected by dyclink .
software clustering and code search are two domains that rely on similarity detection between programs and could bene t from code relatives.
software clustering locates and aggre1 public singularvaluedecomposition final realmatrix matrix .... generate u.
.... for int k nct k k if singularvalues !
for int j k j n j double t for int i k i m i t u u t t u for int i k i m i u t u ... generate v. for int k n k k if k nrt e !
for int j k j n j double t for int i k i n i t v v t t v for int i k i n i v t v ... a commons maths s singularvaluedecomposition.
init public matrix solve matrix b return m n ?
new ludecomposition this .
solve b new qrdecomposition this .
solve b public qrdecomposition matrix a ... for int k k n k ... if nrm !
.
... for int j k j n j double s .
for int i k i m i s qr qr s s qr for int i k i m i qr s qr rdiag nrm public matrix solve matrix b ... for int k k n k for int j j nx j double s .
for int i k i m i s qr x s s qr for int i k i m i x s qr ... b jama s matrix.solve figure a partial comparison of matrix decomposition code from two di erent libraries.
despite di erences in each method both are code relatives.
gates programs having similar code or behavior.
the clusters support developers understanding code semantics prototyping rapidly and locating bugs .
code search helps developers determine if their codebases contain programs be tting their requirements .
a code search system takes program speci cations as the input and returns a list of programs ranked by their relevance to the speci cation.
software clustering and code search can be based on static or dynamic analysis.
static analysis relies on features such as usage of apis to approximate the behavior of a program.
dynamic analysis identi es traits of executions such as input output values and sequences of method calls to represent therealbehavior.
a system that captures more details and represents program behavior more e ectively e.g.
instead of simions can more precisely detect similar programs in support of both software clustering and code search.
based on the use cases above instead of identifying static code clones or dynamic simions we designed dyclink a system to detect dynamic code relatives which represent similar runtime behavior between programs.
we have evaluated dyclink nding it to have high precision when applied to software clustering results discussed in x5.
.
related work code similarity detection tools can be distinguished by the similarity metrics that they use exact or fuzzy matching and the intermediate representation used for comparison.
common intermediate representations tend to be token based ast based or graph based .
deckard detects similar but perhaps structurally di erent code fragments by comparing asts.
sourcerercc compares code fragments using a static bag of tokens approach that is fast but does not target speci cally similarly behaving code with di erent structures.
among static approaches dyclink is most similar to those that used program dependence graphs pdgs to detect clones.
komondoor and horwitz generate pdgs for c programs and then apply program slicing techniques to detect isomorphic subgraphs.
the approach designed by krinke starts to detect isomorphic subgraphs with maximum size kafter generating pdgs.
the granularity of krinke s pdgs is ner than the traditional one each vertex roughly maps to a node in an ast.
the approach proposed by gabel et al.
is a combination of ast and graph.
it generates the pdg of a method maps that pdg back to an ast and then uses deckard to detect clones.
gplag determines when to invoke the subgraph matching algorithm between two pdgs using two statistical lters.
compared with these graph based approaches that identify static code clones dyclink detects the similar dynamic behavior of programs code relatives .
this allows dyclink 704application codeinstruction instrumentergraph constructorlink analysisprogram executioninput workloadpairwise comparisoncode relativesgraph construction online subgraph matching offline figure the high level architecture of dyclink including instruction instrumentation graph construction link analysis and nal pairwise subgraph comparison.
to detect code relatives that are dependent upon dynamic behavior for example splitting across multiple methods.
other previous works in dynamic code similarity detection focus on observing when code fragments produce the same outputs for the same inputs.
jiang and su drive programs with randomly generated input and then observe their output values identifying clones as two methods that provide the same output for the same input.
li et al.
detect functional similarity between code fragments using dynamic symbolic execution to generate inputs .
similarly the mecc system detects code similarity by observing two methods that result in the same abstract memory state.
cccd or concolic clone detection takes a similar approach comparing the concolic outputs of methods to detect functionlevel input output similarity.
elva and leavens propose detecting functionally equivalent code by detecting methods with exactly the same outputs inputs and side e ects .
juergens et al.
propose simions two methods that are found to yield similar outputs for the same input but provide no automated technique for detecting such simions .
we implement a simion detector for java hitoshiio which attempts to overcome the problem of di erent data structures through a fuzzy equivalence matching.
hitoshiio compares the input output of functions while observing their executions in vivo.
code relatives di er from all of these dynamic code similarity detection systems in that similarity is compared between the computations performed notbetween the resulting outputs.
this important distinction allows for similarly behaving code to be detected even when di erent data structures and output formats are used.
moreover it allows for arbitrary code fragments to be detected as code relatives techniques that compare output equivalence tend to work best at a perfunction granularity because that format provides a clear de nition of inputs and outputs.
in addition to work on ne granularity clones much work has been done in the general eld of detecting similarly behaving software.
marcus and maletic propose the notion ofhigh level concept clones detecting code that addressed the same general problem but may have signi cant structural di erences by using information retrieval techniques on code .
similarly bauer et al.
mine the use of identiers to detect similar code .
in addition to code several approaches analyze software artifacts such as class diagrams and design documents.
this type of analysis helps developers understand similarities di erences between software at system level .
software birthmarking uses some representative components of a program s execution to create an obfuscationresilient ngerprint to identify theft and reuse .
coderelatives are comparable to birthmarks in that both capture information about how a result is calculated.
however code relatives are computed using more information than lightweight birthmarks focusing on the use of apis .
.
detecting code relatives with link analysis the high level procedure of dyclink is shown in figure .
to begin the program s to be analyzed are instrumented to allow dyclink to trace their respective executions.
next the program s are executed given some sample inputs or workloads representative of their typical use cases and dyclink creates graphs to represent executions of each program where each instruction is represented by a vertex and each data and control dependency is represented by an edge.
then dyclink analyzes these graphs o ine to detect code relatives.
dyclink traces program execution so its results will be dependent upon the inputs given to the program some methods may not be executed at all while others may only be executed along some speci c paths.
one upside to this approach is that it exposes common behavior allowing code that handles boundary input cases and hence may not be typically executed to be ignored for the purposes of code relative detection.
however it still requires that the inputs to the program are representative of actual and typical workloads.
we will discuss this design decision further inx4.
.
dyclink consists of two major components online graph construction and o ine sub graph matching.
the graph constructor instruments and observes the execution of the code being evaluated to generate these dynamic dependency graphs x4.
while the subgraph matcher analyzes the collected graphs to detect code relatives x4.
.
we calculate the similarity of the two dynamic dependency graphs by rst linkanalyzing their important instructions centroids linearizing them into vectors and then calculating the jaro winkler distance between them.
this process will be described in detail in the following sections.
we have selected java as our target language so the instructions recorded by dyclink are java bytecodes.
dyclink makes extensive use of the asm bytecode instrumentation library requiring no modi cations to the jvm to nd code relatives even without source code present.
to implement the graph matcher for other target languages we could similarly use runtime binary instrumentation to capture execution graphs an approach examined by demme et al.
.
the subgraph matching mechanism which occurs o ine after program execution is language agnostic.
.
constructing graphs to construct dependency graphs dyclink follows the jvm s stack machine to derive the dependencies between instructions recording data and control dependencies.
each execution of each method results in the generation of a new dynamic instruction dependency graph gdig where each vertex represents an instruction and each edge represents an observed dependency.
these graphs contain all instructions executed both by that method and by the methods that method calls.
each edge in the graph is labeled with a weight representing the frequency of its occurrence.
we consider three types of dependencies for our graphs dep inst a data dependency between an instruction and one of its operands.
dep write a read after write dependency on a variable.
dep control a weighted edge indicating that some instructions are controlled by another e.g.
through a jump corresponding to the frequency that control will follow that edge based on the observed executions.
while it is possible to set a di erent weight for each type of dependency we currently weight each equally.
when one method calls another dyclink stores a pointer from the calling method to its callee allowing for code relatives to be detected that span method boundaries.
this way when a target method is examined for code relatives dyclink actually considers both the trace of that method and the traces of all methods that it calls .
dyclink uses two strategies to reduce the total number of graphs recorded.
first dyclink stores these graphs in a attened form when a method calls another many times e.g.
in a loop dyclink identi es that redundancy by using the number of vertices and edges as a hash value and simply updates execution counts for each edge in the graph.
second dyclink imposes a con gurable quota on the number of times qcall that a given method will be captured at a given call site which will be discussed in x5.
.
example to showcase how dyclink constructs a dependency graph consider the mult method in figure .
figure 3a shows the java source for this method that multiplies two numbers while figures 3c and 3b show the java compiler s translation of this source code into bytecode.
consider tracing an execution of this code using fa b 1gas input arguments.
figure 3d shows the graph that may be constructed from such an execution.
the label of each numbered vertex is the index of a bytecode in figure 3c bytecodes in theaddmethod figure 3b are labeled as a2 a3 and a4 each edge is labeled with a counter indicating the number of times it occurred during the run.
every time that mult is executed during pro ling a new gdigwill be generated.
to see how the edges are constructed consider the iload 2instruction on line iload x loads a local variable x onto the jvm s stack .
when this instruction is executed the controlling instruction is if icmplt at line so the dependency dep control is constructed.
any additional dependencies are captured transitively in the graph.
because iload is reading the ndlocal variable dyclink detects the last instruction executed that wrote it which is istore at line creating the dependency dep write .
invokestatic on line 9has twodep instfrom iload and iload because these instructions are used to invoke the addmethod.
when addis called its graph is stored sepa static int mult int a int b int ret for int i i b i ret add ret a return ret static int add int a int b return a b a the mult method.
static add ii i iload iload iadd ireturn b the add instructions.
static mult ii i iconst 0 istore iconst 0 istore goto iload iload invokestatic add istore iinc iload iload if icmplt iload ireturn c the mult instructions.
a4 16dep inst dep write dep control a2 a31 d the mult graph.
figure the mult method in java a translated into bytecode b and a dynamic instruction dependency graph c generated by running mult .
rately with pointers from the mult graph into it vertices a2 a3 and a4 .
by including this callee graph add in its caller graph mult we can detect code relatives that span multiple methods.
once the programs are executed with sample inputs gdigs are then constructed to represent each method execution.
we can proceed to the next phase subgraph matching.
.
linksub link analysis based subgraph isomorphism algorithm to detect code relatives dyclink rst enumerates every pair ofgdigs that were constructed given n g digs there are at most n n subpairs to compare where sub represents the number of potential subgraphs.
note that because each execution of each method will generate a new gdig each method will have multiple graphs that represent its executions meaning that there are more gdigs than methods.
each recorded execution of each method is potentially compared to each of the executions of each other method.
the executions are represented as graphs so we model code relative detection as a subgraph isomorphism problem.
there are two types of subgraph isomorphism or subgraph matching exact and inexact .
for exact subgraph matching a test graph needs to to be entirely the same as a sub graph of a target graph.
exact subgraph matching would only nd cases where all instructions and their dependencies are exact copies between two code fragments this would be too restrictive to detect code relatives.
because dyclink detects similar butnot necessarily identical subgraphs we are focused on techniques for inexact subgraph matching.
706the key to e ciently performing this matching is to lter out pairs of graphs that can never match reducing the number of comparisons needed to a much smaller set.
for example for each graph we calculate its centroid create a simpler representation of each subgraph simply a sequence of instructions and then identify candidate graphs to compare it to ltered to only those that contain that same instruction.
next we perform a constant time comparison between each potentially matching subgraph calculating the euclidean distance between their instruction distributions to eliminate unlikely matches.
for the remaining subgraphs we apply a link analysis to each subgraph to create a vectorized representation of its instructions ordered by pagerank.
from these ordered vectors we apply an edit distance based model to calculate similarity.
hence we reduce the running time in two ways we consider only potential subgraph matches that seem likely based on some lters and then we calculate the actual similarity of those subgraphs.
the overall algorithm is shown at a high level in algorithm .
the summary of each subroutine of linksub is as follows pro legraph computes statistical information of a gdig such as ranking of each instruction and instruction distribution to identify its centroid.
sequence sort instructions of gdigby the feature de ned by the developer to facilitate locating instruction segments.
we use the execution order of each instruction to sort a gdig.
locatecandidates given the centroid of a gte dig locate each instance of that centroid instruction in each potential target graph gta dig.
eucliddist compute the euclidean distance between the instruction distributions of two gdigss.
linkanalysis apply pagerank to a graph returning a rank ordered vector of instructions.
calcsimilarity calculate the similarity of two pagerank ordered instruction vector using edit distance.
linksub models a dynamic instruction dependency graph of a method as a network and uses link analysis specifically pagerank to rank each vertex in the network.
the rst phase of the algorithm profilegraph ranks each vertex in the graph being examined calculating the highest ranked vertex centroid of the graph.
this step also calculates instruction distribution for subgraph matching.
the next phase lists all instructions of the target graph gta dig by execution order in the sequence step to facilitate locating candidate subgraphs.
in the next step locatecandidates we select all subgraphs in the target graph that match the centroid of gte dig.
if a subgraph in gta digcontains the centroid instruction of gte digthen it is potentially a code relative but if it does not contain the centroid instruction then it can t be.
this is e ectively the rst lter that reduces the largest set of potential subgraphs to compare.
for each of the potential candidate subgraphs we next apply a simple lter eucliddist similar to which computes the euclidean distance between the distributions of instructions in the graph of gte digand a candidate subgraph from thegta dig.
if the distance is higher than the threshold dist de ned by the user then this pair of subgraph matching is rejected.
we empirically came to a threshold of the lower the better to include only those subgraphs that were mostly similar.if a candidate subgraph from the gta digpasses the euclidean distance lter dyclink applies its link analysis to this candidate.
dyclink calculates a pagerank dynamic vector dv for the candidate subgraph linkanalysis where the result is a sorted vector of all of the instructions vertices from the subgraph ordered by pagerank.
data the target graph gta digand the test graph gte dig result a list of subgraphs in gta dig coderelatives which are similar to gte dig compute statistical information profile te pro legraph gte dig change representation seqta sequence gta dig filter to nd possible matches assigned ta locatecandidates seqta profile te coderelatives forsubinassigned tado perform multi phase comparison sd eucliddist sv sub profile te sv ifsd distthen continue end dvsub target linkanalysis sub dynsim calcsimilarity dvsub target profile te dv ifdynsim dynthen coderelatives sub end end returncoderelatives algorithm linksub.
finally in calcsimilarity we use the jaro winkler distance to measure the similarity of two dvs which represents the similarity between two gdigs.
jaro winkler has better tolerance of element swapping in the instruction vector than conventional edit distance and is con gurable to boost similarity if the rst few elements in the vectors are the same.
these two features are bene cial for dyclink because the length ofdv gdig is usually long and thus may involve frequent instruction swapping.
for representing the behavior of methods we use the pagerank sorted instructions from dv gdig .
if the similarity between the pagerank vectors from the subgraph of the gta digand thegte digis higher than the dynamic threshold dyn dyclink identi es this subgraph as being inexactly isomorphic to gte dig.
we empirically evaluated several values of this threshold settling on 82as a default inx5.
we refer to the subgraph similar to the gte dig as a code relative in thegta dig.
the runtime execution cost of our algorithm will vary greatly with the number of subgraphs that remain after the two ltering stages.
while each ltering stage itself is relatively cheap the pagerank computation requires only o v e for a graph with vnodes andeedges in the worst case where we would need to calculate the jaro winkler similarity of every possible pair of sub graphs the overall running time would be dominated by these computations for sub graphs.
in practice however we have found that these two ltering phases tend to dramatically reduce the overall number of comparisons needed making the running time of linksub quite reasonable requiring only minutes on a commodity server to detect candidate code relatives 707in a codebase with over 000lines of code.
pro ling this code base resulted in 244gdigs requiring a total worstcase millions of subgraph comparisons.
a complete evaluation and discussion of the scalability of our algorithm and system are in x5.
.
.
limitations there are several key limitations inherent to our approach that may result in incorrect detection of code relatives.
the main limitation stems from the fact that dyclink captures dynamic traces the observed inputs must exercise su ciently diverse input cases that are representative of true application behavior.
a second limitation comes from our design decision to declare that two code fragments are relatives if there is at least a single input pair that demonstrates the two fragments to be similar.
an ideal approach would require pro ling the application over large workloads representative of typical usage.
if we could guarantee that the inputs observed were truly su ciently diverse to represent typical application behavior then it may be reasonable to consider the relative portion of inputs that result in a match compared to those that do not.
however with no guarantee that the inputs that dyclink observes are truly representative of the same input distribution observed in practice in a given environment we decide for now to instead ignore counter examples to two fragments being relatives declaring them relatives if at least one pair of inputs provide similar behavior.
consider the following example of a situation where these choices may result in undesirable behavior.
the rst method will sort an array if the passed array is non null returning if the parameter is null.
the second method will read a le if the passed le is non null returning if the parameter is null.
if dyclink observes executions of each method with a null parameter then these two methods will be deemed code relatives because there is at least one input pair that causes them to exhibit similar behavior.
a future version of dyclink could instead consider all of the inputs received and the coverage of each of those inputs towards being representative of overall behavior.
dyclink can also fail to detect code that is similar in terms of its input and output if it has di erent instructionlevel behavior.
for example a method can multiply two integers fa bg in a convoluted way as figure depicts or it can simply return a b. by our de nitions these are not code relatives and wouldn t be detected by dyclink .
due to nondeterminism in a running program dyclink may record di erent execution graphs causing results to vary slightly between multiple pro ling runs.
in multi threaded applications dyclink currently only considers code fragments that execute within the same thread as code relatives there is no merging of graphs across threads.
.
ev aluation we evaluate dyclink in terms of both runtime performance and precision.
we answer two research questions rq1 given the potentially immense number of subgraph comparisons is dyclink s performance feasible to scale to large applications?
rq2 are the code relatives detected by dyclink more precise for classifying programs than are the similar code fragments found by previous techniques?
unfortunately we are limited in our choice of experimental subjects and comparison approaches by what is publiclytable a summary of the code subjects from the google code jam for classifying software.
proj graph size year problem tot.
aut.
meth.
vavgvmaxeavg irregular cake perfect game cheaters magical tour available.
for example while there are publicly available benchmarks of code clones with a ground truth manually provided we found many of them did not include su cient dependencies and build scripts to be compiled and executed dynamically.
to focus our evaluation on projects that were build able and distributed with inputs test cases we selected projects from the google code jam repository .
google code jam is an annual online coding competition hosted by google.
participants submit their projects source code online and google determines whether they correctly solve a given problem.
because each submission for the same problem attempts to perform the same task we assume that each project within the same year will likely share code relatives while projects between di erent years solving di erent requirements will likely not share code relatives or at least fewer.
to compare dyclink s code relative detection with static code clone detection we selected the state of the art clone detector available sourcerercc .
while sourcerercc is highly performant scaling impressively to big code we admittedly do not expect to nd many near miss static code clones in independently written code jam entries.
in contrast we would expect to nd clusters of dynamic functional i o simions since the independently written entries intend to complete the same tasks.
previous simion detectors for object oriented languages do not address project speci c object data types due to the technical challenges reported by deissenboeck et al.
.
therefore we developed a simion detector that we have recently built for java hitoshiio speci cally designed to overcome these challenges and enable fair comparison of the similarity models.
the information on the evaluation subjects is shown in table .
for each competition year we show the problem name the number of projects in the repository the number of automatic projects without human interactions used in this study the total number of executed methods in those projects and the statistics for the captured gdigs including the number of graphs and the numbers of vertices and edges.
for the executed methods we provide two numbers retained all .
to avoid potentially in ating our results by including matches of trivial methods we lter out simple methods with little work in them such as tostring and initialization methods .
allrepresents the number of all executed methods while retained shows the method number after such ltering.
we discuss some parameter settings of dyclink for conducting the experiments in this paper.
for constructing gdigs inx4.
we empirically set the quota at a given call site qcallas5.
this allows for reasonable performance both in terms of code relative detection and runtime overhead.
for conducting the inexact sub graph matching we set distas and dynas .
in algorithm where both parameters range from 0to1.
the details of each parameter setting 708table number of comparisons performed by dyclink on the google code jam projects showing worst case number of comparisons without any ltering and actual comparisons performed along with the relative reduction in comparisons achieved by dyclink.
we also show the total analysis time needed to complete each set of comparisons.
years comparedsubgraphs compared analysis time sec worst case actual reduction dyclink hitoshiio sourcerercc .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
can be found in the github page of dyclink .
while searching for the best parameter setting for dyclink is out of the scope of this paper we plan to utilize machine learning techniques for optimizing dyclink in future.
.
rq1 scalability to evaluate the scalability of dyclink we measured its performance when running on these projects.
the key to dyclink s performance is the relative reduction in subgraph comparisons that result from ltering and link analysis steps.
if we can greatly reduce the number of candidate subgraphs to be compared then dyclink will scale even on large graphs.
table shows the worst case number of pairwise comparisons that would be needed by a naive subgraph matching algorithm along with the number of comparisons that were actually necessary to detect the code relatives.
we also show the analysis time for each of dyclink hitoshiio and sourcerercc .
dyclink ltered out over of the potential subgraphs to compare resulting in a total analysis time of just minutes on an amazon ec2 c4.8xlarge instance.
while this analysis time is signi cantly longer than the static approach and still more than the simion detector we believe that the analysis runtime is acceptable given the time complexity to solve the inexact sub graph matching problem.
because dyclink is a dynamic pro ling approach there is also a time overhead for collecting the traces and generating the graphs.
our execution tracer implementation is unoptimized and records every single instruction.
an optimized version might instead be able to infer and record instructions that expose program behaviors.
to trace these applications took a total time of just over .
hours compared to a baseline execution time without instrumentation of approximately minute on an imac with cores and gb memory however the instrumentation overhead can vary signi cantly with the complexity of the program one single subject took minutes to execute while the remaining required only a total of minutes to execute.
we are con dent that the tracing overhead can be signi cantly reduced with some optimizations as demonstrated by other java tracing systems such as javaslicer .table code relatives simions and code clones detected by project year and by tool for dyclink hitoshiio and sourcerercc.
years dyclink hitoshiio sourcerercc compared total .
rq2 code relative detection we rst evaluate the quality of the code relatives detected bydyclink by looking at the number of code relatives detected in projects across and within each year.
for this evaluation we ran each tool with its default similarity threshold .
for dyclink .
for hitoshiio and .
for sourcerercc and a minimum code fragment size of lines of code instructions for dyclink .
table shows the number of code relatives detected by dyclink as well as the number of code clones detected by the other two systems.
dyclink detected more similar code fragments on average than the other systems did.
those relatives were skewed to be almost entirely among projects within the same year while the other tools tended to nd similar code fragments more evenly distributed among and within the project years recall that all projects in the same year performed the same task .
this result is encouraging as we expect that there are more code relatives in code that has the same general purpose than in code that is di erent tasks.
figure shows an exemplary pair of similar code fragments detected by dyclink in code jam projects.
the two caller methods calcmaxbet and maxbet exhibit similar functionality to maximize bets so both of them are detected static long calcmaxbet long budget long x int winningthings ... if cando budget x winningthings mid low mid else high mid ... static boolean cando long budget long x int winningthings long lowestbet long paymoney for int i i x. length i if x lowestbet paymoney x lowestbet return paymoney budget a the call sequence includes the cando method long maxbet long a int count long b ... if cost a count mid b left mid else right mid ... long cost long a int count long bet long result for int i i count i result bet a for int i count i a. length i if a bet result bet a return result b the call sequence includes the cost method figure an exemplary code relative.
bydyclink andhitoshiio .
however even though their subroutines cando and cost have similar behavior to evaluate costs hitoshiio cannot detect them as functionally similar by observing their i os.
the reason is that their output values will be hard to detect as similar while cando performs a comparison between the cost and budget and returns a boolean cost solely computes the cost and leaves the comparison for its caller maxbet .
this example shows the di culty to detect dynamic code similarities by observing functional i os of programs.
we did not conduct a user study as part of this experiment other than random sampling performed by the authors to ensure the relatives reported were valid.
to judge the system accuracy we investigated speci cally its precision in a software clustering experiment.
software community clustering.
to judge the e cacy of dyclink in performing software clustering we applied a knn based classi cation algorithm to the google code jam projects.
again our ground truth is that projects from the same year solving the same problem ought to be in the same cluster.
we apply the k nearest neighbors knn classi cation algorithm to predict the label project year for each method and then validate the prediction result by leave one out methodology each sample method plays as a testing subject exactly once where all the rest of the samples play as the training data.
the high level algorithm is shown indata the similarity computation algorithm simalg the set of subject methods to be classi ed methods and the number of the neighbors k result the precision of simalg reallabel methods matrix sim computesim simalg methods succ forminmethods do neighbors searchknn m matrix sim k m predictedlabel vote neighbors ifm predictedlabel m reallabel then succ succ end end precision succ methods size returnprecision algorithm procedure of the knn based software label classi cation algorithm.
algorithm for each method we search for the kother methods that have the greatest similarity to the current one in the searchknn step.
each nearest neighbor method can vote for the current method by its real label in the vote step.
the label voted by the greatest number of neighbor methods becomes the predicted label of the current method.
in the event of a tie we side with the neighbors with the highest sum of similarity scores.
then we track the precision of the approach as the total number of correctly labeled methods divided by the total number of methods.
for observing the e cacy of the systems under single and multiple neighbors we set k andk .
we also vary the line of code thresholds used for each code fragment s minimum size between f10 30g.
only programs that pass the threshold setting including loc and similarity were considered as neighbors of the current program.
the results of this analysis are shown in table dyclink showed the highest precision among all three techniques when examining code fragments that consisted of at least ten lines of code.
when excluding the smallest fragments for example looking only at those with 20lines of code or more the simion detector hitoshiio performed slightly better.
the methods being incorrectly categorized by hitoshiio were mostly less than 20lines of code.
sourcerercc did not nd su cient clones that were longer than lines of code to allow for clustering at that level and hence the precision value is not available.
because we use the project year as the label for each method it is possible that some syntactically similar code detected by sourcerercc is not identi ed as a true positive case.
figure shows the clustering matrix based on dyclink s knn based classi cation result with k loc .
each element on both axes of the matrix represents a project indexed by the abbreviation of the problem set to which it belongs and the project id.
we sort projects by their project indices.
only projects that have at least one code relative with another project are recorded in the matrix.
the color of each cell represents the relevance between the ith project and the jthproject the darker the higher where iandjrepresent the row and column in the matrix.
the project relevance is the number of code relatives that two projects share.
each block on the matrix forms a software community which ts in the problem sets that these projects aim to solve.
these results show that dyclink is capable 710table precision results from knn classi cation of the google code jam projects using dyclink hitoshiio and sourcerercc while varying kand the minimum fragment length considered.
min fragment sizek k dyclink hitoshiio sourcerercc dyclink hitoshiio sourcerercc .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
n a .
.
n a software community based on code relatives i1 i2 i3 i4 i5 i6 i7 i8 i9i10 i11 i12 i13 i14 i15 i16 i17 i18 i19 i20 i21 i22 i23 i24 i25 i26 i27 i28 p1p2p3p4p5p6p7p8p9 p10 p11 p12 p13 p14 p15 p16 p17 p18 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 c17 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 m11 m12 m13 m14 m15 m16 m17 m18 m19 m20 m21 m22 m23 m24 m25i1 i2 i3 i4 i5 i6 i7 i8 i9 i10 i11 i12 i13 i14 i15 i16 i17 i18 i19 i20 i21 i22 i23 i24 i25 i26 i27 i28 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 p18 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 c17 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 m11 m12 m13 m14 m15 m16 m17 m18 m19 m20 m21 m22 m23 m24 m25irregular cake perfect game cheaters magic tour figure the software community based on code relatives detected by dyclink.
the darker color in a cell represents a higher number of code relatives shared by two projects.
of detecting programs with similar behavior and then cluster them for further usage such as code search.
.
discussion through this evaluation we have shown that dyclink is an e ective tool for detecting similar code fragments.
there are several potential limitations to our experiments however.
even though we may have manually come to the conclusion that two code fragments are code relatives and assuming that we are internally valid in that conclusion two developers de nitions of similarly behaving code may di er.
we believe that we have limited the potential for this bias through our study design we purposely selected a suite of projects that are known to be likely to contain similarly behaving code because they were performing the same overall task.
hence when we conclude that dyclink is e ective at nding behaviorally similar code we come to this conclusion both from our internal review and also from the external construction that by de nition the code ought to behave similarly at least on some scale .
however this selectivity comes at a cost the projects that we selected might be too homogeneous overall and not su ciently representative of software in general.
we could bolster our claims by performing a broader study on for instance large open source projects from github.
we could construct a user study to help establish a ground truth for what similar code really is.
dynamic analysis and static analysis have their own opportunities and obstacles in detecting di erent types of similarcode.
thus we plan to distill and integrate the advantages ofdyclink andsourcerercc to devise a new approach for detecting similar code fragments more e ectively with better e ciency.
.
conclusions determining when two code fragments are similar is a subjective and complex problem.
we have distilled the problem of detecting behaviorally similar code fragments into a subgraph isomorphism problem based on dynamic dependency graphs that capture instruction level behavior.
to feasibly analyze the hundreds of millions of potential matching subgraphs we have devised a novel link analysis based algorithm linksub which greatly reduces the number of pairwise comparisons needed to detect code relatives and then e ciently compares them using pagerank.
dyclink detects behaviorally similar code better than previous approaches and has reasonable runtime overhead.
we have released dyclink under an mit license on github .
a tutorial regarding how to use dyclink can be found inx8.
one key limitation of our approach is from its dynamic nature because it relies on program execution traces to detect code relatives it is only applicable to situations where the subject code can be executed.
in addition to being executable at all there must be valid inputs that are representative of a program s normal behavior to expose its typical use cases and generate representative traces.
in our previous work we applied applications existing test suites for this purpose but recognize that test suites may not be truly representative of application usage.
alternatively automated input generation tools could be used to drive the application.
we plan to experiment with input generation techniques allowing us to apply dyclink to larger scale systems than studied in this paper.
furthermore we plan to construct a benchmark suitable for use for dynamic code similarity detection.
this benchmark would contain not only workloads and scripts to compile and run each application but also a human judged ground truth of program similarity analogous to the static code clone benchmark bigclonebench .
we also plan to study additional applications of our linkanalysis based graph comparison algorithm.
for example we plan to explore the possibility to apply dyclink to support software development tasks related to behavior such as semi automatic api generation and code search.
.