managing software evolution through semantic history slicing y i li department of computer science university of toronto toronto on canada liyi cs.toronto.edu abstract software change histories are results of incremental updates made by developers.
as a side effect of the software development process version history is a surprisingly useful source of information for understanding maintaining and reusing software.
however traditional commit based sequential organization of version histories lacks semantic structure and thus are insufficient for many development tasks that require highlevel semantic understanding of program functionality such as locating feature implementations and porting hot fixes.
in this work we propose to use well organized unit tests as identifiers for corresponding software functionalities.
we then present a family of automated techniques which analyze the semantics of historical changes and assist developers in many everyday practical settings.
for validation we evaluate our approaches on a benchmark of developer annotated version history instances obtained from realworld open source software projects on github.
index terms software changes version histories program analysis software reuse.
i. p roblem software configuration management systems scms are widely used in software development practices.
these systems e.g.
git and svn are useful for capturing incremental changes made by developers examining or reverting changes identifying developers responsible for a specific change creating development streams and more.
incremental changes are manually grouped by developers to form commits a.k.a.
change sets .
commits are stored sequentially and ordered by their time stamps so that it is convenient to trace back to any version in the history.
branching is another construct provided by most modern scm systems.
branches are used for example to store a still in development prototype version of a project or to store multiple project variants targeting different customers.
however the sequential organization of changes is inflexible and lacks support for many tasks that require high level semantic understanding of program functionality .
for example developers often need to locate and transfer functionality from one branch to another either for porting bug fixes or for splitting large chunk commits into multiple functionally independent pull requests.
identifying failureinducing changes in version histories is another challenge that developers face in their work.
several scm systems provide mechanism of replaying commits on a different branch e.g.
the cherry pick command in git.
yet little support is provided for matchinghigh level functionality with commits that implement it scm systems only keep track of temporal and text level dependencies between the managed commits.
the job of identifying the exact set of commits implementing the functionality of interest is left to the developers.
motivated by these challenges we propose a new semanticsbased view of software version histories where a set of related changes satisfying a common high level property a.k.a.
slicing criteria is known as a semantic history slice.
as one concrete instantiation test cases exercising a software functionality can be used as slicing criteria to identify the changes implementing the particular functionality.
this dissertation hypothesizes that the proposed organization of version histories is effective in software evolution tasks including software understanding maintenance and reuse.
ii.
r elated work the proposed semantic history slicing problem is most related to change impact analysis and change history analysis including history understanding and manipulation.
change impact analysis.
change impact analysis solves the problem of determining the effects of source code modifications.
it usually means selecting a subset of tests from a regression test suite that might be affected by the given change or given a test failure deciding which changes might be causing it.
research on impact analysis can be roughly divided into three categories the static dynamic and combined approaches.
the work most related is on the combined approaches to change impact analysis.
ren et al.
introduced a tool chianti for change impact analysis of java programs.
chianti takes two versions of a java program and a set of tests as the input.
first it builds dynamic call graphs for both versions before and after the changes through test execution.
then it compares the classified changes with the old call graph to predict the affected tests and it uses the new call graph to select the affecting changes that might cause the test failures.
faulttracer improved chianti by extending the standard dynamic call graph with field access information.
similar techniques can be used to identify changes relating to a slicing criterion.
however another challenge in our problem is to process and analyze the identified changes and ensure that the final results are semantics preserving and well formed.
.
c ieeease urbana champaign il usa doctoral symposium1014 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
history understanding and manipulation.
there is a large body of work on analyzing and understanding software histories.
the basic research goals are retrieving useful information from change histories to help understand development practices localize bugs and support predictions .
the most relevant take on history analysis is to create flexible views of the change histories at various granularities instead of using the fixed commit based representation.
some notable approaches include history slicing and history transformation .
the promise of these techniques is to provide users the most convenient and effective ways of interacting with change histories and better facilitate the specific software evolution tasks at hand.
for example mu slu et al.
introduced the concept of semantics summarization view which clusters original sequence of commits into semantically related high level logical groups.
our proposed approach can be viewed as an implementation of this concept.
delta debugging uses divide and conquer style iterative test executions to narrow down the causes of software failures.
it has been applied to minimize the set of changes which cause regression test failures.
this problem can be considered as finding minimal semantic history slices with respect to the failure inducing properties.
iii.
p reliminaries functionality tests.
we assume that high level software functionalities such as features and bug fixes can be captured by tests and the execution trace of a test is deterministic .
atesttis a predicate t p mapsto bsuch that for a given program p t p is true if the test succeeds and false otherwise.
a test suite is a collection of tests that can exercise and demonstrate the functionality of interest.
let a test suite tbe a set of test cases ti .
we write p tif and only if a program ppasses all tests in t i.e.
t t t p .
commit and commit history.
let a commit be a partial function p mapsto pwhich takes a program version pand transforms it to produce a new program version p .
a commit is a collection of hunks 0 ... n in no particular order each representing a set of line changes with an approximate locality.
composing hunks is equivalent to applying the original commit i.e.
0 n. acommit history is a sequence of commits h an bracketle t ... k an bracketri ht.
asub history is a sub sequence of a history i.e.
a sequence derived by removing changes from hwithout altering the ordering.
we write h hindicating that h is a sub history of h and refer to an bracketle t i ... j an bracketri htashi..j. we usesh h to denote the set of all sub histories of h. iv.
p roposed solutions to tackle the problem described in sect.
i we propose a formal definition of semantics preserving slice and then discuss two different approaches for finding such history slices.s h h all sub histories of h h non minimal semanticspreserving slicesh minimal slices minimalh th fig.
.
relationships between various history slices.
a. semantics pr eserving history slices consider a program p0 pand itsnsubsequent versions p1 ... p nsuch that they are all well formed.
let hbe the original commit history from p0topn i.e.
h1..i p0 pifor all integers i n. lettbe a set of tests passed by pn i.e.
pn t tis fixed once chosen.
definition .
semantics preserving slice .
a semanticspreserving slice of history hwith respect to t denoted by h th is a sub history of h i.e.
h h such that h p0 t. definition .
minimal semantics preserving slice .
a semantics preserving slice h is aminimal if hsub h hsub ne ationslash t. as shown in fig.
there are several special kinds of semantics preserving slices.
first his a semantics preserving slice of itself but it may not be minimal.
second minimal semantic slices h are slices which are semantics preserving and cannot be reduced further.
finally computing minimal semantics preserving slices is expensive so we often compute an approximation known as the minimal semantic slice a slice which cannot be further reduced by removing any single commit.
in practice minimal slices are often minimal .
b. finding semantics preserving slices with the presence of adequate tests for a functionality and the corresponding development history semantic history slicing is a technique which uses tests slicing criteria to identify commits in the history i.e.
a semantics preserving slice that contribute to the implementation of the given functionality.
a trivial but uninteresting solution to this problem is the original history hitself.
shorter slicing results are preferred over longer ones and the optimal slice is the shortest subhistory that satisfies the above properties.
however the optimality of the sliced history cannot always be guaranteed by polynomial time algorithms.
since the test case can be arbitrary it is not hard to see that for any program and history there always exists a worst case input test that requires enumerating all2ksub histories to find the shortest one.
the na ve approach of enumerating sub histories is not feasible as the compilation and running time of each version can be substantial.
even if a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
compile and test run takes just one minute enumerating and building all sub histories of only twenty commits would take approximately two years.
in fact it can be shown that the optimal semantic slicing problem is np complete by reduction from the set cover problem.
we omit the details of this argument here.
to balance between performance and precision we devise two different algorithms for semantic history slicing namely thestatic slicing and dynamic slicing approaches.
static slicing based on dependency analysis.
the static approach mostly relies on static analysis of dependencies between change sets and is therefore much cheaper in terms of running time.
cs licer is an efficient static slicing algorithm which requires only a one time effort for compilation and test execution.
the actual slicing process consists of two phases a generic history slicing algorithm which is independent of any specific scm system in use and an scm adaptation component that adapts the output produced by the slicing algorithm to specifics of scm systems.
the slicing algorithm conservatively identifies all atomic changes in the given input history that contribute to thefunctional andcompilation correctness of the functionality of interest.
the scm adaptation component then maps the collected set of atomic changes back to the commits in the original change history.
it also takes care of merge conflicts that can occur when cherry picking commits in text based scm systems such as svn and git.
cs licer is designed to be conservative in the first phase and thus can be imprecise.
dynamic slicing through delta refinement.
in contrast the dynamic approach executes tests multiple times and directly observes the test results while attempting to shorten the history slices iteratively.
the semantic slices found by the dynamic approach are guaranteed to be minimal but the running time is usually much longer.
definer derives a small and precise semantic slice through the more expensive repeated test executions in a divideand conquer fashion that is very similar to delta debugging .
the high level idea is to partition the input history by dropping some subset of the commits and opportunistically reduce the search space when the target tests pass on one of the partitions until a minimal partition is reached.
to speed up the process definer also uses observed test pass fail signals and dynamic program invariants to predict the significance of change sets with respect to the target tests.
definer operates on the commit level and the history slices produced by d efiner is guaranteed to be minimal removing any single commit from the history slice will break the desired semantic properties.
v. a pplications we have successfully applied the history slicing techniques in many development tasks including back porting bug fixes creating self contained and easy to merge pull requests locating feature implementations and building feature models to assist evolution understanding.feature relationship graph releasef1f2 f3relates to historydepends on fig.
.
feature implementing changes and feature relationship graph extracted from a release history.
a1.
porting functionalities across versions.
the first use case of semantic slicing is to identify the set of commits required for back porting a functionality to earlier versions of a software project.
even in very disciplined projects when such commits can be identified by browsing their associated log messages the functionality of interest might depend on earlier commits in the same branch.
to ensure correct execution of the desired functionality all change dependencies have to be identified and migrated as well which is a tedious and errorprone manual task.
given test cases for the functionalities to be ported semantic slicing techniques can automatically compute the required changes and at the same time effectively avoid including unnecessary changes.
a2.
creating pull requests.
another important use case of semantic slicing is creating logically clean and easy tomerge pull requests.
often a developer works on multiple functionalities at the same time which could result in mixed commit histories concerning different issues.
however when submitting pull requests for review contributors should refrain from including unrelated changes as suggested by many project contribution guidelines.
despite the efforts of keeping the development of each issue on separate branches isolating each functional unit as a self contained pull request is still a challenging task.
for a particular pull request the test cases created for validation can be used as slicing criteria to identify relevant commits from the developers local histories in their forked repositories.
a3.
identifying features and feature relationships.
identifying features in cloned product line variants is important for a variety of software development tasks such as sharing features between variants and refactoring cloned variants into single copy software product line spl representations.
semantic slicing is an effective way of locating featureimplementing changes in software version histories with the presence of feature tests.
for example fig.
shows the mapping between features and their corresponding commits identified by semantic slicing within a single release history f1 mapsto f2 mapsto f3 mapsto .
in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
addition the resulting feature relationship graph is useful for understanding dependencies and connections between features from an evolutionary view point.
each valid product has to respect the inferred depends on relationships in order to function correctly.
the relates to relationships indicate connections between features.
they often reveal underlying hidden dependencies which are essential across the system.
a4.
evolution management framework.
in order to unify different semantic slicing algorithms and provide software developers a flexible and ready to use tool for various evolution management tasks we plan to build a cloud based history slicing service framework.
the front end of the tool chain is a web application closely integrated with the github apis to allow access to users repository meta data and project version histories.
the user interface visualizes various options and slicing results to allow more user friendly interactions with the underlying techniques.
the back end runs on a central server and implements a number of important optimizations including parallelization and caching of slicing results.
it also seamlessly switches between different history slicing algorithms according to specific usage scenarios.
vi.
p lan for evaluation in our preliminary work we have developed experimental support to evaluate the efficiency and effectiveness of our semantic slicing techniques.
more specifically we implemented prototype tools for both the cs licer and the d efiner slicing algorithms.
the tools work with java projects hosted in git repositories and they are available at bitbucket.org liyistc gitslice.
we also constructed a dataset of history slicing problem instances collected from real world software projects.
the ground truth for each instance is obtained through the delta debugging style history partition and thus it is guaranteed to be minimal.
the dataset is available at github.com chenguang zhu dosc.
an additional evaluation strategy is the development of case studies.
we developed case studies on several evolution management tasks in earlier work .
we plan to conduct new case studies on additional development tasks especially with the proposed evolution management framework mentioned in sect.
v. ultimately we intend to evaluate our approach with a comprehensive user study on both experienced and inexperienced developers.
the study will help us evaluate the usability of our tool chain and provide further confidence on the effectiveness of our techniques through direct comparisons with manual operations.
vii.
c ontributions and status this phd work presents a new semantics based view of software version histories and proposes the use of the semantic history slicing techniques to support various evolution management tasks.
we described the work done so far on problem formalization and several alternatives for computing the solutions.
specifically two semantic slicing algorithms have been proposed and implemented as prototype tools.
wedemonstrated applications of the proposed techniques in many practical usage scenarios a1 a2 and a3 .
the construction of an evolution management framework is still in progress a4 .
we also discussed next steps and presented a plan for evaluation.