hybrid regression test selection lingming zhang the university of texas at dallas lingming.zhang utdallas.edu abstract regressiontestingiscrucialbutcanbeextremelycostly.regression test selection rts aims to reduce regression testing cost by only selectingandrunningtheteststhatmaybeaffectedbycodechanges.
todate variousrtstechniquesanalyzingatdifferentgranularities e.g.
atthebasic block method andfilelevels havebeenproposed.
rtstechniquesworkingonfinergranularitiesmaybemorepreciseinselectingtests whiletechniquesworkingoncoarsergranularities may have lower overhead.
according to a recent study rts at the file level frts can have less overall testing time compared with a finer grained technique at the method level and represents state of the art rts.
in this paper we present the first hybrid rts approach hyrts thatanalyzesatmultiplegranularitiestocombine thestrengthsoftraditionalrtstechniquesatdifferentgranularities.
we implemented the basic hyrts technique by combining the method and file granularity rts.
the experimental results on revisionsof32projects totallingover124millionloc demonstratethathyrtsoutperformsstate of the artfrtssignificantlyinterms of selected test ratio and the offlinetesting time.
we also studied the impacts of each type of method level changes and further designed two new hyrts variants based on the study results.
our additionalexperimentsshowthattransforminginstancemethod additions deletions into file levelchanges produces an evenmore effective hyrts variant that can significantly outperform frts in bothofflineandonlinetesting time.
acm reference format lingming zhang.
.
hybrid regression test selection.
in icse icse 40th international conference on software engineering may june gothenburg sweden.
acm new york ny usa pages.
https introduction regressiontestinghasbeenwidelyusedtoensurethatsoftwareevolution does not break existing functionalities.
however simply rerunningentireregressiontestsuitescanbeextremelytimeconsum ing e.g.
somereal worldtestsuitestakeweekstorun .besides regressiontestingcanalsoconsumealotofcomputingresources e.g.
googlehasover100milliontestsrunningeachday occupying variousmachinesandclusters .asaresult shownin apriorsurveybyyooandharman variousapproacheshave beenproposedtoreducethecostsofregressiontesting including permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
regression test suite reduction regression test case prioritization .
regression test selection rts aimstoselectandrunonlytheteststhatareaffectedbycode changes sincethetestsnotaffectedbycodechangesshouldhave the same results with prior runs.
in this way rts can greatly save the regression testing efforts and has been widely used in practice .atypicalrtstechniquerequirestwodimensionsof information the test dependency information i.e.
the program elementsthatcanbeexecutedduringeachtestexecution onanold programversion thechangedprogramelements.then a safe rtstechniqueselectsanytestwhosedependenciesoverlapwith thechangedprogramelementsastheaffectedtests sincemissing any of those tests may fail to detect some regression bugs.
dependingonhowthetestdependenciesarecollected rtstechniques can be categorized as dynamic and static techniques dependingonthegranularitiesofprogramelementsintestdependenciesandprogramchanges rtstechniques can be categorized as basic block level methodlevel file level and even module level techniques.sincestaticrtsusesstaticanalysistooverapproximate thetestdependenciesandthusmayselectmoreteststhannecessary dynamicrtstechniquesatdifferentgranularitieshavebeenlargely studiedintheliterature.accordingtoarecentstudy rtsat the file granularity can have less end to end time i.e.
including both rts overhead and actual testing time compared with a finer grained technique at the method level due to its lower overhead and represents state of the art rts.
actually various open source projects have already adopted file level rts in their daily development e.g.
apache camel math and cxf .
although the file level rts has been demonstrated to be costeffective itmayselectmoreteststhanfiner grainedrts.forexample priorstudyshowedthatfile levelrtsmayselecttwiceas many tests as method level rts on five github java projects .
actually dynamicrtstechniquesatdifferentgranularitieshave there own strengths while techniques working on coarser granularitiesmayhaveloweroverhead rtstechniquesworkingonfiner granularities may be more precise in selecting tests.
our insight is tocombinethestrengthsofrtsatdifferentgranularities to design a hybrid rts approach that can be more cost effective than any of the existing rts techniques.
in this paper we propose the first hybrid rts approach that analyzestestdependencyandchangeinformationatmultiplegranularities.wethenimplementabasichybridrtstechnique hyrts that combines method level and file level analysis for more costeffectivertsformodernjavaprograms.thebasicideaistoperform the method level analysis just for the class files with only finergrained method level changes while performing file level analysis foralltheothercases e.g.
file leveladditions deletions orclassfile acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden lingming zhang header changes.
to evaluate the proposed technique we compare it against state of the art file level rts denoted as frts on revisionsof32githubjavaprojects totalling124 602loc.the experimental results demonstrate that hyrts significantly outperformsstate of the artfrtstechniqueintermsofbothselectedtest ratioandthe offlinetestingtime whenthetestdependenciesare collected offline hyrts frts selects .
.
tests i.e.
.83ppmore precise and costs .60s .06s offlinetesting time i.e.
.
faster onaverageacrossallsubjects.wealsoperformed an extensive study on the impacts of each type of method level changesonhyrts anddesignedtwonewhyrtsvariantsbased on the study results.
additional experimental results show that further including the basic block level analysis in hyrts does not pay off further transforming instance method additions deletions intofile level changesactually producesan evenmore cost effectivevariantthatsignificantlyoutperformsfrtsinboth theofflineandonlinemodes.
the paper makes the following contributions thedesignandimplementationofthefirsthybridrtsapproach hyrts that combines method and file level rts.
experimental results demonstrating the effectiveness andefficiency of the hyrts technique on revisions of projects totalling loc.
anextensivestudyontheimpactsofeachtypeofmethodlevel changes on rts during real world software evolution.
twoadditionalhyrtsvariantsdesignedbasedonthestudy results and experimental results demonstrating that further transforming instance method additions deletions to filelevel changes can make rts even more cost effective.
background and example traditionalregression testselection rts techniques usuallyapplyatcertainlevelofcodegranularity.pioneer rts techniques usually apply at the level of program basicblocks.suchtechniquescollectdynamictestdependenciesforoldprogramversionsatthebasic blocklevel andcomputedetailed programchangeinformationbytraversingcontrol flowgraphs cfgs usingdepth firstsearch dfs .then thetestswhosedependencies overlap with the computed changes are selected forexecution.
although precise such techniques need to computedetailed test dependency and change information and can incur non trivial overhead .
toreducethertsoverhead researchersalsoproposedrtsat themethodlevel.suchtechniques e.g.
faulttracer andchianti compute program changes at the method level denoted asatomic changes .
for example a cm atomic change denotes a changetoamethodbody.besidesnormalatomicchanges theyalso capture changes of instance method overriding hierarchy to detect dynamic dispatch changes denoted as lc i.e.
look upchanges .
a lc change is usually formulated as angbracketleftx y.m angbracketright which denotes that an invocation to y.m with xas the runtime object may be resolved into a different target method due to software changes.such lc changes are additionally generated whenever instancemethods are added am or deleted dm .
then the tests whose method leveldependenciesmayoverlapwiththeatomicchanges are selected.
to illustrate figure presents an example program1 source code classes 2class a 3a ... 4int m1 ... 5static int m2 ... 7class bextends a 8b ... 9static int m2 ... test classes 2class t1 3void t a a new a a.m1 4class t2 5void t a.m2 6class t3 7void t a b new b b.m1 8class t4 9void t b.m2 figure example table example test dependencies testmethod dependency file dependency t1 t1.t a.a a.m1 t1 a t2 t2.t a.m2 t2 a t3 t3.t a.a b.b a.m1 t3 a b t4 t4.t b.m2 t4 b together with its tests and table presents the corresponding test dependenciesatboththemethodandfilelevels.when a.m2 is changed in the next revision denoted as cm a.m2 only test t2needs to be selected and re run since all the other tests cannot execute the change at all.
however when b.m1 is added a naive method level rts technique fails to select any test since no test directly executed the added tests in the prior revision.
therefore a safe method level technique additionally annotates each instancemethoddependency elementwithbothruntime andstatic receiver object types note that such additional information can incur extra overhead during the dependency collection .
for example the method level dependency a.m1 fort3will be annotated with angbracketleftb a.m1 angbracketright toindicatethattheinvocationwasto a.m1 with runtimeobject typeof b.therefore themethod level rtswillbe able to match the annotation with the corresponding lc change to select the truly impacted test t3.
recently researchershavealsoproposedekstazi aneven coarser grainedrtstechniqueatthebinaryclassfilelevel.such file level rts collects test dependencies and computes programchanges both at the file level.
although the coarse granularity makesthetechniqueselectmoreteststhanthemethod levelrts operatingatthefileleveloffersmuchloweroverhead collecting test dependencies at the file level can be faster than the method level computing the program changes at the file level can be directlyachievedbycomputingbinaryfile checksums whichcanbe extremelyfast file levelrtsalsodoesnotneedtotrackdynamic dispatchchanges .forexample accordingtothefile leveldependencyshownintable1 when b.m2 isadded file levelrts will directly be able to detect that t3 and also t4due to the imprecisionoffile levelrts isimpactedwithoutcollectingexpensive runtimetypeinformation sincefile bisalreadyaccessedbythetest.
althoughfile levelrtsselectsmoreteststhanmethod levelrts it has much lower overhead.
overall the file level rts has been shown to save the end to end testing time for real world projects andsignificantlyoutperformthemethod levelrts.similarwith recent advances in flaky test detection using hybrid coverage this work aims to further advance rts using hybrid rts analysis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hybrid regression test selection icse may june gothenburg sweden figure hyrts design overview technique and implementation in this section we present our hybrid rts approach hyrts to combine the strengths of traditional rts techniques at different granularities.
we first introduce a basic hyrts technique that simply computes detailed method level changes only when the corresponding files are modified while simply computing file level changes for file deletions and additions section .
.
then we introduce various hyrts extensions to further study improve rts cost effectiveness section3.
.
finally we summarize thebasis of hyrts changetransformation anddiscussitssafety section3.
.
.
basic hyrts theoveralldesignofourbasichyrtstechniqueisshowninfigure2.thetechniquecanbeinvokedwhenevertheunderlyingbuild system fires the run test command.
the analysis phase of rts performs two levels of rts analysis file level analysis takesthefiledependenciesandselectsalltheteststhatcoverfile level changesfortheexecutionphase method levelanalysistakes the method dependencies and selects all the tests that overlap with thedetailedmethod levelchangesforactualexecution .then bothsetsofselectedtestswillexecuted.duringtheexecutionphase the user can choose to also collect the test dependencies for future rts or collect the dependencies after the execution phase.
theexecution phase results will be stored as test results while the collection phase results will be method level dependencies .
thenforthenextsoftwarerevision themethod leveldependencies will be directly used for the method level analysis .
in addition file leveldependenciescanalsobederivedfrommethod levelanaly sis e.g.
adependencyonclass acanbederivedfromadependency on method a.m for file level analysis .
notethatthehyrtstoolhasbeenimplementedasamavenplugin for testing java programs with junit tests and is publicly availableonourhyrtshomepage .hyrtscurrentlysupportstestclass level rts for both single module and multi module maven projects junit3 and junit4 tests as well asunit via mavensurefire and integration via maven failsafe tests.
we next describe the three key components for hyrts .
.
change computation.
we could have built hyrts based ontheexistingmethod levelrtstool faulttracer orfile level rts tool ekstazi .
however ekstazi is not open source while faulttracer computes program changes at the source code level based on the eclipse java development tools jdt which can incur large overhead for large projects .
therefore we build ourhybridrtstoolfromscratch followingthedesigndecisions of state of the art ekstazi tool .
for example we also compute thechecksums of bytecode files to efficiently detect file changes.
furthermore wealsouse smartchecksums tocomputebytecodefilealgorithm hyrts change computation input v1 old program revision v2 new program revision output the hybrid code changes read old checksums and initialize new ones 1map file csum oldfilecsum map file map meth csum oldmethcsum deserializecsum v1 2map file csum newfilecsum map file map meth csum newmethcsum 3forfile f inv2do compute new file checksums 4newfilecsum computefilecsum f compute new method checksums when necessary 5ifnewfilecsum oldfilecsum then newmethcsum oldmethcsum 7else form e t hmi nf do newmethcsum computemethcsum m serialize new checksums for next rts 10serializecsum newfilecsum newmethcsum file level change computation 11af df ch cf filediff oldfilecsum newfilecsum 12 f af df ch meth level change computation for changed files 13 m uniontext f cfmethdiff oldmethcsum newmethcsum 14return f m contentswithoutdebugginginformation e.g.
linenumberinformation .differentfromekstazi wealsoneedtotracemethod levelchanges.toefficientlystoremethod levelinformationforthepriorrevisionandcomputemethod levelchanges wecomputethesmart checksum foreach method.the detailedhyrts changecomputationisshowninalgorithm1.showninlines5 fortheunchangedfiles all the method level checksums are directly copied from prior revision without further detailed analysis.
during the actual file level change computation line hyrts computes types of changesshowninthetophalfoftable2.notethatweintroduce ch to model the global changes to a file e.g.
interface super classchanges or recompiled bytecode for a newer jdk version to avoid returning all enclosing methods as changed.
in case of af df ch changes any test executing the corresponding class files will be directlyselectedbasedonfile levelrtsanalysis incaseofother file changes cf the basic hyrts does not keep file level changes and performs method level detailed change computation line .
hyrtssupportsallthemethod levelchangessupportedbyprior method levelrts asshowninthebottomparttable2.followingexistingsafemethod levelrts wealsocomputelc changesincaseofinstancemethodadditionsordeletions.notethat fieldchangesdo notneedtobetraced sinceall fieldchangeswill reflectinthecorrespondingmethod levelchanges e.g.
initializer changes at the bytecode level .
also we split non initializer method changes into instance and static method changes e.g.
am to asm and aim to study the impact of each detailed type of changes.
in this work we denote all changes computed by hyrts as m f where mdenotesthemethod levelchanges such as dim andcsi while fdenotes the file level changes suchas df and ch.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden lingming zhang .
.
dependency collection.
ourtestdependencycollection component is implemented based on the asm bytecode manipulation framework with the java agent support for jvm load time code instrumentation.
we override classvisitor and methodvisitor to record the method dependency information togetherwiththeruntimeandstaticobjecttypesforeachinstance method invocation for safe method level rts.
following recent advances on rts we focus on test class level test selection since test methods can be hard to isolate in practice e.g.
test methods may be parameterized or depend on other methods within the test class.
we also create another java agent to dynamically wrap thecorrespondingrunnerclasses e.g.
org.junit.runner.runner forjunit4 tocapturethetestclassstart endeventsforbothjunit3 and junit4 tests in order to trace the per test dependency information.wealsousethesamejavaagenttoexcludetheunselectedtestsfortestexecution.
inthiswork wedenoteallthetestdependencies usedinhyrtsas td tdm tdf wheretdmrepresents the method level test dependencies e.g.
methods invoked as well as runtime type information for receiver objects during test exe cution while tdfis the file level dependencies i.e.
the set of classfilesaccessedduringtestexecution .notethathyrtsonly collectstdmduring runtime for sake of efficiency and tdf can be derived offline from tdmvia skipping detailed method information e.g.
accessing method a.m can be converted into accessing file a. .
.
rts and application modes.
withthechangeinformation and test dependencies collected from the prior revision td theselectedteststsforthecurrentrevisioncanbecomputedasthe testswhose dependencieson thepriorrevision haveoverlap with the changes i.e.
ts td m mtdm f ftdf where mdenotes the method level test selection rules while fdenotes the file level test selection rules .
as shown in figure the time costs during the rts process can be categorizedas the analysis execution and collection time.
in practice the users usually can choose two different rts modes the offline mode that collects test dependencies offline i.e.
after running the selected tests and the onlinemode that collects test dependenciesonlineduringthertsprocess.notethatthe offlinemodecosts moreoverallcputime buttheuserscangetfastertestfeedback andthenpreparethetestdependenciesforthenextrtsrunafter obtainingthetestresults whilethe onlinemodereturnsboththe test results and test dependencies at the same time .
our hyrts technique supports both modes dependency collection willbetriggeredonlyduringthe onlinemode whiletestselection will be triggered for both modes.
in the experimental study section we evaluate hyrts under both modes i.e.
measuring the ae analysis and execution time for the offlinemode and the aec analysis execution and collection time for the onlinemode.
.
hyrts extensions .
.
hyrts study variants.
besidesthebasichyrts wefurther study the impacts of each type of method level changes by transforming it into file level changes to explore the directions for further improving hyrts.
for example when studying the impact ofcimchanges hyrtstreatstheentirefileashavingacfchange cf changes are kept and analyzed in the file level rts analysistable supported change types name description df delete a class file af add a class file ch change file head cfchange a class file not kept in basic hyrts dsi delete a static initializer asi add a static initializercsi change a static initializer di delete an instance initializer ai add an instance initializer ci change an instance initializerdsm delete a static non initializer method asm add a static non initializer methodcsm change a static non initializer method dim delete an instance non initializer method aim add an instance non initializer method cim change an instance non initializer method for these variants whenever there is any cim change within a file while still tracing all the other changes in the same way as the basic hyrts.in thisway hyrts does notneed tracecim changes anymore sincetheyarealreadysubsumedbythecorrespondingfilechanges.clearly suchhyrtsvariantmayselectmoreunnecessarytestsandbemoreimprecise sinceanytestaccessingthecffilewill be selected.
however such hyrts variant can show the impact of eachtypeoffine grainedmethod levelchanges andprovideguide linesformorecost effectiverts.thedetailedexperimentalresultsstudyingtheimpactofeachfine grainedmethod levelchangetype can be found in section .
.
.
.
hyrts b.according to the study results in section .
cim and csm changes tends to have the highest impact on hyrtseffectiveness i.e.
transformingcimandcsmchangesintofile level changesincurshyrtstoselectmanymoretests indicatingthat cim and csm changes require even finer grained analysis instead ofcoarser grainedanalysis.therefore wefurtherproposehyrts b toextendbasichyrtstoperformfiner grainedbasic blocklevel analysis in the case of cim and csm changes to investigate thecost effectiveness of more precise hyrts while keeping the ba sic hyrts method level and file level analyses for other cases .
westrictlyfollowpriorwork onbasic block levelrts inimplementingthebasic block levelanalysisbasedoncontrol flow graph cfg analysis and also analyze the try catch constructs to handle java exceptions.
note that hyrts brequires to also collect detailedtestdependenciesatthebasic blocklevel.weimplement both the cfg analysis and the basic block level dependency collection using the asm framework .
.
.
hyrts f.thestudyresultsinsection5.2alsodemonstrate that aim i.e.
instance method addition and dim i.e.
instance methoddeletion changesdonothavehighimpactsonhyrtseffec tiveness i.e.
transformingeitheraimordimintofile levelchangesdonotincurmuchtestselectionimprecision.therefore wefurther proposehyrts ftoextendbasichyrtsbyfurthertransforming both aim and dim changes into file level changes cf .
although hyrtsfmay select more tests than basic hyrts without aim and dim changes hyrts fdoes not need to consider the class inheritancehierarchychanges i.e.
computinglcchanges ortrace authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hybrid regression test selection icse may june gothenburg sweden the runtime type information for each instance method invocation since the lc changes andruntime type information are both used to handle safety issues in case of instance method additions or deletions .forexample wheninstancemethod a.m is added test tis affected due to method dynamic dispatch change althoughitdoesnothave a.m initsolddependency.if tdoesnot execute other changes tmust invoke m with a receiver object objof type aor subtype of ain the old revision otherwise only adding a.m cannotimpact t .no matter objisof type aorsubtypesof a accordingtojvmspecifications a sinitializer s mustbe invokedfirsttocreate obj.therefore aisaccessedby t andsimply recording file aas changed will be sufficient to select t. without tracing lc changesand runtime type information hyrts fmay be much faster than the basic hyrts in end to end time.
.
hybrid rts safety ourhyrtsapproachtransformscodechangesintofiner coarser grainedchangestoimplementdifferentrtsvariants.beforetalking about hyrts safety we first define two types of transformations.
definition3.
basictransformation .
whenallfine grained elements under acoarse grained element are changed abasic transformation can simply mark the coarse grained element as changed to lowerrtsoverheads i.e.
e where .
denotes the corresponding element is treated as changed.
toillustrate ifclass binfigure1iscompletelydeletedinthenew revision traditional method level techniques still need to dig into btodetectallthedeletedmethods whilefile levelrtscandirectly return a file deletion change.
the actual selection phase for the file levelrtscanalsobefasterduetothesmallnumberoffile leveltestdependenciestoanalyze.therefore wecaneasilycomeupwith hybrid rts techniques that keep changes at the coarse granularity when all the fine grained elements under a coarse grained element arechanged whilekeepingchangesatthefinegranularityatthe other cases.note thatour basichyrts andhyrts bare example techniques in this category.
besidesthebasicchangetransformationsthatwillnotsufferfrom accuracy lost this work also investigates transformations that mayincuraccuracylost e.g.
hyrtsvariantsshowninsection3.
.1andsection3.
.
.toillustrate whenonly b.m2 infigure1ischanged we can still mark the entire class bas changed.
although such aggressive transformationmayselectmoreteststhannecessary the rtsoverheadandend to endtestingtimemaybefurtherlowered definition3.
aggressivetransformation .
aggressivetransformation marks a coarse grained element as changed when onlypart of its fine grained children elements get changed i.e.
ei e ei e .
note that when applying hybrid rts using either basic or aggressive changetransformations the testdependenciesshould be tracedatthefinegranularity e.g.
methodlevelforbasichyrts while basic block level for hyrts b since the coarse grained dependencies can be derived from the fine grained ones.
then thehybrid changes at different granularities can be matched againstcorresponding test dependencies to select tests.
despite the fact that hybrid rts via change transformation may incur imprecision we next discuss that hybrid rts will not incur new safety issues.theorem3.
.
hybridrtsviachangetransformationcannotintroduce new safety issues for dynamic rts.
proof.in general hybrid rts collects test dependencies at different levels denoted as td td1 td2 ... tdn wheretdi i n denotesthetestdependenciesatlevel i.forexample for hyrtsb td tdb tdm tdf which includes basic block method and file level test dependencies.
furthermore hybrid rts also transforms all the changes into different levels denoted as 1 2 ... n where idenote the changes at level i. for example for hyrts b b m f which includes basic block method and file level changes.
then the selected test set tscan be computed asts td uniontext i n tdi i i wherre i denotesthertsrulesatlevel i.ifhybridrtsintroducesnewsafety issues then the test selection must made some unsafe selectionat some level e.g.
there should exist level i i n such that tdi i i failed to select some tests that should have been selected by safe rts.
then wecaneasilyconstructarevision v prime 2betweentheoriginal oldversionv1andtheoriginalnewversion v2 withonlychanges within i.then applyingtraditionalrtsatlevel ibetweenv1and v prime 2will perform tdi i i and thus makingunsafe selection.
however ourhybridrtsisbuilton safertstechniquesatdifferent levels and thus the traditional rts at level ialso cannot make unsafe test selection.
contradiction.
square 4s t u d y .
research questions in this study we are interested in the following research questions rq1 how does our basic hybrid rts technique hyrts compare with state of the art file level rts frts ?
rq2 howdodifferenttypesofmethod levelchangesimpact the rts results?
rq3 can we further transform method level changes of hyrts into finer grained or coarser grained changes for even more cost effective rts?
notethatwedonotcomparehyrtswiththemethod levelrts that compares the detailed contents of all methods regardless of file level changes e.g.
faulttracer since prior work has shownthatmethod levelrtsismuchslowerthanfrts makingit sufficient to compare hyrts against state of the art frts.
.
subjects table3presentsallthesubjectsystemsforthisstudy.forafaircomparisonwithstate of the artfrts weusedallthesingle module mavenprojectsfromrecentstudiesonrts .followingprior work for each project we started from the head revision and selected revisions before it note that if fewer than revisions are available we just use all of them .
then we use all the2 revisions of the studied projects that can pass all the regressiontestsinourevaluation.inthetable allthesubjectsare sorted in the ascending order of their test execution time.
column presents all the projects used as the subject systems.
note that following prior rts work we categorize the subjects into two subsets i.e.
short runningsubjects withtestexecutiontimebelow60s andlong runningsubjects withtestexecutiontimeabove60s .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden lingming zhang subs head revs tests head size loc time s head total invokebinder 004d2fd compile testing e4269a6 logstash logback encoder 4336fdc commons cli b486fbd joda time d7d1620 commons dbutils 633749d commons validator e36fc4b commons fileupload f542f18 asterisk java 61ecf80 commons functor 3da1a4b la4j db20416 commons jxpath e48043d commons email 4ad899d commons compress d5f3062 commons codec 1a4d9cc jfreechart 54eeb32 commons collections 3c1867e commons lang commons imaging 0aec9fd commons configuration commons net 2b0f338 closure compiler e5ca4a7 java apns a7d1e9f commons io 593de77 commons math 79c4719 commons dbcp 6a65042 log4j 7be00ee stream lib a13064c hikaricp 980d8dc opentripplanner cc4dc2e commons pool e35320b mapdb ad7102c total table subject statistics columns2and3presenttheshortsha 1hashfortheheadrevision and the number of revisions for each studied project.
columns and5presentthetestsize i.e.
numberoftestmethods andtestexecutiontimeforthefirstexecutablerevisionofeachstudiedproject.finally columns6and7presentthelinesofcode loc information computedbysloccount excludingcommentsandspaces for the head revision and allthe revisions for each studied project.
in total ourexperimentalstudyinvolves2 707revisionsof32projects totalling over million loc and has a significantly larger scalethan prior studies on rts .
.
experimental setup for each studied rts technique we compute the following widely used rts metrics to measure its effectiveness selected test ratio the ratio of selected tests directly reflects the precision of rts techniques and has been widely used in rts evaluation since the first proposal of rts .wealsousethismetrictostudytheselectionprecisionof different studied rts techniques.end to endtestingtime althoughtheratioofselectedtestscan tell how precise a rts technique is it does not show the overhead incurred by the rts technique.
actually a rts technique that is extremely precise but costs even more than re executing the entire test suite can be useless in practice.
therefore recent work onrts begins to consider the actual time savings of rts techniques.
following recent rts work we measure the end to endtestingtimeforbothmodessupportedbyhyrts i.e.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
figure comparison between basic hyrts and frts the ae analysis and execution time for the offlinemode and the aec analysis execution andcollection timeforthe onlinemode.
allourexperimentsareperformedona3.70ghzintel r xeon r e5 1620v2machinewith128gbofram runningubuntulinux .
.
lts and oracle java bit server version .
.0 101. we applyeachstudiedrtsvariantoneachcoderevisionwithactualcode changes otherwise rts should not be applied .
our experimental data and implementation are available online .
result analysis .
rq1 basic hybrid rts vs. file level rts figure presents the comparison results between our basic hyrts andstate of the artfrts.thethreesub figurespresenttheresults intermsofselectedtestratio the offlineend to endtime i.e.
the aetime andthe onlineend to endtime i.e.
theaectime respectively.notethatthetwotimemetricshavebeennormalizedinto ratioswithrespecttotheoriginaltestexecutiontimefortheeaseofpresentation.ineachsubfigure the x axispresentsallthesubjects while the y axis presents the corresponding metric distributions authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hybrid regression test selection icse may june gothenburg sweden using boxplots with median values marked as lines and mean values marked as hollow diamonds .
from the first sub figure we can observethathyrtsconsistentlyselectsfewertestscomparedwith frts across allthe studied subjects.
on average hyrts and frts select18.
and27.
ofallthetests respectively i.e.
hyrts is .83pp more precise .
this is expected since the finer grained analysiswithinhyrtscanselecttestsmorepreciselyincaseofcf changes.fromthesecondsub figure wefoundthatthehyrtscan outperform frts on the majorityof subjects in terms of the offline testing time demonstrating the effectiveness of the hyrts technique.
for example on average frts and hyrts cost .
and .
of the original test execution time respectively i.e.
hyrts is .
faster .
different from the observations on selected testratio wealsofoundthathyrtstendstooutperformfrtsmore onsubjectswithlongrunningtime sincetheoverheadincurredbythemethod levelanalysismaytakealargerratioforshort running subjects.
from the last sub figure we find that the performance differencebetweenhyrtsandfrtsistheleaston onlineaectime.
forexample theaverageaectimeacrossallsubjectsis58.
and .
of the original testing time for frts and hyrts respectively.
actually hyrts may even cost more than frts for several subjects with long running time e.g.
opentripplanner .
the mainreason is that the method level dependency information including the runtime type information for each instance method invocation forsaferts requiredbyhyrtscanbemorecostlytocollectthan the file level dependency information required by frts.
.
rq2 impacts of fine grained changes inthissection wefurtherstudytheimpactsofeachtypeofmethodlevelchanges bytransformingitintofile levelchangesshownin section3.
.
toexplorethepotentialdirectionsforfurtherimprov inghyrts.tables4and5presenttheresultsintermsoftheselected testratioand offlineaetime respectively.notethattheimpacts foraectimearequitesimilartothoseforaetime therefore we skipthoseresultsduetothespacelimitation.ineachtable column presents all the studied subjects.
columns presents the selected test ratio or ae time by the basichyrts technique.
columns to present theincreased decreased selectedtest ratio or aetime when transforming each type of method level changes into filelevel changes.
finally column presents the increased decreased selected test ratio or ae time by the frts technique as a reference.
to further understand the results we perform the wilcoxon signed rank test .
to compare the result difference on allthe revisionsofeach subject because itissuitable evenforthe casethatthesampledifferencesmaynotbenormallydistributed.
we highlight the cells with statistical differences in gray and also useh and to denote no statistical difference significantly better and significantlyworse respectively.
fromthetable we have the following observations first overall frts performs the worst comparing with transforminganytypeof method levelchangesintofile levelchanges.
for example the selected test ratio increase for frts is .
while it is only .
when transforming cim changes the type of method level changes with the highest impact.
the findings on ae timearealsosimilar.furthermore frtssometimesselectsmore tests than transforming all method level changes into file levelchanges.forexample whenmapdbevolvesfromrevision 45e7679 torevision 1de4c60 theorderingoftwomethodsischangedinfile org mapdb htreemap values .class .
although such modificationdoesnotimpactanymethodbytecodenordynamicprogram behavior the class file is actually changed.
therefore based on thisfinding itispossibletodesignmorecost effectivehyrtsvariants by further transforming a subset of method level changes into file level changes.
second transforming initializerchanges intofile levelchanges cannotimpactthertseffectivenessmuchintermsofbothselected testratioandtestingtime.forexample theinitializerchangesat mostincur0.
increaseinselectedtestratioforcsi and0.70s increase in ae time for ci.
we looked into the code and found the reasontobethatwheneveratestaccessesaclass itusuallyalsohas toinvoketheclass sstaticinitializerorinstanceinitializer.therefore transforming the initializer changes into file level changes won t impact the rts results much.
this finding shows that it is not necessary to build hyrts specifically considering initializer changes since they won t impact the rts results much.
third method bodychanges e.g.
cimandcsm usuallyhave the most impacts on the rts results.
for example among the changes on instance non initializer methods cim has the high est average impacts on both selected test ratio and ae time e.g.
significantlyworsethanhyrtsfor23and8subjects respectively .
similarly csm also has high impacts among the changes on static non initializermethods e.g.
significantlyworsethanhyrtsfor and subjects in terms of selected test ratio and ae time re spectively .
this finding shows that method body changes have highimpactonrtseffectiveness andmaydeservefiner grained analysis e.g.
at the basic block level to further improve rts.
fourth instancemethodadditionsanddeletions i.e.
aimand dim havelowtomoderateimpactsonrtseffectiveness.forexample transformingaimanddimchangesintofile levelchangesonly incurs1.64sand0.23sincreasesinaetime respectively.wefindthe main reason to be that aim and dim changes are not as prevalent as cim changes e.g.
cim changes are .6x as many as the sum of aim and dim changes on average.
we also find that aim changes tend to have higher impacts than dim changes.
the reason is that thereisusuallyalatencytoaddteststoexecutethenewlyadded methods thus transforming aim to file level changes can cause to selectmanyteststhatdonotdirectlyexecutethenewlyaddedmethods.therefore transformingaimchangesintofile levelchanges may incur to select more tests than transforming dim changes.
the low to moderate impacts of aim and dim changes indicate that it may be possible to transform both aim and dim changes intofile levelchangestohavemorepowerfulrts.thereasonis that without aim and dim changes it is not necessary to consider the class inheritance changes i.e.
computing the lc changes and traceruntimetypeinformationforeachinstancemethodinvocation which can be expensive for safe rts section .
.
.
.
rq3 more hybrid rts variants basedonthefourfindingslearntfromtheabovestudy wecomeup withtwonewhyrtsvariants hyrts b section3.
.
andhyrts f section3.
.
furtheroptimizinghyrtsinthefollowingtwodirections even finer grained analysis in case of method body authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden lingming zhang transformed method level changes subs hyrts dsi asi csi di ai ci dsm asm csm dim aim cim frts invokebinder .
.
h0.
h0.
h0.
h1.
h0.
h0.
h2.
h0.
h1.
h9.
.
h13.
compile testing .
.
h0.
h0.
h0.
h0.
h0.
h3.
h3.
h6.
.
h0.
h5.
h15.
logstash logback encoder .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
.
.
commons cli .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h5.
h3.
h13.
joda time .
.
h0.
h1.
h0.
h0.
h0.
h1.
h5.
h7.
h0.
h3.
.
.
commons dbutils .
.
h0.
h3.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
h5.
.
commons validator .
.
h0.
h0.
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
.
.
commons fileupload .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h6.
.
asterisk java .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
.
.
.
commons functor .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
.
la4j .
.
h0.
h0.
h0.
h0.
h1.
h0.
h0.
h6.
.
.
.
.
commons jxpath .
.
h0.
h1.
h0.
h0.
h0.
h1.
h1.
h4.
.
h1.
h5.
.
commons email .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h5.
h1.
h7.
h commons compress .
.
h0.
h0.
h0.
h1.
.
h0.
h1.
h0.
h0.
h0.
.
.
commons codec .
.
h0.
h0.
h0.
h0.
h2.
.
h1.
.
h0.
.
h0.
h4.
jfreechart .
.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
h0.
h0.
h0.
h1.
.
commons collections .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
h1.
h0.
h3.
h commons lang .
.
h0.
h0.
h0.
h0.
h0.
h0.
h2.
.
.
h0.
h0.
.
commons imaging .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
h1.
h9.
.
commons configuration .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
h0.
h4.
.
.
commons net .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h2.
.
closure compiler .
.
h0.
h1.
h0.
h0.
h0.
h0.
h1.
.
.
.
.
.
java apns .
.
h0.
h0.
h0.
h0.
h0.
h2.
h1.
h0.
h2.
.
.
.
commons io .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h6.
.
h0.
h0.
h7.
commons math .
.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
h0.
.
h0.
h1.
.
commons dbcp .
.
h0.
h1.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
h8.
.
log4j .
.
h0.
h0.
h0.
h0.
h1.
h0.
h6.
h0.
h0.
h1.
h2.
h14.
h stream lib .
.
h0.
h0.
h0.
h0.
h0.
.
h0.
h0.
h0.
h0.
h0.
h1.
hikaricp .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h2.
.
opentripplanner .
.
h0.
h0.
h0.
h0.
h0.
.
h0.
h0.
.
.
.
.
commons pool .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h3.
.
.
mapdb .
.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h0.
h1.
h3.
.
avg.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table selection ratio change when transforming different atomic changes into file changes transformed method level changes subs hyrts dsi asi csi di ai ci dsm asm csm dim aim cim frts invokebinder .58s .00sh0.00sh0.01sh0.00sh0.03s .00sh .01sh0.00sh .01sh .02sh0.03sh .01sh .03sh compile testing .14s .00sh0.00sh0.00sh0.01sh0.01sh .01sh0.01sh .01sh0.04sh0.01sh .01sh .04sh0.06sh logstash logback encoder .18s .00sh0.00sh0.00sh0.00sh0.00sh0.00sh .01sh .02sh0.01sh0.00sh .01sh .01sh .02sh commons cli .62s .00sh0.00sh .03sh0.00sh0.00sh .04sh0.00sh0.00sh .01sh0.00sh0.01sh .01sh0.08sh joda time .75s .00sh0.00sh0.01sh0.00sh0.00sh0.00sh0.03sh0.16sh0.12sh0.02sh0.09sh0.25s .33sh commons dbutils .29s .00sh0.00sh .01sh0.00sh0.00sh .04sh0.00sh0.00sh0.00sh .01sh0.00sh0.02sh0.04sh commons validator .72s .00sh0.00sh0.04sh0.00sh0.00sh0.02sh0.00sh0.01sh0.05sh0.00sh0.02s .04sh0.23s commons fileupload .91s .00sh .01sh0.00sh0.00sh .21sh .21sh0.00sh0.00sh0.22sh0.03sh .07sh0.68s .13sh asterisk java .26s .00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.03sh0.04s .04sh0.16sh commons functor .02s .00sh0.00sh0.01sh .01sh0.01sh0.05sh0.01sh0.00sh0.00sh .02sh .15sh .19sh .25sh la4j .49s .00sh0.00sh0.01sh0.00sh0.00sh0.08sh0.00sh0.00sh0.26s .04s .33s .34s .93s commons jxpath .54s .00sh0.00sh0.02sh0.00sh0.00sh0.00sh0.04sh0.03sh0.10sh0.01sh0.03sh0.07sh0.17sh commons email .29s .00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh .02sh0.13sh commons compress .09s .00sh0.00sh0.01sh0.00sh0.08s .16s .06sh0.13s .11sh .04sh0.10sh0.08sh0.32sh commons codec .93s .01sh0.00sh0.05sh .01sh0.33sh0.73s .44sh0.50s .21sh0.53s .24sh0.42sh1.31s jfreechart .80s .00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.04sh0.12sh0.00sh .11sh .15sh0.21sh0.18sh commons collections .72s .00sh0.00sh0.00sh0.00sh0.00sh0.00sh0.00sh .15sh0.00sh0.20sh0.52sh0.06sh0.13sh commons lang .58s .00sh0.00sh .01sh0.01sh .01sh0.03sh0.05sh0.60s .35s .02sh0.04sh0.18sh1.31sh commons imaging .35s .00sh0.00sh0.06sh0.02sh0.05sh0.27sh0.00sh0.02sh .04sh0.46sh0.50sh2.10s .48s commons configuration .12s .00sh0.00sh0.11sh0.00sh0.00sh .01sh0.00sh0.12sh0.03sh .03sh2.98s .28sh5.18s commons net .37s .00sh0.00sh0.04sh0.00sh .01sh .02sh0.00sh0.00sh0.04sh0.00sh .03sh1.44sh1.43sh closure compiler .41s .00sh0.00sh0.52sh .05sh0.05sh .02sh0.03sh0.44sh1.19sh0.65sh1.00sh5.44s .34s java apns .16s .00sh0.04sh0.00sh0.00sh0.00sh0.08sh0.44sh1.67sh0.11sh2.04s .68s .00s .79s commons io .59s .00sh0.00sh2.63sh0.01sh0.00sh .02sh0.00sh1.04sh14.03s .03sh0.02sh .01sh15.06s commons math .71s .00sh0.00sh .02sh0.00sh .01sh0.01sh .01sh0.95sh0.56sh .01sh0.01sh1.98sh4.18sh commons dbcp .16s .01sh0.00sh1.73sh0.00sh .37sh .37sh0.00sh0.04sh0.00sh0.03sh1.31sh3.88sh5.35s log4j .59s .00sh0.00sh0.00sh0.00sh0.00sh0.02sh .01sh8.37sh0.02sh0.00sh0.02sh0.04sh19.45sh stream lib .18s .00sh0.00sh0.00sh0.01sh0.01sh3.49s .62sh2.97s .03sh0.09sh0.94sh0.59sh4.91s hikaricp .10s .00sh0.00sh0.17sh0.00sh0.00sh0.05sh0.00sh0.00sh .02sh0.01sh .01sh0.72sh1.29sh opentripplanner .88s .15sh0.17sh2.50sh0.07sh0.07sh0.17sh2.97sh6.13sh0.91sh3.31sh12.07s .17sh37.10s commons pool .10s .00sh0.00sh0.00sh0.00sh0.00sh5.44sh0.00sh6.06sh0.00sh0.00sh15.66s .67s .40s mapdb .59s .00sh .07sh0.16sh .05sh0.19sh12.65s .12sh5.39sh5.26sh0.14sh13.39sh41.51s .60s avg.
.60s .00s .00s .25s .00s .01s .70s .18s .08s .77s .23s .64s .12s .46s table ae time change when transforming different atomic changes into file changes changes i.e.
csmandcimchanges and fasterhyrts analysisviafurthertransformingaimanddimchangesintofile level changes.notethathyrts bfocusesontheselectionprecisionwhile hyrtsffocusesontheoveralloverhead.themainexperimental results forcomparingdifferenthyrtsvariants i.e.
basic hyrts hyrtsband hyrts f are shown in table .
in the table column subs listsallthestudiedsubjects column selectedtests presentstheselectedtestratiosforeachhyrtsvariant columns aetime and aectime presenttheaeandaecend to endtestingtime including the ratio to the original testing time in brackets.
we also applied wilcoxon signed rank test at the significance level of .
tocompareeachhyrtsvariantagainststate of the artfrts.all the cellswith statistical differences aremarked in gray and h authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hybrid regression test selection icse may june gothenburg sweden selected tests ae time aec time subs hyrts hyrts bhyrts f hyrts hyrts b hyrts f hyrts hyrts b hyrts f invokebinder .
.
.
h1.58sh .
.59s h .
.58s h .
.64sh .
.68s h .
.61s h .
compile testing .
.
.
.14sh .
.15s h .
.13s h .
.27sh .
.21s h .
.24s h .
logstash logback encoder .
.
.
.18sh .
.13s h .
.21s h .
.17s .
.11s .
.19s h .
commons cli .
.
.
.62sh .
.64s h .
.64s h .
.01s .
.76s .
.73s h .
joda time .
.
.
.75sh .
.93s h .
.89s h .
.64s .
.86s .
.35s h .
commons dbutils .
.
.
.29sh .
.42s h .
.24s h .
.30sh .
.40s h .
.36s h .
commons validator .
.
.
.72s .
.83s h .
.72s .
.85sh .
.06s h .
.84s h .
commons fileupload .
.
.
.91sh .
.09s h .
.26s h .
.60sh .
.49s h .
.11s h .
asterisk java .
.
.
.26sh .
.25s .
.31s h .
.42s .
.46s .
.47s h .
commons functor .
.
.
.02sh .
.94s .
.79s h .
.85sh .
.93s h .
.93s h .
la4j .
.
.
.49s .
.54s .
.83s h .
.19sh .
.10s .
.46s h .
commons jxpath .
.
.
.54sh .
.52s h .
.52s h .
.13sh .
.97s h .
.78s h .
commons email .
h19.
h27.
h6.29sh .
.44s h .
.31s h .
.69sh .
.70s h .
.91s h .
commons compress .
.
.
.09sh .
.53s h .
.19s h .
.74sh .
.34s h .
.46s h .
commons codec .
.
.
.93s .
.60s .
.75s h .
.14s .
.60s .
.77s .
jfreechart .
.
.
.80sh .
.08s h .
.82s h .
.86sh .
.02s .
.34s h .
commons collections .
h0.
h3.
h8.72sh .
.36s h .
.09s h .
.91sh .
.22s h .
.03s h .
commons lang .
.
.
.58sh .
.76s h .
.73s h .
.92s .
.31s h .
.10s .
commons imaging .
.
.
.35s .
.54s .
.64s .
.64sh .
.61s .
.80s .
commons configuration .
.
.
.12s .
.21s .
.02s h .
.29s .
.66s .
.36s .
commons net .
.
.
.37sh .
.35s h .
.05s h .
.41sh .
.60s h .
.14s h .
closure compiler .
.
.
.41s .
.10s .
.86s .
.45sh .
.72s h .
.44s .
java apns .
.
.
.16s .
.10s .
.80s h .
.27s .
.11s .
.85s h .
commons io .
.
.
.59s .
.48s .
.68s .
.83s .
.74s .
.77s .
commons math .
.
.
.71sh .
.78s h .
.11s h .
.11s .
.29s .
.94s h .
commons dbcp .
.
.
.16s .
.49s .
.40s h .
.57sh .
.76s h .
.46s .
log4j .
h8.
h10.
h11.59sh .
.62s h .
.67s h .
.80sh .
.87s h .
.67s .
stream lib .
.
.
.18s .
.41s .
.23s h .
.87sh .
.26s .
.99s h .
hikaricp .
.
.
.10sh .
.81s h .
.16s h .
.23sh .
.03s h .
.26s h .
opentripplanner .
.
.
.88s .
.49s .
.34s .
.21s h .
.13s .
.80s h .
commons pool .
.
.
.10s .
.53s .
.42s .
.81s .
.24s .
.54s .
mapdb .
.
.
.59s .
.82s .
.87s .
.99s h .
.96s h .
.80s .
avg.
.
.
.
.60s .
.73s .
.38s .
.56s .
.41s .
.58s .
table experimental results for hyrts variants and represent no statistical difference significantly better and significantlyworse .accordingtotheresultsshownintable6 hyrtsbselects similar ratio of tests with basic hyrts which is counter intuitive.
we looked into the data and found two reasons.first modernsystemdesignprinciplesrecommendwriting simple method bodies for the ease of maintenance making the majorityof methodbodychangesdirectly occuronthe firstbasic blockofthemethods.insuchcases thedetailedbasic block level analysisselectssimilarnumberoftestswithbasichyrts.forexample wheninvokebinderevolvesfrom c35f3ee to9c59df3 method smartbinder.from the only changed source method actually onlyhasonelineofcode.second thebasic block leveldependency collectionfailed foronesubject commons codec whichhas several huge methods e.g.
initstrings andinitbytes inside class base64codec13test .afterthedetailedcodeinstrumentationfor tracing the basic block level test dependencies the code size becamelargerthanthejvmspecifiedmaximumsize i.e.
64kb crash ingjvmwithexception java.lang.runtimeexception method code too large!
.insuchcases ourimplementationsimplyrerunsalltheregressionteststoensuresafety.that sactuallywhy hyrtsbon average selects even slightly more tests than basic hyrts.furthermore hyrts bmayperformevenworsethanbasic hyrts and frts in terms of ae or aec time.
based on the wilcoxontest hyrts bcostssignificantlymoreae aectimethan frts on subjects due to the additional overhead for analyzing basic blockchangesandtracingbasic blockdependencies.onaveragehyrts bcosts46.41saectime whichisevenhigherthan thatoffrts .25s .therefore includingfiner grainedanalysis may not be a good direction for more practical rts.hyrts fextendsbasichyrtsbyfurthertransformingaimand dim changes into file level changes.
although hyrts fmay select more tests than basic hyrts without aim and dim changes hyrtsfdoes not need to consider the class inheritance hierarchy changes i.e.
computing lc changes or trace the runtime type information for each instance method invocation and thus may be muchfaster thanthe basichyrts.
accordingtotable hyrts f incurs small increase in selected test ratio .
and ae time .78s comparedwithbasichyrtsduetothemoreimpreciseanalysis.
however i n terms of the aec time hyrts fis even much more efficient than both basic hyrts and state of the art frts.
forexample hyrts fonlycosts48.
oftheoriginaltestingtime .58s while frts and hyrts cost .
.25s and .
.56s respectively.furthermore hyrts fisneverstatistically significantlyworsethanfrtsintermsofalltheusedmetricswhile the basic hyrts is significantly worse than frts on three subjectsintermsofaectime.overall hyrts fis16.
.
faster than state of the art frts in ae aec time and can be a more cost effective technique than the basic hyrts in practice.
.
threats to validity threats to internal validity.
the main threat to internal validitymainlyliesintheimplementationofthertstechniquesstudied in the work.
to reduce this threat we built the proposed and studied techniques on mature frameworks libraries e.g.
asm and javaagent andcarefullyreviewedourcodeandexperimentscripts beforeand duringtheexperimental study.
furthermore sincethe binary version of the frts tool ekstazi is publicly available we also comparedour frtsimplementation withekstazi interms of selectedtestratioandtheend to endaectimeonsampledprojects.
we found that our frts selects the same number of tests with ekstazi and have competitive end to end time.
to illustrate figure presentstheselectedtestnumberandaectimeforekstaziandour frtsoncommons math.wecanobservethatekstaziandfrts authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden lingming zhang figure ekstazi vs. frts on commons math revisions select exactly the same number of tests for all the studied revisions of commons math with quite close end to end testing time.
threatstoexternalvalidity.
themainthreattoexternalvalidity mainlyliesinthesubjectsystemsusedinthisstudy.toreducethis threat weincludedallthesingle modulemavenprojectsusedin recent rts work and strictly followed prior rts work inselectingprojectrevisions.actually ourstudyincludesallthe projects used on legunsen et al.
s work and involves much more code revisions than recent rts work.
however it is still not clear whether our findings can generalize to other projects.
threats to construct validity.
themainthreattoconstructvalidityliesinthemetricsthatweusedtoevaluatethestudiedrts techniques.
to reduce this threat we use all the three widely used metricsinrts i.e.
theselectedtestratio the offlinetestingtime i.e.
ae time and the onlinetesting time i.e.
aec time .
related work dynamicrts.
rothermelandharrold firstlyinvestigateddynamicrtsforcprogramsatthebasic blockgranularity.harrold etal.
thenextendedthebasic block levelrtstojavaprograms withobject orientedfeatures.orsoetal.
furtherproposeda two phase rts analysis including a partitioning phase to exclude the non affected classes from detailed cfg analysis and a selection phase that performs cfg analysis only on the remaining classes.
note that our work is different from their work their work simplyexcludesthenon affectedclassesandstillperformsuniform detailed analysis i.e.
basic block level analysis on the affected classes whereas our work performs rts analysis at multiple levels in tandem with only detailed analysis when necessary our workdemonstratesthatcombiningmethod levelandfile levelanalysis can outperform state of the art file level rts while further including basic block level analysis is not cost effective.
since finer grained analysis may incur larger overheads besides thebasic block levelrts researchershavealsoinvestigatedrtsatcoarser granularitiestoimprovetheefficiencyofrts.renetal.
and zhang et al.
performed rts at the method level they performed bytecode or source code analysis to detect the changed methods fieldsandthenselectedanytestthatexecutedthechanged methods fields in the old program version.
with the increasing scalesofmodernreal worldprojects method levelrtsmaystill incur large overheads.
therefore gligoric et al.
proposed filelevel rts for java projects which traces the changed bytecode classfilesbasedonfastchecksumcomputation andselectsanytest accessing the changed files.
although imprecise the file level rts canhavenegligibleoverheadandhasbeenshowntooutperformthe method level rts in terms of end to end testing time.
vasic etal.alsocomparedfile levelrtswithevencoarsergrainedrts at the module level for .net programs .
recently celik et al.
designed dynamic file level rts across jvm boundaries.
despiteitseffectiveness file levelrtsmaystillselectmoretests due to the coarse grained analysis.
therefore in this work we propose the first hybrid rts approach to combine the strengths of rts at multiple granularities.
our work differs from all prior rts techniquesthatonlyworkatafixedgranularityandopensanew dimension for further advancing rts.staticrts.
althoughdynamicrtshasbeenwidelystudied itmay notbesuitableforalltypesofsystems.forexample thedynamic test dependencies required by dynamic rts may be challenging to collectforreal timesystemssincethecodeinstrumentationmay breakthetimeconstraintsandinterruptnormaltestruns.therefore staticrtsthatusesstaticanalysistoover approximatetest dependencies has also been proposed to further complement dynamic rts.
kung et al.
proposed the first static rts technique based on the class firewall analysis which computes classes that may be affected by the changes using static class analysis.
since classfirewallanalysismaybeimprecise ryderandtip further proposedstaticrtsatthemethodlevel i.e.
usingstaticcallgraphs to over approximate the dependenciesfor each test.
although the static rts techniques have been proposed for decades their effectivenesshavebeenlargelyunknownduetothelackofstudies on modern software systems.
legunsen et al.
performed a timely and extensive study on static rts recently and showed that static file level rts can have close end to end testing time with state of the artdynamicfile levelrts butissometimesunsafedue toreflections.inthispaper weproposetocombinethestrengths of both fine and coarse grained dynamic rts analysis.
actually our idea is general and can also be applied to static rts and other levels.
we plan to further explore this direction in the future.
conclusion this paper proposes the first hybrid rts approach that analyzes at multiple granularities to combine the strengths of traditional rtstechniquesatdifferentgranularities.weevaluatetheproposed approach in both the onlineandofflinemodes on revisions of 32projects totallingover124millionloc.thestudyshowsthat hyrts ourfirsthybridtechniquethatcombinesmethodandfile granularityrtsanalysis canbesignificantlyfasterthanstate ofthe artfrtsinthe offlinemode butsometimesslowerthanfrtsin theonlinemodeduetothecollectionofmethod leveldependencies.
we then further studied the impact of each type of method level changesonthertsresults anddesignedtwonewhyrtsvariants based on the study results.
the additional study shows that further integrating finer grained analysis at the basic block level is notcost effective whereas transforming instance method additionsand deletions into file level changes can produce a cost effectivehyrts variant that consistently outperforms existing frts for bothonlineandofflinemodes.