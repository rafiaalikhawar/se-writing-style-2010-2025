to type or not to type quantifying detectable bugs in javascript zheng gao university college london london uk z.gao.
ucl.ac.ukchristian bird microsoft research redmond usa cbird microsoft.comearl t. barr university college london london uk e.barr ucl.ac.uk abstract javascript is growing explosively and is now used in large mature projects even outside the web domain.
javascript is also a dynamically typed language for which static type systems notably facebook s flow and microsoft s typescript have been written.
what benefits do these static type systems provide?
leveraging javascript project histories we select a fixed bug and check out the code just prior to the fix.
we manually add type annotations to the buggy code and test whether flow and typescript report an error on the buggy code thereby possibly prompting a developer to fix the bug before its public release.
we then report the proportion of bugs on which these type systems reported an error .
evaluating static type systems against public bugs which have survived testing and review is conservative it understates their effectiveness at detecting bugs during private development not to mention their other benefits such as facilitating code search completion and serving as documentation.
despite this uneven playing field our central finding is that both static type systems find an important percentage of public bugs both flow .
and typescript .
successfully detect !
keywords javascript static type systems flow typescript mining software repositories i. i ntroduction in programming languages a type system guarantees that programs compute with expected values.
broadly two classes of type systems exist static and dynamic.
static type systems perform type checking at compile time while dynamic type systems distinguish types at run time.
the cost and benefits of choosing one over the other are hotly debated .
proponents of static typing argue that it detects bugs before execution increases run time efficiency improves program understanding and enables compiler optimization .
dynamic typing its advocates claim is well suited for prototyping since it allows a developer to quickly write code that works on a handful of examples without the cost of adding type annotations.
dynamic type systems do not force developers to make an explicit upfront commitment to constraining the values an expression can consume or produce which facilitates the writing of reflective adaptive code.
javascript a dynamically typed language is increasing in popularity and importance.
indeed it is often called the assembly of the web it is the core language of many longrunning projects with public version control history.
three companies have viewed static typing as important enoughto invest in static type systems for javascript first google released closure1 then microsoft published typescript2 and most recently facebook announced flow3.
what impact do these static type systems have on code quality?
more concretely how many bugs could they have reported to developers?
the fact that long running javascript projects have extensive version histories coupled with the existence of static type systems that support gradual typing and can be applied to javascript programs with few modifications enables us to under approximately quantify the beneficial impact of static type systems on code quality.
we measure the benefit in terms of the proportion of bugs that were checked into a source code repository that might not have been if the committer were using a static type system that reported an error on the bug.
in this experiment we sample public software projects check out a historical version of the codebase known to contain a bug and add type annotations.
we then run a static type checker on the altered annotated version to determine if the type checker errors on the bug possibly triggering a developer to fix the bug.
unlike a controlled human subject experiment our experiment studies the effect of annotations on bugs in real world codebases not the human annotator just as surgery trials seek to draw conclusions about the surgeries not the surgeons despite our reliance on human annotation.
more generally decision makers can use this what if style of experimentation on software histories to help decide whether to adopt new tools and processes like static type systems.
in this study we empirically quantify how much static type systems improve software quality.
this is measured against bugs that are public actually checked in and visible to other developers potentially impacting them public bugs notably include field bugs which impact users.
we consider public bugs because they are observable in software repository histories.
public bugs are more likely to be errors understanding the specification because they are usually tested and reviewed and in the case of field bugs deployed.
thus this experiment under approximates static type systems positive impact on software quality especially when one considers all their other potential benefits on documentation program performance code completion and code navigation.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the core contribution of this work is to quantify the public bugs that static type systems detect and could have prevented for both flow .
and typescript .
on average.
our experimentation artefacts are available at ucl.ac.uk projects type study index.html.
ii.
p roblem definition here we define the bugs that the use of a type system might have prevented by drawing a developer s attention to certain terms discuss how we leverage information in bug fixes to make our experiment feasible discuss which errors we aim to detect and then close with an example.
definition .
ts detectable given a static type system ts a bug is ts detectable when adding or changing type annotations causes the buggy program to fail to type check and the new annotations are consistent with the fully annotated correct version of the program.
the added or changed type annotations may affect several terms or only one.
these annotations are consistent if the annotated program type checks and for every term the type of that term in the annotated program is a supertype of the term s type in the ideal correct fully annotated program.
in this experiment we can only strive to achieve consistency because we do not have the correct fully annotated program.
one can download our experimental data to verify how well we have reached this goal.
consistency implies that we do not intentionally add ill formed type annotations.
for example when band chave type number changing var a b c tovar a boolean b c incorrectly annotates aasboolean triggering a type error.
if such ill formed annotations are not ruled out one use them to detect any bug even typeindependent failures to meet the specification.
let lbe a programming language like javascript and la be a language based on lwith syntactical support for type annotations like flow or typescript.
let b b1 b2 bm denote a set of buggy programs.
let abe an annotation function that transforms a program p ltopa la.
finally let tcbe a type checking function that returns true if an annotated program patype checks and false otherwise.
we annotate each buggy program bithat is in band written inl and observe whether it would type check.
we calculate the percentage of bugs that a static type system detects over all collected ones.
our measure of a static type system s effectiveness at detecting bugs follows bi b tc a bi b equation reports the portion of bugs that could have been prevented had a type system like flow or typescript reported type errors that caused a developer to notice and fix them.
depending on the error model of a static type system amight be the identity function i.e.
add no annotations.
for instance both flow and typescript are able to detect errors in reading an undefined variable without any annotation.a.
leveraging fixes bug localization often requires running the software and finding a bug triggering input.
code bit rots quickly frequently it is very difficult to build and run an old version of a project let alone find a bug triggering input.
worse many of our subjects are large some having as many as loc table i .
to side step these problems we leverage fixes to localize bugs.
for p l we assume we have a commit history as a sequence of commits c c1 c2 cn .
when ci cdenotes a commit that attempts to fix a bug the code base materialized from at least one of its parents ci 1is buggy.
a fix s changes help us localize the bug we minimally add type annotations only to the lexical scopes changed by a fix.
we add annotations until the type checker errors or we decide neither flow nor typescript would error on the bug.
this partial annotation procedure is grounded on gradual typing which both flow and typescript employ.
these two type systems are permissive.
when they cannot infer the type of a term they assign the wildcard any similar to abadi et al.
sdynamic type to it.
this procedure allows us to answer how many public bugs could flow and typescript have prevented if they had been in use when the bug committed?
under the assumption that one knows the buggy lines.
by in use we mean that developers comprehensively annotated their code base and vigilantly fixed type errors.
the assumption that developers knew the buggy lines is not as strong as it seems because under the counterfactual that developers were comprehensively and vigilantly using one of the studied type systems the bugintroducing commit is likely to be small median of lines in our corpus and to localize some of the error triggering annotations while the rest of the annotations would already exist in the code base.
limitations four limitations of our approach are a fix may fail to resolve and therefore localize the targeted bug a minimal consistent bug triggering annotation may exist outside the region touched by the fix we may not succeed in adding consistent annotations definition .
and the annotation we add may cause the type checker to error on a bug unrelated to the bug targeted by the fix.
further considering only fixed public bugs introduces bias.
we restrict our attention to these bugs for the simple reason that they are observable.
we have no reason to believe this bias is correlated with ts detectability.
section vi discusses other threats to this work.
b. error model the subjects of this experiment are identified and fixed public bugs.
as figure shows we aim to classify these bugs into those that are ts detectable the solid partition of fixed public bugs and not the hashed partition of fixed public bugs .
type systems cannot detect all kinds of fixed public bugs.
what sorts of bugs do our type systems detect and may prevent?
type systems eliminate a set of bad behaviours .
more specifically flow or typescript detects and may prevent type mismatches including those normally hidden by javascript s coercions and undefined property and method authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
the error model of this experiment.
1function addnumbers x y return x y 4console.log addnumbers a the buggy program.
1function addnumbers x y return x y 4console.log addnumbers b the fixed program.
1function addnumbers x number y number return x y 4console.log addnumbers c the annotated buggy program.
fig.
javascript coerces 3to and prints .
from the fix we learn that this behavior was unintended and add annotations that allow flow and typescript to detect it.
accesses.
additionally both flow and typescript identify undeclared variables.
c. example assume addnumbers in figure 2a is intended to add two numbers but the programmer mistakenly passes in a string .
because of coercion a controversial feature that enriches a language s expressivity at the cost of undermining type safety and code understandability in javascript can take a pair of number and string values.
thus figure 2a converts the number to a string concatenates the two values and prints .
by reading the fixed program in figure 2b we infer that both parameters are expected to have type number .
we partially annotate the program shown in figure 2c enabling flow and typescript to signal an error on line and detect this bug.
if in addition to this bug we had shown four other bugs to be undetectable equation would evaluate to1 .
iii.
e xperiment al setup our experimental setup is similar to that of le goues et al.
.
they aimed to determine for a sample of real world historical bugs sampled from github projects what proportion of bugs would been fixed through automatic program generation defects4j enables similar studies and evaluations on real fig.
the automatic identification of fix candidates that are linked to bug reports.
world bugs for java targeted tools .
we perform a sampling of historical real world javascript bugs and attempt to determine what proportion of bugs would have been detected using static javascript type systems if the authors had been using them.
our study comprised many phases methodological decisions investigations and techniques.
in this section we describe the types of data gathered and how we selected the data to use discuss potential threats and how we mitigate them report on preliminary investigations and present our annotation process and various tactics used.
a. corpus collection we seek to construct a corpus of bugs that is representative and sufficiently large to support statistical inference.
as always achieving representativeness is the main difficulty which we address by uniform sampling.
we cannot sample bugs directly but rather commits that we must classify into fixes and nonfixes.
why fixes?
because a fix is often labelled as such its parent is almost certainly buggy and it identifies the region in the parent that a developer deemed relevant to the bug.
to identify bug fixing commits we consider only projects that use issue trackers then we look for bug report