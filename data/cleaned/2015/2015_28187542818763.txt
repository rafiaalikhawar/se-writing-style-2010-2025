automated modularization of gui test cases rahulkrishna yandrapally giriprasad sridhara saurabh sinha ibm research india abstract test cases that drive an application under test via its graphical user interface gui consist of sequences of steps that perform actions on or verify the state of the application userinterface.
such tests can be hard to maintain especially if they arenot properly modularized that is common steps occur in manytest cases which can make test maintenance cumbersome andexpensive.
performing modularization manually can take up con siderable human effort.
to address this we present an automatedapproach for modularizing gui test cases.
our approach consistsof multiple phases.
in the first phase it analyzes individual testcases to partition test steps into candidate subroutines based onhow user interface elements are accessed in the steps.
this phasecan analyze the test cases only or also leverage execution traces ofthe tests which involves a cost accuracy tradeoff.
in the secondphase the technique compares candidate subroutines across testcases and refines them to compute the final set of subroutines.
inthe last phase it creates callable subroutines with parameterizeddata and control flow and refactors the original tests to call thesubroutines with context specific data and control parameters.our empirical results collected using open source applications illustrate the effectiveness of the approach.
i. i ntroduction test cases that drive an application under test via its graphical user interface gui are frequently used in functional testing of enterprise applications.
such a test case consists of asequence of steps that perform actions on the application userinterface and check the expected behavior of the application in response to those actions as exhibited in the state of itsuser interface.
gui tests are created using a test automationtool such as selenium .
like any software system gui test cases after creation require maintenance.
as the application under test evolves the test cases need to be adapted accordingly.
some testscould become obsolete and therefore are removed from thetest suite whereas other tests may need to be repaired involving addition deletion or modification of test steps toreflect the updated application behavior.
in particular contentof the application screens might change requiring the teststhat navigate to those screens to be updated.
to ease test maintenance it is essential that the tests cases are properly modularized.
the benefits of modularization arewell known in software development and these benefits arejust as applicable to gui test cases.
to illustrate this considerthe registration page of a bookstore web application shown in figure .
there are several testing scenarios for this page.after providing the required data in the fields clicking theregister button results in successful registration clickingthe cancel button causes the registration process to terminateand the previous page to be displayed and clicking theclear button erases all entered data and control stays on the t1 t2 action target data action target data .
click registration .
click registration .
enter login l1 .
enter login l2 .
enter password p1 .
enter password p2 .
enter confirm password p1 .
enter first name john .
enter first name john .
enter last name smith .
enter last name smith .
click register .
click register .
exists angbracketlefterror message angbracketright .
click sign in .
enter login l1 .
enter password p1 .
click login .
exists angbracketleftsuccessful login angbracketright fig.
.
the registration page in the bookstore web application top .
two test cases that navigate to the registration page bottom .
registration page.
in addition to these valid scenarios thereare error scenarios to be exercised as well attempting toregister with an already existing login id or without providingall required information in which case registration fails withan appropriate error message.
figure also shows two gui test cases that navigate to the registration page.
test t 1exercises the valid scenario of successful registration whereas t2covers the error scenario where registration is attempted without providing data for therequired confirm password field.
a test case is a sequenceof steps where each step consists of an action a target user interface ui element on which the action is performed and an optional data value.
step in t 1and step in t2 contain assertions that verify successful and failed registration respectively the actual messages are elided for brevity .
during application evolution different structural and logical changes could be made that break gui test cases .
asexample of a structural change the label login could bechanged to user id which would affect whether the targetui element can be located in step of t 1andt2.
partly the problem of maintaining gui tests pertains to the resilienceof ui element locators to such structural page changes.
aui element can be located using different selectors such asxpaths css paths or html attributes e.g.
idandname or alternatively via neighboring text labels or contextual ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee icse florence italy labels .
depending on what locators are used and the types of changes made on a page test steps may break and need tobe patched.
apart from structural changes logical changes thataffect application flows can break test cases too in such cases steps have to be added or deleted to fix the test.
for instance the registration page could be split into two pages where onlythe login text box appears on the first page and control reachesto the second page containing the remaining ui elements only after the login value passes validation checks e.g.
that the id is not already existing .
the problem of test breakage caused by such structural and logical changes can be addressed partially by robust ui element locators e.g.
and test repair techniques e.g.
but these techniques nonetheless have limitations and often test repair requires manual intervention.
in this situation the manual maintenance effort would be much lower if testswere modularized.
for our example if the steps in t 1andt2 that are performed on the registration page were extractedinto a reusable module which was invoked from those tests changes on the registration page would require updates inonly the common module instead of each test case and theregistration page in fact has more scenarios to be coveredthan just the two illustrated by t 1andt2 .
these maintenance issues with gui tests has led to development of the notion of page objects for creating modular and easy to maintain gui tests .
the idea is toencapsulate in a page object the ui elements and functionalityon an application page and then create test cases by invokingmethods on page objects.
the problem is that creating pageobjects is a manual process requiring considerable humaneffort.
test scenarios have to be broken down into modularizedsequences of steps based on the structure of the navigatedpages page objects with appropriate parameterized methodshave to be created and tests have to be coded by invoking thepage object methods.
leotta and colleagues report that thedevelopment of gui test cases via manual coding of modularpage objects can be much more expensive than in somecases taking more than twice as much effort as creating thesame tests using capture replay techniques the latter set oftests as expected have a greater maintenance cost .
therefore an approach for automatically modularizing tests created via recording would be very useful it would providethe benefits of low maintenance costs and avoid the upfrontcosts of crafting modular tests by hand.
in this paper wepresent such a technique.
our technique can be applied to guitests created via manual recording or automated test generation e.g.
which also produce non modular test cases.
intuitively modularization of gui tests requires the structure of the navigated pages to be analyzed so that elementson a page or at a more granular level in a form can beaggregated into a module.
thus at a high level our techniqueattempts to recover this structure by analyzing the ui elementsaccessed in the test steps.
the notions of page and form are well defined in conventional web applications pages areassociated with urls and forms can be related to html form elements.
but in modern ajax style applications whichcontain significant client side processing there is often noclear distinction between pages e.g.
all application pages can have the same url .
similarly forms need not be associatedwith html form elements.
to overcome these issues and to be more generally applicable our approach analyzes theunderlying document object model dom of the pagesnavigated by test cases.
our approach operates in three phases.
in the first phase it analyzes each test case independently to partition the test steps into candidate subroutines.
this phaseanalyzes the occurrences of the accessed ui elements in thedom.
it uses distance metrics on the dom to detect theloading of a new page and consequently the beginning ofa new module.
this phase can be performed dynamically by leveraging execution traces consisting of the dom snap shot after each test step or statically by analyzing the testcases only.
if dom snapshots are available the candidatesubroutines can be computed more accurately at the additionalcost of trace collection .
the output of this phase is a set ofcandidate subroutines which feeds into the subsequent phases.
in the second phase the technique compares candidate subroutines across test cases to compute the final set of subrou tines.
it creates initial groups of candidate subroutines and thenrefines the groups based on the degree of commonality in theaccessed ui elements and whether the candidate subroutinesin a group contain conflicting orderings of actions.
the last phase performs test refactoring to transform the original test suite into a suite consisting of reusable subroutinesand modular test cases.
specifically phase creates callablesubroutines with parameterized data and control flow andreplaces steps in the original test cases with calls to the subrou tines along with context specific data and control parameters.
although many approaches have been developed for generating gui tests e.g.
there is not much existing research on modularizing gui tests to make them easierto maintain which is a problem with significant practicalimplications.
mahmud and lau present a supervisedmachine learning technique for identifying subroutines in guitest cases written in the clearscript language .
unlike thattechnique our approach analyzes the structure of the pagesnavigated by a test case and does not require a training sampleof subroutines.
section iv further discusses related work.
we implemented the technique and conducted empirical studies using four open source web applications with guitests in total to evaluate various aspects of the technique.
theresults show that our technique can extract highly reusablesubroutines and reduce the sizes of test cases for our subjects it extracted subroutines with an average of about sixsteps and eight call sites per subroutine the total test stepsdecreased from over in the original test suites to 721in the refactored suites a reduction of .
moreover theextracted subroutines correlate closely to application pages which typically is the goal when modular test cases are de signed by hand for example using the page object abstraction.this indicates that our approach could be effectively used toautomate the task of finding plausible subroutines in recordedor automatically generated gui tests.
icse florence italythe contributions of this work are the description of an automated technique for extracting subroutines from and refactoring gui tests that is basedon the structure of the pages navigated by the tests andis generally applicable.
the implementation of the technique for modularizinggui tests for web applications.
the presentation of empirical results demonstrating theeffectiveness and efficiency of the technique.
the rest of the paper is organized as follows.
the next section describes our technique for modularizing gui testcases.
section iii presents the results of the empirical studies.section iv discusses related work.
finally section v summa rizes the paper and lists directions for future research.
ii.
o urtechnique given a suite of gui test cases our technique refactors the tests by extracting reusable subroutines and replacing steps inthe original tests with calls to the extracted subroutines.
figure shows the refactored bookstore test cases and the extracted subroutine for entering registration information.to simplify the presentation we use pseudo code notation infigure to illustrate the subroutine and the tests the imple mented tool creates the refactored test suite as selenium test cases written in java that can be executed using junit seesection iii .
the extracted subroutine enterregdetails contains test steps that are executed on the registration pageand takes two input parameters an array data of contextspecific data values for test steps and an array control of boolean flags controlling the execution of test steps.
the values of data are used in those test steps that required data steps and .
the boolean flags in control determine whether steps and are executed the remaining steps execute unconditionally.
tests t1andt2are refactored to call enterregdetails line in t1andt2 and set up the context specific data and control parameters lines and in t 1andt2 .
the data setup in t1creates five data values whereas the data setup in t2creates four values the third parameter which is used for the confirmpassword text box is empty because the correspondingtest step step in enterregdetails does not execute when enterregdetails is called from t2.
the control setup line ensures that when enterregdetails is invoked from t1 step executes and step does not execute the converse is true when enterregdetails is called from t2.
our technique performs this transformation in a mechanized way and ensures that the behavior of the original tests ispreserved in the transformed tests.
before presenting thealgorithm we provide some preliminary definitions.
1although figure illustrates the extracted subroutine s data and control parameters as arrays alternatively a separate formal parameter with a meaningful name e.g.
derived from attributes of the target ui element to which the parameter applies could be generated for each data and or control parameter.sub enterregdetails str data bool control .
enter login data .
enter password data .
if control .
enter confirm password data .
enter first name data .
enter last name data .
click register8.
if control .
exists error message end subtest t1 .
str data l1 p1 p1 john smith .
bool control true false .
click registration4.
call enterregdetails data control .
click sign in6.
enter login l17.
enter password p18.
click login9.
exists successful login end testtest t2 .
str data l2 p2 john smith .
bool control false true .
click registration4.
call enterregdetails data control end test fig.
.
the transformed bookstore test suite with the extracted subroutine for entering registration information and the refactored test cases that call the extracted subroutine.
a. definitions we consider gui test cases of the form shown in figure b .
a test case is a sequence of test steps angbracketlefts1 ... s n angbracketright where each siis an action performed on the application user interface an action step or a verification of the userinterface state a verification step .
a test step is a triple a e d consisting of a command a a target ui element e and an optional data value d. the command acan be a predefined verification command e.g.
exists selected enabled that is a predicate on the state of a ui element a predefined action command e.g.
right click or a generic action command e.g.
enter select .
the set of predefined commands depends on the test automation tool being used.
the target ui element for a test step is identified using element locators.
web testing tools such as selenium provide different types of locators that are based on xpaths css paths or html attributes.
our approach requires inparticular the xpaths of ui elements.
for example forstep of tests t 1andt2 where the target is the registration image on the bookstore home page the xpath html body table tbody tr td table tbody tr td a image is recorded in those tests.
an xpath encodes both the hierarchyof elements and the relative position of an element within itsparent for example td refers to the third tdelement within the parent trelement.
figure shows a partial dom for the registration page in bookstore .
the ui elements labels and other html elements are nodes in the dom.
to match test steps effectively across test cases we use a notion of equivalence rather than strict equality which abstracts out unnecessary details.
we define a canonical representation of a test step sas s llbracket a e d rrbracket.
a maps command ato the constant aifais a generic action command otherwise a a .
e maps element eto its xpath.
d mapsdto the boolean value true ifdis non46 icse florence italy g1005 g1013 g1005 g1008 g1005 g1008 g1006 g1012 g1005 g1007 g1005 g1007 g171 g1005 g1005 g1005 g1005 g1005 g1006 g1005 g1006 g1005 g1004 g1005 g1004 g1005 g1010 g1005 g1010 g1005 g1009 g1005 g1009 g1006 g1004 g1006 g1004 g1005 g1013 g1005 g1013 g1006 g1005 g1006 g1005 g1007 g1007 g1011 g1011 g1008 g1008 g1009 g1009 g1010 g1010 g171 g171 g1005 g1012 g1005 g1012 g1005 g1011 g1005 g1011 fig.
.
partial dom for the bookstore registration page.
empty and to false otherwise.
the canonical representation abstracts out generic action commands and data values so that test steps in different contexts can be matched.
thus thecanonical representations of step of t 1andt2are the same llbracketa html body table ... tr td input true rrbracket.
next we define path equivalence on the dom.
a dom node has a type e.g.
div table button image and a set of html attributes e.g.
id name class src associated with it.
node nisequivalent to nodemif and only if the nodes have the same type the same set of attributes and thesame value for each attribute.
let idx n denote the index of n. letp n ... n k andq m1 ... m k be two paths in the dom.
then p qif and only if for all i k niis equivalent to miand for all i k idx ni idx mi .
b. the test modularization algorithm the algorithm has three phases which we explain next.
computation of candidate subroutines algorithm presents the phase analysis it takes as input a test suite tand produces as output the set of candidate subroutines for the tests in t. the algorithm partitions the steps of each test case based on the dom locations of the referenced uielements.
the intuition behind this is that the proximity of thereferenced ui elements indicates logical groupings of steps test steps that access closely located elements in the dompertain to actions performed on a page or form whereasa step that accesses a significantly different part of the domthan its preceding step potentially begins a new subroutine.more concretely the analysis determines this by computing theleast common ancestor lca of a set eof ui element nodes.
the farther away that the lca of eis from the dom root node the more likely that the ui elements in eare related.
conversely if the lca is close to the root econtains widely dispersed and potentially unrelated ui elements.
acandidate subroutine s c d e p wheredis a dom is a sequence of test steps eis the set of ui elements referenced in the steps in andp referred to as path prefix is the path in dfrom the root node to the lca of all nodes ine.
consider figure .
suppose that econsists of nodes the login text box the password text box and theregister button these nodes are highlighted in figure .
then the lca of these nodes is node and pis the path shown as the dashed path in figure .
as mentioned earlier phase can be performed statically or dynamically algorithm presents the dynamic variant ofalgorithm identification of candidate subroutines.
input test suite t output set scof candidate subroutines 1foreacht tdo initialize sc d e p lprev foreachs a e d tdo letdcurr be the dom snapshot before step s letlcurr be the lca of eandlprev indcurr ifstartnewsubroutine l prev lcurr d curr e then letlbe the lca in dcurr of the elements in e setdto the subtree in dcurr rooted at l setpto the path from the root node to lindcurr addsctosc reinitialize sc lprev else setlprev tolcurr addetoe addsto returnsc phase which assumes that an execution trace containingthe dom snapshot before each test step is available.
afterexplaining the dynamic variant of the algorithm we discussthe modifications required for the static variant.
the algorithm iterates over each test case t line and each step int line .
line reads the dom snapshot before step s from the execution trace and line computes the lca of e the ui element referenced at s andl prev the lca from the previous iteration which is undefined for the first test step .the lca computation locates the nodes for eandl prev in dcurr .
botheandlprev have xpaths associated with them so the algorithm uses path equivalence to locate them in dcurr .
if stepsresults in the loading of a new page lprev would not appear in dcurr in this case eis used as the lca in line .
next the algorithm calls the startnewsubroutine function line which uses two metrics to determine whethera new subroutine should be started at s. first startnewsubroutine checks whether all elements in e i.e.
the elements referenced by steps in the candidate subroutine under consideration appear in dcurr .i f this is the case the function proceeds with the second check otherwise it returns true indicating that a new subroutineshould be started.
typically the latter condition would indicatea server side communication that re renders the dom causingpreviously referenced elements to no longer be available.
thischeck is performed only in the dynamic variant of phase .
second startnewsubroutine checks whether the normalized difference between the distances of lprev andlcurr from the root node of dcurr exceeds a threshold value and returns true if it does.
the check is performed as lprev dcurr lcurr dcurr lprev dcurr d where n d returns the distance of nfrom the root node ofd.
intuitively this formula captures whether saccesses a ui element in a substantially different part of the dom than thepart accessed in the preceding steps thus causing a big shift inthe lca node toward the dom root.
to accommodate caseswherel prev is close to the root before applying the distance metric startnewsubroutine checks whether lcurr is the html body element and if it is returns true.
icse florence italytable i candida te subroutines computed for t1andt2inphase .
subroutine d e p s1 c1dom rooted at node angbracketleft1 angbracketright s1 c2dom rooted at node angbracketleft2 angbracketright ... s1 c3dom rooted at node angbracketleft8 angbracketright s1 c4... angbracketleft9 angbracketright ... ... s2 c1dom rooted at node angbracketleft1 angbracketright s2 c2dom rooted at node angbracketleft2 angbracketright ... if a new subroutine is to be started the algorithm updates the information for the current subroutine sc lines adds sc to the set of candidate subroutines line and re initializes scandlprev line .
however if startnewsubroutine returns false the algorithm simply updates lprev for the next iteration.
in either case it also adds eandstosc.
consider the partitioning of the steps of t1 figure using the dom shown in figure .
the first test step accessesthe registration image which corresponds to node in thedom.
line of algorithm sets l curr to node l prev is undefined .
in the next iteration test step which accessesthe login text box node is processed.
the lca ofnodes and is the root node.
the distance metric on theold lca node and the new lca node evaluates to lcurr dcurr which exceeds the threshold d setting d .
the value we used in our experiments .
thus the processing of the current candidate subroutine is complete itcontains step only and step and node are added to anew candidate subroutine.
next test step is processed forwhich the accessed ui element is node .
the new lca isnode and the distance metric is calculated as .
whichis less than d. therefore step and node are added to the current subroutine.
continuing in this way the algorithmadds steps for which the referenced ui elements occur inthe subtree rooted at node to the current subroutine.
afterstep a new page is loaded on which step is performed thus a new subroutine is initialized.
in the end the algorithm computes four candidate subroutines for t shown in rows of table i. two of the subroutines s1 c1ands1 c3 have only one test step each whereas the remaining two s1 c2ands1 c4 have six and four steps respectively.
similarly two candidate subroutines arecomputed for t shown in the last two rows of table i. the static variant of phase differs from the dynamic variant in two ways.
first at line dcurr is not set to the dom snapshot instead dcurr is built incrementally by adding xpaths to it for the referenced ui elements one at atime.
thus d curr corresponds to the dom induced by the test steps in the current candidate subroutine.
second in thestatic variant startnewsubroutine does not perform the first check that check is redundant because all elements in e always occur in the induced dom.
the dynamic variant can bemore accurate in computing subroutines than the static variant but it comes with the cost of collecting execution traces.
inone of the empirical studies we compared the effectivenessof the dynamic and static variants of phase section iii c .
computation of final subroutines phase starts by grouping the candidate subroutines into subroutine groups.
itthen refines each subgroup possibly splitting a subgroup intosmaller subgroups to compute the final set of subroutines.
asubroutine group s g sc1 ... s ck k is a set of candidate subroutines such that for each pair sci scj sg i negationslash j pi pj.
in other words sgis the set of candidate subroutines that have equivalent path prefixes.
forthe candidate subgroups for our running example table i thetechnique computes four subroutine groups s g1 s1 c1 s2 c1 groups two of the subroutines based on the equivalent pathprefix s g2 s1 c2 s2 c2 groups two subroutines based on the equivalent path prefix the remaining two groups contain one candidate subroutine each.
these subroutine groups are a conservative initial grouping the rest of phase refines the initial groups.
first it analyzesthe overlap of ui elements among the subroutines in a groupto refine the group into smaller groups.
second it computes atotal order of the test steps for a group splitting a group whennecessary to resolve sequencing conflicts.
algorithm presents this analysis it takes as input a set s gof subroutine groups and returns the set sfof final subroutines.
line refine the groups based on elementoverlap.
intuitively the analysis determines the cohesion ofcandidate subroutines in a group based on commonality of thereferenced ui elements.
in this it serves to separate outpotentially incorrect groupings for example two subroutinesthat perform actions on different pages but coincidentally havethe same path prefix because of which they were groupedtogether can be separated based on low element overlap.
theanalysis thus attempts to follow the reasoning that would bedone in identifying page object abstractions manually.
the algorithm iterates over each s giin the input set of subroutine groups line it removes subroutines from sgi untilsgibecomes empty lines creating one or more refined groups sgoin the process.
it first sorts the subroutines insgibased on the sizes of their element sets and initializes the output group sgowith the first subroutine lines .
then it incrementally builds sgoby moving those elements that have a high overlap with the set of doms in sgo.
the parameter edetermines whether a candidate subroutine is moved to sgo.
when the loop in line terminates some or all of the subroutines in sgihave been moved to sgo.
if there are remaining subroutines in sgi this process is repeated.
note that the element intersection in line is computed with respect to the dom objects in the candidate subroutines.in the dynamic variant of phase even elements that arenot referenced in a test case but that occur in the domrooted at the lca appear in the subroutine dom object.
thishas the nice property of accommodating the scenario wheretwo tests navigate to the same form but access different setsof ui elements in the form with little or no overlap.
theelement intersection of these tests as computed in line would still be high because the respective doms contain thenon referenced elements also.
thus the initial grouping ofthese tests is maintained.
however for the static variant of icse florence italyalgorithm computation of final subroutines.
input set sg sg1 ... s gm of subroutine groups output set sf sf1 ... s fn of final subroutines refine sgbased on element overlap to create sg1 1initialize sg1to the empty set 2foreachsgi sgdo whilesgi negationslash do sortsgiin decreasing size of element set e initialize sgo remove the first subroutine from sgiand add it to sgo foreachsc sgido letebe the element set of sc letesbe elements of ethat occur in a dom in sgo if e s e ethen removescfromsgiand add it to sgo addsgotosg1 compute final subroutines from sg1 further refining the subroutine groups in case of conflicts in step sequences 12initialize sfto the empty set foreachsgi sg1do sortsgiin decreasing length of step sequence whilesgi negationslash do remove the first sub.
sc1fromsgiand initialize sfwith it let 1be the step sequence of sc1 initialize graph gwith canonical representation of steps in 1 foreachsc sgido let cbe the sequence of canonical rep. of the steps in sc ifadding ctogdoes not create a cycle in gthen removescfromsgi update test mapping information forg let be the step sequence in topological sort order of g add tosf returnsf phase in which case the subroutine dom is the induced dom algorithm would separate these tests into different subroutine groups because of low element overlap.
after refining sgintosg1 algorithm computes the final subroutines lines which involves creating for eachsubroutine group s ginsg1 a total order of step sequences.
letsg sc1 ... s ck be a subroutine group.
let 1 ... kbe the step sequences in the subroutines in sg with each test step in its canonical representation.
a final subroutine sf is constructed from sg where is an interleaving of 1 ... ksuch that for any i the order of steps in iis preserved in is a function that maps a step to the test cases in which the step occurs.
the total order in a final subroutine must ensure that the order of execution of steps in the original tests is preserved whenthe subroutine is called from those tests.
this is necessary toguarantee behavior preserving subroutine extraction.
considerthe subroutine group s g2for the bookstore example which consists of two candidate subroutines rows and of table i with six steps each five of which are common steps ofs c2which come from test t1and steps of s2 c2 which come from t2.
the total ordering shown in the extracted subroutine in figure preserves the execution order of thesteps from t 1andt2.
in general some precedes relations between test steps must be preserved e.g.
steps must execute before step int2 whereas other relations can be relaxed e.g.
the order of execution of steps and does not matter .
but withoutknowing the semantics of each step it is not possible todetermine which precedes relations can be relaxed.
thus although steps could be reordered in a semantics preservingmanner we take the conservative approach of ensuring thatall precedes relations are preserved in the final subroutine ifconflicts occur the subroutine group is refined via splitting.
the problem of computing a precedence preserving total order and detecting conflicts can be solved by constructinga directed graph in which a cycle indicates conflicts and atopological sort on the final acyclic graph gives a precedence preserving total order.
at a high level this is what algorithm 2does in lines .
it iterates over each subroutine group line and processes each candidate subroutine startingwith the one with the longest step sequence lines .line initializes a graph gin which nodes represent canonical representations of test steps and edges represent theorder of execution among steps.
the graph can have multipleinitial and final nodes.
then for each subroutine s cin the group the algorithm attempts to add the steps of sc in order tog.
if the addition of a step and its outedge results in a cycle ing the algorithm has detected a conflicting sequence.
in that case it omits scand proceeds to the next subroutine.
if the steps in sccause no cycles it is removed from sgi and the step to tests map is updated lines with the newly added steps from sc.
after each subroutine has been processed a topological sort ofggives the total step sequence which along with the map is added to the set of final subroutines lines .
generation of refactored test suite phase uses the set of final subroutine to create the transformed test suite.
thisphase creates a callable subroutine for each final subroutines f insf.
to do this it first determines which statements in execute conditionally and which ones execute unconditionally in other words in all calling contexts .
themapping information maps each test step in to the set of tests containing that step.
thus the union of the tests inthe range of gives the set of tests t cthat forms all calling contexts for sf.
then for any step s i f s tc s executes unconditionally otherwise it executes conditionally.the algorithm creates a formal control parameter and enclosesthe conditionally executing test steps of the subroutine in if statements as illustrated for enterregdetails in figure .
also for each test step that takes a data value the datareference is parameterized.
after creating the subroutines the algorithm refactors each test case by replacing tests steps with calls to the subroutines and adding statements that set up the actual parameters for thecalls with context specific data and control values.
iii.
e mpirical ev alua tion we implemented our technique and conducted three empirical studies using open source web applications to evaluatevarious aspects of the technique.
after describing the experi mental setup we present the results of the studies.
a. experimental setup we implemented the static and dynamic variants of our technique as an extension to ata which is a tool for icse florence italytable ii subjects used in the empirical studies .
test steps subject description tests total avg min max bookstore shopping portal for books classifieds portal for posting and checking advertisements jbilling enterprise billing application tudulist portal for managing personal todos total creating gui tests for web applications.
the implementation analyzes the tests created in ata given a suite of test cases it creates a modularized test suite consisting of selenium test cases coded in java that can be executed using junit.
themodularized test suite consists of parameterized subroutines each of which is a static java method defined in a modules class that takes an array of strings data values and an array ofbooleans control predicates as formal parameters.
a methodis parameterized only if it contains at least one test step thatrequires a data value or that needs to execute conditionally.each transformed ata test case is emitted as a junit test case.
we also implemented a trace collection feature which records the complete browser dom before the execution ofeach test step this is done using the selenium api.
we used four open source web applications as experimental subjects table ii lists the applications.
among these jbilling andtudulist are ajax applications whereas the others are jsp applications.
table ii also presents information about the test cases for the subjects.
we created test suites consisting of func tional test cases.
we designed the test cases to cover vari ous application features.
for example the test cases for bookstore exercise application functionality such as adding modifying or deleting members books orders etc.
the testscover normal scenarios and error scenarios e.g.
attempting to register with an existing user id .
over all subjects wecreated functional tests cases consisting of teststeps.
the average number of test steps ranges from to11 the largest test consisting of steps occurs in the testsuite for bookstore .
the evaluation dataset is available at sites.google.com site irlexternal test modularization.
we automated the test cases using ata and then executed the dynamic and static variants of the implementationto generate modularized selenium test cases.
as a sanity checkfor correctness we executed each refactored test to ensure thatit passed.
at the minimum this guarantees that subroutineextraction does not alter the passing outcome of test cases.
in the first study we used the dynamic variant of the technique which in general is more effective than the staticvariant and the parameter values d .75and e .
.i n the second study we compared the static and dynamic variants using the default parameter values above .
in the final study we evaluated the effects of varying dand e. b. study effectiveness goals and method in the first study we evaluated the effectiveness of our technique.
we collected data about thetable iii sizes of the refactored tests and extracted subroutines .
refactored test steps sub subroutine steps call subject tests tot avg min max routines tot avg min max sites bookstore classifieds jbilling tudulist total reduced lengths of the refactored tests and data about the ex tracted subroutines such as their lengths and number of callingcontexts.
moreover to quantify the simplification attained inthe refactored test suite t r over the original test suite t we used three metrics.
the first metric reduction index ri quantifies the decrease in the number of test steps in tr whereas the second metric call index ci quantifies the reuse via calls to subroutines for a refactored test suite ri summationtext t trst t summationtext s sfst s summationtext t tst t ci sf summationtext s sfcs s where st t is the number of steps excluding calls in test t st s is the number of steps in subroutine s and cs s is the number of calls to s. both ri andci range from zero inclusive to one exclusive with higher values indicatinggreater reduction in test steps and greater reuse respectively.
although high reduction via extraction of highly reusable subroutines is desirable the complexity of the extractedsubroutines in terms of the distinct flows that occur throughthem can make the refactored tests harder to understand thereby negatively impacting the simplification achieved.
toinvestigate this aspect of modularization we define the numberofdistinct behaviors of a subroutine as the distinct sequences of steps abstracting out the data values that execute overall calling contexts of the subroutine.
2our third metric subroutine behavior index bi quantifies this for a refactored test suite bi sf summationtext sf sfdb sf where db sf is the number of distinct behaviors of subroutinesf.bivaries from zero exclusive to one inclusive with higher values indicating fewer distinct behaviors which isdesirable from the perspective of comprehension complexity.
results and analysis table iii presents the basic data about the sizes of the refactored tests and the extracted subroutines.columns show data about the refactored test cases.
arefactored test case can contain ui actions and calls to the ex tracted subroutines in measuring the size of a refactored test we count only the ui actions.
as the data illustrate the testsbecome smaller after subroutine extraction the total numberof test steps decreases from to reduction whereas the average test size over all subjects decreases from 2note that by our definition distinct behaviors are a subset of the linearly independent paths in the control flow graph of a subroutine they represent only those paths that execute in at least one calling context of thesubroutine.
icse florence italy g17 g381 g381 g364 g400 g410 g381 g396 g286 g18 g367 g258 g400 g400 g349 g296 g349 g286 g282 g400 g361 g17 g349 g367 g367 g349 g374 g336 g100 g437 g282 g437 g367 g349 g400 g410 g18 g94 g24 g17 g18 g94 g24 g17 g18 g94 g24 g17 g18 g94 g24 g17 g951 g3 g18 g258 g367 g367 g400 g3 g400 g349 g410 g286 g400 g3 g876 g3 g282 g349 g400 g410 g349 g374 g272 g410 g3 g271 g286 g346 g258 g448 g349 g381 g396 g400 fig.
.
distribution of call sites and distinct behaviors for extracted subroutines cs represents call sites whereas db represents distinct behaviors.
.
to .
.
in three of the subjects the smallest test case ends up containing only subroutine calls and no ui actions indicated by the min values of zero.
columns show data about the extracted subroutines subroutines are extracted over the four subjects containinga total of steps or ui actions .
on average the subroutinescontain about six steps the largest subroutine which occursin tudulist has steps.
thus the technique is able to extract reasonably sized subroutines which are on average more than half as long as the original tests.
the next question about the extracted subroutines is about their reuse how many times are the subroutines called andthus reused by test cases?
the last column of table iii liststhe total number of call sites created in the refactored tests.for example for the subroutines extracted for bookstore call sites are created on average over six call sitesper subroutine.
for jbilling the average is over nine call sites per subroutine.
to provide further details on call sitedistribution figure presents the data for all subroutines usinga boxplot plots labeled cs which shows median value therange of the quartiles and the outliers.
each subroutine has at least two call sites which is ensured by our algorithm it does not extract subroutines that have onlyone caller.
for bookstore jbilling andtudulist or more of the subroutines have four or more calls to them.excluding the data points not plotted 2the maximum numbers of call sites for any subroutine in bookstore classifieds jbilling andtudulist are and respectively.
listing shows an example extracted subroutine for jbilling .f o r jbilling we have test cases that exercise the functionality of adding a new partner.
this requires the tests tonavigate to a registration page in which various details suchas login name password email id etc.
have to be entered.the test cases either save the changes on the page or discardthe changes by clicking cancel.
these steps are extractedinto a subroutine as shown in the top part of listing thebottom part shows call sites from two test cases that invokethe subroutine with appropriate data and control parameters.the illustration in listing is a simplified version of this 3the data is plotted after eliminating three data points one subroutine each inbookstore classifieds and jbilling with call sites respectively.
in each case these are login subroutines that are called from many test cases in some cases at the beginning of test cases and in othercases in the middle of test flows.public static void enter login name password verify password string data boolean control execute enter login n a m e data lo cator false execute enter password data loc ator false execute enter verify password data lo cator false execute enter next payout date data lo cator false execute select rel ated clerk data lo cator false execute enter email data loc ator false if control execute click save changes lo cator false if control execute click cancel loc ator false test case save changes after entering details enter login name password verify password new string partner1 pass123 pass123 clerk1 partner1 xyz .com new boolean true false test case cancel after entering details enter login name password verify password new string partner1 pass123 pass123 clerk1 partner1 xyz .com new boolean false true listing .
an extracted subroutine and two related call sites for jbilling.
table iv simplifica tion achieved in the refactored test suites .
subject reduction index ri call index ci behavior index bi bookstore .
.
.
classifieds .
.
.
jbilling .
.
.
tudulist .
.
.
subroutine the actual subroutine incorporates more steps and is invoked from eight call sites.
we manually examined the subroutines for bookstore classifieds and tudulist to see whether they correspond to pages or forms in those applications.
for classifieds of the subroutines roughly correspond to an applicationpage whereas one subroutine combines elements from twopages member record and registration that have similarforms pertaining to member information.
we found threesimilar instances in bookstore the remaining subroutines correspond to a form.
for tudulist two of the subroutines correspond to login and registration features each of whichis implemented on one page the third subroutine correspondsto the main page which supports different features such asadding deleting or editing lists all of which cause the samepage with the list of available items to be displayed.
table iv shows the data about the reduction call and behavior indexes.
as the data show a significant amount ofreduction or removal of duplication occurs for jbilling and tudulist where the total number of ui action steps in the refactored suites is less than of what they were in theoriginal test suites.
for bookstore andclassifieds the reduction is less but still close to .
the ci values are consistently high for all subjects indicating that the extractedsubroutines have a very high degree of reuse via calls frommultiple call sites.
the behavior index ranges from .
to0.
.
on average the subroutines for tudulist exhibit about four distinct behaviors whereas the subroutines for jbilling exhibit only two distinct behaviors.
figure also shows the distribution of distinct behaviors of subroutines plots labeled db .
in all cases the numberof distinct behaviors is significantly lower than the number ofcallers indicating that multiple call sites invoke a subroutine icse florence italytable v comparison of the dynamic and sta tic v ariants .
dynamic v ariant static v ariant avg avg test sub test sub subject steps sub size ri ci bi steps sub size ri ci bi bookstore .
.
.
.
.
.
classifieds .
.
.
.
.
.
jbilling .
.
.
.
.
.
tudulist .
.
.
.
.
.
t o t a v g .
.
.
.
.
.
.
b g237d b g237s c g237d c g237s j g237d j g237s t g237d t g237s5 sub g237routine steps fig.
.
distribution of subroutine sizes for the dynamic and static variants.
the subject names are abbreviated to their initials d indicates dynamic whereas s represents the static variant.
with the same control parameters.
for classifieds and jbilling none of the subroutines have more than four distinct behaviors for bookstore none of the subroutines have more than five distinct behaviors with of the subroutines having at most three distinct behaviors.
even in thecase of tudulist for which the subroutines exhibit relatively more behaviors most of the subroutines have five or lessdistinct behaviors for the remaining the number of behaviorsranges between six and eight.
c. study comparison of dynamic and static v ariants goals and method in the second study we compared the dynamic and static variants.
in general we expect the dynamic variant to be more effective in extracting subroutines that havehigh reduction and reuse with low distinct behaviors.
wecollected data to compare the variants in terms of the sizesof the refactored tests the number of subroutines the averagesubroutine size the three indexes and execution times.
results and analysis table v presents the data comparing the variants on these metrics.
the dynamic variant identifiesmore subroutines versus that have smaller lengths onaverage .
steps versus steps than the static variant.the dynamic variant also outperforms the static variant on thereduction index and the call index for all subjects.
on the bi metric however the results are mixed and more favorable tothe static variant.
while the dynamic variant is more effectivefor jbilling it is less effective for the other subjects.
this is particularly notable for tudulist where the subroutines for the dynamic variants can have twice as many distinct behaviors four versus two as the subroutines computed by the staticvariant.
for tudulist the dynamic variant computes a large subroutine mentioned earlier which contains steps andhas callers and distinct behaviors.
figure presents the distribution of the subroutine sizes for the dynamic and static variants.
with the exception of g19 g19 g17 g21 g19 g17 g23 g19 g17 g25 g19 g17 g27 g19 g17 g20 g19 g17 g21 g19 g17 g22 g19 g17 g23 g19 g17 g24 g19 g17 g25 g19 g17 g26 g19 g17 g27 g19 g17 g28 g20 g17 g381 g381 g364 g400 g410 g381 g396 g286 g18 g367 g258 g400 g400 g349 g296 g349 g286 g282 g400 g361 g17 g349 g367 g367 g349 g374 g336 g100 g437 g282 g437 g367 g349 g400 g410 g19 g19 g17 g21 g19 g17 g23 g19 g17 g25 g19 g17 g27 g19 g17 g20 g19 g17 g21 g19 g17 g22 g19 g17 g23 g19 g17 g24 g19 g17 g25 g19 g17 g26 g19 g17 g27 g19 g17 g28 g20 fig.
.
effects of varying e horizontal axis on the harmonic mean of ri ci and bi for the dynamic variant top and the static variant bottom .
tudulist the dynamic variant produces smaller subroutines than the static variant and this difference is quite significant forclassifieds andjbilling .
in terms of execution performance the static variant executed in about a second or less for each subject.
the dynamicvariant has a large overhead for loading execution traces afterthe traces are loaded the time for modularaization is roughlythe same as that for the static variant.
for jbilling the execution time was a little over a minute most of which wasspent in loading a 60mb trace file whereas for the othersubjects the dynamic variant took about seconds or less.
d. study effects of the configuration parameters goals and method in the final study we investigated the effects of varying the lca distance parameter d algorithm and the element overlap parameter e algorithm .
we varied dand efrom .
to in increments of .
for both the dynamic and static variants.
as the dependent variable we used the harmonic mean of ri ci and bi which we refer to as the modularization index mi .
the harmonic mean is used as it tends to privilege balanced systems compared toother means such as the arithmetic mean .
results and analysis for d with the dynamic algorithm we did not see any difference in mi whereas with the static variant mi decreased slightly with increase in d before stabilizing.
we next discuss in more detail the results for e for which we observed greater variations in mi.
figure presents the plot of the modularization index against different values of efor the dynamic and static variants.
a general trend that can be observed is that themi values increase monotonically and plateau out around .
with only minor or no increases after that.
there are acouple of notable exceptions in the static case mi continues to increase for jbilling even for e .7and decreases sharply for bookstore for e .
.
based on this data the range .
.
for eseems to offer the best trade off between accommodating candidate subroutines with some diversity tobe merged while also attaining high scores for the reduction call and behavior indexes.
icse florence italymore generally the static variant displays a greater sensitivity to e and therefore greater instability than the dynamic variant which also suggests that the dynamic algorithm is superior to the static algorithm for subroutine extraction.
e. discussion although our results are promising like any empirical study there are threats to the validity of our results.
the most significant of these are threats to external validity which arisewhen the observed results cannot be generalized to otherexperimental setups.
in our study we used four subjects withmanually created functional test suites.
the performance of thetechnique may vary for other subjects and types of test suites e.g.
tests generated via automated techniques with different coverage goals .
iv .
r ela ted work there is a large body of work on automated techniques for generating gui tests based on different notions of coverage in the context of web applications e.g.
and other forms of guis e.g.
.
the tests generated by such techniques are essentially sequencesof gui events e.g.
as illustrated in figure b thus being non modular they can be hard to maintain when intended foruse in regression testing.
this has motivated the developmentof techniques for automatically repairing test cases e.g.
or generating less brittle tests upfront or tests withreliable oracles e.g.
that require less maintenance.
an orthogonal approach toward simplifying maintenance is tomodularize the tests but this has not received much attentionin the testing research community.
the work that comes closest to ours in terms of the objective is the test modularization approach presented by mahmud andlau .
their technique uses supervised machine learning requiring a training sample of subroutines and analyzes testswritten in clearscript .
given a training set ofsubroutines it computes similarity of test case instruction se quences with instructions in the labeled subroutines and usesheuristics to accommodate partial matches and generalizations.the effectiveness of that techniques in general depends onthe diversity of the training set.
moreover it does not analyzethe referenced ui elements and the structure of the navigatedwebpages which can affect its accuracy in two ways.
first twotest steps that read the same in clearscript may in fact referto ui elements on different pages.
therefore similar lookingactions on different pages could be erroneously marked asbelonging to the same subroutine.
second two sequences ofinstructions that reach the same page but perform differentactions on the page would have low similarity but nonetheless could be considered as part of the same subroutine fromthe perspective of maintaining test scripts .
in such cases the technique could fail to identify reusable subroutines.
ourtechnique addresses these issues by analyzing the ui elementsand the structure of the pages accessed in the tests and notrelying on the availability of training samples.
in previous work we presented a technique for merging similar gui tests in a semantics preserving manner .
thegoal was to improve the execution efficiency of gui tests by eliminating repeated executions of the same sequence ofactions in the context of different test cases while preservingthe fault detection effectiveness .
given a suite of gui tests the technique identifies the tests that can be combined andcreates a merged test which covers all the application statesexercised individually by the tests but with the redundantcommon steps executed only once.
in contrast the goal of thiswork is to improve the maintenance efficiency by extracting out reusable subroutines and making gui tests modular.although modularization can simplify maintenance it doesnot improve execution efficiency e.g.
the common steps of t 1andt2 figure execute twice in the contexts of those tests after modularization.
in programming extractmethod code refactoring refers to the extraction of code statements from a given method into an other newly created method.
the end goals of extractmethod code refactoring and our test case modularization are thesame increased modularization and better maintainability.however extractmethod code refactoring is distinct from testcase modularization in the techniques used to achieve theend goal.
method extraction is primarily based on programslicing to make the dependence related statementscontiguous for extraction.
our technique is applicable togui tests cases that consist of sequences of events on theapplication user interface it extracts contiguous events into asubroutine with parameterized data and control flow.
v. s ummary and future work we presented a new technique for automated modularization of gui test cases.
unlike learning based gui test modulariza tion our technique analyzes the