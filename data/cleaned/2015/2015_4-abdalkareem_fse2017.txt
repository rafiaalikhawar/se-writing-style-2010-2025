why do developers use trivial packages?
an empirical case study on npm rabe abdalkareem olivier nourry sultan wehaibi suhaib mujahid and emad shihab data driven analysis of so f tware das lab department of computer science and so f tware engineering concordia university montreal canada frababdu o nourry s alweha s mujahi eshihabg encs.concordia.ca abstract code reuse is traditionally seen as good practice.
recent trends have pushed the concept of code reuse to an extreme by using packages that implement simple and trivial tasks which we call trivial packages .
a recent incident where a trivial package led to the breakdown of some of the most popular web applications such as facebook and net f lix made it imperative to question the growing use of trivial packages.
t herefore in this paper we mine more than npm packages and javascript applications in order to study the prevalence of trivial packages.
we found that trivial packages are common and are increasing in popularity making up .
of the studied npm packages.
we performed a survey with node.js developers who use trivial packages to understand the reasons and drawbacks of their use.
our survey revealed that trivial packages are used because they are perceived to be well implemented and tested pieces of code.
however developers are concerned about maintaining and the risks of breakages due to the extra dependencies trivial packages introduce.
to objectively verify the survey results we empirically validate the most cited reason and drawback and f ind that contrary to developers beliefs only .
of trivial packages even have tests.
however trivial packages appear to be deployment tested and to have similar test usage and community interest as non trivial packages.
on the other hand we found that .
of the studied trivial packages have more than dependencies.
hence developers should be careful about which trivial packages they decide to use.
ccs concepts so f tware and its engineering !so f tware libraries and repositories so f tware maintenance tools keywords javascript node.js code reuse empirical studies permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro f it or commercial advantage and that copies bear this notice and the full citation on the f irst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permi t ted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci f ic permission and or a fee.
request permissions from permissions acm.org.
esec fse paderborn germany acm.
.
.
.
.
.
.3106267acm reference format rabe abdalkareem olivier nourry sultan wehaibi suhaib mujahid and emad shihab.
.
why do developers use trivial packages?
an empirical case study on npm.
inproceedings of 11th joint meeting of the european so f tware engineering conference and the acm sigsoft symposium on the foundations of so f tware engineering paderborn germany september esec fse pages.
.
.
introduction code reuse is o f ten encouraged due to its multiple bene f its.
in fact prior work showed that code reuse can reduce the time to market improve so f tware quality and boost overall productivity .
t herefore it is no surprise that emerging platforms such as node.js encourage reuse and do everything possible to facilitate code sharing o f ten delivered as packages or modules that are available on package management platforms such as the node package manager npm .
however it is not all good news.
t here are many cases where code reuse has had negative effects leading to an increase in maintenance costs and even legal action .
for example in a recent incident code reuse of a node.js package called le f t pad which was used by babel caused interruptions to some of the largest internet sites e.g.
facebook net f lix and airbnb.
many referred to the incident as the case that almost broke the internet .
t hat incident lead to many heated discussions about code reuse sparked by david haney s blog post have we forgo t ten how to program?
.
while the real reason for the le f t pad incident was that npm allowed authors to unpublish packages a problem which has been resolved it raised awareness of the broader issue of taking on dependencies for trivial tasks that can be easily implemented .
since then there have been many discussions about the use of trivial packages.
loosely de f ined a trivial package is a package that contains code that a developer can easily code him herself and hence is not worth taking on an extra dependency for .
many developers agreed with haney s position which stated that every serious developer knows that small modules are only nice in theory suggesting that developers should implement such functions themselves rather than taking on dependencies for trivial tasks.
other work showed thatnpm packages tend to have a large number of dependencies and highlighted that developers need to use caution since some dependencies can grow exponentially .
in fact in our dataset we found that more than of the trivial packages have more than dependencies.esec fse september paderborn germany r. abdalkareem et al.
so the million dollar question is why do developers resort to using a package for trivial tasks such as checking if a variable is an array?
at the same time other questions regarding how prevalent trivial packages are and what the potential drawbacks of using these trivial packages remain unanswered.
t herefore we performs an empirical study involving more than npm packages and javascript applications to be t ter understand why developers resort to using trivial packages.
our empirical study is qualitative in nature and is based on survey results from node.js developers.
we also quantitatively validate the most commonly developer cited reason and drawback related to the use of trivial packages.
since to the best of our knowledge this is the f irst study to examine why developers use trivial packages we f irst propose a de f inition of what constitutes a trivial package based on feedback from javascript developers.
we also examine how prevalent trivial packages are in npm and how widely they are used in node.js applications.
our f indings indicate that trivial packages are common and popular.
of the npm packages in our dataset .
of them are trivial packages.
moreover of the node.js applications on github .
of them directly depend on one or more trivial packages.
most developers do not consider the use of trivial packages as bad practice.
in our survey of the javascript developers .
of them said they do not consider the use of trivial packages as bad practice whereas only .
consider it to be a bad practice.
t his f inding shows that there is not a clear consensus on the issue of trivial package use.
trivial packages provide well implemented and tested code and increase productivity.
developers believe that trivial packages provide them with well implemented tested code and increase productivity.
at the same time the increase in dependency overhead and the risk of breakage of their applications are the two most cited drawbacks.
developers need to be careful which trivial packages they use.
our empirical f indings show that many trivial packages have their own dependencies.
in fact we found that .
of trivial packages have at least one dependency and .
of trivial packages have more than dependencies.
in addition to the aforementioned f indings our study provides the following key contributions we provide a way to quantitatively determine trivial packages.
to the best of our knowledge this is the f irst study to examine the prevalence reasons for and drawbacks of using trivial packages in node.js applications.
our study is also one of the largest studies on javascript applications involving a survey of more than javascript developers npm packages and node.js applications.
we perform an empirical study to validate the most commonly cited reasons for and drawbacks of using trivial packages in our developer survey.
we make our dataset of the responses provided by the npm developers publicly available.
t he paper is organized as follows section provides the background and introduces our datasets.
section presents how we determine what a trivial package is.
section examines the prevalence 1h t tp das.encs.concordia.ca publications npm survey data of trivial packages and their use in node.js applications.
section presents the results of our developer survey presenting the reasons and perceived drawbacks for developers who use trivial packages.
section presents our empirical validation of the most commonly cited reason for and drawback of using trivial packages.
t he implications of our f indings are noted in section .
we discuss the related works in section the limitations of our study in section and present our conclusions in section .
background and datasets javascript is used to write client and server side applications.
its popularity has steadily grown thanks to popular frameworks such as node.js and an active developer community .
javascript projects can be classi f ied into two main categories packages that are used in other projects or applications that are used as standalone so f tware.
t he node package manager npm provides tools to manage node.js packages.
npm is the official package manager for node.js and its registry contains more than packages .
to perform our study we gather two datasets from two sources.
we obtain node.js packages from the npm registry and applications that use npm packages from github.
packages since we are interested in examining the impact of trivial packages we mined the latest version of all the node.js packages from npm as of may .
for each package we obtained its source code from github.
in some cases the package publisher did not provide a github link in which case we obtained the source code directly from npm.
in total we mined packages.
applications we also want to examine the use of the packages in javascript applications.
t herefore we mined all of the node.js applications on github.
to ensure that we are indeed only obtaining the applications from github and not npm packages we compare the url of the github repositories to all of the urls we obtained from npm for the packages.
if a url from github was also in npm we f lagged it as being an npm package and removed it from the application list.
to determine that an application uses npm packages we looked for the package.json f ile which speci f ies amongst others the npm package dependencies used by the application.
to eliminate dummy applications that may exist in github we choose non forked applications with more than commits and more than developers.
similar f iltering criteria were use in prior work by kalliamvakou et al.
.
in total we obtained javascript applications and a f ter removing applications that did not use the npm platform we were le f t with applications.
what are trivial packages anyway?
although what a trivial package is has been loosely de f ined in the past e.g.
in blogs we want a more precise and objective way to determine trivial packages.
to determine what constitutes a trivial package we conducted a survey where we asked participants what they considered to be a trivial package and what indicators they used to determine if a package is trivial or not.
we devised an online survey that presented the source code of randomly selected node.js packages that range in size between javascript lines of code loc .
participants were asked to indicate if they thought the package was trivial or not and specify what indicators they use to determine a trivial package.
we opted towhy do developers use trivial packages?
an empirical case study on npm esec fse september paderborn germany limit the size of the node.js packages in the survey to a maximum of javascript loc since we did not want to overwhelm the participants with the review of excessive amounts of code.
we asked the survey participants to indicate trivial packages from the list of node.js packages provided.
we provided the survey participants with a loose de f inition of what a trivial package is i.e.
a package that contains code that they can easily code themselves and hence is not worth taking on an extra dependency for.
figure shows an example of a trivial package called is positive which simply checks if a number is positive.
t he survey questions were divided into three parts questions about the participant s development background questions about the classi f ication of the provided node.js packages and questions about what indicators the participant would use to determine a trivial package.
we sent the survey to developers and colleagues that were familiar with javascript development and received a total of responses.
1module .
exports function n return tostring .
call n quotesingle.var quotesingle.var n figure package is positive on npm participants background and experience.
of the respondents are undergraduate students are graduate students and are professional developers.
ten of the respondents have at least years of javascript experience and half of the participants have been developing with javascript for more than f ive years.
survey responses.
we asked participants to list what indicators they use to determine if a package is trivial or not and to indicate all the packages that they considered to be trivial.
of the participants state that the complexity of the code and state that size of the code are indicators they use to determine a trivial package.
another mentioned that they used code comments and other indicators e.g.
functionality to indicate if a package is trivial or not.
since it is clear that size and complexity are the most common indicators of trivial packages we use these two measures to determine trivial packages.
it should be mentioned that participants could provide more than indicator hence the percentages above sum to more than .
next we analyze all of the packages that were marked as trivial.
in total we received votes for the packages.
we ranked the packages in ascending order based on their size and tallied the votes for the most voted packages.
we f ind that of the votes consider packages that are less than lines of code to be trivial.
we also examine the complexity of the packages using mccabe s cyclomatic complexity and f ind that of the votes marked packages that have a total complexity value of or lower to be trivial.
it is important to note that although we provide the source code of the packages to the participants we do not explicitly provide the size or the complexity of the packages to the participants so they are not biased by any metrics i.e.
size or complexity in their classi f ication.
based on the aforementioned f indings we used the two indicators javascript loc and complexity to determine trivial packages in our dataset.
hence we de f ine trivial packages as xloc xcomplexit y.alt where xloc represents the javascript loc and xcomplexit y.altrepresents mccabe s cyclomatic complexity of package x. although we use the aforementioned 25percentage of trivial to all packages published on npm2011 2016npm prevents publishers from unpublishing their packages april 1st figure percentage of published trivial packages on npm .
measures to determine trivial packages we do not consider this to be the only possible way to determine trivial packages.
our survey indicates that size and complexity are commonly used measures to determine if a package is trivial.
based on our analysis packages that have javascript loc and a mccabe s cyclomatic complexity are considered to be trivial.
how prevalent are trivial packages?
in this section we want to know how prevalent trivial packages are.
we examine prevalence from two aspects the f irst aspect is from npm s perspective where we are interested in knowing how many of the packages on npm are trivial.
t he second aspect considers the use of trivial packages in javascript applications.
.
how many of npm s packages are trivial?
we use the two measures loc and complexity to determine trivial packages which we now use to quantify the number of trivial packages in our dataset.
our dataset contained a total of npm packages.
for each package we calculated the number of javascript code lines and removed packages that had zero loc which removed packages.
t his le f t us with a f inal number of packages.
t hen for each package we removed test code since we are mostly interested in the actual source code of the packages.
to identify and remove the test code similar to prior work we look for the term test and its variants in the f ile names and f ile paths.
out of the npm packages we mined .
packages are trivial packages.
in addition we examined the growth of trivial packages in npm.
figure shows the percentage of trivial to all packages published on npm per month.
we see an increasing trend in the number of trivial packages over time and approximately of the packages added every month are trivial packages.
we investigated the spike around march and found that this spike corresponds to the time when npm disallowed the un publishing of packages .
npm posts the most depended upon packages on its website .
we measured the number of trivial packages that exist in the top most depended upon packages we f ind that of them are trivial packages.
t his f inding shows that trivial packages are not only prevalent and increasing in number but they are also veryesec fse september paderborn germany r. abdalkareem et al.
popular among developers making up .
of the most depended on npm packages.
trivial packages make up .
of the studied npm packages.
moreover the proportion of trivial packages is increasing and trivial packages make up .
of the top most depended on npm packages.
.
how many applications depend on trivial packages?
just because trivial packages exist on npm it does not mean that they are actually being used.
t herefore we also examine the number of applications that use trivial packages.
to do so we examine the package.json f ile which contains all the dependencies that an application installs from npm.
however in some cases an application may install a package but not use it.
to avoid counting such instances we parse the javascript code of all the examined applications and use regular expressions to detect the require dependency statements which indicates that the application actually uses the package in its code2.
finally we measured the number of packages that are trivial in the set of packages used by the applications.
note that we only consider npm packages since it is the most popular package manager for node.js packages and other package managers only manage a subset of packages e.g.
bower only manages front end client side frameworks libraries and modules .
we f ind that of the applications in our data set .
directly depend on at least one trivial package.
of the node.js applications in our dataset .
of them depend on at least one trivial package.
survey results we surveyed node.js developers to understand the reasons for and the drawbacks of using trivial packages.
we use a survey because it allows us to obtain f irst hand information from the developers who use these trivial packages.
in order to select the most relevant participants we sent out the survey to developers who use trivial packages.
we used git s pickaxe command on the lines that contain the required dependency statements in the applications a procedure that provided us with the email and name of the developer who introduced the trivial package dependency.
survey participants.
to mitigate the possibility of introducing misunderstood or misleading questions we initially sent the survey to two javascript developers and incorporated their minor suggestions to improve the survey.
next we sent the survey to developers from applications.
to select the developers we ranked them based on the number of trivial packages they use.
we then took a sample of developers that use trivial packages the most and another of those that indicated the least use of trivial packages.
t he survey was emailed to the selected developers however since some of the emails were returned for various reasons e.g.
the email account does not exist anymore etc.
we could only reach developers.
t he survey listed the trivial package and the application that we detected the trivial package in.
we received responses to 2note that if a package is required in the application but does not exist it will break the application.our survey which translates to a response rate of .
.
our survey response rate is in line with and even higher than the typical response rate reported in questionnaire based so f tware engineering surveys .
of the respondents of them identi f ied as developers working either in industry or as a full time independent developers .
t he remaining identi f ied as being a casual developers or other including one student and two developers working in executive positions at npm.
as for the development experience of the survey respondents the majority of the respondents have more than years of experience have between years and have years of experience.
t he fact that most of the respondents are experienced javascript developers gives us con f idence in our survey responses.
.
do developers consider trivial packages harmful?
t he f irst question of our survey to the participants is do you consider the use of trivial packages as bad practice?
t he reason to ask this question so bluntly is that it allows us to gauge in a very deterministic way how the node.js developers felt about the issue of using trivial packages.
we provided three possible replies yes no or other in which case they were provided with a text box to elaborate.
of the participants .
stated that they do not consider the use of trivial packages as bad practice.
another .
stated that they indeed think that using trivial package is a bad practice.
t he remaining .
stated that it really depends on the circumstances such as the time available how critical a piece of code is and if the package used has been thoroughly tested.
most of the surveyed developers .
do not believe that using trivial packages is a bad practice.
.
why do developers use trivial packages?
while we have answered the question as to whether developers think using trivial packages is a bad practice what we are most interested in is why do developers resort to using trivial packages and what do they view as the drawbacks of using trivial packages.
t herefore the second part of the survey asks participants to list the reasons why they resort to using trivial packages.
to ensure that we do not bias the responses of the developers the answer f ields for these questions were in free form text i.e.
no predetermined suggestions were provided.
a f ter gathering all of the responses we grouped and categorized the responses in a two phase iterative process.
in the f irst phase the f irst two authors carefully read the participant s answers and came up with a number of categories that the responses fell under.
next they discussed their groupings and agreed on the extracted categories.
whenever they failed to agree on a category a third author was asked to help break the tie.
once all of the categories were decided the same two authors went through all the answers again and classi f ied them into their respective categories.
for the majority of the cases the two authors agreed on most categories and the classi f ications of the responses.
to measure the agreement between the two authors we used cohen s kappa coefficient .
t he cohen s kappa coefficient has been used to evaluate inter rater agreement levels for categorical scales and provides the proportion of agreement corrected for chance.
t he resulting coefficient is scaled to range between andwhy do developers use trivial packages?
an empirical case study on npm esec fse september paderborn germany table reasons for using trivial packages.
reason description resp.
well implemented tested participants state that trivial packages are effectively implemented and tested.
.
increased productivity trivial packages reduce the time needed to implement existing source code.
.
well maintained code it eases source code maintenance since other developers maintain the trivial package.
.
improved readability reduced complexityusing trivial packages improve the source code quality in terms of readability and reduce complexity.
.
be t ter performance trivial packages improve the performance of web applications compared to the use of large frameworks.
.
no reason .
where a negative value means less than chance agreement zero indicates exactly chance agreement and a positive value indicates be t ter than chance agreement .
in our categorization the level of agreement measured between the authors was of .
which is considered to be an excellent inter rater agreement.
table shows the f ive reasons for using trivial packages as reported by our survey respondents another category was used to group the no reason responses.
table presents the different reasons a description of each category and its frequency.
t hese reasons are listed below in order of their popularity r1.
well implemented tested .
t he most cited reason for using trivial packages is that they provide well implemented and tested code.
more than half of the responses mentioned this reason.
in particular although it may be easy for developers to code these trivial packages themselves it is more difficult to make sure that all the details are addressed e.g.
one needs to carefully consider all edge cases.
some example responses that mention these issues are stated by participants p68 and p4 who cite their reasons for using trivial packages as follows p68 tests already wri t ten a lot of edge cases captured .
p4 t here may be a more elegant efficient correct cross environment complatible solution to a trivial problem than yours .
r2.
increased productivity .
t he second most cited reason is the improved productivity that using trivial packages enables.
trivial tasks or not writing code on your own requires time and effort hence many developers view the use of trivial packages as a way to boost their productivity.
in particular early on in a project a developer does not want to worry about small details they would rather focus their efforts on implementing the more difficult tasks.
for example participants p13 and p27 state p13 and it does save time to not have to think about how best to implement even the simple things.
p27 don t reinvent the wheel!
if the task has been done before.
.
t he aforementioned are clear examples of how developers would rather not code something even if it is trivial.
of course this comes at a cost which we discuss later.
r3.
well maintained code .
a less common but cited reason for using trivial packages is the fact that the maintenance of the code need not to be performed by the developers themselves in essence it is outsourced to the community or the contributors of the trivial packages.
for example participant p45 states also a highly used trivial package is probable to be well maintained.
.
even tasks such as bug f ixes are dealt with by the contributors of thetrivial packages which is very a t tractive to the users of the trivial packages as reported by participant p80 leveraging feedback from a larger community to f ix bugs etc.
r4.
improved readability reduced complexity .
participants also reported that using trivial packages improves the readability and reduces the complexity of their code.
for example p34 states immediate clarity of use and readability for other developers for commonly used packages p47 states simple abstract brings less complexity.
r5.
better performance .
a few of the participants stated that using trivial packages improves performance since it alleviates the need for their application to depend on large frameworks.
for example p35 states you do not depend on some huge utility library of which you do not need the most part.
only a small percentage .
of the respondents stated that they do not see a reason to use trivial packages.
the two most cited reasons for using trivial packages are they provide well implemented and tested code and they increase productivity.
.
drawbacks of using trivial packages in addition to knowing the reasons why developers resort to trivial packages we wanted to understand the other side of the coin what they perceive to be the drawbacks of their decision to use these packages.
t he drawbacks question was part of our survey and we followed the same aforementioned process to analyze the survey responses.
in the case of the drawbacks the cohen s kappa agreement measure was .
which is considered to be an excellent agreement.
table lists the drawback mentioned by the survey respondents along with a brief description and the frequency of each drawback.
i1.
dependency overhead .
t he most cited drawback of using trivial packages is the increased dependency overhead e.g.
keeping all dependencies up to date and dealing with complex dependency chains that developers need to bear .
t his situation is o f ten referred to as dependency hell especially when the trivial packages themselves have additional dependencies.
t his drawback came through clearly in many comments for example p41 states people who don t actively manage their dependency versions could exposed to serious problems p40 hard to maintain a lot of tiny packages .
hence while trivial packages may provide wellesec fse september paderborn germany r. abdalkareem et al.
table drawbacks of using trivial packages.
drawback description resp.
dependency overhead using trivial packages results in a dependency mess that is hard to update and maintain.
.
breakage of applicationsdepending on a trivial package could cause the application to break if the package becomes unavailable or has a breaking update.
.
decreased performancetrivial packages decrease the performance of applications which includes the time to install and build the application.
.
slows development finding a relevant and high quality trivial package is a challenging and time consuming task.
.
missed learning opportunities t he practice of using trivial packages leads to developers not learning and experiencing writing code for trivial tasks.
.
security using trivial packages can open a door for security vulnerability.
.
licensing issues using trivial packages could cause licensing con f licts.
.
no drawbacks .
implemented tested code and improve productivity developers are clearly aware that the management of the additional dependencies is something they need to deal with.
i2.
breakage of applications .
developers also worry about the potential breakage of their application due to a speci f ic package or version becoming unavailable.
for example in the le f tpad issue the main reason for the breakage was the removal of le f t pad p4 states obviously the whole le f t pad crash exposed an issue .
however since that incident npm has disabled the possibility of a package to be removed .
although disallowing the removal solves part of the problem packages can still be updated which may break an application.
for a non trivial package it may be worth it to take the risk however for trivial packages it may not be worth taking such a risk.
i3.
decreased performance .
t his issue is related to the dependency overhead drawback.
developers mentioned that incurring the additional dependencies slowed down the build time and increased application installation times.
for example p64 states too many metadata to download and store than a real code.
p34 states slow installs can make project noisy and unintuitive by a t tempting to cobble together too many disparate pieces instead of more targeted code.
.
as mentioned earlier in some cases it is not just the fact that the trivial package adds a dependency but in some cases the trivial package itself depends on additional packages which negatively impacts performance even further.
i4.
slows development .
in some cases the use of trivial packages may actually have a reverse effect and slow down development.
for example as p23 and p15 state p23 can actually slow the team down as no ma t ter how trivial a package if a developer hasn t required it themselves they will have to read the docs in order to double check what it does rather than just reading a few lines of your own source.
p15 we have the problem of locating packages that are both useful and trustworthy it can be difficult to f ind a relevant and trustworthy package.
even if others try to build on your code it is much more difficult to go fetch a package and learn it rather than read a few lines of your code.
i5.
missed learning opportunities .
in certain cases the use of these trivial packages is seen as a missed learning opportunityfor developers.
for example p24 states sometimes people forget how to do things and that could lead to a lack of control and knowledge of the language technology you are using .
t his is a clear example of where just using a package rather than coding the solution yourself will lead to less knowledge about the code base.
i6.
security .
in some cases the trivial packages may have security f laws that make the application more vulnerable.
t his is an issue pointed out by a few developers for example as p15 mentioned earlier it is difficult to f ind packages that are trustworthy.
p57 also mentions if you depend on public trivial packages then you should be very careful when selecting packages for security reasons .
as in the case of any dependency one takes on there is always a chance that a security vulnerability could be exposed in one of these packages.
i7.
licensing issues .
in some cases developers are concerned about potential licensing con f licts that trivial packages may cause.
for example p73 states possibly license issues p62 there is a risk that the trivial package might be licensed under the gpl must be replaced anyway prior to shipping.
t here were also of the responses that stated they do not see any drawbacks with using trivial packages.
the two most cited drawbacks of using trivial packages are they increase dependency overhead and they may break their applications due to a package or a speci f ic version becoming unavailable or incompatible.
putting developer perception under the microscope t he developer survey provided us with great insights on why developers use trivial packages and what they perceive to be their drawbacks.
however whether there is empirical evidence to support their perceptions remains unexplored.
t hus we examine the most commonly cited reason for using trivial packages i.e.
the fact that trivial packages are well tested and drawback i.e.
the impact of additional dependencies based on our f indings in section .why do developers use trivial packages?
an empirical case study on npm esec fse september paderborn germany .
.
.
.
.
.0trivialnon trivialtests value a tests trivialnon trivialcommunity interest value log scaled b community interest trivialnon trivialdownloads count value log scaled c download count figure distribution of tests community interest and download count metrics.
.
examining the well tested perception as shown in table .
of the responses indicate that they use trivial packages since they are well implemented and tested.
and the developers have good reasons to believe so.
npm requires that developers provide a test script name with the submission of their packages listed in the package.json f ile .
in fact .
out of of the trivial packages in our dataset have some test script name listed.
however since developers can provide any script name under this f ield it is difficult to know if a package is actually tested.
we examine whether a package is really well tested and implemented from two aspects f irst we check if a package has tests wri t ten for it.
second since in many cases developers consider packages to be deployment tested we also consider the usage of a package as an indicator of it being well tested and implemented .
to carefully examine whether a package is really well tested and implemented we use the npm online search tool known as npms to measure various metrics related to how well the packages are tested used and valued.
to provide its ranking of the packages npms mines and calculates a number of metrics based on development e.g.
tests and usage e.g.
no.
of downloads data.
we use three metrics measured by npms to validate the well tested and implemented perception of developers which are3 tests considers the tests size coverage percentage and build status for a project.
we looked into the npms source code and f ind that the tests metric is calculated as testssize buildstatus co v.altera afii10069.italepercenta afii10069.itale .
we use the tests metric to determine if a package is tested and how trivial packages compare to non trivial packages in terms of how well tested they are.
one example that motives us to investigate how well tested a trivial package is the response by p68 who says tests already wri t ten a lot edge cases captured .
.
community interest evaluates the community interest in the packages using the number of stars on github npm forks subscribers and contributors.
once again we f ind through the source code of npms that community interest is simply the sum of the aforementioned metrics measured as starscount f orkscount subscriberscount contributorscount .
we use this metric to compare how interested the community is in trivial and non trivial 3it is important to note that the motivation and full derivation e.g.
why they put a weight of .
on the test coverage etc.
of the metrics is beyond the scope of this paper.
we refer interested readers to the npms documentation for more details .
to make our paper self sufficient we include how the metrics are calculated here.table mann whitney test p value and cliff s delta d for trivial vs. non trivial packages metrics p value d tests .2e .
small community interest .2e .
small downloads count .2e .
small packages.
we measure the community interest since developers view the importance of the trivial packages as evidence of its quality as stated by p56 who says using an isolated module that is well tested and ve t ted by a large community helps to mitigate the chance of small bugs creeping in.
.
download count measures the mean downloads for the last three months.
again the number of downloads of a package is o f ten viewed as an indicator of the package s quality as p61 mentions this code is tested and used by many which makes it more trustful and reliable.
.
as an initial step we calculate the number of trivial packages that have a tests value greater than zero which means trivial packages that have some of tests.
we f ind that only .
of the trivial packages have tests i.e.
a tests value .
in addition we compare the values of the tests community interest and download count for trivial and non trivial packages.
our focus is on the values of the aforementioned metric values for trivial packages however we also present the results for non trivial packages to put our results in context.
figure shows the bean plots for the tests community interest and download count.
t he f igures show that in all cases trivial packages have on median a smaller tests value community interest value and download count compared to non trivial packages.
t hat said we observe from figure a that the distribution of the tests metric is similar for both trivial and non trivial packages.
most packages have a tests value of zero then there are small pockets of packages that have values of aprox.
.
.
.
and .
.
in the case of the community interest and download count metrics once again we see similar distributions although clearly the median values are lower for trivial packages.
to examine whether the difference in metric values between trivial and non trivial packages is statistically signi f icant we performed a mann whitney test to compare the two distributions and determine if the difference is statistically signi f icant with a p value .
we also use cliff s delta d which is a non parametric effect size measure to interpret the effect size between trivial and non trivial packages.
as suggested in we interpret the effect size value to be small for d .
positive as well as negative values medium for .
d .
and large for d .
.
table shows the p values and effect size values.
we observe that in all cases the differences are statistically signi f icant however the effect size is small.
t he results show that although the majority of trivial packages do not have tests wri t ten for them and have statistically lower tests community interest and download count values their effect size is smaller than non trivial packages.esec fse september paderborn germany r. abdalkareem et al.
number of releases log scaled non trivial packages trivial packages figure number of releases for trivial packages compared to non trivial packages.
number of direct indirect dependencies log scaled non trivial packages trivial packages figure distribution of direct indirect dependencies for trivial and non trivial packages p value .2e cliff s delta d .
small .
contrary to developers perception only .
of trivial packages actually have tests.
albeit trivial packages have lower tests community interest and download count values the values of the metrics do not seem to have a large difference compared to non trivial packages i.e.
trivial packages are similar to non trivial packages in terms of how well they are tested.
.
examining the dependency overhead perception as discussed in section the top cited drawback of using trivial packages is the fact that developers need to take on and maintain extra dependencies i.e dependency overhead.
examining the impact of dependencies is a complex and well studied issue e.g .
that can be examined in a multitude of ways.
we choose to examine the issue from both the application and the package perspectives.
applications when compared to coding trivial tasks themselves using a trivial package imposes extra dependencies.
one of the most problematic aspects of managing dependencies for applications is when these dependencies update causing a potential to break their application.
t herefore as a f irst step we examined the number of releases for trivial and non trivial packages.
t he intuition here is that developers need to put in extra effort to assure the proper integration of new releases.
figure shows that trivial packages have less releases than non trivial packages median is for trivial and for non trivial packages hence trivial packages do not require more effort than non trivial packages.
t he fact that the trivial packages are updated less frequently may be a t tributed to the fact that trivial packages perform less functionality hence they need to be updated less frequently.table percentage of packages vs. the number of dependencies used.
npm packages dependencies direct indirect zero trivial .
.
.
.
non trivial .
.
.
.
next we examined how developers choose to deal with the updates of trivial packages.
one way that application developers reduce the risk of a package impacting their application is to version lock the package.
version locking a dependency package means that it is not updated automatically and that only the speci f ic version mentioned in the packages.json f ile is used.
as stated in a few responses from our survey e.g.
p8 also people who don t lock down their versions are in for some pain.
.
t here are different types of version locks i.e.
only updating major releases updating patches only updating minor releases or no lock at all which means the package automatically updates.
t he version locks are speci f ied in the packages.json f ile next to every package name.
we examined the frequency at which trivial and non trivial packages are locked.
we f ind that on average trivial packages are locked .
of the time whereas non trivial packages are locked .
of the time.
however the wilcox test shows that the difference is not statistically signi f icant p value .
.
hence we cannot say that developers version lock trivial packages more.
packages at the package level we investigate the direct and indirect dependencies of trivial packages.
in particular we would like to determine if the trivial packages have their own dependencies which makes the dependency chain even more complex.
for each trivial and non trivial package we install it and then count the actual number of direct and indirect dependencies that the package requires.
so allows us to know the true direct and indirect dependencies that each package requires.
note that simply looking into the .json f ile and the require statements will provide the direct dependencies but not the indirect dependencies.
figure shows the distribution of dependencies for trivial and non trivial packages.
since most trivial packages have no dependencies the median is .
t herefore we bin the trivial packages based on the number of their dependencies and calculate the percentage of packages in each bin.
table shows the percentage of packages and their respective number of dependencies.
we observe that the majority of trivial packages .
have zero dependencies .
have between dependencies .
have between dependencies and .
have more than dependencies.
t he table shows that some of the trivial packages have many dependencies which indicates that indeed trivial packages can introduce signi f icant dependency overhead.
trivial packages have fewer releases and developers are less likely to be version locked than non trivial packages.
that said developers should be careful when using trivial packages since in some cases trivial packages can have numerous dependencies.
in fact we f ind that .
of trivial packages have at least one dependency and .
of trivial packages have more than dependencies.why do developers use trivial packages?
an empirical case study on npm esec fse september paderborn germany relevance and implications a common question that is asked in empirical studies is so what?
what are the implications of your f indings?
why would practitioners care about your f indings?
we discuss the issue of relevance of our study to the developer community based on the responses of our survey and highlight some of the implications of our study.
.
relevance do practitioners care?
at the start of the study we were not sure how practically relevant our study of trivial packages is.
however we were surprised by the interest of developers in our study.
in fact one of the developers p39 explicitly mentioned the lack of research on this topic stating t here has not been enough research on this but i ve been taking note of people s proposed quick and simple code to handle the functionality of trivial packages and it s surprised me to see the high percentage of times the proposed code is buggy or incomplete.
moreover when we conducted our study we asked respondents if they would like to know the outcome of our study and if so they provide us with an email address.
of the respondents aprox.
of them provided their email for us to provide them with the outcomes of our study.
some of these respondents hold very high level leadership roles in npm.
to us this is an indicator that our study and its outcomes are of high relevance to the npm and node.js development community.
.
implications of our study our study has a number of implications on both so f tware engineering research and practice.
implications for future research our study mostly focused on determining the prevalence reasons for and drawbacks of using trivial packages.
based on our f indings we f ind a number of implications motivations for future work.
first our survey respondents indicated that the choice to use trivial packages is not black or white.
in many cases it depends on the team and the project.
for example one survey respondent stated that on his team less experienced developers are more likely to use trivial packages whereas the more experienced developers would rather write their own code for trivial tasks.
t he issue here is that the experienced developers are more likely to trust their own code while the less experienced are more likely to trust an external package.
another aspect is the maturity of the project.
as some of the survey respondents pointed out they are much more likely use trivial packages early on in the project so they do not waste time on trivial tasks and focus on the more fundamental tasks of their project.
however once their project matures they start to look for ways to reduce dependencies since they pose potential points of failure for their project.
hence our study motivates future work to examine the relationship between team experience and project maturity and the use of trivial packages.
second survey respondents also pointed out that using trivial packages is seen favourably compared to using code from q a sites such as stackover f low or reddit.
when compared to using code on stackover f low where the developer does not know who posted the code who else uses it or whether the code may have tests or not using a trivial package that is on npm is a much be t ter option.
in this case using trivial packages is not seen as the bestchoice but it is certainly a be t ter choice.
although there have been many studies that examined how developers use q a sites such as stackover f low we are not aware of any studies that compare code reuse from q a sites and trivial packages.
our f indings motivate the need for such a study.
practical implications a direct implication of our f indings is that trivial packages are commonly used by others perhaps indicating that developers do not view their use as bad practice.
moreover developers should not assume that all trivial packages are well implemented and tested since our f indings show otherwise.
npm developers need to expect more trivial packages to be submi t ted making the task of f inding the most relevant package even harder.
hence the issue of how to manage and help developers f ind the best packages needs to be addressed.
to some extent npms has been recently adopted by npm to speci f ically address the aforementioned issue.
developers highlighted that the lack of a decent core or standard javascript library causes them to resort to trivial packages.
o f ten they do not want to install large frameworks just to leverage small parts of the framework hence they resort to using trivial packages.
t herefore there is a need by the node.js community to create a standard javascript api or library in order to reduce the dependence on trivial packages.
however the issue of creating such a standard javascript library is under much debate .
related work studies of code reuse.
prior research on code reuse has been shown its many bene f its which include improving quality development speed and reducing development and maintenance costs .
for example sojer and henkel surveyed open source developers to investigate how they reuse code.
t heir f indings show that more experienced developers reuse source code and of the functionality of open source so f tware oss projects reuse existing components.
developers also reveal that they see code reuse as a quick way to start new projects.
similarly hae f liger et al.
conducted a study to empirically investigate the reuse in open source so f tware and the development practices of developers in oss.
t hey triangulated three sources of data developer interviews code inspections and mailing list data of six oss projects.
t heir results showed that developers used tools and relied on standards when reusing components.
mockus conducted an empirical study to identify large scale reuse of open source libraries.
t heir study shows that more than of source f iles include code from other oss libraries.
on the other hand the practice of reusing source code has some challenging drawbacks including the effort and resource required to integrate reused code .
furthermore a bug in the reused component could propagate to the target system .
while our study corroborates some of these f indings the main goal is to de f ine and empirically investigate the phenomenon of reusing trivial packages in particular in node.js applications.
studies of other ecosystems.
in recent years analyzing the characteristics of ecosystems in so f tware engineering has gained momentum .
for example in a recent study bogart et al.
empirically studied three ecosystems including npm and found that developers struggle with changing versions as they might break dependent code.
wi t ter et al.
investigated the evolution of the npm ecosystem in an extensive study that covers the dependence between npm packages download metrics and theesec fse september paderborn germany r. abdalkareem et al.
usage of npm packages in real applications.
one of their main f indings is that npm packages and updates of these packages is steadily growing.
also more than of packages have at least one direct dependency package.
other studies examined the size characteristics of packages in an ecosystem.
german et al.
studied the evolution of the statistical computing project gnu r with the aim of analyzing the differences between code characteristics of core and user contributed packages.
t hey found that user contributed packages are growing faster than core packages.
additionally they reported that user contributed packages are typically smaller than core packages in the r ecosystem.
kabbedijk and jansen analyzed the ruby ecosystem and found that many small and large projects are interconnected.
in many ways our study complements the previous work since instead of focusing on all packages in an ecosystem we speci f ically focus on trivial packages.
moreover we examine the reasons developers use trivial package and what they view as their drawbacks.
we study the reuse of trivial packages which is a subset of general code reuse.
hence we do expect there to be some overlap with prior work.
like many empirical studies we con f irm some of the prior f indings which is a contribution on its own.
moreover our paper adds to the prior f indings through for example our validation of the developers assumptions.
lastly we do believe our study f ills a real gap since of the participants said they wanted to know our study outcomes.
threats to validity construct validity considers the relationship between theory and observation in case the measured variables do not measure the actual factors.
to de f ine trivial packages we surveyed javascript developers who are mostly graduate student with some professional experience.
however we f ind that there was a clear vote for what is considered a trivial package.
also although our data suggested that packages with loc and a complexity are trivial packages we believe that other de f initions are possible for trivial packages.
t hat said of the survey participants that we emailed about using trivial packages only mentioned that the f lagged package is not a trivial package even though it f it our criteria .
to us this is a con f irmation that our de f inition applies in the vast majority of the cases although clearly it is not perfect.
we use the loc and complexity of the code to determine trivial packages.
in some cases these may not be the only measures that need to be considered to determine a trivial packages.
for example some of the trivial packages have their own dependencies which may need to be taken into consideration.
however our experience tells us that most developers only look at the package itself and not its dependencies when determining if it is trivial or not.
t hat said it would be interesting to replicate this questionnaire with another set of participants to con f irm or enhance our de f inition of a trivial node.js package.
our list of reasons for and drawbacks of using trivial packages are based on a survey of node.js developers.
although this is a large number of developers our results may not hold for all node.js developers.
a different sample of developers may result in a different list or ranking of advantages and disadvantages.
to mitigate the risk due to this sampling we contacted developers from different applications and as our responses show most areexperienced developers.
also there is potential that our survey questions may have in f luenced the replies from the respondents.
however to minimize such in f luence we made sure to ask for freeform responses to minimize any bias and we publicly share our survey and all of our anonymized survey responses.
we used npms to measure various quantitative metrics related to testing community interest and download counts.
our measurements are only as accurate as npms however given that it is the main search tool for npm we are con f ident in the the npms metrics.
we do not distinguish between the domain of the npm packages which may impact the f indings.
however to help mitigate any bias we analyzed more than npm packages that cover a wide range of domains.
we removed test code from our dataset to ensure that our analysis only considers javascript source code.
we identi f ied test code by searching for the term test and its variants in the f ile names and f ile paths.
even though this technique is widely accepted in the literature to con f irm whether our technique is correct i.e.
f iles that have the term test in their names and paths actually contain test code we took a statistically signi f icant sample of the packages to achieve a con f idence level and a con f idence interval and examined them manually.
external validity considers the generalization of our f indings.
all of our f indings were derived from open source node.js applications andnpm packages hence our f indings may not generalize to other platforms or ecosystems.
t hat said historical evidence shows that examples of individual cases contributed signi f icantly in areas such as physics economics social sciences and even so f tware engineering .
we believe that strong empirical evidence is built from both studies on individual cases and studies on large samples.
conclusion t he use of trivial packages is an increasingly popular trend in so f tware development.
like any development practice it has its proponents and opponents.
t he goal of our study is to examine the prevalence reasons and drawbacks of using trivial packages.
our f indings indicate that trivial packages are commonly and widely used in node.js applications.
we also f ind that the majority of developers do not oppose the use of trivial packages and the main reasons developers use trivial packages is due to the fact that they are considered to be well implemented and tested.
however they do cite the fact that the additional dependencies overhead as a drawback of using these trivial packages.
t hat said our empirical study showed considering trivial packages to be well tested is a misconception since more than half of the trivial package we studied do not even have tests wri t ten however these trivial packages seem to be deployment tested and have similar tests community interest and download count values as non trivial packages.
in addition we f ind that some of the trivial packages have their own dependencies and in our studied dataset .
of the trivial packages have more than dependencies.
hence developers should be careful about which trivial packages they use.