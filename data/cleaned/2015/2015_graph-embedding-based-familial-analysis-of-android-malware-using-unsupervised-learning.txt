graph embedding based familial analysis of android malware using unsupervised learning ming fan xiapu luo jun liu meng wang chunyin nong qinghua zheng ting liu school of electronic and information engineering xi an jiaotong university china department of computing the hong kong polytechnic university china school of computer science and engineering southeast university china fanming.
stu.xjtu.edu.cn luoxiapu gmail.com liukeen xjtu.edu.cn meng.wang seu.edu.cn cynong foxmail.com qhzheng xjtu.edu.cn tingliu xjtu.edu.cn abstract the rapid growth of android malware has posed severe security threats to smartphone users.
on the basis of the familial trait of android malware observed by previous work the familial analysis is a promising way to help analysts better focus on the commonalities of malware samples within the same families thus reducing the analytical workload and accelerating malware analysis.
the majority of existing approaches rely on supervised learning and face three main challenges i.e.
low accuracy low efficiency and the lack of labeled dataset.
to address these challenges we first construct a fine grained behavior model by abstracting the program semantics into a set of subgraphs.
then we propose sra a novel feature that depicts the similarity relationships between the s tructural r oles of sensitive a pi call nodes in subgraphs.
an sra is obtained based on graph embedding techniques and represented as a vector thus we can effectively reduce the high complexity of graph matching.
after that instead of training a classifier with labeled samples we construct malware link network based on sra s and apply community detection algorithms on it to group the unlabeled samples into groups.
we implement these ideas in a system called gefdroid that performs g raph e mbedding based f amilial analysis of android malware using unsupervised learning.
moreover we conduct extensive experiments to evaluate gefdroid on three datasets with ground truth.
the results show that gefdroid can achieve high agreements .
.
in term of nmi between the clustering results and the ground truth.
furthermore gefdroid requires only linear run time overhead and takes around .6s to analyze a sample on average which is considerably faster than the previous work.
keywords android malware graph embedding familial analysis unsupervised learning i. i ntroduction with the rapid development of smartphones mobile applications apps have become an inherent part of our everyday life since many convenient services are provided to us through mobile apps.
unfortunately android the most popular mobile operating system has become the major target of mobile malware .
a new security report showed that about .
million malware samples were captured in .
such malware has posed severe security threats to smartphone users.
many recent studies reveal that the android malware exhibits obvious familial trait because attackers usually create malware by injecting the similar malicious components into different popular apps.
in other words malware samples within corresponding author ting liu.the same family have similar malicious behaviors.
similar to the clone detection that discovers similar fragments between code snippets familial analysis is a promising way to identify the common malicious components among malware samples within the same families thus reducing the analytical workload and accelerating malware analysis.
most existing familial analysis approaches rely on supervised learning that first trains a classifier using labeled dataset and then use it to classify new malware samples.
they differ in their features which could be roughly divided into two categories including string based features e.g permissions and api calls graph based features e.g.
function call graph fcg and control flow graph cfg .
however these approaches have three main limitations as follows.
low accuracy string based features are insufficient to distinguish the malicious components and the legitimate part of popular apps.
for example the api getlastknownlocation for obtaining the location information is widely used in both malware samples and benign apps .
low efficiency although graph based features could profile the behaviors of malware samples the similarity calculation of the graph based features is bounded by the efficiency of existing graph matching approaches which are usually slow since the graph isomorphism problem is np complete.
lack of labeled dataset it is time consuming and laborintensive to label a large scale of malware samples with family names.
moreover since classifiers are trained using known malware samples they cannot correctly classify new malware samples from unknown families.
note that retraining the classifier model for every new sample may be impractical .
to tackle these challenges we propose gefdroid a novelgraph embedding based familial analysis approach of android malware with the following salient features high accuracy to achieve a high accuracy of familial analysis we use the graph based features that contain the structural information to profile the app behaviors rather than the string based features.
specifically we abstract the program semantics of an app into an fcg representation and further divide the fcg into a set of small subgraphs according to the app s file directory structure.
by so a fine grained ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
behavior model is constructed in order to locate the malicious components when performing familial analysis.
high efficiency to reduce the high complexity of directly using graph matching inspired by the graph embedding techniques that can transform the high dimensional graph structure data into low dimensional space we propose a novel feature called sra to depict the similarity relationships of structural roles of sensitive api call nodes in a graph.
the structural roles refer to the graph position and the structure of local graph neighborhood.
specifically we employ graph embedding techniques to learn low dimensional vector representations for graph nodes and then calculate the sra based on the vector representations of sensitive api call nodes.
finally the similarity computation of two graphs is simplified to the similarity comparison between two vectors based on the generated sra s instead of the high cost graph matching.
no need of labeled dataset instead of training a classifier we leverage unsupervised learning to cluster unlabeled samples according to their similarity.
in particular we construct a malware link network mln to represent the similarity relationships among samples based on their similar sra s. then we apply community detection algorithms to group the samples into a set of clusters.
after applying gefdroid to three widely used datasets we find that it exhibits impressive performance of familial analysis.
in summary our major contributions include i we propose sra a novel feature to represent the similarity between the structural roles of sensitive api call nodes in a graph.
based on sra s we transform the high cost graph matching into an easy to compute similarity calculation between vectors.
ii we propose and develop gefdroid a novel system for familial analysis of android malware by using unsupervised learning and constructing malware link network mln based on sra s. iii we conduct extensive experiments to evaluate gefdroid.
the results show that gefdroid achieves high agreements .
.
in term of nmi between clustering results and the ground truth datasets.
furthermore gefdroid requires only linear run time overhead and takes around .6s to analyze a sample on average which is considerably faster than the previous work.
the rest of this paper is organized as follows.
section ii introduces the problem.
section iii details gefdroid and section iv reports the experimental results.
after discussing the threats to validity in section v we introduce the related work in section vi and conclude the paper in section vii.
ii.
m otiv a tion and problem definition a. motivating scenario let us consider a security analyst who faces thousands of unlabeled malware samples captured every day as illustrated in fig.
.
these malware samples are generally produced by injecting different kinds of malicious components into popular apps.
the analyst aims to find and analyze the hdwxuh oxvwhuv liihuhqw nlqgv ri pdolflrxv frpsrqhqwv 6lplodu pdolflrxv frpsrqhqwv ri foxvwhu 6lplodu pdolflrxv frpsrqhqwv ri foxvwhu 8qodehohg 0dozduh 6hw fig.
motivation scenario of gefdroid new injected malicious components.
however it is timeconsuming to conduct an in depth analysis on each sample.
therefore the analyst tries to group these malware samples into a set of clusters where the samples belonging to the same cluster share similar malicious components.
by inspecting the similar malicious components in each cluster the analytical workload of the analyst can be effectively reduced.
however the analyst faces two challenges first how to effectively identify the malicious components that usually constitute only a small portion of the samples and may not be implemented in the same way?
second how to efficiently accomplish the clustering of thousands of malware samples with low overhead?
note that directly applying pair wise exact matching is neither effective nor efficient .
to tackle the challenges in the above scenario we first propose a fine grained feature called sra that can not only retain the properties of malicious components but also can be resilient to their polymorphic variants.
furthermore sra is represented as vectors in a low dimensional space so that a great deal of malware samples can be handled efficiently.
we further develop a new system named gefdroid for automating the analysis process.
b. problem definition letm m1 m2 ... m k be a set of given android malware samples without family labels where kis the number of samples.
the main task of our work is to construct an mln that depicts the similarity relationships among different malware samples.
let mln m l where l m mdenotes the edge set.
each mi mj wij l denotes that there exists an edge with weight wijbetweenmi andmjand they share similar malicious components.
the key challenge for this task is how to determine the edges between malware samples.
thus in our approach we aim to propose an effective and efficient feature based on which we can quickly determine the similarities between thousands of malware samples with high accuracy.
then the constructed mln is similar to a social network.
the malware families that we aim to find are regarded as the communities existed in the network.
in general community detection algorithms are widely used to detect community structures in social networks thus they can be applied on our constructed mln in a similar way.
formally after constructing the mln we aim to find the families as c mln y y1 y2 ... y r whereydenotes the set of clusters generated by community detection algorithm c rdenotes the number of generated clusters.
note that each sample in mbelongs to only one cluster in y thus summationtextr r yr k. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
3uhsurfhvvlqj rqvwuxfwlrq udsk 3duwlwlrq 1rlvh 5hprydo udsk pehgglqj hqhudwlrq 6lplodulw dofxodwlrq hdwxuh wudfwlrq dploldo oxvwhulqj rqvwuxfwlrq rppxqlw hwhfwlrq frp frp jhlqlpl frp dolsd qrlvh fig.
the overview architecture of gefdroid preprocessing stage contains three processes fcg construction section iii a1 graph partition section iii a2 and noise removal section iii a3 feature extraction stage contains three processes graph embedding section iii b1 sra generation section iii b2 and similarity calculation section iii b3 familial clustering stage contains two processes mln construction section iii c1 and community detection section iii c2 .
iii.
m ethodology fig.
illustrates the overview architecture of gefdroid which consists of three main stages.
the preprocessing stage constructs the basic behavior model for each malware sample and it contains three processes.
first an fcg is constructed to depict the program semantics of a malware sample.
second due to the inefficiency of analyzing the whole fcg it is divided into a set of subgraphs according to the app s file directory structure.
third the subgraphs that belong to the third party or advertisement libraries are regarded as noises and are removed from the subgraph set.
in the feature extraction stage an sra is extracted from each subgraph to perform an easy to compute similarity calculation between vectors instead of the high cost graph matching between subgraphs.
in the familial clustering stage to perform a clustering task of the malware samples without family labels an mln is first constructed based on the similar sra s between samples.
then community detection algorithms are applied on the mln to divide it into a set of clusters which would be regarded as malware families.
a. preprocessing fcg construction android apps are normally written in java and compiled to dalvik code dex stored in a classes.dex file.
the compiled code and the required resources are packaged into an apk file.
on the basis of existing disassemble tools e.g.
apktool we can obtain the dalvik code from the apk.
given that the dalvik code can be easily changed by typical code obfuscation techniques e.g.
renaming of methods or classes directly analyzing the dalvik code is not effective.
furthermore the malware samples within the same family only share similar malicious components that constitute only a small portion of the apps it is also not efficient to mine similar code snippets with information retrieval techniques.
to retain the program semantics and be resilient to typical code obfuscation techniques different kinds of effective graph models including fcg cfg and user interface graph uig are proposed.
in our approach we use fcg rather than cfg and uig as our graph model to depict app behaviors because of two reasons.
first uig is not suitable for similarity detection between malware samples since they usually have entirely different uis.
second although cfg is a fine grained graph model that contains detail information of the basic blocks in methods theextraction and analysis of cfgs is a time consuming job that requires considerable computational resources.
in addition the results of related approaches have proved that fcg contains enough semantic information to perform malware analysis.
to construct the fcg of a given app we extract the callers and callees from the dalvik code by identifying the invocation statements such as invoke direct.
then we add the callers and callees as nodes in a graph and insert an edge between two nodes if a function call relation exists between them.
the fcg is represented as a directed unweighted graph g v e .
v vi i n denotes the set of functions invoked by an app where each vi vindicates a function name.
e v vdenotes the set of function calls where edge vi vj eindicates that a function call exists from the caller function vito the callee function vj.
graph partition thousands of nodes are usually found in a constructed fcg.
the analysis of entire fcgs are neither effective i.e.
the malicious components constitute only a small portion nor efficient i.e.
excessive number of nodes and edges to analyze .
however the malicious components are generally inserted as a package of class files into the popular benign apps .
for example the malware samples in the family called adrd are produced by injecting the malicious package called com.xxx.yyy where the malware samples receive control instructions from control servers and send collected device information to a data server.
therefore it is a promising way to leverage the app s file directory structure rather than its whole graph to identify the commonalities among malware samples.
to this end we divide the fcg into a set of subgraphs as fdiv g sg sgt t t wherefdiv denotes the graph partition function and t denotes the number of class files of the given app.
specifically we first traverse the app s file structure and record all the class file names.
then for each class file a subgraph is constructed by extracting the corresponding part in fcg.
for example to construct the subgraph of a class file whose name is com.geinimi.c we extract all the caller nodes whose class names are com.geinimi.c and add them into a subgraph.
then we add their callee nodes as well as the corresponding edges into the subgraph.
noise removal it is worth noting that the widelyused third party and advertisement libraries can introduce false positive links when constructing the mln.
for example two authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
malware samples that belong to different families might use the same advertisement libraries such as com.alipay.sdk which is a widely used library for financial apps.
thus the similarity between the samples that share any common thirdparty or advertisement libraries would be higher than their true similarity in terms of malicious activities.
to solve the problem two filtering methods are applied in gefdroid.
first a list that contains widely used library names provided by existing approaches is constructed.
second a list of class names collected from benign apps is also constructed.
the class names on the two lists are regarded as noises and their corresponding subgraphs are removed from the subgraph set.
even if the two lists can work well for most apps they are not sound for the class files whose names are obfuscated as a borc.
to this end we use the tool deguard to reverse the obfuscated names of given apps.
then we are able to remove the subgraphs of such obfuscated class files if they are obtained in the above two lists.
b. feature extraction graph embedding after the construction of graph models it is straightforward to apply graph matching algorithms e.g.
bipartite graph matching to perform app similarity detection.
however the graph matching algorithms are slow since they require super linear time running in the graph size.
furthermore there are generally hundreds of thousands of graphs that are required to calculate similarities between each other.
thus the approaches based on graph matching algorithms are inevitably inefficient.
in recent years deep learning has been applied to many application domains including graph embedding which aims at learning low dimensional vector representations for nodes of a given graph.
graph embedding has been proven to be useful in many tasks of graph analysis including link prediction node classification and visualization .
the learned low dimensional vector representations for nodes can effectively transform the high cost graph matching to an easy to compute distance calculation between vectors.
in our approach the applied graph embedding technique should satisfy two requirements.
first given that new malware samples are constantly being discovered the graph embedding algorithm should work with the input of only one graph per time rather than a graph set see details in section vi b .
in this way the trained model does not need retraining process for the new coming samples.
second the latent representation of nodes should not depend on the node or edge attribute especially the node labels i.e.
method names that can be easily changed by obfuscation techniques.
consider integrating the performance and scalability we use struc2vec as our default graph embedding technique.
given a subgraph sgt vt et after applying struc2vec we use usgt r vt dtodenote the embedding result.
note thatsgtis regarded as an undirected graph here.
for each node vinvt it will learn a ddimensional feature vector uv.
the learned feature vectors enable the nodes with similar structural roles to be embedded in the near points in euclidean space.
fig.
an example of an undirected graph that contains nodes and edges where node and node are structurally similar since both of their degrees are .
fig.
visualization of the embedding results of the same graph after twice applying of struc2vec with the same arguments.
fig.
presents an example of an undirected graph that contains nodes and edges.
the embedding results of the example graph are illustrated in fig.
where the dimension argument is set as for visualization here.
as can be seen from the two figures the learned feature vectors of the same nodes are quite different due to the random walk strategy used instruc2vec .
thus it is not effective to directly apply the embedding technique in our work.
however we observe that even the vectors of the same nodes are different the distance relationships between the nodes are well remained.
for example node and node are structurally similar and the distances between them in the two figures are nearly the same while their locations are different.
sra generation inspired by the above observation found from the embedding result we leverage the similarity relationships between the structural roles of identified node pairs e.g.
node and node to represent the structural feature of a subgraph.
however it is impossible to map the user defined method nodes between two subgraphs since their names can be changed by the obfuscation techniques.
thus we focus on the sensitive api call nodes that cannot be easily changed.
furthermore the sensitive api calls are generally invoked by malware samples to perform malicious activities which could provide useful information for the malware similarity detection .
to obtain the set of sensitive api calls we rely on the work of susi which provides a list of source api calls e.g.
getline1number that returns the phone number of the user and a list of sink api calls e.g.
sendtextmessage that sends short messages .
finally we usesa to denote the set of sensitive api calls.
according to the constructed sa we generate the sra representing the similarity relationships between the structural roles of sensitive api call nodes for each given subgraph.
in detail sratof subgraph sgtis calculated with two steps.
first a subgraph sgtcontains a set of sensitive api call nodes which is denoted as sat sa.
thus a set of sensitive api node pairs v u v u sat is obtained if the subgraph sgtcontains at least two sensitive api call nodes.
second on the basis of the learned low dimensional vector authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
an example of the similarity calculation of two sra s generated from sg1andsg2.
representations of sensitive api call nodes using struc2vec let ht v u be the similarity relationship between the structural roles of node vand node u and it is calculated with the standard cosine similarity metric as ht v u cos uv uu uv uu bardbluv bardbl bardbluu bardbl where uvanduudenote the vector representations of node vand node u respectively.
furthermore ht v u ht u v .
in our work we rank the sensitive api calls in a dictionary ordered method.
thus for two sensitive api call nodes vand u ht v u is stored only if the dictionary order index of vis less than that of u o rht u v is stored.
finally sratis obtained as sra t ht v u v u sa tand v negationslash u .
thus srat sa t sa t where sat is considerably less than the subgraph s node number.
sra similarity calculation after generating sra for each subgraph we are able to transform the high cost graph matching between subgraphs into the similarity calculation between sra s. there are two intuitions for the similarity calculation between sra s and they are listed as below if twosra s share less common sensitive api call nodes the functionalities of their corresponding classes would be less similar.
if the common sensitive api call nodes of two sra s present less similar structural roles between each other their invocation patterns as well as the functionalities of their corresponding classes would be less similar.
on the basis of the above two intuitions the similarity of two given sra s generated from sg1andsg2 denoted as sim sra sra is obtained with eq.
.
sim sra sr a summationtext vi sa1 sa2sim sr1 vi sr2 vi sa1 sa2 where sr1 vi and sr2 vi are represented as two vectors and they denote the similarity relationships between node vi with other sensitive api call nodes in subgraphs sg1andsg2 respectively.
to obtain sr1 vi andsr2 vi for convenience we first construct two distance matrices dt t for two subgraphs as eq.
.
then srt vi is theithrow vector of the constructed matrices as eq.
.
dt braceleftbigg ht vi vj vi vj sa1 sa2 i negationslash j i j srt vi dt sim sr1 vi sr2 vi bardblsr1 vi sr2 vi bardbl2 fig.
presents an example of the similarity calculation of twosra s generated from sg1andsg2.
note that only parts of the subgraphs are shown the other parts located in rectangles are quite different.
the two subgraphs have three common sensitive api call nodes i.e.
red nodes v1 v2 andv3 .
for subgraph sg1 h1 v1 v2 .4andh1 v1 v3 .
.
for subgraph sg2 h2 v1 v2 h2 v1 v3 .
.
therefore sim sr1 v1 sr2 v1 sim .
.
.
.
.
note that the cosine metric result of the two vectors is .
.
however the high similarity calculated with cosine metric cannot depict the different sensitive api invocation patterns here.
thus we apply the euclidean metric with eq.
rather than the cosine metric.
the euclidean metric result is .
considerably less than the result of cosine metric.
c. familial clustering mln construction after the feature extraction stage given two malware samples we are able to capture their similarity relationship based on their similar sra s. to perform familial analysis using unsupervised learning we aim to construct an mln where each node denotes a malware sample and each edge between two samples denotes that there exist similar sra s between them.
therefore the mln can depict the similarity relationships among all the malware samples to be analyzed.
algorithm lists the steps of constructing the mln with the input of malware set mand two threshold values and epsilon1.
denotes the similarity threshold value between sra s. in other words if the similarity of two sra s calculated with eqs.
is no less than they are regarded as the same indicating that their corresponding classes share similar functionalities.
epsilon1 denotes the threshold value of adding edges between sample nodes.
if the number of same sra s shared by two samples is no less than epsilon1 then an edge is added between the two samples.
in algorithm after the preprocessing of each sample in m lines a set of sra s denoted as sraset is constructed lines .
then each sample is added to the mln as a node line .
after that for each sample pair in m the number of same sra s between them is calculated and represented ask lines .
an edge with weight kis added for the sample pair if there exist no less than epsilon1samesra s between them lines .
community detection to group the malware samples into clusters on the basis of the constructed mln community detection algorithms are effective to determine whether the mln has community structures if the nodes can be easily grouped into sets of nodes such that each set of nodes is internally densely connected.
as a result the malware samples grouped in the same cluster could be regarded as belonging to the same malware family.
for the new samples that are constantly being discovered they are placed into the clusters that have connections with them by calculating the similarity relationships with existing samples.
fig.
presents an example of community detection result of mln for fifteen malware samples in three families i.e.
geinimi droidkungfu and adrd .it is obvious that the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm construction of mln input m mdenotes the set of malware samples to be analyzed.
denotes the similarity threshold value between sra s. epsilon1 epsilon1denotes the threshold value of adding edges between nodes.
output mln m l for each malware sample miinmdo sg mi fdiv gmi removenoise sg mi for eachsgtinsg mido sra t generatesra sgt end for sraset mi sra t t t mln.addnode mi end for for each sample pair mi m j inmdo k for eachsra tinsraset mido for eachsrat primeinsraset mjdo ifsim sra t srat prime then k k end if end for end for ifk epsilon1then mln.addedge mi m j k kdenotes the edge weight.
end if end for returnmln jhlqlpl gurlgnxqjix dgug fig.
an example of community detection result of mln for fifteen malware samples in three families.
constructed mln can be divided into three clusters.
in each cluster the samples are connected with each other indicating that the samples within the same cluster share similar malicious components.
on the basis of the clustering results our approach can effectively help security analysts focus on the commonalities among malware samples within the same cluster and potentially isolate the malicious behaviors of malware samples from different clusters.
iv .
e v alua tion we use three datasets with real malware samples and six metrics to carefully evaluate gefdroid and answer five research questions rq does gefdroid outperform the baseline approaches in term of accuracy?
section iv b1 rq can gefdroid handle new malware samples without retraining the model?
section iv b2 rq can gefdroid process a great deal of samples with low run time overhead?
section iv c1 rq does gefdroid outperform the baseline approaches in term of efficiency?
section iv c2 rq to what extent is gefdroid resilient to obfuscation techniques?
section iv d rq examine the accuracy of gefdroid while rq investigate the efficiency.
rq evaluates the resilience of gefdroid to code obfuscation.table i descriptions of three used datasets dataset family q malware k max.
min.
avg.
dataset i .4mb 12kb .3mb dataset ii .8mb 5kb .3mb dataset iii .2mb 12kb 2mb a. study setup datasets we evaluate gefdroid on three ground truth datasets provided by genome project drebin and fan et al.
.
for convenience they are named as dataseti dataset ii and dataset iii.
their descriptions are listed in table i where columns list the number of families q and the number of malware samples k .
different datasets have different distributions of malware samples.
columns lists the maximum minimum and average size of malware samples.
note that each sample in these datasets has been attached to a family label given by experts.
metrics six metrics are used to measure the clustering performance.
they are normalized mutual information nmi adjusted rand index ari fowlkes mallows index fmi homogeneity completeness and v measure .
nmi ari and fmi are three widely used metrics that measure the agreement between the clustering result and the ground truth dataset.
homogeneity measures the extent of how each generated cluster contains only samples of a single family.
completeness measures the extent of how all samples of each family are assigned to the same cluster.
v measure is the harmonic mean of homogeneity and completeness.
except for the ari the values of the other five metrics range from to where a higher value indicates a better agreement between the predicted clusterings and the true clusterings.
the value of ari ranges from to where random labelings have an ari value close to .
.
for all the six metrics .
stands for a perfect match with the ground truth dataset.
recall the example of community detection result illustrated in fig.
all the six metrics are .
.
community detection algorithm we apply four widelyused community detection algorithms to the mlns constructed on the three datasets.
these algorithms include infomap which detects community structures of a network using the approach proposed by rosvall et al.
.
fast greedy which is based on the greedy optimization of modularity a metric to measure the quality or significance of a community structure.
label propagation which is a fast partitioning algorithm proposed by raghavan et al.
.
multilevel which is a layered and bottom up community detection algorithm proposed by blondel et al.
.
due to the page limitation we cannot present all the clustering performance with the four algorithms on the three datasets.
according to the performance the infomap algorithm achieves the best clustering performance among these four algorithms.
the average nmi value of infomap on the three datasets is .
while those of the other three algorithms are .
.
and .
.
in addition infomap also performs best in terms of the other five metrics.
therefore in our latter experiments we select infomap as our default community authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii clustering performance of gefdroid and baseline approaches with infomap algorithm on three datasets.
dataset baseline approaches nmi ari fmi homogeneity completeness v measure cluster dataset i q k permission .
.
.
.
.
.
api .
.
.
.
.
.
faldroid .
.
.
.
.
.
groupdroid .
.
.
.
.
.
gefdroid w o nr .
.
.
.
.
.
gefdroid .
.
.
.
.
.
dataset ii q k permission .
.
.
.
.
.
api .
.
.
.
.
.
faldroid .
.
.
.
.
.
groupdroid .
.
.
.
.
.
gefdroid w o nr .
.
.
.
.
.
gefdroid .
.
.
.
.
.
dataset iii q k permission .
.
.
.
.
.
api .
.
.
.
.
.
faldroid .
.
.
.
.
.
groupdroid .
.
.
.
.
.
gefdroid w o nr .
.
.
.
.
.
gefdroid .
.
.
.
.
.
detection algorithm due to its superior performance.
parameters there are two parameters that play important roles in our approach i.e.
controls the similarity threshold value between sra s epsilon1controls the threshold value of adding edges between sample nodes.
to select the proper and epsilon1 we vary the values of as .
.
.
.
.
.
.
.
and vary the values of epsilon1as when conducting the experiments on all the three used datasets.
according to the clustering performance with different parameters we select the default values of and epsilon1 as .
and respectively.
we conduct the experiments on a quad core .
ghz pc running ubuntu .
bit with gb ram and tb hard disk.
b. accuracy of gefdroid rq1 does gefdroid outperform the baseline approaches in term of accuracy?
we compare the accuracy of gefdroid with four baseline approaches that are briefly introduced as below wang et al.
proposed an approach for malware detection based on the requested permissions which are securityaware features that restrict the access of apps to the core facilities of devices .
aafer et al.
proposed an approach for malware detection based on api calls which are more fine grained features than permissions since each permission governs several api calls .
fan et al.
proposed faldroid which performs familial classification based on the generated fregraphs that denote the common behaviors of malware samples within the same families .
marastoni et al.
proposed groupdroid which uses 3dcfg centroids as features to measure the similarities between malware samples and perform grouping .
among these approaches groupdroid performs a clustering task like gefdroid does while the other three approaches perform a classification task and they suffer two main limitations.
first they require a training dataset with family labels assigned by experts which is noteasy to obtain.
second they can only identify the families that are only provided in the training dataset.
thus for android familial analysis it is more practical to perform a clustering task as we do rather than performing a classification task.
to have a fair comparison of clustering performance with the approaches that perform a classification task we construct different mlns for such approaches based on their proposed features e.g.
fregraphs permissions and api calls.
then the infomap algorithm is applied on their mlns to perform a clustering task.
for groupdroid we reimplement it and perform a clustering task based on the extracted 3d cfg centroids.
in addition we use gefdroid w o nr to denote our approach without the preprocessing of noise removal in order to evaluate whether the third party or advertisement libraries affect the clustering performance.
the comparison results are listed in table ii where the term cluster denotes the number of generated clusters.
we can draw the following four conclusions from the results i except for the completeness metric gefdroid performs best among these approaches in terms of the other five metrics.
ii gefdroid generates the most clusters.
the highest homogeneity values and the most clusters indicate that gefdroid can well isolate the malicious behaviors of malware samples from different families.
iii in general the string based features i.e.
permissions and api calls perform worse than the graph based features.
the main reason is that they cannot well depict the program semantic meanings thus insufficient to mine the common malicious components of malware samples within the same families.
iv the preprocessing of noise removal significantly improves the clustering performance indicating that the widely used third party or advertisement libraries would introduce noise edges into the mlns.
then we investigate the clustering results of data iii that has only families but generated clusters.
the clustering results are listed in table iii where rp denotes the reduced percentage of malware samples in which its inspection can be deferred because of our clustering.
rp authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii clustering result of gefdroid on dataset iii where rp denotes the reduced percentage of malware samples in which its inspection can be deferred because of our clustering.
family sample cluster rp family sample cluster rp adwo .
hongtoutou .
airpush .
iconosys .
anserver .
imlog .
basebridge .
jsmshider .
boqx .
kmin .
boxer .
kuguo .
clicker .
lovetrap .
dowgin .
mobiletx .
ddlight .
pjapps .
droidkungfu .
plankton .
droidsheep .
smskey .
fakeangry .
smsreg .
fakedoc .
steek .
fakeinst .
utchi .
fakeplay .
waps .
geinimi .
youmi .
gingermaster .
yzhc .
golddream .
zitmo .
is calculated as rp cluster sample.
for example the family steek contains samples and only one cluster is generated with our clustering approach.
therefore its rp is .
.
in other words the analyst only need to inspect one sample from the generated cluster because these samples share similar malicious components.
according to the result the average value of rp is .
indicating that our approach can effectively reduce the analytical workload of the analyst.
however there are still some families whose rps are lower than .
e.g.
.
for family youmi indicating that it still requires a lot time for the analyst to manually review.
we manually inspect the samples in family youmi which are adware that just display annoying and misleading advertisement.
we find that samples do not contain any sra since their malicious advertisements are removing in our preprocessing stage.
therefore these samples have no connection with others.
the detection of whether the contained advertisements are annoying or misleading is still a challenge for existing works and we leave this as our future work.
answer to rq gefdroid can achieve high agreements between the clustering results and the ground truth datasets which outperforms baseline approaches.
rq2 can gefdroid handle new malware samples without retraining the model?
we randomly select samples from each dataset and regard them as new samples.
then we calculate their similarity relationships with existing samples in the mln and use three terms to evalaute the performance.
true link rate the percent of new samples that have links with the samples that belong to the same families.
false link rate the percent of new samples that have and only have links with the samples that belong to different families.
no link rate the percent of new samples that have no links with existing samples.
we repeat this experiment times on the three datasets.
the average results listed in table iv indicate that gefdroid can effectively link the new coming samples with their variants in the mln.
moreover we find that .
of new samples actually belong to the families that contain only one sample intable iv performance of detecting new coming malware samples.
dataset true link rate false link rate no link rate dataset i .
.
.
dataset ii .
.
.
dataset iii .
.
.
fig.
cdfs for the run time overhead of the preprocessing stage left and the feature extraction stage right on dataset iii.
table v run time overheads of mln construction and community detection on three datasets.
dataset t sra pairs mln construction community detection dataset i .
.
10620s 2s dataset ii .
.
108131s 11s dataset iii .
.
108750s 45s the datasets thus causing their no link with existing samples.
answer to rq gefdroid can effectively link the new samples with their variants in the mln and identify the samples that belong to new families.
c. efficiency of gefdroid rq3 how is the overhead of gefdroid for handling a great deal of samples?
we evaluate the run time overhead of gefdroid for its three main stages that are listed as below preprocessing all the given samples are disassembled and a set of subgraphs for each sample are constructed.
feature extraction for each subgraph of a sample its nodes are encoded into low dimensional vectors with struc2vec .
then an sra is generated to represent the structural feature of the subgraph.
familial clustering an mln is constructed based on the similarity calculation of sra s. then the infomap algorithm is applied on the mln for malware clustering.
fig.
presents the cumulative distribution function cdf for the run time overhead of the preprocessing procedure left and the feature extraction procedure right on dataset iii.
for the preprocessing stage only .1s is needed on average.
moreover more than of samples require less than 10s.
for the feature extraction stage .5s is needed on average.
furthermore only about .
of samples require more than 30s.
the cost of feature extraction mainly depends on the size of the subgraphs that are embedded.
the used embedding algorithm struc2vec scales super linearly but closer to linear.
it is worth noting that the preprocessing and the feature extraction stages could be conducted on several pcs in parallel thus further reducing the total overhead.
for the stage of familial clustering an mln is first constructed by calculating the similarities between sra s. thus the calculation complexity of the sra pairs is about o k k t t wherekandtdenote the total number of samples and the average number of sra s per sample authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
comparison result of the run time overheads.
has respectively.
table v lists the run time overheads of mln construction and community detection on three datasets.
even for the biggest dataset iii the similarity calculation of .
108pair ofsra s is accomplished in only 750s.
the cost for the community detection is considerably less than that of the mln construction.
furthermore for a new coming sample it only needs .2s to calculate the similarities with existing samples.
answer to rq gefdroid only takes around .6s to analyze a sample on aver age and thus it can handle a large scale of samples efficiently.
rq does gefdroid outperform the baseline approaches in term of efficiency?
we compare the overhead of gefdroid and that of the baseline approaches.
for the permissions and api calls based approaches their clustering performance is considerably worse than gefdroid.
moreover compared with the graph based features the permissions and api calls based features cannot provide enough explanations to the relationships between malware samples within the same clusters.
hence we focus on the efficiency comparison between gefdroid and the two graph based approaches i.e.
faldroid and groupdroid.
more precisely we first randomly select malware samples.
then a set of subgraphs are generated for each sample in the three approaches.
after that faldroid adopts a weighted sensitive api calls based graph matching approach to calculate the graph similarities which has been proved to be faster than the graph edit distance algorithm.
for groupdroid a 3d cfg centroid represented as a four dimensional vector is calculated for each subgraph.
in gefdroid an sra is generated to represent each subgraph.
in summary the similarity detection between samples of faldroid is based on the graph matching algorithm while groupdroid and gefdroid rely on similarity calculation between vectors.
fig.
use the blue line black line and red line denote the increase of total run time overhead of faldroid groupdroid and gefdroid respectively.
we can see that the blue line grows exponentially while the black line and the red line show linear growths.
about 19s is required for groupdroid to construct the 3d cfgs and calculate the centroid which is twice as the time gefdroid needs.
for faldroid when the number of samples is lower than it shows higher efficiency than gefdroid by directly applying the graph matching approach.
however with the increase in the number of samples the cost of faldroid is considerably higher than gefdroid.
answer to rq gefdroid only requires linear run timeoverhead in terms of the number of samples and thus is considerably faster than the previous work.
d. resilience of gefdroid rq to what extent is gefdroid resilient to obfuscation techniques?
to answer rq we initially leverage different kinds of obfuscation techniques to produce the variants of our samples.
then we calculate the similarities between the sra s generated by the original and obfuscated samples.
given that sra is proposed to depict the similarity relationships between structural roles of sensitive api call nodes in a graph it is resilient to typical obfuscation techniques such as function renaming instruction substitution and string encryption which cannot change the structure of fcg.
however there are several advanced obfuscation techniques that can slightly change the fcg structure including the control flow obfuscation and the reflection technique.
to evaluate the resilience of gefdroid to the control flow obfuscation which changes the fcg structure by inserting or deleting useless method nodes we apply gefdroid to ten samples obfuscated by the android obfuscator called dasho .
after the similarity calculation between the sra s generated by the original and obfuscated samples the results show that even the fcg structures are slightly changed with several nodes their similarities are still higher than our threshold value which is set as .
in our approach.
for the reflection technique which might hide calling edges of fcg we leverage droidra an open source tool to detect reflection methods and add the missing edges.
the experiment shows that on average only two edges containing a sensitive api call node are added into the fcg for each app which barely affects the accuracy of gefdroid.
in addition to the above obfuscation techniques encryption packers such as bangcle and baidu are the most popular obfuscation tools now.
they can hide the actual dex code thus making the disassembled tools unable to get the dalvik code.
in our approach we use the unpacker tool packergrind to recover the actual dex files.
answer to rq gefdroid is resilient to typical obfuscation techniques and can deal with advanced packing techniques by leveraging existing tools.
v. t hrea ts to v alidity a. threats to internal v alidity native code.
in our approach we limit our analysis to the fcg model constructed based on the dalvik code.
we do not analyze native code.
thus our approach would miss the malicious behaviors implemented in native code.
however there are many binary analysis frameworks such as angr that can help us address this limitation by constructing the fcg of the native code.
then we could apply our approach to conducting similarity detection of such fcgs.
we will explore this approach in future work.
sensitive api calls.
our detection of sensitive api calls relies on the set provided by susi which now four years later might be incomplete or outdated.
missing or incorrect authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sensitive api calls contained in sa would make gefdroid miss or misidentify the common malicious behaviors between malware samples within the same families.
furthermore since the sensitive api calls are extracted statically in gefdroid the ones that are never executed by the malware samples would introduce noises when detecting the similarities between samples.
in future work combining the dynamic analysis with the static analysis is a promising way to reduce the sideeffects caused by the dead code that will never be executed.
b. threats to external v alidity third party libraries.
to remove the third party and advisement libraries we extend the widely used library list by adding the class names of benign apps.
even the list works well on our datasets it is unclear how does the list performs when applying gefdroid on other datasets.
in future work we plan to construct bigger datasets that contain recent malware samples and evaluate the performance of gefdroid on them.
multi label malware.
gefdroid can well handle the samples in our three used datasets from which each sample belongs to exactly one malware family.
however it might fail when dealing with the multi label malware samples that contain code from multiple malware families.
the multi label malware samples belong to the overlapping region in the constructed mln which might be handled by the overlapping community detection algorithms .
we leave the detection of multi label samples as our future work.
vi.
r ela ted work a. malware familial analysis there is a large body of research devoted to the familial analysis of android malware.
deshotels et al.
proposed droidlegacy which partitions the app code into loosely coupled modules and identifies the malicious module of each piggybacked malware family.
suarez et al.
proposed dendroid which automatically classifies malware and analyzes families on the basis of code structures.
zhang et al.
proposed droidsift which constructs family features on the basis of the api dependency graphs.
feng et al.
proposed astroid which automatically synthesizes a maximally suspicious common subgraph of each malware family as a signature to perform the familial analysis.
most of the above approaches work with supervised learning.
they require a set of known malware samples labeled by experts to be used as training samples.
thus they can only classify the malware samples that belong to known families in training dataset.
compared with these approaches gefdroid works with unsupervised learning that does not need any labeled samples.
therefore our approach is able to avoid the model retraining and detect the new coming samples by calculating their connections with existing samples in mln.
b. graph embedding the embedding techniques based on representing graphs in vector spaces while preserving their properties have become widely popular.
there are two types of representation learning.the first is to encode nodes as low dimensional vectors that summarize their structural roles in graphs.
perozzi et al.
proposed deepwalk which first uses the random walks to generate node sequence as its context.
then grover and leskovec improved the deepwalk model by proposing node2vec that uses second order random walks to generate the node sequence.
ribeiro et al.
proposed struc2vec which uses a hierarchy to measure node similarity at different scales and constructs a multilayer graph to encode structural similarities and generate the structural context for nodes.
however these approaches cannot be directly applied to our work since their embedding results of the same graph are not in a consensus due to the using of random walks.
thus we proposesra to represent the graph feature for similarity calculation.
the second is to encode a graph as low dimensional vectors instead of a node.
dai et al.
proposed structure2vec which is based on the idea of embedding latent variable models into feature spaces and learning such feature spaces using discriminative information.
narayanan et al.
proposed graph2vec which is also based on the skip gram model for learning embedding similar to node2vec.
the difference is that it views an entire graph as a document and the subgraphs around each node in the graph as words that compose the document.
even such approaches can learn representations for graphs they require a graph set as input and need model retraining to deal with the new coming samples.
vii.
c onclusion we propose sra a novel feature to represent the similarity relationships between the structural roles of sensitive api call nodes in a graph.
by so we transform the high cost graph matching into an easy to compute similarity calculation between vectors.
moreover we design and develop gefdroid a new system for familial analysis of android malware by using unsupervised learning and constructing mln based on sras.
our extensive evaluation results show that gefdroid outperforms the state of the art approaches in terms of accuracy and efficiency.
acknowledgment this research was supported by national key r d program of china 2016yfb1000903 national natural science foundation of china u1766215 innovative research group of the national natural science foundation of china ministry of education innovation research team irt 17r86 consulting research project of chinese academy of engineering the online and offline mixed educational service system for the belt and road training in mooc china and project of china knowledge centre for engineering science and technology and in part by rgc project no.
polyu 16e 17e cityu c100816g.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.