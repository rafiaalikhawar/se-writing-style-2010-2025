facoy a code to code search engine kisub kim1 dongsun kim1 tegawend f. bissyand 1 eunjong choi2 l il i3 jacques klein1 yves le traon1 1snt university of luxembourg luxembourg 2nara institute of science and technology naist japan 3faculty of information technology monash university australia abstract code search is an unavoidable activity in software development.
various approaches and techniques have been explored in the literature to support code search tasks.
most of these approaches focus on serving user queries provided as natural language free form input.
however there exists a wide range of use case scenarios whereacode to codeapproachwouldbemostbeneficial.forexample researchdirectionsincodetransplantation codediversity patch recommendation canleverage a code to code search engine to find essential ingredients for their techniques.
in this paper we proposefacoy anovelapproachforstaticallyfindingcodefragmentswhichmaybe semantically similartouserinputcode.facoy implements a query alternation strategy instead of directly matchingcodequerytokenswithcodeinthesearchspace facoyfirst attemptstoidentifyothertokenswhichmayalsoberelevantinim plementingthefunctionalbehavioroftheinputcode.withvarious experiments we show that facoy is more effective than online code to codesearchengines facoycandetectmoresemantic codeclones i.e.
type inbigclonebenchthanthestate of theart facoy whilestatic candetectcodefragmentswhichare indeed similar with respect to runtime execution behavior and facoy can be useful in code patch recommendation.
introduction insoftwaredevelopmentactivities sourcecodeexamplesarecriticalforunderstandingconcepts applyingfixes improvingperformance andextendingsoftwarefunctionalities .previous studieshaveevenrevealedthatmorethan60 ofdeveloperssearch for source code every day .
with the existence of superrepositoriessuchas githubhostingmillionsofopensourceprojects there are opportunities to satisfy the search need of developers for resolving a large variety of programming issues.
oftentimes developersarelookingforcodefragmentsthatoffer similar functionalitythan someother codefragments.
for example adevelopermayneedtofindjavaimplementationsofallsorting algorithms that could be more efficient than the one she he has.
we refer to such code fragments which have similar functional behavior even if their code is dissimilar as semantic clones.
the corresponding authors.
publication rights licensed to acm.
acm acknowledges that this contribution was authoredor co authoredbyanemployee contractororaffiliateof anationalgovernment.assuch thegovernmentretainsanonexclusive royalty freerighttopublishor reproduce this article or to allow others to do so for government purposes only.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
also refers to them as type 4clones for consistency with the taxonomy of code clones .
besides the potential of helping developers collect relevant examples to improve their code finding similar code fragments is an important endeavor at they can provide essential ingredients for addressing challenges in various software engineering techniques.
among such challenges we canenumerateautomatedsoftwaretransplantation software diversification and even software repair .
findingsemanticallysimilarcodefragments is howev er challenging to perform statically an essential trait to ensure scalability.
afewstudies haveinvestigatedprograminputsandoutputs tofindequivalentcodefragments.morerecently suetal.
have proposed an approach to find code relatives relying on instructionlevelexecution traces i.e.
codewith similarexecutionbehaviors .
unfortunately allsuchdynamicapproachescannotscaletolarge repositories because of their requirement of runtime information.
ourkeyinsighttostaticallyfindcodefragmentswhicharesemanticallysimilarisfirsttoundertakeadescriptionofthefunctionalityimplementedbyanycodefragment.then suchdescriptions can be used to match other code fragments that could be described similarly.
this insight is closely related to the work by marcus and maletic on high level concept clones whose detection is based on source code text comments and identifiers providing an abstract view of code.
unfortunately their approach can only help to identify high level concepts e.g.
abstract data types but is not targeted at describing functionalities per se.
because of the vocabulary mismatch problem be tweencodetermsandhumandescriptionwords itischallengingto identifythemostaccuratetermstosummarize innaturallanguage the functionality implemented by a code fragment.
to work around the issue of translating a code fragment into natural language description terms one can look2up to a developer community.
actually developers often resort to web based re sourcessuchasblogs tutorialpages andq asites.
stackoverflow is one of such leading discussion platforms which has gained popularity among software developers.
in stackoverflow an answer to a question is typically short texts accompanied by code snip pets that demonstrate a solution to a given development task orthe usage of a particular functionality in a library or framework.
stackoverflow providessocialmechanismstoassessandimprove thequalityofpoststhatleadsimplicitlytohigh qualitysourcecode snippets on the one hand as well as concise and comprehensive questionsontheotherhand.ourintuitionisthatinformationin q asitescanbeleveragedasacollectiveknowledgetobuildan 2becausesoftwareprojectscanbemoreorlesspoorlydocumented wedonotconsider sourcecodecommentsasareliableandconsistentdatabaseforextractingdescriptions.
instead we rely on developer community q a sites to collect descriptions.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden k. kim et al.
intermediatetranslationstepbeforetheexplorationoflargecode bases.
this paper.
we propose facoy findacodeother than yours as a novel static scalable and effective code to code search engine for finding semantically similar code fragments in large code bases.
overall we make the following contributions thefacoyapproach for code to code search w ep r o po s ea solutiontodiscovercodefragmentsimplementingsimilarfunctionalities.
our approach radically shifts from mere syntactic patterns detection.
it is further fully static i.e.
relies solely on source code with no constraint of having runtime information.
facoy is based onqueryalternation afterextractingstructuralcodeelementsfrom a code fragment to build a query we build alternate queries usingcodefragmentsthatpresentsimilardescriptionstotheinitial code fragment.
we instantiate the facoy approach based on indices on java files collected from github and q a posts from stackoverflow tofindthebestdescriptionsoffunctionalitiesimplemented in a large and diversified set of code snippets.
a comprehensive empirical evaluation .
we present evaluationresultsdemonstrating thatfacoycanaccuratelyhelp search for syntactically and semantically similar code fragments outperforming popular online code to code search engines.
we further show withthebigclonebenchbenchmark thatweperform better than the state of the art on static code clone detectors identifying semantic clones our approach identifies over semanticclones whileothersdetectfewtonosemanticclones.we also break down the performance of facoy to highlight the addedvalueofour queryalternation scheme.usingthedyclinkdynamic tool wevalidatethat in68 ofthecases ourapproachindeed finds code fragments that exhibit similar runtime behavior.
finally weinvestigatethecapabilityoffacoytobeleveragedforrepair patch recommendation.
motivation and insight finding similar code fragments beyond syntactic similarities has severalusesinthefieldofsoftwareengineering.forexample developers can leverage a code to code search tool to find alternative implementations of some functionalities.
recent automated software engineering research directions for software transplantation or repair constitute further illustrations of how a code to code search engine can be leveraged.
despiteyearsofactiveresearchinthefieldofcodesearchand codeclonesdetection fewtechniqueshaveexplicitlytargetedsemantically similar code fragments.
instead most approaches focus ontextually structurallyorsyntacticallycodefragments.thestateof the art techniques on static detection of code clones leverage various intermediate representations to compute code similarity.
token based representationsareusedinapproachesthat targetsyntacticsimilarity.ast based representationsare employedinapproachesthatdetectsimilarbutpotentiallystruc turally different code fragments.
finally program dependency graph based representationsareusedindetectingclones where statements are not ordered or parts of the clone code are intertwinedwitheachother.althoughsimilarcodefragmentsidentified by all these approaches usually have similar behavior the contemporarystaticapproachesstillmissfindingsuchfragments which have similar behavior even if their code is dissimilar .to find similarly behaving code fragments researchers have relied upon dynamic code similarity detection which consists in identifyingprogramsthatyieldsimilaroutputsforthesameinputs.
state of the art dynamic approaches generate random inputs relyonsymbolic orconcolicexecution andcheckabstract memory states to compute function similarity based on execution outputs.
the most recent state of the art on dynamic clone detection focuseson thecomputations performedby thedifferent programs and compares instruction level execution traces to identify equivalent behavior .
although these approaches can be very effective in finding semantic code clones dynamic execution of code is not scalable and implies several limitations for practical usage e.g.
the needofexhaustivetestcasesto ensureconfidence in behavioral equivalence .
tosearchforrelevantcodefragments usersturntoonlinecodeto code search engines such as krugle which statically scan open source projects.
unfortunately such internet scale searchengines still perform syntactic matching leading to low quality output in terms of semantic clones.
onthekeyidea considerthecodefragmentsshowninfigure1.
theyconstitutevariantimplementationsforcomputingthehashof astring.theseexamplesarereportedinbigclonebench astype4 clones i.e.
semantic clones .
indeed their syntactic similarity is limited to a few library function calls.
textually only about half of the terms are similar in both code fragments.
structurally the first implementationpresentsonlyoneexecutionpathwhilethesecond includes two paths with the try catch mechanism.
public string gethash final string password throws nosuchalgorithmexception unsupportedencodingexception final messagedigest digest messagedigest.getinstance md5 byte md5hash digest.update password.getbytes utf password.length md5hash digest.digest return converttohex md5hash a excerpt from md5hashhelperimpl.java in theyes cart project.
public static string encrypt string message try messagedigest digest messagedigest.getinstance md5 digest.update message.getbytes base64encoder encoder new base64encoder return encoder.encode digest.digest catch nosuchalgorithmexception ex ... b excerpt from crypt.java in thebettaserver project.
figure implementation variants for hashing.
tostaticallyidentifythecodefragmentsaboveassemantically similar a code to code search engine would require extra hint that i gethashandencryptdeal with related concepts and that ii base64encoder apiisofferingsimilarfunctionalityas converttohex.
such hints can be derived automatically if one can build a comprehensive collection of code fragments with associated descriptionsallowingforhigh levelgroupingsoffragments basedon naturallanguagedescriptions toinferrelationshipsamongcode tokens.
the inference of such relationships will then enable the generationof alternatequeries displayingrelated butpotentially syntacticallydifferent tokensb orrowedfrom othercodefragments havingsimilardescriptionsthantheinputfragment.thus given thecodeexampleoffigure1 a thesystemwilldetectsimilarcode authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
facoy a code to code search engine icse may june gothenburg sweden fragmentsbymatchingnotonlytokensthataresyntactically3similartotheonesinthiscodefragment i.e.
gethash messagedigest andconverttohex butalsootherssimilartoknownrelatedtokens e.g.
base64encoder encrypt etc.
.
such a system would then be abletoidentifythecodefragmentoffigure1 b asasemantically similar code fragment i.e.
a semantic clone .
we postulate that q a posts and their associated answers constitute a comprehensive dataset with a wealth of information on how different code tokens found in code snippets displayed as exampleanswers canbematchedtogetherbasedonnaturallanguage descriptions found in questions .
figure illustrates the steps that could be unfolded for exploiting q a data to find semantic clones in software repositories such as github.
what functionality is implemented?
what are related implementations?what are other representative tokens for the functionality?
which code fragments best match these tokens?
q a posts questions code snippets target code basecode fragment similar code fragments figure conceptual steps for our search engine.
givenacodefragment thefirststepwouldconsisttoinfernaturallanguagetermsthatbestdescribethefunctionalityimplemented.
to that end we must match the code fragment with the closest codeexampleprovidedinaq apost.then wesearchintheq a datasetallpostswithsimilardescriptionstocollecttheirassociated codeexamples.bymixingallsuchcodeexamples wecanbuilda morediversesetofcodetokensthatcouldbeinvolvedintheimple mentationoftherelevantfunctionality.usingthissetoftokens we can then search real world projects for fragments which may be syntactically dissimilar while implementing similar functionality.
basic definitions we use the following definitions for our approach in section .
code fragment a contiguous set of code lines that is fed as input to the search engine.
the output ofthe engine is also a listof code fragments.
we formalize it as a finite sequence of tokens representing full or partial program source code at different granularities e.g.
a function or an arbitrary sequence of statements.
codesnippet acodefragmentfoundinq asites.wepropose this terminology to differentiate code fragments that are leveragedduring the search process from those that are used as input or that are finally yielded by our approach.
q apost apairp q a alsonoted pq a whereqisaquestion andaisalistofanswers.forinstance foragivenpost pq a question qis a document describing what the questioner is trying to ask aboutand a aisadocumentthatanswersthequestionin q.each answeracanincludeoneorseveralcodesnippets s snippets a wheresis a set of code snippets.
we also recall for the reader the following well accepted definitions of clone types type identical code fragments except for differences in whitespace layout and comments.
3naive syntactic matching may lead to false positives.
instead there is a need to maintain qualification information about the tokens e.g.
the token represents a method call a literal etc.
cf.
section .
type identical code fragments except for differences in identifiernamesandliteralvalues inadditiontotype 1clonedifferences.
type syntactically similar code fragments that differ at the statement level.
the fragments have statements added modified and orremovedwithrespecttoeachother inadditiontotype and type clone differences.
type syntacticallydissimilar code fragmentsthat implement the same functionality.
they are also known as semantic clones.
disclaimer.
inthiswork werefertoapairofcodefragmentswhich are semantically similar as semantic clones although they might have been implemented independently i.e.
no cloning e.g.
copy paste was involved .
such pairs are primary targets of facoy.
approach facoytakesacodefragmentfromauserandsearchesinasoftware projects code base to identify code fragments that are similar to theuser sinput.althoughthedesignoffacoyistargetedattaking intoaccountfunctionallysimilarcodewithsyntacticallydifferent implementations thesearchoftenreturnsfragmentsthatarealso syntactically similar to the input query.
figure illustrates the steps that are unfolded in the working process of the search user input snippet indexcode indexcode query generating expanded code querycode queries code fragment search results question index generating code query question answer snippet question answer snippet searching for similar code snippets searching for similar questions searching for code examples figure overview of facoy.
whenfacoyreceivesacodefragment itgeneratesastructured query called code query based on the code elements present in the fragment section .
.
.
given a code query facoy searches for q a posts that include the most syntactically similar code snippets.
to that end the query is matched against the snippet index of q a posts section .
.
.
oncetherelevantpostsareidentified facoycollectsnatural languagedescriptivetermsfromtheassociatedquestionsand matches them with the question index of q a posts to find other relevant posts.
the objective is to find additional code snippets that could implement similar functionalities with a diversified set of syntactic tokens section .
.
.
using code snippets in answers of q a posts collected by previoussteps facoygeneratescodequeriesthateachconstitutes an alternative tothe first code query obtained fromuser input in step section .
.
.
as the final step facoy searches for similar code fragmentsby matching the code queries yielded in step against the code index built from the source code of software projects section .
.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden k. kim et al.
.
indexing ourapproachconstructsthreeindices snippet question andcode in advance to facilitate the search process as well as ensuring a reasonablesearchspeed .tocreatetheseindices weuseapache lucene oneofthemostpopularinformationretrievallibraries .
luceneindicesmaptokensintoinstanceswhichinourcasescan be natural language text code fragments or source code files.
.
.1snippet index.
thesnippetindexinfacoymaintains themappinginformationbetweenanswerdocumentidsofq a posts and their code snippets.
it is defined as a function inxs s 2p wheresis a set of code snippets and pis a set of q aposts.2pdenotesthepowersetof p i.e.
thesetofallpossible subsetsof p .thisindexfunctionmapsacodesnippetintoasubset ofp in which the answer in a post has a similar snippet to the input.
our approach leverages the snippet index to retrieve the q a post answers that include the most similar code snippets to a given query.
tocreatethisindex wemustfirstcollectcodeexamplesprovided as part of a q a post answer.
since code snippets are mixed in the middle of answer documents it is necessary to identify such regions containing the code snippets.
fortunately most q a sites including stackoverflow make posts available in a structured document e.g.
html or xml and explicitly indicate source code elements with ad hoc tags such as code code allowing facoytoreadilyparseanswerdocumentsandlocatecodesnippets.
aftercollectingacodesnippetfromananswer facoycreates its corresponding index information as a list of index terms.
anindex term is a pair of the form token type actual token e.g.
used class actionbar .table1enumeratesexamplesoftokentypes considered by facoy.
the complete list is available in .
table1 examplesoftokentypesforsnippetindexcreation.
typedescription typed method call partially qualified name of called method unresolved method call non qualified name of called method str literal string literal used in code figure shows an example of code fragment with the corresponding index terms.
public class baseactivity extends appcompatactivity public static final int image pick request code public static final int music pick request code protected actionbar actionbar override protected void oncreate bundle savedinstancestate super.oncreate savedinstancestate setcontentview r.layout.activity based a example code fragment.
extends appcompatactivity used class baseactivity used class rused class r.layoutused class actionbarused class bundlemethods declaration oncreate typed method call appcompatactivity.oncreate typed method call appcompatactivity.setcontentview b corresponding index terms.
figure extraction of index terms from a code fragment.
to generate index terms facoy must produce the abstract syntaxtree ast ofacodesnippet.eachastnodethatcorrespondsto a tokentype in table 14is then retainedto form an index term.
finally facoypreserves foreachentryintheindex theanswer document identifier to enable reverse lookup.
themainchallengeinthisstepisduetothedifficultyofparsing incompletecode acommontraitofcodesnippetsinq aposts .
indeed it is common for such code snippets to include partial statements or excerpts of a program with the purpose to give only somekeyideasinaconcisemanner.often snippetsincludeellipses i.e.
... b efore and after the main code blocks.
to allow parsing bystandardjavaparsers facoyresolvestheproblembyremoving the ellipses and wrapping code snippets with a custom dummy class and method templates.
besidesincompleteness codesnippetspresentanotherlimitation due tounqualified names.
indeed in code snippets enclosing class namesofmethodcallsareoftenambiguous .arecentstudy even reported that unqualified method names are pervasive in codesnippets.recoveringunqualifiednamesis however necessary for ensuring accuracy when building the snippet index.
to that end facoytransformsunqualifiednamesto partially qualified names by using structural information collected during the ast traversal of a given code snippet.
this process converts variable namesonwhichmethodsareinvokedthroughtheircorresponding classes.
figure showcases the recovering of name qualificationinformation.
although this process cannot recover all qualified names it does improve the value of the snippet index.
saxparserfactory ft inputsource is url ul new url feed ft saxparserfactory.newinstance saxparser pr factory.newsaxparser xmlreader rd pr.getxmlreader rsshandler hd new rsshandler rd.setcontenthandler hd is new inputsource url.openstream xmlreader.parse is return hd.getfeed a fragment before recovering name qualification.saxparserfactory ft inputsource is url ul new url feed ft saxparserfactory.newinstance saxparser pr saxparserfactory .newsa... xmlreader rd saxparser .getxmlreader rsshandler hd new rsshandler xmlreader .setcontenthandler hd is new inputsource url .openstream xmlreader .parse is return rsshandler .getfeed b fragment after recovering name qualification.
figure5 recoveryofqualificationinformation .recovered name qualifications are highlighted by red color.
disclaimer.
facoyiscompliantwiththecreativecommonsattributesharealikelicense ofstackoverflow wedonotredistribute any code from q a posts.
we only mine developer code examples instackoverflow to learn relationships among tokens.
.
.2questionindex.
thequestionindexmapsasetofword tokensintoq aposts.themappinginformationservestoidentify q a posts where the questions are similar to the questions retrievedinstep cf.figure3 whoseanswerscontaincodesnippets that aresimilar to the userinput.
facoy leverages this index toconstructalternatequeriestotheonederivedfromuserinput.
these alternate queries are necessary to increase the opportunities for finding semantically similar code fragments rather than only syntactically similar fragments.
the following equation defines the question index function inxq q 2p whereqis a set of questions and pis a set of q a posts.
this function maps a set of words from the input into a subset of posts pe p that are similar to the input.
4our approach focuses on the types in the table since they represent most of the characteristics in a code snippet.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
facoy a code to code search engine icse may june gothenburg sweden to buildthequestionindex facoytakesthequestion part q of each q a post and generates index terms.
to that end a preprocessing of the question text is necessary.
this pre processingincludes tokenization e.g.
splitting camel case stop word removal5 andstemming.fromthepre processingoutput facoy builds index terms in the form of term token .
each index term isfurthermappedwiththequestionwhereitstokenisoriginated from to keep an inverse link.
figure illustrates how given a question text index terms are generated.
a description text in a question.
term simpl term java term algorithm term generat term pseudo term random term alpha term numer term string term situat term uniq term session term key term identifi term uniq term 500k term requir term sophist term ideal term length term depend term string term length term term aeygf7k0dm1x b resulting index terms generated from a .
figure example of question index creation.
.
.3code index.
thecode index maintains mappinginformationbetweentokensandsourcecodefiles.facoyleveragesthis indextosearchforcodeexamplescorrespondingtoacodequery yielded at the end of step cf.
figure .
this index actually definesthesearchspaceofourapproach e.g.
f droidrepository ofandroidapps or javaprojects ingithub ora subsetof mozilla projects .
the code index function is defined as inxc s 2f wheresisasetofcodesnippetsand fisasetofcodefragments.
f actually defines the space of facoy.
the creation process of the code index is similar to the process for building the snippet index that is described in section .
.
.
facoyfirstscansallavailablesourcecodefilesintheconsidered codebase.then eachfileisparsed6togenerateanastfromwhich facoy collects the set of ast nodes corresponding to the token types listed in table .
the ast nodes and their actual tokens are usedforcreatingindextermsinthesameformatasinthecaseof thesnippetindex.finally eachindextermismappedtothesource code file where the token of the term has been retrieved.
.
search once the search indices are built facoy is ready to take a userquery and search for relevant code fragments.
algorithm formulates the search process for a given user query.
its input also considers the three indices described in section .
and stretch parametersusedinthealgorithm.thefollowingsectionsdetailthe whole process.
.
.1generatingacodequeryfromauserinput.
asthe first step of code search facoy takes a user input and generates a code query from the input to search the snippet index line in algorithm .
the code query is in the same form of index terms illustrated in figure so that it can be readily used to match the index terms in the snippet index.
5using lucene s version english default stop word set.
6thisstepalsorecoversqualifiednamesbyapplying whenevernecessary thesame procedure described in section .
.
.algorithm similar code search in facoy.
input c code fragment i.e.
user query .
input inxs qs a function of a code snippet s to a sorted list of posts ps.
input inxq qq a function of a question q to a sorted lis of questions qq.
input inxc qs a function of a code snippet s to a sorted list of code fragments fs.
input ns nq nc stretch parameters for snippet question and code search respectively e.g.
consider top nsimilar snippets .
output f a set of code fragments that are similar to c. 1function searchsimilarcodeexamples c inxs inxq inxc ns nq nc 2qin gencodequery c 3ps inxs qin .top ns 4qs ps.foreach pi takequestion pi 5pe qs.foreach qi inxq qi .top nq 6letf 7foreachpi pedo s takesnippet etanswer pi qex gencodequery s f f inxc qex .top nc 11end 12returnf 13end to generate a code query our approach follows the process described in section .
.
for generating the index terms of anygiven code snippet.
if the user input is also an incomplete codefragment i.e.
impossible to parse facoy seamlessly wraps thefragmentusingadummyclassandsomemethodtemplatesafterremoving ellipses.
it then parses the code fragment to obtain an astand collectthenecessary astnodesto generateindexterms in the form of token type actual token.
.
.2searching for similar code snippets.
after generatingacodequeryfromauserinput ourapproachtriestosearchfor similarsnippetsinanswersofq aposts line3inalgorithm1 .
since thecode queryand index termsin the snippet index are in thesameformat ourapproachusesfull textsearch i.e.
examining all index terms for a code snippet to compare with those in a code query .
the full text function implemented by lucene is utilized.
our approach computes rankings of the search results based on a scoring function that measures the similarity between the code query and matched code snippets.
facoy integrates two scoring functions boolean model bm and vector space model vsm which are already implemented in lucene.
first bm reducestheamountofcodesnippetstoberanked.ourapproach transforms the code query of the previous step qin into a normalform andmatches codesnippets indexedinthe snippetindex.
weadoptbestmatchretrievaltofindasmanysimilarsnippetsas possible.
then for the retained snippets vsm computes similarity scores.
after computing tf idf term frequency inverse doc ument frequency of terms in each snippet as a weighting scheme it calculates cosine similarity values between the code query and indexed snippets.
from the sorted list of similar snippets facoy takes top ns snippets i.e.
thosethatwillallowtoconsideronlymostrelevant natural language descriptions to associate with the user input .bydefault inallourexperimentsinthispaper unlessotherwise indicated we set the value of ns stretch parameter to .
.
.3searching for similar questions.
in this step line in algorithm our approach searches for questions similar to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden k. kim et al.
thequestionsofq a postsretrievedinthepreviousstep cf.
section .
.
.
the result of this step is an additional set of q a posts containing questions that are similar to the given questions identified as describing best the functionality implemented in the user input.thankstothis searchspaceenrichment approach facoy canincludemorediversecodesnippetsforenumeratingmorecode tokens which are semantically relevant.
tosearchforsimilarquestions weusethequestionindexdescribed in section .
.
.
since all questions are indexed beforehand theapproachsimplycomputessimilarityvaluesbetweenquestions as the previous step does cf.
section .
.
i.e.
filtering questions based on bm and calculating cosine similarity based on vsm.
once similarity scores are computed we select the top nqposts based on the scores of their questions as the goal is to recommend most relevant questions rather than listing up all similar questions.
since it takes nsposts for each of nqquestions retrieved in line of algorithm the result of this step consists of ns nqposts when using the same stretch parameter for both steps.
facoy can be tuned to consider different stretch values for each step.
.
.4generatingalternatecodequeries.
thisstep line5 in algorithm generates code queries from code snippets present in newly retrieved q a posts at the end of the previous step cf.section .
.
.
our approach in this step first takes q a postsidentifiedinline4andextractscodesnippetsfromtheiranswer parts.
it then follows the same process described in section .
.
togenerate code queries.
since the result of the previous step line isns nqposts whenusingthesamevalueforstretchparameters this step generates at most ns nqcode queries referred to as alternate queries.
.
.5searching for similar code fragments.
as the last step facoy searches the code index for similar code fragments to output lines in algorithm .
based on the alternate code queries generated in the previous step cf.
section .
.
and since codequeriesandindextermsarerepresentedinthesameformat facoy can leverage the same process of step illustrated in section .
.
to match code fragments.
while the step described in section .
.
returns answers containing code snippets similar to a userquery theresultofthisstepisasetofsourcecodefilescontain ingcodefragmentscorrespondingtothealternatecodequeryfrom the previous step.note that facoy provides at most ns nq nc codefragmentsasline10inalgorithm1uses nctotaketopresults.
delimitatingcodefragments sincedisplayingtheentirecontent of a source code file will be ineffective for users to readily locate the identified similar code fragment facoy specifies a code range after summarizing the content .
to summarize search results into a specific range facoy uses a query dependent ap proach that displays segments of code based on the query termsoccurring in the source file.
concretely the code fragment starts fromklines preceding the first matched token and spreads until k lines following the last matched token.
evaluation in this section we describe the designof different assessment scenarios for facoy and report on the evaluation results.
specifically our experiments aim to address the following research questions rq1 howrelevantarecodeexamplesfoundbyfacoycompared to other code to code search engines?
rq2 whatistheeffectivenessoffacoyinfindingsemantic clones based on a code clone benchmark?
rq3 dothesemanticallysimilarcodefragmentsyieldedby facoy exhibit similar runtime behavior?
rq4 couldfacoy recommend correctcode as alternative of buggy code?
toanswertheseresearchquestions webuildaprototypeversion of facoy where search indices are interchangeable to serve thepurpose of each assessment scenario.
we provide in section .
somedetailsontheimplementationbeforedescribingthedesign and results for the different evaluations.
.
implementation details accuracy and speed performance of a search engine are generally impacted by the quantity of data and the quality of the in dices .
we collect a comprehensive dataset from github a popularandverylargeopensourceprojectrepository aswellfrom stackoverflow a popular q a site with a large community to curate and propose accurate information on code examples.
we furtherleveragetheapachelucenelibrary whosealgorithmshavebeen tested and validated by researchers and practitioners alike for indexing and searching tasks.
for building the code index representing the search space of the code base where to code fragments we consider the github repository.wefocusonjavaprojectssincejavaremainspopularinthedevelopmentcommunityandisassociatedwithalargenumber of projects in github .
overall we have enumerated projects where java is set as the main language.
since there aremany toy projects on github we focused on projects that have been forked at least once by other developers and droppedout projects where the source code include non ascii characters.
table summarizes the collected data.
table statistics on the collected github data.
feature value feature value number of projects number of duplicate files number of files locs 384m forbuildingthesnippetandquestionindices wedownloaded adumpfile fromthe stackoverflow websitecontainingall posts between july and september in xml format.
in total we have collected and indexed posts tagged as about java or android coding.
we have used a standard xml parser to extract natural language elements tagged with p .
.
.
p markers and code snippets tagged with code .
.
.
code .
it should be noted that we first filter in code snippets from answers that havebeenacceptedbythequestioner.thenweonlyretainedthose accepted answers that have been up voted at least once.
these precautionsaimatensuringthatweleveragecodesnippetsthatare ofhighqualityandarereallymatchingthequestions.asaresult we eventually used q a posts to build the snippet and question indices.
by default we set all three stretch parametersto ns nq nc .
the stretch for delimitating output code fragments is also set to k .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
facoy a code to code search engine icse may june gothenburg sweden .
rq1 comparison with code search engines design in this experiment we compare the search results of facoywiththosefromonlinecodesearchengines.wefocuson krugle and searchcode since these engines support code tocode search.
as input code fragments we consider code examples implementing popular functionalities that developers ask about.
to that end we select snippets from posts in stackoverflow .
the snippetsareselectedfollowingtworequirements theassociated postisrelatedto java and theanswerincludecodesnippets.weselectcodesnippetsinthetop10postswiththehighestviewcounts fortheirquestions .table3liststhetitlesof stackoverflow posts whosecodesnippetsareusedinourexperiment.notethat forafair comparison and to avoid any bias towards facoy the actual posts includingthecodesnippetsintheiranswers showninthetable areremovedfromthesnippetandquestionindices thisprevents our tool from leveraging answer data in advance which would be unfair.
table3 top10 stackoverflow javapostswithcodesnippets.
query question title q1 how to add an image to a jpanel?
q2 how to generate a random alpha numeric string?
q3 how to save the activity state in android?
q4 how do i invoke a java method when given the method name as a string?
q5 remove html tags from a string q6 how to get the path of a running jar file?
q7 getting a file s md5 checksum in java q8 loading a properties file from java package q9 how can i play sound in java?
q10 what is the best way to sftp a file from a server?
figure shows an example of input code fragments collected fromstackoverflow thatisusedinourevaluation.10codesnippets7are then used to query facoy krugle and searchcode.
import java.security.securerandom import java.math.biginteger public final class sessionidentifiergenerator private securerandom random new securerandom public string nextsessionid return new biginteger random .tostring figure code snippet associated to q2 in table .
on each search engine we consider at most the top search resultsforeachqueryandmanuallyclassifythemintooneofthe four clone types defined in section .
table4 statisticsbasedonmanualchecksofsearchresults.
facoy searchcode krugle query outputs type 2type 3type outputs type 1type outputs type q1 .
.
q2 .
.
q3 q4 q5 .
.
.
.
.
q6 .
.
q7 q8 .
.
q9 q10 .
.
result table details statistics on the search results for the differentsearchengines.facoy krugle andsearchcode produce searchresultsforeight fourandonequeriesrespectively.search results can also be false positives.
we evaluate the efficiency of facoy using the precision kmetric defined as follows 7code snippets available on project web page .precision k q q summationdisplay i relevant i k k whererelevant i krepresentstherelevantsearchresultsforquery iin the top kreturned results and qis a set of queries.
facoy achieves .
and .
scores for precision and precision respectively.
we further categorize the true positive code fragments based on theclonetype.
krugleappearstobeabletoidentifyonlytype clones.searchcode ontheotherhandalsoyieldssometype 3code clonesfor2queries.finally facoymostlysuccessfullyretrieves type and type clones.
unlikeonlinecode to codesearchengines facoycanidentify similar codefragments fora more diverseset offunctionalityimplementations.
those code fragments can be syntactically dissimilar to the query while implementing similar functionalities.
.
rq2 finding similar code in ijadataset design this experiment aims at evaluating facoy against an existingbenchmark.sinceourcode to codesearchengineissimilar toacodeclone detectorinmanyrespects we focus onassessing which clones facoy can effectively identify in a code clone benchmark.
a clone benchmark contains pairs of code fragments which are similar to each other.
we leverage bigclonebench one of the biggest million clone pairs code clone benchmarks publicly available.
this benchmark is built by labeling of pairs of code fragments from the ijadataset .
.ijadatasetincludesapproximately25 000opensource java projects consisting of million source code files and millions of lines of code mloc .
bigclonebench maintainers have mined this dataset focusing on a specific set of functionalities.
theythenrecordmetadatainformationabouttheidentifiedcode clone pairs for the different functionalities.
in this paper we use a recent snapshot of bigclonebench including clone pairs clustered in functionality groups made available for the evaluation of sourcerercc .
weconsider8 104clonepairsin bigclonebench basedon the same criteriaused in bothcode fragments in aclone pair haveat least6linesand 50tokensinlength a standardminimum clone size for benchmarking .
clone pairs are further assigned a type based on the criteria in type 1andtype 2clonepairsareclassifiedaccordingto the classical definitions recalled in section .
type and type clonesarefurtherdividedintofoursub categoriesbasedontheir syntacticalsimilarity verystronglytype3 vst3 stronglytype3 st3 moderatelytype3 mt3 andweaklytype3 type4 wt3 .
each clone pair unless it is type or is identified as one of four if its similarity scorefalls into a specific range vst3 st3 mt3 and wt3 .
for this experiment we adapt the implementation described in section .
.
since the experiment conducted in detected clones only from ijadataset the github based code index in our tool is replaced by a custom index generated from ijadataset for a fair comparison.this makes facoy search only codefragments in ijadataset.
in addition the stretch parameters see algorithm authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden k. kim et al.
are set to ns nq nc making facoy yield as many snippets posts and fragments as possible in each step.
wefeedfacoywitheachcodefragmentreferencedinthebenchmark in order to search for their clones in the ijadataset.
we compare each pair formed by an input fragment and a search result against the clone pairs of bigclonebench.
we then compute the recall of facoy following the definition proposed in the benchmark recall d btc btc wherebtcisthesetofalltrueclonepairsin bigclonebench and dis the set of clone pairs found by facoy.
to quantify the improvement brought by the two main strategies proposed in this work namely query alternation andquery structuring we define four different search engine configurations baseline se the baseline search engine does not implement any query structuring or query alternation.
input code query as well as the search corpus are treated as natural language text documents.searchisthendirectlyperformedbymatchingtokens with no type information.
facoynoqa in this version only query structuring is applied.
no query alternation is performed and thus only input code query is used to match the search corpus.
facoynouq in this version query alternation is performed along with query structuring but initial input query is left out.
facoy this version represents the full feature version of the code to codesearchengine queriesarealternatedandstructured and initial input code query also contributes in the matching process.
result table details the recall8scores for the baseline se facoynoqa facoy nouqand facoy.
recall scores are summarizedperclonetypewiththecategoriesintroducedabove.sincewe are reproducing for facoy the experiments performed in we directlyreportinthistableallresultsthattheauthorshaveobtained on the benchmark for state of the art nicad iclones sourcerercc ccfinderx deckard clone detectors.
table recall scores on bigclonebench .
clone types t1 t2 vst3 st3 mt3 wt3 t4 of clone pairs facoy facoy nouq facoy noqa baseline se sourcerercc ccfinderx deckard iclones nicad cumulative number of wt3 clones that facoy found.
the tools could not scale to the entire files of ijadataset .
werecallthatfacoyisacode to codesearchengineandthus theobjectiveistofindsemanticclones i.e.
towardstype 4clones .
nevertheless foracomprehensiveevaluationoftheaddedvalue of the strategies implemented inthe facoy approach we provide comparison results of recall values across all clone types.
8it should be noted that recall is actually recall max.overall facoyproducesthehighestrecallvaluesformoderately type as well as weakly type and type clones.
the recall performance of facoy for mt3 clones is an order of magnitude higher than that of out the detection tools.
while most tools detectlittletonowt3 t4codeclonepairs facoyisabletofind over clones in the ijadataset.
furthermore apart from sourcerercc the othertools couldnot covertheentire ijadataset as reported in .benefitof querystructuring.
thedifferenceofperformancebetween baseline se and facoy noqaindicates that query structuring helps to match more code fragments which are not strictly syntactically identical to the query cf.
vst3 st3 .benefit of query alternation.
thedifferenceofperformancebetween facoy and facoy noqadefinitively confirms that query alternationisthestrategythatallowscollectingsemanticclones recall for wt3 t4 goes from to and recall for mt3 goes from to .benefit of keeping input query.
the difference of performance betweenfacoyandfacoy nouqfinallyindicatesthatinitialinput code query is essential for retrieving some code fragments that are more syntactically similar in addition to semantically similar code fragments matched by alternate queries.
with recall for semantic clones wt3 t4 facoy achieves the best performance score in the literature.
although this scoremay appear to be small it should be noted that this corresponds to the identification of clones a larger set than the accumulatedsetofallclonesofothertypesinthebenchmark.finally it should also be noted that while the dataset includes over .
million wt3 t4 code clones state of the art detection tools can detect only or less of these clones.
wefurtherinvestigatetherecalloffacoywithregardstothe functionalities implemented by clone pairs.
in bigclonebench e v ery clone pair is classified into one of functionalities including download from web and decompress zip archive .
for each clonetype wecountthenumberofclonesthatfacoycanfind per functionality.
functionalities with higher recall tend to have implementations based on apis and libraries while those with low recall aremorecomputation intensivewithoutapis.thisconfirmsthat facoyperformsbetterforprogramsimplementedbydescriptive apinamessinceitleverageskeywordsinsnippetsandquestions.
this issue is discussed in section in detail.
because of space constraints we refer the reader to the facoy project page for more statistics and information details on its performance.double checking facoy s false positives although it is one of thelargestbenchmarksavailabletotheresearchcommunity bigclonebench clone information may not be complete.
indeed as described in bigclonebench is built via an incremental additive process i.e.
gradually relaxing search queries based on keyword andsourcepatternmatching.thus itmaymisssomeclonesdespitethe manual verification.
in any case computing precision of a code search engine remains an open problem .
instead we chose to focus on manually analysing sampled false positives.
we manually verify the clone pairs that are not associated in bigclonebench but facoy recommended as code clones i.e.
false positives.
our objective is then to verify to what extent they are indeedfalsepositivesandnotmissesby bigclonebench.wesample 10falsepositivesperclonetypecategoryforamanualcheck.for32 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
facoy a code to code search engine icse may june gothenburg sweden out of cases it turns out that bigclonebench actually missed to include them.
specifically it missed type type type andeven4type 1clones.amongthe28cases for26cases facoy points to the correct file but another location than actual clones.
in only two cases facoy completely fails.
we provide this data inthe projectweb page as afirst steptowardsinitiating acurated benchmark of semantic code clones which can be eventually integrated into bigclonebench.
facoycanfindmoretype weaklytype 3andtype 4clonesthanthe state of the art thus fulfilling the objective for which it was designed.
.
rq3 validating semantic similarity design since facoy focuses on identifying semantically similarcodesnippetsratherthansyntactic structuralclones itisnecessary to verify whether the search results of the approach indeed exhibitsimilarfunctionalbehavior beyondkeywordmatchingwith high syntactic differences implied in bigclonebench .
the datasets used in sections .
and .
are however not appropriate for dynamicanalysis thecodemustcompileaswellasexecute andthere must be test cases for exercising the programs.
to overcome these challenges we build on dyclink a dynamic approach that computes the similarity of execution traces todetectthattwocodefragmentsarerelatives i.e.
thattheybehave functionally similarly .
the tool has been applied to programs writtenfor googlecodejam toidentifycoderelativesatthe granularity of methods.
we carefully reproduced their results with thepubliclyavailableversionofdyclink.amongthe642methods in the code base dyclink matches pairs as code relatives9.
weconsiderallmethodsforwhichdyclinkfindsarelativeand usefacoytosearchforitsclonesin codejam andwecheckthat the found clones are relatives of the input.
since facoy provides a ranked list of code examples for a given query we measure the hit10ratio of the top nsearch results.
here weusethedefaultstretchparametersspecifiedinsection4.1and thusn .in additionto hitratio we computethe meanreciprocal rank mrr of the hit cases.
to calculate mrr for each clone pair we use the following formula mrr q q summationdisplay i rank i whererankiistherankpositionofthecorrespondingcodefragment for the given peer in a clone pair.
qis the number of all queries.
result asaresult facoycanidentify278outof411coderelativesandthehitratiois68 .asforefficiency facoyachieves45 and scores respectively for precision and precision andexhibitsanmrrof0.
whichmeansfacoyrecommendsthe code relatives into lower rankings.
on the one hand since many programs in google code jam oftenusevariableswithnomeaning suchas void s int a facoycannotfindrelatedcodein stackoverflow andthuscannot build alternate queries limiting the hit ratio.
on the other hand 9wedid our bestto reproducethe resultsof dyclink.
we checkedwith the authors that the found relatives are consistent with the released tool version.
10a hit indicates that the corresponding code fragment is in the top nresults for a given query.since dyclink also uses a similarity metric to decide on code relativeness the mrr score of facoy could be higher with a more relaxed threshold currently set at in dyclink.
facoycanindeedfindalternativefragmentsthatexhibitsimilarruntime behavior with input code fragment.
.
rq4 recommending patches with facoy design thisexperimentattemptstousefacoytosearchfor correct code that can help fix buggy code.
code search has indeed been proposed recently as a potential step for patch recommendation and even automated repair .
since facoy can find codesnippetsthataresemanticallysimilartoagivenquerycode we conjecture that it can be used for helping find alternative implementations which may turn out to be more correct than the user scode.weassesssuchapotentialapplicationbyleveraging the defects4j benchmark .
defects4j include real bugs for each bug the buggy code andtheassociatedfixedversionaremadeavailable alongwithtest suitesforexecution.foreachbug wetakebuggycodefragment generally a function and query facoy.
by going through the search results from the top we manually compare each result with the actual paired fixed code.
our objective is to check whether facoy s output code fragments can help build a patch that would havebeencorrectw.r.t.tothebenchmarkfix.weperformthesame experiments using krugle andsearchcode .
public static boolean equals charsequence cs1 charsequence cs2 return cs1 null ?
cs2 null cs1.equals cs2 a defects4j buggy code fragment from commons lang .
public static boolean equals charsequence a charsequence b if a b return true int length if a !
null b !
null length a.length b.length if a instanceof string b instanceof string return a.equals b f o r i n ti i length i if a.charat i !
b.charat i return false return true return false b code fragment found in github by facoyas similar to fragment in a .
public static boolean equals charsequence cs1 charsequence cs2 return cs1 null ?
cs2 null cs1.equals cs2 if cs1 cs2 return true if cs1 null cs2 null return false if cs1 instanceof string cs2 instanceof string return cs1.equals cs2 return charsequenceutils.regionmatches ... c actual patch that was proposed to fix the buggy code in a .
figure successful patch recommendation by facoy.
for each bug one of the authors of this paper examined at most top search results from each search engine.
when the author marks a result as a good candidate for patch recommendation two other authors double check and the final decision is made authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden k. kim et al.
by majority voting.
note that since defects4j projects are also available in github the fixed code may be in facoy corpus.
thus wehavefilteredoutfromthesearchresultsanycodefragmentthat is collected from the same project file as the buggy code used as query.
figure 8a shows an example buggy function that we used as querytofacoy.fig.8bshowsoneofthesimilarcodefragments returnedbyfacoyandwhichwefoundthatitwasagoodcandidate for recommendingthe patchthat was actuallyapplied cf.
fig.8c .
result out of bugs in defects4j our preliminary results showthatfacoyfoundsimilarfixedcodeexamplesfor21bugs.in contrast searchcode located a single code example while krugle provided no relevant results at all.
specifically project specific resultsareasfollows.lang mockito chart closure time and math .
searchcode was successful only for mokito bug.
all details are available in .
facoy basedsearchofsemanticallysimilarcodefragmentscansupport patch coderecommendation softwarediversificationortransplantation.
discussions exhaustivity of q a data the main limitation of facoy comes from the use of code snippets and natural language descriptions in q apoststoenablethegenerationofalternatequeriestowards identifying semantically similar code fragments.
this data may simply be insufficient with regards to a given user input fragment e.g.
uncommon functionality implementation .
threats to validity as threat to external validity we note that we only used java subjects for the search.
however the same processcanbedevelopedwithotherprogramminglanguagesby changingthelanguageparser theindicesforrelatedq apostsand projectcode.anotherthreatstemsfromtheuseof stackoverflow andgithubwhichmaybelimited.wenotehoweverthattheirdata can be substituted or augmented with data from other repositories.
internalvalidity we usesubjectsfrombigclonebench anddyclinkdatasetstovalidateourwork.thosesubjectsmaybebiasedforclonedetection.nevertheless thesesubjectsarecommonlyused and allow for a fair comparison as well as for reproducibility.
related work code search engines.
code search literature is abundant .
codehow finds code snippets relevanttoauserquerywritteninnaturallanguage.itexploresapidocumentstoidentifyrelationshipsbetweenquerytermsandapis.sourcerer leveragesstructuralcodeinformationfromacomplete compilationunittoperformfine grainedcodesearch.portfolio is a code search and visualization approach where a chain of function calls are highlighted as usage scenario.
codegenie expands queries for interface driven code search idcs .
it takestest cases rather than free form queries as inputs and leverages wordnetand a code related thesaurus forquery expansion.
sirres et al.
also use stackoverflow data to implement a free form code search engine.clone detection and search.
clone detection has various applications such as plagiarism detection.
however most techniquesdetectsyntacticallysimilarcodefragmentsinsourcecodeusingtokens asttrees or programdependency graphs .onlyafewtechniquestargetsemanticallysimilar sourcecodeclones .komondoorandhorwitzsearchfor isomorphicsub graphsofprogramdependencegraphsusingprogram slicing .
jiang and su compare program execution traces using automated random testing to find functionally equivalentcode fragments .
mecc detects semantically similar c functionsbasedonthesimilarityoftheirabstractmemorystates .
whiteetal.
proposetousedeeplearningtofindcodeclones.
theirapproachismoreeffectivefortype 3clonesthantype .
coderecommendation systems supportdevelopers withreusablecodefragmentsfromotherprograms orwithpointers toblogsandq asites.strathcona generatesqueriesfromuser codeandmatchesthemagainstrepositoryexamples prompter directlymatchesthecurrentcodecontextwithrelevantq aposts.
although several studies have explored stackoverflow posts none to the best of our knowledge leveraged stackoverflow data to improve clone detection.
programrepair canalsobenefitfromcodesearch.gao et al.
proposed an approach to fix recurring crash bugs by searchingforsimilarcodesnippetsin stackoverflow .searchrepair infers potential patch ingredients by looking up code fragmentsencodedassmtconstraints.koyuncuetal.
showed that patching tools yield recurrent fix actions that can be explored tofixsimilarcode.liuetal.
explorethepotentialoffixpatterns for similar code fragments that may be buggy w.r.t.
findbugs rules.
api recommendation is a natural application of code search.
the baker approach connects existing source code snippets to api documentation .
muse builds an index of real source code fragments by using static slicing and code clone detection andthen recommends api usage examples.
keivanloo et al.
p r e sentedaninternet scalecodesearchenginethatlocatesworking code examples.
buse and weimer proposed an approach to recommend api usage examples by synthesizing code snippets basedondataflowanalysisandpatternabstraction.bajracharya proposed structural semantic indexing which examines the api calls extracted in source code to determine code similarity.
conclusion wehavepresentedfacoy acode to codesearchenginethataccepts code fragments from users and recommends semantically similar code fragments found in a target code base.
facoy is based onquery alternation after generating a structured code query summarizingstructuralcodeelementsintheinputfragment we searchinq apostsothercodesnippetshavingsimilardescriptions but which may present implementation variabilities.
these variant implementations arethen used togenerate alternate codequeries.
wehaveimplementedaprototypeoffacoyusing stackoverflow andgithubdata on java.
facoy achieves better accuracy than onlinecode to codesearchenginesandfindsmoresemanticcode clones in bigclonebench than state of the art clone detectors.
dynamic analysis shows that facoy s similar code fragments are indeedrelated execution wise.finally wehaveinvestigateda potential application of facoy for code patch recommendation on buggy code in the defects4j benchmark.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
facoy a code to code search engine icse may june gothenburg sweden