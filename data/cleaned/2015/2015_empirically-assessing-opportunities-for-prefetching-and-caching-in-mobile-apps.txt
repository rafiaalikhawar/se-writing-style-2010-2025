empirically assessing opportunities for prefetching and caching in mobile apps yixue zhao university of southern california los angeles california usapaul wat university of southern california los angeles california usa marcelo schmitt laser university of southern california los angeles california usanenad medvidovi university of southern california los angeles california usa abstract networklatencyinmobilesoftwarehasalargeimpactonuserexperience withpotentiallysevereeconomicconsequences.prefetching and caching have been shown effective in reducing the latenciesin browser based systems.
however those techniques cannot be directly applied to the emerging domain of mobile apps because of thedifferencesinnetworkinteractions.moreover thereisalackof research on prefetching and caching techniques that may be suitableforthemobileappdomain anditisnotclearwhethersuch techniques can be effective or whether they are even feasible.
this papertakesthefirststeptowardansweringthesequestionsbyconductingacomprehensivestudytounderstandthecharacteristics ofhttprequestsinover1 000popularandroidapps.ourwork focusesontheprefetchabilityofrequestsusingstaticprogramanalysis techniques and cacheability of resulting responses.
we find that there is a substantial opportunity to leverage prefetching and caching in mobile apps but that suitable techniques must take intoaccountthenatureofapps networkinteractionsandidiosyncrasiessuchasuntrustworthyhttpheaderinformation.ourobservationsprovideguidelinesfordeveloperstoutilizeprefetchingandcaching schemes in app development and motivate future research in this area.
ccs concepts software and its engineering software performance keywords prefetching caching mobileapps networklatency empiricalstudy acm reference format yixue zhao paul wat marcelo schmitt laser and nenad medvidovi .
.
empiricallyassessingopportunitiesforprefetchingandcachinginmobile apps.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.acm newyork ny usa 11pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
introduction there are over billion mobile phone users and millions of mobile appstoday .thelatencyinmobileappshasbeenshowntohave a large impact on user experience and potentially severe economic consequences .
the main cause of user perceived latency is the network since the majority of mobile apps fetch data from the internet regularly .1moreover mobile devices rely on wireless networks which can exhibit intermittent connectivity and low bandwidth .
optimizingnetworkperformancehaslongbeenstudiedindistributedsystems andprefetchingandcachingtechniqueshavebeen shownasahigh rewardwaytoreducenetworklatency theycanby passtheperformancebottleneck networkspeed andmasklatency by returning a response to a request from a local cache immediately .whileprefetchingmakesuseofbuilt incachingschemes caching onlytechniquesarealsowidelyemployed e.g.
.in thiswork westudythetworelatedphenomenaseparately prefetchabilityinvolves prefetching plus caching while cacheability involves only caching.
the research on prefetching and caching techniques in the web browserdomainhasyieldedalargebodyofwork .
however the resulting techniques cannot be applied to mobileappsduetotheirdifferentrootcausesofnetworklatency.in the browser domain the bottleneck for latency is resource loading sincealargenumberofresources usuallyfilessuchasimages are needed within each http request .
in the mobile app domain eachrequestonlyfetchesasingleresponse andadditionalrequestsneedtobeissuedexplicitlytofetchfurtherresources .thus prefetching and caching techniques in the browser domain targetsubresources withinasinglerequest while the researchinthemobileappdomainfocusesonseparatehttprequests .
mobile users currently spend more than of their time in mobile apps rather than using mobile browsers .
aside from a couple of exceptions there has been a lack of research on prefetching and caching techniques that may be suitable for the mobileapp domain.
in fact it is currently not clear whether such techniquescanbeeffectiveorwhethertheyareevenfeasibleinpractice.cachekeeper madeaninitialefforttostudytheredundantweb traffic in mobile apps and proposed an os level caching service.
however the resulting service was only evaluated on apps.
furthermore cachekeeper sperformancehighlydependsontheflaws 1in this context we define latency as the response time of an http request.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yixue zhao paul wat marcelo schmitt laser and nenad medvidovi in the web caching strategies employed in the original app and its broader utility is unclear.
our previous work paloma used program analysis to identify http requests that should be prefetchedin mobileapps.
wehighlightedseveral programanalysis challenges that can improve prefetching if addressed.
however palomawasevaluatedon32apps.itisthusuncleartowhatextent palomawillbeeffectiveatalargerscale andwhetheraddressing the identified program analysis challenges is worthwhile.
the dearth and shortcomings of previous work motivated us to conduct a more extensive empirical study that aims to understand the characteristics of http requests in mobile apps.
in this paper we report our results from the automated analysis of most popularandroidapps spreadacross33appcategories.ourworkfo cusesontheprefetchabilityofrequests paloma sproblemspace and cacheability of resulting responses cachekeeper s problem space .wefoundthatalargenumberofhttprequestsusedinrealappsareprefetchableandtheresponsestothoserequestscacheable.
this has the potential for significant reductions in user perceived latency whichwould inturn rendertheuseofcertainmobileapps even more attractive.
atthesametime ourstudyhighlightedtheneedtocarefullyconsider which requests should be prefetched and which data cached for two reasons.
first we empirically demonstrated the frequentlack of discipline with which developers use the relevant http headers in mobile specifically android apps making those headersmisleading.second weshowedthatresponsestocertainhttp requests that seem like good candidates for caching may yield incorrect app behaviors due to cache staleness.
our study is the first to provide extensive empirical evidence regardingthe opportunitiesforprefetching andcachingin mobile apps.
it is also the first to identify concrete shortcomings in the currentappdevelopmentpracticesthatareguaranteedtohinder solutionsthatmayotherwiseseemeasyandintuitive.asaresult the study has the potential to motivate significant future research in this area.
in this paper we have identified several promising research directions.
the remainder of the paper is organized as follows.
section overviewsthehttpprotocolanditsuseinthemobileappdomain.
section3motivates and states our research questions.
section describesourcollectionandprocessingofthesubjectapps.section discussesourfindingsandsection 6describesthethreatstotheir validity.
a discussion of related work and conclusions round out the paper.
background in this section we overview aspects of the http protocol thatare relevant to prefetching and caching.
we then illustrate with concrete examples of how developers perform network operations in mobile apps with a particular focus on android.
.
http protocol previous studies have shown that mobile apps spend between and of their time fetching data from the internet .
the majorityofappsrunoverhttp whererequestsaresentby clients and responses returned by servers.anhttp request consistsofanhttpmethod thedestination of the resource to fetch i.e.
the url and request headers andbody both of which are optional.
the http method get post delete etc.
needstobespecifiedbydeveloperswhensendinga request.optionalrequestheadersallowtheclienttopassadditional information to the server such as accept language en us .
the request body contains the resource to send to the server but is only needed for write http methods such as post.
http .
defines eight methods.
some of them such as delete are not suitable for prefetching because they may change the server s state contrary to the user s intention.
only the get andheadmethodsareconsidered safe inthattheyresultinthe retrieval of data and do not have any side effects on the server .
theheadmethod is similar to get except that its response does not contain a message body .
thus getrequests are of particular interest in our study.
anhttp response consists of a status code a status message and response headers and body both of which are optional.
the statuscodeandstatusmessageindicatewhethertherequestwas successfulornot andwhy.theresponsebodycontainsthefetchedresourcefromtheserver.responseheaderscontainadditionalinformation that is often used by developers to decide on their caching strategies.
for example the expires header specifies when the responsewillbecomestale while cache control headercontainsthe informationpertainingto cachingmechanismssuchas no cache andmax age.interestingly asobservedinourstudy seesection thoseheaderscannotalwaysbetrustedbydevelopers andsometimes they are missing altogether.
1url url newurl 2urlconnection conn url.openconnection 3conn.setrequestmethod post 4conn.setrequestproperty accept language en us 5outputstreamwriter wr newoutputstreamwriter conn.getoutputstream 6wr.write post data to send 7wr.flush 8inputstream responsestream conn.getinputstream 9map headermap conn.getheaderfields listing1 sendingapostrequestusingtheurlconnectionlibrary 1okhttpclient client newokhttpclient 2request request newrequest.builder .url .addheader accept language en us .post post data to send .build 7response response client.newcall request .execute 8headers headers response.headers listing sending a post request using the okhttp library .
http libraries used in mobile apps in android apps developers use off the shelf http libraries tointeract with servers.
listing 1and listing 2demonstrate how developers send http requests and receive responses using the twomostpopularhttplibrariesforandroid urlconnection and okhttp.
whensendinghttprequests developersneedtospecifythe urloftheresourcetobefetched listing line1 listing line3 httpmethod listing line3 listing line5 requestheaders authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirically assessing opportunities for prefetching and caching in mobile apps ase september montpellier france line4inbothlistings andrequestbody listing line6 listing line .
only the url is mandatory and getmethod will be used by default if the http method is not specified e.g.
if line in listing1andline5inlisting 2areremoved .whenreceivinghttp responses developers can retrieve the response body listing line8 listing line7 aswellastheresponseheaders listing line listing line that may contain caching information.
research questions the goal of this paper is to understand whether prefetching and caching can be applied to the mobile app domain effectively in ordertoreduceuser perceivedlatency.weformulatednineresearch questions rqs to this end.
these rqs target the prefetchability of http requests cacheability of http responses and redundancies among http requests.
.
prefetchability of http requests our objective is to assess the extent to which requests in mobile apps are prefetchable.
prefetchable requests are read only requests that have no side effects on the server state.
as discussed above section2.
in the context of the http protocol these are get requests .
furthermore we study whether the prevalence of prefetchablerequestsvariesacrossdifferentappcategories.such variationsmayallowidentifyingappcategoriesthatareparticularly suitable for prefetching.
we formulate three research questions to this end rq1 what is the number of getrequests per app?
rq2 what is the percentage of getrequests among all http requests in mobile apps?
rq3 how prevalent are getrequests across different app categories?
.
cacheability of http responses a prefetchable request may not be cacheable if the response to the requestchangesovertime e.g.
inthecaseofweatherdata .insuch cases thecachedresponsemaybestaleandservingitwouldlead to incorrect app behavior.
to determine when a response becomes stale orwhetherarequestiscacheableatall developershavetorely on the header information specified in the response specifically expiresandcache control recall section .
.
however there are no standard rules for developers to follow when constructing a response leaving open the possibility that header information may be unreliable or even missing.
to investigate this we formulate four additional research questions rq4 how prevalent are expiresheaders?
rq5 a r eexpires headers trustworthy?
rq6 how prevalent are cache control headers?
rq7 a r ecache control headers trustworthy?
.
identifying truly redundant http requests cachingisonlyeffectivewhenthereexistredundantrequestsfor the same resource.
an http request is redundant if a previous request specified the same http method and url and yieldedthesameresponse thelaterrequestisredundantbecausetheoriginalresponsecouldhavebeenstoredlocallyandreused.previous work suggestsanopportunityformobileapp basedcaching techniques in that it identified the presence of redundant http traffic and showed that implementations of web caching are inadequateformobileapps.ourworkgoesbeyondidentifyingredundant http requests and tries to assess the intent behind them.
a set of ostensibly redundant requests could be generated on purpose e.g.
toretrieveupdatedweatherinformation andthusmaynotbe truly redundant.
if a caching scheme fails to consider this it will lead to cache staleness.
we thus consider the actual responses to the candidateredundantrequests aimingtodistinguishamongthem and provide better insights for future caching techniques in mobile apps.
with this in mind we formulate the last two research questions rq8 how prevalent are redundant http requests?
rq9 aretheidentifiedostensiblyredundantrequeststruly redundant?
data collection this section details the workflow we used for data collection the criteria behindour selection of subject apps app instrumentation our collection of data via runtime testing and the reasons for eliminating certain apps from the subject set before conducting further analysis.
all of the raw data regarding our subject apps and the corresponding code are publicly available .
.
data collection workflow figure1illustratestheworkflowweimplementedforcollectingthe data needed to answer the nine research questions stated above.
the initial subject apps were downloaded from the google play store section .
.theappswereautomaticallyinstrumentedbased on the information extracted from http library documentation and the decompiled code of several sample apps section .
.
the instrumented apps were automatically tested using randomly gen erated inputs to produce logs that contain the information needed to answer rq rq4 rq6 and rq section4.
.wemanually examinedtheappsthatcouldnotbetestedduetoproblemssuchas installationfailuresandruntimecrashes toidentifytherootcauses of the problems section .
.
finally we automatically sent get requeststothesubjectappsatdifferenttimeintervals toanswer rq5 r q7 and rq sections .2and5.
.
.
initial set of subject apps wedownloaded1 687top rankedappsacross33categoriesfrom the google play store in the united states.
of the apps could be processed by soot a state of the art tool for instrumenting androidapps asfurtherdiscussedinsection .
.thesizesofthose apps vary between kb and .
mb.
the total number of http requests per app varied between and in our tests as described in section .
.
table1summarizestheinformationaboutthe1 308subjectapps.
the table shows the maximum and average numbers of http requestsperappforeachcategory theminimumnumberofhttp requestsineverycategoryis0andwethusomititfromthetable.
finally theright mostcolumnshowsthenumberofappsineach authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yixue zhao paul wat marcelo schmitt laser and nenad medvidovi figure our data collection workflow.
the app profiling app instrumentation app testing and send get requests components perform automated tasks.
category that sent at least four http requests in our tests as well as the percentage of such apps compared to the total number of apps in the given category.
the reason behind highlighting this subset of the subject apps will be explained in section .
.
.
app instrumentation each subject app went through an automated instrumentation process offline that used soot to insert code that captures information about http requests and responses.
this information is primarilylocatedinthehttpheaders.capturingsuchinformation inthebrowserdomainisstraightforwardbecausehttprequests and responses are managed in a unified way.
on the other hand mobile apps presented a challenge we first had to identify how thehttprequestsandresponsesarehandledindifferenthttp libraries recall section .
only then could we instrument the corresponding code to capture this information automatically.
it was thus necessary to determine what libraries most apps use tosendhttprequests.wefirstidentifiedasetofpopularhttp libraries including urlconnection okhttp volley andretrofit .we thenanalyzed asampleof thesubjectapps bytecodes and checked the package names against the libraries.
for example the presence of the string java.net.urlconnection generally indicates the use of the urlconnection library.
the data gathered from our analysis point to urlconnection andokhttpasthemostpopularhttplibrariesusedinthesubject apps.
this is unsurprising urlconnection is the standard built in library of the android framework and it has been augmented with okhttpsinceandroidv.
.
kitkat .wethusdecidedtofocuson urlconnection andokhttpin our study.
we then performed a more detailed analysis of how our subject apps use these two libraries.
we recorded the runtimes of those methods that are importedfrom urlconnection andokhttp and narrowedourfocustomethodsthataremosttime consuming.the rationale isthat those are mostlikely to be themethods related to sending requests and receiving responses over the network.
in addition we inspected the decompiled code of the subject apps aswellasthedocumentationandsourcecodeofthehttp libraries used in the apps to identify the actual usage of httprequestsandresponses.thereasonforthisadditionalinspection isthatdeveloperssendrequestsandreceiveresponsesinvarious ways even when using the same http library.
listings 1and2 insection 2onlydemonstrateonecommonwayofusingeachof the two http libraries.
while recommended in thelibraries documentation there is no requirement or guarantee that developers will followthis guidance intheir apps.
furthermore the examples table app information for each category among initial subjects category apps max req avg req apps req .
art design .
.
.
auto vehicles .
.
.
beauty .
.
.
books reference .
.
business .
.
.
comics .
.
.
communications .
.
dating .
.
.
education .
.
.
entertainment .
.
.
events .
.
.
finance .
.
.
food drink .
.
.
games .
.
.
health fitness .
.
.
house home .
.
libraries demo .
.
.
lifestyle .
.
.
maps navigation .
.
.
medical .
.
.
music audio .
.
.
news magazines .
.
.
parenting .
.
.
personalization .
.
.
photography .
.
.
productivity .
.
.
shopping .
.
.
social .
.
.
sports .
.
.
tools .
.
.
travel local .
.
.
video players editors .
.
.
weather .
total .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirically assessing opportunities for prefetching and caching in mobile apps ase september montpellier france in the documentation are at the source code level while our instrumentation using soot is at the bytecode level.
this meant that we needed to understand the actual usage of those two http librariesatthebytecodelevel.withtheadditionalinspection we were able to identify the actual methods used for sending requests and receiving responses in the apps allowing us to instrument the codetocapturethepreciseinformationneededforourstudy.for example line9inlisting 1definesheadermap thatcontainsallof the header information our instrumentation then inserts a method after line to capture the headers relevant to our study such as expires header.itisimportanttonotethattheinstrumentedapps primary functionality is left unchanged in this process.
.
app testing aftertheinstrumentation eachappwassubjectedtorandominput testingthroughandroiddebugbridge adb .weusedtheui application exerciser tool monkey to generate random streams of userevents suchasclicks touches andswipes.weusedrandom events in this study for two reasons to avoid bias introduced byparticularuserbehaviorsand togeneratelargevolumesof runtime requests automatically which would not be practical if we reliedon ahuman user.this isfurther discussedin section .
theappswererunonthenoxplayerandroidemulator .each testconsistedof3 000eventsunderwifinetworksettings.wealso exploredtestingwith1 and10 000events.wefoundthat was the smallest number of events that yielded a represen tative number of http requests triggered at runtime across the subjectapps neither5 000nor10 000eventsresultedinasignificantincreaseinhttprequests while1 000eventsprovedtobetoofew to adequately exercise the relevant functionality in the apps.
alltestswereprecededbyafreshinstallationofthegivensubject app andthe appwas removedfrom theemulator aftereach test s conclusion.
this minimized the chances of errors caused by any interference between apps or by previously saved settings.
.
final set of subject apps theobjectiveofourstudyistodeterminewhetherandwhenhttp requests should be prefetched and their responses cached.
in some cases thenumberofhttprequeststriggeredinourtestswasvery low suggestingthatprefetchingandcachinginsuchappswould notbebeneficial.todeterminethenatureof lownetworkusage appsandtheunderlyingreasonsbehindthedataweobtained we manuallyinspectedeachapp startingwiththosethatdonottrigger any requests.
atotalof623outofthe1 308subjectappstriggerednorequests.
we identified six recurring reasons behind this the app s installation failed.
the app crashed upon launching.
the app s version was incompatible with the noxplayer android emulator .
the app was obfuscated so that the methods relevant to http requests were not captured by our instrumentation.
the app required external information before it could be used such as a bank pin commonly required in the finance category oravehiclelicenseplate commonlyrequiredin theauto vehicles category .
the app only contained static content and did not rely on the network.
note that while we could not automatically test the above apps many of them may in fact trigger http requests at runtime.
the only exception are apps from the last category.
the automated nature of our app testing prevented us from determining the exact numbers of apps that fell in each of the above six categories.
amanualinspectionofarandomsampleoftheappssuggeststhat with a confidence level no more than of the apps contained only static content.
anadditional234ofthe1 308subjectappstriggered1 3requests at runtime.
we observed a common pattern among these apps.
namely regardlessofthetypeofapp thoserequeststendedtobe one or more of the following load an application specific configuration file.
log in with facebook using facebook graphrequest.
use monitoring services such as crashlytics orgoogle analytics.
furthermanualtestingoftheseappsyieldednoadditionalhttp requests beyond the above three.
this finding shows a common usageofpopularthird partyservicesinmobileappdevelopment whoseimpactonappperformanceshouldalsobetakenintoaccount in terms of overhead data usage and energy consumption.
wewereunabletoidentifyanypatternssuchastheaboveinapps thattriggeranyothernumberofrequests.thus thebelowanalysis ofprefetchability andcacheability is based on of our subject appsthattriggerfourormorerequestsatruntime corresponding to the right most column of table .
results and discussion this section describes the results of our analysis framed by the nineresearchquestionsfromsection anddiscussesthelessons learnedfromtheresults.table 2summarizestheinformationabout the final set of subject apps in each category that are analyzed in this section.
note that the app categories are numbered to aidthedepictionandunderstandingofthefiguresintheremainderof this section.
among the apps the number of http requestsrangedbetween4 thecut offnumberforouranalysis asdiscussed above and1 withtheaverageslightlyabove35requestsper app.
.
prefetchability of http requests recallfromsection 3thatwetrytoanswerthreeresearchquestions regardingtheprefetchabilityofhttprequests.specifically weare interested in getrequests which are the primary candidates for prefetching.
rq1 what is the number of getrequests per app?
rq2 what is the percentage of getrequests among all http requests in mobile apps?
rq3 how prevalent are getrequests across different app categories?
to answer the above questions we instrumented and tested our subject apps using the procedure described in section .
we calculatedthetotalnumberof getrequestsobservedduringourtesting authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yixue zhao paul wat marcelo schmitt laser and nenad medvidovi and the percentage of getrequests among all http requests triggered at runtime in each app.
we subsequently grouped the results by app category.
figure 2depicts the minimum maximum and average numbersofgetrequests per app rq across the different categories rq .
figure 3depicts the minimum maximum andaverage percentages ofgetrequestsas comparedtoall http requests rq in each app category rq .
ourdataindicatethat getrequestsarepervasiveacrossall33app categories.asshowninfigure sevencategoriescontainedapps that sent or more getrequests.
on average an app sent get requests andthoserequestscomprised68 ofallhttprequests sentbytheapp.asshowninfigure severalcategories beauty comics entertainment and events had veryhighpercentagesof getrequests.onlytwocategories dating and tools had slightly fewer than of getrequests.
theseresultssuggestthatthereisasignificantopportunityto exploit prefetching among the subject apps that sent or more http requests.
it was surprising to see that apps spanning 29ofthe33categories sentonly getrequests.certaincategories are potentially more suitable for prefetching than others.
this is a by product of the types of functionality that are typical in agiven category.
the nature of apps in stable domains such asart design orlibraries demo is such that they may be able figure minimum bottom edges maximum top edges and average horizontal dashes numbers ofgetrequests in apps across the app categories.
apps in categories hadmaximums higher than numbers displayed beside thecorrespondingbars .notethattheaverageforappcategory3 is also higher than and thus not shown.
figure minimum bottom edges maximum top edges and average horizontal dashes percentages ofgetrequests in apps across the app categories.to operate with less remotely accessed data than apps in more dynamic domains such as news magazines orshopping.
this suggeststhatprefetchingandcachingtechniquesmaybenefitfrom leveraging knowledge regarding an app s domain.
table2 appinformationforeachcategoryamongfinalsubjects category apps min.
req max.
req avg.
req .
art design .
.
auto vehicles .
.
beauty .
.
books reference .
.
business .
.
comics .
.
communications .
dating .
.
education .
.
entertainment .
.
events .
.
finance .
.
food drink .
.
games .
health fitness .
.
house home .
.
libraries demo .
lifestyle .
maps navigation .
.
medical .
music audio .
.
news magazines .
.
parenting .
personalization .
.
photography .
productivity .
.
shopping .
.
social .
.
sports .
.
tools .
.
travel local .
.
video players editors .
.
weather .
total .
.
cacheability of http responses as discussed in section the cacheability of http responses is a function of the presence of cache control andexpiresheaders and their trustworthiness.
to that end we try to answer the following four research questions.
rq4 how prevalent are expires headers?
rq5 a r eexpires headers trustworthy?
rq6 how prevalent are cache control headers?
rq7 a r ecache control headers trustworthy?
toanswertheabovequestions weinstrumentedthesubjectapps tocaptureresponseheaders recallsection .
andcalculate the numbers of occurrences of the two relevant headers.
to determine whethertheheaderofagivenrequestistrustworthy wemadeeach request4times atinitialtime t t t and t 60seconds.
this allowed us to determine whether later responses reflect what is specified in the header of the original response.
for example let us assume that the original request is sent at time t andthattheresponseheadercontains expires time exp .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirically assessing opportunities for prefetching and caching in mobile apps ase september montpellier france figure minimum bottom edges maximum top edges andaverage horizontaldashes numbers ofexpiresheaders in each app category.
apps in categories had maximumshigher than numbers displayed beside or above the cor responding bars .
figure minimum bottom edges maximum top edges and average horizontal dashes percentages of the expires headers for each app category.
figure minimum bottom edges maximum top edges and average horizontal dashes percentages of trusted expiresheaders in each app category.
we will mark the header as untrustworthy if it falls into any of the following three cases where xis the time period after the original request is sent time exp time t time t time exp time t x response t response t x time exp time t x response t nequalresponse t x figure minimum bottom edges maximum top edges and average horizontal dashes numbers ofcache control headersineachappcategory.appsin14categorieshadmax imums higher than numbers displayed beside or abovethe corresponding bars .
figure minimum bottom edges maximum topedges and average horizontal dashes percentages of cache control headers in each app category.
figure minimum bottom edges maximum top edges and average horizontal dashes percentages of trusted cache control headers in each app category.
in our case xis any of s s o r6 s. the first case indicates a scenario where the response expires before the request is evensent.
the second case indicates a scenario where the response is supposed to have expired but ithas remained unchanged.
finally the third case indicates a scenario where the response should have remained the same but it changed.
weusetheanalogousalgorithmtodeterminewhetherthe cachecontrolheaderistrustworthy basedonthe max agefieldspecified within the header.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yixue zhao paul wat marcelo schmitt laser and nenad medvidovi figure4shows the minimum maximum and average numbers oftheexpiresheadersincludedinhttpresponsesforeachapp category rq .figure5showstheminimum maximum andaverage percentagesof the expiresheaders amongall theresponse headers in each app category rq .
figure6shows the percentages of the trustworthy expiresheaders among all the expires headers rq .
figures and9show the analogous information for thecache control header rq rq7 .
fromtheresults wecanconcludethatthe expires headersand cache control headers are not always included in the responses andtheyarenotalwaystrustworthy.the cache control header tendstobeusedmorereliablythanthe expires header.acrossthe app categories of the response headers contain expires on average while contain cache control .
only an average of of the expiresheaders are trustworthy while of the cache control headersaretrustworthy.whilethereareindividual appsamong oursubjectswhere eachof thetwoheaders wasused in a completely trustworthy manner there were an even greater number of apps where the opposite was true .
these results strongly suggest that developers should not depend on the response headers to determine their caching schemes.
unfortunately therearecurrentlynoreliablealternativesforthe mobile app domain.
however this presents a research opportunity toinvestigatemoreintelligentapproaches.onestrategythatsuggests itselfbased on ourstudy would involve learning the correct informationtoincludeintheheadersbasedonhistoricaldata.such a technique could then automatically suggest app modifications in order to fix the buggy headers.
.
identifying truly redundant http requests asdiscussedinsection redundanthttprequestsaregoodcandidatesforprefetchingandcaching.however certainhttprequests are only ostensibly redundant in that they seem identical but actually yield different responses.
our final two research questions aim to shed light on this issue.
rq8 how prevalent are redundant http requests?
rq9 aretheidentifiedostensiblyredundantrequeststruly redundant?
in our analysis we have specifically focused on getrequests as discussed previously.
to answer the above questions upon completion of testing a givenapp byexecutingthe3 000eventsasexplainedinsection .
weidentifytheostensiblyredundantrequestsineachapp.wethen runascriptthatexecutestheappbysendingeachidentifiedrequest four times at initial time t t t and t seconds.
we checkwhethertheresponseschangeduringthisinterval.thishelps to identify http requests that are truly redundant the responses to those requests are thus suitable candidates for caching.
figure10shows the minimum maximum and average percentagesoftheidentifiedostensiblyredundantrequestsascomparedto the total number of requests in each app category rq .
figure11 showstheminimum maximum andaverageexpirationtimesfor the identified requests rq .
a request s expiration time is the timeatwhichitsresponseisdifferentfromtheresponsereceivedfortheinitialrequestattime t.finally figure 12showstheminimum maximum andaveragepercentagesofthe trulyredundant requests rq .
asfigure 10shows redundantrequestscompriseasignificant proportion of all http requests across most of the app categories.
incertainapps nearly100 oftherequestsareredundant while the average across all apps is .
by themselves these results would suggest considerable cacheability potential.
this is further bolstered by some of the results in figure whichpointstoseveralappsinwhichthehttprequestsdidnot figure minimum bottom edges maximum top edges andaverage horizontaldashes percentagesof ostensibly redundant requests in each app category.
figure minimum bottom edges maximum top edges and average horizontal dashes expiration times for the redundant requests in each app category.
figure minimum bottom edges maximum top edges and average horizontal dashes percentages of trulyredundant requests in each app category.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirically assessing opportunities for prefetching and caching in mobile apps ase september montpellier france expire even after the full 60s.
however this is somewhat deceptive the average request expiration time was 12s across the app categories itwasexactly10sforseveralofthecategories andonly two categories food drink and house home had average expiration times over 20s.
since 10s was the shortest interval used in our study these results suggest that most redundant requests expirewithinarelativelyshorttimeperiod.thisshouldbetaken into account when devising caching schemes for mobile apps.
finally figure 12shows that on average an overwhelming majorityofostensiblyredundantrequestsare truly redundant across the app categories.
this means that the ostensibly redundant requestdidnotexpireatoneormoreofthe10s 30s and60scheckpoints.
in a number of individual apps all ostensibly redundant requestsaretrulyredundant themaximumvalueof100 while their average for app categories is as high as .
this observation showsalargeopportunityforcachingredundantrequestsinmobile apps.
.
implications our study provides evidence that prefetching and caching can be beneficial in a large number of mobile app scenarios.
at the sametime wecameacrossseveralappsinwhichprefetchingand caching are unlikely to have significant or any benefits.
at theleast these include the several hundred apps from our originalset of subjects that only provide static content or make very few http requests.
in fact it is possible that the number of these appssurpassesthe451appsthatdorelyonthenetworkandthat we included in our final set of subjects recall the discussion in section4.
.
this outcome was at least somewhat surprising given the long history of research on data prefetching and caching in distributedsystems ofwhichmobileappsareonlyamorerecent example.
adeeperanalysishelpstoidentifyseveralreasonsbehindthis.
forexample inhindsightitmayhavebeenexpectedthatappsfrom thelibraries demo orvideo players editors categories provide static content such as pdf viewers organizers digital books and video players.
on the other hand we did not expect to find almost as much static content in auto vehicles.
we already discussed in section4.5thatanumberofappsfromthiscategoryrequiredlogin by suppling a license plate number.
an additional large numberofappsalsocontainedpurelystaticcontent suchasinstructions onhowtoperformcarmaintenance.thisisreflectedinourdata under ofthe auto vehicles apps made itinto our final set of subjects recall table .
another issue was presented by apps that used network communicationthatwaseithernotbasedonhttporextensivelyused httpmethodsotherthan get.forexample anumberofappsin thecommunications categoryprovideinstantmessagingcapabilities including voip while others actually implement browsers.
maps navigation providegpsapplicationsthatdiffersignificantly from typical http services.
yet another example are financeapps.
even though of these apps made it into our final set of subjects alotofthemarebankingappsthatpredominantlyperform push type operations making them ill suited for prefetching.
even within the final subject apps there are clearly some for which the benefits of prefetching and caching may be marginal.gamespresented an interesting case.
over2 3of the apps in this category made it into our final set of subjects since they used sufficiently large numbers of http requests.
these apps also exhibited veryhigh cache control trustworthiness.ontheotherhand as expected their requests tended to expire very quickly and to have littleredundancy.therefore whileagameappmaybeidentifiedasacandidateforprefetching theresultingcacheddatawouldbecome stale very quickly.
in turn this would possibly lead to incorrect app behavior or just as bad constant thrashing of the prefetching facilities that would cripple the app s performance.
theseissuescanbefurtherillustratedwithasomewhatcrude analysisofanaverageappfromoursubjectset.theaverageapp sent 28getrequests recall section .
as a result of the automaticallygenerateduievents.
ofthoserequestsweretruly redundant recallsection .
.thatmeansthatupto6 getrequests were prefetchable.
our previous work paloma measured the processing of a single http request to take slightly over 800ms under network conditions similar to ours.
this would mean that an average app among our subjects would save only 4s by caching andreusingtheresultsoftheoriginalrequest assumingthatthe cache does not become stale.
whilewemustbecognizantofapps suchasthoseabove that arenotespeciallyamenabletoprefetchingandcaching severalscenarios in our study paint a much more favorable picture.
consider the app from category beauty that issued getrequests recallfigure allofwhicharetrulyredundant corresponding to the maximum value for app category in figure .
even if we assumethattheresultofeachredundantrequestcanonlybereusedoncebeforeitexpires recallfromfigure 11thattheexpirationtime forappcategory3is10s thatstillyields621requestsforwhichthe results can be reused from the local cache.
assuming once again the same executionconditions as paloma s this would result in massive execution time savings totaling 497s or .
minutes.
in summary there is a notable opportunity for prefetching and caching in the mobile app domain.
at the same time the resulting techniquesmusttakeintoaccountthecharacteristicsofdifferent app categories and different http requests.
otherwise the em ployed techniques may yield undesired outcomes such as cache staleness non trivial performance overhead and incorrect app behaviors.
threats to validity ourstudyisbasedontop ranked freeandroidapps.therefore our results may not hold for paid apps or lower ranked apps.
however over of the android apps in the google play store are free .
furthermore top ranked apps are used most widely.
this suggests that our results should have broad applicability.
weexcludedfromournumericalanalysistheappsthattrigger fewerthanfourhttprequestsat runtime.ho wever part oftheobjective of our study was to explore this problem space.
specifically weidentifiedthereasonsbehindtheapps lownumbersofrequests recallsection .
.furthermore weacknowledgedexplicitlythat the exclusion of these apps from the final set of subjects limits the applicability of our findings recall section .
.
our study is based on apps that use the http protocol and two http libraries urlconnection andokhttp .
our findings authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yixue zhao paul wat marcelo schmitt laser and nenad medvidovi are unlikely to be directly applicable to other protocols for network communication and they may not carry over to other http libraries.
however most mobile apps and in particular android apps relyonhttp .furthermore ourfocusisonthefundamental characteristics of http requests and responses and those characteristicsdonotchangeacrossdifferenthttplibraries.including other libraries would naturally result in the inclusion ofgreater numbers of subject apps.
however given the popularityof the http libraries we selected our results should be widely representative among android apps.
in our process for answering rq r q7 and rq we sent out sets of four requests at times t t t and t seconds recall sections .2and5.
.
as shown in figure redundant requeststendtoexpireat t 10orsoonthereafter.thisindicates that t is a sufficiently long period to identify truly redundant requestsinmostcases.furthermore mobileuserstendtousean appforrelativelyshortperiods sothatprefetchingandcachingfar in advance is not necessary and is likely to yield cache staleness.
while choosing different time intervals would likely not lead to differentresults finer grainedintervalsmaygiveustighterbounds on request expiration times.
finally our app usage information was obtained via automated generationofuievents asopposedtologgingrealuserevents.thismayresultinnumbersandsequencesofhttprequeststhatarenotrepresentativeofactualappuse.however thepurposeofourstudy wastoanalyzeallpossiblehttprequeststhatcouldbepotentially triggeredatruntime and3 000randomeventswereshowntobe able to generate representative http requests as discussed insection4.
.
given the nature of the study and the large number ofappsweaimedtoanalyze itwouldhavebeenunreasonableto attempttofindactualusersforeachapp whileourresultswould potentially suffer from user specific biases and idiosyncrasies in engaging the app.
on the other hand mimicking actual users with humanswhoareunfamiliarwiththeappsinquestion whichwould have been a more likely alternative would have suffered from the same potential problem as our automated testing.
furthermore all of our research questions focus on individual http requests rather than their sequences.
thus real user traces would notlead todifferentresultscomparedtorandomordersofruntimeevents.
finally neither actual nor novice human users would have beenable to repeatedly and reliably generate large numbers of events 000perappexecutioninthemainportionofourstudy andup to per execution in the preliminary analysis .
related work web prefetching and caching are entrenched techniques to reduce network latency since the internet was born and have attracted alargebodyofworkinbrowserdomain includingmeasurement studies to understand web performance and identify performance bottlenecks literature reviews and quantitative studies to compare fundamental prefetching and caching al gorithms leveraging prefetching and caching techniques at different levels such as studying user browsing behaviors providing api support for developers restructuring page load process providing server or infrastructure support .the recent surge of mobile devices has attracted researchers to study prefetching and caching techniques in the context of mobile browsersandmobileapps.withthefoundationofthetraditional research in browser domain mobile browser performance soon became a crowded research area but the researchonmobileappsisstillinitsinfancy.thisisunfortunate because mobile users currently spend more than of their time in mobile apps rather than mobile browsers .
in mobile app domain cachekeeper studied the redundant http traffic and proposed an os level caching service for http requests on smartphones.paloma usedprogramanalysistoaddress what and when toprefetchcertainhttprequestsinmobileapps.however thosetechniqueswereonlyevaluatedonasmallnumberofapps andtheperformancedependsontheflawsofwebcachingschemes employed in the original apps thus it is not clear to what extent thosetechniques will beeffectiveinpractice.
thoseshortcomings ofexistingapproachesmotivatedus toconductanin depthstudy that aims to understand the characteristics of http requests in ordertoguidefutureresearchinmobileapps.otherexistingworks thatfocusonmobileappperformancearecomplementarytoour focus such as pre launching mobile apps balancing quality of service qos tosuggest howmuch toprefetch identifying performance bottlenecks .
conclusion in this paper we presented the results of an extensive empirical studyaimedatunderstandingthecharacteristicsofhttprequests andresponsesinmobileapps.weformulatednineresearchquestionswiththefocusonthe prefetchability ofhttprequestsand cacheability of http responses.
our overarching objective is to fillinthegapbetweenthewell studiedbrowserdomainandcomparatively less explored mobile app domain by motivating and providing guidelines for future research in this area.
ourresultssuggestthatprefetchingandcachingcanbeuseful across a wide range of mobile apps and scenarios but they are not universally applicable and their benefits will vary.
certain app categoriesaremoreamenableforprefetchingandcaching.however thereisanon trivialamountofvariationevenamongdifferentapps within a single cateogry.
while our analysis reported in this paper doesnotprovidedefinitiveanswerstoquestionsof what when and how much to prefetch cache it providesa process tools and data thatform afoundationfor answeringthosequestions muchmore precisely than has been possible thus far.
acknowledgment theauthorsthankwilliamg.j.halfond jiapinggui andtherest of their research group at the university of southern california forprovidinguswiththeapksforoursubjectapps.thisworkis supported by the u.s. national science foundation under grants no.ccf 1618231andccf u.s.officeofnavalresearch under grant no.
n00014 and by huawei technologies co. ltd. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirically assessing opportunities for prefetching and caching in mobile apps ase september montpellier france