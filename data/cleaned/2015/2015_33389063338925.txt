ifixflakies a framework for automatically fixing order dependent flaky tests august shi university of illinois urbana il usa awshi2 illinois.eduwing lam university of illinois urbana il usa winglam2 illinois.edureed oei university of illinois urbana il usa reedoei2 illinois.edu tao xie university of illinois urbana il usa taoxie illinois.edudarko marinov university of illinois urbana il usa marinov illinois.edu abstract regression testing provides important pass or fail signals that developers use to make decisions after code changes.
however flaky tests which pass or fail even when the code has not changed can mislead developers.
a common kind of flaky tests are order dependent tests which pass or fail depending on the order in which the tests are run.
fixing order dependent tests is often tedious and time consuming.
we propose ifixflakies a framework for automatically fixing order dependent tests.
the key insight in ifixflakies is that test suites often already have tests which we call helpers whose logic resets or sets the states for order dependent tests to pass.
ifixflakies searches a test suite for helpers that make the order dependent tests pass and then recommends patches for the order dependent tests using code from these helpers.
our evaluation on truly orderdependent tests from a public dataset shows that of them have helpers and ifixflakies can fix all .
we opened pull requests for order dependent tests of were already fixed and developers have already accepted pull requests for of them with all the remaining ones still pending.
ccs concepts software and its engineering software testing and debugging .
keywords flaky test order dependent test patch generation automated fixing acm reference format august shi wing lam reed oei tao xie and darko marinov.
.
ifixflakies a framework for automatically fixing order dependent flaky tests.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
introduction regression testing is an important part of software development but it suffers from the problem of flaky tests.
developers run regression tests when they make changes to ensure that the changes do not break existing functionality.
flaky tests can pass or fail even when run on the same code without any changes.
these tests are problematic for software testing in general and they are particularly problematic for regression testing because they provide misleading signals to developers regarding the effects of their changes .
typically when a test fails the failure indicates a fault introduced by a change and the developers should debug the change.
however with flaky tests a test failure may not indicate a fault introduced by a change and developers can waste time trying to debug a fault unrelated to recent changes .
labuschagne et al.
found that of the failed builds studied by them in open source projects using travis ci are due to flaky tests.
the software industry also widely reports major problems with flaky tests e.g.
luo et al.
reported that at one point 73k of .6m test failures per day at google were due to flaky tests.
an important kind of flaky tests are order dependent tests which pass or fail based solely on the order of the sequence in which the tests run .
each order dependent test has at least one test order a sequence of of tests in the test suite where the orderdependent test passes and at least one other different test order where the order dependent test fails if the two test orders do not differ the test is not flaky solely due to the ordering.
prior work showed that order dependent tests are among the top three most common kinds of flaky tests.
as an example a widely reported case happened when java projects updated from java to java .
java changed the implementation of reflection which junit uses to determine the test order to run tests in.
many tests failed due to the tests being run in a different test order from before requiring developers to manually fix their test suites .
prior work including ours developed automated techniques for detecting order dependent tests in test suites .
furthermore we released a dataset of flaky tests where about half are order dependent.
in this paper we propose a framework ifixflakies that can automatically fix many order dependent tests.
our key insight is that test suites often but not always already have tests which we call helpers whose logic re sets the state required for orderdependent tests to pass.
we first identify that an order dependent esec fse august tallinn estonia august shi wing lam reed oei tao xie and darko marinov test can be classified into one of two types based on the result of running the test in isolation from the other tests.
one type is a victim an order dependent test that passes when run in isolation but fails when run with some other tests.
the other type is a brittle1 an order dependent test that fails when run in isolation but passes when run with some other test s .
more specifically our insight for ifixflakies is that running some helper s directly before victims and brittles makes these order dependent tests pass.
therefore we can use the code from these helpers to fix order dependent tests so that they pass even if helpers are not run directly before the order dependent tests.
ifixflakies searches for helpers and when it can find them uses them to automatically recommend patches for order dependent tests.
as inputs ifixflakies takes an order dependent test a test order where the test passes and a test order where the test fails.
it outputs a patch that can be applied to the order dependent test to make it pass even when run in the test order where it was failing before.
the code in the patch comes from a helper and while simply using all the code from the helper can create a patch such a patch would be complex and undesirable because helpers typically contain many statements irrelevant to why the tests are order dependent.
ifixflakies produces effective patches by delta debugging the helpers to produce the minimal patch for order dependent tests.
we evaluate ifixflakies on all truly order dependent tests from a public dataset that includes the order dependent tests and their corresponding passing and failing test orders.
we find that tests are victims and are brittles.
we also find that of these order dependent tests have helpers allowing ifixflakies to propose patches for all of these tests victims and brittles .
these patches have on average only .
of the statements of the original helper and .
of these patches consist of only one statement .
the overall time that ifixflakies takes to find the first helper and to produce a patch using that helper is only seconds on average.
when an order dependent test has no helper ifixflakies takes seconds on average to determine that it cannot produce a patch.
these time results show that ifixflakies is efficient.
we opened pull requests for order dependent tests with helpers of were already fixed in the latest version of the code .
while all patches generated by ifixflakies semantically fixed the flaky test not all patches were syntactically the most appropriate.
for tests we created the pull requests using exactly the patch recommended by ifixflakies while the remaining ones involved some manual changes mostly refactorings to make the code more similar to the style of the project.
developers have accepted our pull requests fixing order dependent tests the pull requests for the remaining order dependent tests are still under consideration but none have been rejected.
this paper makes the following main contributions formalization.
we formally define two different types of order dependent tests and three different roles of tests that can help in the patching of order dependent tests.
technique.
we present a technique to fix order dependent tests using helpers.
our technique automatically generates a patch for out of order dependent tests.
1the word brittle is commonly used as an adjective but can also be used as a noun.
framework.
we implement our technique and make publicly available a framework ifixflakies .
evaluation.
we evaluate ifixflakies on a dataset of order dependent tests.
using ifixflakies we break down the order dependent tests into victims and brittles where of these tests have helpers.
furthermore ifixflakies is able to automatically fix allthese order dependent tests.
formalization of tests order dependent tests are flaky tests whose results can differ depending on the order in which the tests run.
an order dependent test consistently passes when run in one order but then consistently fails when run in a different order .
lettbe the set of all tests2in the test suite.
a test order is a sequence of a subset of tests from t. for a test order othat has a testt t letrun t o be the result of the test twhen run in the test order o the result can be either pass orfail consistently we ignore other flaky tests that have results pass andfail when rerun in the same test order due to other sources of non determinism.
we userun o to refer to the result of the lasttest in o. we use to denote a test order consisting of just one test t and use o o to denote the concatenation of two test orders oando .
definition .
a test t thas a passing test order or afailing test order oif run t o pass or run t o fail respectively.
definition .
anorder dependent test t thas a passing test order oand a failing test order o o. we classify an order dependent test into one of two types victim or brittle.
we also classify other tests related to order dependent tests into three different roles polluter cleaner and state setter.
.
victim avictim is an order dependent test that consistently passes when run by itself in isolation from other tests.
definition .
an order dependent test v tis avictim if run pass .
the reason why a victim fails in a failing test order is that there is at least one test that runs before the victim and these tests pollute the state e.g.
global variable file system network on which the victim depends.
we call such state polluting tests polluters .
note that a polluter can consist of multiple tests where the combination of running those tests in a certain order leads to the victim failing.
definition .
a test order with one or more tests pis apolluter for a victim vif run p fail .
figure shows an example identified by ifixflakies of a victim and a polluter from elastic job .
the polluter is by itself the test assertremovelocalinstancepath orptfor short because it starts the instance line but does not shut it down.
the victim is the test assertisshutdownalready orvtfor short that fails on line which checks whether an instance of a class variable has been shut down.
vtpasses by itself or in test orders where a polluter like pt is run after vt. 2when we say test for java we mean test method as defined in junit.
546ifixflakies a framework for automatically fixing order dependent flaky tests esec fse august tallinn estonia victim in shutdownlistenermanagertest class test public void assertisshutdownalready shutdownlistenermanager .
new instanceshutdownstatusjoblistener .
datachanged test job instances .
.
.
type .
node removed verify schedulerfacade times .
shutdowninstance polluter also in shutdownlistenermanagertest class test public void assertremovelocalinstancepath jobregistry .
getinstance .
registerjob test job jobschedulecontroller regcenter shutdownlistenermanager .
new instanceshutdownstatusjoblistener .
datachanged test job instances .
.
.
type .
node removed verify schedulerfacade .
shutdowninstance cleaner in failoverservicetest class test public void assertgetfailoveritems jobregistry .
getinstance .
registerjob test job jobschedulecontroller regcenter ... more lines jobregistry .
getinstance .
shutdown test job figure example victim polluter and cleaner from elastic job.
a victim may not fail even when a polluter is run before it as long as a cleaner is run between the two.
intuitively a cleaner is a test order that resets the state polluted by a polluter when the cleaner is run after a polluter and before its victim the victim passes.
definition .
a test order cis acleaner for a polluter pand its victim vif run p c pass .
an example of a cleaner is also shown in figure .
the test assertgetfailoveritems orctfor short is a cleaner for ptand vt because line of ctshuts down the instance that ptstarts and vt checks.
therefore even if ptruns before vt as long as ct s line successfully executes before vt vtpasses.
we can fix vtby inserting the statement from this line of ctat the end of pt.
.
brittle in contrast to a victim an order dependent test is a brittle if the test consistently fails when run by itself in isolation.
definition .
an order dependent test b tis abrittle if run fail .
intuitively because a brittle fails in isolation and yet has a passing test order then its passing test order must contain one or more tests that set up the state for the brittle to pass.
we refer to a test order that sets up the state for a brittle as a state setter .
definition .
a test order sis astate setter for a brittle bif run s pass .
figure shows an example identified by ifixflakies of a brittle and its corresponding state setter test from wildfly .
the test testpermissions orbtfor short is a brittle because it fails when run by itself due to an accesscontrolexception .
the test testbind orstfor short is by itself a state setter for bt because running st and then btis enough to make btpass.
ifixflakies finds that the store.lookup call of ston line is the only method call that btneeds in order to pass.
store is a test class variable initialized by the setup method of the test class.
when store.lookup is invoked before line btpasses.
when we proposed this fix to the developers of wildfly they quickly accepted1 brittle in writableservicebasednamingstoretestcase class test public void testpermissions throws exception ... final string name a b final object value new object try ... store.bind new compositename name value ... assertequals value testactionwithpermission jndipermission.
action lookup permissions namingcontext name state setter also in writableservicebasednamingstoretestcase class test public void testbind throws exception final name name new compositename test final object value new object ... more lines assertequals value store.lookup name figure example brittle and state setter from wildfly.
def ifixflakies odtest passingorder failingorder odtype polluters cleaners minimize odtest passingorder failingorder patches ifodtype victim for polluter inpolluters for cleaner incleaners patches cleaner else odtype brittle for statesetter inpolluters patches statesetter return patches figure pseudo code for the overall process of ifixflakies.
our fix and clarified that it works because the lookup call causes the wildflysecuritymanager.
clinit to run and running this class constructor resolves the accesscontrolexception ofbt .
both cleaners for victims and state setters for brittles help make order dependent tests pass when they run in certain test orders.
hence we refer to cleaners and state setters as helpers .
our insight is that these helpers already contain logic to set the state for their corresponding order dependent tests.
ifixflakies we present ifixflakies to automatically recommend patches for order dependent tests with helpers.
figure shows the pseudocode for the overall process.
ifixflakies takes as input an orderdependent test a passing test order and a failing test order.
by definition each order dependent test has at least one passing and one failing test order.
several automated approaches exist for detecting order dependent tests and their corresponding test orders which can provide all these inputs for ifixflakies.
ifixflakies has two main components minimizer and patcher.
ifixflakies first calls minimizer line to get the type of the order dependent test the minimized polluters state setters and the minimized cleaners.
based on the type of the order dependent test ifixflakies then calls patcher to create patches corresponding to each helper for the order dependent test lines and .
prior to developing ifixflakies we attempted to manually fix some order dependent tests using just their passing and failing test orders.
in this manual process we found it difficult to understand why each test fails let alone fix.
however as part of this process 547esec fse august tallinn estonia august shi wing lam reed oei tao xie and darko marinov def minimize odtest passingorder failingorder isolation run run in isolation multiple times to confirm it is order dependent for iin range rerun if not isolation run raise exception incorrectly classified as order dependent passing in isolation means victim failing means brittle ifisolation pass odtype victim startingorder failingorder expected fail else isolation fail odtype brittle startingorder passingorder expected pass polluters set state setters for brittles cleaners empty map from polluters to cleaners get minimal test order that causes odtest to match expected result prefix startingorder while run prefix expected polluter deltadebug prefix lambda o run o expected polluters.add polluter ifodtype victim cleaners findcleaners odtest polluter passingorder failingorder if not configured to find everything stop if not find all break prefix.remove polluter return odtype polluters cleaners figure pseudo code for finding minimal test orders.
we found ourselves manually searching for the polluter cleaner and state setter tests for order dependent tests which inspired minimizer.
once we realized the importance of the helpers and how they can be used as the basis for patches we developed patcher.
overall we found that the manual steps that we undertook could be automated by a tool leading to ifixflakies and such automation can save developers time for fixing order dependent tests.
.
minimizer minimizer aims to find the minimal subsequence3of tests called minimal test order from a passing test order or a failing test order to make the order dependent test pass or fail respectively.
the minimal test order is minimal meaning removing any test from the minimal test order will no longer satisfy the criterion .
figure shows the pseudo code for minimizer.
the input is an order dependent test and its two test orders.
as shown in lines minimizer first checks whether the order dependent test consistently passes or fails by itself rerunning the test rerun number of times default is .
if the test consistently passes or fails it is likely order dependent.
this check should not be needed when the input test is correctly classified as order dependent but our evaluation finds that we incorrectly classified one test in our previous work .
if the test is truly order dependent the isolation result determines whether it is a victim or a brittle lines .
next minimizer proceeds to delta debug the prefix to find the minimal test order line .
delta debugging iteratively splits a sequence of elements to find a smaller subsequence that satisfies a criterion.
our general delta debugging method takes two 3the term subsequence refers to a potentially non consecutive subset of elements in relation to the original ordering.
def findcleaners victim polluter passingorder failingorder determine cleaner candidates from passing and failing orders candidates polluterpos indexof polluter passingorder victimpos indexof victim passingorder ifpolluterpos victimpos candidates polluterpos indexof polluter failingorder victimpos indexof victim failingorder candidates candidates add all tests as single candidates candidates for cinfailingorder filter out candidates to find actual cleaners cleaners for cincandidates ifrun polluter c pass if not configured to find everything just return the first one if not find all return pass cleaners minimize the cleaners so polluter cleaner victim passes return unique map lambda c deltadebug c lambda o run polluter o pass cleaners figure pseudo code for finding cleaners.
parameters the sequence to start delta debugging and the criterion in the form of a function to check the current subsequence validity at each iteration.
for line a subsequence is valid when running it before the order dependent test matches the expected result for that test.
the delta debugging output is a minimal test order representing a polluter for a victim or a state setter for a brittle ideally the polluter or state setter consists of only one test.
the search for finding a polluter or a state setter is the same so our code assigns the final result to the variable named polluter but it is actually a state setter if the order dependent test is a brittle.
in practice after line a developer would proceed to find a cleaner for the polluter if the order dependent test was a victim or proceed to patcher if the order dependent test was a brittle.
however for the sake of our experimental evaluation we introduce the option to find allpolluters or state setters from these test orders.
if the find all option is set line minimizer proceeds to find more polluters or state setters by first removing the found polluter or state setter and then continuing with the loop that calls delta debugging again lines .
the process stops when running the prefix before the order dependent test no longer matches the expected result.
our evaluation section .
shows that finding more polluters or state setters does not provide substantial benefits in terms of patching order dependent tests so in practice one can just use the first handful of found tests of each type.
.
.
finding cleaners.
after finding a polluter for a victim minimizer proceeds to find cleaners lines of figure .
figure shows the findcleaners method.
it takes as input a victim a polluter for the victim a passing test order and a failing test order.
the returned cleaners make the victim pass when they are run between the polluter and the victim.
first findcleaners determines cleaner candidates which are test orders that are potentially cleaners.
findcleaners finds cleaner candidates using the passing and or failing test order depending on 548ifixflakies a framework for automatically fixing order dependent flaky tests esec fse august tallinn estonia def patch order helpertests statements grab statements from helper methods including setups and teardowns for hinhelpertests statements get setup h get body h get teardown h create a method within the last helper s class with these statements patchmethod insert new method test class helpertests insert call to patchmethod at start of flaky test last test in order insert call at start patchmethod order delta debug statements such that the order that was failing can pass minimalstatements deltadebug statements lambda s patchmethod.
setbody s .
compile and run order pass patchmethod.setbody minimalstatements return patchmethod figure pseudo code for finding a patch.
the index of the polluter and victim in these test orders.
for the passing test order if the victim is run after the polluter then a cleaner must be among the tests that run between the polluter and victim so these tests in between become a cleaner candidate lines .
for the failing test order a cleaner can be run before the polluter or after the victim so tests that run before the polluter and after the victim both become cleaner candidates lines .
finding a cleaner is crucial to enable automated search for a patch.
to maximize the chance to find at least one cleaner findcleaners also considers every individual test as a cleaner candidate including even both the polluter and the victim line .
by considering every test as a cleaner candidate findcleaners may even find a cleaner that junit would never run between the polluter and the victim.
more specifically when a polluter and victim are in the same class findcleaners may find a cleaner consisting of tests from a different class junit will never run this cleaner between the polluter and victim.
findcleaners still searches for such cleaners because their code can be used by patcher.
for each cleaner candidate findcleaners runs the polluter the cleaner candidate and then the victim checking whether the victim passes in this test order.
if the victim passes then the cleaner candidate is an actual cleaner findcleaners proceeds to delta debug the cleaner candidate to find the minimal test order line with the delta debugging criterion being that running the polluter the subsequence from the cleaner and the victim passes.
if the find all option is not set then the first cleaner found is returned.
otherwise findcleaners checks the remaining cleaner candidates for the set of all unique cleaners.
we use this option to find all cleaners as part of our evaluation section our results suggest that finding just a few cleaners suffices.
minimizer takes the returned cleaners from findcleaners and adds them to a map from found polluters to found cleaners line in figure .
the final return value for minimizer is a tuple of the type of the order dependent test victim or brittle the polluters or state setters for the order dependent test and the map from polluters to cleaners empty if the order dependent test is a brittle .
.
patcher patcher automatically recommends patches for fixing an orderdependent test using code from helpers.
patcher takes as input the minimal test order where the order dependent test fails victim in shutdownlistenermanagertest class test public void assertisshutdownalready call to patch method new failoverservicetest .
patch ... starting patch method in failoverservicetest class public void patch statements from beforeclass or before ... statements from cleaner assertgetfailoveritems ... jobregistry .
getinstance .
shutdown test job statements from afterclass or after ... figure starting code of patcher for example in figure .
victim in shutdownlistenermanagertest class test public void assertisshutdownalready call to patch method new failoverservicetest .
patch ... final patch method in failoverservicetest class public void patch jobregistry .
getinstance .
shutdown test job figure final code of patcher for example in figure .
for a victim this order is the polluter followed by the victim and for a brittle this order is just the brittle and a helper for the order dependent test note that a helper can consist of multiple tests .
figure shows the pseudo code for patcher.
first patcher obtains all of the statements from the tests in the helper line .
these statements come from not just the body of the tests themselves but also from all the setup and teardown methods of these helper tests.
we use javaparser a library for parsing java source code to obtain these statements.
patcher keeps these statements in the order that junit runs them in i.e.
statements in before run first then statements in the test and lastly statements in after .
more specifically get setup obtains the statements from the setup methods annotated with beforeclass or before in the test class or super classes get body obtains all statements in the helper test s body and get teardown obtains statements from the teardown methods annotated with afterclass or after in the test class or super classes .
if the helper test has the annotation expected which indicates that the test expects a particular exception to be thrown for it to pass then get body also wraps the statements from the test in an appropriate try catch block.
next patcher adds code to run the helper code before the orderdependent test in two steps.
first patcher creates an empty method referred to as the patch method to store all of the statements from the helper line .
second patcher inserts a call to the patch method at the start of the order dependent test line .
the inserted code creates an instance of the test class using the default constructor and uses that instance to call patch .
note that the code shows inserting this call at the start of the order dependent test but for a victim the call can also be inserted at the end of the polluter.
users can configure patcher to insert the patch at the beginning of the order dependent test or at the end of the polluter for victims.
549esec fse august tallinn estonia august shi wing lam reed oei tao xie and darko marinov table breakdown of the likely order dependent tests from a public dataset .
of tests category in a class with fixmethodorder reuseforks is set to false in pom.xml 1non order dependent test 2out of memory when run with ifixflakies truly order dependent tests figure shows an example of the starting code to be minimized by patcher.
this code is adapted from the example in figure .
line shows the declaration of the new patch method.
the body of the patch method contains all of the statements from the setup method of failoverservicetest the cleaner test body assertgetfailoveritems and the teardown method of failoverservicetest .
the inserted line line calls patch using a new instance of the helper s test class.
finally patcher delta debugs the statements from the helper to find the minimal list of statements that can make the orderdependent test pass when run in the minimal test order line of figure the minimal list of statements is also minimal and the finest granularity is at the level of statements as defined by javaparser .
the delta debugging method is the same general one as in minimizer except this time it is minimizing the list of statements from the helper tests instead of test orders.
the deltadebugging criterion for patcher is that the patch method compiles and the inserted code makes the order dependent test pass when run in the minimal test order.
patcher returns the patch method with the minimal list of statements for the order dependent test to pass.
figure shows the final code after patcher runs the patch method contains only one statement line .
while the order dependent test can already be fixed by inserting a call to the patch method at the start of the order dependent test a developer using ifixflakies can choose to inline the statements from the patch method directly into the order dependent test or into the polluter.
in some cases it may be trivial to just inline these statements into the order dependent test body.
however in general a developer should decide whether it is best to inline the statements of the helper into the order dependent test or polluter or leave them in a separate method.
factors that may influence the developer s decision include the applicability of the patch method to other tests and the data encapsulation of the patch method.
to further refine how statements invoked from helpers fix the order dependent test patcher could potentially minimize and inline the statements of methods indirectly invoked by the helper tests.
by minimizing those statements the developer can be given a patch that is much more specific to the cause of the flakiness.
however it can be difficult to inline statements from code further away from the helper tests.
also the number of statements in the final patch will likely increase.
as such patcher currently does not minimize the statements of these invoked methods and we leave such investigation for future work.
evaluation setup we released a public dataset of flaky tests including order dependent tests as part of our prior work .
our dataset is split into two sets comprehensive and extended.
for our evaluation we use thecomprehensive set.
this set consists of likely order dependent tests from maven modules a maven module consists of code and tests from the project that the developers organized to be built and run together.
our dataset also has at least one passing and one failing test order for each order dependent test.
we implement ifixflakies as a plugin for maven .
for each module in the maven project ifixflakies takes as input orderdependent tests in the module to fix along with a passing test order and failing one for each one.
ifixflakies uses a custom junit test runner to run the tests so ifixflakies currently recommends patches for only junit order dependent tests in maven based projects.
unfortunately not all tests in the dataset are well suited for our goal of submitting patches to developers.
first tests are in test classes annotated with fixmethodorder .
this annotation tells junit to run the tests within that test class in a fixed order.
since the developers are already aware of the order dependent tests in their test suite and have taken measures to address them we omit these tests from our evaluation.
second tests from the dataset are in modules that use the maven surefire parameter reuseforks to run each test class isolated in its own jvm.
such isolation removes many of the dependencies between tests and is another way used by developers to accommodate order dependent tests.
we run ifixflakies on all the remaining purported orderdependent tests using the passing and failing test orders from our dataset.
some order dependent tests have more than one passing test order and or failing test order in the dataset and we need only one of each for ifixflakies so we arbitrarily choose one of each test order to run ifixflakies.
we configure ifixflakies to find allpolluters cleaners and state setters for every order dependent test.
for each order dependent test we run ifixflakies on microsoft azure with the virtual machine size standard d11 v2 which consists of cpus 14gb of ram and 100gb of hard disk space.
overall we find truly order dependent tests.
test is misclassified as order dependent found to be non order dependent through our reruns and due to the large number of polluters and cleaners tests encounter out of memory errors from ifixflakies.
table shows the summary breakdown of the tests from the dataset.
evaluation to evaluate the effectiveness and efficiency of ifixflakies we address the following research questions rq1 what are the numbers of victims brittles polluters cleaners and state setters found by ifixflakies among test suites with orderdependent tests?
how many tests can ifixflakies fix?
rq2 what are the characteristics e.g.
size uniqueness of the patches generated by ifixflakies?
rq3 how much time does ifixflakies take to find polluters cleaners state setters and patches?
we address rq1 primarily to inform researchers and tool developers on which types of order dependent tests and roles of tests are the most common so that they can be prioritized appropriately.
with the main insight of ifixflakies being to use helpers to propose patches for order dependent tests rq1 also evaluates the frequency of tests that have helpers and therefore the applicability of our insight on order dependent tests.
we address rq2 to evaluate the effectiveness in terms of size and accepted pull requests concerning the patches proposed by ifixflakies and rq3 to evaluate the 550ifixflakies a framework for automatically fixing order dependent flaky tests esec fse august tallinn estonia table characteristics of the order dependent tests od in the projects used in our study.
number of average number of victims w polluters cleaners state setters id project name module tests od victims brittles cleaners per victim per victim per brittle m1 alibaba fastjson .
.
.
m2 apache incubator dubbo m1 .
.
n a m3 m2 .
.
.
m4 m3 .
.
n a m5 m4 .
.
n a m6 apache jackrabbit oak .
.
.
m7 apache struts .
.
n a m8 dropwizard dropwizard .
.
n a m9 elasticjob elastic job lite .
.
n a m10 jfree jfreechart .
.
n a m11 kevinsawicki http request .
.
n a m12 undertow io undertow .
.
n a m13 wildfly wildfly .
.
.
total average per test .
.
.
efficiency of ifixflakies and thus how it could be integrated into a practical software development process.
.
rq1 characteristics of tests table shows some summary information about the projects and modules that contain at least one order dependent test.
for each module the table lists the total number of tests the number of order dependent tests and the breakdown of the number of victims and brittles among those order dependent tests.
overall we find that out of order dependent tests tests are victims and tests are brittles so most order dependent tests are victims.
table also shows the average number of polluters per victim cleaners per victim that have cleaners and state setters per brittle that ifixflakies finds.
each victim has at least one polluter.
in the final row for averages we show the averages computed per test not per module .
on average we find .
polluters per victim with a total of polluters for the victims.
note that our search does notexhaustively find all polluters for a victim the polluters that it finds depend on the position of the victim in the failing test order.
on average across all victims the position of a victim in its failing test order is .
i.e.
a victim is just over the halfway position in the failing test order .
of the victims have just one polluter while victims have more than one polluter the max number of polluters per victim is and the median is polluters per victim.
while a polluter can consist of multiple tests that only when run together before the victim lead to it failing section we find that only polluters consist of more than one test.
because most polluters consist of only one test it is practical to assume only one test pollutes the state for a victim and future work on finding polluters may benefit from focusing on individual tests.
we hypothesized the existence of cleaners among the orderdependent tests in our prior work and using ifixflakies we find and show the actual number of cleaners per victim and polluter different polluters for the same victim may have cleaners in common but we report each cleaner separately per polluter for the same victim because each one indicates a potential different patch for that victim.
we find that victims of the total victims haveat least one cleaner so almost half of all victims can be fixed using the code from their corresponding cleaners.
of these victims have just one cleaner while the remaining have more than one cleaner.
the average number of cleaners per victim with at least one cleaner is .
and the median number of cleaners per victim is cleaners.
in total we find cleaners for all these victims where each cleaner consists of only one test.
as described in section .
.
when ifixflakies searches for cleaners it considers every test as a potential cleaner even when junit would not run such a test in between the polluter and victim.
from the victims with cleaners we find with cleaners that junit would not run between the polluter and the victim.
interestingly two of the cleaners are actually the polluters of a victim as well!
we also find that victims have more than one polluter with cleaners.
interestingly all polluters of these victims have exactly the same cleaners.
based on these results a developer should use ifixflakies to search for cleaners in just one polluter to know whether a victim contains a cleaner or not.
different cleaners can produce different patches but we find that the numbers of statements produced by different cleaners are similar section .
.
concerning state setters each brittle must have at least one state setter and we find a brittle has on average .
state setters and the median number of state setters is .
the brittles have a total of state setters.
because all brittles can be fixed using code from one of their state setters and victims have cleaners ifixflakies can recommend patches for a total number of tests over half of the truly order dependent tests.
in total ifixflakies finds helpers to use to recommend patches for the tests.
.
rq2 characteristics of patches table shows the characteristics of the patches that ifixflakies recommends with one patch per helper we do not show rows for modules with no helpers namely m5 and m10.
for each module we show the average number of patches per order dependent test.
we also show the average number of unique patches based on statements for each order dependent test per module.
for example m7 apache struts has .
patches per order dependent test but 551esec fse august tallinn estonia august shi wing lam reed oei tao xie and darko marinov table characteristics of patches proposed by ifixflakies for each module averages per order dependent test are shown.
first patch all patches unique unique avg.
stmts avg.
stmts id patches patches patch sizes avg.
stmts from original avg.
stmts from original m1 .
.
.
.
.
.
.
m2 .
.
.
.
.
.
.
m3 .
.
.
.
.
.
.
m4 .
.
.
.
.
.
.
m6 .
.
.
.
.
.
.
m7 .
.
.
.
.
.
.
m8 .
.
.
.
.
.
.
m9 .
.
.
.
.
.
.
m11 .
.
.
.
.
.
.
m12 .
.
.
.
.
.
.
m13 .
.
.
.
.
.
.
average .
.
.
.
.
.
.
only .
unique patches per order dependent test.
overall while ifixflakies recommends on average .
patches for each orderdependent test across all modules only .
are actually unique.
the overall average in the final row is the average per test across all modules not the unweighted average of averages per module.
table also shows the average number of unique patch sizes among all patches for each order dependent test per module several patches with different statements can have the same number of statements.
if the patch size is the most important for a good patch then it suffices to find just one patch of a certain size instead of finding all the different patches of that size.
with only .
unique patch sizes per order dependent test on average many patches actually have the same size.
table also shows some statistics about the sizes of patches for only the first patch from ifixflakies trying the first cleaner of the first polluter or the first state setter and across all patches.
the table shows the average number of statements and the average percentage of the number of statements w.r.t.
the number of statements in the original helper section .
.
across all patches ifixflakies recommends a patch with only .
statements on average and these statements comprise only .
of the statements in the original patch method.
in fact of the total patches .
contain just one statement!
when we look into the spread of the patch sizes per order dependent test we find that on average each order dependent test has around of their patches with the same size most often being the smallest size.
for example the average number of statements in the first patch .
is almost equal to the average number of statements across all patches .
.
overall the results suggest that ifixflakies should search for a few helpers but not all of them because the majority of the helpers lead to the same size of patches.
.
.
submitted patches.
we submitted pull requests for of the order dependent tests with helpers of the had already been fixed before we submitted pull requests.
table shows the breakdown of the tests corresponding to our pull requests.
developers already accepted pull requests for tests.
while allour pull requests are based on the patches generated by ifixflakies we sent patches for half of the tests exactly as ifixflakies recommended and the remaining half required small table number of tests addressed by pull requests prs based on ifixflakies patches.
of test fixed by id pending prs accepted prs patcher m1 m2 m3 m4 m6 m7 m8 m9 m11 m12 m13 total manual changes.
when we had to make changes to the patch for the pull requests the effort was roughly minutes per patch mostly refactorings or simple changes to match the style of the existing code.
existing techniques and tools could help with such manual effort.
we believe that developers using ifixflakies could use such tools for more automation but still examine the patches and manually apply small changes if necessary.
we make available the patches that ifixflakies generates a more detailed breakdown describing the changes that we made to the patches and links to the corresponding pull requests on our website .
because ifixflakies fixes an order dependent test using statements from a helper the recommended patches may reduce the order dependent test s fault detection capability i.e.
make the test miss a fault.
however if a patch does reduce an order dependent test s fault detection capability then the passing test order in which ifixflakies may have found the helper could likely miss the fault as well.
ifixflakies assumes that each passing test order is correct and the failing test order indicates a fault in the test code not a fault in the code under test.
we do not believe that the scenario where the failing test order indicates a fault in the code under test actually occurred in our evaluation particularly because developers did not reject our pull requests to fix the order dependent tests.
552ifixflakies a framework for automatically fixing order dependent flaky tests esec fse august tallinn estonia table average time in seconds that ifixflakies takes denotes that the time includes finding some test s with no cleaner.
test suite avg.
time to find first avg.
time to find all id time polluter cleaner state setter patch polluters cleaners state setters patches m1 m2 n a n a m3 m4 n a n a m5 n a n a n a n a m6 m7 n a n a m8 n a n a m9 n a n a m10 n a n a n a n a m11 n a n a m12 n a n a m13 average it should be noted that for m13 wildfly wildfly ifixflakies actually helps fix victims without cleaners as well!
none of the victims had a cleaner.
however they all share the same polluter and that polluter is itself the single brittle found.
when we apply a recommended patch for the brittle not only is the brittle fixed but all of the victims are also fixed.
this example showcases one of the complexities of order dependent tests and how ifixflakies can even help fix order dependent tests that do not have helpers themselves.
we do notcount these tests as fixed in our evaluation because ifixflakies fixes these tests indirectly.
.
rq3 performance table shows the time that it takes for ifixflakies to find polluters cleaners and state setters along with the time to create patches.
the table shows for each module the average time across all orderdependent tests in the module that ifixflakies takes to find create the first polluter cleaner state setter and patch and all polluters cleaners state setters and patches.
the time to create patches assumes that a helper has been found and does notinclude the time to find the helper.
as a reference for the time taken by ifixflakies the table shows the time to run each module s test suite.
effective use of ifixflakies would only require finding the first polluter and cleaner for a victim or state setter for a brittle so that ifixflakies can recommend a patch section .
.
if the victim has more than one polluter then the time for the first cleaner is for the first cleaner of the first polluter.
similarly the time to the first patch for such a victim is then the patch created from the first cleaner for the first polluter.
if the victim has no cleaners the table reports the time taken by ifixflakies to search for cleaners for that first polluter eventually not finding any we mark such time with a in the table.
the overall average time to find the first polluter cleaner state setter and patch is and seconds respectively.
once again the overall averages are over all order dependent tests not over modules.
likewise the overall average for running all tests in a module is weighted by the number of tests as well so modules with more than one order dependent test have their test suite time counted multiple times once per each order dependent test.
compared to this weighted average time to run all the tests the time to find the first polluter cleaner state setter and patch is about .8x .0x .0x and .3x the time to run all tests respectively.
on average ifixflakies takes and seconds to find create all polluters cleaners state setters and patches respectively once again denotes time that includes searching for cleaners where there are none.
compared to the time to find create just the first corresponding test patch the time is .3x .4x .2x and .3x larger.
the average time for finding all state setters is particularly larger than the time for finding the first state setter due to the large number of state setters in m1 alibaba fastjson .
the average time for creating all patches is also particularly larger due to the large number of helpers one per patch .
note that ifixflakies performance can be improved e.g.
patcher could modify the bytecode of the patch code in memory to avoid compilation during delta debugging or could instrument the code to allow turning statements on or off during delta debugging similar to metamutants .
in general considering the large amount of time to create all patches and there being fewer unique patches than all patches we do notrecommend developers to use ifixflakies to create all patches using all helpers for each orderdependent test obtaining just a few appears to suffice.
overall the average end to end time for ifixflakies to try to create a patch for an order dependent test is seconds the endto end includes the time to find the first helper including the time to find the first polluter for victims and then to create the corresponding patch.
this end to end time also includes the cases where an order dependent test has no cleaner and ifixflakies spends time looking for it.
if we split the order dependent tests between those with and without helpers the time to create a patch for an orderdependent test with a helper is seconds while the time to fail to create a patch for one without a helper is seconds.
threats to validity the results of our study concerning the frequency of victims brittles polluters cleaners and state setters may not generalize to other projects.
we attempt to mitigate this threat by using a dataset of popular and diverse projects from our prior work .
we generated this dataset of order dependent tests using projects from 553esec fse august tallinn estonia august shi wing lam reed oei tao xie and darko marinov earlier work on flaky tests and java projects deemed the most popular on github based on the number of stars that the projects have.
furthermore ifixflakies itself or tools that it uses e.g.
javaparser may have faults that could have affected our results.
we used extensive logging in ifixflakies and at least two authors reviewed ifixflakies s code and logs.
the metrics that we use to evaluate the patches that ifixflakies creates e.g.
patch size and uniqueness may not be the most important metrics for determining the quality of patches.
other important metrics include the time taken to run the patched in code.
the patches that ifixflakies recommends may also not lead the order dependent test to pass for test orders other than the failing test orders that ifixflakies checks.
to mitigate these two threats we submitted pull requests for the patches that ifixflakies recommends.
so far developers have already accepted pull requests for order dependent tests and the rest are pending with none rejected.
related work luo et al.
reported the first extensive academic study of flaky tests they categorized flaky tests by studying historical commits of fixes for flaky tests and found order dependent tests to be among the top three most common categories.
palomba and zaidman also studied flaky tests and categorized the ones that they found with order dependent tests claimed to similarly be in the top three categories.
gao et al.
studied flaky gui tests and they found tests that change the configurations for later run tests resulting in gui order dependent tests.
we recently released a dataset of flaky tests that we found by rerunning test suites while randomizing their test orders almost half of the flaky tests found are orderdependent tests and we evaluate ifixflakies using these tests.
zhang et al.
proposed discovering order dependent tests through randomizing the test orders.
huo and clause studied tests whose assertions depend on input data not controlled by the tests themselves.
they called these assertions brittle inspiring our naming of brittles as tests with similar kinds of assertions4.
the difference is that their brittle assertions may fail due to the tests using wrong input data that they do not control while our brittles are tests that always fail when run in isolation without a state setter running before them .
gyori et al.
proposed a technique poldet for detecting tests that change shared state so the state at the end of their run differs from the state at the start of their run.
they call these tests polluters and our polluters are similar in nature.
the difference is that their polluters may pollute the state so other tests potentially future ones fail while our polluters always pollute the state for some existing victims.
bell et al.
proposed a technique electrictest to detect data dependencies between existing tests in a test suite and gambi et al.
followed up on electrictest with pradet which detects when dependencies between tests can actually lead to tests failing in different orders.
in this paper instead of detecting order dependent tests our goal is to automatically fixorder dependent tests.
bell and kaiser proposed vmvm a technique to tolerate order dependent tests by restoring the state of the heap between test runs.
vmvm adds instrumentation that re initializes static 4the term brittle or fragile test was also used to describe gui tests that fail due to changes in the interface .fields shared between tests to isolate tests from one another with regards to their heap state when run in the same jvm.
mu lu et al.
proposed an even more extreme technique for isolation in that each test should not only run in a separate jvm but also in a fresh environment e.g.
a fresh file system.
bell et al.
also evaluated how various forms of isolation can help in test reruns to detect which test failures are due to flaky tests.
however all forms of isolation add extra overhead on top of executing tests.
in this paper we use code from helpers that are already in the test suite to re set the state for order dependent tests to pass even when not run in isolation but together with the other tests.
automatic patch generation is a well studied topic .
the goal is to automatically patch faults in the code exposed by failing tests.
these techniques generate patches using a variety of mechanisms such as systematically mutating code learning from example patches and symbolic execution.
to validate the success of the patches most of the techniques rely on the outcomes of tests.
in this paper we aim to patch tests as opposed to the code under test.
we create these patches by searching for helpers among the existing tests which have code that can be used to make order dependent tests pass in their respective failing test orders.
daniel et al.
mirzaaghaei et al.
and yang et al.
also fixed test code while gao et al.
and stocco et al.
fixed test scripts for gui.
however they all fixed tests that become broken due to code evolution not flaky tests.
conclusion flaky tests provide misleading signals to developers during regression testing.
prior work has found order dependent tests to be among the top three common kinds of flaky tests.
we present ifixflakies a framework for automated fixing of order dependent tests.
our main insight for ifixflakies is that test suites already have helper tests whose code can help fix order dependent tests.
ifixflakies searches for helpers and uses their code to propose relatively small patches for order dependent tests.
our evaluation on order dependent tests from a public dataset shows that ifixflakies can automatically recommend patches for of tests.
the recommended patches are effective with .
of them having just one statement.
also ifixflakies is efficient requiring only seconds on average to produce the first patch for an orderdependent test with a helper.
the effectiveness and efficiency of ifixflakies show promise that it may be integrated into a practical software development process.
we used patches recommended by ifixflakies to open pull requests for order dependent tests of the had already been fixed developers have already accepted pull requests for tests and the remaining ones are pending.