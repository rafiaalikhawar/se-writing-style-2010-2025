dsibin identifying dynamic data structures in c c binaries thomas rupprecht university of bamberg germany trupprecht swt bamberg.de jan h. boockmann university of bamberg germany jboockmann swt bamberg.dexi chen microsoft canada xcihen microsoft.com gerald l uttgen university of bamberg germany gluettgen swt bamberg.dedavid h. white university of bamberg germany dwhite swt bamberg.de herbert bos vrije universiteit amsterdam the netherlands herbertb cs.vu.nl abstract reverse engineering binary code is notoriously difficult and especially understanding a binary s dynamic data structures.
existing data structure analyzers are limited wrt.
program comprehension they do not detect complex structures such as skip lists or lists running through nodes of different types such as in the linux kernel s cyclic doubly linked list.
they also do not reveal complex parent child relationships between structures.
the tool dsi remedies these shortcomings but requires source code where type information on heap nodes is available.
we present dsibin a combination of dsi and the type excavator howard for the inspection of c c binaries.
while a naive combination already improves upon related work its precision is limited because howard s inferred types are often too coarse.
to address this we auto generate candidates of refined types based on speculative nested struct detection and type merging the plausibility of these hypotheses is then validated by dsi.
we demonstrate via benchmarking that dsibin detects data structures with high precision.
index terms data structure identification reverse engineering dynamic data structures pointer programs type recovery.
i. i ntroduction understanding the internals of software binaries is an important challenge especially for tackling challenges in comprehending legacy code and security threats posed by malware .
a particular challenge in reverse engineering is the identification of dynamic data structures ds in pointer programs and in this context also of nested structs that occur frequently in c c code e.g.
the linux kernel s cyclic doubly linked list cdll .
the demand for automated analysis of pointer programs can e.g.
be seen by the recent acquisition of infer by facebook .
while there is a wealth of related work on type recovery with divine and howard being examples of such static and respectively dynamic analysis tools ds identification tools are scarce .
mempick ddt and artiste are examples of state of the art tools for dynamic ds identification.
they are based on a dynamic analysis but have limitations sec.
ii .
firstly some make strong assumptions on the binary underanalysis for example ddt requires that interface functions can be revealed easily which is e.g.
the case when the c standard template library stl has been used.
however this assumption is not necessarily true for low level inlined or optimized code.
secondly tools such as artiste are not robust against ds operations that temporarily break the structure s shape invariant.
thirdly the mentioned tools cannot identify lists if these run through differently typed nodes for which the linux cdll is an example.
they do also not recognize complex relationships between structures such as arbitrary parent child nesting.
the program comprehension tool dsi implements a dynamic analysis that overcomes these limitations but works on c sources only.
its heap abstraction breaks with the common assumption that each node of a dynamic structure resides in a memory chunk of its own instead it employs a notion of cell that can e.g.
be either a struct or a nested struct.
moreover dsi does not analyze at the node level but uses strands which can be thought of singly linked lists as the building blocks of a ds.
strands can be interconnected loosely i.e.
via pointer based nesting or tightly i.e.
via overlay.
for example dsi represents a doubly linked list dll as a strand graph that consists of two strands that run in opposite directions and are connected by nodewise overlay.
its subgraphs are then annotated by dsi with quantitative evidence for a structure having a certain interpretation.
this evidence is accumulated by structural and temporal repetition not unlike as in artiste sec.
ii which typically leads to overwhelming evidence for a ds s true shape.
this paper develops the novel tool chain dsibin that enables dsi s core algorithm to work on binaries.
our first naive approach simply replaces the source code instrumentation framework cil that is employed by dsi with intel s pin binary instrumentation framework and utilizes howard for extracting type information that is then used by dsi sec.
iii .
we evaluate this naive tool chain on an benchmark comprising of real world examples standard textbook examples examples taken from .
c ieeease urbana champaign il usa technical research331 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
parent fwd parent rev child fwd child revdll no nonono dllmemory vertex type void void howard dsiref untyped void struct untyped void void address 19c5040 19c5048 19c5050 19c5058 19c5060 memory vertex type howard dsiref untyped void struct untyped void void address 19c5078 19c5080 19c5088 void fig.
.
dsi s aggregate strand graph left and a snippet of the points to graph right for example syn parent dll with nested child dlls .
the shape analysis literature and handwritten examples that challenge our tool chain in various aspects.
our results demonstrate that the naive tool combination leads to the correct identification of of the benchmark s examples which already improves upon the capabilities of related tools especially regarding the recognition of skip lists and various forms of nesting.
a detailed analysis of the negative examples reveals that recognition fails due to insufficient and imprecise type information excavated by howard particularly regarding nested structs and type mergings.
therefore we propose a new approach for refining the lowlevel type information excavated by howard which utilizes dsi s core algorithm sec.
iv b .
we infer some of the missing type information by propagating existing information within a type graph .
this leads to speculative type mergings and struct nestings which we term type hypotheses.
their plausibility is then quantitatively evaluated via dsi s core algorithm which identifies the most probable correct typing on the basis of the complexity of the ds that is implied by a typing hypothesis.
we complete dsibin by adding this refinement component dsiref to our naive tool chain and can now correctly identify the dss in of the benchmark examples.
we briefly illustrate our improvement in the state of theart of dynamic ds identification and related type recovery mechanisms.
consider example syn of our benchmark which contains a parent dll with nested dll children and is not recognized by other tools.
dsibin reports the ds in an aggregated form of a strand graph figure s left hand side .
it reveals the strand aggregates parent fwd parent rev child fwd child rev the first and second pair of which each forms a dll dll label between the fwd and rev strands .
it also highlights the nesting on overlay no between the parent and child dlls where the head node of the child dll is embedded inside the parent node.
this correct interpretation is only possible due to dsiref s type refinement.
to see this consider the snippet of a points to graph thatdsibin constructs when analyzing syn figure s righthand side where a parent vertex is displayed at the top and a child vertex at the bottom.
we have annotated the type information extracted by howard and dsiref resp.
which shows how much more information dsiref reveals.
firstly it reveals a nested struct encompassing addresses 19c5050 to 19c5060 the nested head of the child dll .
secondly this enables dsiref to identify the equality between the type of vertex and the type of the nested struct of vertex and thus to detect the child dll.
ii.
b ackground r elated work several dynamic analyses of binary programs have been introduced for identifying contained dynamic dss in particular mempick ddt and artiste .
we first discuss their underlying analysis approaches and point out their limitations then introduce the dsi approach that overcomes these limitations but requires source code and some type information included therein.
this leads us to surveying tools such as howard that excavate type information from binaries and that will ultimately enable our desired application of dsi to binaries.
mempick artiste ddt.
mempick aims at determining the periods in the program trace under consideration when pointer operations are absent.
for these quiescent periods it considers the heap s structure as points to graphs tries to type the graphs nodes on the basis of information revealed by cpu instructions and clusters the nodes according to types.
each cluster is then processed via a set of rules to identify the corresponding ds.
for example if an analyzed cluster contains only nodes with two outgoing arcs and one incoming arc plus one node with two outgoing arcs but no incoming arc then mempick reports the cluster as a binary tree.
however mempick does not analyze the relationships between dss such as parent child nesting and thus cannot identify more complex dss such as the linux kernel cdll that involves nodes of different types.
artiste samples every nthstep of the executed trace which does away with quiescence analysis but may result in considering execution points at which the dynamic dss are in some degenerate shape i.e.
a shape that arises in the middle of a ds manipulation and temporally breaks the ds s invariant.
the points to graphs at the sampled execution points are checked for structural repetition within a graph and temporal repetitions across graphs where subgraphs of the same structure are folded.
the naming of the overall dss is then left to a rule based selection algorithm.
while this approach can discover even complex structures involving some nesting artiste looses precision if sample points containing degenerate shapes are picked.
ddt aims at finding interface functions to dss i.e.
functions that e.g.
insert and remove nodes from a dynamic data structure.
as a prerequisite the types of the nodes in the points to graphs of a trace are inferred by tracking allocation sites during program execution and merging types from different allocation sites e.g.
if nodes are accessed authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
headstrand1 strand2fig.
.
dsi s view of the linux kernel cdll.
through a common interface function.
thereby ddt can build up signatures of interface functions which are then matched against a library of known dss for identification.
this works well if interface functions are easily revealed e.g.
if programs use well structured libraries such as the c stl.
however the approach is hampered in the presence of obfuscation inlining or optimization which are often employed in legacy and kernel space software.
dsi data structure investigator.
dsi aims at overcoming the abovementioned limitations of ds identification but operates on c code rather than binary code.
the workings of dsi are not unsimilar to artiste but the detection of structural and temporal repetition is not directly conducted on points to graphs but instead on strands.
strands are an abstraction from the core ingredient of dynamic dss singlylinked lists.
during program execution dsi tracks strands and their interconnections such as overlay or nesting in a strand graph.
it is then the evolving sequence of strand graphs on which repetition detection is performed and on which folding takes place.
on the one hand the difference of dsi to competing tools lies in the finer more expressive concept of strands.
a strand links cells rather than nodes which can be thought of as memory subregions while a node is normally a struct a cell could be e.g.
the whole struct or just a nested struct within the whole struct.
thus strands can traverse through nodes of different types while the traversed cells themselves are obviously required to be of the same type.
fig.
shows dsi s view of the recognized linux kernel cdll where strands are drawn using wide colored arrows and involve linkages between nodes of different types head node vs. tail nodes .
on the other hand dsi does not rely on quiescent periods but instead employs an evidence based approach that considers all points of an execution trace.
at each point a subgraph of the strand graph is given a count on the basis of its strands sizes and their kinds of interconnections which reflects the likelihood of the subgraph representing a certain ds for example the count for the subgraph capturing a dll might be higher than the count for two singly linked lists slls intersecting.
these counts or evidences are accumulated when folding strand graphs structurally within a strand graph and temporally across all strand graphs of the considered execution trace.
this typically leads to overwhelming evidence for the true ds shape and makes dsi s approach robustagainst degenerate ds shapes.
these degenerate shapes are just injecting interpretation noise that is becoming irrelevant when accumulating evidence.
in summary dsi overcomes the limitations of related work in that it i does not make strong assumptions on the program under analysis ii is not mislead by temporarily degenerate shapes and iii is more general as it supports the identification of lists through different node types and arbitrarily nested combinations of lists.
because of this dsi can reliably handle custom implementations including those involving cyclic singly doubly linked lists various skip lists and binary trees and interconnections between those including indirect and overlay parent child nesting.
consequently dsi can deal with real world software e.g.
the linux kernel cdll the region clipping library of vnc hvnc2 libs libvncsrv rfbregion.c found in carberp and libusb .
dsi would be a useful tool for understanding complex code such as malware but currently and in contrast to the related work discussed above it cannot handle binary code.
while its instrumentation that captures pointer based events such as memory de allocations and pointer writes can be switched from the c intermediate language cil to e.g.
intel s pin framework the core dsi algorithm requires type information on cells which is accessible in source code but not in stripped binaries.
thus the essential step for our desired opening of dsi to binaries is the type recovery for structs and nested structs.
type recovery tools.
a multitude of tools exist for recovering type information from binaries .
they differ in i whether a static a dynamic or a combined analysis is performed ii whether they operate on a binary file or a memory snapshot and iii the spectrum of discovered type information ranging from simply identifying pointers and sizing memory chunks to detecting structs and their primitive types.
a closer investigation reveals that especially the tools divine and howard can deal with nested structs.
divine conducts a static analysis of windows binaries and discovers types of memory regions including regions on the heap which may be primitive data types or complex types e.g.
consisting of arbitrarily nested structs.
its machinery combines a classic value set analysis with an algorithm for aggregate structure identification in an iterative manner.
memory access patterns in a binary are exploited for making educated guesses as to how data is laid out in memory.
for example if a code instruction accesses a sequence of eight bytes at a particular offset this corresponds to a variable or field of this size at that location within the region.
however memory access patterns can be blurred by memcpy like functions which restricts divine s utility .
in contrast howard conducts a dynamic analysis but handlesmemcpy and similar functions in c c binaries in accordance with its practical aims of supporting forensics reverse engineering and protecting existing binaries against memory corruption attacks.
howard also tracks memory ac333 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dsi binary frontendoffline analysisdynamic analysis dsi core algorithmdsi source frontendsource file binary file howard dsiref sec.
iv identified data structureoriginal dsi dsibinfig.
.
overview of our tool chain.
cess patterns and additionally monitors mallocs for heap memory stack frames for local variables and pointers to reveal primitive types and nested structs.
for typing heap memory howard identifies allocation sites by their call stack and stack frames by their associated function address.
howard reports the typed memory for each allocation site and stack frame.
howard is arguably the best candidate for extracting type information for use by dsi it i supports nested structs ii deals with c c binaries that include memcpy like functions and iii operates under linux as does dsi.
below we see that howard still has some limitations and show that dsi s core algorithm can be employed to improve the type information reported by howard.
iii.
n aive approach howard dsibin this section describes a naive approach for combining dsi and howard evaluates it on an benchmark and discusses the results.
our observations pave the way for a much improved approach secs.
iv v .
a. howard dsibin tool chain the naive tool chain is depicted in fig.
when ignoring component dsiref and consists of three components the core dsi algorithm that was already used in the source code dsi version a newly created dsi binary frontend and howard.
we refer to the core dsi algorithm simply as dsi and to the binary frontend as well as the overall tool chain as dsibin.
recall that dsi performs an offline analysis for detecting dynamic data structures.
for this purpose the original sourcecode version of dsi is provided with an execution trace captured by executing instrumented c source code where the instrumentation of memory de allocation and memory write events is done via the cil framework .
we treat dsi as a black box and replace the instrumentation part with dsibin which utilizes intel s pin framework .
because dsi relies on primitive data type information including structs and nested structs on the heap and stack dsibin needs to provide thisinformation as well.
therefore dsibin not only instruments the binary under investigation but also incorporates type information excavated by howard.
technically dsibin models heap and stack separately to keep track of memory de allocations and stack status.
all live heap objects are recorded allowing for sanity checks such as checking for dangling