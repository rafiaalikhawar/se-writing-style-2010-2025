discovering bug patterns in javascript quinn hanam university of british columbia vancouver bc canada qhanam ece.ubc.cafernando s. de m. brito univ.
federal da para ba jo o pessoa pb brazil fernando lavid.ufpb.brali mesbah university of british columbia vancouver bc canada amesbah ece.ubc.ca abstract javascript has become the most popular language used by developers for client and server side programming.
the language however still lacks proper support in the form of warnings about potential bugs in the code.
most bug nding tools in use today cover bug patterns that are discovered by reading best practices or through developer intuition and anecdotal observation.
as such it is still unclear which bugs happen frequently in practice and which are important for developers to be xed.
we propose a novel semi automatic technique called bugaid for discovering the most prevalent and detectable bug patterns.
bugaid is based on unsupervised machine learning using languageconstruct based changes distilled from ast di erencing of bug xes in the code.
we present a large scale study of common bug patterns by mining 105k commits from server side javascript projects.
we discover bug xing change types and discuss pervasive bug patterns that occur across multiple projects and can likely be prevented with better tool support.
our ndings are useful for improving tools and techniques to prevent common bugs in javascript guiding tool integration for ides and making developers aware of common mistakes involved with programming in javascript.
ccs concepts software and its engineering !software testing and debugging empirical software validation keywords bug patterns javascript node.js data mining static analysis this author was a visiting student at the university of british columbia when this work was done.
.
introduction a recent survey of more than 26k developers conducted by stack over ow found that javascript is the most used programming language .
javascript is the language used inside the browser but it is also becoming popular as a desktop and server side language thanks to the node.js1platform.
despite this javascript currently lacks ide support in the form of analysis alerts that warn the developer about potential bugs in their code.
such alerts are common to compiled strongly typed languages such as java in the form of compilers and bug nding tools like findbugs .
the lack of tool support for javascript is in part due to several challenges that are unique to javascript including but not limited to weak typing dynamic eld access and creation higher order functions dynamic code evaluation and execution and event driven and asynchronous ow of control .
recent research advances have made the use of static analysis on javascript more practical while other techniques mitigate the analysis challenges by using a dynamic or hybrid approach .
as toolsmiths begin to develop the rst bug nding tools for javascript it is unclear which bugs require the most attention.
unlike the most popular statically typed languages e.g.
there is little research studying bugs in javascript.
while dom api interactions have been shown to dominate bugs in client side javascript to the best of our knowledge there is no work studying common bug patterns in javascript in general.
the goals of this paper are twofold namely developing a systematic semiautomated approach for discovering pervasive bug patterns discovering bug patterns in server side javascript that occur frequently across projects.
we accomplish these goals in two parts.
first we propose a novel semi automatic approach to discover common bug patterns.
our approach called bugaid mines version control repositories and discovers bugs that are frequently repaired by developers.
our insight that makes this approach e ective is that instances of bug patterns cau sed by language misuse can be grouped together by changes to language constructs in the bug xing commit.
using this intuition bugaid creates feature vectors of language construct changes and uses unsupervised machine learning to group them into ranked clusters of bug patterns.
by inspecting these clusters we create natural language descriptions of pervasive bug patterns.
second we produce the rst ranked list of frequently oc1 bugs for a programming language by performing a large scale study of common bug patterns in server side javascript applications.
using bugaid we analyze commits from javascript projects mostly server side node.js applications and packages and discover common bug xing change types.
we inspect the commits in each change type and discuss the bug patterns that we believe have the highest maintenance costs and are good candidates for automated tool support.
this paper makes the following main contributions a novel technique for automatically learning bug xing change types based on language construct changes.
the rst comprehensive study of pervasive bug patterns in server side javascript code.
our toolset bugaid and empirical dataset which are publicly available .
.
cross project bug patterns software bugs can be grouped by their fault the root cause of the bug their failure how they manifest in output or their x. a group of defects along one of these dimensions is referred to as a defect class .
defect classes are important because they allow us to group defects while designing techniques that mitigate them.
for example static bug nding tools tend to look for defect classes grouped by fault dynamic bug nding tools target defect classes grouped by failure symptom and automated repair tools x defect classes grouped by repair.
our interest in this work lies in defect classes that are detectable across multiple projects.
we call these defect classes cross project bug patterns .
de nition cross project bug pattern a pattern in source code that produces incorrect behaviour has a consistent fault and repair and occurs across multiple projects.
we include the fault in our defect classes because crossproject tools typically discover defect instances based on their fault.
we also include the repair in our defect classes because in order to be e ective cross project bug nding tools should also produce alerts that are actionable .
function obj iterator callback callback callback noop obj obj var nextkey keyiterator obj if limit return callback null figure a potential typeerror in keyiterator at line is repaired by initializing objif it is falsey at line .
consider the bug x in fig.
from the async node.js project.
prior to the repair the parameter objcould have the value undefined at line .
when elds or methods are accessed on undefined objects in javascript a typeerror is thrown.
if objis unde ned such an error is thrown inside the method keyiterator .
at line the developer repairs the bug by checking if objcould be undefined and if it is initializing it to an empty array.
we consider thisan example of a cross project bug pattern because it has a speci c fault dereferencing a non value a consistent repair checking if the value of objisundefined and can be seen in many javascript projects.
.
approach the seminal static analysis papers by engler and hovermeyer do not provide a systematic approach to discovering and selecting pervasive bug patterns to detect.
more than a decade after their publication many of the popular cross project bug nding tools in use choose a set of defect classes to detect based on best practices or through developer intuition and observation this is the case with findbugs and dlint .
because the goal of software companies is to maximize pro tability they should deploy tools that discover defect classes with the highest costs.
monperrus describes the two metrics of defect classes that contribute to costs as the frequency with which a defect class appears and the severity of a defect class.
frequent defect classes result in high maintenance costs while severe defect classes result in high production loss .
the question we are interested in is how do we systematically discover frequently occurring bug patterns?
.
reducing the search space one way is to search for bug patterns that are frequently repaired by developers.
this can be done by inspecting source code changes in project histories.
there is however a problem with this method.
an inspection of all the bug repairs in one project s history by a human might take several days for a project with a few thousand commits.
this means a manual inspection of a su cient set of projects representative for a language is not feasible.
we must therefore reduce the search space in which we look for frequently occurring bug patterns.
because bug patterns have consistent repairs we can reduce the search space by grouping bug patterns based on their repairs.
repairs can be observed automatically by extracting the source code changes of a bug xing commit .
we focus on commits rather than bug reports because developers often omit links from commits to bug reports or do not create bug reports in the rst place .
first we reduce the search space by only considering commits where between one and six statements are modi ed i.e.
inserted removed or updated .
if zero statements are modi ed the commit has not modi ed any code while repetitive cross project repairs have been shown to contain six or fewer modi ed fragments .
the search space should now exclude many repairs that are not repetitive across projects.
however there may still be many bug patterns that do not occur frequently or related bug patterns that are fragmented throughout the search space making manual inspection challenging.
next we consider automatically grouping related bug patterns.
.
grouping cross project bug patterns given a large number of commits with modi ed statements our goal is to group bug xing commits with the same bug pattern.
because we do not have a priori knowledge about what bug patterns exist to achieve this goal we perform cluster analysis using machine learning.
the challenge we face is selecting the best feature vector and clustering algorithm such that the number of commits a human must inspect is minimized and the number ofbug patterns recalled by an inspection of the clusters is maximized.
ideally each cluster would contain all instances of one bug pattern perfect recall and only instances of one bug pattern perfect precision .
so what should our feature vector look like?
our feature vector must capture unknown semantic changes while ignoring noise such as variable names and minor di erences in control ow.
a naive approach is to use a source code di erencing approach such as line level di erencing or ast di erencing.
as we discovered early in our work such an approach does not consider the semantics of the changes and is therefore highly susceptible to noise.
a better approach ischange classi cation where semantics are added to the source code changes identi ed by source code di erencing.
change classi cation approaches already exist for java.
fluri and gall identify basic change types that can be performed on various java entities and use those basic changes to discover more complex changes .
kim et.
al.
enhance this approach by creating a database of basic change facts and using datalog to specify more complex change types.
however we wish to detect unknown change types.
from this context both these approaches su er because the lowest level change types which they use which we callbasic change types bcts must be manually speci ed imperatively or declaratively .
such an approach is limited by these pre de ned bcts and does not scale to capture new patterns with the addition of data.
.
learning change types our intuition is that we can automatically learn bcts by combining information from a model of the language with information from source code di erencing.
we introduce the following abstraction for capturing bcts.
in our abstraction all bcts are made up of the following components language construct type the type of language artifact or concept being modi ed.
for javascript a model of the language may include reserved words api artifacts e.g.
method and eld names statement types operators behaviour e.g.
auto casting behaviour and even code conventions e.g.
error rst protocol .
language construct context the context in which the language construct appears.
for example the reserved word this could be used in many di erent contexts such as inside a branch condition or as an argument.
modi cation type how the language construct was modi ed by the commit.
this information is computed by the source code di erencing tool.
name the name we assign to the language construct.
assuming the order in which classi ed changes occur in a commit does not matter much we can represent more complex change types i.e.
change types made up of one or more bcts as a bag of words where each bct discovered is a feature and the number of times a bct appears in a commit is the value of that feature.
for the rest of the paper when we refer to a change type we mean a set of one or more bcts.
.
language construct selection we must decide which aspects of the programming language we wish to model.
to do this we distinguish between three types of bug patterns patterns that are inherent to the programming language patterns that are inherent totable feature properties identi er short forms type behaviour b class cl constant co convention cv error ex event ev field f method m parameter p reserved re variable v context argument a assignment lhs al assignment rhs ar class declaration cd condition c expression exp error catch ec event register erg event remove erm method call mc method declaration md parameter declaration pd statement s variable declaration vd change type inserted i removed r updated u name undefined equal return callback error ... external libraries and patterns that are inherent to a particular project e.g.
.
our goal in this paper is to discover bug patterns that are inherent to javascript.
we therefore use javascript reserved words operators and standard methods elds events from the ecmascript5 api .
in addition we include the following javascript interpreter behaviours and coding conventions falsey all variables in javascript can be cast as booleans in a branch condition.
types undefined null and nan and values 0and evaluate to false while everything else evaluates to true.
typeof we consider the boolean operators and!
with the form undefined null nan equivalent to inserting a typeof keyword.
callback callback functions are commonly given similar names i.e.
cb callb or callback which we capture in our analysis.
error we capture errors that are caught or used in the error rst callback idiom.
table shows the concrete values we use for modelling changes in javascript and their respective abbreviations used throughout the paper.
.
extracting basic change types algorithm shows a summary of our method for extracting bcts from a list of subject programs p into a relational database d offcommit bctgpairs.
for each commit c in a project s history c we obtain the set of all modied source code les in the commit.
this gives us a set f ffb1 fr1g ffbn frngofnfbuggy le repaired le g pairs.
for each pair in f we compute the bcts that were made to the source code using abstract syntax tree ast di erencing .
because it considers the program structure when computing the changes between fbandfr ast di erencing is more accurate than line level di erencing.
it also computes ne grained changes by labelling each node in the ast this ne granularity is useful for learning bcts.
the product of ast di erencing is an ast for fb ast b and an ast for fr ast r .
for eachfast b ast rgpair we extract the set of functions that occur in both ast b and ast r. we omit functions that were inserted or removed because we nd these represent refactorings not bug xes.
this gives us a set m fmb1 mr1g fmbk mrkgof kfbuggy function repaired function gpairs.
for each pair in m we extract bcts into set tby analysing the asts whose nodes are annotated by the di erencingalgorithm basic change type extraction input p subject programs output d database of commits and change types d foreach p2pdo c commits p foreach c2cdo t f modi edfiles c foreachffb frg2fdo fast b ast rg astdi fb fr m modi edfunctions ast b ast r foreachfmb mrg2mdo t t extractbasicchangetypes mb mr end end d d hc ti end end tool with the modi cation performed by the commit i.e.
inserted updated or removed .
each chas a one to many relationship between it and the bcts found within it one ccontains zero or more bcts and is stored in a relational database.
each cwill be a feature vector in our dataset eventually but it is convenient to store the dataset in a database which we can query.
once the database is populated we lter out noise by selecting candidate commits that have between one and six modi ed statements do not contain the text merge in the commit message contain at least one bct that does not have language construct context s and has at least one bct that does not have modi cation type u .
we express this query in datalog and build a dataset from the results of this query.
each bct in the query results is converted to a feature while each commit in the query results is converted to an instance of a feature vector in the dataset.
table shows an example of three feature vectors.
the feature vector includes the the number of modi ed statements and a bag of words where the features are the bcts and the values are the number of times the bct occurs in the commit.
the rst commit from the async project shows the feature vector of the change type from fig.
.
it contains one bct that states that one instance of the behaviour b falsey used in a branch condition c was inserted i .
the other two feature vectors pertain to di erent change types.
.
clustering and ranking we can now obtain a list of change types that occur frequently by clustering the dataset obtained in the previous step section .
.
the clustering algorithm we use is dbscan because it is a density based algorithm i.e.
it groups feature vectors that are closely related and unlike other clustering algorithms it does not require the number of clusters to be provided in advance as an input.
we use manhattan distance as our distance function because it computes shorter distances between commits with the same bcts.
change types are ranked by the number of projects that are represented and by the number of commits they contain.
we expect change types with more projects to contain cross project bug patterns and change types with more commits to contain frequently occurring bug patterns.
.
change type inspectiontable an example dataset containing feature vectors for three commits.
there are three change types in this feature vector.
change type headers have the form .
the number beside the change type header is the value for that feature the number of occurrences of the change type in the commit.
see table for short forms.
proj.
commit modi ed statementschange type header async 63b bcifalsey bcrfalsey mmcibind bower 2d1 bcifalsey bcrfalsey mmcibind express 5c4 bcifalsey bcrfalsey mmcibind for our manual inspection of change types we give priority to larger change types and only inspect change types that contain ve or more commits and are represented by more than one project.
we use a systematic inspection process based on grounded theory to infer bug patterns from change types based on their faults and repairs.
this approach is described below.
sampling.
from each change type we randomly select one commit from each project to be part of that change type s sample.
for example if a change type contains commits from projects the sample size of that change type will be .
we choose this sampling method because our goal is to nd cross project bug patterns.
selecting multiple items from the same project may bias our results towards projects with more bugs.
summarizing.
in order to help the inspectors understand the change we open the summary of the commit on github in a web browser.
the summary includes a line level di of the commit the commit message and links to the bug report if any .
using the summary we record a description of the bug pattern i.e.
the fault and repair for the commit .
grouping.
from these descriptions we group bug pattens.
we compare the bug pattern of each commit to existing groups.
if the description of a commit s bug pattern closely matches the descriptions of the bug patterns in an existing group we place the commit in that pattern.
if no bug pattern contains a similar fault and repair description we create a new bug pattern group.
reviewing.
once all commits in the change type sample have been placed into a group we iteratively review patterns merging or splitting them according to their descriptions.
.
implementation we implement our technique in a tool called bugaid which is publicly available .
project histories are explored using jgit a git client for java.
javascript asts are created and explored using a fork of mozilla rhino a javascript parser and runtime environment that we modify to better support ast change classi cation.
ast di erencing is performed using a fork of gumtree a ne grained ast di erencing tool that we modify to better support javascript ast changetable evaluation subject systems.
kloc indicates thousands of javascript lines of code excluding comments and empty lines.
measure mediacenterjs pm2 total size kloc stars on github commits candidate commits classi cation.
clustering is performed using weka .
to assist in the manual inspection of change types we implement a script that randomly selects commits from a change type and displays the github commit summary in a web browser.
.
cluster evaluation and tuning we evaluate our feature vectors and tune the parameters of our clustering algorithm dbscan.
we use two popular node.js projects as evaluation subjects.
mediacenterjs is a home media server that we selected randomly from a web search of popular node.js applications.
pm2 is a process manager and load balancer that we selected randomly from thenpmhomepage.
.
gold standard to assess the accuracy of our clustering approach we create a gold standard of cross project bug patterns by manually inspecting all commits of the two subject systems where statements are modi ed.
we classify the bugs repaired by each bug xing commit into bug pattern categories.
we categorize both the fault and repair of each bug and determine if a bug pattern meets our de nition of a cross project bug pattern see de nition .
our classi cation yields four cross project bug patterns with at least three instances typeerror unde ned a variable can be unde ned but is dereferenced.
it is repaired by adding a branch condition that checks if the variable points to the undefined object.
typeerror falsey a variable can evaluate to falsey but is dereferenced.
it is repaired by adding a branch condition that checks if the variable evaluates to false when used as a boolean.
error handling a method call may throw an error that is uncaught.
it is repaired by surrounding the method call with a try statement.
incorrect comparison a compare by value operator i.e.
or!
is too permissive.
it is repaired by replacing the compare by value operator with a compare bytype and value operator i.e.
or!
.
.
comparison as discussed in section .
change type classi cation tools already exist for java.
while we believe our approach is uniquely suited to identifying unknown bug xing changes and could outperform existing change classi cation approaches for this specialized task existing tools for java cannot easily be converted to javascript.
therefore a direct comparison is not possible.
instead we compare our feature vector of bcts learned with language constructs to two alternative approaches based on creating a feature vector ofmore naive bcts built from ast node types.
this gives us three data sets to evaluate one dataset for each feature vector dataset language constructs bcts are the same as those described in section .
.
dataset statements bcts are statement types e.g.
for loops expression statements function declarations etc.
and how they are modi ed i.e.
inserted removed updated or moved .
dataset nodes bcts are ast node types e.g.
simple names literals expressions etc.
and how they are modi ed i.e.
inserted removed updated or moved .
.
evaluation results we cluster each of our three evaluation datasets into change types using various values of dbscan s density parameter epsilon where the distance between data points in the same cluster must be less than epsilon.
smaller values of epsilon result in denser clusters.
because we assign the modi ed statements feature a weight of .
and bct features a weight of values of epsilon that are less than mean that commits in the same cluster have the same set of bcts but may di er in the number of modi ed statements.
the rst value of epsilon .
means that commits in the same cluster have the same feature vector.
each set of change types for a dataset epsilon pair is evaluated against our gold standard.
we consider a cross project bug pattern captured by a change type if there are two or more instances of the pattern in the change type.
this would allow a human to identify the pattern if they manually inspected the change type.
the results of the evaluation are shown in fig.
.
.
.
.
.
clustered a clustered commits01234 captured b patterns captured .
.
.
.
6f measure c f measure0.
.
.
.
6precision d precision .
.
.
.
epsilon cluster e avg cluster density0.
.
.
.
epsilon class f avg class density dataset language node statement figure evaluation and tuning results.
in each chart the x axis shows the values of epsilon the dbscan density parameter.
a shows the percentage of commits that were clustered relative to the number of commits in the dataset thatmeet the modi ed statement requirements.
lower is better in this case because most commits are unrelated and should not be clustered.
a low value also means fewer commits need to be inspected by a human.
b shows the number of cross project bug patterns in the gold standard that would be captured if a human manually inspected all change types.
a y value of means all patterns would be captured.
c and d show precision and recall.
an instance is recalled if it is found with at least one other instance in a cluster.
in all cases higher is better.
e shows the average percent of cross project bug patterns that make up their respective change type.
a high value means the pattern is more likely to be captured by a random sample of the change type.
f shows the average percent of cross project bug patterns that are included in a change type.
a high value means an estimate of the pattern frequency is more likely to be correct.
when picking a feature vector and epsilon value we are interested in how much we can reduce the number of commits we have to inspect while still capturing all frequently occurring bug patterns.
charts a b and e are most relevant for this purpose.
our dataset of language constructs signi cantly outperforms the other datasets with respect to the number of commits that need to be inspected a while being competitive with the dataset of ast node changes with respect to patterns captured b and cluster density e .
an epsilon value of between .
and .
seems to give us the largest search space reduction while still maintaining good recall.
it is worth mentioning that while precision and recall is signi cantly better for the dataset of language constructs it is low relative to what one might expect from some other clustering task.
precision seems low because there are many bug patterns that were not identi ed in our manual inspection.
because clustering discovers unknown relationships this is not surprising.
these patterns will be discusses in the next section.
a better measure of precision with respect to cross project patterns is the average cluster density in chart e .
recall is also low for small values of epsilon.
this indicates that our approach is susceptible to noise.
for example the incorrect comparison pattern has only three instances.
two of the instances x more than one bug in the same commit which causes the distance between the instances to increase.
we rely on a large dataset to mitigate the e ects of low recall and sensitivity to noise.
overall our proposed approach based on language constructs outperforms the two alternatives.
based on our evaluation results we choose an epsilon value of .
as the basis of our feature vector.
this value of epsilon yields the lowest number of commits to inspect and the highest f measure and cluster density while still capturing patterns.
.
clustering example fig.
shows a breakdown of the commits for our evaluation dataset using the language construct feature vector and epsilon .
.
the treemap on the left represents all commits in pm2 and mediacenterjs.
the box labelled merge represents the commits removed because they merge two branches.
the box labelled outside modi ed statement bounds represents the commits removed figure a treemap of the search space reduction left and the clusters and their patterns right .
patterns from the gold standard are marked with a gold bar.
because they do not meet the modi ed statement requirements of repetitive changes.
the box labelled other noise represents the commits removed because they do not meet other requirements from the query lter.
the box labelled uc unclustered represents the commits removed because they were not present in a change type with size .
the smallest box labelled c clustered represents the commits which were clustered into change types.
the clustered commits are expanded into the treemap on the right which shows a detailed breakdown of the change types.
each colour shows one change type which is broken down into bug patterns discovered within the change type.
in addition to the bug patterns identi ed in our gold standard we inspect all change types and label additional bug patterns which we didn t identify in our manual inspection.
for example the largest change type in red at the bottom left of the treemap shows all instances that contain the feature b cifalsey and or modi ed statements.
an inspection of this change type yields three bug patterns one identi ed in our manual inspection typeerror falsey and two where the fault is that a program state is unchecked or unhandled.
the patterns not identi ed in our manual inspection are arguably less relevant to cross project tools but still interesting.
.
empirical study in this section we present our empirical study in which we address the following research questions rq1 what basic change types exist in javascript?
rq2 what change types exist in javascript?
rq3 what pervasive bug patterns exist in javascript?
recall that bcts are features in our feature vector each cluster represents a change type and bug patterns are inferred from a manual inspection of change types.
.
subject systems our subject set contains projects packages and applications and commits to analyse.
a javascript project is either a package also called a module used in other projects or an application which is normally executed as standalone software.
we use both in our study but search for them in di erent ways.
for packages we use npm 2a popular package manager for node.js.
npmhas become the largest software package repository with over packages now surpassing maven central and rubygems.
the npmwebsite provides lists of of bcts a type b context c mod behaviour class constant convention field method operator reserved of occurrences s argument assign lhs assign rhs condition ex catch expression meth decl method call param decl statement var decl050100150200 inserted removed updatedfigure the distribution of the bcts discovered by our analysis over the feature properties from table .
column a shows the distribution over language construct types.
column b shows the distribution over language construct contexts.
column c shows the distribution over modi cation types.
table subject systems.
kloc indicates thousands of javascript lines of code excluding comments and empty lines.
downloads are over the last month extracted from npm o cial website only available for modules .
measure average median total size kloc stars on github downloads x1031 commits feature vectors analysis time 6m10s 4s 4h32m the most depended upon packages and most starred byusers packages .
from each of the two lists above we take the top packages and merge them into a single list.
we remove duplicates which occur in both lists and three projects which are written in co eescript resulting in a nal set of modules.
all these use git and are hosted on github.
in total these modules have been downloaded more than million times over the last month and have around stargazers number of users that starred the github repository on github.
for nding popular node.js applications we rely on lists curated by users that collect popular node.js applications.
after we remove duplicates and projects where commit messages are not written in english we end up with a list of node.js applications.
these applications have more than stargazers on github.
table summarizes some of the characteristics of the javascript projects we use in our study.
.
feature extraction rq1 we use bugaid to extract bcts from each commit and build the database of fcommit bctgrelations.
bugaid is run on a server with two intel xeon e5 cpus and 64gb of ram.
table shows the time to extract the bcts figure of the original commits ltering and clustering produces clusters containing commits.
from the commits of the subject projects.
four projects did not complete after hours because gumtree ast di erencing did not complete.
these projects are omitted from the analysis time statistics.
the number of feature vectors are less than the total number of commits because the analysis for each project is done in a single thread so the analysis missed some commits from projects where gumtree did not complete.
a few large projects take up most of the analysis time with an average analysis time of 6m10s and a median analysis time of 4s.
the total analysis time is 4h32m.
bugaid discovered bcts in the commits we analyzed.
fig.
shows the distribution of the bcts over the feature properties described in section .
and listed in table .
the rst row shows the distribution over the bcts themselves while the second row shows the distribution over the bct occurrences in the dataset.
we do not show the distribution over each language construct name e.g.
var falsey etc.
because there are too many to t within the paper.
the number and diversity of bcts supports our claim that manually encoding all bcts is impractical and that modelling the language in order to automatically learn bcts is a more scalable approach.
because previous work required bcts be manually de ned the number of change types or the granularity of the results in studies using these tools may be limited.
the full list of bcts is available in our dataset .
.
clustering rq2 we use bugaid to build a dataset of commits based on the query in section .
and cluster the commits in to change types.
fig.
shows a breakdown of the commits.
the tree map on the left shows that after ltering commits with our datalog query we are left with commits to cluster from a total of commits .
clustering removes another commits leaving commits in clusters with size .
the tree map on the right shows the size of each of the clusters.
the smallest clusters contain ve commits.
fig.
shows the change types in more detail.
change types are shown in two facets the number of bcts in the change type and the average number of modi ed statements ms in the change type.
there are change types with one bct with two with three and with four.
commits with fewer modi ed statements are more repetitive so there are more change types with fewer modi ed statements.
table gives descriptive statistics of the change types in fig.
.
for each change type it includes the number of commits the number of projects represented the number of modi ed statements and the number of bcts.
there are three change types with only one project represented whichtable change types descriptive statistics measure min average median max commits projects modi ed statements .
basic change types .
bct 1bct 2bct 3bct 050100150200ms 1ms 2ms 3ms 4ms 5ms 6change typecommits figure clustering produced change types.
the bct facet stores the number of bcts in the change type.
the ms facet stores the average number of modi ed statements in the change type.
are excluded from our inspection.
the change type with the most commits has the signaturefbc falsey 1g which inserts one falsey check into a branch condition and has one modi ed statement on average.
this is typically to repair a typeexception or to handle a missing edge case.
as another example the most frequent change type with four bcts has the signature frsivar1 bcifalsey r aritrue r arifalse 1g which declares a new variable adds a falsey branch condition and adds one true and one false reserved word to the right hand side of assignments.
when we inspect the commits with this change type we see that this change type repairs a bug where a method should only be executed once.
the full list of change types is available in our dataset .
.
pervasive bug patterns rq3 our manual inspection took two authors approximately man hours to inspect the change types described in section .
.
compared to an earlier inspection where it took one author over ve days to inspect approximately commits from only two node.js projects our approach is able to greatly reduce the inspection time.
we found that in most cases the change types produced by bugaid have very similar bug patterns i.e.
usually between one and three patterns per change type we now provide a qualitative analysis of common bug patterns from our inspection.
we discuss the bug patterns at a high level and omit discussing each change type individually.
for example a bug pattern where null orundefined could be dereferenced is present in multiple change types because it can be repaired in multiple ways such as putting the dereference inside a conditional statement exiting the function before the dereference occurs or initializing the variable.
foreach group of bug patterns their frequency the associated change type ct id and a link to a representative commit are listed in our online dataset and tech report for the interested reader.
the following are the inferred patterns that we believe are the most relevant to the development of tools and ide support for detecting and preventing bugs in javascript code.
.
.
dereferenced non values in javascript there are two types null and undefined which indicate that a variable does not have a value.
dereferencing these objects produces a typeerror .
a variable which is not declared or initialized points to the property undefined while it is convention to assign the value null to a variable that has no value.
the following repairs frequently occur for this bug pattern protect with falsey check cts .
in javascript several types and values are coerced to the boolean value false when used as a boolean in a condition.
these include false null undefined andnanand are known as falsey values.
this repair prevents the dereference of null orundefined values by checking if they are coerced to false.
if !
target .
parts return part target .
parts protect with no value check cts .
there are two different equivalence comparison operators in javascript.
the rst is the value comparison operator and !
which checks if two variables have the same value.
null andundefined are value equivalent because both are considered to have no value.
this repair prevents the dereference of null orundefined values by checking if they do not have a value.
if val if val val null val curcss elem name protect with type check cts .
the second equivalence comparison operator is the value and type comparison operator and !
which checks if two variables have the same value and type.
types can also be checked with thetypeof keyword.
this repair prevents the dereference of null orundefined values by performing a type check with either a value and type comparison operator or the use of a typeof operator.
if typeof torlink string if torlink .
tolowercase .
match ... !
null .
.
incorrect comparison because there are multiple ways falsey check by value or check by value and type of checking equivalence in javascript it is possible to use a comparison operator that permits too many types or too few types to pass a branch condition.
compare fewer types cts .
a variable can be compared for multiple types by coercing it to a boolean or by using a check by value operator.
in some cases the omission of type equivalence causes an incorrect result for a branch condition.
for example if the variable port may be undefined it is incorrect to prevent its use in a url by checking if it is falsey.
such a comparison would also lter out port number zero which is a valid port.
the use of compare byvalue operators are discouraged for this reason and linting tools typically generate a warning when it encounters one.in most cases the repairs we see address bad practice however we also see instances of bugs that result from the use of compare by value operators.
if typeof opt .
default !
undefined if typeof opt.
default !
undefined self .
default key opt .
default compare more types ct .
in the opposite scenario a value may be encoded in di erent types e.g.
no value can be expressed as null orundefined but the comparison permits only one of those values.
if encoded test test if encoded test test .
.
missing argument cts javascript functions are variadic i.e.
they can accept a variable number of arguments.
this means javascript does not require that the arguments in a function call match the parameters in a function de nition.
because of this arguments may be accidentally omitted resulting in an incorrect argument order.
in the callee this means the parameters will be out of order.
this bug is often repaired by passing null in place of the missing argument.
1if completed arr.
length callback callback null .
.
incorrect api configs cts one of the more common change types is the repair of api con gurations.
in this bug pattern an api con guration option is not speci ed or not correct.
there are several factors that may contribute to this pattern.
first apis can be con gured in many di erent ways e.g.
through constructors object literals json etc.
but very rarely are developers forced to specify a con guration option.
in a statically typed language such as java the developer might be forced to assign values to elds through the constructor which would be enforced at compile time.
second many javascript ides do not support code completion forcing a developer to manually look up expected options.
third node.js applications rely heavily on a large number of apis maintained by di erent developers.
such variation in developers may contribute to a wide variety of apis that may be non trivial to con gure.
grunt .
initconfig clean force true build .
.
this not correctly bound in javascript functions the reserved word this is bound to the object which rst executes the function.
because of javascript s closure property developers may incorrectly assume that this is bound to the object in which the function is de ned.
access thisthrough closure cts .
because of javascript s closure property a function declared inside another function can access the local variables of the parent function.
this property can be used to eliminate the use of this inside a callback function and avoid binding issues.
var self this self .
serverconfig .
connect function err result self .
state connected bind this ct .
javascript contains three functions that explicitly bind this to an object before a function is called.
these functions are call bind andapply .
this repair binds this using one of these three functions.
kiwi .
global .
panels this .
panels kiwi .
global .
panels .
bind this .panels this .
.
unhandled exception error handling in javascript can be messy and errorprone.
because javascript is often asynchronous and eventbased errors are propagated in many di erent ways.
catch thrown exception ct .
in sequential javascript where errors are propagated with a throw statement and caught with a catch statement error handling is not enforced which can lead to uhandled errors.
try html kiwi .
jade .
compile str ... catch e response .
statuscode error not propagated to callback ct .
callbacks and promises complicate the propagation of errors in javascript because in this asynchronous model errors cannot be propagated up the stack .
errors that must be explicitly propagated through callbacks or promises are often forgotten about.
server .
prototype .
handle function outernext function next err outernext outernext err check callback exception ct .
similar to the previous repair errors given to callback functions are often left unchecked.
this repair handles an error that has been passed to the callback function.
return fs.
readfile path function err buffer if err throw err .
discussion due to space limitations we have only presented a few of the more common bug patterns that exist in our dataset of change types.
many more exist although building a generic tool to look for some of them might be prohibitively di cult because of their project speci c characteristics.
one interesting question is of the bug patterns we identify which are currently handled by existing tools?
type checking tools for javascript have been a research focus recently once adopted and integrated into ides they may help to reduce bug patterns such as those in dereferenced non values .
linting tools such as jshint3can also help prevent some but not all of the bugs in incorrect comparison .
simple tools like argument validator may help prevent the missing arguments bug pattern.
still techniques for preventing these bugs are far from mature.
new ideas implementations and integrations are needed to further reduce their prevalence.
for other bug patterns like this not correctly bound incorrect api con gurations and unhandled exception there is a lack of tool support to the best of our knowledge.
must also consider bugs we expected but did not nd.
for example we found that prototype handling was often done very well with changes to prototypes often re ecting changes to a module s api.
this was often the best documented and well formatted code.
we did not encounter any repairs involving the use of eval considered by many as a problematic language construct.
while eval did appear in our list of bcts it did not appear in any change type.
this likely indicates that eval is either used sparingly in node.js javascript or it is not as error prone as people might have expected.
our ndings may be used to direct researchers towards creating and improving tools and techniques to prevent common bugs in javascript act as a guide to which tool support to implement in a javascript ide and make developers aware of the common mistakes involved with programming in javascript so that they can adopt their programming style accordingly.
threats to validity.
threats to internal validity are the language model we use is not complete.
there are language constructs which we did not include in our language model e.g.
the operator .
a better language model may discover more bug patterns however we believe that our language model includes the most important javascript constructs and likely captures many of the most pervasive bug patterns the subjects and change types used in tuning our clustering approach may have caused over tting.
we attempted to mitigate this by keeping our language model simple and by using a large data set to mitigate the e ects of a small epsilon we only inspect repairs which appear in a commit.
bugs that are repaired before a commit is merged into the main branch are not captured by our method.
threats to external validity are the results may not extend to client side javascript.
almost all of our subjects are server side node.js projects under heavy use and development the results may not generalize to all node.js projects.
while this is unlikely for the most frequently occurring patterns some results may be speci c to our subject systems we discuss a subset of bug patterns based on our knowledge of program analysis and testing.
there may be bug patterns that are more interesting or relevant to others which is why we make the data set of bug patterns publicly available.
.
related work mining change types.
fluri et al.
use hierarchical clustering to discover unknown change types in three java applications.
this approach is similar to ours however the basic change types they use are limited to the bcts identi ed in and do not use language constructs.
unlike bugaid this work does not identify pervasive bug patterns.
negara et al.
use an ide plugin to track ne grained changes from developers and infer general code change patterns.
livshits and zimmerman discover applicationspeci c bug patterns methods that should be paired but are not by using association rule mining on two java projects.
unlike bugaid this work is limited to method pairs only.
pan et al.
use line level di erencing to extract and reason about repair patterns for automated program repair.
the repair patterns they identify are coarse grained and do not identify the root cause of the bugs.
kim et al.
discover six common repair patterns in java by grouping changeswith groums .
they suggest possible root causes for three of these patterns.
however the focus of their work is on discovering repair patterns for automated repair.
they do not provide metrics or discussion on the root causes of the six repair patterns.
it is unclear whether using groums for discovering change types is more e ective than any of the approaches previously discussed.
an implementation of the groum mining tool is not available and may not be feasible for analyzing javascript.
in our experience these techniques have not been able to group repair patterns tightly enough to easily infer the root cause of each bug.
this limitation from our perspective may not be relevant to automated repair research however it is worth considering if a more ne grained grouping of repair patterns will enhance automated repair approaches.
mining bug patterns.
li et.
al.
group bugs by classifying the natural language content of bug reports .
this is useful for inferring what kinds of bugs are being repaired at a high level but does not give us the exact source code changes that are taking place.
further because many bugs are repaired without records in a bug report this technique may miss important bug patterns.
javascript bug patterns.
there have been very few studies which investigate bug patterns in dynamic languages.
ocariza et al.
manually inspect bug reports pertaining only to client side javascript code.
they nd that the majority of reported javascript bugs on the client side are dom related meaning the fault involves a dom api call in javascript code.
we apply our technique to javascript applications and server side javascript code in which the dom is non existent to detect and analyze bug patterns that are inherent to the javascript language.
in addition our study includes javascript applications making it the largest empirical study to nd common javascript bug patterns.
.
conclusion and future work we proposed bugaid a data mining technique for discovering common unknown bug patterns.
we showed that language construct changes are closely related to bug patterns and can be used to group bug xing commits with similar faults and repairs.
using bugaid we performed an analysis of commits from server side javascript projects.
we discovered bcts and change types.
from our inspection of change types we discussed groups of pervasive bug patterns that we believe are among the most pressing issues in javascript.
with a better language model weighing of features and enough data it is feasible in future work that the density of the clusters could be increased so that almost all clusters include only one bug pattern.
if such a result could be achieved our approach to discovering pervasive bug patterns will be completely automated with human intervention only required to create natural language descriptions of the bug patterns.
this could have implications for a number of research areas including automated repair and defect prediction.
.
artifact description in this section we describe the artifact dataset and tool that accompanies this paper.
the purpose of the artifact is to enable replication of the evaluation and empirical study and to allow users to explore some of the bug patterns that exist in javascript in greater detail than could be presented in this paper.
it has multiple components including an executable for reproducing or expanding the dataset the list of subjects the raw data the list of basic change types bcts and the list of change types.
in addition to the raw data and executable for each component we provide a graphical web interface for exploring the data.
.
executable and subjects we provide an executable and a list of git repositories for reproducing or expanding the results of our empirical study.
the executable has two main classes the rst builds the raw dataset ofhcommit bctirelations by mining the repository histories the second lters the data and clusters the commits into change types.
installation and useage instructions are available in the executable s readme .
the list of git repositories is the same as what we used in our empirical study.
detailed information about these repositories is available on the artifact s web page .
.
raw data our commit mining process created hcommit bctirelations for commits.
the dataset is available as a csv le which is downloadable from the artifact s web page.
each row contains the commit id the number of modi ed statements in the commit and a list of bcts that are present in the commit.
it can be used in lieu of regenerating the dataset with the executable or to perform alternate data mining tasks.
.
basic change types a bct is the smallest unit of change in our method.
the list of unique bcts in the raw data and the number of occurrences of each bct is available through a searchable interface on the artifact s web page.
the dataset is useful for looking up the relative frequency of bcts.
for example the most frequently inserted call to a javascript api method is replace which was inserted times in our subjects.
by contrast the builtin method evalwas only inserted times.
.
change types change types are groups of commits which share a similar set of bcts and number of modi ed statements.
the list of change types discovered in our empirical study is available as an .arff le and through a searchable interface on the artifact s web page.
the dataset is useful for exploring bug patterns that exist for javascript.
in our empirical study we highlighted bug patterns that we believe are good candidates for detection using static analysis tools.
there are many more patterns that either occurred less frequently in our dataset or that require project speci c or api speci c knowledge to diagnose.
because there are alternate applications for which these patterns may be relevant we provide an interface for exploring change types in the same manner that we used in our empirical study.
we suggest the following method for investigating a particular class of bug .
identify which bcts might be included with the class of bug under investigation.
.
use the interface on the artifact s web page to nd change types that contain these bcts.
.
for each change type use the interface to inspect the commits inside the change type.
for example assume we are interested in bugs associated with using callbacks.
first we identify relevant bcts.
in this case they are bcts that change a callback convention token such as the bct cvmc icallback .
next we search for clusters that contain this bct.
cluster includes this bct.
finally we inspect the commits in cluster by opening the commit summaries on github using the provided links.
we observe that in general the commits in cluster repair an error caused by unchecked state by returning control through a callback function.
.
evaluation data the raw data used in the evaluation both hcommit bcti relations and change types is available as a download from the artifact s web page.
it can be used to replicate the evaluation.
.