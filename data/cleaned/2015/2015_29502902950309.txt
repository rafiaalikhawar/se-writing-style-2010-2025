understanding and generating high quality patches for concurrency bugs haopeng liu yuxi chen shan lu university of chicago usa fhaopliu chenyuxi shanlu g cs.uchicago.edu abstract concurrency bugs are time consuming to x correctly by developers and a severe threat to software reliability.
although many auto xing techniques have been proposed recently for concurrency bugs there is still a big gap between the quality of automatically generated patches and manually designed ones.
this paper rst conducts an in depth study of manual patches for real world concurrency bugs which provides both assessments for existing techniques and actionable suggestions for future research.
guided by this study a new tool hfix is designed.
it can automatically generate patches which have matching quality as manual patches for many concurrency bugs.
ccs concepts general and reference !reliability computer systems organization !reliability availability software and its engineering !software maintenance tools keywords concurrency bugs automated bug xing multi threaded software empirical study .
introduction .
motivation concurrency bugs are caused by synchronization problems in multi threaded software.
they have caused real world disasters in the past and are a severe threat to software reliability with the pervasive use of multi threaded software.
the unique non determinism nature has made them di cult to avoid detect diagnose and x by developers.
previous studies of open source software have shown that it often takes developers several months to correctly x concurrency bugs.
furthermore concurrency bugs are the most di cult to x correctly among common bug types with many incorrect patches released.
consequently child thread if ... unlock fifo mut a return parent thread thread join ... if ... fifo mut null b1 fifo null b2 a manual and hfix patch child thread if ... unlock fifo mut a lock l signal con unlock l return lock l signal con unlock l parent thread lock l while ... wait con l unlock l if ... fifo mut null b1 fifo null b2 b simpli ed cfix patch figure a simpli ed concurrency bug in pbzip2.
automated tools that help x real world concurrency bugs are well desired.
recently many automated xing techniques have been proposed.
some are for general bugs and some are for speci c type of bugs .
particularly several tools dedicated to concurrency bugs have been proposed .
existing concurrency bug xing tools can handle all common types of concurrency bugs leveraging a unique property of concurrency bugs since concurrency bugs manifest nondeterministically the correct computation semantics already exist in software.
consequently these tools work not by changing computation semantics which is required for most non concurrency bug xing but by adding constraints to software timing.
they mostly achieve this by adding synchronization operations including locks and condition variable signal waits into software.
figure 1a illustrates a simpli ed version of a real world bug in pbzip2 a parallel le compression software.
here the lack of synchronization causes the parent thread to occasionally nullify objects b1andb2in figure that are still used by the child thread ain gure making pbzip2 crash.
an existing tool cfix can automatically x this bug by adding condition variable signals and waits as illustrated by the lines in figure 1b1.
although great progress has been made patches generated by existing tools are mostly di erent from patches manually designed by developers.
existing auto patches mostly insert permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
locks and lock related synchronization operations into software yet less than one third of real world concurrency bugs are xed by developers through adding or changing lock operations .
the state of the art auto patches often lack simplicity comparing with manual patches which we will discuss in details in section .
for example developers simply x the pbzip2 bug by adding the missing thread join operation as shown in the figure 1a.
instead automatically generated patches are much more complicated adding ve sets of conditionvariable signal wait operations as well as corresponding lock unlock operations and counter ag maintenance and checking operations .
clearly we need a better understanding of the gap between automatically generated patches and manually generated patches so that we can eventually design auto xing tools that generate not only correct but also simple and wellperforming patches appealing to developers.
.
contributions in this paper we rst conduct an in depth study of manual patches for real world concurrency bugs.
guided by this study we then build a new bug xing tool hfix that can automatically generate patches with matching quality as manual patches for many concurrency bugs.
study manual patches we have checked the manual patches of real world concurrency bugs collected from a set of open source c c multi threaded software.
it tells us what synchronization primitives and x strategies are used by developers to x concurrency bugs.
we list a few ndings below with more details in section .
.lock is indeed the dominant synchronization primitive for enforcing mutual exclusion atomicity condition variable signals and waits are notthe dominant primitive for enforcing pairwise ordering in patches.
.although adding extra synchronization operations is indeed a common x strategy leveraging existing synchronization in software is as common.
unfortunately the latter has notbeen explored by previous work that xes concurrency bugs in large scale software.
.more than of the studied bugs are not xed by constraining the timing of program execution.
in fact about of bugs are xed by changing computation not synchronization semantics in a thread deviating from the fundamental assumptions taken by existing concurrency bug xing tools.
these patches are not ad hoc.
they follow certain patterns and are promising to get automatically generated in the future.
our ndings provide assessment for existing techniques both justifying their directions and identifying their limitations and provide actionable suggestions for future research.
hfix guided by the above study we design hfix that can x many real world concurrency bugs in large software by two strategies that have not been well explored before.
the rst hfix join enforces ordering relationship by adding thread join operations instead of signal waits section .
1figure1b does not show all signals and waits in auto patches it also omits counter ag operations associated with each signal or wait operation for illustration purpose.table applications and bugs in study app.
description bugs av ov apache web server mozilla browser suite mysql database server openo ce o ce suite misc.
cherokee web server click router fft benchmark pbzip2 compressor transmission bittorrent client and x264 encoder1 total hfix joincan produce simple patches just like the manual patch shown in figure 1a.
the second hfix move enforces ordering and atomicity relationship by leveraging synchronization operations that already exist in software section .
hfix works for a wide variety of concurrency bugs.
evaluation using real world bugs shows that it can indeed automatically generate patches that have matching quality with manual patches and are much simpler than those generated by previous state of the art technique section .
.
studying manual patches our study aims to answer three sets of questions.
what are manual patches like?
what are the x strategies and synchronization primitives used by manual patches?
are all concurrency bugs xed by constraining the timing?
does any patch change sequential semantics?
how do patches vary for di erent types of concurrency bugs?
how are existing techniques?
how do existing tools work particularly compared with patches manually developed by developers?
how about the future?
how might future tools generate patches that match the quality of manual patches?
.
patch study methodology to answer the above questions we review the manual patches of bugs.
these bugs come from two sources.
the rst is the real world concurrency bug benchmark suite created by previous work .
among the non deadlock bugs in that suite2 a couple of them are not completely xed by developers and hence are excluded from our study.
the remaining are shown in the top half of table .
the second part includes all the bugs evaluated by a few recent concurrency bug detection and xing papers that have available manual patches and are not included in the rst source shown in the misc.
row of table .
these bugs come from a broad set of c c open source applications that include both big server applications e.g.
mysql database server and apache httpd web server and client applications e.g.
mozilla web browser suite and many others .
these applications are all widely used with a long software development history.
among these bugs of them are atomicity violation av bugs and of them are order violation ov bugs.
2our study focuses on non deadlock concurrency bugs.
716table synchronization primitives in patches lock con.var.
create join misc.
none av ov total atomicity violations occur when the atomicity of a code region in one thread gets violated by interleaving accesses from another thread s .
previous research often denotes an atomicity violation by a p c rtriplet where pand crepresent two operations forming the expect to be atomic code region in one thread and rrepresents the interleaving operation from another thread.
we will use these symbols when discussing av bugs.
order violations occur when an operation bunexpectedly execute before instead of after an operation a e.g.
the bug shown in figure .
previous research uses abto represent an order violation bug and we will also use these symbols when discussing ov bugs.
we carefully study the nal patch of each bug.
we also read developers discussion on the on line forums and software source code to obtain a deep understanding of each patch.
every bug was reviewed by all authors with the patch categorization cross checked by all authors.
threats to validity like all empirical studies our study cannot cover all concurrency bugs.
our study only looks at c c user level client and server applications and does not cover java programs operating systems software or high performance computing software.
our study does not look at deadlock bugs and also does not cover bugs that are related to the newly minted c concurrency constructs.
our study does not and cannot cover all concurrency bugs in apache mysql mozilla and other software in our study.
our main bug source the benchmark from previous work is based on xed concurrency bugs randomly sampled from the above applications bug databases.
all our ndings should be interpreted with our methodology in mind.
.
what are manual patches like?
synchronization primitives as shown in table a big portion of bugs are xed without using any synchronization primitives about half .
most of these bugs are xed without disabling the buggy timing which will be explained later.
among patches that leverage synchronization primitives there is a clear distinction between atomicity violation and order violation patches.
in av patches lock is the single dominant synchronization primitive rarely condition variables interrupt disabling and atomic instructions are used.
in ov patches condition variable signal waits thread creates and thread joins are about equally common.
occasionally customized synchronizations like spin loops are used.
fix strategies concurrency bugs are caused by instructions that access shared variables under unexpected timing.
patches can prevent these bugs in three ways change the timing among those instructions timing in table which can be achieved by either adding new synchronization adds or moving around existing synchronization move s bypass some instructions under the original buggy context instruction bypass make some shared variables private under the original buggy context data private .
patches could also tolerate the e ect of concurrency bugs insteadtable fix strategies break downs across root caused and applications are both shown above and below the line prevention tolertiming instruction data ance addsmove s bypass private av ov ap my mo op misc.
total child thread assert h band b parent thread void tr sessioninit ... h malloc ... h band bdnew h tr eventinit ... ... h band bdnew h a void tr eventinit ... pthread create ... figure a bug in tranmission with and denoting its manual hfix patch.
of preventing them tolerance .
the break down of these strategies is shown in table .
overall as shown in table constraining the timing through new or existing synchronization is the most common x strategy applied to almost of bugs in study.
other x strategies are not as common but still non negligible each applied to at least of studied bugs.
among patches that use the timing x strategy about half add new synchronization operations into the software and the other half leverage existing synchronization operations.
for the latter type the patch is always done by code movement.
for example the real world bug illustrated in figure is xed by moving variable initialization a before child thread creation in the parent thread so that the child thread is guaranteed to read an already initialized value b .
bugs are xed by making some instructions involved in the bug access local instead of shared variables.
we will discuss them in more details in section .
.
patches with instruction bypassing and bug tolerance strategies change the sequential computation semantics out of .
note that all previous concurrency bug xing work uses an opposite assumption and only produce patches that preserve sequential semantics.
.
how about existing techniques?
adding locks and condition variables recently several tools have been built to automatically x concurrency bugs by adding locks such as afix grail and axis and condition variables such as cfix .
these techniques provide general xing capability that applies for a wide variety of concurrency bugs.
717our empirical study shows that these techniques indeed emulate the most common type of manual x strategies add new synchronization add s as shown in table .
however there are still many bugs that are not xed through add sby developers in our study .
in many cases other x strategies can produce much simpler patches and introduce fewer synchronization operations into software than add s such as those in figure and .
another limitation for this series of tools is that they only look at two types of synchronization primitives locks and condition variables.
locks are indeed the most dominant primitive for xing av bugs.
however condition variables arenotthe most dominant primitive for xing ov bugs as shown in table .
in fact among the ov bugs that are xed by adding new synchronizations only of them are xed by adding condition variable signal waits.
most of them are in fact xed by adding thread join operations such as that in figure 1a.
data privatization another x strategy automated by recent research is data privatization .
previous technique targets two types of av bugs where the atomicity of readafter write raw accesses or read after read rar accesses can be violated.
its patch creates a temporary variable to bu er the result of an earlier write access in case of raw or read access in case of rar to or from shared variables and let a later read instruction from the same thread to directly access this temporary variable instead of the shared variable.
our empirical study shows that data privatization is indeed a common x strategy for av bugs in practice taken by developers to x out of av bugs in our study.
however our study also found that the data privatization scheme used by developers goes beyond what used by existing research.
first some write after write waw atomicity violations are also xed by data privatization by developers.
for example mozilla and mozilla are both xed by making the rst write outputs to a temporary local variable so that an interleaving read will not see the intermediate value.
second in several cases the bugs are xed not by introducing a temporary local variable but by changing the declaration of the original shared variable to make it a local variable.
for example in mysql mozilla and mysql developers realize there are in fact no need to make the buggy variables shared.
only bugs are xed by developers following exactly the same way as existing research proposes.
.
how about the future?
our study points out directions for future research in automated concurrency bug xing.
speci cally future work can further re ne existing auto x strategies such as data privatization following our study above future research can also try to automate manual x strategies that have not been well explored before which we will discuss below.
automating add joinfor ov bugs although many recent research tools apply add sto x concurrency bugs they only add lock related synchronization into software including locks and condition variables.
this is particularly problematic for ov bugs as many manual ov patches are unrelated to locks or condition variables.
our work along this direction will be presented in section .
automating move sfor concurrency bugs move s leverages existing synchronization in software to x con table semantic changing patches b bypass strategy t tolerance strategy .
patch location patch structure avcavrova ovb misc skip unskip misc b t currency bugs.
it is one of the most common manual x strategies for both av out of and ov bugs out of .
unfortunately it has never been automated by previous research to x real world bugs in large applications.
our work along this direction will be presented in section .
semantic changing x for concurrency bugs bypass and tolerance are two intriguing concurrency bug x strategies as they change the sequential semantics and were never explored by previous research.
they are common enough to deserve attention together they are chosen for out of real world bugs in our study.
their patches are often simple mostly between lines of code changes.
our in depth study shows that these patches are not adhoc.
instead they follow common patterns that can be leveraged by automated tools as shown in table .
first the patch location is almost always around key operations in the bug report as shown in table .
second the patch structure is mostly simple.
naturally all bypass patches add condition checks to bypass code.
interestingly almost all tolerance patches are also about control ow changes.
some add condition checks to bypass failureinducing operations such as a null pointer dereference after the unsynchronized accesses.
others change existing condition checking so that some code that was originally skipped under the unsynchronized accesses would now get executed under the patch.
of course there are still challenges such as guring out the expressions used for condition checking and refactoring following the control ow changes.
overall our empirical study shows that automating bypass and tolerance strategies are not only intriguing but also important and promising.
we leave this direction to future research.
.
bug fix background overview hfix reuses the general bug xing framework proposed by cfix figure .
the inputs to the bug xing framework are bug reports which can be automatically generated by bug detection tools .
given a bug report some checkings are conducted to see which x strategies might be suitable for the bug fix strategy design .
then program analysis and code transformation are conducted to enforce the desired synchronization following the x strategy synchronization enforcement .
after that the generated patches go through testing and merging with nal patches produced.
hfix will modify and extend three key components of the xing framework highlighted by gray background in figure .
that is di erent x strategies will be considered di erent types of program analysis and code transformation will be conducted following the di erent x strategies nally the patch merging will also be di erent.
hfix reuses some cfix techniques.
speci cally hfix reuses the function cloning technique used in cfix when it 718fix strategy design synchronization enforcement patch testing selection patch merging final patches feedback bug report figure bug xing process generates patches that take e ect under speci c calling contexts.
cfix makes best e ort to avoid introducing deadlocks but does not prove deadlock free.
instead it provides the option to instrument patches for light weight patch deadlock monitoring which is reused in hfix.
hfix reuses an important philosophy of cfix bug xing works only when correct bug reports are provided.
hfix re uses the bug report format requirement of cfix.
an av report needs to specify three statements p c and r. as discussed in section .
an av bug manifests when one thread unexpectedly executes rbetween another thread s execution of pandc.
an ov report needs to specify two statements aandb.
as also discussed in section .
the ov bug happens when aunexpectedly executes after instead of before b. since ov bugs are sometimes context sensitive cfix also requires an ov bug report to contain the calling contexts of aandb including a call stack that executes the buggy instruction in the thread and a chain of call stacks referred as thread stack indicating how that thread has been created.
for an instruction i we call its call stack and thread stack together as stack ofi and we call the thread that executes ias thread of i orthread i. .
hfix join a thread join operation i.e.
join such as pthread join can enforce all operations after join in a parent thread to wait for all operations in the joined thread.
adding join is a common way to x ov bugs as discussed in section .
this section presents hfix jointhat automatically identi es suitable ov bugs and xes them through add joinstrategy.
hfix jointakes as input the ov bug report that includes the stack of aand the stack of bwithaexpected to execute before b as de ned in section .
hfix joinwill then go through two main steps.
.suitability checking section .
.
not all ov bugs can be xed by adding join.
hfix checks whether thread a is a never joined child of thread band other conditions to decide whether add joinis a suitable strategy for the given bug.
.patching section .
.
once the suitability is decided hfix conducts code transformation to x the bug.
.
patch suitability checking isthread aa joinable child thread of thread b?hfix patches follow the common practice and only join a thread from its parent thread.
to achieve this hfix checks whether thread ais a child of thread bby examining the stacks of a andb.
from the stack of a hfix identi es the statement c that creates thread a and then easily tells whether ccomes from thread bby comparing the stacks.
in addition hfix checks the stack of bto make sure there will be only one instance of thread b i.e.
hfix checks to make sure thatthe thread creation statements are not in loops .
otherwise inserting join cannot guarantee every instance of bto wait for all instances of a. isthread aalready joined?
when the software already contains a join forthread a adding an extra join is often not a good strategy.
this analysis goes through two steps.
we rst go through all functions in software to identify join statements.
for every existing join we then check whether it is joining thread a. in our implementation this is done by checking whether the rst parameter of the pthread create statement for thread amay point to the rst parameter of thepthread join under study.
will there be deadlock?
an added join will force b to wait for not only a but also all operations following a inthread a. this extra synchronization is not required by bug xing.
therefore we need to check whether it may lead to deadlocks or severe performance slow down.
speci cally we conduct inter procedural analysis to see if any blocking operations i.e.
pthread cond wait pthread join and pthread mutex lock in our implementation may execute after ain thread a. if any of these are found hfix aborts the add join x strategy as adding join will bring a risk of potential deadlocks and or severe performance slowdowns.
furthermore hfix also aborts the patch if bis inside a critical section because inserting a blocking operation i.e.
join inside a critical section may lead to deadlocks.
.
patch generation to generate an add joinpatch we need to rst decide the location of the new join right before b. ifbis inside a loop we will use a ag to make sure that the join executes only once.
note that an alternative and simpler patch is to insert the join before the loop which does not require any ags.
the current implementation of hfix does not take this option fearing that the early execution of join may hurt performance or introduce deadlocks.
the parameter of join needs to contain an object that represents the child thread i.e.
the thread t object returned by pthread create in posix standard .
to obtain this object our patch creates a global vector pushes every newly created thread t object into this vector right after an instance of thread ais created and invokes join for each object in the vector right before b. our current implementation targets posix standard and posix functions.
small modi cations can make hfix work for non posix customized synchronization operations.
.
hfix move as shown in section and table many concurrency bugs including both av bugs and ov bugs can be xed by leveraging existing synchronization in software instead of adding new synchronization.
speci cally a move patch rearranges the placement of memory access statements which 719threada threadb b s sdsfbuf threada threadb b a b s skpjo threadpc threadr r s svompdl p c threadpc threadr r s p c a a c p a movecsfbuf fixes ov bug move up a or move down s b movejoin fixes ov bug move up s or move down b c moveunlock fixes av bug move up c or move down s d movelock fixes av bug move up s or move down p smpdl figure fixing ov bugs and av bugs through move thick arrows represent happens before relationship enforced by a synchronization operation s such as signal wait create and join the dashed arrows demonstrate move directions are involved in a concurrency bug and synchronization operations which already exist in the same thread so that the memory access statements will be better synchronized as illustrated in figure .
this section will present hfix move that automates the move x strategy.
.
overview of hfix move applying a move patch is more complicated than applying an add joinpatch.
the suitability checking and patch generation are conducted together in four steps.
.identify two operations in one thread so that ipping their execution order can x the reported bug.
how to conduct this step varies depending on the type of the bug and the type of synchronization nearby.
.control ow checking.
we need to make sure the movement does not break control dependencies causing a statement to execute for more or fewer times than it should be.
at the end of this step a candidate patch will be generated and go through the next two steps.
.data ow checking.
we need to make sure the movement does not break existing de ne use data dependency within one thread causing the patched software to deviate from the expected program semantic.
.deadlock and performance checking.
we need to check whether the movement could bring risks of deadlocks or severe performance slowdowns.
.
identifying move opportunities move joinopportunities for ov bugs since join can enforce ordering between operations in parent and child threads we can leverage existing join to x ov bugs as shown in figure 4b.
given an ov bug ab we check whether thread aisjoin ed by thread bin the buggy software.
if such a join exists we know that this bug can potentially be xed by moving bafter the join move down or moving the join before b move up as shown in figure 4b.
of course if we want to make sure all instances of awill execute before b we need to check the stack of bto make sure there is only one dynamic instance of thread b. move create opportunities for ov bugs a thread creation operation denoted as create forces all operations before create inside the parent thread to execute before all operations inside the child thread.
consequently create can be leveraged to x some ov bugs as shown in figure 4a.speci cally given an aborder violation bug we will check the stack of bto see if thread bis created by thread a. if so a move create opportunity is identi ed the bug can potentially be xed by moving ato execute before the create moveup or moving the corresponding create to execute after a move down .
of course like that in move join if the patch wants to force all dynamic instances of ato execute before b we also need to check the stack of ato make sure that there could be only one dynamic instance of thread a. move lockand move unlock opportunities for av bugs given an av bug report p c r the patch needs to provide mutual exclusion between the p ccode region and r. ifr and part of the p ccode region are already protected by a common lock the patch can leverage existing lock orunlock as illustrated by figure 4d and figure 4c.
speci cal hfix identi es move lockor move unlock opportunities for an av bug in two cases.
in the rst case p andrare inside critical sections of lock l but cis not.
as shown in figure 4c this type of bugs can potentially be xed by re ordering cand a corresponding unlock operation move unlock3 .
in the second case candrare inside critical sections of lock l but pis not.
as shown in figure 4d this type of bugs can potentially be xed by re ordering pand a corresponding lock operation move lock .
below we describe our analysis algorithm focusing on the move unlock case.
the algorithm for move lockpatches is similar.
to identify the above two cases we rst identify all the critical sections that contain p c and r respectively and then compare the locks that are used for these critical sections.
note that accurately identifying all enclosing critical sections and comparing lock sets are very challenging as it involves inter procedural and pointer alias analysis.
our current implementation only considers critical sections that are in the same function as p orc orr not in their callers and are protected by global locks not heap locks.
this way although we may miss some x opportunities we keep our analysis simple and accurate.
generalize move join move create move lock move unlock for the ease of discussion we generalize all these strategies and use the following terms and symbols in the remainder of this section.
we use move up to refer to patches that make an operation execute earlier by moving it up in its thread denoted by up pointing dashed arrows in figure we use move down to refer to patches that make an opera3sometimes we use move lockto represent both lock moving patches and unlock moving patches.
720if ... pthread create ... y else ... g t x xy b what if y may not execute a what if y is in a loop?
for ... pthread create ... y g t x yxpthread create ... y if ... g t x c what if x may not execute figure control ow challenge for code movement.
tion execute later by moving it down in its thread denoted by down pointing dashed arrows in figure .
we use xto denote the operation in the original program that gets moved use x to denote its counter part in the patched program and use yto denote the operation that x needs to move around in order to x the bug.
for example figure 4a demonstrates move create strategy.
in the move up version of a move create patch xrepresents operation a and yrepresents synchronization s i.e.
create in the movedown version of move create xrepresents synchronization s andyrepresents operation a. .
control flow checking we conduct several rounds of control ow checking to identify the correct location of x while make sure that x will execute for exactly the same number of times as x. first check if xandyare inside the same function.
we do not want to make the movement when xandyare inside di erent functions as that would break the original code encapsulation.
for the cases of move joinand move create when xandyare inside di erent functions we nd a common function fon their call stacks change the operations under interests from xandyto their call sites in f and then conduct all the controlow analysis and movement inside one function f. for example for the bug shown in figure the two operations that we initially want to reorder are pthread create inside function tr eventinit and the write access to h!band inside function tr sessioninit .
since they are not inside the same function we instead identify their common caller tr sessioninit and shift our focus to ipping the order between tr eventinit and the write access.
the same strategy cannot be directly applied to move lockor move unlock .
imagine we want to move a lock operation in function f1so that the corresponding critical section can be extended to contain not only cinf1but also pin function f0 the caller of f1.
we cannot simply move the callsite of f1inf0 because that would likely move the whole critical section inside f1and still leave poutside the critical section.
consequently hfix simply makes a clone of the callee function makes the cloned function inlined and then conducts code movement inside one function.
second check if xis inside a loop.
if it is we abort the x. the reason is that it would be too di cult to move x without changing the number of times xexecutes.
third identify the location x .
note that this is easy when xandyare inside the same basic block x would be simply right after or before y. however in reality there could be several challenges.
for example as demonstrated in figure 5a if yis inside a loop simply moving xto be right after or before it could cause x to execute for many more times in the patched program than xdoes in theoriginal program.
more importantly this movement cannot guarantee that xwill execute before allinstances of y a property that is needed to x many ov bugs e.g.
we may want a variable to be initialized before any child thread can read it .
as another example demonstrated in figure 5b when xandyare not inside the same basic block a naive movement could also cause x to execute for fewer times in the patched program than xdoes in the original program.
our algorithm addresses all these challenges.
when we want to move xup to execute before all instances of y we will do the following.
we rst identify all controlow graph nodes in function fthat are reachable from y referred to as aftery nodes as shown by the gray boxes in figure .
we then delete x and make x appear on every edge that goes from a non aftery node nto an aftery node n2.
this arrangement guarantees that x will execute before all instances of y because otherwise nwould have been an aftery node it also guarantees that x will execute at most once in its function because once the execution goes from non aftery nodes to aftery nodes it can never go back to nodes non reachable from y before the function exits.
when we want to move xdown to execute after all instances of y the handling is similar.
we rst identify all controlow graph nodes inside function fthat can reach y referred to as beforey nodes.
we then delete x and place x on every edge that goes from a beforey node nto a nonbeforey node n2.
similarly this arrangement guarantees that that x will execute at most once in function fand will execute before all instances of y. finally we need to make sure x will execute for the same number of times xdoes.
note that since xis not inside a loop it will execute at most once.
our arrangement above guarantees the same property for x .
in case of movedown our patch would insert a ag setting statement in the original location of x and a ag checking before every x .
this way we guarantee that x is executed only when the original xwould have been executed.
the move up case could be complicated as illustrated in figure 5c.
when x is executed we may not be able to predict whether x would be executed or not later.
if later execution decides to by pass x we will have to revert the e ect of x .
the revert could be impossible within one thread if x creates a thread or writes to a shared variable.
given this complexity in our implementation we apply the move up strategy only when xexecutes exactly once in function f or the execution of xdoes not require revert or can be reverted easily e.g.
some moved up join does not require revert some moved up lock can be easily reverted .
the complexity of the above analysis is linear to the size of the control ow graph of function f. .
data flow checking we use data ow analysis to check whether the code movement could a ect thread local data dependency and mistakenly change program semantics.
speci cally we identify all instructions ithat might execute between the original location of xand the new location ofx and check if they might access the same memory locations as x. we abort the patch if either imay access a memory location that is written by xor imay write to a memory location that is read by x. in these cases the code movement could break the write after write write afterread or read after write dependency in the original program incorrectly changing program semantics and hence should not be used in bug xing.
in our current prototype we use the default may pointer alias analysis in llvm to decide whether two sets of instructions may read write the same memory object.
we consider create join and un lock functions to only access its parameter objects.
.
deadlock and performance checking to avoid introducing deadlocks or severe performance slowdowns into the program we also check and abort some patches to minimize the risk of introducing circular waits among threads.
for move create we make sure the patch does not push extra blocking operations to execute before create for move join we make sure the patches does not delay some unblock operations to execute after join.
in case of move lockand move unlock we make sure not to move any blocking operations into a critical section.
in our implementation the black list of blocking operations includes lock condition variable wait and thread join operations.
summary hfix moveis sound but not complete.
its patches are guaranteed not to introduce new bugs that violate control dependency or thread local data dependency of the original software as discussed in section .
and .
.
hfix move guarantees not to introduce deadlocks as long as its list of un blocking operations is complete.
however hfix move may miss the opportunity to generate move patches for cornercase move suitable bugs as we will see in our evaluation section .
.
.
.
patch merging a single synchronization mistake such as forgetting to join a child thread can often lead to multiple related bug reports.
fixing these related bugs separately would hurt the patch simplicity and performance.
for example bug detectors report ve highly related ov bugs in pbzip2 two of them are illustrated by ab1andab2in figure .
naively xing these bugs separately would add ve join within a few lines of code which is unnecessarily complicated.
fortunately both add joinand move strategies are naturally suitable for patch merging.
for example if multiple ov bugs between a parent thread and a child thread are reported we may x one bug through add join and the remaining ones through move join leveraging the newly added join.
we could also x each bug report separately and then analyze the patches to see if we can merge them which is exactly what we have implemented in this work.
we only merge patches with the same x strategy.
we only discuss how to merge two patches below merging more than two patches is similar.
we do not discuss how to mergemove lockpatches below because it can be addressed by merging technique proposed in previous work .
.
merge add joinpatches imagine that two add joinpatches are generated for two ov bugs a1b1anda2b2.
our merger explores merging these two patches if a1anda2are from the same thread andb1andb2are from the same thread.
this checking is conducted based on the stack of a1 a2 b1 and b2.
if the two bugs patches pass the rst checking our merger will try to create a merged patch.
that is the merger tries to decide where to add join in the merged patch.
we use j1to denote the location of the added join in the patch for a1b1 i.e.
right before b1in figure 1a and j2to denote the location of the added join in the patch for a2b2 i.e.
right before b2in figure 1a .
the merger will identify the nearest common dominator of j1andj2 denoted as j12 and put the join there in the merged patch i.e.
the line in figure 1a .
this merged patch can guarantee to x both a1b1anda2b2ov bugs because b1andb2are guaranteed to execute after their common dominator join j12 which in turn is guaranteed to execute after a1anda2.
to avoid introducing deadlocks or severe performance slowndowns the merger stops the merging attempt if there exist any signal or unlock operations along the paths that connect j12andj1 and j12andj2.
note that we decide to put the merged join at the nearest instead of any commondominator exactly because we want to minimize the risk of introducing deadlocks or severe perforfance slowdowns.
.
merge move joinand move createpatches imagine that two move joinpatches are generated for two ov bugs a1b1anda2b2.
there is clearly no chance for merging if one patch uses move up i.e.
moving join to execute before b1orb2 and the other patch uses movedown i.e.
moving b1orb2to execute after join there is also no bene t of merging if both patches use the movedown strategy.
when both patches use move up our merger explores merging these two patches if a1anda2are from the same thread and b1andb2are from the same thread just like that in add joinpatch merging.
once the two patches pass the above checking hfix creates a merged patch in a similar way as add joinpatch merging.
that is the merged patch keeps only one of the join from the two patches at the nearest common dominator of the original locations in the two patches.
similar checking is conducted to make sure the merge does not bring extra risks of deadlocks or severe slowdowns.
hfix merges move create patches in a similar way as merging move joinpatches.
we skip the discussion here.
.
experimental evaluation .
methodology hfix is implemented using llvm .
.
.
all the experiments are conducted on eight core intel xeon machines.
benchmark suite to evaluate hfix we use two sets of real world concurrency bugs.
the rst is the bug xing benchmark suite set up by cfix .
it contains ov and av bugs.
these bugs are all representative benchmarks used by many previous works .
they come from publicly released versions of open source c c multithreaded applications most of which contain tens to 722table patch comparison for ov bugs a add m move sync number of new synchronization operations added by the patch j join s signal w wait l lock u unlock patch not generated or not available bugid app.hfix manual cfix strategy sync strategy sync strategy sync ov1 fft a join 1j a join 1j a s.w.
4s 1w ov2 httrack a s.w.
1s 2w ov3 mozilla a lock 2l 2u a s.w.
1s 1w ov4 pbzip2 a join 1j a join 1j a s.w.
4s 1w ov5 transmission m create m create a s.w.
1s 1w ov6 x264 m join m join a s.w.
6s 1w ov7 zsnes m create a s.w.
2s 1w hundreds of thousands lines of code.
they lead to severe crashes and security vulnerabilities.
they are xed by developers through a wide variety of strategies which we will discuss in section .
.
for each bug cfix suite contains the following information the original buggy software bug reports that can be used as inputs to auto xing tools following the format discussed in section and scripts for patch performance and correctness testing.
particularly there is a slightly modi ed buggy program that contains random sleep s to make a bug manifests more frequently and hence more suitable for rigorous correctness testing.
the second set includes allthe av bugs in the concurrencybug benchmark suite composed by lu et.
al.
that are xed by developers through moving synchronization operations.
there are six bugs in this set as shown in table .
for each bug there is a bug report prepared by us using the format discussed in section .
we use the rst set of benchmarks because it enables direct comparison between hfix and the state of the art concurrency bug xing tool cfix.
we use the second set because it allows a targeted evaluation about how well hfix can automate the move x strategy for av bugs.
evaluation metrics we evaluate the quality of hfix patches mainly by comparing them with manual patches.
we will explain what are the di erences if any and whether how the di erences a ect patch quality.
it is infeasible to prove the correctness of a big multi threaded software.
fortunately hfix already provides soundness guarantees for its patches discussed at the end of section and we will use comparison with manual patches to further demonstrate the correctness of hfix patches.
since the main goal of hfix is to improve the patch simplicity of the state of the art we will quantitatively measure patch simplicity by counting the number of new synchronization operations added by each patch.
in addition to comparing with manual patches we will also compare hfix with cfix using cfix benchmark suite.
we will use the simplicity metric discussed above and also run the performance and correctness testing provided by cfix benchmark suite to show that hfix patches do not hurt performance or correctness.
.
experimental results .
.
overall results for ov bugs as shown in table hfix correctly identi es ov bugs that are suitable for add or move x strategies and e ectively generates patches that are as simple as manual patches well complementing the state of the art.among all the ov bug benchmarks hfix automatically and correctly generates simple patches for ve.
hfix also makes correct decisions for the other two that indeed cannot be xed by add joinor move.
speci cally ov3 happens when a child thread unexpectedly reads a variable before it is initialized in the parent thread.
as correctly pointed out by hfix ov3 cannot be xed by add joinor move because join cannot force parent thread operations to execute before child thread operations and data dependency prevents move from being applied.
the situation in ov2 is opposite the parent thread could read a variable before it is initialized in the child thread.
move joinis tried and correctly aborted by hfix due to failed deadlock checking.
comparing with manual patches hfix performs very well.
hfix produces exactly the same patches as developers manually did for ov1 ov4 and ov5.
hfix patch for ov6 has a trivial controlow di erence from the corresponding manual patch hfix patch conducts if .. .. x else x while manual patch does if .. .. x .
comparing with cfix hfix can generate much simpler patches than cfix does.
for ov1 and ov4 ov7 cfix introduces about four signal operations and one wait operation ineach patch.
instead hfix only introduces synchronization operation.
note that the cfix patch complexity goes beyond the synchronization operations listed in table .
for example it also contains the declarations of new global synchronization variables every signal or wait operation also comes with one lock one unlock and some corresponding ag setting checking operations.
of course cfix can x all the seven ov bugs including ov2 and ov3 that cannot be xed by hfix.
this result matches the di erent design goals of cfix which emphasizes generality and hfix which emphasizes specialization and simplicity.
.
.
overall results for av bugs hfix can patch not only ov bugs but also av bugs through the move strategy.
however manual move patches are not as common for av bugs than for ov bugs in real world .
our evaluation shows a consistent trend.
among the six av bugs in cfix benchmark suite none of them is suitable for move strategy because there is no lock unlock operations around the buggy code.
hfix correctly gures this out and did not generate patch for any of them.
cfix can x all these six bugs introducing one new global lock variable and lock unlock operations in each patch.
developers xed these bugs by a mix of strategies including adding lock unlock operations data privatization changing reader lock to writer lock and tolerating buggy timing.
723table patch comparison for av bugs bug app.
hfix manual id stra sync stra sync av1 ap m unlock av2 mo m lock m lock av3 mo m lock m lock av4 my m unlock m unlock av5 my m unlock m unlock av6 my m unlock m unlock among the six av bugs in our second benchmark suite hfix correctly generates simple move patches involving no new synchronization operations or variables for ve of them.
hfix patch for av4 is exactly the same as the manual patch.
hfix patches for av2 and av3 only have trivial di erence from the manual patches exactly like the case of ov6 discussed above.
hfix patches for av5 and av6 are very similar with manual patches.
the di erence is that manual patches directly moved code between a caller function f0and a callee function f1.
instead hfix rst inlines the corresponding invocation of f1inside f0before the movement.
hfix did not generate move patches for av1 because none of the atomicity violation related statements p c and r are inside any critical sections in the buggy software.
the manual patch moves unlock statements to extend a critical section that did not contain p c or rin the buggy version to contain all three of them.
.
.
other detailed results alternative patches for every evaluated bug hfix tries all x strategies and generates as many patches as possible.
having said that ov6 is the only case where hfix generates more than one patch one moves join up and one moves a memory access down.
they only have a trivial di erence and are semantically equivalent with each other there are a few lines of local variable computation that are executed after join in one patch yet before join in the other.
patch testing using cfix benchmark suite we conducted the patch testing provided by cfix benchmark suite.
hfix patches passed the correctness testing the failure rates of unpatched programs range between and measured through testing runs with random sleep s the failure rates of hfix patched programs are all 0under the same setting.
hfix patches also passed the performance testing the overhead of hfix patched programs is always under .
which is each averaged upon failure free runs similar with that of cfix patches .
hfix static analysis hfix static analysis is e cient.
it takes less than seconds to generate patches for each bug.
merging our patch merging is e ective.
among all the bugs ov1 and ov4 are the two cases that contain multiple related bug reports.
without patch merging hfix patches would have contained as many as and join operations for these two bugs.
fortunately after the merging only one join is needed for each as illustrated in figure 1a.
.
.
threats to validity we evaluated hfix on two sets of representative realworld bugs the cfix benchmark suite and all av bugs with move style manual patches in the benchmark suite composed by lu et.
al.
.
we should not over generalize the evaluation results.
it would be wrong to speculate thathfix can generate patches for more than two thirds of ov bugs or of move suitable av bugs in the world.
what we cangeneralize is that hfix is a useful complement and can e ectively improve the state of the art of auto xing for concurrency bugs.
hfix is designed to produce highquality patches for many but not all concurrency bugs.
that hfix has achieved this goal.
users can use hfix together with other auto xing tools and pick the best patches produced.
our benchmark suite does not include any deadlock bugs.
hfix currently does not handle deadlock bugs.
theoretically some deadlock bugs could be xed by moving lock acquisition statements which we leave as future work.
we should also note that the set of bugs used to evaluate hfix in this section is a subset of the bugs studied in section .
this methodology is potentially a source of threats to validity.
we decide to focus hfix on move and join x strategies exactly because of the study of those bugs.
however the exact design did not target any speci c bug.
we have tried our best to make hfix algorithm generally applicable.
another potential threat to validity is that for big multithreaded software it is infeasible to prove the correctness of patched software.
following the methodology of previous work we made our best e ort in correctness checking through manual examination and anecdotal patch testing.
we are con dent in the correctness of hfix patches because of both the soundness guarantee of hfix discussed at the end of section and the similarity between hfix patches and manual patches.
just like cfix hfix takes bug report inputs which specify static program statements involved in bugs.
at run time each static statement may have multiple dynamic instances.
the current design of hfix just like cfix generates patches for all dynamic statement instances in case of av bugs and for all dynamic statement instances that match the reported callstacks in case of ov bugs.
this treatment could lead to incomplete patches for ov bugs or overly synchronized patches for ov and av bugs.
the callstacksensitive treatment of ov bugs requires hfix to conduct function cloning which may cause the resulting patches to be more complicated than necessary.
ultimately it is impossible to decide what is the best x strategy unless we know which exact dynamic statement instances are buggy.
finally hfix relies on the bug report inputs to work e ectively.
if the bug reports are incomplete or incorrect hfix cannot guarantee the quality of its patches.
fortunately as shown by our experiments and earlier work a lot of concurrency bugs can indeed be correctly and automatically detected and reported by existing concurrency bug detectors.
.
related work empirical study of concurrency bugs past studies looked at real world concurrency bugs and synchronizationrelated code changes .
they provide important guidance for concurrency bug detection.
several empirical studies have looked at concurrency bug patches but with di erent focuses and ndings from our study.
one focuses on the correctness of intermediate patches one focuses on how transactional memory might help simplify concurrency bug patches one studies patches to understand how le systems evolve .
724lu et.
al.
summarize concurrency bug patches into ve categories condition check code switch design change add change locks others .
their overall study focuses on bug understanding and we cannot directly use their results to help automated concurrency bug xing.
first that study does not provide break downs among synchronization primitives used in patches.
it does not discuss which speci c synchronization primitives are used other than locks.
second their categories are not aligned with x strategies.
for example their condition check category actually includes both bypassing cases and spin loop synchronization cases which require completely di erent techniques to automatically generate.
third they do not provide enough information for each category of patches to help understand how patches might be automatically generated.
speci cally they do not provide category break downs across di erent bug root causes they do not explain how components of a patch might be related to components of a bug report they do not discuss how many patches change sequential semantics.
another study conducted by cerny et.
al.
checked patches of concurrency bugs in linux device drivers.
comparing our ndings with theirs there are both commonalities and di erences between concurrency bug patches in userlevel applications and kernel code.
for examples there are similar portions of concurrency bugs xed by existing synchronization operations move s adding lock synchronization add lock and bypassing respectively in both user level applications and kernel.
on the other hand there are many kernel level bugs xed by atomic instructions and synchronization upgrading which are rare in user level applications there are many user level bugs xed by data privatization bug tolerance and thread create join synchronization which are rare or not mentioned in the kernel study.
furthermore with a di erent x framework in mind their study does not tie x strategies with bug root causes and hence cannot directly guide cfix hfix style bug xing.
fixing general software bugs many techniques have been proposed to automatically x general bugs .
since they neither leverage unique features of concurrency bugs nor assume knowledge about concurrency bug reports they cannot be directly applied for concurrency bugs.
interestingly our study shows that a non negligible portion of concurrency bug patches actually do change the sequential computation semantics.
therefore future research can leverage these general techniques to help generate semanticchanging concurrency bug patches.
past work has studied real world patches of general bugs to guide bug xing .
without targeting concurrency bugs the ndings do not directly guide concurrency bug xing.
note that since there are much fewer concurrency bugs that are clearly documented studies for general bugs and patches usually check many more samples than studies for concurrency bugs.
for example the main bug set used in this paper comes from lu et.
el.
.
containing around non deadlock real world concurrency bugs it is already among the largest concurrency bug study.
concurrency bug xing here we focus on techniques that have not been well discussed.
concurrencyswapper and conrepair are designed for xing concurrency bugs in linux device drivers .
di erent from many previous techniques they could x a bug by reordering statements similar with the move strategy in hfix.
however due to the di erent design goal their techniques are di erent from hfixand cannot be applied to bugs handled by hfix.
speci cally they do not use an atomicity violation or order violation bug report as input they try all possible statement reordering within basic blocks they rely on model checking.
they are evaluated on simpli ed skeleton programs hundreds of lines of code written in a simpli ed language which supports a subset of c. even the simpli ed bug could takes minutes to x. the simpli ed language provides atomic and await constructs but not explicit locks condition variables threadcreate joins etc.
although inspiring at this point this technique cannot handle concurrency bugs in large software like the ones hfix targets.
.
conclusion automated bug xing is both challenging and important.
many automated xing techniques have been proposed recently for concurrency bugs.
this paper provides an in depth understanding of this research direction through a thorough study of manual patches for real world concurrency bugs.
our study provides both endorsement for existing techniques and actionable suggestions for future research to further improve the quality of automatically generated patches.
our design of hfix leverages some of these ndings and our evaluation shows that hfix can indeed produce high quality patches for many real world concurrency bugs in large applications.
we believe future research can further improve the quality of auto patches following the guidance provided by our patch study and extending hfix.
.