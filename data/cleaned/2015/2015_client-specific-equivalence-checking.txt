client specific equivalence checking federico mora univ.
of toronto toronto canada fmora cs.toronto.eduyi li univ.
of toronto toronto canada liyi cs.toronto.edujulia rubin univ.
of british columbia vancouver canada mjulia ece.ubc.camarsha chechik univ.
of toronto toronto canada chechik cs.toronto.edu abstract softwareisoftenbuiltbyintegratingcomponentscreatedbydifferentteamsorevendifferentorganizations.withlittleunderstanding of changes in dependent components it is challenging to maintain correctnessandrobustnessoftheentiresystem.inthispaper we investigate the effect of component changes on the behavior oftheir clients.
we observe that changes in a component are often irrelevanttoaparticularclientandthuscanbeadoptedwithoutanydelaysornegativeeffects.followingthisobservation weformulate the notion of client specific equivalence checking cse and develop an automated technique optimized for checking such equivalence.
we evaluate our technique on a set of benchmarks including those from the existing literature on equivalence checking and show its applicability and effectiveness.
ccs concepts software and its engineering software evolution dynamic analysis keywords software change equivalence checking symbolic execution acm reference format federicomora yili juliarubin andmarshachechik.
.client specific equivalencechecking.
in proceedingsofthe 201833rd acm ieeeinternational conference on automated software engineering ase september montpellier france.
acm new york ny usa 11pages.
introduction software systems are often composed of multiple related but independently developed components.
specifications of such components are usually limited to the description of their apis.
yet even upgrades that do not alter apis can hinder the stability of dependentcomponents .thus dealingwithcomponentupgrades becomes a time consuming task.
this paper addresses the problemby investigating the impact of a change to a component which we refer to as a library on its downstream consumers which we refer to as clients .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn .
client1 int x if x return x else return lib1 x a client1.1int client2 int x if x lib2 x return x else return lib2 x d client2.
1int lib1 old int x return x b lib1 old.1int lib2 old int x return x e lib2 old.
1int lib1 new int x if x return else return x c lib1 new.1int lib2 new int x return x f lib2 new.
figure two client library pairs illustrating cse.
several existing techniques such as moddiff rvt symdiff and r ve can be used for validating behavioral equivalence between two versions of a program or for identifying the precise set of changes between them.
yet these equivalence checkingtechniquesdonotexploitthe usagepattern ofaparticular library component within its client.
we argue that the equivalence checking problem becomes more tractable when the usage pattern isconsidered.inparticular reasoningaboutalibraryupdatewith respecttoitsimpactonan unmodified clientenablesustoproduce a highly efficient and accurate analysis.
ourpreliminaryanalysisof66real lifeclientsoffourlargeopensourcelibrariesshowedthat in71 ofthecases thebehaviorofthe clientcomponentiscompletelyunaffectedbyacommittooneofits libraries seesec.
2formoredetails .toillustrate fig.
1showstwo simplified client library pairs namely client1which depends on lib1 figs.1a c and client2whichdependson lib2 figs.1d f .each of the libraries has two versions old and new for simplicity weassumethatallvariablestakearbitraryinputvaluesfromthe unboundedintegerdomain sotherearenooverflowsorunderflows.
forbothclient librarypairs thechangesin thelibrariesdoaffect howthelibrariesbehave butdonotaffecttheclients functional behaviors.
for instance even though lib1 new returns different values for inputs lesser than compared to lib1 old the behavior ofclient1remainsexactlythesamebecauseofthewayitcallsthe library.
we say that the two versions of the libraries are equivalent with respect to this client.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france federico mora yi li julia rubin and marsha chechik in this paper we provide a method for the effective checking of aspecialcaseofequivalenceproblems whethertwolibrarycomponentsareequivalentwithrespecttoaparticularclient.weformalize the notion of client specific equivalence cse and provide implementation forefficiently establishingcse.
morespecifically this paper contributes empirical evidence for the prevalence of library changes that do not affect individual clients and con secutively for the applicability of our approach in practice a genericframeworkforcheckingcsewithaneffectiveimplementationbasedonsymbolicexecution clever and anempirical evaluation of clever versus state of the art equivalence checking tools.
clever inherits the pitfalls of symbolic execution and the current implementation is limited to integer data types.
the rest of the paperis structured as follows.
sec.
2describes a preliminarystudyweconductedtoassessthepracticalrelevance ofthecseproblem.sec.
3presentstheoverviewofourapproach onsimpleexamples.sec.
4fixesnotationandprovidesnecessary background.
we formally define our client specific equivalence checking framework in sec.
.i ns ec .
we describe our implementationandevaluateitseffectiveness.relatedworkisdiscussedin sec.
.s ec .8outlines possible future directions and concludes.
applicability study inthissection weassessthepracticalrelevanceofthecseproblem via manualanalysis of 66client library functionpairs.
wefound thesepairsbysearchinggithubforpopularprojectsthatprovide functionality to other projects libraries .
we then identified signaturepreservingcommitsthatmodifythesemanticsofalibrary method and checked how these modifications affect the clients.
the library functionscome from popularopen sourceprojects delorean openssl linux and gmp.
the first three projects have been starred on github over and times re spectively while gmp which is not hosted on github has been underactivedevelopmentforover25years.sixoftheclient library function pairs are written in python and the remaining in c.the automatedanalysis ofthe pythonexamples isdiscussedin sec.
.
.
here we briefly describe the libraries and clients.
delorean.
init delorean .
thedelorean.
init libraryfunction receives two parameters datetypeandtimezone and returns a delorean object that provides users with the datetime manipulation functionality.
the behavior of the constructor is entirely defined by the type of arguments it receives.
that is all conditionalsbranchbasedonthetypeof datetime andtimezone.thereare twochangesofinterestforthislibrary 679596a 064bc8d .both changes which concernthe settingof aninstance variable tzinfo timezone info occur inside a check for timezone anddatetime beingnone the latter change occurs inside an additional check for timezone being of type tzinfo.
we found three client functions and analyzedthemwithbothlibraryupdates.allsixpairsareunaffected bythelibraryupdatesbecausetheycallthedeloreanconstructor with values of datetime o rtimezone that avoid the change.
bn is prime fasttest ex openssl .
the library bn is prime fasttest ex receivesfourparameters aninteger a anintegerflag do trial division and two structs used for call back procedure and 1full study details available at that are irrelevant to the change.
the function aims to return if ais prime and otherwise.
do trial division specifies whether the function should attempt to divide aby a constant list of small primes.
the change of interest 6e64c560 fixes a bug in which the original function considered small primes as composites because they are evenly divisible by a prime themselves .
after thecommit aptlytitled smallprimesareprimestoo thefunction checks that a candidate composite is not in the list of small primes.
wefound10uniqueclientsforthislibrary fiveofthemcall bn is prime fastest ex withdo trial division avoiding the change.
rsa check key openssl .
thersa check key function takes inapointertoarsakeyanddecidesitsvalidity.rsakeysarecom posedoffiveintegerfields p q n e andd.themodificationthatwe considered 534e5fa adds a check that returns bad key if any of these five components are null.
we found clients that are unaffectedbythislibrarychange.24oftheseclientsconstructanrsa key by calling either pem read rsaprivatekey evp pkey get1 rsa orrsa generate key andthen call rsa check key withthis key.
according to the documentation these three helper functions successfullypopulatethersafieldswithnon nullvaluesorreturnnull.additionallytherearethreeclients fbf15c7 thatattempted to access the fields before calling rsa check key.
the change does notaffecttheseclientsbecausetheywillcauseasegmentationfault before calling the library in the cases relevant to the change.
we alsofoundfiveclientsthatareaffectedbythischange.theseclients receive the rsa key as an input parameter or use an unknown functiontogenerateit e.g.
parse pk file dudders crypt openssl.c and then call rsa check key.
gcd linux .
the linux project s gcdfunction calculates the greatest common denominator of two unsigned integer values using the standard euclidean algorithm.
the original implementation of this function was vulnerable to division by zero.
to circumvent thisissue an update e968756 was made to check that the smaller of the two input values is not zero.
we found clients for this librarywithinthelinuxprojectitself.ofthese threeareunaffected by the change.
these clients either check that the inputs to gcd are non zero directly or use provably strictly positive values.
the remaining eight clients call the gcdfunction with values set by parameters and so may be affected by the change.
mpf get d 2exp gmp .we also considered the function mpf get d 2exp.
fora partialcodelisting seefig.
.
thischange affects thesignof thereturnwhentheinputis negative.wefoundseven unique clients six of which were unaffected by the change.
three of these six unaffected clients did not use the returned double one alwayscalledthelibrarywithpositivevalues andone shownin fig.3a changed the sign of the return when necessary.
the one client affected by the change shown in fig.
3b calls a function that is undefined on negative inputs with the result returned by mpf get d 2exp.
summary.
table1summarizestheresultsofouranalysis listing the overall number of clients of each library that we considered andthenumberofwhichhavebeenaffectedorunaffectedbythe corresponding change.
for of the cases considered clients remain unaffected by the changes to libraries.
we thus conclude that the problem we are trying to address is of practical relevance.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
client specific equivalence checking ase september montpellier france double mpf get d 2exp signed long int expptr mpf srcptr src mp size t size abs size mp srcptr ptr int cnt double d size siz src if unlikely size expptr return .
ptr ptr src abs size abs size count leading zeros cnt ptr cnt gmp nail bits expptr exp src gmp numb bits cnt return mpn get d ptr abs size abs size gmp numb bits cnt d mpn get d ptr abs size abs size gmp numb bits cnt return size ?d d figure simplified patch 17323from the gmp library.
1double f mpz poly eval horner d 2exp long exp f mpz poly t poly double val ... res mpf get d 2exp exp output work around bug in earlier versions of gmp mpir if mpf sgn output res .
res res ... a client function f mpz poly eval horner d 2exp from the flint library .
1real log real real x double d double ln app signed long int exp d mpf get d 2exp exp x.get mpf t ln app double exp log .
log d return ln app b client function log real from the mpack library .
figure3 anupdateandtwosampleclientsofthe mpf get d 2explibrary function.
overview inthissection wegiveanoverviewofourapproachfordetermining equivalences of libraries with respect to a particular client.
we use the examples in fig.
1to illustrate the approach these examples abstract the patterns observed in the applicability study of sec.
.
example .
.
fig.1ashows the source code of a client program figs.1band1cshow the two versions of a library on which this client could depend.
the change introduced in the new version isanif statementwhichsplitsthesingleprogrampathoftheold versionintotwo whentheinputvalueisgreaterthan10andwhen itisnot.inthisexample thebehaviorof lib1 oldandlib1 new istable results of the applicability study.
project library function clients affected unaffected delorean delorean delorean delorean openssl bn is prime fasttest ex openssl rsa check key linux gcd gmp mpf get d 2exp differentforany input x the oldlibrarywill return x and the new library will always return a constant .
yet the two library versions are equivalent in the eyes of client1because the library is never called with x lines in fig.
1a .
thus the change inlib1 new is never exercised.
in fact the two library versions are conditionally equivalent underthe condition x and both returnxforanygiveninput x.sincelib1isonlycalledbytheclient under sucha condition line 5in fig.
1a we say that thatlibrary versions are client specific equivalent w.r.t.client 1. example3.
.
fig.1dshowsanotherclient client2.figs.
1eand1f showtwoversionsofthelibrarythat clientcalls.theonlychangeto theoldlibraryversionisthereplacementof x by x .although thetwolibraryversionsareobviouslynotequivalent thedifference does not lead to a different client behavior lib2 oldalways returns avaluewhichissmallerthantheinput x leadingclient2intothe if branch lines2 3infig.
1d .astheresult theinputvalue xis returned by the client.
the new version of the library lib2 new returns the input itself leading the execution of client2into the else branch lines in fig.
1d yet input value xis returned by client2in this case as well.
unlikeexample .
herethechangeinthelibraryisexercised by the client.
yet the two library versions are still client specific equivalent the change on the library is digested by the client so that the final output is unaffected.
the example shown earlier in fig.3afalls into the same category.
client specific equivalence cse .
in both examples changes inthe libraryprogramsdo notaffect thefinalreturn valuesofthe client.wecharacterizeclient specificequivalenceintermsofthe client sobservablebehaviors weignoretheinternalexecutionsteps and only observe the input and output values of the client.
this definition of equivalence is also referred to as functional equivalence .
checkingcse.
now wedescribeourgeneralframeworkfordeterminingclient specificequivalence.fig.
4overviewsthearchitecture oftheframework.theframeworkacceptsasinputaclientandtwo versions of a library.
we assume that library interfaces remain unchanged since the change can be easily caught by a compiler.
the framework smain components are a behavior explorer and anequivalenceverifier.thebehaviorexploreranalyzesbehaviors ofthelibrariesintermsofhowtheyareused andthenitgenerates equivalence assertions that must be satisfied for the libraries to be cse.
the equivalence verifier checks the libraries against theequivalence assertions and either declares them to be equivalent authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france federico mora yi li julia rubin and marsha chechik client lib lib behavior explorer equivalence verifierequivalence assertions figure architecture of the client specific equivalence checking framework.
or provides a counter example which demonstrates the behavioral differences observed in the client.
incremental lazy exploration.
comparing examples .1and .
we identify two types of cse inactive cse that holds whenchangesarenotexercisedbytheclientand activecse thatholdswhenchangesareanticipated exercised andspecially handled by the client.
the biggest distinction being that to show inactivecse onedoesnotneedtoreasonaboutthesemanticsof thelibraries apurelysyntacticcheckonallfeasiblelibrarypaths suffices to confirm that no change gets exercised.
on the other hand toclaimactivecse oneneedstoanalyzetheinput output relations of the libraries and their interplay with the client.
withthisinsight weproposeacsecheckingapproachcalled incremental lazy exploration which prioritizes establishing proof arguments for inactive cse while keeping the number of paths explored to a minimum.
it helps to eliminate the main source of inefficiencyofthegenericcseframeworkdescribedabove fully exploringboththeclientandlibraryprogramsbeforegenerating equivalence assertions based on the explored behaviors.
we call a path containing a call to the library an active path.
whenever an active path is explored we effectively obtain a client contextfor the library call a condition over client inputs under whichthepathistaken.withthiscontext weperforma parallel exploration of both library versions under the given context by shadowing one with the other.
this is done by simultaneously examiningthesamepathsinbothversionswithsymbolicexecution .thisstepproducesasetoflibrarypathpairs andforeach pair two checks are performed isthe path exercising changed addedandremoved code?
doesaconcretesimulationonthe pathpairrevealacounterexample?bothofthesechecksarerelativelycheap check canimmediatelyrevealacounterexamplefor cse and if check fails for all client contexts then we can alsoconcludecsewithoutreasoningabouttheactualsemanticsof the paths explored.
inexample .
webeginbyexploringtheclientandskipthefirst pathwhichdoesnotinvolvelibrarycalls row1infig.
5a .then weexplorethesecondpath showninrow2 andperformaparallel explorationonbothlibrarieswiththeclientcontext x .the first rows of figs.
5band5cshow the only pair of library paths explored.wethenperformthefirstcheckandrealizethatthechange isnotactiveonthispath therefore uponfinishingthelibraryexploration wecanconcludethatthelibrariesareequivalentunder thecurrentclientcontext.sincenootherclientpathsremain we identifythecaseofinactivecse.weevaluatetherelativeefficiency of incremental lazy exploration in sec.
.partition effect explored active 1x 10ret x yes no x ret lib1 x yes yes a client1.
partition effect explored active 1true ret xyes no b lib1 old.
partition effect explored active x ret xyes no 2x 10ret 9no no c lib1 new.
figure paths explored for example .
.
background in this section we provide the necessarybackground on program analysis that will be used in the remainder of the paper.
programs.
werestrictthepresentationtoasimpleimperativeprogramminglanguagewherealloperationsareeitherassignments assumptions or function calls and all variables range over integers.
we assume that the type and number of input and output parameters are statically known for each function.
aprogram p fc fl i consistsofaclientandasetoflibrary functions suchthattheclientcallsthelibraries.eachofthefunctions can be represented as a control flow graph l l0 lf e v wherelisafinitesetofprogramlocations withaninitiallocation l0 land a final location lf l. the set vdenotes a finite set of variables and e l lis the set of control flow edges where isthesetofoperationsinstantiatedbyoneofthefollowing constructs an assignment v exp wherev v an assumption of the form assume b where bis a boolean expressionoverprogramvariables v callstolibraryfunctions e.g.
vecx f vecy where vecxand vecyare vectors of variables in vandfis a function in fl i. we write l l primeinstead of l l prime eto denote an edge fromltol primeintroducedbyanoperation .weassumethatall executions of pterminate but this assumption does not prevent p from possibly having an infinite number of paths such as in the case where there is a loop whose number of iterations depends on an unbounded variable.
functionsummaries.
givenaprogram pandafunction fi the function summary offiis a first order formula iover vectors ofvariables vec vec suchthat vec denotesfi sinputparametersand vec denotes its outputs.
a function summary is completeif it is defined for all possible inputs.
we write p to denote the program with everyfunctioncall vecx fi vecy replacedby assume i .in otherwords p islikepbutwitheveryfunctioncall fireplaced by its function summary.
for example the function summary for lib1 new in fig.1cis lib1 prime ite x ret ret x whereiteistheif thenelseoperator xistheinputparameter and retistheoutput.
lib1 prime is also complete since it covers both the case when x and whenx .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
client specific equivalence checking ase september montpellier france llbracket rrbracket v mapsto z mapsto v mapsto z llbracketx exp rrbracket v v assignment llbracketassume b rrbracket v braceleftbiggvifv b otherwiseassume llbracket vecx f vecy rrbracket v llbracketassume f rrbracketvfunction call figure semantics of operations.
concrete abstract andobservableruns.
weinterpretsemanticsofprogramexecutionsusingalabelledtransitionsystem lts s s0 sf foreachcontrol flowgraph where s l v mapsto z isasetofprogramstates and s0 sandsf saretheinitial andfinalstates respectively.let v v mapsto zbeavaluationofthe variables at state s. we write l v l prime v prime to represent the transitionfromstate stos primeifl l primeand v v prime llbracket rrbracket definedinfig.
.
aconcrete run s0 0 k skof an lts is an execution path that starts with an initial state.
the set of all concrete runs iswrittenas .anabstractrun isasetofconcreteruns i .
let mapsto beanobservationfunction whichmapsaconcrete run to anobservable run hiding unobservable states and operations.
recallclient1shown in fig.
1a.
with the values of xandret writtencompactlyasatuple x latticetop x x isanabstract run which subsumes all concrete runs going through the if branch ofclient1 lines2and3 where latticetopdenotesanuninitializedvalue.
by hiding the values of x the observable part of the same runs can be written as simply latticetop x .
symbolicexecution.
symbolicexecution usessymbolicvalues as input instead of the actual data and represents the values of program variables as symbolic expressions.
as a result output values computed by the program are also represented as symbolic expressions.the stateofasymbolically executedprogramincludes thesymbolicvaluesofprogramvariables apathconditionanda program location.
the path condition is a boolean formula over the symbolic inputs corresponding to the accumulated constraints along the path which are satisfiable if and only if the associatedpath is feasible.
a symbolic path corresponds to an abstract runof the program which can be instantiated to a concrete run by computing a satisfying model of the path condition.
our approach in this section we first formalize our client specific equivalencechecking framework and then report on a specific instantiation which leverages common patterns observed in inactive cse cases tospeedupthe checkingprocess.
.
the cse checking problem problem definition.
letfcbeaclientprocedure andlet fland f prime lbe two versions of a library procedure such that they share the same signature and can be called interchangeably from fc.
let be an observation function which maps a concrete run to an observable run only considering the input and output values of theclient.behav f denotesthesetofall concrete runsofaprocedure f. definition .
client specific equivalence .
we sayflandf prime lare client specificequivalent w.r.t.fcand denotedby fl fc f prime l if and only if behav fc and prime prime behav fc f prime l are equal.
client specific equivalence of two library versions is defined in termsoftheobservablebehaviorsoftheclient.twoconcretepaths and primeareequivalentiftheyfollowtheexactsamesequenceof state transitions.
two procedures fandf primeare considered equivalent when their sets of concrete runs are equal.
we say that the observablebehaviorsof fandf primeareequivalentiftheybothhave the same set of observable runs defined by .
finally two libraries flandf prime lareclient specificequivalentwhenthe observablebehaviors of the composed programs fc andfc f prime l are equivalent.
.
checking functional cse in most cases there are infinite number of concrete runs and thus checkingclient specificequivalencebyenumeratingallrunsofa client composedwithbothlibraries andexplicitlycomparingthem against each other is often infeasible.
we show that it is possible toreduce thecsecheckingproblemtothe validityoffirst order formulas.
we begin by describing a general algorithmic framework clever 2for checking functional cse using symbolic execution.
theinputstothealgorithmareaclient fc andtworelatedlibraries sharing the same interface flandfl .
behavior exploration.
first clever explores behaviors of the client through symbolic execution without considering the bodiesofthelibraries.itdoessoviastandardpathexplorationwhile replacing each library call with an uninterpreted function placeholder.
focusing only on the client program reduces the number of paths and allows for modular checking of libraries.
the abstract runs returned from symbolic executing the procedure can be repre sentedasasetof partition effectpairs namely pci obi where pcirepresents a path constraint andobistands for an observable effect constraint for a particular path i. the path constraint is a conjunctionofrelationalexpressionsdefinedoverconstantsand inputvariables.theeffectconstraintisaconjunctionofexpressions whichequateaspecialreturnvariable ret toexpressionsover constants and input variables.
representing effects as symbolic expressionsoverinputvariablesallowsustoreasonaboutmultiple concrete runs together.
the set of abstract runs returned from exploring a procedure is itssummary.summariescanbe incomplete duetothelimitationsin symbolic execution.
for example with the presence of unbounded loops it is only possible to get paths of limited length.
equivalence assertion generation.
letthesummariesfortwo library versions produced in the previous step be behav fc andbehav fc f prime l .
clever uses them to generate an equivalence assertion a first order formula with uninterpreted functions as placeholders for the libraries.
the formula serves as a mutual specification forthetwolibraries theobservablebehaviors of the client are equivalent if and only if the library bodies respect 2clever stands for client specific equivalence checker.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france federico mora yi li julia rubin and marsha chechik theequivalenceassertion.followingthenotionof logicalmethod summary theobservablebehaviorsoftheclientinthiscase can be encoded as a disjunction over all symbolic paths and the resulting equivalence assertion is parenleftbig logicalordisplay.
i behav fc pci obi logicalordisplay.
prime i behav fc f prime l pc prime i ob prime i parenrightbig wherepciandobiarepathandeffectconstraintsof i respectively.
equivalenceverification.
finally isverifiedagainstthelibrary implementations flandf prime l. the verification task can be delegated to a theorem prover based on the procedure summaries of the libraries.wefirstgenerateproceduresummariesforbothlibrary versions.thesummariesfor flandf prime larethenusedtoconstrainthe uninterpretedfunctionplaceholdersintheequivalenceassertion .
finally we check the validity of composed with the library summaries.
if a violation is found we report a counterexample otherwise if the generated summaries are complete we proved functional cse.
proposition5.
.
givencompletesummariesof fc flandf prime l the equivalenceassertionisvalidifandonlyif flandf prime lareclient specific equivalent w.r.t.
fc.
proofsketch.
sinceallsummariesarecomplete anyconcreterunof theclientisamodelofthepathconstraints.fromdef.
.
fland f prime lare cse since the equality between concrete runs is established by the logical equivalence between composed summaries.
.
incremental lazy exploration it may not always be possible to compute complete summariesof client and libraries due to limitations of symbolic executiontechniques.
we now present an optimized behavior exploration strategy incrementallazyexploration whichprioritizesestablishing proofargumentsfor inactivecse seesec.
anddisprovingcse throughearlydiscoveryofcounterexamples.thisallows ustospeed upthecsecheckingprocessandobtainpartialresultsevenifthe path exploration of some functions is not exhaustive.
apseudo codeimplementationof cleverwithincrementallazy exploration is given in fig.
7and the workflow for this technique infig.
.theinputstothealgorithm asbefore areaclient fc and two related libraries sharing the same interface flandfl .
this time however weareonlyinterestedinexploringandreasoning about active paths.
we call a summary consisting of only active paths anactive summary.
the while loop on line 3drives the lazy exploration its body is executed until the client is fully explored.
each iteration takes apartition effectpair p fromthe client ssummaryandprocesses the libraries modulo p resulting in behavp fl andbehavp f prime l respectively.ifthesesummariesexercisethedifferenceinthelibrary versions checked on line then clever does two things.
first itfindsaconcretevaluethatsatisfies pandcheckswhetheritisa counterexample.ifaffirmative cleverreportsthat flandfl ar e notclient specificequivalent.second cleverupdatestheactive summaries.
if no active paths have been found after the clienthas been fully explored clever reports equivalence.
otherwise cleverusestheactivesummariestogenerateanassertion line and then check it line .require fccallsflandf prime linterchangebly ensure iffl fcf prime lthen returns true else returns false procedure clever f c fl f prime l a initial initialize active summaries of fc fl fl whilep explore f c do behavp fl explore f l vecx vecx p behavp f prime l explore f prime l vecx vecx p summaries mod p ifpuses change then ifconcrete value for pis a counterexample then returnfalse end if a.update p behavp fl behavp f prime l end if end while ifempty a then return true assertgen a ifverify fl f prime l then return true else return false end procedure figure7 algorithmforcheckingcsebasedonsymbolicex ecution and lazy path exploration.
context specific parallel library exploration is change active?
is concrete cex?yesclientincremental client explorationclient contextlib lib cexno yesnoactive paths empty non emptyinactive cse verify figure clever workflow with incremental lazy explo ration.
proposition5.
.
letcompleteactivesummary meanthemaximal active subset of a complete summary.
given complete active summariesof fc flandf prime l the equivalenceassertion isvalid ifand only ifflandf prime lare client specific equivalent w.r.t.
fc.
proof sketch.
suppose the equivalence assertion defined over complete active summaries is valid and the libraries are not clientspecificequivalent.byproposition .
thevalidityoftheequivalence assertion implies that the observable part of the active paths areequal.hence theremustexistaninactivepathwhichcannot bematched.thiscontradictsthefactthatinactivepathdoesnotgo through any change and therefore stays the same in both versions.
the other direction is similar.
finally ifwefailtodiscovercounterexamplesorfullyexplore all client paths with limited resources we are still able to partially prove or disprove equivalence for the considered client contexts.
a differentequivalencecheckingtechniquecanbeusedinthiscase to decide equivalence of the remaining explored contexts.
cleverexample.
wenowillustratecleverusingexample .
from fig.
.
in example .
the change is always active so we have to go through both client contexts rows in fig.
9a .
when comparing active library paths which exercise changes we opportunistically perform concrete simulation where a concrete input authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
client specific equivalence checking ase september montpellier france partition effect explored active 1x lib2 x ret x yes yes x lib2 x ret lib2 x yes yes a client2.
partition effect explored active 1true ret xyes no b lib2 old.
partition effect explored active x ret xyes no 2x 10ret 9no no c lib2 new.
figure paths explored for example .
.
satisfying the current client context is used to replay on the paths from both library versions.
in this example we might use x 0a s aconcreteinputwhichturnsoutnottobearealcounterexample.
after failing to quickly find a counterexample we store the active path for later use and return to search for a new path in the client.
inthecaseof client2 thenextpaththatwefindisshowninrow of fig.9a.
having completed the exploration of the client we generate anequivalence assertioninvolving onlythe activepaths collectedsofarandtrytoproveitsvalidity.thissucceedsandthus the case for active cse is identified for client2.
evaluation in this section we describe our implementation of clever report on an empirical evaluation and present a case study.
we aim to answer the following research questions rq1 how effective is clevercomparedtothestate of the artequivalencecheckingtechniques for checking cse?
rq2 how significant is the impact of incrementallazyexplorationoneffectivenessof clever?
rq3 can clever be effectively applied to real software projects?
.
implementation our implementation3of clever is built on top of pyexz3 a symbolic execution engine for python written in python and pysmt apythoninterfacetosmtsolvers.asaconsequenceof this combination our tool is currently limited to integer reasoning.
thefourkeycomponentsofoursoftwarearesummarygeneration support for uninterpreted functions exploration modulo calling context and parallel exploration.
summarygeneration iscrucialtoclever sequivalenceassertion generation.
this feature symbolically executes programs returning a set of partition effect pairs one for each explored symbolic path.
supportfor uninterpretedfunctions enablesthetop downgenerationofsummariesbyallowingclientexplorationirrespectiveofa particular version of its library.
whencleverencountersacalltoalibrary itusesthearguments andcurrentpathconditionasacontextwhenexploringthetwoversions ofthelibrary.
our explorationmodulo callingcontext feature collectsand subsequentlyusesthisclientcontext.
finally the parallel exploration feature allows clever to explore both versions of thelibrarywhilemonitoringequivalenceanddiscoveringpotential 3code is available at execution but incorporates summary generation directly.
finally we implemented a driver which connects the above features logs execution information and provides an interface for running experiments.
our implementation changed files in the pyexz3 project modifying approximately lines of code.
pyexz3wasnottheonlychoiceofsymbolicexecutionengine but its focus on extensibility and its combination of existing features made it a natural choice.
we also considered klee which canprocess cprograms andimplements shadowsymbolic execution .
however klee does not support uninterpreted functions or summary generation and was not as amenable to the necessary modifications as pyexz3.
.
comparison with existing tools in this section we report the results of comparing clever with well established equivalence checking tools.
existingtools.
wecomparedclever withfourstate of the art toolsinequivalencecheckingandregressionverification rvt symdiff moddiff and r ve .
all of these tools can beusedtopr o v e partialequivalence oftworelatedprograms i.e.
producing the same outputs for all possible inputs given that both programsterminate.therefore technically they canalso beused to check functional cse by considering the client library pair asa whole.
however since they are not designed for checking cse specifically they would not be able to leverage the fact that the clients areunmodified andthe particular usagepatterns observed in the clients.
a more detailed discussion of these approaches is found in sec.
.
subjects and methods.
we evaluated all tools on benchmarks witheachbenchmarkconsistingofapairofprogramsbeforeand aftersomechangesinthelibrary.weused23benchmarksfromthe moddiff suite in c .
we excluded six moddiff benchmarks that do not perform updates to libraries.
some of the moddiff benchmarksareindexed e.g.
loopmult5 isrelatedto loopmult10.w e augmented the suite with additional benchmarks that continue theseindexedpatterns.21benchmarksareexamplesextractedfrom programs that we inspected during the applicability study in c or python and examples we constructed ourselves in python .
in total pairs were equivalent and inequivalent.
to run the different tools on the benchmark we translated all of theprogramstoc requiredbyrvt moddiff r ve andpython required by clever manually and to boogie required by symdiff with smack .
weperformedtheexperimentsonanintelcorei74.00ghzcpu with16gbofmemoryrunningwindows10withcygwin.foreach benchmark we set a timeout of seconds.
results.
table2showstheresultsofcomparingcleverwiththe other four state of the art equivalence checking tools.
the execution times are measured in seconds and the winner for eachbenchmark is in boldface.
clever solves the biggest number of benchmarks and outperforms all of the other tools in the majority ofthecases.forr ve manyinstancesthattimeoutonourmachine usingthedesktopdistribution terminateinsecondswhenrunusing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france federico mora yi li julia rubin and marsha chechik table run time in seconds of clever moddiff r ve rvt and symdiff where indicates that the tool either times out or reports inconclusive results and indicatesan error.
benchmarks clever moddiff r ve rvt symdiffequivalentdivide .
.
factorial .
fib .
get sign2 .
.
is prime1 .
.
is prime3 .
.
ltfive .
.
multiple .
.
order .
.
.
pos2 pos3 .
onen2 .
.
onebound .
.
.
add .
.
.
.
const .
.
.
.
loopunreach2 .
.
loopunreach5 .
.
loopunreach10 .
.
loopunreach15 .
.
loopunreach20 .
.
unchloop .
.
non equivalentdivide2 .
factorial .
.
fib .
get sign .
.
is prime2 .
.
loopunreach2 .
.
loopunreach5 .
.
loopunreach10 .
.
loopunreach15 .
.
loopunreach20 .
.
odd pos onen1 .
the online version of the tool.
to optimally capture r ve s capabilities wereportcategoricalresultscollectedfromrunningtheonline version termination in and seconds and non termination in over seconds or returning unknown .
since rvt and symdiff are not designed for disproving equivalence wedidnotincludetheminthecomparisonfornon equivalent cases.similartotheexperimentresultsreportedin rvtand symdiffonlysolvedfourandtwobenchmarks respectively.symdiff crashed with an unhandled exception for pos2while moddiff reportedanincorrectresultfor divide fib divide2 and onen1 all markedby .r veperformswellonnon equivalentcasesand struggles on proving equivalence for benchmarks which requirenon trivial relational invariants e.g.
divide factorial ltfive etc.
therearealsoafewcases including pos2 odd andpos thatnotool couldsolvewithinthegiventimelimit.thereasonwasthatthey all have an unbounded loop with a non trivial loop condition.
p a t h stime s clever moddiff figure10 cleverandmoddiffexecutiontimesversusnumber of paths over fifteen client specific equivalent probleminstances.
looking at the equivalent cases clever performed significantly betterthantherestofthetoolson divide is prime1 pos3 loopmult15 andloopmult20 which demonstrate the benefits of early detection of inactive cse.
a common trait of these benchmarks is that the analysisofalong runningloopinthelibrarycouldbeavoidedif thetop down analysis considered the specific range of input values coming fromthe client.for instance bothof thelibrary functions intheloopmult examplesbothcomputetheproductoftwoinput parameters but in slightly different ways.
in oder to prove thatthey are equivalent a bottom up analysis of rvt and symdiff wouldneedtoestablishanon linearrelationalinvariantbetween thelibraryfunctions namely ret x y ret prime y prime x prime wherex y x prime andy primeare the input parameters.
yet clever only needs to consider the few cases defined by the particular inputs provided by the clients.
for the non equivalent cases clever was almost always the best among the four.
this shows the advantages of the parallelexploration feature which disproves equivalence by discovering counterexamples early on.
overall clever and moddiff were comparable in most of the cases and the differences in their run times were often under asecond.
in all of the cases where this difference was larger the performanceof cleverwassuperior.this benefitisillustratedin fig.10which plots the execution times of clever and moddiff on the set of equivalent loopmult instances.
the first five instances loopmult weredirectlytakenfromthemoddiffsuite.
we extended the pattern to analyze the growth of the execution times.fig.
10showsresultsconsistentwithtable .whentheinstancein questionissimple as measuredinthe numberofpaths the two tools perform similarly.
as the difficulty increases moddiff sexecutiontimegoesupsignificantlywhileclever sgrows linearly.
the non equivalent loopmult instances show a similar but more pronounced difference.
this is because clever is able to ignore most library paths due to the client usage of the library.
answertorq1 yes thecomparisonresultssuggestthatour technique is effective and efficient on deciding client specific equivalence compared with the state of the art.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
client specific equivalence checking ase september montpellier france time s by clever ntime s taken by clever100101102 path by clever n path by clever time paths figure11 comparisonoftimeandnumberofpathsbetween clever n and clever.
.
effect of incremental lazy exploration to evaluate the effect of incremental lazy exploration we created a versionofourtoolwithoutthisfeature namedclever n andcompared it to clever on the set of benchmarks described in sec.
.
.
fig.11showstheresultsovertwometrics thetotalnumberof paths explored and executiontimes.
the axes are logarithmically scaled.
each blue circle shows the comparison of the two tools in terms of the number of paths explored for a particular benchmark the top and right axes represent the results by clever n and clever respectively.
there are more circles below the diagonalline because clever is often able to ignore paths in the libraries when proving equivalence and paths in the client when finding acounterexample.therearesomecirclesabovethediagonalline becausetwodifferentcallingcontextscanleadtotheexplorationofthesamelibrarypath andbecausecleverdoesnotavoidexploring the same path multiple times at the time of writing .
similarly each red cross shows the comparison of clevern and clever in terms of their execution time.
the bottom and left axes represent the running time of clever n and clever respectively.
again the crosses tend to be below the diagonal suggesting that clever outperforms clever n in most of the cases.
the crosses lying on the right axis represent benchmarks where cleversucceededandclever nwasunabletoterminate.these includemostofthe loopmult examplescomingfromthemoddiff benchmarks.
exploiting the specific client contexts clever avoids exploringtheexponentialnumberofpathsforthewhileloopsin the libraries and thus saves the execution time.
answer to rq2 incremental lazy exploration has a positive andpronouncedimpactontheeffectivenessof cleverboth in terms of running time and the number of paths explored.
.
case study insec.
wedescribedsixpythonclient libraryfunctionpairs.in this section we report on the experience applying clever to these pairs aiming to answer rq3.
second minute 3def truncate self s if s second if s second self.
dt self.
dt.replace microsecond elif s minute elif s minute ... figure example string to integer transformation for delorean.truncate.
preparation.
to prepare the examples as a valid input to clever we step made the necessary simplifications to external functions step transformed string operations to integer operations and step wrapped the client function with an entry point for symbolic execution.
we describe these in turn below.
step .to illustrate the required simplifications to external functions considerthepythondatetimefunction now .itisintended toreturnthetimeatinvocation buttoavoidspuriouscounterexamplestoclient specificequivalence wesimplifiedittoreturna fixed time.
step .we illustrate a transformation from string operations to integer operations in fig.
.
this figure shows a snippet of a delorean methodthat reasonsby caseson asingle argument and thecorrespondingtransformation.becausetheoriginalreasoning islimitedtocheckingequalityagainstconstantstringvalues we transformthefunctiontocheckintegerconstants ensuringthatthe mapping from string to integer constants is a bijection the empty string is mapped to inputs are transformed accordingly and the changes are propagated to all dependent code.
step3.wewrapclientfunctionswithanentrypointforsymbolic executionsothatallargumentsandfunctionreturnsareintegers.
the wrapping function constructs the necessary objects to pass into the client function and then deconstructs the output.
results.
sinceallsixclient librarymethodpairsareclient specific equivalent see sec.
we added modified examples intended to break the equivalence.
clever correctly classified all examples with an average execution time of .
seconds.
answertorq3 yes ourapproachcanbeeffectivelyapplied torealsoftwareprojects.however ourcurrentimplementation requires some manual program preprocessing.
.
threats to validity the applicability study in sec.
2relies on manual determination of ground truth.
to ensure internal validity we had two authors independently classify each client library function pair and a third author settle conflicting cases.
wemaintainedthreeversionsofthebenchmarksusedinsec.
.
python c boogie .toenablecross languagecomparisonsbetween the tools we limited the examples to subsets of the languages that can be trivially translated control flow integer operations and no 4all examples are available at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france federico mora yi li julia rubin and marsha chechik heap manipulations.
furthermore since all the tools assume unboundedintegers c s intdatatypecorrespondsdirectlytopython s forourcomparisons.theconversionbetweencandboogiewas done automatically using smack .
ourencouragingresultspresentedintheapplicabilitystudyin sec.
inthecomparisonsinsec.
.
andinthecase studyinsec.
may not generalize to all software projects.
yet we believe that our selection process of the sample populations used in these sections resulted in software representative of current best practice.
related work clever relates to several techniques reviewed below.
programequivalencechecking.
differential symbolic execution dse bypersonetal.
istheclosestworktoours.dseperforms standard symbolic execution on both program versions before and afterthechange andeitherreportsthatthetwoversionsareequivalent orcharacterizes the behavioral differences by identifyingthe sets of inputs that cause different effects.
it also introduced several notions of behavioral equivalence including partition effect and functionalequivalence.however thesenotionsaredefinedovera wholeprogram withoutseparationbetweenclientsandlibraries.
symdiff alsochecksforpartialequivalencebetweenpairsof proceduresinaprogram anditsnotionof mutualsummary can also be used to encode client specific equivalence.
for example symdiff implements differential assertion checking dac whichdefinesprogramequivalenceintermsofuser providedassertions.
given two program versions pandp primeand a set of assertions s.t.
all of them hold in p dac checks whether these assertions still holdinp prime.unlikedse behavioralpreservationdoesnothavetobe guaranteedacrossversions andonlyaweakerformofequivalence with respect to the assertions is checked.
in principle cse can be phrased as dac by asserting that the input output relations of theclientstaythesameevenwhenthelibrarychanges.however symdiff can only prove equivalences and not disprove them .
in addition as shown byour experiments seesec.
.
symdiffoften fails to automatically infer mutual summaries which are strong enough to conclude functional equivalence.
regression verification aims to formally prove that two programsarefunctionallyequivalent.rvt provespartialequivalenceoftworelatedprograms i.e.
thattheyproducesameoutputs for all inputs given that both of them terminate according to a set of proof rules.
recursive calls are first abstracted as uninterpreted functions and then the proof rules for non recursive functions aredischargedinabottom upfashion whichmakesitdifficultto exploit specific calling contexts for specific clients.
r ve targets programs with complex arithmetic and control flows and automaticallyprovesequivalencewhen simple couplingpredicatesover lineararithmeticexistforthetwoprograms.trostanetskietal.
recently proposed a modular demand driven approach moddiff to improve the precision and scalability of such analysis.
whenconsidering the client and library as a whole cse also falls intothe regression verification framework.
however our problem ismore specific in the sense that the change is restricted to the librarypartwhiletheclientiskeptunchanged.inaddition thereare nocircular dependenciesfromthe librariestothe client allowing us to optimize equivalence checking by exploring the programstop downwhilesignificantlylimitingthebehaviorsthatneedtobe considered.
incremental program analysis.
the work on incremental verification aims to reuse results from prior verification as programsevolve assumingthatproperties oftheclient tobeverified are given.
for example sery et al.
uses a compositional approach implemented in a tool named evolcheck to summarize the properties of each procedure and then check whether these propertiesholdfortheupdatedversionoftheprogram.chakietal.
uses state machine abstractions to analyze whether every behaviorthatshouldbepreservedisstillavailable containment andwhetheraddedbehaviorsconformtotheirrespectfulproperties compatibility .
fedyukovich et al.
offer an incremental verification technique for checking equivalence w.r.t.
program properties.
theprimaryfocusofalltheseworksisreusingpriorverification results as programs evolve while our work focuses on establishing equivalencew.r.t.aparticularclient.furthermore ourworkdoes not require specifications.
symbolic execution.
apart from dse there are a number of other symbolic execution based approaches which are related to our work.
directed incremental symbolic execution dise builds on dse by adding static impact analysis for finding possible locationswheretheexecutionmayvary.theinsightof diseisto leveragetheinformationextractedfromthecheaperchangeimpact analysistoenablemoreefficientsymbolicexecutionofprograms as they evolve.
this is similar to our optimizations of collecting activepathswhichexercisechanges makingsubsequentanalysis focused only on potentially changed behaviors.
godefroid et al.
introduced demand driven compositional symbolic execution the key novelty being compositionality the search process is made compositional and consequently exponentiallyfasterthanthenon compositionalone .althoughthese approaches do not address the problem of equivalence checking our context specific library exploration is inspired by them.
conclusion and future work in this paper we defined the notion of client specific equivalence cse andpresentedanalgorithmcalledclever whichleverages heuristics tailored for checking cse.
we implemented a prototype for clever and compared it with four state of the art equivalence checkingtoolsonasetofnon trivialbenchmarks.wealsoevaluatedourapproachonareal worldcasestudy confirmingitsapplicability and efficiency.
as future work we intend to apply clever to more diverse systems extending it to support other programming languages and language constructs such as heap manipulations.
we also intend to addsupportforfloatingpointnumbers strings andobjectscomposed of these primitives.
beyond that we are interested in exploringotherdefinitionsofequivalence suchas pathequivalence and partition effectequivalence whichgivestrongerguaranteesbut mightbemoreexpensivetocheck.finally proposingdesirablefixes for the identified client specific inequivalence is another fruitful direction.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
client specific equivalence checking ase september montpellier france