exploring regular expression comprehension carl chapman sandia national laboratories albuquerque nm usa carlallenchapman gmail.compeipei wang department of computer science north carolina state university usa pwang7 ncsu.edukathryn t. stolee department of computer science north carolina state university usa ktstolee ncsu.edu abstract the regular expression regex is a powerful tool employed in a large variety of software engineering tasks.
however prior work has shown that regexes can be very complex and thatit could be difficult for developers to compose and understand them.
this work seeks to identify code smells that impact comprehension.
we conduct an empirical study on pairs of behaviorally equivalent but syntactically different regexes using180 participants and evaluate the understandability of various regex language features.
we further analyze regexes in github to find the community standards or the common usages of variousfeatures.
we found that some regex expression representations are more understandable than others.
for example using a range e.g.
is often more understandable than a default character class e.g.
.
we also found that the dfa size of a regex significantly affects comprehension for the regexesstudied.
the larger the dfa of a regex up to size eight the more understandable it was.
finally we identify smelly and non smelly regex representations based on a combination of communitystandards and understandability metrics.
index t erms regular expression comprehension equivalence class regex representations i. i ntroduction regular expressions regexes are used fundamentally in string searching and substitution tasks such as word searching text editing file parsing user input validation and access con trols.
more advanced uses can be seen in search engines database querying and network security .
recent research has suggested that regular expressions are hard to understand hard to compose and error prone .given their frequent appearances in software source codeand the difficulty of working with them some effort hasbeen put into easing the burden on developers by providingenvironments that make regexes easier to understand.
sometools provide debugging environments which explain stringmatching results and highlight the parts of regex patternswhich match a certain string .
other tools presentgraphical representations e.g.
finite automata of the regularexpressions .
still others can automatically generatestrings according to a given regular expression or automatically generate regexes according to a given listof strings .
the commonality of such tools andtechniques provides evidence that developers need help with regex composition and comprehension.
in software engineering code smells have been found to hinder understandability of source code .
once this work was done while this author was at iowa state university.removed through refactoring the code becomes more understandable easing the burden on the programmer.
in regular expressions such code smells have not yet been defined perhaps in part because it is not clear what makes a regex difficultto understand or maintain.
this is one of the goals of this work to explore language features that impact comprehension andbegin to identify code smells in regexes.
in regular expressions as in source code there are multiple ways to express the same semantic concept.
for example theregex aa matches an a followed by zero or more a and is equivalent to a which matches one or more a .
that is both regexes match the same language but are expressed using different syntax.
what is not clear is which representation aa ora is more easily understood.
in this work we focus on identifying regex comprehension smells.
we identify equivalence classes of regex representations that provide options for concepts such as double bounds in repetitions e.g.
a a aa or character classes e.g.
.
based on an empirical study measuring regex comprehension on pairs of regexes using180 participants as well as an empirical study of nearly14 regexes and their features we identify smelly and non smelly regex representations.
for example aa is more smelly thana based on feature usage frequency in source code conformance to community standards and understandability.our contributions are an empirical study to evaluate regex comprehension with180 participants for studying regex understandability identification of five types of equivalence classes and18 corresponding representations for regular expressions and identification of smelly and non smelly regex representations to optimize understandability and conformanceto community standards backed by empirical evidence.
despite the frequent usage of regexes in source code this is the first work to explore regex comprehension.
ii.
r esearch questions in this work we use the term regex representation to refer to the syntactic expression of a regular expression.
a feature is a structural component of a regular expression e.g.
kleenestar or custom character class .
an equivalence class is a group of behaviorally equivalent regular expressions.
to explore regex comprehension we answer the followingresearch questions .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research405 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
lwb group using the abstract a where a is any pattern aa l3 aaa l2a l1 ccc group using the concrete example of and assuming an ascii charset lit group using the concrete example a and assuming an ascii charset a t1 062t4 x07 x24 x3et2 a t3 c1 a a d a c5 c4 c2 c3dbb group using the abstract pb s where b is any pattern p and s are any possibly empty prefix suffixpbb?b?sd2pb sd1 pbs pbbs pbbbsd3 sng group using the abstract s where s is any pattern ssss2 s s3s s1 s s sb ss b b ps a aa a 9a fig.
.
types of equivalence classes based on language features.
dbb double bounded sng single bounded lwb lower bounded ccc custom character class and lit literal.
we use concrete regexes along with their deterministic finite automaton dfa in the representations for illustration.
however the a s in the lwb group or b s in dbb group s s in sng group and so forth abstractly represent any pattern that could be operated on by a repetition modifier e.g.
literal characters character classes or groups .
the same is true for the literals used in all the representations.
rq1 which regex representations are most understandable?
to answer rq1 we conduct a study in which programmers are presented with a regex and asked comprehension ques tions about its matching behavior.
by comparing accuracybetween regexes that match the same language but are expressed using different representations e.g.
tri and tri a b c d e f we can measure understandability and identify code smells.
we also explore factors that may impact comprehension namely regex string length regex dfa size and the equiva lence class representation.
this analysis requires identificationof equivalence classes for regexes.
by inspecting a pythonregex dataset of nearly regexes we formed an initial set of five types of equivalence classes to explore.
rq2 which regex representations have the strongest community support based on frequency?
to answer rq2 we explore the publicly available regex dataset and use the presence and absence of language features as a proxy for communitysupport where more frequently used features are assumed tobe more understandable.
rq3 which regex representations are most desirable i.e.
least smelly based on both community support and understandability?
based on rq1 and rq2 we identify smelly and non smelly regex features based on a combination of comprehension metrics and community support.
iii.
e quiv alence classes to explore understandability we defined an initial set of equivalence classes for regexes.
using the publicly availablebehavioral clusters of python regexes we manually identified several representations that appeared in many of the largerclusters.
while they are not a complete set of equivalenceclasses this is the first work to explore regex understandability and these equivalence classes provide an initial testbed forexploration.
figure shows five types of equivalence classes in grey boxes and examples of behaviorally equivalent representations in white boxes with identifiers in white circles.
for example lwb is a type of equivalence class with representations l1 l2 and l3.
regexes aaa andaa map to l2 and l3 respectively.
each equivalence class is accompanied by a deterministic finite automata dfa representing the behavior of the exam ple regexes.
for example with the sng group each of theregexes accepts strings with a sequence of exactly three s characters.
the accept state is marked by a double circle.
next we describe each equivalence class group.
a. custom character class group the custom character class ccc group has regex representations that use the custom character class language feature or can be represented by such a feature.
a custom characterclass matches a set of alternative characters.
for example theregexc t will match strings cat and cot because between the candt there is a custom character class that specifies either aoro but not both must be selected.
we use the term custom to differentiate these classes from the default character classes d d w w s s and.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
provided by most regex libraries though the default classes can be encapsulated in a custom character class.
c1 any pattern that contains a non negative custom character class with a range feature like as shorthand for all of the characters between a and f inclusive belongs to c1.
c2 any pattern that contains a non negative custom character class without any shorthand representations specifi cally ranges or defaults e.g.
is in c2 but is not .
c3 any pattern with a character class expressed using negation indicated by a caret i.e.
followed by a custom character class.
for example the pattern matches every character exceptaoro.
c4 any pattern using a default character class such as d or w within a non negative character class.
c5 these can be transformed into custom character classes by removing the ors and adding square brackets e.g.
d a in c5 is equivalent to in c4 .
all custom character classes expressed as an or of lengthone sequences including defaults or other custom classes are in c5 .
note that a pattern can belong to multiple representations.
for example belongs to both c1 and c4.
b. double bounded group the double bounded dbb group contains all regex patterns that use some repetition defined by a non equal lowerand upper boundary.
for example pb s represents a p followed by one to three sequential bpatterns then followed by a single s. this matches pbs pbbs and pbbbs .
d1 any pattern that uses the curly brace repetition with a lower and upper bound such as pb s. d2 any pattern that uses the questionable i.e.
?
modifier implies a lower bound of zero and an upper bound of one and hence is double bounded .
d3 any pattern that has a repetition with a lower and upper bound and is expressed using ors e.g.
pb s becomespbs pbbs pbbbs by expanding on each option in the boundaries .
patterns can belong to multiple representations e.g.
a aa x?y belongs to all three nodes y maps to d1 x?
maps to d2 and a aa maps to d3 .
c. literal group in the literal lit group all patterns that are not purely default character classes must use literal tokens.
we use theascii charset in which all characters can be expressed using hex and octal codes such as xf1 and respectively.
t1 patterns that do not use any hex wrapped or octal characters but use at least one literal character.
specialcharacters are escaped using the backslashes.
t2 any pattern using a hex token such as x07.
t3 any pattern with a literal character wrapped in squarebrackets.
this style is used most often to avoid using a 1an or cannot be directly negated it there is no edge between c3 and c5backslash for a special character in the regex language for example which must otherwise be escaped like .
t4 any pattern using an octal token such as .
patterns often fall in multiple of these representations.
for example abc includes literals a b andc and also octal thus belonging to t1 and t4.
not all transformationsare possible in this group.
if a hex representation used for acharacter is not on the keyboard a transformation to t1 or t3 is infeasible.
d. lower bounded group the lower bounded lwb group contains patterns that specify only a lower boundary on repetitions.
this can be expressed using curly braces with a comma after the lowerbound but no upper bound.
for example a will match aa aaa aaaa and any number of a s greater orequal to .
in figure we chose the lower bound repetitionthreshold of for illustration in practice this could be anynumber including zero.
l1 any pattern using this curly braces style lower bounded repetition i.e.
belongs to node l1.
l2 any pattern using the kleene star i.e.
which means zero or more repetitions.
l3 any pattern using the additional repetition i.e.
.
forexample t means one or more t s. patterns often fall into multiple nodes in this equivalence class.
for example with a b a maps it to l3 and b maps it to l2.
e. single bounded group the single bounded sng equivalence class contains three representations in which each regex has a fixed number of repetitions of some element.
the important factor distinguishingthis group from dbb and lwb is that there is a single finitenumber of repetitions rather than a bounded range on thenumber of repetitions dbb or a lower bound on the number of repetitions lwb .
s1 any pattern with a single repetition boundary in curly braces belongs to s1.
for example s states that s appears exactly three times in sequence.
s2 any pattern that is explicitly repeated two or more times and could use repetition operators.
s3 any pattern with a double bound in which the upper and lower bounds are same belong to s3.
for example s statessappears a minimum of and maximum of times.
the pattern fa is a member of s2 as is repeated three times and it could be transformed to fa in s1 or fa in s3.
iv .
u nderst andability study rq1 this study presents programmers with regexes and asks comprehension questions.
by comparing the understandability authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able i ma tching metric example string rr oracle p1 p2 p3 p4 arrow qrs ?
r0r ?
qrs score .
.
.
.
.
match not a match ?
unsure left blank of semantically equivalent regexes that match the same language but have different syntactic representations we aim toidentify understandability code smells.
this study was imple mented on amazon s mechanical turk with participants.a total of regexes were evaluated constructing pairsof regex comparison.
each regex pattern was evaluated by 30participants.
a. metrics we measure the understandability of regexes using two complementary metrics matching and composition.
these are referred to as the comprehension metrics.
for a deeper look at the data to gain a better understanding of factors that impact comprehension we also compute regex length and df a size for each regex.
matching given a pattern and a set of strings a participant determines by inspection which strings will be matched bythe pattern.
there are four possible responses for each string matches not a match unsure or blank.
an example 2from our study is shown in figure .
the percentage of correct responses disregarding blanks and unsure responses is the matching score.
for example consider regex pattern rr the five strings shown in table i and the responses from four participants in the p1 p2 p3 and p4 columns.
the oracle indicates the first three strings match and the last two do not p1 answers correctly for the first three strings and the fifth but incorrectly on the fourth so the matching score is .
.
p2 incorrectly thinks that the second string is not a match so the score isalso .
.
p3 marks unsure for the third string and so the total number of attempted matching questions is .
p3 is incorrect about the second and fourth string so they score .
.f o r p4 we only have data for the first and second strings since the other three are blank.
p4 marks unsure for the second string so only one matching question has been attempted the matching score is .
.
blanks were incorporated into the metric because questions were occasionally left blank in the study.
unsure responses were provided as an option so not to bias the results through blind guessing.
these situations did not occur very frequently.out of questions participants questions each only .
were impacted by a blank or unsure response never more than four out of responses per pattern .
2task instructions are also available regexsmells blob master questionnaire.pdf fig.
.
questions from one pattern in one hit composition given a pattern a participant composes a string they think it matches question .f in figure .
if the participant is accurate a composition score is otherwise .for example given the pattern q4fab ab from our study the string xyzq4fab matches and gets a score of but thestring acb does not match and gets a score of .
to determine the match between a string and a pattern the pattern is compiled using the re.compile module in python.
an instance of re.regexobject mis created using the compiled pattern.
m.search returns an instance of re.matchobject m2 with the string given as the input to this function.
if m2 is not none then that string was a match and scored otherwise itscored .
regex length given a pattern the regex length is computed by its literal string length.
for example regexes andab care both length four.
dfa size given a pattern to compute the size of minimal dfa we run both brics and rex on each regex and manually check their results to guarantee their correctness.
b. design we implemented this study on amazon s mechanical turk mturk a crowdsourcing platform where requesters create human intelligence tasks hits for completion by workers.
worker qualification qualified workers had to answer four of the five basic regex questions correctly.
these questionswere multiple choice and asked the worker to analyze the following patterns a r z d q and .
tasks guided by the patterns in the corpus we created regex patterns that were grouped into semantic equivalence groups.
there were groups with two regexes targetingvarious edges in the equivalence classes.
the other eightgroups had three regexes each.
in total there are pairs ofpatterns.
in this way we can draw conclusions by comparingrepresentations since the regexes evaluated were semanticallyequivalent.
to form the semantic groups we took a regex from the corpus matched it to a representation in figure trimmed itdown so it contained little more than just the feature of interest and then created other regexes that are semantically equivalentbut belong to other nodes in the equivalence class.
forexample a semantic group with regexes q4f ab authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able ii factor anov a with a verage ma tching or composition accuracy as dependent v ariables considering represent a tion rep dfa size dfa size and regex length len as independent v ariables average matching average composition df f value pr f f value pr f dfa size .
.
.
.
len .
.
.
.
rep .
.
.
.
dfa size len .
.
.
.
dfa size rep .
.
.
.
len rep .
.
.
.
dfa size len rep .
.
.
.
residuals .
.
.
.
q4f ?ab and q4fab ab belong to d1 d2 and d3 respectively.
a group with regexes .
and d .
d is intended to evaluate the edge between c1 and c4.
we note that if we only used regexes from the corpus we would have had regexes with different semantics ateach node or with additional language features which wouldmake the comparisons of the targeted features difficult.for each of the semantic groups we created five strings for the study where at least one matched and at least one didnot match.
these were used to compute the matching metric.
once all the patterns and matching strings were collected wecreated tasks for the mturk participants as follows randomlyselect a pattern from of the semantic groups.
randomize the order of these patterns as well as the order of thematching strings for each pattern.
after adding a question asking the participant to compose a string that each patternmatches this creates one task on mturk such as the examplein figure .
this process was completed until each of the 60regexes appeared in hits resulting in a total of total unique hits.
implementation workers were paid .
for successfully completing one and only one hit.
the average completion time for accepted hits was seconds mins secs .a total of hits were rejected had too many blankresponses four were double submissions by same workers one did not answer composition questions and one misseddata of questions.
rejected hits were returned to mturk tobe completed by others.
participants in total there were participants.
a majority were male .
most had at least an associates degree were at least somewhat familiar with regexes and had prior programming experience .
c. analysis we computed a matching and composition score for each regex based on the participant responses.
the average analysis or average composition is computed by averaging theassociated values for each metric for each of the 60regexes fewer than values were used if all the responses ina matching question were a combination of blanks and unsure .
of the original pairs we report scores for .
due to a design flaw the regexes evaluated .. and .
.
werenot semantically equivalent the former is missing an escapeand should be .
.
so this was omitted from the data.
in the end we analyzed regexes that cover edges fromfigure .
to gain a better understanding of why some regexes may be more understandable than others we also look at theimpact of the representation from figure regex length and dfa size 3on the comprehension metrics.
note that we retain all regexes for this analysis as we are looking at the properties of regexes individually.
we conduct two three factoranalysis of variances anov as with matching accuracy andcomposition accuracy as the dependent variables.
we alsoconduct the correlation analysis between these three factors and the composition metrics.
we use spearman s rank ordercorrelation because we have no priori knowledge about thedistributions of the factors.
since the regex representations are categorical data these are excluded from the correlationanalysis.
d. results the anov a in table ii shows that dfa size significantly affects both the average matching accuracy and the average composition at .
and .
respectively.
the length and representation from figure each significantlyaffect the average matching accuracy at .
.
since the dfa sizes vary across the pairwise comparisons withina representation we present our results for matching andcomposition using each of the pairs of regexes separately rather than in aggregate over the equivalence class edgesexplored.
for the comprehension metrics table iii presents the results.
each row represents a pair of regex evaluated by study participants.
the representations for the regexes per figure 1are shown in the edge column which is how the table is sorted.
the regex1 and regex2 columns identify the regexes used in the study mapping to the first and second representations in the edge column respectively.
match1 is the average matching for regex1 and match2 is the average matching for regex2.
using the mann whitney test of means the sigm column following tests if there is a significant difference between the accuracies.
the comp1 column presents the percentage of the string responses for that were in fact correctly matched by regex1.
comp2 presents the same information except for regex2.
the following sigc column uses a test of two proportions to identify if the percentage of the participants who correctly composed a string for regex1 is significantlydifferent than the percentage who correctly composed a string for regex2.
to illustrate consider pair in table iii.
one pair of regexes was and in c4 and c5 respectively with average matching scores of .
and .
and average composition scores of .
and .
respectively.
the difference between the composition scores 3note that the study was not specifically designed for regex length and dfa size authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able iii pairwise comp arisons of regexes .e ach ma tching or composition v alue is computed based on approxima tel y da t a points from study p articip ants pair edge regex1 regex2 match1 match2 sigm comp1 comp2 sigc c1 c 2tri tri .
.
.
.
c1 c 2no no .
.
.
.
3c c3no no w x y z .
.
.
.
4c c4 .
d .
d .
.
.
.
c1 c 4xg1 xg1 d .
.
.
.
c1 c d .
.
.
.
7c c4 w .
.
.
.
c1 c 41q 1q w w .
.
.
.
c1 c 4tuv tuv w .
.
.
.
c1 c 5tri tri a b c d e f .
.
.
.
c2 c4 .
.
.
.
c2 c 5tri tri a b c d e f .
.
.
.
c2 c5no no w x y z .
.
.
.
c3 c4 .
.
.
.
c3 c4 .
.
.
.
c4 c5 .
.
.
.
c4 c5 .
.
.
.
d1 d q4f ab q4f ?ab .
.
.
.
d1 d dee do deedo do ?
.
.
.
.
d1 d3 q4f ab q4fab ab .
.
.
.
d1 d3 dee do deedo deedodo .
.
.
.
d2 d3 q4f ?ab q4fab ab .
.
.
.
d2 d3 deedo do ?
deedo deedodo .
.
.
.
l2 l3 zaa za .
.
.
.
l2 l3rr r .
.
.
.
s1 s2 .
.
.
.
s1 s2 d z d z .
.
.
.
s1 s2 fa fa .
.
.
.
t1 t2 xyz xyz .
.
.
.
t1 t 2t p t p .
.
.
.
t1 t3 d d .
.
.
.
t1 t3t .
d t d .
.
.
.
t1 t d .
d d d .
.
.
.
t1 t 4xyz xyz .
.
.
.
t1 t 4t p t p .
.
.
.
t1 t .
.
.
.
t1 t .
.
.
.
t1 t .
.
.
.
t1 t .
.
.
.
t2 t 4xyz xyz .
.
.
.
t2 t4t p t p .
.
.
.
.
.
.
.
is significant at .
yet the difference between the accuracies is not.
in fact the representation c5 was more understandable in that participants could more effectivelycompose a string that it would match but c4 is more un derstandable in that participants could more easily determinewhich of a set of strings would be matched by c4.
thus neither representation is bolded in the edge column since there is a conflict.
if both comprehension metrics indicateda preferred representation that representation is bolded e.g.
c4 in pair .
ties are broken by deferring to the other metric.
for example there s a tie in composition for pair but matching indicates a preference for c5.
therefore c5 is bolded.for pairs and the difference in composition is significant at .
indicating differences favoring c5 over c4 t1 over t2 and twice favoring t1 over t4.
for pairs23 and the difference in matching is significant with .
indicating differences favoring d3 over d2 and twice favoring t1 over t4.
interestingly for pairs and while the differences in composition are significant there is aconflict between the composition metrics.
further investigationis needed to understand in what circumstances the metrics arein conflict with one another.
recall that participants were able to select unsure for whether a string is matched by a pattern.
from a comprehension perspective this indicates some level of confusion.
for each pattern we counted the number of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
responses containing at least one unsure.
overall the highest number of unsure responses came from t4 and t2 which haveoctal and hex representations of characters.
the least numberof unsure responses were in l3 and d3.
these results mirrorthe understandability analysis as t4 and t2 are generallylower in comprehension and l3 and d3 are generally higher.
while the anov a indicates that variance in matching is due to all three factors representation dfa size and regexlength it is not entirely clear why.
v ariance in composition isimpacted by dfa size only.
between dfa size and compo sition there is a strong positive correlation at .01with .
.
at first this result may seem counter intuitive but considering that larger dfas may represent more constrainedregex languages i.e.
languages that accept fewer strings these may be easier to compose a string for.
however as the explored dfa size range was between two and eight nodes these results may not generalize to larger regexes.
none of theother correlations are significant with .
.
e. summary matching and composition are impacted by dfa size and matching is also impacted by regex length and representation showing some support that the representation of the regeximpacts comprehension.
the larger the dfa the easier itwas for the community to generate strings that match it.there also appears to be a clear trend favoring t1 over t4.representations d3 and c5 are also preferred.
while c1is favored comparisons against c2 c4 and c5 none aresignificant.
v. c ommunity support study rq2 the goal of this evaluation is to understand how frequently each of the regex representations appears in source code as away to identify community standards code smells .
a. artifacts we analyzed an existing corpus of regexes collected from python code in github projects .
this dataset has distinct non duplicate regex patterns from projects.
this corpus was created by analyzing static invocations to the python re library.
consider the python snippet r1 re.compile ?
re.multiline the function re.compile compiles the regex ?
intor1 an object of re.regexobject.
re.multiline is a flag that changes the matching behavior from the default one line to multiple lines.
this particularregex will match strings with any integer at the end of a line ?
indicates the integer may be negative .
b. metrics we measure community support by matching regexes in the corpus to representations in figure and by counting the patterns and projects.
these are referred to as the communitystandards metrics.
a regex can belong to multiple represen tations and to multiple projects since the corpus tracks itsduplicates.
c. analysis to match patterns to representations we either used the pcre parser to parse features of patterns or extracted token streams of them.
the choice depends on the characteristics ofthe representation.
our analysis code is available on github .
the details of this process are described as follows.
presence of a feature for representations that require a particular feature we used the pcre parser to decidemembership.
this applies to c3 d1 d2 l1 l2 l3 s1 and s3.
features and pattern identifying d3 requires an or containing at least two entries with a sequence repeated ntimes in one entry and the same sequence repeated n timesin another entry.
we first looked for a sequence of n repeatinggroups with an or bar i.e.
next to them on a side.
this produced a list of candidates and we narrowed them downmanually to actual members.
t1 requires that no characters are wrapped in brackets or are hex or octal characters which matches over of the patterns analyzed t2 requires a literal character with a hexstructure t3 requires that a single literal character is wrappedin a custom character class a member of t3 is always amember of c2 t4 requires a literal character with a python style octal structure.
token stream c1 requires a non negative class of characters whose ascii codes are consecutive c2 requires a custom character class which does not use ranges or defaults c4requires the presence of a default character class within acustom character class c5 requires an or of length one sequences literal characters or any character class s2 requires a repeated element which could be a character class a literalcharacter or a smaller regex encapsulated in parentheses.these representations were treated as sequences of tokens.
toidentify them we chose token streams instead of the pcreparser.
d. results table iv presents the results.
node