restler stateful rest api fuzzing vaggelis atlidakis columbia universitypatrice godefroid microsoft researchmarina polishchuk microsoft research abstract this paper introduces restler the first stateful rest api fuzzer.
restler analyzes the api specification of a cloud service and generates sequences of requests that automatically test the service through its api.
restler generates test sequences by inferring producer consumer dependencies among request types declared in the specification e.g.
inferring that a request b should be executed after request a because b takes as an input a resource id xproduced by a and by analyzing dynamic feedback from responses observed during prior test executions in order to generate new tests e.g.
learning that a request c after a request sequence a b is refused by the service and therefore avoiding this combination in the future .
we present experimental results showing that these two techniques are necessary to thoroughly exercise a service under test while pruning the large search space of possible request sequences.
we used restler to test gitlab an open source git service as well as several microsoft azure and office365 cloud services.
restler found 28bugs in gitlab and several bugs in each of the azure and office365 cloud services tested so far.
these bugs have been confirmed and fixed by the service owners.
i. i ntroduction over the last decade we have seen an explosion in cloud services for hosting software applications software as aservice for building distributed services and data processing platform as a service and for providing general computing infrastructure infrastructure as a service .
today most cloud services such as those provided by amazon web services aws and microsoft azure are programmatically accessed through rest apis by third party applications and other services .
meanwhile swagger recently renamed openapi has arguably become the most popular interface description language for rest apis.
a swagger specification describes how to access a cloud service through its rest api including what requests the service can handle what responses may be received and the response format.
tools for automatically testing cloud services via their rest apis and checking whether those services are reliable and secure are still in their infancy.
the most sophisticated testing tools currently available for rest apis capture live api traffic and then parse fuzz and replay the traffic with the hope of finding bugs .
many of these tools were born as extensions of more established website testing and scanning tools see section viii .
since these rest api testing tools are all recent and not yet widely used it is still largely unknown how effective they are in finding bugs and how security critical those bugs are.
in this paper we introduce restler the first automatic stateful rest api fuzzing tool.
fuzzing means automatic the work of this author was mostly done at microsoft research.test generation and execution with the goal of finding security vulnerabilities.
unlike other rest api testing tools restler performs a lightweight static analysis of an entire swagger specification and then generates and executes tests that exercise the corresponding cloud service in a stateful manner.
by stateful we mean that restler attempts to explore service states that are reachable only using sequences of multiple requests.
with restler each test is defined as a sequence of requests and responses.
restler generates tests by inferring dependencies among request types declared in the swagger specification e.g.
inferring that a resource included in the response of a request a is necessary as input argument of another request b and therefore that a should be executed before b and by analyzing dynamic feedback from responses observed during prior test executions in order to generate new tests e.g.
learning that a request c after a request sequence a b is refused by the service and therefore avoiding this combination in the future .
we present empirical evidence showing that these two techniques are necessary to thoroughly test a service while pruning the large search space defined by all possible request sequences.
restler also implements several search strategies akin to those used in model based testing and we compare their effectiveness while fuzzing gitlab an open source self hosted git service with a complex rest api.
during the course of our experiments we found 28new bugs in gitlab see section vi .
we also ran experiments on four public cloud services in microsoft azure and office365 and found several bugs in each service tested see section vii .
this paper makes the following contributions we introduce restler the first automatic stateful fuzzing tool for rest apis which analyzes a swagger specification automatically infers dependencies among request types and dynamically generates tests guided by feedback from service responses.
we present detailed experimental evidence showing that the techniques used in restler are necessary for effective automated stateful rest api fuzzing.
we present experimental results obtained with three different strategies for searching the large search space defined by all possible request sequences and discuss their strengths and weaknesses.
we present a detailed case study with gitlab a large popular open source self hosted git service and discuss several new bugs found so far.
we discuss preliminary experiences using restler to test ieee acm 41st international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
swagger specification of blog posts service several microsoft public cloud services.
the remainder of the paper is organized as follows.
section ii describes how swagger specifications are processed by restler .
sections iii and iv present the main test generation algorithm used in restler and implementation details.
section v presents an evaluation of the test generation techniques and search strategies implemented in restler .
section vi discusses new bugs found in gitlab.
section vii presents our experiences fuzzing several public cloud services.
section viii discusses related work and section ix concludes the paper.
ii.
p rocessing api s pecifications in this paper we consider services accessible through rest apis described with a swagger specification.
a client program can send messages called requests to a service and receive messages back called responses .
such messages are sent over the http protocol.
a swagger specification describes how to access a service through its rest api e.g.
what requests the service can handle and what responses may be expected .
given a swagger specification open source swagger tools can automatically generate a web ui that allows users to view the documentation and interact with the api via a web browser.
a sample swagger specification in web ui form is shown in figure .
this specification describes the api of a simple blog posts hosting service.
the api consists of five request types specifying the endpoint method and required parameters.
this service allows users to create access update and delete blog posts.
in a web browser clicking on any of these five request types expands the description of the request type.
for instance selecting the second post request reveals text similar to the left of figure .
this text is in yaml format and describes the exact syntax expected for that specific request and its response.
in this case the definition part of the specification indicates that an object named body of typestring is required and that an object named idof type integer is optional since it is not required .
the path part of the specification describes the http syntax for this post request as well as the format of the expected response.
from such a specification restler automatically constructs the test generation grammar shown on the right of figure .
this grammar is encoded in executable python code.
it consists of code to generate an http request of type post in this case and code to process the expected response of this request.
each function restler static simply appends the string it takes as argument without modifyingbasepath api swagger .
definitions blog post properties body type string id type integer required body type object paths blog posts post parameters in body name payload required true schema ref definitions blog post from restler import requests from restler import dependencies def parse posts data post id data dependencies .setvar post id request requests .request restler static post restler static api blog posts restler static http .
restler static f restler static body restler fuzzable string restler static g post send f parser parse posts dependencies post id.writer g fig.
swagger specification and automatically derived restler grammar.
shows a snippet of swagger specification in yaml left and the corresponding grammar generated by restler right .
it.
in contrast the function restler fuzzable takes as argument a value type like string in this example and replaces it by one value of that type taken from a small dictionary of values for that type.
how dictionaries are defined and how values are selected is discussed in the next section.
the response is expected to return a new dynamic object a dynamically created resource id named idof type integer .
using the schema shown on the left restler automatically generates the function parse posts shown on the right.
by similarly analyzing the other request types described in this swagger specification restler will infer automatically thatids returned by such post requests are necessary to generate well formed requests of the last three request types shown in figure which each requires an id.
these producer consumer dependencies are extracted by restler when processing the swagger specification and are later used for test generation as described next.
iii.
t estgeneration algorithm the main algorithm for test generation used by restler is shown in figure in python like notation.
it starts line by processing a swagger specification as discussed in the previous section.
the result of this processing is a set of request types denoted reqset in figure and of their dependencies more on this later .
the algorithm computes a set of request sequences as inferred from swagger denoted seqset and initially containing an empty sequence line .
a request sequence is valid if every response in the sequence has a valid return code defined here as any code in the range.
at each iteration of its main loop line starting with n the algorithm computes all valid request sequences seqset of lengthnbefore moving to n 1and so on until a user specified maxlength is reached.
computing seqset is done in two steps.
first the set of valid request sequences of length n 1is extended line to create a set of new sequences of length n authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1inputs swagger spec maxlength setofrequests parsed from theswagger api spec 3reqset process swagger spec setofrequest sequences initially anempty sequence 5seqset f g main loop iterate uptoagiven maximum sequence length 7n 8while n maxlength seqset extend seqset reqset seqset render seqset n n extend allsequences inseqset byappending new requests whose dependencies aresatisfied 14defextend seqset reqset newseqset fg forseqinseqset forreqinreqset ifdependencies seq req newseqset newseqset concat seq req return newseqset concretize allnewly appended requests using dictionary values execute each new request sequence andkeep thevalid ones 23defrender seqset newseqset fg forseqinseqset req last request in seq v tuple offuzzable types in req for vin v newreq concretize req v newseq concat seq newreq response execute newseq ifresponse has a valid code newseqset newseqset newseq else log error return newseqset check thatallobjects referenced inarequest areproduced bysome response inaprior request sequence 39defdependencies seq req ifconsumes req produces seq return true else return false objects required inarequest 45defconsumes req return object types required in req objects produced intheresponses ofasequence ofrequests 48defproduces seq dynamicobjects fg forreqinseq newobjs objects produced inresponse of req dynamicobjects dynamicobjects newobjs return dynamicobjects fig.
main algorithm used in restler .
by appending each request with satisfied dependencies at the end of each sequence as described in the extend function line .
the function dependencies line checks if all dependencies of the specified request are satisfied .
this is true when every dynamic object that is a required parameter of the request denoted by consumes req is produced by some response to the request sequence preceding it denoted byproduces seq .
if all the dependencies are satisfied the new sequence of length nis retained line otherwise it is discarded.
second each newly extended request sequence whose dependencies are satisfied is rendered line one by one as described in the render function line .
for every newlyappended request line the list of all fuzzable primitivetypes in the request is computed line those are identified byrestler fuzzable in the code shown on the right of figure .
then each fuzzable primitive type in the request is concretized which substitutes one concrete value of that type taken out of a finite user configurable dictionary of values.
for instance for fuzzable type integer restler might use a small dictionary with the values and while for fuzzable type string a dictionary could be defined with the values samplestring the empty string and a very long fixed string.
the function render generates all possible such combinations line .
each combination thus corresponds to a fully defined request newreq line which is httpsyntactically correct.
the function render then executes this new request sequence line and checks its response if the response has a valid status code the new request sequence is valid and retained line otherwise it is discarded and the received error code is logged for analysis and debugging.
more precisely the function execute executes each request in a sequence one by one each time checking that the response is valid extracting and memoizing dynamic objects if any and providing those in subsequent requests in the sequence if needed as determined by the dependency analysis the response returned by function execute in line refers to the response received for the last newly appended request in the sequence.
note that if a request sequence produces more than one dynamic object of a given type the function execute will memoize all of those objects but will provide them later when needed by subsequent requests in the exact order in which they are produced in other words the function execute will not try different ordering of such objects.
if a dynamic object is passed as argument to a subsequent request and is destroyed after that request i.e.
it becomes unusable later on restler will detect this by receiving an invalid status code outside the range when attempting to reuse that unusable object and will then discard that request sequence.
by default the function render of figure generates all possible combinations of dictionary values for every request with several fuzzable types see line .
for large dictionaries this may result in astronomical numbers of combinations.
in that case a more scalable option is to randomly sample each dictionary for one or a few values or to use combinatorialtesting algorithms for covering say every dictionary value or every pair of values but not every k tuple.
in the experiments reported later we used small dictionaries and the default render function shown in figure .
the function extend of figure generates allrequest sequences of length n 1whose dependencies are satisfied.
since nis incremented at each iteration of the main loop of line the overall algorithm performs a breadth first search bfs in the search space defined by all possible request sequences.
in section v we report experiments performed also with two additional search strategies bfs fast and randomwalk.
bfs fast.
in function extend instead of appending every request to every sequence every request is appended to at most one sequence.
this results in in a smaller set newseqset which covers i.e.
includes at least once every request but authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
does not generate all valid request sequences.
like bfs bfs fast still exercises every executable request type at each iteration of the main loop in line it still provides full grammar coverage but with fewer request sequences which allows it to go deeper faster than bfs.
randomwalk.
in function extend the two loops of line and line are eliminated instead the function now returns a single new request sequence whose dependencies are satisfied and generated by randomly selecting one request sequence seq inseqset and one request in reqset .
the function randomly chooses such a pair until all the dependencies of that pair are satisfied.
this search strategy will therefore explore the search space of possible request sequences deeper more quickly than bfs or bfs fast.
when randomwalk can no longer extend the current request sequence it restarts from scratch from an empty request sequence.
since it does not memoize past request sequences between restarts it might regenerate the same request sequence again in the future.
iv.
i mplementation we have implemented restler in lines of modular python code split into the parser and compiler module the core fuzzing runtime module and the garbage collector gc module.
the parser and compiler module is used to parse a swagger specification and to generate the restler grammar describing how to fuzz a target service.
in the absence of a swagger specification the user could directly provide the restler grammar.
the core fuzzing runtime module implements the algorithm of figure and its variants.
it renders api requests processes service side responses to retrieve values of the dynamic objects created and analyzes service side feedback to decide which requests should be reused in future generations while composing new request sequences.
finally the gc runs as a separate thread that tracks the creation of the dynamic objects over time and periodically deletes aging objects that exceed some user defined limit see section vii .
a. using restler restler is a command line tool that takes as input a swagger specification service access parameters e.g.
ip port authentication the mutations dictionary and the search strategy to use during fuzzing.
after compiling the swagger specification restler displays the number of endpoints discovered and the list of resolved and unresolved dependencies if any.
in case of unresolved dependencies the user may provide additional annotations or resource specific mutations see section vii and re run this step to resolve them.
alternatively the user may choose to start fuzzing right away and restler will treat unresolved dependencies in consumer parameters asrestler fuzzable string primitives.
during fuzzing restler reports each bug currently defined as a http status code internal server error received after executing a request sequence as soon as it is found.
b. current limitations currently restler does not support requests for api endpoints with server side redirects e.g.
moved perma nently see other and temporary redirect .
furthermore restler currently can only find bugs defined as unexpected http status codes.
such a simple test oracle cannot detect vulnerabilities that are not visible though http status codes e.g.
information exposure and others .
despite these limitations restler has already found confirmed bugs in a production scale open source application and in several microsoft azure and office365 services as will be discussed in sections vi and vii.
v. e valuation we present experimental results obtained with restler that answer the following questions q1 are both inferring dependencies among request types and analyzing dynamic feedback necessary for effective automated rest api fuzzing?
section v b q2 are tests generated by restler exercising deeper service side logic as sequence length increases?
section v c q3 how do the three search strategies implemented in restler compare across various apis?
section v d we answer the first question q1 using a simple blog posts service with a rest api.
we answer q2 and q3 using gitlab an open source production scale1web service for self hosted git.
we conclude the evaluation by discussing in section v e how to bucketize i.e.
group together the numerous bugs that can be reported by restler in order to facilitate their analysis.
a. experimental setup blog posts service.
we answer q1 using a simple blog posts service written in lines of python code using the flask web framework .
its functionality is exposed over a rest api with a swagger specification shown in figure .
the api contains five request types i get on posts returns all blog posts currently registered ii post on posts creates a new blog post body the text of the blog post iii delete posts id deletes a blog post iv get posts id returns the body and the checksum of an individual blog post and v put posts id updates the contents of a blog post body the new text of the blog post and the checksum of the older version of the blog post s text .
to model an imaginary subtle bug at every update of a blog post put request with body text and checksum the service checks if the checksum provided in the request matches the recorded checksum for the current blog post and if it does an uncaught exception is raised.
thus this bug will be triggered and detected only if dependencies on dynamic objects shared across requests are taken into account during test generation.
gitlab.
we answer q2 and q3 using gitlab an opensource web service for self hosted git.
gitlab s back end is written in over 376k lines of ruby code using ruby onrails and its functionality is exposed through a rest 1gitlab is used by more than organizations has millions of users and has currently a 3market share of the self hosted git market .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
api .
for our deployment we apply the following configuration settings we use nginx to proxypass the unicorn web server and configure unicorn workers limited to up to 2gb of physical memory we use postgresql for persistent storage configured with a pool of workers we use gitlab s default configuration for sidekiq queues and redis workers.
according to gitlab s deployment recommendations such configuration should scale up to concurrent users .
fuzzing dictionaries.
for the experiments in this section we use the following dictionaries for fuzzable primitives types string has possible values samplestring and empty string integer has possible values and boolean has possible values true and false .
all experiments were run on ubuntu .
microsoft azure vms configured with eight intel r xeon r e5 v3 40ghz cpu cores and 56gb of physical memory.
b. techniques for effective rest api fuzzing in this section we report results with our blog posts service to determine whether both inferring dependencies among request types and analyzing dynamic feedback are necessary for effective automated rest api fuzzing q1 .
we choose a simple service in order to clearly measure and interpret the testing capabilities of the two core techniques being evaluated.
those capabilities are evaluated by measuring service code coverage and client visible http status codes.
specifically we compare results obtained when exhaustively generating all possible request sequences of length up to three with three different test generation algorithms restler ignores dependencies among request types and treats dynamic objects such as post idand checksum as fuzzable primitive type string objects while still analyzing dynamic feedback.
restler ignores service side dynamic feedback and does not eliminate invalid sequences during the search but still infers dependencies among request types and generates request sequences satisfying those.
restler uses the algorithm of figure using both dependencies among request types and dynamic feedback.
figure shows the number of tests i.e.
request sequences up to maximum length generated by each of these three algorithms from left to right.
the top plots show the cumulative code coverage measured in lines of code over time as well as when the sequence length increases.
the bottom plots show the cumulative number of http status codes received.
code coverage.
first we observe that without considering dependencies among request types figure top left code coverage is limited to up to 130lines and there is no increase over time despite increasing the length of request sequences.
this illustrates the limitations of using a naive approach to test a service where values of dynamic objects like idand checksum cannot be randomly guessed or picked among values in a small predefined dictionary.
in contrast by infering dependencies among requests and by processing service responses restler achieves an increase in code coverage up to150lines of code figure top center and right .second we see that without considering dynamic feedback to prune invalid request sequences in the search space figure top center the number of tests generated grows quickly even for a simple api.
specifically without considering dynamic feedback figure top center restler produces more than 600tests that take 750seconds and cover about lines of code.
in contrast by considering dynamic feedback figure top right the state space is significantly reduced andrestler achieves the same code coverage with less than 800test cases and only 179seconds.
http status codes.
we make two observations.
first focusing on 40x status codes we notice a high number of 40x responses when ignoring dynamic feedback figure bottom center .
this indicates that without considering serviceside dynamic feedback the number of possible invalid request sequences grows quickly.
in contrast considering dynamic feedback dramatically decreases the percentage of 40x status codes from to26 without using dependencies among request types figure bottom left and to with using dependencies among request types figure bottom right .
moreover when using dependencies among request types figure bottom right we observe the highest percentage of20x status codes approximately indicating that restler then exercises a larger part of the service logic also confirmed by coverage data figure top right .
second when ignoring dependencies among request types we see that no status codes are detected figure bottom left while restler finds a handful of status codes when using dependencies among request types see figure bottom left and bottom right .
these responses are triggered by the unhandled exception we planted in our blog posts service after a put blog update request with a checksum matching the previous blog post s body see section v a .
when ignoring dependencies among request types restler misses this bug figure bottom left .
in contrast when analyzing dependencies across request types and using the checksum returned by a previous get posts id request in a subsequent put posts id update request with the same id restler does trigger the bug.
furthermore when additionally using dynamic feedback the search space is pruned while preserving this bug which is then found with the least number of tests figure bottom right .
overall these experiments illustrate the complementarity between utilizing dependencies among request types and using dynamic feedback and show that both are needed for effective rest api fuzzing.
c. deeper service exploration in this section we use gitlab to determine whether tests generated by restler exercise deeper service side logic as sequence length increases q2 .
we perform individual experiments on six groups of gitlab apis related to usual operations with commits branches issues and notes repositories and repository files groups and group membership and projects.
table i shows the total number of requests in each of the six target api groups and presents experimental results obtained authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time seconds 105110115120125130135140code coverage loc coverage seq.
length increase40 900test cases time seconds 110120130140150160code coverage loc coverage seq.
length increase0 4700test cases time seconds 110120130140150160code coverage loc coverage seq.
length increase30 776test cases time seconds 02004006008001000occurences over time http status http status http status http status 900test cases time seconds 01000200030004000500060007000occurences over time http status http status http status http status http status 4700test cases time seconds 0200400600800occurences over time http status http status http status http status http status 776test casesfig.
blog posts service code coverage and http status codes over time.
shows the increase in code coverage over time top and the cumulative number of http status codes received over time bottom for the simple blog posts service.
left restler ignores dependencies among request types.
center restler ignores dynamic feedback.
right restler utilizes both dependencies among request types and dynamic feedback.
when leveraging both techniques restler achieves the best code coverage and finds the planted internal server error bug with the least number of tests.
api total requestsseq.
len.coverage increasetests seqset sizedynamic objects commits branches issues repos groups projects table i testing common gitlab apis with restler .shows the increase in sequence length code coverage tests executed seqset size and the number of dynamic objects being created using bfs until a hours timeout is reached.
longer request sequences gradually increase service side code coverage.
with the test generation algorithm of figure using bfs.
for each experiment we run restler with a hours timeout and limit the number of fuzzable primitive type combinations tomaximum combinations per request.
between experiments we reboot the entire gitlab service to restart from the same initial state.
for each api group as time goes by table i shows the increase going down in the sequence length code coverage tests executed seqset size and the number of dynamic objects created until the hours timeout is reached.
code coverage.
we collect code coverage data by configuring ruby s class tracepoint hook to trace gitlab s service lib folder.
table i shows the cumulative code coverage achieved after executing all the request sequences generated by restler for each sequence length or until the hours timeout expires.
the results are incremental on top of lines of code executed during service boot.
from table i we can see that longer sequence lengths consistently lead to increased service side code coverage.
this is the desired behaviour especially for small sequence lengths as some of the service functionality can only be exercised after at least a few requests are executed.
as an example consider the gitlab functionality of selecting a commit .
according to gitlab s specification selecting a commit requires two dynamic objects a project id and a commit id and the following dependency of requests is implicit a user needs to create a project use the respective project id to post a new commit and then select the commit using its commitidand the respective project id .
clearly this operation can only be performed by sequences of three requests or more.
for the commit apis note the gradual increase in coverage from to1 108to1 196lines of code for sequence lengths of one authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
apitotal requeststime hrs bfs bfs fast randomwalk len.
coverage seqset len.
coverage seqset len.
restarts coverage seqset commits branches issues repos groups projects table ii comparison of bfs bfs fast and randomwalk over time .
shows the maximum sequence length the increase in lines of code covered excluding service boot coverage and the seqset size with each search strategy after and 5hours.
the second column shows the total number of requests in each api along with the average feasible request renderings .
although bfs covers slightly more lines of code bfs fast andrandomwalk reach deeper request sequences and maintain a much smaller seqset size.
two and three respectively.
most notably for the branches api service side code coverage keeps gradually increasing for sequences of length up to five and reaches lines when the hours limit expires.
tests sequence sets and dynamic objects.
in addition to code coverage table i also shows the increase in the number of tests executed the size of seqset after the render function returns line of figure and the number of dynamic objects created by restler .
all those numbers are quickly growing since the search space also grows quickly due to the exhaustive nature of the bfs search strategy.
nevertheless we emphasize that without the two key techniques evaluated in section v b this growth would be much worse.
for instance for the commit api the seqset size is20 and there are dynamic objects created by restler for sequences of length up to five.
by comparison since the commits api has 11request types with an average of 4rendering combinations the number of all possible rendered request sequences of up to length four is already more than millions and a naive brute force enumeration of those would already be untractable.
still even with the two core techniques used in restler the search space explodes quickly and we evaluate other search strategies next.
d. search strategies we now present results of experiments comparing the bfs bfs fast and randomwalk search strategies defined in section iii q3 .
for each search strategy table ii shows the maximum sequence length the increase in lines of code covered excluding service boot coverage after and hours and the size of the seqset when the hours timeout isreached.
for the randomwalk search strategy the total number of restarts is also shown in parenthesis.
first we compare bfs with bfs fast.
we observe that after five hours bfs achieves better coverage than bfs fast in commits branches and repos.
these groups of apis have relatively fewer requests and bfs delivers better coverage by exercising all feasible request sequences.
however bfs does not scale well in apis with relatively more requests such as issues groups and projects.
as shown in table ii after hours for issues groups and projects bfs is still exploring sequences of length 3while bfs fast is exploring sequences of length and respectively.
bfs fast scales better in apis with many request because unlike bfs it does not explore all feasible request sequences but instead appends each request to at most one sequence in each generation.
bfs fast maintains a smaller seqset and explores deeper sequences and grows coverage faster in issues groups and projects.
we now compare bfs with randomwalk.
by construction randomwalk does not guarantee full grammar coverage since it appends each request to one random sequence in each generation.
as shown in table ii randomwalk maintains a small seqset at any time by construction.
furthermore after 5hours randomwalk explores considerably deeper request sequences compared to bfs and in most cases compared to bfs fast.
randomwalk also delivers the best coverage after 5hours in branches repos and groups.
on the other hand in issues we observe that after hours randomwalk explores sequences of length 16and the coverage increase is lines.
in the same time frame bfs explores sequences of length 3but the coverage increase is1 and bfs fast explores sequences length 5with a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
api bfs bfsfastrandomwalkintersection union commits branches issues repos groups projects total table iii bug buckets found by bfs bfs fast and randomwalk after five hours.
shows the sets of bugs found by each search strategy in each api.
in total restler found 22new bugs.
coverage increase of .
compared to all other apis shown in table ii issues have 82feasible request renderings on average.
this is relatively large and in such a case with many feasible request renderings the breadth of the search achieved by randomwalk is small e.g.
after 5hours there are only restarts .
consequently the search remains focused on a very restricted subspace which reflects poorly on coverage.
in practice both controlling the size of seqset when facing broader search spaces due to large apis with many requests or when reaching greater depths and maintaining some breadth when extending request sequences seem key to delivering better code coverage.
nevertheless the ultimate goal is to find bugs and maximizing code coverage is just a heuristic to try to reach that goal.
e. bug bucketization before discussing real bugs found with restler we introduce a bucketization scheme to cluster similar internal server errors .
when fuzzing different instances of a same bug are often found repeatedly.
since all the bugs found have to be inspected by the user it is therefore important in practice to facilitate this analysis by identifying likelyredundant instances of a same unique bug.
in our context we define a bugas a500 http status code being received after executing a request sequence.
thus every bug found is associated with the request sequence that was executed to find it.
given this property we use the following bucketization procedure for the bugs found by restler whenever a new bug is found we compute all nonempty suffixes of its non rendered request sequence2 starting with the smallest one and check whether some suffix is a previously recorded sequence leading to a bug found earlier.
if there is a match the new bug is added to the bucket of that previous bug.
otherwise a new bucket is created with the new bug and its request sequence.
when using bfs or bfs fast this bucketization scheme will identify bugs by the shortest sequence necessary to find it.
table iii shows the sets of bug buckets found by each search strategy after five hours in each gitlab api group.
to demonstrate the overlap between the bugs reported by each 2a request sequence of length nhasnsuffixes of length n.method the last two columns show the intersection and the union of the bug buckets.
in the context of these experiments restler found 22new unique bugs after running each search strategy for 5hours on each api group.
randomwalk stands out in table iii by finding the most bugs 21compared to 16and 13for bfs and bfs fast respectively.
it is particularly intriguing that randomwalk finds as many bugs as bfs and bfs fast combined in commits and in issues apis because in these apis randomwalk delivers relatively little coverage.
after 5hours in commits randomwalk finds as many bugs as bfs and more than bfs fast.
at the same time randomwalk delivers less code coverage than each of bfs and bfs fast in commits see table ii .
similarly randomwalk finds 1bug in issues while bfs finds none and bfs fast also finds one.
yet again randomwalk achieves less code coverage than each of bfs and bfs fast in issues.
the differences between bfs and bfs fast are less striking.
bfs finds more bugs in commits while bfs fast finds more bugs in issues and repos.
overall within the hours time frame of our experiments randomwalk finds more bugs than bfs or bfs fast despite the fact that it does not always deliver the best coverage.
it is unclear how this generalizes to longer fuzzing sessions or to other apis.
yet it becomes apparent that coverage increase should not always dictate the selection of a search strategy because different search strategies may be complementary within a large search space.
next we discuss details of the bugs founds with restler in gitlab and the total number of bugs found when running longer fuzzing experiments.
vi.
n ewbugs found in gitlab during all our fuzzing experiments with restler on our local gitlab deployment we found a total of 28new unique bugs.
all bugs were easily reproducible disclosed to gitlab developers confirmed and fixed.
due to space limitation we describe only 2of these bugs to give the reader a flavor of what those bugs look like and how they were found.
see for other examples of bugs found.
example bug in commits api.
one of the bugs found by restler in the commits api is triggered when a user tries to cherry pick a commit to a branch with an empty name.
due to incomplete input validation an invalid branch name can be passed between two different layers of abstraction as follows the ruby code that checks if a target branch exists invokes a native c function whose return value is expected to be either null or an existing entry.
however if an unmatched entry type e.g.
an empty string is passed to the native function an exception is raised.
this exception is unhandled by the higherlevel ruby code and therefore it causes a internal server error .
the bug can be reproduced by creating a project creating a new branch in addition to master branch which is created by default posting a valid commit with action create in the branch created in and cherry picking the commit to a branch whose name is set to the empty string.
example bug in branches api.
another bug found byrestler in the branches api is triggered when a user authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
tries to edit a branch of a recently deleted project.
the bug is due to invalid serialization of operations which results in an database entry update using an invalid foreign key of a deleted project.
since the project id foreign key is not present in the respective projects table a pg foreignkeyviolation exception causes a internal server error .
the bug can be reproduced by creating a project creating a branch deleting the project created in and quickly editing the branch of the deleted project.
from the above bug descriptions we see a two fold pattern.
first restler produces a sequence that exercises the target service deep enough so that it reaches a particular valid state .
second while the service is in such a state restler produces an additional request with an unexpected fuzzed value e.g.
an empty string or an unexpected action e.g.
edit a branch of a recently deleted project .
most bugs found by restler require a combination of these two features in order to be found.
vii.
e xperiences with public cloud services in this section we describe our preliminary experiences running restler on three azure services and one microsoft office365 service.
the services we fuzzed primarily perform resource management and real time data aggregation.
swagger specifications for these services are publicly available and published by microsoft on github.
while still in an early stage of development restler found new bugs in all of these services.
these bugs range from mis handled invalid inputs e.g.
using a wrong id or enum value executing operations in invalid states e.g.
updating a resource that no longer exists and inconsistent parameter validations e.g.
using a valid request body with incorrect metadata .
although we cannot disclose detailed descriptions of these bugs we emphasize that all bugs found by restler so far have been confirmed and fixed by microsoft service developers.
indeed internal server errors are server state corruptions that may severely damage service health and security it is safer to fix these rather than risk a live incident with unknown consequences.
during this effort we faced a number of challenges unique to public cloud services including resource quota limitations short lived access tokens and complex api dependencies beyond the canonical rest api structure with applicationspecific resource values and naming schemes.
we describe the extensions made to restler to address these challenges.
resource quotas.
production services that run in public clouds are deployed with default resource quotas.
once quotas are reached restler s core algorithm will continue to try request sequences containing requests that can no longer succeed due to exceeded quotas since these requests were valid in prior tests and generated lots of new resources which impedes progress.
this challenge is unique to public cloud deployments contrary to self contained deployments where one can easily control and reconfigure resource quotas.
to address this problem we implemented a garbage collector gc in restler .
the gc runs as a separate thread that monitors the creation of dynamic resources over time andperiodically deletes dynamic objects that are no longer used in order to avoid exceeding resource quotas.
this allows restler to continuously test new sequences for hours or days without hitting resource quota related errors.
short lived access tokens.
unlike in self contained deployments where an admin can pre populate static or long lived authentication tokens public cloud services use short lived refreshable authentication tokens.
usually a public endpoint accessible with some type of static credentials e.g.
a usernamepassword pair or a master token and service specific logic generates fresh short lived access tokens.
the latter are added in the header of https requests.
since different services may require custom logic to access their public authentication endpoints restler provides an authentication hook which periodically executes a user provided piece of code e.g.
a script and propagates fresh values in the pool of refreshable authentication tokens.
application specific naming schemes.
as discussed in section ii restler performs a light weight static analysis of a swagger specification to infer dependencies among requests of the target rest api.
however part of a target api may not be fully rest compliant or the specification may be incomplete and consequently the inferred dependencies will also be incomplete.
to address this challenge restler supports annotations which can be added directly to the specification as swagger extensions in order to explicitly declare dependencies as well as resource specific mutations which can be used for the creation of resources that require some custom format e.g.
an ip address .
these two features have proven useful in practice because azure services use put requests to create resources whose user provided names are passed as url parameters and after successful creation are also returned in the response.
for this scenario one can use resource name specific mutations to indicate that a put request should create a resource named in a custom format and then use that name to identify the corresponding dynamic object in subsequent requests.
viii.
r elated work http fuzzers.
since rest api requests and responses are transmitted over the http protocol http fuzzers can be used to fuzz rest apis.
fuzzers like burp sulley boofuzz or the commercial appspider and qualys s was can capture replay http traffic parse http requests responses and their contents like embedded json data and then fuzz those using either pre defined heuristics or user defined rules .
tools to capture parse fuzz and replay http traffic have recently been extended to leverage swagger specifications in order to parse http requests and guide their fuzzing .
compared to those tools the main originality of restler is the lightweight static analysis of swagger specifications in order to infer dependencies among request types which in turn allows restler to automatically generate sequences of requests that exercise the business logic exposed by the api in a stateful manner andwithout pre recorded http traffic .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
feedback directed test generation.
the dynamic feedback restler uses to prune invalid requests from the search space line in figure is similar to the feedback used in randoop .
however the randoop search strategy in particular search pruning and ordering is different from the three search strategies considered in our work and the randoop optimizations related to object equality and filtering are not relevant in our context.
restler s dependency analysis is also related to the analysis of type dependencies performed by the randoop algorithm for typed object oriented programs.
however unlike in the randoop work dynamic objects in swagger specifications are implicitly declared and untyped e.g.
authentication tokens or service specific resources .
when a swagger specification is not complete or restler cannot infer object types correctly restler supports annotations see section vii that the user can use to fix and control restler s behavior.
in the future it would be interesting to allow richer user annotations in order to easily specify complex service specific types as well as their properties in the spirit of code contracts .
model based testing.
our bfs fast search strategy is inspired by test generation algorithms used in model based testing whose goal is to generate a minimum number of tests covering say every state and transition of a finite state machine model e.g.
see in order to generate a test suite to check conformance of a blackbox implementation with respect to that model.
bfs fast is also related to algorithms for generating tests from an input grammar while covering all its production rules .
indeed in our context bfs fast provides by construction a full grammar coverage up to the given current sequence length.
the number of request sequences it generates is not necessarily minimal but that number was always small hence manageable in our experiments so far.
grammar based fuzzing.
general purpose grammar based fuzzers like peach and spike among others are not swagger specific but can also be used to fuzz rest apis.
with these tools however the user has to manually construct an api specific input grammar often encoded directly by code specifying what and how to fuzz similar to the code shown on the right of figure .
by contrast restler automatically generates an input grammar from a swagger specification and its fuzzing rules are determined separately and automatically by the algorithm of figure .
automatically learning input grammars from input samples is another complementary research area .
restler currently relies on a swagger specification to represent a service s input space and it learns automatically how to prune invalid request sequences by analyzing service responses.
still a swagger specification could be further refined given representative unit tests or live traffic in order to focus the search towards specific areas of the input space.
for rest services without a swagger specification it would be worth investigating how to automatically infer it by using machine learning on runtime traffic logs or static analysis on the code implementing the api.
whitebox fuzzing.
grammar based fuzzing can also be com bined with whitebox fuzzing which uses dynamic symbolic execution constraint generation and solving in order to generate new tests exercising new code paths.
in contrast restler is currently purely blackbox the inner workings of the service under test are invisible to restler which only sees rest api requests and responses.
since cloud services are usually complex distributed systems whose components are written in different languages general symbolic execution based approaches seem problematic but it would be worth exploring this option further.
for instance in the short term restler could be extended to take into account alerts e.g.
assertion violations reported in back end logs in order to increase chances of finding interesting bugs and correlating them to specific request sequences.
penetration testing.
in practice the main technique used today to ensure the security of cloud services is the so called penetration testing or pen testing which means security experts review the architecture design and code of cloud services from a security perspective.
since pen testing is labor intensive it is expensive and limited in scope and depth.
fuzzing tools like restler can partly automate the discovery of specific classes of security vulnerabilities and are complementary to pen testing.
ix.
c onclusion restler is the first automatic tool for stateful fuzzing of cloud services through their rest apis.
while still in early stages of development restler was able to find bugs in gitlab and several bugs in each of the four azure and office365 cloud services tested so far.
although still preliminary our results are encouraging.
how general are these results?
to find out we need to fuzz more services through their rest apis and check more properties to detect different kinds of bugs and security vulnerabilities.
indeed unlike buffer overflows in binary format parsers use after free bugs in web browsers or cross site scripting attacks in web pages it is still unclear what security vulnerabilities might hide behind rest apis.
while past human intensive pen testing efforts targeting cloud services provide evidence that such vulnerabilities do exist this evidence is still too anecdotal.
new automated tools like restler are needed for more systematic answers.
how many bugs can be found by fuzzing rest apis?
how security critical will they be?
this paper provides a clear path forward to answer these questions.
x. a cknowledgements we thank william blum dave tamasi and david molnar for their helpful comments and the whole microsoft security risk detection team for their support.
we also thank albert greenberg mark russinovich and john walton from microsoft azure for encouraging us to pursue this line of work.
finally we thank the gitlab and microsoft developers we interacted with for graciously acknowledging discussing and fixing the bugs found during this work.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.