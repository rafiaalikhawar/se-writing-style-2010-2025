parallel bug finding in concurrent programs via reduced interleaving instances truc l. nguyen peter schrammely bernd fischerz salvatore la torrex gennaro parlato university of southampton uk trucnguyenlam gmail.com gennaro ecs.soton.ac.uk yuniversity of sussex uk p.schrammel sussex.ac.uk zstellenbosch university south africa bfischer cs.sun.ac.za xuniversit a degli studi di salerno italy slatorre unisa.it abstract concurrency poses a major challenge for program verification but it can also offer an opportunity to scale when subproblems can be analysed in parallel.
we exploit this opportunity here and use a parametrizable code to code translation to generate a set of simpler program instances each capturing a reduced set of the original program s interleavings.
these instances can then be checked independently in parallel.
our approach does not depend on the tool that is chosen for the final analysis is compatible with weak memory models and amplifies the effectiveness of existing tools making them find bugs faster and with fewer resources.
we use lazy cseq as an off the shelf final verifier to demonstrate that our approach is able already with a small number of cores to find bugs in the hardest known concurrency benchmarks in a matter of minutes whereas other dynamic and static tools fail to do so in hours.
index terms verification concurrency sequentialization swarm verification i. i ntroduction processor development has reached the point where clock speeds can no longer be increased easily but processors contain multiple cores that work in parallel.
therefore to achieve higher performance software must necessarily be concurrent.
unfortunately developing correct scalable and efficient concurrent programs is a complex and difficult task due to the large number of possible concurrent executions that must be considered.
modern multi core processors and weak memory models wmms make this task even harder as they introduce additional executions that confound the developers reasoning.
due to these complex interactions concurrent programs often contain bugs that are difficult to find reproduce and fix.
existing automatic bug finding techniques and tools are not effective when facing concurrent programs.
they struggle particularly with programs that contain rare concurrency bugs i.e.
programs where only a few specific interleavings violate the specification.
for techniques that analyze executions explicitly finding rare bugs is like looking for a needle in a haystack.
for techniques that analyze all executions collectively using symbolic representations finding rare bugs is also challenging due to the large amount of memory required for the analysis.
as a result we currently do not have techniques and tools that can reliably find such rare bugs.
partially supported by epsrc grants no.
ep m008991 and no.
ep p022413 and miur farb grants.although concurrency is clearly a problem for reasoning about programs it also offers a chance to scale up verification as suggested by holzmann et al.
.
.
.
to scale applications of logic model checking to larger problem sizes then we must be able to leverage the availability of potentially large numbers of processors that run at relatively low speed.
different approaches have been tried out to achieve this leveraging with varying degrees of success.
in truly distributed algorithms multiple processors are running the same algorithm jointly on the same problem and periodically exchange information.
however verification using distributed model checking techniques e.g.
has had limited success because they need to share too much information leading to high communication overheads and contention.
instrategy competition multiple processors are running different variants of the same underlying algorithm independently i.e.
without exchanging information on the same problem the first variant that produces a definitive answer i.e.
counterexample or proof wins and aborts the others.
this exploits the fact that complex search procedures such as model checkers sat solvers or first order theorem provers have many control parameters and strategies that can be used to explore different parts of the search space.
holzmann et al.
have applied this idea in swarm verification to scale up model checking based on explicit state space exploration.
more specifically their approach is to spawn a large number of instances the swarm of the spin model checker each with different parameters and search strategies each instance runs an incomplete search but in aggregate the swarm substantially outperforms an exhaustive search.
in this paper we propose a different approach called task competition we run the same algorithm on multiple processors again in competition without information exchange but now on different andeasier verification tasks derived from the original problem.
specifically each task captures a subset of the program s interleavings under analysis in a way that each of such interleavings is captured by at least one of these tasks.
thus for programs with rare concurrency bugs most tasks do not contain a bug.
however in tasks that do the bugs are generally more frequent i.e.
manifest in a higher fraction of the interleavings than in the original program.
consequently bugs can be found faster and with fewer resources because the individual tasks are simpler and can be analyzed in parallel .
c ieeease urbana champaign il usa technical research753 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
each with a shorter time out and a smaller memory.
we develop and evaluate this approach under a bounded context switch analysis where only interleavings with up to k context switches for a given k are explored.
this choice is justified by an empirical study which shows that most of the concurrency bugs manifest themselves within a small number of context switches .
we use a code to code translation to derive the tasks as variants of the original program by splitting the code of each thread into fragments tiles and allowing context switches only in some of them.
by selecting dk 2etiles in all possible ways we thus ensure the coverage of all interleavings up to kcontext switches.
our approach offers a number of advantages.
first since it is using code to code translations it is agnostic of the underlying verification techniques and tools existing bugfinding tools can be reused as is and while we have achieved very good results using bounded model checking bmc techniques in particular lazy cseq it can also be used with other symbolic analysis techniques explicit state space exploration techniques or even testing.
second our approach amplifies the effectiveness of existing bug finding tools.
we empirically demonstrate that it is particularly effective for symbolic methods it reduces the memory consumption and run time of each individual verification task containing a bug and also leads to a considerable reduction in time for the global verification.
we show a substantial reduction in the wall clock times required to find a bug in some very difficult problems from hours using a single instance of lazy cseq the only tool capable of finding the underlying bugs down to minutes using lazy cseq on a modest number of processors.
looking at this from an opposite perspective our approach enables existing tools to find rare bugs that were previously out of their reach.
third our approach also is oblivious of the assumed memory model and therefore also works for wmms as long as the underlying analysis tool supports their semantics.
moreover our experiments demonstrate that the approach is also effective for reducing the additional verification complexity introduced by relaxed consistency semantics.
finally our approach is tuneable.
the verification complexity of each of the instances generally depends on the underlying analysis tool and number of interleavings captured by each instance.
from our experience instances with roughly the same number of interleavings have similar verification times.
thus we empirically learn the number of interleavings per instance that the underlying tool can effortlessly handle and then generate all the instances to capture all interleavings according to a fixed schema.
however the number of instances to generate can be extremely high.
we empirically show that using only a few instances selected at random still enables us to find rare bugs.
in our experiments we demonstrate that we only have to consider a few instances out of millions or billions to find bugs with high probability.
contributions.
in summary in this paper we make three main contributions.
first we propose a new swarm verification approach for the analysis of concurrent programs that isbased on a code to code translation and leverages the power of sequential analysis engines.
second we implement the approach as an extension to lazy cseq.
third we report the results of an evaluation of our approach on the two hardest known concurrency benchmarks safestack andeliminationstack for three different memory models sc tso pso .
organization of the paper.
in the next section we give a highlevel overview of our approach.
sections iii and iv describe our code to code translation.
section v gives details on our implementation and section vi presents the results of our experimental evaluation.
section vii compares with related work and section viii concludes.
ii.
a pproach we consider multi threaded programs where threads communicate through shared memory for example a c program that uses the posix threads library for concurrency .
as in bounded model checking we first flatten the program by inlining functions and unrolling loops up to a given bound.
the resulting bounded program say p consists of a finite number of threads the control in each thread can only move down in the code.
the goal of the analysis is to find an assertion violation of pthat may occur through an execution that involves at most kcontext switches for a given k .
let kbe a small natural number denoting the maximum number of context switches to consider along an execution and tbe the set ofp s threads.
we denote with ik p the set of all executions that pcan exhibit with at most kcontext switches.
a. splitting computations with tilings our goal is to define a code to code translation for p parameterized over k that generates a set of simpler program variants each capturing a subset of p s executions such that each ofp s executions involving at most kcontext switches is captured by at least one of them.
the resulting variants can then be checked independently in parallel.
we construct these variants by building on the notion of tiling.
a tiling of a thread t2tis a partition of t s statements.
each element of a tiling is called tile.
for example consider fig.
.
the program has two threads with respectively seven a .
.
.
g and five h .
.
.
l statements and the tiling of each thread is marked with the braces.
a tiling of a program pis a set of thread tilings one for each thread of p. let p f tgt2tbe a tiling of p. az selection of pis a set f tgt2twhere t tcontains exactly ztiles.
we build the variants as follows.
for a given tiling pof pand any of its z selections f tgt2t we construct a program variant p ofpobtained by instrumenting pin a way that each thread tcan only be preempted at statements belonging to the tiles of tand at any other blocking statement oft in order to allow an execution to continue when a statement is blocked and there are other threads that are ready to execute .
consider again fig.
.
if we take the selection corresponding to selecting tiles and the executions ofp are of the form uvw where uis any interleaving of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
thread 0f a b c d e f g gthread 1f h i j k l g fig.
.
tiling example a bandh i ifuends with b thenv c .
.
.
g andw jk l ifuends with i thenv j k l andw c .
.
.
g. for example a b h .
.
.
l c .
.
.
g anda h i b c .
.
.
g j kldenote possible executions of p .
we observe that the set of executions over all the variants p with being adk 2e selection of p that contain at most kcontext switches is exactly the set ik p .
in fact every execution of a variant p ofpis also an execution of p sincep by construction is the same as p except that we forbid context switches to occur at some points.
vice versa any execution ik p can context switch out of each thread at mostdk 2etimes thus it suffices to select dk 2etiles per thread to capture .
therefore is an execution of some variantp for adk 2e selection .
b. overall approach the verification approach works in two phases.
we first generatep s variants according to any selection of an input tiling.
we then search for bugs in each of the resulting program variants typically in parallel using an off the shelf analyzer such as a testing tool or a model checker.
the analysis phase can be stopped as soon as a bug is found in one of the program variants.
the overall scheme is shown in fig.
in the following we sketch the two phases in turn.
instance generation the first phase is composed of a chain of code to code transformations of the input multithreaded program.
the first module transforms this program into a bounded multi threaded program pthat is syntactically guaranteed to terminate after a bounded number of transitions by applying standard bmc program transformations such as inlining the functions and unwinding the loops up to a given bound .
pthus has a different function associated with each thread we refer to these as thread functions.
the second module injects numerical labels at each visible statement of the thread functions i.e.
at the beginning and end of the function before each access to the shared memory and before each call to a thread synchronization primitive of p. in each thread function the labels start at zero and increase consecutively in statement order we assume that any other label of the program is non numerical.
this labeling simplifies the code injected by the third module for the tile selection.the third module instruments the code with guarded commands that at each numerical label enable disable contextswitchs and statement reordering.
this control flow code is used by the next module to imprint the tile selection in the code.
a detailed description of the translation by this module is given in section iv.
the fourth and last module generates the variants of p according to any z selection of the input tiling p where zis the value of the input parameter tiles .
this is done by triggering the guards injected by the previous module.
note that the number of different program variants generated this way is finite but can be large.
therefore we consider a randomized version of this module along with a new input parameter the number nof instances to be generated.
the n instances are generated by randomly choosing the z selections.
this also introduces a loop in our verification approach we repeat the random generation of nnew variants until either a bug is found or all the variants are generated.
verification cluster since the generated instances can be analyzed independently we can achieve in our scheme a high diversification and parallelism of the analysis each instance can be analyzed on a separate core and possibly using a different tool for concurrent program analysis.
iii.
s hared memory multi threaded programs our implementation can handle the full c language see section v but we describe our approach for multi threaded programs in a simple imperative language.
this features dynamic thread creation thread join and mutex locking and unlocking operations for thread synchronization.
thread communication is implemented via shared memory and modelled by global variables.
all threads share the same address space they can write to or read from global variables of the program to communicate with each other.
we assume that each statement is atomic as it is always possible to decompose a statement into a sequence of statements each involving at most one access to the shared memory .
a. syntax the syntax of multi threaded programs is defined by the grammar shown in fig.
.
terminal symbols are set in typewriter font.
notation hnti represents a possibly empty list of non terminals nthat are separated by terminals t xdenotes a local variable ya shared variable ta thread variable and pa procedure name.
all variables involved in a sequential statement are local.
we assume expressions eto be local variables integer constants that can be combined using mathematical operators.
boolean expressions bcan be true orfalse or boolean variables which can be combined using standard boolean operations.
amulti threaded program consists of a list of global variable declarations i.e.
shared variables followed by a list of procedures.
each procedure has a list of zero or more typed parameters and its body has a declaration of local variables followed by a statement.
a statement is either a simple statement or a compound statement i.e.
a sequence authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
splitunwindinline bugno buginstance generator verification cluster programinst inst nanalyzer analyzer nnumerical labelsinstrument tiling tilesfig.
.
verification approach.
p dec typep hdec i dec stm dec typez type booljintjvoid stm sstmj hstm i sstm seqjconcjl sstm seq assume b jassert b jx ejp he i jreturnejif b then stm else stm jwhile b dostmjgotol conc x yjy xjt createp he i jjointjinitmjlockm junlockmjdestroym fig.
.
syntax of multi threaded programs.
of statements enclosed in braces.
a simple statement is either a labeled simple statement or a sequential statement or a concurrent statement.
asequential statement can be an assume or assertstatement an assignment a call to a procedure that takes multiple parameters with an implicit call by reference parameter passing semantics a return statement a conditional statement a while loop or a jump to a label.
local variables are considered uninitialized right after their declaration which means that they can nondeterministically take any value from their type domains until they are explicitly set by an assignment statement.
we also use the symbol to denote the expression that nondeterministically evaluates to any possible value with x we then mean that xis assigned with any possible value of its type domain.
aconcurrent statement can be a concurrent assignment a call to a thread routine such as a thread creation a join or a mutex operation i.e.
init lock unlock and destroy .
a concurrent assignment assigns a shared resp.
local variable to a local resp.
shared one.
unlike local variables global variables are always assumed to be initialized to a default value.
for the sake of simplicity we assume that the default valuealways 0regardless of the variable type.
a thread creation statementt createp e1 e n spawns a new thread from procedure pwith expressions e1 e nas arguments.
a thread join statement joint pauses the current thread until the thread identified by tterminates its execution i.e.
after the thread has executed its last statement.
lock and unlock statements respectively acquire and release a mutex.
if the mutex is already acquired the lock operation is blocking for the thread i.e.
the thread is suspended until the mutex is released and can then be acquired.
we assume that a valid program psatisfies the usual wellformedness and type correctness conditions.
we also assume thatpcontains a procedure main which is the starting procedure of the only thread that exists in the beginning.
we call this the main thread.
we further assume that there are no calls to main inpand that no other thread can be created that uses main as starting procedure.
b. semantics as common a program configuration is a tuple of configurations of each thread that has been created and has not yet terminated along with a valuation of the global variables.
a thread configuration consists of a stack which stores the history of positions at which calls were made along with valuations for local variables and the top of the stack contains the local and global valuations and a pointer to the current statement being executed.
the behavioral semantics of a program pis obtained by interleaving the behaviors of its threads.
at the beginning of any computation only the main thread is ready andrunning.
at any point of a computation only one of the ready threads isrunning.
a step is either the execution of a step of the running thread or a context switch that nondeterministically replaces the running thread with one of the ready ones that thus becomes the running thread at the next step.
a thread will no longer be available when its execution is terminated i.e.
there are no more steps that it can take.
iv.
c ode to code translation in this section we give a formal description of the code instrumentation done by module instrument in fig.
.
for the sake of better presentation in the following in order to enable disable context switches in the code we consider a semantics in the style of preemptive asynchronous programs authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
s dec typepi hdec i dec stm i n def bool yields ffa0 a0 a0 h 1g fan an an h 1gg dec typepi hdec i dec jstmki i n jstmkidef jsstmkij hjstm ki i jsstmkidef seqjconcjjl sstmki jl sstmkidef l if yields yield jsstmki iflis numerical l jsstmki otherwise fig.
.
formal description of the code to code translation by module instrument.
with nondeterministic scheduler.
in particular we augment the concurrent statements of the syntax from fig.
with a yieldstatement i.e.
we add the rule conc yield and restrict the context switches to occur only if explicitly invoked via a yield statement which thus causes the control to return to the nondeterministic scheduler .
in the following we will refer to this class of programs as extended preemptive asyncronous programs epa programs for short .
it is straightforward to show that given a multi threaded programpunder the syntax and semantics of section iii we can easily obtain an equivalent program p0under syntax and semantics sketched above by simply inserting a yieldstatement guarded by a nondeterministic guess in front of each statement of p. moreover as we are interested only in reachability of program locations or assertion failure checking such as in standard bug finding analysis it is sufficient to account only for context switches that occur at visible statements i.e.
the concurrent statements and each thread s first and last statements .
we recall that we assume that all the labels of the original multi threaded program must be non numerical and that after the code to code translation by modules inline unwind and numerical labels we get that the code of each thread is all contained within the same procedure i.e.
there are no procedure calls and there are no loops and the visible statements are all labeled with a numerical label such that in each thread code labels start from 0and increase by according to the statement order.
in module instrument we thus rewrite the code by inserting a guarded yield statement after each numerical label.
guards are triggered by input boolean parameters we use ai lto activate the yield statement at the numerical label lof thread i. these parameters are assigned to a boolean array yields.
after the instrumentation the portion of code l sstm of threadi where lis a numerical label is thus if yields yield sstm the rest of the code stays unchanged.
we formally give our code to code translation in fig.
asrewrite rules over the syntax of programs.
in the figure we have denoted with nthe number of threads and with hthe maximum number of numerical labels over all threads.
we observe that whenever yields holds by the choice operator the yield statement is nondeterministically executed or not.
this can be used to select in the code the points where context switches can happen.
thus the following module split see fig.
will assign the array yields accordingly to a valid selection for the input tiling and blocking statements.
v. i mplementation we have implemented the verification approach illustrated in fig.
to analyze concurrent c programs that use the concurrency library posix threads.
we optimize the tilings by taking into account only statements at which contextswitches can occur which correspond to numerical labels.
for the instance generation we use uniform window tilings i.e.
tilings where all tiles have the same number of numerical labels except for the last one that can have fewer and all tiles correspond to contiguous sections of a thread s code.
for example the tiling from fig.
is not uniform though tiles cover contiguous portions of code.
theinstance generator is written as an independent component that takes as input a multi threaded program pwith assertions the unwinding bound the size tof each tile i.e.
the number of numerical labels the number s of tiles to select from each thread and the number nof randomly chosen instances to generate.
the pool of bounded epa programs generated by the instance generator is then verified on a cluster of computers with a modified version of the symbolic verification tool lazy cseq .
below we provide more details on our implementation of theinstance generator the verification tool and the cluster.
a. instance generator our tool v erismart1 verification smart builds upon the cseq framework and is composed of a chain 1verismart is publicly available at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of software modules that matches the chain of modules of the instance generator from fig.
.
we recall that cseq is a framework that comprises several software modules implementing standard source to source transformations of c programs.
we re use cseq modules to implement the modules inline unwind andnumerical labels.
for instrument we have realized a new software module that implements the code to code translation detailed in section iv.
it is written in python and uses the ast built by pycparser2on the fetched program to implement the rewriting rules of fig.
.
the last module split is also written in python.
it generates each instance by randomly selectingstiles per thread by setting to true the corresponding entries of the array yields entries corresponding to blocking statements are always set to false .
this module also takes an additional parameter that allows to bound the number of generated instances.
in our setting we manually allocate the resulting instances to several verification units that are analyzed independently.
the code of v erismart is publicly available at http users.ecs.soton.ac.uk gp4 cseq and can be used in combination with different bug finding analysis tools for experimenting with the verification approach proposed in this paper.
b. backend verification tool lazy cseq is a symbolic bug finding tool for multithreaded programs based on sequentialization and bounded model checking.
the multi threaded input program is translated into a corresponding sequential program up to a given number of rounds of execution where in each round each thread is executed exactly once according to a fixed ordering.
the resulting sequential program is then verified using existing verification tools for sequential programs.
we modify lazy cseq to account for the syntax and the semantics of epa programs.
essentially we extend the parsing for handling also the yield statement and then adjust the code to code translation such that in the resulting sequential c program the context switches are now simulated only at theyield statements according to the semantics of the epa programs.
in the following we refer to this modified version of lazy cseq as epa lazy cseq.
in our experiments we use the c bounded model checker cbmc3v5.
as sequential backend for lazycseq and epa lazy cseq.
cbmc encodes symbolically the multiple execution paths of the input program which is then checked by a sat smt solver.
if the formula is satisfiable there is a definite execution path that leads to an assertion violation.
in this case the sat smt solver returns the values of the variables along this execution path.
from these values which in particular include the input values and the encoded context switch points a test can be constructed and executed in order to debug the reason for the assertion violation.
if the formula is unsatisfiable then there is no execution that violates any of the assertions up to the considered 2pycparser 3cbmc the formula is generated by symbolically executing the program while encoding the control flow structure into additional boolean variables.
the formula is linear in the size of the program but implicitly encodes a potentially exponential number of execution paths.
hence unlike pathwise enumeration approaches this approach avoids explicitly enumerating a potentially exponential number of execution paths and maximizes the exploitation of today s optimized sat solvers.
lazy cseq was initially developed for c program running under the sc semantics.
it has been recently extended to handle wmm semantics such as tso and pso .
our modification are also compatible with these extensions.
in our experiments we only use epa lazy cseq for the analysis carried out on the cluster.
our choice has been motivated by the effectiveness of lazy cseq for complex benchmarks containing rare bugs.
vi.
e xperiments here we report on a large number of experiments that we have conducted to demonstrate the effectiveness of the proposed approach.
it turns out that v erismart improves the performance of lazy cseq by achieving more than 1000x speed up already with few cores on some benchmarks that are hard to analyze.
a. benchmarks our first effort was to identify suitable benchmarks that present a non trivial challenge for concurrency bug finding tools.
the widely used concurrency benchmarks from the software verification competition sv comp are too easy several tools can quickly find the bugs in all buggy benchmarks lazy cseq requires .
seconds on average.
we have instead considered several concurrency benchmarks from the literature including the sct benchmarks5 .
from these we discarded all parametric benchmarks whose complexity comes simply from artificially increasing the number of threads e.g.
cs.reorder n bad and cs.twostage n bad where nis the number of threads or the size of the data structures e.g.
the work stealing queue since their bugs can already be exposed with smaller instances.
we further discarded all benchmarks that lazy cseq can solve in less than seconds this includes several benchmarks that are traditionally considered to be hard e.g.
dcas .
similarly to the sv comp benchmarks our experiments showed that there is no significant performance difference between lazy cseq and v erismart in some sense these benchmarks are too simple to benefit substantially from the v erismart approach.
we therefore do not 4for the hardest benchmark fibonacci lazy cseq required less than seconds but this is an atypical artificial example specifically crafted to require a high number of context switches in a small program visible statements in two threads each which is smaller than our usual tile size so that there is no difference to v erismart .
for four other benchmarks lazy cseq requries between and seconds here v erismart performs similarly.
for the majority of the simple benchmarks v erismart pays a small wall clock time penalty due to the transformation overhead.
5sct benchmarks authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
report further details for these benchmarks.
this leaves us with two benchmarks that both come from the domain of concurrent data structures.
eliminationstack is a c implementation of hendler et al.
s elimination stack that follows the original pseudocode presentation.
it augments treiber s stack with a collision array used when an optimistic push or pop detects a conflicting operation the collision array pairs together concurrent push and pop operations to eliminate them without affecting the underlying data structure.
this implementation is incorrect if memory is freed in pop operations.
in particular if memory is freed only during the elimination phase then exhibiting a violation an instance of the infamous aba problem requires a seven thread client with three push operations concurrent with four pops.
to witness the violation the implementation is annotated with several assertions that manipulate counters as described in .
lazy cseq is the only tool we are aware of that can automatically find bugs in this benchmark and requires almost hours and gb of memory to find a bug.
safestack is a real world benchmark implementing a lock free stack designed for weak memory models.
it was posted to the chess forum7by dmitry vyukov.
this benchmark is unique as it contains a very rare bug that requires at least three threads and five context switches to get exposed when running under the sc semantics whereas it requires only four context switches when running under tso or pso.
in the verification literature it was shown that real world bugs require at most three context switches to manifest themselves .safestack for this reason presents a nontrivial challenge for concurrency testing and symbolic tools.
lazy cseq is the only tool we are aware of that can automatically find these bugs it takes almost hours to find these bugs and consumes more than gb of memory.
b. experimental set up in our experimental evaluation we compare v erismart against lazy cseq v1.
.9the results are summarized in fig.
.
for both tools we use the minimum number of unwindings and rounds of computation that are required to expose the bug in the original program by lazy cseq the exact values for these parameters are reported in fig.
for each considered benchmark.
we also report the number of the threads involved in the computation and the number of visible points in each of those threads.
for lazy cseq the results for the comprehensive verification are given in the leftmost columns of fig.
.
under 6it is hardly surprising that lock free programming is an important source of truly concurrently complex benchmarks since the focus there is to minimize the amount of synchronization for performance optimization thus generating a large amount of nondeterminism due to interleaving.
en us 91c1971c 519f 4ad2 816d 149e6b2fd916 bug with a context switch bound ?forum chess 8the tool relacy can find a bug in a modified version of safestack where an explicit pthread yield call has been added to help the search.
in our experiments on the plain safestack benchmark used here relacy was not able to detect a bug within one million iterations.
9cseq framework schedules we report the verification time and memory consumption when all interleavings are analyzed in one attempt.
we also estimate the sequential complexity of the benchmarks as the average performance to analyze them given one fixed schedule.
this gives us an estimated lower bound for the analysis of each of the tasks generated by verismart .
for this we have considered randomly selected interleavings.
we report the computed average time and memory consumption in fig.
under one schedule .
for v erismart see fig.
again we select as many tiles per thread as the number of rounds required to expose the bug in each of the considered benchmark this ensures that the bug can in principle be found.
we use a uniform window tiling with three different tile sizes to evaluate the effect of tiling.
for each benchmark and tile size we then analyze program variants with the timeout given in fig.
these variants are generated by randomly selecting the tiles.
we report the minimum the maximum the average and the standard deviation over the verification time and memory consumption of all the buggy variants.
we also report the percentage of the buggy variants.
we also estimate for each considered benchmark and setting using the data collected in the v erismart experiments described above how the expected bug finding time varies as the number nof cores increases.
we thus randomly draw sets ofnvariants containing at least one with a bug and compute the the minimum time to find a bug over this set.
we then plot the expected bug finding time for values of nup to see fig.
.
here a round resp.
square point marks the expected number of cores required find a bug with probability .
resp.
.
and the corresponding expected time.
we carried out our experiments on a cluster with compute nodes equipped with dual .
ghz intel sandybridge processors.
each compute node has cpus with gb of physical shared memory running bit linux .
.
.
on each cpu of a node we run epa lazy cseq over a single verification task produced by the instance generator with the timeout given in fig.
.
c. experimental results fig.
and give detailed results of our experiments the safestack tso results are summarized in the text.
as expected the results for the comprehensive verification using lazy cseq show that both benchmarks are very hard under sc.
the relation between the numbers for one schedule and all schedules respectively shows that the complexity comes from the interleavings.
less expectedly with lazycseq requiring seconds and .
gb of memory to find a bug in safestack tso they also show that wmms can actually make it easier to find bugs as both runtime and memory requirements go down.
this is a consequence of both the lower number of rounds required to expose the bug and the higher number of buggy executions that the wmms allow.
the main part of fig.
shows the v erismart results for the different tile sizes.
we focus on the sc benchmarks first and defer the discussion of wmm benchmarks to below.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
eliminationstack sc unwind rounds thread visible point comprehensive verification verismart tiles per thread time memory tile size timeout .5hrs tile size timeout 2hrs tile size timeout 3hrs verification time memory verification time memory verification time memory one schedule .
.1min .
.
min .
.
min .
.
max .
.
max .
.
max .
.
all schedules .9average .
.
average .
.
average .
.
deviation .
.
deviation .
.
deviation .
.
instances with bug .
instances with bug .
instances with bug .
safestack sc unwind rounds thread visible point comprehensive verification verismart tiles per thread time memory tile size timeout 1hr tile size timeout 1hr tile size timeout 4hrs verification time memory verification time memory verification time memory one schedule .
.1min .
.
min .
.
min .
.
max .
.
max .
.
max .
.
all schedules .4average .
.
average .
.
average .
.
deviation .
.
deviation .
.
deviation .
.
instances with bug .
instances with bug .
instances with bug .
safestack pso unwind rounds thread visible point comprehensive verification verismart tiles per thread time memory tile size timeout .5hrs tile size timeout .25hrs tile size timeout 3hrs verification time memory verification time memory verification time memory one schedule .
.8min .
.
min .
.
min .
.
max .
.
max .
.
max .
.
all schedules .4average .
.
average .
.
average .
.
deviation .
.
deviation .
.
deviation .
.
instances with bug .
instances with bug .
instances with bug .
fig.
.
v erismart experiments each experiment is carried out using instances chosen randomly.
the verification is done using lazy cseq .
for all schedules and epa lazy cseq for the program variants.
for each experiment we report the minimum the maximum the average and the standard deviation over the verification time and memory consumption of all the buggy variants.
time is given in seconds and memory in mb.
for sc we see the best case resource consumption required to expose a bug in any of the generated instances drops dramatically the best instances expose the bugs 100x to 1000x faster with only to of the memory.
the relative numbers of buggy instances are very favorable and can be improved even further by increasing the tile sizes.
these increased odds come at modest costs average times to expose the bugs increase 2x 3x while average memory consumption remains roughly stable.
taken together this means that we only need to analyze a small number less than and in many cases less than of relatively simple average times to find the bugs between minutes and one hour problems to find a bug with probability approximating see fig.
.
forsafestack pso the results appear at first less impressive.
while the best case bug finding times still represent a roughly 5x speed up the average times are closer to and in some times even exceed the comprehensive analysis times.
however the high fraction of buggy instances roughly allows us to play the numbers game to achieve a good overall performance.
if we run a moderate number say of tasks in parallel we will with high probability since the distribution of the bug finding times exhibits a log normal shape also come across one of the faster tasks which will abort the remaining slower tasks giving us wall clock speedups roughly similar to the best cases.
finally for safestack tso none of the tasks generated with three selected tiles exposes a bug within thegiven timeouts despite the fact that this already represents hours cpu time .
since the experimental set up means we are only looking for bugs that occur only under tso but not under sc we can clearly see that the tso only bug is extremely rare.
in such cases v erismart is unable to leverage the effectiveness of the underlying analysis tool and suffers from the same explosion of the search spaces as other sampling based methods such as testing or explicit state model checking.
here symbolic methods that analyze all behaviors simultaneously have the upper hand as demonstrated by lazycseq s ability to expose the tso only bug.
since the generated problem instances are completely independent and can be analyzed in parallel v erismart is indeed a very effective verification approach.
fig.
shows that with moderate resources cores we can get a noticeable speed up on the expected bug finding time.
in particular for eliminationstack sc the expected time is roughly the same as the minimum time already for few cores and reaches a more than 1000x speed up compared to the all schedule comprehensive verification time.
in general fig.
shows that the expected bug finding time converges faster to the minimum time when the probability of finding a buggy program variant is higher.
since larger tiles would ensure higher probability of finding a buggy variant but at the same time could affect the verification time determining the right tile size seems to be a crucial aspect for maximizing the benefits of our approach.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
all schedules t ime 46764s memory .9mb number of coresexpected b ug finding time second eliminationstack sc unwind rounds thread visible point tile size tile size minimum time allschedules t ime 24139s memory .4mb number of coresexpected b ug finding time second safestack sc unwind rounds thread visible point tile size tile size minimum time allschedules t ime 4777s memory .4mb number of coresexpected b ug finding time second safestack pso unwind rounds thread visible point tile size tile size minimum time fig.
.
expected bug finding time varying over the number of cores.
a round resp.
square point marks the expected time corresponding to the number of cores that are needed to find a bug with probability .
resp.
.
.vii.
r elated work there is a wide range of approaches proposed in the literature on automatic analysis of concurrent programs.
here we briefly describe the related work and compare it to the work presented in this paper.
parallel verification attempts to parallelize verification by partitioning the problem and distributing the workload have been implemented in explicit state model checking and sat solving .
with the rise of multi core processors techniques that exploit shared memory for communication have been proposed .
however these approaches suffer from the overhead introduced by exchanging information between the instances.
approaches that run several tools with different strategies and heuristics in parallel on the unpartitioned problem have been more successful.
such portfolio approaches have been implemented in automated theorem provers and sat smt solvers .
our approach leverages so called swarm verification sv as promoted by holzmann et al for explicit state model checking .
in sv computing instances do not collaborate directly in finding a solution but solve independent subproblems that cover the original problem.
we lift this idea to symbolic model checking through sequentialization.
sequentialization reducing the analysis of a concurrent program to the analysis of sequential programs was first proposed by qadeer and wu .
they transform a concurrent program into a sequential one that simulates all executions of the original program with at most two context switches.
lal and reps generalized the concept to arbitrary context bounds.
in our experiments we used lazy cseq which implements a sequentialization as a code to code translation that is efficiently analyzable by sequential bounded model checking tools such as cbmc .
musuvathi and qadeer propose an algorithm for iteratively relaxing the context bound.
this is orthogonal to our approach in our experiments we fixed the maximum number of contextswitches and analysed tilings of three different sizes.
we could consider their algorithm as a starting point to automatically find good parameter values for our tilings.
concolic testing concolic testing combines symbolic aspects with concrete inputs.
namely it runs the program over an input vector with both concrete and symbolic values and uses smt solvers to compute new input vectors that systematically explore the branches of the program.
farzan et al extend this idea to concurrent programs and call it con 2colic testing.
they use the notion of thread interference scenario which is a representation of a set of bounded interferences among the threads which define the scheduling constraints for a concurrent program run.
these interference scenarios are then explored in a systematic way by generating a schedule and input vectors that conform with the scenario.
con 2colic testing analyzes the program sequentially and accumulates information about explored scenarios in a data structure whereas our approach is capable of analyzing tilings independently and can thus be parallelized at large scale.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
moreover con 2colic testing requires to modify the core of a concolic testing tool in order to handle concurrent programs and thus it cannot flexibly leverage the increasing power of existing sequential checkers.
testing automated testing tools such as chess have been highly successful for finding concurrency bugs in large code bases because of their ability to handle code independently of its sequential complexity.
chess controls the scheduler and explores all possible interleavings giving priority to schedules with few context switches.
nonetheless the success of testing depends on the proportion of schedules that lead to a bug w.r.t.
the total number of schedules as shown by a recent empirical study on testing of concurrent programs.
preemption sealing consists of inhibiting preemptions in some program modules which corresponds in our approach to choose a tiling where tiles exactly correspond to program modules.
this strategy was aimed to tolerating errors for finding more ones and compositional testing of layered concurrent systems.
the uniform tiling we implement in this paper is irrespective of the structure of the program and looks more appropriate for an exhaustive bug finding search up to a given number of context switches.
there are also differences in the implementation of the two techniques we do not seal portions of code with scope functions but rather we implement tiles statically that in general makes the underlying bmc analysis simpler.
other testing tools try to mutate observed interleavings to find bugs e.g.
.
our approach can be seen as a way to tune concurrency verification between concrete testing and fully symbolic verification.
viii.
c onclusions and future directions we have presented a swarm approach for finding bugs in concurrent programs.
we perform a code to code translation that constructs program variants by placing tiles over the threads and thus reducing nondeterminism by allowing context switches to occur only in a selected subset of tiles and inhibiting statement reordering in other selected ones.
the set of possible program variants defined by a tiling covers all possible interleavings of the concurrent programs.
we can analyze these program variants in parallel on a cluster using any off the shelf backend tool.
we implement the approach building on the cseq framework and use lazycseq with cbmc backend for the final analysis.
we experimentally show that we can find bugs in very hard concurrency benchmarks eliminationstack andsafestack under different memory models sc and pso by analysing only a modest number of randomly picked program variants.
in comparison to analyzing the original program our approach reduces time and memory footprint of the backend analysis tool when launched on a program variant.
in summary we are able to reduce the wall clock time to find heisenbugs by at least two orders of magnitude on the hardest known concurrency benchmarks.
future directions the ideas and approaches proposed in this paper may underpin the development of more effectivebug finding approaches for concurrent programs.
we briefly discuss this below.
we have conducted preliminary experiments using a bddbased model checker designed for concurrent boolean programs on a version of safestack that we have translated by hand.
by performing a state space exploration up to four rounds of computation the bdd size exploded and the analysis was unsuccessful.
repeating the experiment by applying our verification approach with this same tool as backend analyzer the bdd sizes reduced considerably on all produced program variants and we have been able to find a bug in less than one minute using only a handful of instances.
this suggests that analysis based on bdd can be very valuable when combined with our verification approach particularly for lock free implementations of data structures and should be further developed to handle multi threaded c programs.
in our experiments we use a bounded model checking backend.
this proved to be very efficient on instances that actually contain an interleaving that exposes the bug but very slow on the other bug free instances.
we think that abstract interpretation has the potential for quickly discharging bugfree instances.
this is indeed corroborated by our preliminary experiments where we have used standard abstractions available in abstract interpreters such as c oncur inter proc .
we have in fact discovered that with abstract interpretation we can deem bug free a significant number of instances ordersof magnitude faster than bmc.
effective analysis tools based on sound approximation such as abstract interpretation can also play a significant role in building verification approaches for finding extremely rare bugs.
for example in our experiments we are not able to find the bug for safestack tso although we know that there must be an offending execution.
we intend to tackle the problem of finding such extremely rare bugs by combining tools based on sound approximations with a recursive verification approach in the style of a divide and conquer algorithm.
at each level of the recursion we split the problem using the tiling as shown in this paper.
then we run in parallel on each instance two tools a bug finder and bug free prover.
we also give a timeout to halt them.
now as soon as one of the two tools succeeds we either report the bug or discard the instance bottom of the recursion .
the method recurs on all the instances where the timeout is reached.
this method has the potential to take advantage of both the best available technologies for finding bugs such as those based on bmc and testing and for proving absence of bugs such as abstract interpretation enhanced with the v erismart approach.
acknowledgment the authors acknowledge the use of the iridis high performance computing facility and associated support services at the university of southampton in the completion of this work.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.