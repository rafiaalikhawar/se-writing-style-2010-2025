smoke scalable path sensitive memory leak detection for millions of lines of code gang fan rongxin wu qingkai shi xiao xiao jinguo zhou charles zhang hong kong university of science and technology gfan wurongxin qshiaa charlesz cse.ust.hk sourcebrella inc. xx jinguo sbrella.com abstract detecting memory leak at industrial scale is still not well addressed in spite of the tremendous effort from both industry and academia in the past decades.
existing worksuffers from an unresolved paradox a highly precise analysis limits its scalability and an imprecise one seriously hurts its precision or recall.
in this work we present s moke a staged approach to resolve this paradox.
in the first stage instead of using a uniform precise analysis for all paths we use a scalable but imprecise analysis to compute a succinct set of candidatememory leak paths.
in the second stage we leverage a more precise analysis to verify the feasibility of those candidates.
the first stage is scalable due to the design of a new sparse program representation the use flow graph ufg that models the problem as a polynomial time state analysis.
the second stageanalysis is both precise and efficient due to the smaller number of candidates and the design of a dedicated constraint solver.experimental results show that s moke can finish checking industrial sized projects up to 8mloc in forty minutes withan average false positive rate of .
.
besides s moke is significantly faster than the state of the art research techniques as well as the industrial tools with the speedup ranging from .2x to .8x.
in the twenty nine mature and extensively checked benchmark projects s moke has discovered thirty previouslyunknown memory leaks which were confirmed by developers and one even assigned a cve id.
index t erms memory leak static bug finding use flow graph value flow graph i. i ntroduction despite the tremendous research progress in recent decades the detection of memory leaks in industrialscale is still pretty much an unsolved problem.
in the firsthalf of the year more than memory leak bugs havebeen reported in firefox and chrome .
more than240 cve common vulnerabilities and exposures entries in are memory leaks bugs .
apparently with the explosive growth of the code size and the complexity inmodern software a practical memory detector needs tobehighly scalable checking millions of lines of code within minutes and precise understanding complex path conditions with less than false positives .
the state of the art approaches suffer from the scalability and precision paradox.
one category of the approaches give up path sensitivity for scalability inevitably introducing rongxin wu is the corresponding author.imprecise results.
for example we observed that s aber a recent path insensitive memory leak detection technique incurs a false positive rate of .
in our evaluation.
anothercategory traverse the control flow graph and use thepath sensitive analysis to achieve high precision.
however they are known to easily suffer from scalability issues espe cially for the whole program analysis.
for example s a turn is reported to have spent more than hours in checkingmemory leaks for a 5mloc code base.
our experiment showsthat csa and i nfer fail to analyze large projects of over 2mloc in two hours.
our idea to resolve this paradox is based on an observation that in real programs only a small proportion of programpaths lead to memory leaks.
therefore instead of using asledge hammer i.e.
the expensive path sensitive analysis for all paths we use a two staged analysis by first computing a succinct set of candidate memory leak paths through a novelscalable and path insensitive method followed by a moreprecise and heavy weight verification of the feasibility of thesepaths in order to achieve path sensitivity.
more specifically to check millions of lines of code in minutes we believe that the sparse value flow analysis already widely adopted in finding memory leaks is theright direction as it tracks values along the data dependencerelations on the value flow graph vfg instead of the control flow graph skipping irrelevant program statements to achievescalability.
however we observe that the vfg originally intended for program transformations is not suitable forarbitrary finite state machine properties such as the memoryleak problem due to the omission of flow information order of events .
therefore instead of finding a leak path vfg based methods need to deduce the leak path by checkingwhether the non leak paths i.e.
paths where the heap object is safely freed cover all control flow paths from where the heapmemory is allocated.
such an analysis is equivalent to solving ak sa t problem which is np hard with the input size k krepresents the number of the branch conditions .
this induces a very high time complexity in theory and maygreatly compromise the efficiency and scalability in practice.for instance the most recent vfg technique pinpoint in spite of its leap in achieving scalability and precision stillcannot complete the analysis in some large subjects in our ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
experiments.
to overcome this limitation we designed an extension of vfg namely the use flow graph ufg that encodes not just the definition but also the use of the problem relevant heap objects.
all use sites of the same heap object in ufg are ordered according to the control flow to check finite statemachine properties and to use polynomial time graph search methods to find possible memory leak paths.
path sensitivity is achieved in the second stage by using a dedicated constraint solver to verify the feasibility of these candidate leak paths.
the verification process is efficient because at this stage the number of paths is very small only on average and we use a customized constraint solver to further filter out easyto contradict ones leading to a further pruning of the paths.
finally we invoke a full smt solver such as z3 for the remaining candidates.
to evaluate the scalability and effectiveness of our proposed technique we implemented a tool s moke and applied it to the spec2000 benchmark programs and seventeen well maintained open source projects.
the experimental results have demonstrated that s moke is highly efficient and effective as it could finish checking industrial sized projects up to 8mloc in forty minutes with an overall false positive rate of .
.
this is aligned with the common industrial requirements of checking millions of loc code .
in the twenty nine mature and already extensively checked third party benchmark projects s moke found thirty previously unknown memory leaks all confirmed by the original developers.
one of the reported leaks was even assigned with a cve id due to its high severity.
we highlight our contributions as follows we present the design and the implementation of s moke a staged approach for detecting memory leaks.
s moke is faster more scalable and more precise than the stateof the art approaches.
we present a novel sparse program representation namely the use flow graph which allows us to efficiently and effectively detect memory leaks.
using the use flow graph we can model the memory leak detection problem as a p problem rather than an np hard problem on value flow graph.
we extensively evaluated s moke with standard benchmarks and a broad spectrum of open source projects.
the experimental results demonstrate that s moke achieves the speedup ranging from .2x to .8x compared with the state of the art techniques.
this paper is organized as follows.
we first present motivating examples in section ii.
section iii describes our approach.
the implementation and evaluation are presented in section iv and section v respectively.
section vi discusses related works and this paper is concluded in section vii.
ii.
m otiv a ting examples in this section we use three examples to illustrate the limitations of the conventional sparse v alue flow analysis svfa for detecting memory leaks which gives a better understanding of the key insights of our approach.
a. reducing complexity with use flow graph conventional svfa techniques such as f astcheck start with the sparse value flow graphs svfg as shown in figure b and figure b for the code snippets in figure a and figure a respectively.
in those svfgs each edge represents a data dependence relation denoting the flow of value.
for example the value flow edge p s2 p s7in figure b implies that the allocated heap object pointed to bypmay be released at the statement s7 we use si to represent the statement at line i .
in order to decide if the memory is always released properly f astcheck annotates the control flow conditions on the value flow edges and relies on a constraint solver to solve the conditions.
for the example in figure we will solve the condition fleak c1 c2 c1 c2 .i ffleak is satisfiable there exists a path with no memory release operations leading to a memory leak vulnerability.
note that in general solving fleakis ak sa t problem krepresents the number of the branch conditions which has the best time complexity ofo k n and is proved to be np hard for k .
in s moke we propose a new type of sparse program representation named use flow graph ufg that still contains the necessary control flow information.
specifically the ufg encodes the definition and the use of problem relevant heap objects which is similar to the sparseness feature in vfg.
in addition it records the control flow order of uses of the same heap object which enables the checking of finite statemachine properties such as memory leaks.
figure c shows the ufg of the code in figure a .
the ufg slices away the unnecessary program statements such as the ones in lines and and only encodes the necessary data dependence and the control dependence.
meanwhile ufg explicitly models the life cycle of a value by creating an out of scope node i.e.
p s8in figure c which indicates that the heap object pointed to by pis no longer referenced.
a simple graph traversal on the ufg shall discover that there exits a path where the pointer pis never freed .
similarly a simple graph traversal on the ufg in figure c will verify the absence of memory leaks because each path in the graph contains a memory release operation.
it is noteworthy that using ufg we can obtain the same results with the same precision as that of f astcheck without collecting constraints for each path and using a heavyweight constraint solver.
b. regaining path sensitivity via staged constraint solving since most of the allocated memory spaces are managed properly in common software many cases of memory leaks can be detected by graph traversals on the ufg with the flowsensitive precision.
however there still exists a handful of cases that require capturing branch correlations the importance of which is illustrated by figure .
this example is leakfree because the memory is allocated and released under the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
p a program leaks on an early exit at line b sparse value flow graph c use flow graphp p a leak pathp p .voidfunc .
char p malloc .
if ... 1 .
printf .
if ... 2 .
return .
free p .
fig.
.
a memory leak example.
b sparse value flow graph c use flow graph p a a code snippet contains no memory leaksp p p p p p 1.voidfunc booly .
char p malloc .
if y 1 .
... .
free p .
else .
... .
free p .
.
fig.
.
an example without any memory leaks.
same condition at line and line respectively.
however fastcheck as well as other existing svfa techniques e.g.
saber will mistakenly report it as a memory leak due to the negligence of the branch correlation.
such negligence is caused by the large overhead of collecting path conditions for many paths and the high complexity of conventional constraint solving methods.
to correctly identify that the code snippet is leak free smoke employs a staged constraint solving process to verify the feasibility of the candidate leak paths such as the one in figure c .
first we adopt a linear time solver to filter obvious infeasible paths.
most of the false warnings involving branch correlations can be pruned at this stage.
for the remaining paths with complex path conditions we adopt a fully featured smt solver such as z3 to check their feasibility to achieve a low false positive rate.
iii.
m emory leak detection in order to speed up the memory leak detection without losing the precision we make two design decisions.
first we use a lightweight finite state analysis with a new sparse program representation the use flow graph section iii a .
second we achieve the precision of path sensitivity through a dedicated constraint solver section iii b .
in this section we assume that a program consists of functions in ssa form and the pointer relations in the program have been resolved.
we b sparse value flow graph c use flow graph a branches at line and line are correlated p p p entry a leak pathp p .voidfunc booly .
char p null .
if y 1 .
p malloc .
... .
if y 2 .
free p .
.
fig.
.
a false memory leak due to an infeasible program path.
discuss how to satisfy the assumptions in our implementation in the next section.
a. finite state analysis with use flow graph our analysis is based on a new type of sparse program representation the use flow graph ufg .
compared to the conventional sparse value flow graph ufgs have the following features for checking the finite state properties of a program it models the whole life cycle of program variables by encoding the property related control flows which we referred to as use flows.
it can be efficiently built in linear time with regard to the program size.
a finite state property of a program can be modeled as a finite state machine fsm which defines the valid sequences of operations that can be performed upon an object.
definition finite state machine fsm .a finite state machine of a program property is a quintuple m s s0 f where is a finite non empty set of classes of program points.
sis a finite non empty set of the states of a program object.
s0 sis the initial state.
is the state transition function s mapsto s. s1 p s2means that the state s1of an object can transit to the state s2if the object goes through a program point p p. f sis the set of final states.
example .
as shown in figure we use an fsm to model different states and state transitions of a heap object.
there are four states in the fsm allocated a freed f error e and exit x .ais the initial state and both eand x are the final states.
eindicates a safety violation of the finitestate property such as memory leak and double free and x denotes a normal exit.
the state awill transit to the state fif a newly allocated heap object goes through a program point where a free operation is performed.
the state awill transit to the state e i.e.
a memory leak issue if a heap object goes out of its life scope and can be no longer referenced.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
the finite state machine for a heap object.
table i the analysis steps in example .
step vertex before after t s2 a t s3 a a f p s10 a a p s11 a f p s12 a f a f t s6 a f f e t s7 a f f a f t s9 a f e x given an fsm we can build the sparse program representation the use flow graph as follows.
definition use flow graph ufg .the use flow graph of a program with regard to a given fsm is a directed graph g v e wherevis the set of vertices and eis the set of edges a vertex o p vrepresents an object oat a program pointp.pis one of the following program points p pwherep and s p negationslash s. that is pis a program point that can cause a transition between different states.
pis where we call a function using oas an actual parameter.
pis the entry of a function where ois a formal parameter.
for each o p prime v pis the dominance frontier ofp prime.
intuitively the dominance frontier is where the states of the object ofrom different paths can be merged.
a directed edge o1 p1 o2 p2 eif and only if o1ando2represent the same object and there exists a control flow path from p1top2.
the path does not go through any other program point p3such that there exists o3representing the same object and o3 p3 v. given a program and the fsm of a property the ufg can be built efficiently according to definition in polynomial time.
the basic idea is to traverse the control flow graph of each function and remove the statements at program points that are irrelevant according to the fsm.
example .
figure illustrates an example of the ufg w.r.t.
the fsm in figure .
as a sparse representation all irrelevant program statements such as the ones at lines and are not modeled.
we have the vertices t s7andp s12because theyt t t t p p p call ret t s91.voidfoo .
int t malloc ... .
bar t .
intq qux .
printf d n q .
if ... free t .
... .
return .
.voidbar int p .
if ... free p .
fig.
.
an example to illustrate ufg construction.
sirepresents the program point at line i. are the dominance frontiers of t s6andp s11 respectively.
at the program points s7ands10 the states of the heap object from different program paths can be merged.
we have the vertext s9because this is the end point of the scope of the heap object t. next we describe how to detect memory leaks using ufg.
the basic idea is to check the state of a heap object by traversing the ufg inter procedurally.
when traversing a ufg we use a set to keep track of the states at each vertex.
from the memory allocation site the state ais added to the set.
the state set is propagated forward along the ufg edges.
when visiting a vertex corresponding to a transition of the fsm we transit a state accordingly.
otherwise the states remain unchanged.
at each merge point we merge the state sets from different paths by the set union operation.
instead of giving a complex formal representation of the algorithm we use the following example to illustrate the process.
example .
we use table i to illustrate the steps of our state analysis on the ufg in figure .
each row of the table shows the state set before and after a vertex.
for example in steps and since the program points s12ands7 are dominance frontiers where two state sets from different paths meet we use the set union operation to merge the states.
in step since the program point s9represents the end of the scope of the heap object t the state atransits to the state eand the state f transits to the state x. since the state eis obtained via an outof scope operation we report a memory leak candidate.
this candidate will be verified path sensitively as detailed later.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
as illustrated by the above example the ufg is traversed inter procedurally.
the context sensitivity is achieved via the cfl reachability method .
that is we assign a string to each state during the graph traversal to check the validity of the context.
when propagating a state along a call edge at a call site cs we append a left parenthesis csto the string.
when propagating a state back to a call site csalong a return edge we append a right parenthesis csto the string.
a state propagation is valid only if the string has matched parentheses.
we create a function summary for each function in a demand driven way.
that is when reaching a call site we check if the callee has a usable summary so that we do not need to reanalyze the callee.
otherwise we create a summary after the callee is analyzed.
in our approach a summary is a map between the input states of a parameter pand the states ofpat the end of a function.
therefore it is unnecessary to repeat the analysis of a function at different call sites if its summary has been created.
our analysis can be efficiently implemented using the rhs algorithm .
given an fsm m s s f and its corresponding ufg g v e the time complexity of the algorithm is o v s e s calls s where calls is the number of call sites in the program to check.
b. staged path sensitive v erification .voidfoo boolc .
int t malloc ... .
if c .
free t .
... .
if !c .
free t .
... .
a false leak patht t t t t t a f a f f e a a f a f e x fig.
.
a false memory leak case whose path condition contains an apparent contradiction c c. some of the ufg paths generated by the aforementioned state analysis are infeasible which may result in false positives as illustrated in figure .
to reduce the false positives we introduce a path sensitive verification step where we collect and solve path conditions of each memory leak candidate path.
although the path sensitive verification is usually expensive our approach can be efficient because of two important observations.
first we observe that the state analysis only produces a handful of memory leak candidates that require a path sensitive verification.
this is because most of the heap memory spaces are managed safely in practice.
second we observe that the constraint in a path condition usually has apparent contradictions such as a a as shown in the example in figure .
the reason is that the programmers tend to use direct contradictions to ensure some required logicalproperties.
thus we first adopt a linear time solver to detect apparent contradictions and to filter obviously infeasible paths.
for the remaining complex cases we use a fully featured smt solver such as z3 to check the path feasibility.
the basic idea of the linear time solver is similar to the one used in prior study and it continuously collects the sets of positive and negative atomic constraints during the construction of a path condition.
an atomic constraint is a first order logic formula that does not contain any logic operator like and .f o r example a 2bandcare two atomic constraints in a 2b c. if a path condition has an atomic constraint ain both sets this path condition must contain a aand thus is unsatisfiable.
iv .
i mplementa tion we have implemented s moke on top of the llvm framework which takes an llvm bitcode file as input for detecting c c memory leaks.
similar to some earlier work we have some unsound trade offs to make the detector more practical.
we assume a path in ufg is safe if this path flows to a global pointer or a container e.g.
std list std vector .
we do not report memory leaks if a path ends in a call to exit .i f a heap object is used as an argument of a library function i.e.
a function that is not defined in the bitcode on a path we conservatively treat it as an unknown value and stop searching this path.
we manually modeled some common library functions such as memcpy andmemset to improve the precision and the recall.
similar to f astcheck we do not check the arithmetic operations on heap pointer free p y is simply treated as free p .
figure illustrates the overview of our tool s moke .
smoke has four phases pre analyses ufg construction state analysis and path sensitive v erification.
here we only discuss the details of the pre analyses phase since other three phases have already been discussed in section iii.
in the pre analyses phase we conduct several analyses to compute the necessary information for later phases.
we first use a flow sensitive and context sensitive pointer analysis similar to the one used in p inpoint to compute the data dependence.
control dependence is computed on demand since not all functions in a program are related to memory leak detection.
we construct the control dependence by computing the dominance frontier in the reverse graph of the control flow graph .
to construct the call graph we use the must alias results from the pointer analysis to resolve function pointers and adopt a class hierarchy analysis to resolve virtual function calls.
during the state analysis we only consider the case when the memory allocation operation is successful.
for instance if a heap object is created in x malloc we do not consider the case when the test x null is true.
we use a lightweight data flow analysis to identify and ignore ufg edges on which heap memories have not been successfully allocated.
v. e v alua tion we evaluate the precision the recall and the scalability of smoke by comparing four well known static analysis tools authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pointer analysis ufg constructionstate analysispath sensitive verification control flow analysisdata dependence control dependencememory leak fsmleak path candidatesmemory leaks solver function summaryufgchecker specification program ir analysis report joint path conditionssat unsatquery fig.
.
system overview of s moke that have memory leak detectors from both academia and industry.
we compare to both s aber and p inpoint since they are the state of the art svfa based approaches with the precision of flow sensitivity and path sensitivity respectively.
we also choose csa and i nfer two prominent and mature open source tools from the industry.
we plan to evaluate other memory leak detection tools such as s a turn and c alysto .
however they are either publicly unavailable or outdated for running in the environments we are able to set up.
to demonstrate the usefulness of our approach we also seek confirmations from original developers of the subjects we use.
for each baseline we only enable the memory leak detector since some tools may have other bug detectors.
we set the timeout to hours and configure each tool with its default settings.
all the experiments are performed on a moderate computer running ubuntu .
with an intel core i5 quad core processor and 64gb physical memory.
a. subjects for evaluation we evaluate s moke saber pinpoint csa and i nfer using twenty nine subjects including the twelve benchmark programs from standard spec cint2000 a commonly used benchmark in the existing literature and seventeen well tested open source projects.
table ii shows the basic information of the evaluation subjects.
the size of these subjects ranges from a few thousand of lines of code to nearly eight million of lines of code.
these projects are widely used and well tested before release.
some of them are regularly scanned by free or commercial static tools such as c overity sa ve and thus expected to have high code quality.
we divide the subjects into two categories medium sized projects including all spec cint2000 programs and the projects with code size less than 1mloc and large sized projects with code size larger than 1mloc.
scalability to evaluate the scalability of each tool we first check whether it can successfully analyze the selected subjects under our experimental environment which is a typical desktop computer rather than a powerful cluster and within the time budget hours .
as shown in table ii s moke successfully analyzes all twenty nine projects in forty minutes while others fail to analyze some of the projects due to either crash outof memory or segmentation faults or timeout.
for example saber having the lowest success rate fails on nine projects including two medium sized and seven large sized projects.
pinpoint and csa achieve the second best success rate but still fail on four projects which are mostly large sized projects.
we further compare the time cost of analysis of all the tools shown in table ii.
on average s moke achieves the highest efficiency and is significantly .2x faster than saber .0x faster than p inpoint .4x faster than csa .8x faster than i nfer faster than other tools.
smoke performs better than s aber and p inpoint in all subjects.
compared to csa and i nfer smoke also performs better on all the subjects except one medium sized project .perlbmk .
overall the evaluation results show that compared to other tools s moke achieves the highest scalability and scales to millions of lines of code without requiring too much computation resource using a desktop computer .
c. precision following the common practice in the literature on memory leak detection we manually check each error report provided by all the tools and then compare their false positive rate fp rate for short to evaluate the precision.
this process may be subjective and introduce threats to the validity of the fp results.
therefore we ask three software engineers to crossvalidate the results and meanwhile seek confirmations from the developers of the subjects.
in addition we release the reports and data for inspection.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii analysis time comparison osk yki osk yki 9vkkj v osk yki 9vkkj v osk yki 9vkkj v osk yki 9vkkj v m ov vx mii xgyn sil ixglz vgxykx kut vkxrhsq mgv uxzk h ov z url lzvj .zuv 3ksiginkj gllk xgyn roh s vgink nzzvj 5vkt992 svkm ujuz tmotk 3 972 nxusk 9qog rktjkx otk xgyn oxklu s kuskzxoi 3kgt 9ghkx tlkx q2u rruigzouty 9ozky xkk 9ozky tiy 32u 5vkt 9u xik 6xupkizy96 6xupkiz 5xomot 32u 5vkt 9u xik 6xupkizy u z ul zosk u z ul sksux tuz g gorghr k table iii shows the comparison results.
on average s moke achieves an fp rate of .
which is the lowest one among all the tools.
as discussed in section v b not all the subjects can be successfully analyzed by all the tools.
and the number of false positives in the failure cases e.g.
s aber fails in the project l ame is counted as .
for the medium sized subject the small number of failure cases only by s aber 1b y csa and i nfer allows a fair comparison of all the tools where s moke outperforms all other tools with a lowest fp rate of .
.
the second best tool p inpoint achieves a much higher fp rate of .
.
i nfer performs the worst with an fp rate of .
.
for the large sized subjects we also observe s moke achieves the lowest fp rate which is consistent with the results in medium sized subjects.
we further investigate why s moke can achieve the lowest fp rate.
s aber does not capture the path correlation.
therefore it cannot filter out cases with infeasible paths.
since pinpoint and csa achieve the precision of path sensitivity they report the smallest number of false positives.
however they report much fewer true positive instances incurring the higher fp rate.
i nfer has the highest fp rate.
a manualcheck reveals that i nfer generates a specification for each analyzed function and discards some of these specifications for unknown reasons.
the omitted specifications produce imprecision in the whole program analysis.
for example a typical false positive case happens when the specification for a wrapper function of free i.e.
a library function to free heap object is discarded.
d. recall from the results in table iii we observe that s moke reports more memory leaks than other tools.
s moke reports real memory leaks while the other four tools report only real memory leaks in total.
saber and p inpoint make significant precision tradeoffs to achieve efficiency.
for instance they limit the calling depth for inter procedural analysis and only report memory leaks with six levels of function calls.
they also stop analysis whenever they find that a heap object is assigned to a global variable on a path even when the heap object obviously leaks on another path.
for example figure shows a leak found by s moke a heap object allocated in get dll name flows to dll name .
it leaks when taking the true branch at line .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii memory leak results 9ghkx tlkx 8kv 8kv 8kv 8kv 8kv m ov vx mii sil ixglz vgxykx kut vkxrhsq mgv uxzk h ov z url lzvj .zuv 3ksiginkj gllk roh s vgink nzzvj 5vkt992 uzgr 32ui 8gzk svkm ujuz 3 972 nxusk 9qog rktjkx otk oxklu uzgr 32u 8gzk rr 8gzk 32u 5vkt 9u xik 6xupkizy96 5xomot 6xupkiz 32u 5vkt 9u xik 6xupkizy saber and p inpoint cannot find this leak since it can flow to a global variable dll delayed ordll imports when taking the false branch at line .
csa does not analyze function calls across different files.
infer can only handle a small number of function calls across different files.
however we observe that it is very common that a memory leak relates to functions from different files.
as a result csa and i nfer miss many real memory leaks.
for example figure shows a memory leak in bftpd reported by smoke but not by csa or i nfer .
a heap object allocated in a source file cmd.c leaks in another file commands.c .
e. contribution of the analysis stages to better understand the effectiveness and the efficiency of the staged analysis we report the number of pruned candidates and the time cost of each stage in table iv.
note that since it is difficult to calculate the total number of the candidate paths starting from each allocation sites e.g.
path explosion due to loops we estimate the lower bound of the total number of candidates using the number of allocation sites.location import.c .
add a dll to the list of imports .voidadd import dll const char name const char filename .
.
dllspec spec .
char dll name get dll name name filename .
structimport imp xmalloc sizeof imp .
.
memset imp sizeof imp .
.
if filename imp full name xstrdup filename .
elseimp full name find library name .
.
if !
spec read import lib imp .
.
free imports imp .
return .
.
.
imp dll name spec file name ?
spec file name dll name .
imp c name make c identifier imp dll name .
.
if is delayed import dll name .
list add tail dll delayed imp entry .
else .
list add tail dll imports imp entry .
a memory is allocated and assigned to dll name take the true branch at line dll name is leaked fig.
.
a memory leak in wine .
appendpath result path2 .
free path2 .
returnresult .
.char bftpd cwd mappath char path .
.
char result malloc ... .
char path2 .
char tmp .
if !
result .
returnnull .
path2 strdup path .
if !
path2 location cmd.c location commands.c .
free philename .
free mapped .
philename null .
.voidcommand rnto char newname .
.
char mapped bftpd cwd mappath newname .
if !
mapped !
philename .
.
control printf sl failure error unable to rename file.
.
return .
fig.
.
a memory leak in bftpd in the first stage s moke prunes .
o f the candidates leaving twenty one paths on average for each subject to be checked further.
in the second stage s moke further prunes .
of the candidates by detecting infeasible paths.
the above results indicate that both authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv sta tistics of two analysis stages 6gzny osk yki uzgr osk 6gzny osk yki uzgr osk m ov vx mii sil ixglz vgxykx kut vkxrhsq mgv uxzk h ov z url lzvj .zuv 3ksiginkj gllk roh s vgink nzzvj 5vkt992 svkm ujuz tmotk 3 972 nxusk 9qog rktjkx otk oxklu uzgr kxgmk yz 9zgmk tj 9zgmk yzosgzkj 6gzny6xupkiz of the stages are effective in improving the precision.
table iv shows the time cost of the two stages.
s moke spends .
of the time in the first phase and only .
in the second phase.
the two staged design significantly reduces the cost for the path sensitive analysis and thus achieves high efficiency.
f .
detected real memory leaks to better understand the usefulness of s moke in practice we seek confirmations from the original developers of the subjects.
since we can not flood them with all warnings we manually pre screen the bug reports and choose only the ones that are likely to have severe impacts.
the majority of the reports are for large and well maintained projects such as ffmpeg wine firefox mysql godot engine and chrome v8 .
all thirty reports get confirmed by their developers and result in many patches and bug fixes.
this result confirms the usefulness of our approach because those projects are regularly scanned by free and commercial tools and s moke only takes minutes to analyze each project.
we release the confirmed memory leaks online .
due to the high scalability of s moke we can detect the inter procedural memory leaks in large projects without consuming too much computing resources.
figure shows dom media encoder vp8trackencoder.cpp .
nsresult .
vp8trackencoder getencodedpartitions ... .
.
vpx codec iter t iter nullptr .
encodedframe frametype frametype encodedframe vp8 p frame .
nstarray uint8 t framedata .if !framedata.isempty .
copy the encoded data to adata.
.
encodedframe videodata newencodedframe .
videodata setframetype frametype .
.
convert the timestamp and duration to usecs.
.
checkedint64 timestamp ... .
if !timestamp.isvalid .
ns error microsecond timestamp overflow .
returnns error dom media overflow err .
.
videodata settimestamp ... .to adata memory is allocated and assigned to videodata take the true branch at line videodata is leaked.
fig.
.
a memory leak in firefox location sparselu.h .
constindex outerindexptr .
if iscompressed .
outerindexptr newindex .
else .
outerindexptr mat.outerindexptr .
.
for index i i mat.cols i .
m mat.outerindexptr outerindexptr .
m mat.innernonzeroptr outerindexptr outerindexptr .
.
if iscompressed .
delete outerindexptr .
fig.
.
a false positive report in blender a memory leak confirmed by the developers of firefox a project of approximately eight million lines of code.
in this example the memory space pointed to by videodata is allocated at line and leaks on an early return at line when timestamp.isv alid returns false .
this case is not very complicated.
however because of the complexity in the code and the enormous project size this memory leak has been hidden for more than one year.
figure shows a memory leak that s moke found in bftpd a lightweight flexible ftp server widely used in desktops servers embedded devices and media centers.
this vulnerability has been in the code since .
it has survived for more than twelve years and has impacted eighty six versions altogether.
we report this leak to its developers and receive a confirmation and an appreciation acknowledgment on its homepage.
a remote attacker can utilize this leak to launch denial of service attacks to the users ofbftpd .
due to its high severity a cve id cve is assigned.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g. limitations our approach can be imprecise for several reasons.
one reason is the lack of library specifications.
figure shows a leak free example simplified from a false positive report in blender.
at line the program allocates an array and stores it to the memory pointed to by outerindexptr under the condition that iscompressed returns true.
at line the program deletes outerindexptr when another call toiscompressed returns true at line .
the function iscompressed is implemented in a library and it returns the same boolean value at both places.
hence the two branches are correlated.
unfortunately we cannot statically determine this branch correlation since we do not have the specification of the library function.
one way to mitigate this problem is to manually or automatically provide specifications for libraries when detecting infeasible paths.
another reason is that we inherit the imprecision from the lower level program analyses such as the pointer analysis.
the pointer analysis may mistakenly identify two different heap objects as aliases.
operations on one object of the alias pair may cause state changes of another which could result in mutual interference and incorrect results.
there are still some types of infeasible paths that cannot be identified by our approach.
such paths usually involve complex arithmetic in branch conditions complicate data dependence or deep inter procedural effects.
including more control and data dependence in the path constraints can help to mitigate this limitation at the price of being less efficient.
vi.
r ela ted work in this section we survey the related approaches in two categories.
a. static memory leak detection sa turn reduces the memory leak detection problem to a boolean satisfiability problem and uses a sa t solver to find memory leaks.
facebook i nfer is based on biabductive inference of separation logic that extends the hoare logic by explicitly modeling the heap.
c louseau detects memory leaks based on a practical ownership model of memory management.
orlovich and rugina proposed a leak detection algorithm based on a reverse data flow analysis that assumes the presence of the leak first followed by a pruning method.
s parrow detects memory leaks in c programs based on abstract interpretation.
tools based on symbolic execution such as the csa c overity sa ve and k lee are promising in practice.
by treating all external inputs as symbols and execute the program on symbols symbolic execution tools can explore program states that are hard to reach for concrete executions.
however symbolic execution tools do not scale to large programs due to the path explosion problem and intensive uses of the constraint solver.
all of the above techniques are not sparse which a lot of irrelevant program statements and thus suffer from performance issues.
fastcheck s aber and p inpoint are mostly related to our approach.
they work on a sparse value flow graph with guards annotated on the graph edges.
as we have discussed in this paper when high precision is required vfg based model of the memory leak problem is the reason for the analysis to be not scalable.
to achieve scalability f astcheck and s aber have to compromise the path sensitivity leading to many false warnings.
p inpoint improves the sparse value flow analysis by building precise data dependence in an efficient manner but it does not provide a better model for memory leak detection.
in comparison we propose a fsm based model that enables us to efficiently detect memory leaks on ufg.
b. dynamic memory leak detection dynamic approaches detect memory leaks by instrumenting and running a program.
some dynamic approaches operate at the binary level such as the memcheck tool of v algrind d r.m emory and p urify .
these approaches track memory allocation and deallocation during a program s execution and detect leaks by scanning the program s heap for memory blocks that no pointer points to.
insure and a ddress sanitizer detect memory leaks by inserting extra statements to the source code before compiling the binary.
unlike static approaches that have relatively high false positive rate due to the abstraction of concrete program states dynamic approaches have few false positives because they have access to the concrete program states at runtime.
however dynamic approaches can miss many real bugs because they cannot cover all possible program behaviors with limited number of test cases.
also dynamic approaches are hard to be applied in a production run because running the instrumented program usually causes unbearable runtime overhead.
vii.
c onclusion we have presented an approach to static memory leak detection which runs in a fast scalable and precise manner.
the key factor to make our technique fast is a staged analysis in which we first efficiently filter safe cases based on our new program representation i.e.
use flow graph and then employ a constraint solver to verify path feasibility only for a handful of leak candidates.
we implemented our technique as a tool called s moke and evaluated it systematically.
the evaluation results demonstrate that s moke is promising as an industrialstrength static memory leak detector.
acknowledgment we thank the anonymous reviewers for their insightful comments and dr. y ulei sui for his help on the saber implementation.
this work was partially funded by hong kong grf16214515 grf16230716 grf16206517 nsfc61628205 and its 16fp grants.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.