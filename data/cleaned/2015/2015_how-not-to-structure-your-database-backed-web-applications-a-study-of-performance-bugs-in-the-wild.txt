how notto structure your database backed web applications a study of performance bugs in the wild junwen yang pranav subramaniam shan lu university of chicago junwen psubramaniam shanlu uchicago.educong yan alvin cheung university of washington congy akcheung cs.washington.edu abstract manywebapplicationsusedatabasesforpersistentdatastorage and using object relational mapping orm frameworks is a commonwaytodevelopsuchdatabase backedwebapplications.unfortunately developingefficientormapplicationsischallenging astheormframeworkhidestheunderlyingdatabasequerygeneration and execution.
this problem is becoming more severe as these applications need to process an increasingly large amount of persistent data.
recent research has targeted specific aspects of performanceproblemsinormapplications.however therehasnot beenanysystematicstudytoidentifycommonperformanceantipatterns in real world such applications how they affect resulting application performance and remedies for them.
inthispaper wetrytoanswerthesequestionsthroughacomprehensivestudyof12representativereal worldormapplications.we generalize9ormperformanceanti patternsfrommorethan200 performance issues that we obtain by studying their bug tracking systems andprofiling theirlatest versions.
to prove ourpoint we manually fix performance issues in their latest versions and obtain amedian speedupof and up to max with fewer than lines of code change in most cases.
many of the issues we found have been confirmed by developers and we have implemented ways to identify other code fragments with similar issues as well.
ccs concepts software and its engineering software performance keywords performanceanti patterns object relationalmappingframeworks database backed applications bug study introduction modernwebapplicationsfacethechallengeofprocessingagrowing amount of data while serving increasingly impatient users.
on one permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
popular web applications typically increase their user bases by per week in the first few years with quickly growing data that is produced or consumed by these users and is managed by applications.on the otherhand studies haveshown thatnearly halfoftheusersexpectasitetoloadinlessthan2secondsandwillabandon a site if it is not loaded within seconds while every extra .
second of latency reduces the overall traffic by .
tomanagelargeamountsofdata modernwebapplicationsoften follow a two stack architecture with a front end application stack fulfillingapplicationsemanticsandaback enddatabasemanagementsystem dbms storingpersistentdataandprocessingdatare trievalrequests.tohelpdevelopersconstructsuchdatabase backed webapplications objectrelationalmapping orm frameworks have become increasingly popular with implementations in all common general purpose languages the ruby on rails framework rails forruby djangoforpython andhibernateforjava .
these orm frameworks allow developers to program such database backed web applications in a dbms oblivious way as the frameworks expose apis for developers to operate persistent data storedinthedbmsasiftheyareregularheapobjects withregularlooking method calls transparently translated to sql queries by frameworks when executed.
unfortunately orm frameworks inevitably bring concerns to theperformance andscalability ofweb applications whosemultistack nature demands cross stack performance understanding and optimization.
on one hand it is difficult for application compilers or developers to optimize the interaction between the application andtheunderlyingdbms astheyareunawareofhowtheircode wouldtranslatetoqueriesbytheorm.ontheotherhand orm framework and the underlying dbms are unaware of the high level application semantics and hence cannot generate efficient planstoexecutequeries.makingthingsevenworse data related performanceandscalabilityproblemsareparticularlydifficultto exposeduringin housetesting astheymightonlyoccurwithlarge amounts of data that only arises after the application is deployed.
unlikeperformanceproblemsontheclientside whichhavebeen well studied in prior work the cross stack performance problemsontheserversideareunder studied whichunfortunately arethekeytothedata processingefficiencyoformapplications.
although recent work has looked at specific performanceproblemsinormapplications therehasbeennocomprehensive study to understand the performance and scalability of real world orm applications the variety of performance issues that prevail and how such issues are addressed.
giventheabove wetargetthreekeyresearchquestionsabout real world orm applications in this paper acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
rq1 howwelldoreal worlddatabase backedwebapplications perform as the amount of application data increases?
rq what are the common root causes of performance and scalability issues in such applications?
rq what are the potential solutions to such issues and can they be applied automatically?
to answer these questions we conduct a comprehensive twopronged empirical study on a set of rails applications representing common categories that exercise a wide range of functionalities provided by the orm framework and dbms.
we choose rails as it is a popular orm framework .
we carefully examine fixed performance issues randomly sampled from the bug tracking systems of these applications.
this helps us understand how well these applications performed on real world data in the past and what types of performance and scalability problems have been discovered and fixed by end users and developers in past versions.
to complement the above study we also conduct thorough profilingandcodereviewofthelatestversionsofthese12applications.
this investigation helps us understand how these applications currentlyperformonourcarefullysynthesizeddata tobeexplained in section what types of performance and scalability problems still exist in the latest versions and how they can be fixed.
intermsoffindings for rq1 ourprofilinginsection4shows that under workload that is no larger than today s typical workload out of studied applications contain pages in their latest versions that take more than two seconds to load and also pages thatscalesuper linearly.comparedtoclient sidecomputation e.g.
executing javascript functions in the browser server side computation takes more time in most time consuming pages and often scalesmuchworse.theseresultsmotivateresearchtotackleserverside performance problems in orm applications.
forrq2 we generalize orm performance anti patterns by thoroughlystudyingabout200real worldperformanceissues with 140collected from12 bug trackingsystems and64 manuallyidentified by us based on profiling the same set of orm applications section5 .wegroupthese9patternsintothreemajorcategories orm api misuses database design problems and trade offs in applicationdesign.allbutoneofthesepatternsexistbothinprevious versions i.e.
fixed and recorded in bug tracking systems and the latest versions i.e.
discovered by us through profiling and codereview oftheseapplications.6oftheseanti patternsappear profuselyinmorethanhalfofthestudiedapplications.whileafew ofthemhavebeenidentifiedinpriorwork themajorityofthese anti patterns have notbeen researched in the past.
finally for rq3 wemanuallydesignandapplyfixestothe64 performance issues in the latest versions of these orm applications section6 .ourfixesachieve2 medianspeedup andup to39 inserver sideperformanceimprovement andreducethe averageend to endlatencyof39problematicwebpagesin12applicationsfrom4.17secondsto0.69seconds makingtheminteractive.mostoftheseoptimizationsfollowgenericpatternsthatwebelieve can be automated in the future through static analysis and codetransformations.
as a proof of concept we implement a simple static checker based on our findings and use it to find hundreds of api misuse performance problems in the latest versions of these applications section .fodvv 0hvvdjhv rqwuroohu ghi lqgh phvvdjhv xvhu xqghohwhgbphvvdjhv uhqghu lqgh hqg hqg fodvv 8vhu fwlyh5hfrug dvh kdvbpdq phvvdjhv fodvvbqdph !
0hvvdjh iruhljqbnh !
xvhublg ghi xqghohwhgbphvvdjhv phvvdjhv zkhuh ghohwhg !
idovh hqghqg fodvv 0hvvdjh fwlyh5hfrug dvh ehorqjvbwr xvhu fodvvbqdph !
8vhu iruhljqbnh !
xvhublg hqg phvvdjhv hdfk gr phvvdjh !
wu!
phvvdjh xvhu qdph wu!
hqg !
phvvdjhvbfrqwuroohu uephvvdjhv lqgh kwpo hue l5 g xvhu ue phvvdjh uep rqwuroohu9lhz o80rgho ssolfdwlrq 6huyhu 5rxwlqj uxohv jhw phvvdjhv lqgh !
phvvdjhv lqgh lglgxvhublggghohwhg lgqdph figure structure of an example rails application overall our comprehensive study provides motivations and guidelinesforfutureresearchtohelpavoid detect andfixcrossstackperformanceissuesinormapplications.wehaveprepared adetailedreplicationpackageforalltheperformance issuestudy profiling and program analysis conducted in this paper.
this package is available on the webpage of our hyperloop project a projectthat aimsto solvedatabase related performanceproblems in orm applications.
background our study focuses on applications written in ruby on rails rails .
ruby is among the top popular languages on github and rails is among the top popular web application frameworks .
many widely used applications are built upon rails such ashulu gitlab airbnb etc.comparedtootherpopular orm frameworks such as django and hibernate rails has moreapplicationsongithubwith400morestarsthandjango andhibernatecombined.asrailsprovidessimilarfunctionalities as django and hibernate we believe our findings can apply to applications built on top of those frameworks as well.
likeotherapplicationsbuiltontopofanormframework rails applications are structured based on the model view controller mvc architecture.
we illustrate this using an example shown in figure which is abridged from a forum application that al lows users to publish posts and comments.
first developers designmodelclasses that inherit from a special activerecord super class such as userandmessage in figure where their corresponding fields are stored persistently in the dbms.
the associ ations between model classes chosen from has many has one andbelongs to need to be explicitly declared in modelclasses such as the has many messages specified in the userclass and the belongs to user specifiedinthe message class.afterthat they design controllers such as messagescontroller.rb in figure1thatcontainsmultiple actions witheachactiondetermining authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table details of the applications chosen in our study category abbr.
name stars commits contributors forumds discourse lo lobster collaborationgi gitlab re redmine e commercesp spree ro ror ecommerce task fu fulcrum management tr tracks social da diaspora network on onebody mapos openstreetmap ff fallingfruit howtheapplicationrespondstoaspecificweb pagerequest.inside an action there is code to retrieve database data through queries transparently translatedby theorm.
finally the retrieved datais renderedvia viewsthatareoftenwritteninatemplatelanguage as shown in index.html.erb in figure .
such views determine how the retrieved data is displayed in a client s browser.
the life cycle of a rails application and orm applications in general isasfollows.whenreceivingaclienthttprequestlike theapplicationserverfirstlooks up the routing rules shown at the top of figure to map this requesttothe indexactioninside messagescontroller .whenthe indexactionexecutes itinvokesthe user.undeleted messages function which calls messages.where ... .
the call to the rails apiwhereis dynamically translated to a sql query by the rails framework to retrieve data from the dbms.
the query results are then serialized into model objects and stored in messages .
the indexaction then calls render index to render the retrieved data in messages using the index.html.erb template.
profiling study methodology thissectionexplainshowweprofileormapplicationsandstudy theirbug trackingsystems withthegoaltounderstandhowthey perform and scale in both their latest and previous versions.
.
application selection as mentioned in section we focus on rails applications.
since itisimpracticaltostudyallopen sourcerailsapplications about thousand of them on github we focus on popular application categories1as shown in table .
these categories cover of all rails applications with more than stars on github.theyalsocoveravarietyofdatabase usagecharacteristics suchas transaction heavy e.g.
e commerce read intensive e.g.
socialnetworking andwrite intensive e.g.
forums .furthermore they cover both graphical interfaces e.g.
maps and traditional text based interfaces e.g.
forums .
we study the top most popular applications in each category basedonthenumberof stars ongithub.these12applications shownintable1havebeendevelopedfor5to12years.theyare 1we use the category information as provided by the application developers.
for example diaspora is explicitly labeled social network .table some of gitlab statistics for workload synthesis projects users commits projects branches projects statistics about the number of users who own certain number of projects and the number of projects that have certain number of commits and branches.
table database sizes in mb records ds lo gi re sp ro fu tr da on ff os all in active use and range from 7k lines of code lobsters to 145k lines of code gitlab .
.
profiling methodology populatingdatabases.
toprofileanormapplication weneed topopulateitsdatabase.withoutaccesstothedatabasecontentsin thedeployedapplications wecollectreal worldstatisticsofeachapplicationbasedonitspublicwebsite e.g.
for gitlab or similar application s website e.g.
amazon statistics for e commerce type applications .
we then synthesize database contents based on these statistics along with applicationspecific constraints.
specifically we implement a crawler that fills out forms on the application webpages hosted on our profiling serverswithdataautomaticallygeneratedbasedonthedatatype constraints.ourcrawlercarefullycontrolshowmanytimeseach form is filled following the real world statistics collected above.
takegitlabasanexample anapplicationthatallowsusertomanageprojectsandgitrepositories.werunacrawleronourowngitlab installation.undereachgenerateduseraccount thecrawlerfirst randomlydecideshowmanyprojectsthisusershouldownbasedonthereal worldstatisticscollectedfrom shown in table say n and then fills the create project page ntimes.
the crawler continues to create new project commits branches tags and others artifacts in this manner.
otherapplicationsarepopulatedsimilarly andweskipthedetails due to space constraints.
virtual machine images that contain alltheseapplicationsandoursyntheticdatabasecontent aswell as data populating scripts are available at our project website .
scaling input data.
wesynthesizethreesetsofdatabasecontentsforeachapplicationthatcontain200 and20 000records initsmaindatabasetable whichistheoneusedinrenderinghome page suchasthe projects tableforgitlabandredmine the posts tableforsocialnetworkapplications etc.othertables sizesscale up accordingly following the data distribution statistics discussed above.thetotaldatabasesizes inmb underthesethreesettings are shown in table .
when we discuss an application s scalability we compare its performance among the above three settings.
when we discuss an application s performance wefocusonthe20 recordsetting whichisa realisticsettingforalltheapplicationsunderstudy.in fact based on the statistics we collect the number of main table authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table numbers of sampled and total issue reports ds lo gi re sp ro fu tr da on ff os the upper row shows the number of reports sampled for our study the lower row shows the total number of reports in each application s bug tracking system.
records of every application under study is usually larger than in public deployments of the applications.
for example lobstersandtracks maintablesholdthefewestrecords and respectively.
many applications contain more than million records in their main tables spree s official website contains almost million products fallingfruit s official website contains more than million locations on map etc.
identifying problematic actions.
next we profile applications to identify actions with potential performance problems.
we deploy an application s latest version under rails production mode on aws m4.xlarge instance with populated databases.
we run a chrome based crawler on another aws instance to visit links repeatedly and randomly for hours to collect performance profiles for every actionin an application.2we repeat this for all three setsofdatabasesshownintable3 andeachsetisrepeatedfor3 times.
wethen processthe logproduced byboth chromeand the rails active support instrumentation api to obtain the average end to endloadingtimeforevery page thedetailedperformance breakdown as well as issued database queries.
for each application we firstly identify the top most timeconsuming controller actions among which we further classify an action aasproblematic ifiteitherspendsmore thanonesecondon theserverside meaningthatthecorrespondingend to endloading time would likely approach two seconds making it undesirable for most users or its performance grows super linearly as the databasesizeincreasesfrom200to2 000andthento20 000records.
theidentifiedactionsarethetargetofourstudyonperformance and scalability problems as we describe in section and .
.
report study methodology tocomplementtheaboveprofilingthatexaminesthelatestversion ofanapplicationusingoursyntheticdatasets wealsostudytheperformanceissues reportedby usersbased onreal world workloads andfixedbydevelopersforpastversionsoftheseormapplications so that we can understand how well these deployed applications performed in the past.
todoso weexamineeachapplication sbug trackingsystem.for 6applicationsthatcontainfewerthan1000bugreports asshownin table4 wemanuallycheckeverybugreport.forapplicationswith 1000to5000bugreports werandomlysample100bugreportsthat have been fixed and contain the keywords performance slow o r optimization.forredmineandgitlab whichhavemorethan10 000bugreports wesample200fromtheminthesameway.bymanually checking each report s discussion source code and patches weidentifytheonesthattrulyreflectperformanceproblemsrelatedto data processing on the server side.
every bug report is crosschecked by at least two authors.
this results in reports in total from all applications as shown in table .
2thedatabasesizewillincreasealittlebitduringprofilingassomepagescontainforms but the overall increase is negligible and does not affect our scalability comparison.figure end to end page loading time measured for top time consuming pages per application.
box to percentile red line median pa problematic actions from all applications see section .
.
figure percentage of server time among end to end time measured for top most time consuming pages per application.
red line median pa problematic actions from all applications see section .
.
threats to validity threats to the validity of our study could come from multiple sources.applicationsbeyondthese12applicationsmaynotshare the same problems as these applications.
the profiling workloadsynthesizedbyusmaynotaccuratelyrepresentthereal world workload.
the machine and network settings of our profiling may bedifferentfromrealusers setting.ourstudyofeachapplication sbug trackingsystemdoesnotconsiderbugreportsthatarenotfixed or not clearly explained.
despite these aspects we have made our best effort in conducting a comprehensive and unbiased study and we believe our results are general enough to guide future research on improving performance of orm applications.
profiling results end to end loading time.
weidentify the pageswith the most loading time for every application under the record databaseconfigurationandplottheiraverageend to endpageloading time in figure .
out of applications have pages whoseaverage end to end loading time i.e.
from browser sending the url request to page finishing loading exceeds seconds out of 12applicationshavepagesthattakemorethan3secondstoload.
tracksperformstheworst allofitstop10mosttime consuming pagestakemorethan2secondstoload.notethat ourworkloadissmalleror for some applications much smaller than today s real worldworkload.consideringhowthereal worldworkload s size will continue growing these results indicate that performance problems are prevalent and critical for deployed rails applications.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table number of problematic actions in each application app ds lo gi re sp ro fu tr da on ff os slow not scalable slow not scalable server vs. client.
we break down the end to end loading time ofthetop10pagesineachapplicationintoservertime i.e.
time for executing controller action including view rendering and data access onrailsserver clienttime i.e.
timeforloadingthedomin thebrowser andnetworktime i.e.
timefordatatransferbetween server and browser .
as shown in figure server time contributes to at least40 of the end to end latencyfor more than half ofthe top pages in all but application.3furthermore over of problematic pages spend more than of the loading time on railsserver asshownbytherightmostbar labeled pa infigure3.
thisresultfurthermotivatesustostudytheperformanceproblems on the server side of orm applications.
problematic server actions.
table shows the number of problematicactionsforeachapplicationidentifiedusingthemethodology discussed in section .
.
in total there are problematicactions identified from the top most time consuming actionsof every application.
among them have scalability problemsand take more than second of server time.
half of the pagesthat correspond to these problematic actions take more than2 seconds to load as shown in the rightmost bar labeled pa i n figure .
in addition we find performance issues in these problematicactions andwewilldiscussthemindetailinsection5.
causes of inefficiencies after studying the performance issues in the problematic actions and the issues reported in the applications bug tracking systems wecategorizetheinefficiencycausesintothreecategories orm api misuses database design and application design.
in the following we discuss these causes and how developers have addressedthem.webelievethesecausesapplytoapplicationsbuilt usingotherormframeworksaswell aswewilldiscussinsection8.
.
orm api misuses abouthalfoftheperformanceissuesthatwestudiedsufferfrom apimisuses.inthesecases performancecanbeimprovedbychanging how the rails apis are used without modifying program se mantics or database design.
while some of these misuses appear simple making the correct decision requires deep expertise in the implementation of the orm apis and query processing.
.
.
inefficient computation ic in these cases the poorly performing code conducts useful computation but inefficiently.
such cases comprise more than of theperformanceissuesinbothbugreportsandproblematicactions.
inefficientqueries.
thesameoperationonpersistentdatacan beimplementedviadifferentormcalls.however theperformance of the generated queries can be drastically different.
this problem has not been well studied before for orm applications.
figure4showstwowaysthatanonlineshoppingsystemchecks ifthereareproduct variants whoseinventoryarenottracked.the 3partoftheservertimecouldoverlapwiththeclienttimeorthenetworktime.however our measurement shows that the overlap is negligible.table inefficiency causes across applications dslogiresprofutrdaonffossum orm api misuse ic0000010122208 uc0300000000205 id01003203230115 ud0010000000001 ir0310000100005 database design problems mf0001000000113 mi0100000000203 application design tradeoffs dt100202610010022 ft0200000000002 sum181724253178271711109204 data with white background shows issues from problematic actions data with gray background shows issues from bug tracking systems ic inefficient computation mf missing fields uc unnecessary computation mi missing indexes id inefficient data accessing dt content display trade offs ud unnecessary data retrieval ft functionality trade offs ir inefficient rendering ruby code differs only in the use of any?vsexists?.
however the performance of the generated queries differs substantially the generated query in figure a scans all records in the variants tabletocomputethecountifnoindexexists butthatinfigure4 b onlyneedstoscanandlocatethefirst variantrecordwherethe predicate evaluates to true.
spreedevelopers discovered and fixed this problem in spree .4our profiling finds similar problems.
forexample simplyreplacing any?withexists?
inaproblematic actionof onebody improvesservertimeby1.
.ourstaticchecker that will be discussed in section finds that this is a common problemasitappearsinthelatestversionsof9outof12applications under study.
anothercommonproblemisdevelopersusingapicallsthatgeneratequerieswithunnecessaryorderingoftheresults.forexample ror diaspora and spree developers use object.where c .first togetanobjectsatisfyingpredicate cinsteadof object.find by c notrealizingthattheformerapiorders objectsbyprimarykey after evaluating predicate c. as a fix both gitlab and tracks developers explicitly add except order in the patches to eliminate 4we usea nto denote report number nin application a s bug tracking system.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a inefficient b efficient figure different apis cause huge performance difference figure a loop invariant query in redmine unnecessaryordering inthe queries further showinghow simple changes can lead to drastic performance difference.
moving computation to the dbms.
as the orm framework hides thedetails ofquery generation developers oftenwrite code that results in multiple queries being generated.
so incurs extranetworkround trips orrunningcomputationontheserver rather than the dbms which leads to performance inefficiencies.
for example the patch of spree replaces if exist?
find else create withfind or create by where the latter combines two queries that are issued by existandfind create intoone.thepatchof spree replacespluck total .sum withsum total .
the former uses pluckto issue aquery toload thetotalcolumn of all corresponding records and then computes the sum in memory while the latter uses sumto issue a query that directly performs the sum in the dbms without returning actual records to the server.
the patch of gitlab replaces pluck id pluck id which replaces two queries and an inmemoryunionvia withonesql unionquery ineffectmoving the computation to the dbms.
such api misuses are very common and occur in many applications as we will discuss in section .
therearealsomorecomplicatedcaseswherealoopimplemented in ruby can be completely pushed down to dbms which has been addressed in previous work using program synthesis .
moving computation to the server.
interestingly there are caseswherethecomputationshouldbemovedtotheserverfrom thedbms.asfarasweknow thisissuehasnotbeenstudiedbefore.
for example in the patch of spree developers replace objects.count withobjects.size in different locations as countalwaysissuesa countquerywhile sizecountsthe objects inmemoryiftheyhavealreadybeenretrievedfromthedatabasebyearliercomputation.suchissuesarealsoreportedin gitlab .
summary.
rails likeotherormframeworks letsdevelopers implement a given functionality in various ways.
unfortunately developers often struggle at picking the most efficient option.
the deceptivenamesofmanyrailsapislike countandsizemakethis even more challenging.
yet we believe many cases can be fixed using simple static analyzers as we will discuss in section .
.
.
unnecessary computation uc morethan10 oftheperformanceissuesarecausedby mis using orm apis that lead to unnecessary queries being issued.
this type of problems has not been studied before.
figure a query with known results in tracks loop invariant queries.
sometimes queries are repeatedly issuedtoloadthe samedatabasecontentsandhenceareunnecessary.
for instance figure shows the patch from redmine .
this code iterates through every custom field valueand retains only those that userhas write access to.
to conduct this accesspermission checking in every iteration read only attribute names user issuesaquerytogetthenamesofallread onlyfields ofuser asshownbytheredhighlightedlineinthefigure.then ifvaluebelongs to this read only set it will be excluded from the return set of thisfunction i.e.
the rejectat the beginning ofthe loop takes effect .
here the read only attribute names user query returns exactly the same result during every iteration of the loop and causes unnecessary slowdowns.
as shown by thegreen lines in figure redmine developers hoist loop invariant read only attribute names user outsidetheloopandachieve more than speedup for the corresponding function for their workload.
similar issues also occur in spree and discourse.
dead store queries.
in such cases queries are repeatedly issued to load differentdatabase contents into the same memory object while the object has not been used between the reloads.
for example in spree every shopping transaction has a correspond ing orderrecord in the orderstable.
this table has a has many association relationship with the line items table meaning that everyordercontainsmultiplelinesofitems.whenevertheuserup dateshis hershoppingcart the line items tablewouldchange at whichpointtheoldversionofspreealwaysusesan order.reload to make sure that the in memory copy of orderand its associated line item s are up to date.
later on developers realize that this repeatedreloadisunnecessary becausethecontentof orderisnot usedbytheprogramuntilcheckout.consequently in spree developersremovemany order.reload frommodelclasses and instead add it in a few places in the before payment action of the checkout controller where the orderobject is to be used.
queries with known results.
a number of issues are due to issuingquerieswhoseresultsarealreadyknown henceincurring unnecessarynetworkroundtripsandqueryprocessingtime.an exampleisin tracks .asshowninfigure6 thecodeoriginally issues a query to retrieve up to show number completed number of completed tasks.
clearly when show number completed is the query always returns an empty set due to limitbeing .
developers later realize that is a very common setting for show number completed .
consequently they applied the patch shown in figure to only issue the query when needed.
summary.
whilesimilarissuesingeneralpurposeprograms canbeeliminatedusingclassiccompileroptimizationtechniques e.g.
loopinvariantmotion dead storeelimination orm applications is difficult as it involves understanding databasequeries.
weare unawareofany compilersthatperform such transformations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure inefficient lazy loading in lobsters figure inefficient eager loading in spree .
.
inefficient data accessing id problems under this category suffer from data transfer slow downs including not batching data transfers e.g.
the well known n problem or batching too much data into one transfer.
inefficientlazyloading.
asdiscussedinsection2 whenaset of objects oin table t1are requested objects stored in table t2 associated with t1andocan be loaded together through eager loading.
if lazy loading is chosen instead one query will be issued to load nobjects from t1 and then nseparate queries have to beissuedtoloadassociationsofeachsuchobjectfrom t2.thisis known as the n query problem.
while prior work has studied this problem we find it still prevalent it appears in problematic actions and performance issues in our study.
figure 7shows an examplethat we findin thelatest version of lobsters wherethedeletedcoderetrieves50 modsobjects.then for each mod a query is issued to retrieve its associated story.
using eager loading in the added line all queries and hence 51networkround trips willbecombinedtogether.inourexperiments the optimization reduces the end to end loading time of the corresponding page from .
seconds to .
seconds.
inefficient eager loading.
however always loading data eagerly can also cause problems.
specifically when the associated objects are too large loading them all at once will create huge memorypressureandevenmake theapplicationunresponsive.in contrasttothe n lazyloadingproblem thereislittlesupport for developers to detect eager loading problems.
inspree a spree user complains that their installation performsverypoorlyontheproductsearchpage.developersfoundthattheproblemwasduetoeagerloadingshowninfigure8.intheuser sworkload whileloading405 products todisplayonthepage eagerloading causes13811related variants productscontaining 276220option values i.e.
productinformationdata tobeloaded altogether makingthepagefreeze.asshowninfigure8 thepatch delays the loading of option values fields ofvariants products.
notethatthese option values areneededbylatercomputation and the patch delays but not eliminates their loading.
inefficientupdating.
likethe n problem developerswould issuenqueriestoupdatenrecordsseparately e.g.
objects.each o o.update end rather than merging them into one update e.g.
objects.update all .thisisreportedinredmineandspree and our static checker to be discussed in section finds this to becommoninthelatestversionsof6outofthe12studiedapplications.
.
.
unnecessary data retrieval ud unnecessary data retrieval happens when software retrieves persistent data that is not used later.
prior work has identifiedthis problem in applications built using both hibernate and rails .
in our study we find this continues to be a problem in one problematic action in the latest version of gitlab and performanceissuereports.particularly fixingtheunnecessarydata a inefficient partial rendering b efficient partial rendering figure inefficient partial rendering in gitlab retrieval in the latest version of gitlab can drop the end to endloading time of its dashboard milestones index page from .
to1.1secondsinourexperiments.wealsoseesomeunnecessary dataretrievalcausedbysimplemisusesofapisthathavesimilar names map id retrievesthewholerecordandthenreturns theidfield yet pluck id only retrieves the idfield.
.
.
inefficient rendering ir irreflectsatrade offbetweenreadabilityandperformancewhen a view file renders a set of objects.
it has not been studied before.
givenalistofobjectstorender developersoftenusealibrary function like link to online4offigure9 a torenderoneobject andencapsulateitinapartialviewfilesuchas milestone.html.haml infigure9 a .then themainviewfile index.html.haml simply applies the partial view file repeatedly to render all objects.
the inefficiency is that a rendering function like link to is repeatedly invoked to generate very similar html code.
instead the view file could generate the html code for one object and then use simple string substitution such as gsubin figure b to quickly generate thehtmlcodefortheremainingobjects avoidingredundantcom putation.thelatterwayofrenderingdegradescodereadability but improves performance substantially when there are many objects to render or with complex rendering functions.
although slow rendering is complained such transformation hasnotyetbeenproposedbyissuereports.ourprofilingfindssuch optimization speedsup5pr oblematic actions by .
on average.
.
database design problems anotherimportantcauseofperformanceproblemsissuboptimal database design.
fixing it requires changing the database schema.
.
.
missing fields mf decidingwhichobjectfieldtobephysicallystoredindatabaseis a non trivial part of database schema design.
if a field can be easily derived from other fields storing it in database may waste storage space and i o time when loading an object if it is expensive to compute notstoringitindatabasemayincurmuchcomputation cost.decidingwhenapropertyshouldbestoredpersistentlyisa general problem that has not been studied in prior work.
forexample whenweprofilethelatestversionofopenstreetmap a collaborative editable map system we find that a lot of time is spent on generating a location name string for every diary based onthediary slongitude latitude andlanguagepropertiesstored inthediary entry table.suchslowcomputationresultsinaproblematicactiontaking1secondtoshowonly20diaries.however the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
location name isusuallyashortstringandremainsthesamevalue sincethelocationinformationforadiarychangesinfrequently.storingthisstringphysicallyasadatabasecolumnavoidstheexpensive computation.
we evaluate this optimization and find it reducing the action time to only .
second.
weobservesimilarproblemsinthebugreportsoflobster spree andfallingfruit andinthelatestversionofredmine fallingfruit and openstreetmap.
clearly developers need help on performance estimationtodeterminewhichfieldstopersistentlystoreindatabase tables.
.
.
missing database indexes mi having the appropriate indexes on tables is important for query processingandisawell studiedproblem .asshownintable6 missingindexisthemostcommonperformanceproblemreportedin orm application s bug tracking systems.
however it only appears in three out of the problematic actions in latest versions.
we speculate that orm developers often do not have the expertiseto pick the optimal indexes at the design phase and hence addtable indexes in an incremental way depending on which query performance becomes a problem after deployment.
.
application design trade offs developers fix out of the issue reports by adjusting applicationdisplayorremovingcostlyfunctionalities.wefindsimilar design problems in latest versions of out of orm applications.
itisimpracticaltocompletelyautomatedisplayandfunctionality design.
however our study shows that orm developers need tool support whichdoesnotexistyet tobemoreinformedaboutthe performance implication of their application design decisions.
.
.
content display trade offs dt in our study the most common cause for scalability problems isthatacontrolleractiondisplays alldatabaserecordssatisfying certainconditioninonepage.whenthedatabasesizeincreases the correspondingpagetakesalotoftimetoloadduetotheincreasing amount of data to retrieve and render.
this problem contributes to out of the problematic actions that do not scale well in our study.
it also appears in out of issue reports and is always fixed bypagination i.e.
displayonly a fixednumber of recordsin one page and allow users to navigate to remaining records.
forexample in diaspora developersusedthe will paginate library torender25contactsperpageandallowuserstosee theremainingcontactsbyclickingthenavigationbaratthebottom ofthepage insteadofshowingallcontactswithinonepageasin the old version.
clearly good ui designs can both enhance user experience and improve application performance.
unfortunately the lack of pagination still widely exists in latest versionsoformapplicationsinourstudy.thisindicatesthatorm developersneeddatabase awareperformance estimationsupport to remind them of the need to use pagination in webpage design.
.
.
application functionality trade offs ft it is often difficult for orm developers to estimate performance of a new application feature given that they need to know what queries will be issued by the orm how long these queries will execute and how much data will be returned from the database.
in ourstudy allbuttwoapplicationshaveperformanceissuesfixed by developers through removing functionality.
a server timespeedup b line of code changes figure performance fixes and loc involved forexample tracks madeatrade offbetweenperformance andfunctionalitybyremovingasidebarontheresultingpage.this sidebarretrievesanddisplaysall theprojectsandcontextsofthe currentuser andcostsalotoftimeforuserswhohaveparticipated in manyprojects.
in theside bar code theonly data related part is simply a sidebar.active projects expression which seems like a trivial heap access but actually issues a selectquery and retrieves a lot of data from the database.
as another example our profiling finds that the story.edit actioninthelatestversionoflobsterstakes1.5secondsjusttoexecute one query that determines whether to show the guidelines for users when they edit stories while the entire page takes seconds to load altogether.
since the guidelines object only takes very small amount of space to show on the resulting page removing suchcheckinghasnegligibleimpacttotheapplicationfunctionality yetitwouldspeedupthe loading time of that page a lot.
ingeneral performanceestimationforapplicationsbuiltusing ormsisimportantyethasnotbeendonebefore.itismoredifficult as compared to traditional applications due to multiple layers of abstraction.
we believe combining static analysis with query scalability estimation will help developers estimate application performance as we will discuss in section .
fixing the inefficiencies after identifying the performance inefficiencies in the problematicactionsacrossthe12studiedapplications wemanuallyfixeachofthemandmeasurehowmuchourfixesimprovetheperformance of the corresponding application webpages.
our goal is to quantify the importance of the anti patterns discussed in section .
.
methodology we use the same record database configuration used in profiling to measure performance improvement.
for a problematic action that contains multiple inefficiency problems we fix one at a time and report the speedup for each individual fix.
to fix api use problems wechangemodel view controlfilesthatarerelatedtothe problematic apiuses to add missingindexes or fields wechange corresponding rails migration files to apply pagination we use the standard will paginate library .
we carefully apply fixes to make sure we do not change the program semantics.
finally for two actions in lobster we eliminate the expensive checking about whether to show user guidelines as discussed in section .
.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
results intotal 64fixesareappliedacross39problematicactions5tosolve the problems listed in table .
speedupofthefixes.
figure10 a showstheamountofservertime speedup and the sources of the speedup broken down into different anti patterns as discussed in section .
manyfixesareveryeffective.aboutaquarterofthemachieve morethan5 speedup andmorethan60 ofthemachievemore than speedup.
every type of fixes has at least one case where it achievesmorethan2 speedup.thelargestspeed upisaround39 achievedbyremovingunnecessaryfeaturein storiescontroller.new action in lobsters i.e.
the example we discussed in section .
.
.
there are fixes that alter neither the display nor the functionalityoftheoriginalapplication.thatis theyfixtheanti patterns discussed in section .
and .
.
they achieve an average speedup of .
with a maximum of .
speedup by adding missing fields inganttscontroller.show from redmine.
forall39problematicactions manyofwhichbenefitfrommore thanonefix theiraverageservertimeisreducedfrom3.57seconds to .
seconds and the corresponding end to end page loading time is reduced from .
seconds to .
seconds including client rendering and network communication.
in other words by writing codethatcontainstheanti patternsdiscussedearlier developers degrade the performance of their applications by about .
wehavereportedthese64fixestocorrespondingdevelopers.so far we have received developers feedback for of them all of whichhavebeenconfirmedtobetrueperformanceproblemsand7 have already been fixed based on our report.
simplicity of the fixes.
figure b shows the lines of code changes required to implement the fixes.
the biggest change takes 56linesofcodetofix foraninefficientrendering ir anti pattern whilethesmallestchangerequiresonly1lineofcodein27fixes.
morethan78 offixesrequirefewerthan5lines.inaddition among the fixes that improve performance by or more more than ofthemtakefewerthan10linesofcode.around60 offixesare intra procedural involving only one function.
theseresultsquantitativelyshowthatthereisstillahugeamount ofinefficiencyinreal worldormapplications.muchinefficiency can be removed through few lines of code changes.
a lot of the fixes can potentially be automated as we will discuss in section .
finding more api misuses someproblemsdescribedinsection5.1areaboutsimpleapimisuses.weidentify9suchsimplemisusepatterns aslistedintable andimplementastaticanalyzertosearchfortheirexistencein latestversionsofthe12ormapplications.duetospaceconstraints we skip the implementation details.
to recap these api patterns cause performance losses due to an inefficient query moving computation to the dbms moving computationtotheserver inefficientupdating and unnecessary data retrieval as discussed in section .
.
as shown in table every api misuse pattern still exists in at least one application s latest version.
worse patterns each 5amongthe40problematicactionsidentifiedbyourprofiling 1ofthem fromgitlab spendsmostofitstimeinfile systemoperationsandcannotbespedupunlessitscore functionality is modified.table api misuses we found in the latest versions app.
sum d s l o1 g i7301633002 r e3 s p2 r o f u000020000 t r4 d a o n f f200200000 o s sum any?
exists?
where.first find by .except order each.update update all .count .size .map .pluck pluck.sum sum pluck pluck sql union if exists?
find else create end find or create by occurinover30placesacrossmorethan5applications.wehave checkedallthese428placesandconfirmedeachofthem.forfurther confirmation we posted them to corresponding application s bugtrackingsystem andeverycategoryhasissuesthathavealready been confirmed by application developers.
api misuses have been confirmed and already fixed in their code repositories based on our bug reports.
none of our reports has been denied.
only out of these api misuses coincide with the performanceproblemslistedintable6andfixedinsection6.thisis becausemostofthese428casesdonotresideinthe40problematic actions that we have identified as top issues in our profiling.
how ever they do cause unnecessary performance loss which could be severeunderworkloadsthatdifferfromthoseusedinourprofiling.
insum theaboveresultsconfirmourpreviouslyidentifiedissues and furthermore indicate that simple api misuses are pervasive acrosseventhelatestversionsoftheseormapplications.yet there are many other types of api misuse problems discussed in section .
that cannot be detected simply through regular expression matching and will require future research to tackle.
discussion inthissection wesummarizethelessonslearnedandhighlightthe new research opportunities that are opened up by our study.
improving orm apis.
our study shows that many misused apis have confusing names as listed in table but are translated todifferentqueriesandhaveverydifferentperformance.renaming someoftheseapiscouldhelpalleviatetheproblem.addingnew apis can also help developers write well performing code without hurting code readability.
for example if rails provides native api support for taking union of two queries results like django does there willbefewer casesofinefficient computation suchas those discussed in section .
.
.
as another example better rendering api supports could help eliminate inefficient partial render authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
problemdiscussedinsection5.
.
.toourbestknowledge noorm framework provides this type of rendering support.
supportfordesignanddevelopmentoformapplications.
developersneedhelptobetterunderstandtheperformanceoftheir code especiallythepartsthatinvolveormapis.theyshouldfocusonnotonlyloopsbutormlibrarycalls e.g.
joins inperformance estimation since these calls often execute database queries and can be expensive in terms of performance.
building static analysis toolsthatcanestimateperformanceandscalabilityoformcode snippets will alleviate some of the api misuses.
more importantly thiscanhelpdevelopersdesignbetterapplicationfunctionalityand interfaces as discussed in section .
.
developers will also benefitfrom tools that can aid in database design suchassuggestingfieldstomakepersistent asdiscussedinsection5.
.whilepriorworkfocusesonindexdesign littlehas been done on aiding developers to determine which fields to make persistent.astheormapplicationalreadycontainsinformation onhoweachobjectfieldiscomputedandused thisprovidesagreat opportunity for program analysis to further help in both aspects.
compiler and runtime optimizations.
while some performanceissuesarerelatedtodevelopers designdecisions webelieve that others can be detected and fixed automatically.
previous work hasalreadytackledsomeoftheissuessuchaspushingcomputation down to database through query synthesis query batching and avoiding unnecessary data retrieval .
there are still many automatic optimization opportunities that remain unstudied.thisrangesfromcheckingforapimisuses aswediscussed in section to more sophisticated database aware optimization techniques to remove unnecessary computation section .
.
and inefficient queries section .
.
.
besides static compiler optimizations runtime optimizations or trace based optimization for orm frameworks are further possibilities for future research such as automatic pagination for applications that render many records runtime decisions to move computation between the server and the dbms runtime decisions toswitchbetweenlazyandeagerloading andruntimedecisions aboutwhethertoremovecertainexpensivefunctionalitiesasdiscussed in section .
.
.
automated tracing and trace analysis tools can help model workloads and workload changes which can then be used to adapt database and application designs automatically.such tools will need to understand the orm framework and the interaction among the client server and dbms.
generalizing to other orm frameworks.
ourfindingsand lessonsapply tootherorm frameworksaswell.
thedatabase design section .
and application design trade offs section .
naturallyapplyacrossorms.mostoftheapiuseproblems section .
like unnecessary computation uc data accessing id ud and rendering ir are not limited to specific apis and hence are general.
while the api misuses listed in table may appear to berailsspecific therearesimilarmisusesinapplicationsbuiltupon django orm as well exists is more efficient than count filter .get is faster than filter .first clear ordering true is likeexcept order all.update can batchupdates len isfasterthan count withloadedarrays only is likepluck aggregate sum is likesumin rails unionallowstwoqueryresultstobeunionedindatabase get or create islikefind or create by inrails .wesampled15issuereportseachfromtop3populardjangoapplications on github.
as shown below these performance issues fall into the same anti patterns our rails issue reports fall into ic uc id ud mf mi dt ft redash zulip 2django cms related work empiricalstudies.
previousworkconfirmedthatperformance bugs are prevalent in open source c java programs and often take developerslongertimetofixthanothertypesofbugs .prior work studiedtheperformanceissuesinjavascriptprojects.we target performance problems in orm applications that are mostly relatedtohowapplicationlogicinteractswithunderlyingdatabase andareverydifferentfromthoseingeneralpurposeapplications.
ourrecentwork lookedintothedatabaseperformanceoform applicationsanddiscussedhowbetterdatabaseoptimizationand querytranslationcanimproveormapplicationperformance.no issue report study or thorough profiling was done.
in contrast our paperperformsacomprehensivestudyonalltypesofperformance issuesreportedbydevelopersanddiscoveredusingprofiling.unnecessary data retrieval ud content display trade offs dt and part of the inefficient data accessing id anti patterns are the only overlap between this study and our previous work .
inefficiencies in orm applications.
previous work has addressedspecificperformanceproblemsinormapplications suchas locatingunneededcolumndataretrieval n 1query pushingcomputationtothedbms andquery batching .
while effective these tools do nottouch on many anti patternsdiscussed in our work like unnecessary computation uc inefficient rendering ir database designs mf mi functionality trade offs ft and also do not completely address anti patterns like inefficient computation ic and inefficient data accessing id .
performance issues in other types of software.
much researchwasdonetodetectandfixperformanceproblemsingeneral purpose software .
detecting and fixing ormperformanceanti patternsrequireacompletelydifferentsetoftechniquesthatunderstandormandunderlyingdatabasequeries.
conclusion database backed web applications are widely used and often built using orm frameworks.
we conduct a comprehensive study to understandhowwellsuchapplicationsperformandscalewiththedata theymanage.byprofilingthelatestversionsof12representative ormapplicationsandstudyingtheirbug trackingsystems wefind types of orm performance anti patterns and many performance problemsinthelatestversionsoftheseapplications.ourfindings openupnewresearchopportunitiestodeveloptechniquesthatcan help developers solve performance issues in orm applications.