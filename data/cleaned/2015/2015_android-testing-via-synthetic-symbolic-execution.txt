android testing via synthetic symbolic execution xiang gao national university of singapore singapore gaoxiang comp.nus.edu.sgshin hwei tan southern university of science and technology china tansh3 sustc.edu.cn zhen dong national university of singapore singapore zhen.dong comp.nus.edu.sgabhik roychoudhury national university of singapore singapore abhik comp.nus.edu.sg abstract symbolic execution of android applications is challenging as it involves either building a customized vm for android or modeling the android libraries.
since the android runtime evolves from one version to another building a high fidelity symbolic execution engine involves modeling the effect of the libraries and their evolved versions.withoutsimulatingthebehaviorofandroidlibraries path divergencemayoccurduetoconstraintlosswhenthesymbolicvalues flow into android framework and these values later affect the subsequentpathtaken.previousworkssuchasjpf androidhave relied on the modeling of execution environment such as libraries.
in this work we build a dynamic symbolic execution engine for android apps withoutany manual modeling of execution environment.environment orlibrary dependentcontrolflowdecisions in the application will trigger an on demand program synthesis steptoautomatically deducearepresentationofthelibrary.this representation is refined on the fly by running the corresponding librarymultipletimes.theoverarchinggoaloftherefinementisto enhancebehavioral coverageandto alleviatethepath divergence problem during symbolic execution.
moreover our library synthesiscanbemadecontext specific.comparedtotraditionalsynthesis approaches which aim to synthesize the complete library code our context specificsynthesisenginecangeneratemorepreciseexpressions for a given context.
the evaluation of our dynamic symbolic execution engine built on top of jdart shows that the library modelsobtainedfromprogramsynthesisareoftenmoreaccurate than the semi manual models in jpf android.
furthermore our symbolic execution engine could reach more branch targets as compared to using the jpf android models.
ccs concepts software and its engineering software testing and debugging corresponding author this work was done by the author at national university of singapore.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
android testing symbolic execution program synthesis acm reference format xiang gao shin hwei tan zhen dong and abhik roychoudhury.
.
androidtestingviasyntheticsymbolicexecution.in proceedingsofthe2018 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 11pages.
introduction symbolicexecutionisapowerfulprogramanalysistechniquewhich can simultaneously explore multiple program paths that a programcouldtakeunderdifferentinputs.however itisdifficultto apply it to framework oriented android apps because android framework is very complex and it is built with multiple languages.
moreover androidframeworkcannotbeexecutedoutsideandroid devices emulators.
one common solution to this problem is to manually generate a framework modelthatsimulatestheframeworkbehaviorbutcan besymbolicallyexecuted.forexample jpf android relieson a semi manual created model of android framework that can be symbolicallyexecutedonjava virtualmachine.however significanteffortneedstobespentonwritingmodelsofandroidlibraries.
accordingto astudy onthe androidecosystem android isevolvingrapidlyatanaveragerateof115apiupdatespermonth .
the rapid evolution of android api poses additional challenges for applying these approaches in practice.
to relieve the burden of writingframeworkmodels pasket exploresthepossibilityof synthesizingframeworkmodelsforsymbolicexecution.itleverages severaldesignpatterns e.g theobserverpatterns tosynthesize modelsforseveralclassesinandroidframeworksandthesemodels arethenpassedtooff the shelfsymbolicexecutionenginewhere thesymbolicexecutionenginesimplyservesasaseparatevalidationstepforthecorrectnessofthesynthesizedmodels.insteadof incorporating the constraints gathered during symbolic execution pasket requires tutorial programs to exercise the target models.
anotherstandardsolutionistoperformconcreteexecutionof theframeworkcodetoprovideenvironmentmodelsforsymbolic execution of a particular code of interest such as app code.
forexample s 2e performs symbolic execution on specified components and concretely executes other components.
meanwhile existing concolic execution techniques on android apps such as acteve andcollider usesinstrumentationfor constraint tracking.
one of the major challenges in such approaches is the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france xiang gao shin hwei tan zhen dong and abhik roychoudhury problemof pathdivergence wheremissed instrumentationscould leadtothedivergencebetweentheconcreteandsymbolicexecution paths .moreover thepathdivergenceproblemmayimpair thesoundnessandcompletenessoftheconcolicexecution.without symbolic execution of framework code certain path constraints can be missed when symbolic values flows into the framework.
in this paper we present synthetic symbolic execution a se m bodied by our tool synthesise.
it is a concolic execution approach for android apps that aims to alleviate all of the above mentioned problems.insteadofrelyingonmanuallywrittenmodelsforandroidframework ourapproachautomaticallydeducesexpression representing android models dynamically during the execution.
when dependent control flow decisions are encountered in subsequent execution the deduced expression will be refined with the ultimate goal of enhancing branch coverage and to alleviate thepath divergenceproblem.moreover insteadofgenerating the entire android model classes in a single step our library synthesis is context specific which allows it to generate more precise expression for a given context.
symbolicexecutionofapplicationsalwaysrequirescaptureofthe environment whichincludeslibraries.thetwoextremeapproaches are thein vitroapproach where theeffect of the libraries are modeled andthe in vivoapproachwheretheeffectoflibraries environmentarecapturedviawholesystemexecution.forcprograms the klee tool embodies the in vitro approach and the s2e tool embodiesthein vivoapproach.atahighlevel ourapproachlies inbetweenthein vivoandin vitroapproaches.wedonotmodel the libraries and yet we go beyond concrete execution of libraries.
instead we synthesize expressions to capture the effect of libraries with the goal of enhancing branch coverage in testing.
we have implemented a dynamic symbolic execution platform for android apps.
in summary we make the following contributions.
on demand framework synthesis.
we present an approach which synthesizes the relationship between symbolic inputs and outputsforaframeworklibraryduringconcreteexecution.using the deduced relationship we collect more complete path constraints from the programs to explore paths which are missed by symbolicexecutionduetoconcreteexecutionofframeworkcode.
weimplementadynamicsymbolicexecutionplatformforandroidappswhichcouldbeusedforenhancingtestingofandroid apps.
as our approach does not require manual modeling our platformisagnostictodifferentandroidsdkversions.moreover this approach could be used for the symbolic execution of any code that uses libraries.
incorporatingguiconstraints.
androidappsrelyongraphicaluserinterface gui tointeractwithusers.guiconstraint imposesrestrictionstothelayoutandapplicationresourcesdefined in an android app.
our platform automatically extracts theseconstraintsandincorporatesthemintosymbolicexecution for exploration of android apps.
importance of modeling android libraries we perform a study of android apps in the androtest benchmark t o investigatehowoftentheresultsofinvokingandroidlibraries affectthedependentbranchdecisioninandroidapps.ourstudyshowsthat37.
ofbranchesinandroidappsareaffectedbythe results of executing android libraries.
evaluation.
weevaluateourapproachon14androidappsby comparing oursynthesized models against realimplementation andsemi manuallycreatedmodelsinjpf android.ourevaluationshowsthatifwetreatallthebranchesaffectedbyanandroid library invocation as targets our synthesized models are able to reach more targets than the models used in jpf android.
background concolic execution.
concolic execution is a program analysis techniquecombiningconcreteexecutionandsymbolicexecution.
it uses a concrete value cto generate a path c and uses symbolic executionalongthepathtocomputea pathcondition pc.systematic negation of branch conditions in the path condition pcthen leadstomodifiedconstraints pc prime whichissolvedtogenerateinputs which trace different paths.
the process is repeated to obtain a test suite with high path coverage.
concolic execution has beenused to analyze android apps for event generation and fault localization .
typically it is performed either on a java symbolic engine with android library models or on android runtime using instrumentation techniques to trace the app execution for constraintscollectionandexploredifferentpathswithgenerated inputs.
program synthesis.
program synthesis has been formalized to be asecond orderconstraintsolvingproblemthroughpropositional synthesisencoding recentlyin andweusethisworkinour testing method.
given a set of components it will construct the set of terms and represent them via a tree.
boolean variables si called selector variables are assigned to choose a particular term from among a set of terms.
specifically each leaf of the tree corresponds tocomponentswithoutinputandintermediatenodehasasmany subnodes as the maximal number of inputs of a component.
foreach node iwith sub node i1 i2 ... ik the output and inputs are representedby outiand outi1 outi2 ... outik respectively.inaddition sj iis thej th selector of node i which means j th component is used in this node cis the number of components fjis the semantics of j th component.
for node i a set of terms is encoded as i node choice such that node c logicalanddisplay.
j 1sj i outi fj outi1 outi2 ... outik choice exactlyone s1 i s2 i ... sc i nodedescribesthesemanticrelationsbetweentheoutputvalueof nodeiand the output value of its subnode while choicerestricts that onlyone component isselected inside eachnode.
given aset ofinput outputpairs thisalgorithmshouldreturnasetofnodes satisfyingtheinput outputrestriction.usingtheaboveencoding thesecond orderconstraintsolvercanbeimplementedontopof the first order solver.
the importance of modeling android libraries to study the importance of encapsulating the constraints given by androidlibraries weperformaninitialinvestigationof68android appsintheandrotestbenchmark acommonlyusedbenchmark inpriorevaluationsofandroidtestingtechniques .ourgoal authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
android testing via synthetic symbolic execution ase september montpellier france !
!
!
!
.
.
.
!
.
!
!
!
!
!
!
!
!
.
!
!
!
!
!
.
!
!
!
.
.
.
.
.
!
!
.
.
a figure the number of branches affected by android library calls and the corresponding percentage istoinvestigatehowoftentheresultsofinvokingandroidlibraries affectthedependentbranchdecisioninandroidapps.toachieve this goal we perform taint analysis to determine whether there existsaninformationflowfromandroidlibrarycallstosubsequent branches in the evaluated android apps.
specifically we modify flowdroid a taint analysis tool by specifying all android libraries as source and branches as sink to count the numberof paths from source to sink .
we also instrument apps using soot to compute the total number of branches.
our investigation aims to answer two questions q1 what is the general structure of android apps in terms of control flow?
what is the number of branches in apps?
q2 howwouldtheresultsofinvokingandroidlibrariesinfluence the branch decisions in android apps?
we study q1 to obtain an overview of the control structure in android apps.
our main goal in q1 andq2 is to compute the percentageofbranchdecisionsaffectedbytheresultsofinvoking android libraries.
figure1shows the results of our study.
the x axis in figure denotesthenamesoftheevaluatedapps whereasthey axisonthe left and the bar represent the number of branches in each app that areaffectedbytheresultsofinvokingandroidlibraries.meanwhile thedashedlineandthey axisontherightoffigure 1denotethe percentageofbranchesaffectedbyandroidlibrarycalls computed using the equation in the following.
branches affected ofbranches affected total of branches accordingtofigure thebranchdecisionsofmostappsareheavily influenced by android libraries.
on average .
of branches in the evaluated android apps are affected by the results of invoking android libraries.
figure 1also shows that in one extreme case although the gestures app only contains six branches in total all of its branches are affected by android library calls.
overall our studydemonstrates ahigh percentageof branchesin android apps are affected by android library calls.
hence we derive that if androidlibrariesarenotproperlymodeledbyasymbolicexecution engine the constraints imposed by android libraries in android apps may be lost.
subsequently the inappropriate modeling of android libraries may also hinder the ability of a symbolic execution engine to explore more program branches.
public boolean ontouchevent motionevent event floatx event.getx floaty event.gety intoffset getoffsetforposition x y putoffsetinrange offset .
.
.
private int putoffsetinrange into intoffset o editable text gettext intreallength text.l ength if offset reallength return offset editable editable gettext while offset fi ndtext editable offset findchip offset null offset return offset listing1 theontoucheventeventhandleroftagactivity overview we give a high level overview of synthetic symbolic execution and synthesise by presenting an example android application tagactivity.
tagactivity is an android open source text tag editor that generates tags using user text input.
listing 1shows the simplified source codes of one event handler ontouchevent which will be invoked when user touches the screen.
the execution of this event handler proceeds as follows extracting the touchcoordinates x y invoking android library method getoffsetforposition withtouchcoordinatesasparameters triggeringa local method putoffsetinrange which contains at least four path conditions including path conditions inside findtextandfindchip that are related to the return variable of getoffsetforposition.
existingsymbolicexecutionapproachesmayfaceseveralchallengeswhenanalyzingthissimpleandroidapp.first pathexplosion may occur when these techniques symbolically execute the wholeandroidappandframework.second someandroidlibraries suchasgetx cannotbesymbolicallyexecuted sinceitwillinvokea nativecallwhichisimplementedintheclanguage.althoughexisting symbolic execution techniques could leverage pre built models forandroidlibraries buildingmodelsisatime consumingtaskand the manually automatically designed model may be imprecise.
for example in the model of jpf android the method getoffsetforpositioninlisting 1simplyreturnsaconstantglobalvariabletop int.
another option is to concretely execute android libraries while performingsymbolicexecutionofappcode.however thesymbolic relationship between the input x y and the output offsetwill be lostifthelibrarycodeisconcretelyexecuted.therefore existing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france xiang gao shin hwei tan zhen dong and abhik roychoudhury !
!
figure workflow of on demand synthesis for symbolic execution symbolicexecutionenginescannotgeneratethecorrectinputs x y toexploreprogrambranchesthatareaffectedbytheoutput offset .
to solve the above mentioned problems synthesise is designed toefficiently explorebehaviorsthatare constrainedbythereturn valuesofconcretelyexecutedlibrary.forexample ifweconcretely execute the method getoffsetforposition the execution of line listing1 is constrained by the concrete execution result.
to continue the symbolic exploration after concrete execution symbolic relation between its input and output should be recovered.
the key idea of synthesise lies on the symbolic concrete transition across the symbolic concrete execution boundary.
the interleaving between symbolic value and concrete value must behandled carefully to preserve the consistency and completeness.
we now describe how we handle the transition.
symbolic concrete transition when a library that should beconcretelyexecutedisinvokedanditsparametersaremarked symbolic theconcretevaluesfortheargumentsshouldbegenerated.theconcretizationofsymbolicvariablescanaffectsubsequent path exploration by incorrectly ruling out certain paths.
s2e uses a back and forth mechanism for switching between symbolic and concrete execution to ensure the execution consistency .
different from s2e synthesise does not suffer from the path missing problem due to concretization as it performs concolic execution fromthebeginningoftheexecution.synthesiseretainsconcrete valueaswellassymbolicvalueforeachvariableateachprogram point.therefore itcandirectlyinvokeaconcreteexecutionwith the concrete values of its parameters without affecting the subsequent symbolic exploration.
concrete symbolic transition we consider two situations where concrete value is transferred to symbolic thereturnvalueoflibrarymethodsthatobtainuserinputs likegetx in listing the return value of library method if its return value is dependent on its symbolic arguments.
for the first scenario a new symbolic variable will be created.
for the second scenario we will illustrate our workflow in figure .
assumethatthelibrarycode getoffsetforposition representedby fin figure should be concretely executed and x yare symbolic variables.
this method is invoked with the concrete value of its parameters.dueto theconcreteexecution thesymbolicinformationofparameterscannotflowintotheoutput offset .therefore a function x y is introduced to represent the android library call f .
meanwhile the symbolic value of method output offset will be regarded as x y .
in the subsequent execution there is path condition x y related to variable o. assume that inthe first iteration of the execution we explore the left path then we can generate a path constraint x y along with the concreteexecution.
to explore adifferent path wenegate the corresponding path condition and provide the generated path constraints x y 0tothesolver.asfunction x y isunknown asynthesisprocesswillbetriggeredtodeducetherelationbetween inputs x y and output offset .
with the initialized expression e a newvalue x y willbegeneratedbysolving x y e. ideally the solution x y should allow us to explore the target path.however sincewecannotensurethatthesynthesizedexpression x y represents fcorrectly thissolutionmayfailtofollow the negated path.
if the input x y could trigger the execution of the target path then we derive a new input.
otherwise the expressionewill be refined based on the newly generated input x y and its corresponding output o .
furthermore application configurations or ui hierarchy may impose additional constraints on the variables.
in this example touch coordinates x y must be within the scope of the screen.
we define such constraints as gui constraint which can be missed by concretely executing library code.
therefore we introduce a strategy to collect gui constraint by parsing app configuration xml and monitoring ui hierarchy.
approach inthissection wefirstintroducethenotationsthatweuse andthen we present the on demand program synthesis and the extension of traditional concolic execution technique.
throughout this section prepresentstheprogramundertest xtodenotethesetofsymbolic variables and to denote the library function to be synthesized.
.
on demand analysis algorithm 1showsthekeystepsinouron demandanalysisbuilt on top of existing concolic execution engine.
the algorithm operates on an android app that consists of java source code with function calls to android libraries.
the pathexploration procedure is similar to traditional concolic execution approaches where symbolic execution is run simultaneously with concrete execution andpathconstraints pcarecollectedalongsidewiththeconcrete execution.
the pathexploration procedure proceeds by invoking theexecuteconcolic procedure that iterates through each program statement.
for each program statement stmt executeconcolic procedure distinguishes between two kinds of statements statementsthatinvolveinvocationsofandroidlibrariesand other statementsthatcanbetreatedasregularjavastatements.thealgorithm will process the second kind of statements by invoking authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
android testing via synthetic symbolic execution ase september montpellier france algorithm syntheticsymbolicexecution themainprocedure is pathexploration 1procedure executeconcolic program p symbolic x 2symbolic memory s 3concrete memory c 4path condition pc 5library functions 6stmt stmt0 initial program statement 7whilestmt nelementexitsdo switchstmtdo casey libraryinvocation v0 v1 ...vn do c executeconcrete stmt c c d v v v0 v1 ...vn s nequalnull if!isempty d then s s d d s s end otherwise do executejavaconcolic stmt pc end end stmt p.getnextstmt 23end 24return angbracketleftpc angbracketright 26procedure pathexploration program p 27x init 28whilex nequalnulldo angbracketleftpc angbracketright executeconcolic p x select one condition to negate pci select pc pc prime pci pc pci contains pc prime if!isempty then x synthesize pc prime else x solve pc prime end 38end a concolic execution engine for java programs lines .
for the statements that contain invocations of android libraries we assumethattheyareoftheform y libraryinvocation v0 v1 ...vn where the effect of calling an android library function will be captured through its return values1.
we execute the statements that involveandroidlibraryfunctioncallsandanalyzethestatementtocheck if it satisfies two criteria at least one of the function argumentsissymbolicvariable line12 and itsreturnvalueis accessed in subsequent branch conditions in the program line .
as our synthesis engine is triggered when an android library invocation satisfies these two criteria our synthesis engine is invoked on demand.
in line the to be synthesized function collects all 1a function where its return value is not stored is rewritten with new temporary variable that store the return value.algorithm iterative synthesis 1procedure synthesize program p pathcond pc func in0 out0 from initial execution 2e out0 3r angbracketleftin0 out0 angbracketright 4synthesisiteration 5whilesynthesisiteration ldo x prime solve pc e ifunsat or unknown then x prime solve pc nequale ifunsat or unknown then returnnull unsatisfiable pc end end angbracketleft rio angbracketright concreteexecution p x prime r r rio if tar etthen returnx prime else e componentbasedsynthesis r end synthesisiteration 21end argumentsofthefunction libraryinvocation thatcontainsymbolic values.
after that our algorithm maps the return variable yto the to be synthesized function in our symbolic memory s line .
afterprocessingtheprogramstatementsonline29 theconcolic executionengineproceedsbypickingaconditiontonegateinordertovisitanewexecutionpath line30 .inlines32 ifthemodifiedpathconstraint pc primecontainstheto be synthesizedfunction our algorithm will trigger the synthesis procedure to generate new input to explore a new execution path.
otherwise our engine will solve the modified path condition like regular concolic execution.
.
synthesis one of the main challenges in concolic execution is the problem whereconcolictestingmaygetstuckinexploringahugenumberof programpathsbefore reachingthetargetstate .oursynthesis engine aims to solve this problem by synthesizing a representation for the android library invocation.
specifically we consider all the subsequentbranchdecisionsthataredependentontheresultsof theandroidlibraryinvocationasthetargetstates tar et.during thepathexploration ageneratedinputmaynotbeabletoreachthe target states or no input satisfies the condition of the target states duetotheinaccuratelibrarysynthesis.forsuchcases weconcretelyexecutetheprogramanditerativelyrefinethesynthesizedfunction until generated inputs reach the target states.
.
.
iterative refinement.
algorithm 2presentsouriterativerefinementsteps.inpractice pathconditionscollectedbyconcolicengine might be computed with symbolic values from multiple to be synthesizedfunctions.ouralgorithmrefineseachoftheinvolved functions independently using the same process.
for the sake of simplicity we demonstrate iterative refinement with a single synthesized function in algorithm .
given the input output authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france xiang gao shin hwei tan zhen dong and abhik roychoudhury table the categorization of synthesis components level type elements constant constants bitwise arithmetic flow control ite if then else array access array pair angbracketleftin0 out0 angbracketrightfrom the initial concrete execution of an android library function the synthesize procedure starts by initializing the synthesizedexpression etotheoutput out0 constantexpression of the android library function line .
then our synthesis engine conjoins the constraint erepresented by the synthesized expressionwiththepathconstraint pcandpassthisnewconstraintto thesmtsolver line6 .ifthesolverreturnsunsatorunknown this unsatisfiability may be caused by pcor the introduced constraint e.therefore wewilltrytosolve pc nequale.ifthesolver still returns unsat or unknown that means pcis unsatisfiable andwedirectlyreturnnull.otherwise wegenerateanewinput x prime and perform concrete execution of program pusing the updated input to obtain additional input output pair rio line .
when ouralgorithmhassuccessfullysynthesizedalibraryrepresentation toreachthetargetstate wereturnthenewgeneratedinput x primeto the concolic execution engine for its path exploration section .
.
otherwise thesynthesisengineaddsanewinput outputpair rioto the setrand continue generating new expressions until we reach the target state or the synthesis iteration exceeds the threshold l. thoughthisalgorithmrequiresiterativerefinement theprogram will not be concolically executed multiple times.
to gather more input output pairs multiple concrete executions are needed while the symbolic execution is performed once.
therefore compared with traditional concolic execution this algorithm will not induce too much overhead.
.
.
core program synthesis.
differentfromtraditionalsynthesis approacheswhichaimtosimulate behaviorsofalibrary oursynthesisengineisdesignedtosynthesizeanexpressionthatcanguide path exploration of symbolic execution.
we use the recent work of togenerateexpressionsbyincrementallyfeedinginput output pairs.
as mentionedin algorithm we provideour synthesizerwith oneinput outputpairinitially theniterativelyfeedmorepairsonlyifthesynthesizedexpressiondoesnothelpingeneratingnewinputs to explore the target state.
when the generated input x primeby solving pc e fails to make real execution follow the target path the synthesized expression emust be incorrect.
in this situation refinement process will be triggered to refine expression e. this strategydoesnotneedpre generatedinput outputpairs instead it will generate new pairs according to the feedback of concrete execution.
therefore this strategy needs less input output pairs to synthesize an expression to cover more program behaviors.
moreover weprovidedifferentcomponentstothesynthesizer based on an incremental strategy.
to reduce the complexity ofsynthesis we first categorize common components according to theircomplexity .table1showsthecategorizedcomponents.
the first level is constant which means that our synthesizer willfirstuseaconstantvaluetorepresentthelibrary.ifthislevelfailsto generate expressions that satisfies the input output relations then it will try higher levels with more input output pairs.
this process willterminatewhenacertainiterationlimitisreachedorwhenit generatesnewinputsthatexplorethetargetpath algorithmwill reach the iteration limit if the target path is infeasible .
.
.
context specific.
our synthesisprocess is context specific whichmeansthatwewilltreatthesamemethodinvokedindifferent programpointsasdifferent.synthesizingalibrarymethodunder acertaincontextwillsimplifythesynthesisprocess becausethe library method may only show part of its behaviors under this context e.g.someexecutionpathsareconstrainedbyglobalstates .
underacertaincontext moreprecisemodelscanbesynthesized.
context specificsynthesisisusedbecausethegoalofoursynthesis is not simulating complete library behaviors instead synthesizing a model to help symbolic execution reach more branches.
weconsiderthe contextofanandroidapptobetheglobalstates of the app.
in the refinement process we have to make sure the functionto be synthesizedisinvokedunderthesamecontext so thattheinput outputpairsaregeneratedbasedonsamecontext.we will illustrate this process using the example in figure .
consider alibrarycall f x y invokedwith xandyasargument.let x1and x2betwoconcretevaluesof x sameoperationforvariable y .in figure2 isthepathconstraintbeforetheinvocationof f x y and x1andx2isobtainedbysolving x y e.sincex1and x2satisfythepathconstraint theprogramwillreachthemethod invocation ffollowing the same path when it is given either x1 orx2as input.
hence either the library invocation is reached with thesame global state orthe differenceinglobalstatesat thetime ofthelibrary invocation f x isaccountedfor bythedifferencein thevalueof x.thoughoursynthesizedexpressionsdonotmodel the effect of global states they adequately capture this situation by synthesizing expressions on the argument x. .
gui constraints for android apps developers often specify certain constraints on inputsbydefiningconstraintsforuielements.theseconstraints are validated by android libraries at runtime.
for instance in apptagactivity the touch coordinates x y are extracted at runtime.
based on our experimental devices the bound of screen is .
this means that xis limited to while yis limitedto .wecallthistypeofconstraint guiconstraint.
gui constraint collection can be added after line in algorithm andthenincorporatedtopathcondition pc.addingguiconstraints to the path condition can help the concolic execution engine togenerate valid inputs i.e.
inputs that are accepted by the app .generating valid inputs is important in ensuring that the errors foundbyourconcolicexecutionenginecorrespondtorealerrors that could be replicated in android devices.
ourconcolicexecutionincorporatesguiconstraintsintwosteps.
first we collect the gui constraints from the android execution at runtime.secondly weprovideasetoftemplatestotranslategui constraints to constraints that are supported by the smt solver.
defining a template is required since gui constraints are typically defined in high level semantics and cannot be directly used by smtsolvers.currently wesupportsevencommonguiconstraints authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
android testing via synthetic symbolic execution ase september montpellier france table the templates for translating gui constraints wheremandnrepresent attribute values.
source gui constraints translation layoutandroid maxlength n android digit true i i 10n android alpha m m m .
android progress m android max n m m n android maximumangle m m m ui hierarchycombobox numitems n i i n list numitems n i i n bound x m y n figure architecture of our implementation synthesise.
shown in table .
this list of supported gui constraints can be easily extended.
.
handling library functions with side effects as capturing the effect of an android library invocation via its returnvaluemaynotbesufficientforlibraryfunctionswithsideeffects we handle the potential imprecision caused by methods with sideeffectsbymitigatingthisissueforcertainandroidlibraryfunctions.
specifically we analyze android libraries that are accessor methods getters if it has a corresponding mutator methods setters that are invoked before the execution of the mutator method withinthesameclass.foreachmutatormethod e.g.
setx val thatchangesthevalueofafield westorethevalueinamapand we use this value for representing the subsequent accessor method e.g.
val getx .similarstrategycanalsobeusedforlibraryfunctions related to inter process communication intent and database access.
implementation toperformconcolicexecutionofandroidapp wereusetheconcolicexecutionenginedesignedforjavaprograms.duringconcolic execution whenencounteringacalltoandroidapi fromandroid framework it communicates with android device emulator to obtain the runtime value for the result of the api call.
if the android libraryinvocationsatisfiesthecriteriadefinedinsection .
itwill trigger a synthesis process.
figure3showsthearchitectureofourimplementationsynthesise implementedinjava whichcomprisesofthreelayers concolic executor jvm android communicator and java and android execution environments.concolic executor .
we implement our synthesis engine based on the recent work of which embodies program synthesis via second order constraint solving this is partly because hasbeensuccessfullyusedforlibrarymodeling.wechoosejdart github commit id 6584bd0 as the concolic engine of synthesise.
jdart which has been used to test industry programs is developed as an extension to java pathfinder jpf .
the concolic engine can be easily replaced by other engines since our approach does not require modifications of the concolic execution engine insynthesise weusemicrosoftz3 asthesmtsolversinceit supports constraints containing complex arithmetic operations.
jvm android communicator .
the android related statements will be delegated to the android devices emulators so that the java concolic engine does not need to execute them.
we implement android execution delegator on top of the model java interface mji2 component supported by jpf and jdart which allows delegating theexecutionofthespecifiedmethodstothehost vmfromtheconcolic engine.furthermore we leverage theandroid debug bridge adb to communicate with a device emulator from one desktop.
execution environments .
our concolic execution runs in the java environment.
the concrete execution of android apps can runonrealdevices emulatorssothatourconcolicexecutioncan analyze android apps in a real android environment.
evaluation weperformevaluationontheeffectivenessofsynthesiseinsynthesizing android library methods and its ability to enhance code coverageofsymbolicexecution.ourevaluationaimstoaddressthe following research questions rq1if we treat all the branches affected by an android library invocation as targets howmany targets can we reach with our synthesized model?
rq2what is the quality of the synthesized library code?
how many iterations are needed for our synthesis engine?
.
subject selection to compare our synthesized library models with other existing models weevaluateourgeneratedmodelsagainstthemodelsin jpf android .wechoosetoevaluateagainstthemodelsinjpfandroid3because it contains a large number of models a set of modelsdevelopedoveracourseofseveralyears and allofthese modelsarepubliclyavailable.someofthemodelsinjpf android are manually crafted whereas others are automatically generated usingocsegen theseautomaticallygeneratedmodelmethods will return default values .
thedetails of our selection process are described below asitisdifficulttodistinguishbetweenmanuallycraftedmodels and automatically generated models we first obtain the set of android library methods that have been modeled by jpfandroid.amongthesupportedlibrarymodels weonlyconsider the library methods with at least one input of primitive type and output of primitive type.
we randomly select methods for our evaluation because we need to manually assess the quality of each synthesized library methods.
foreachofthese methods wesearchthroughgithub forandroid apps that invoke these methods.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france xiang gao shin hwei tan zhen dong and abhik roychoudhury table statistics for the selected android library calls method class description app loc calculatesignallevel wifimanager calculates the level of the signal.
wifiscanner checksignatures packagemanager compare the signatures of two packages catlogdonate .5k comparesignallevel wifimanager compare signal level goproclose .4k getattributeresvalue attributesetimpl return the value of attribute as a resource identifier.
musicxiami .4k getcolor contextcompat retrieve the color value for the attribute at index myleafpic 16k getdefaultsize view utility to return a default size constrained by input audiovideorecord 12k getdimensionpixeloff typedarray retrieve a dimensional offset in raw pixels marketing getindex typedarray returns an index in the array that has data.
robolectricissue getintextra intent retrieve extended data from the intent.
twowayactivity getlayoutdimension typedarray retrieving viewgroup s layout width and layout height attributes precentadaptation getoffsetforposition textview get the character offset closest to the specified absolute position.
tagactivity .5k nextspantransition spannablestringbuilderreturn the first span offset that is greater than the first parameter or parameter itself.sechandtreak .6k resolvesize view reconcile a desired size and state and return only masked bits surrounding scanner resolvesizeandstate view reconcile a desired size and state constrained by input paper scissors fromthegithubsearchresults weselectthefirstappwhere at least one of its branches are affected by the output of the corresponding library methods.
we exclude six methods where the outputs of these methods do not affect any branch decision in the evaluated android apps.
overall we select android apps using the process mentioned above.table 3showstheselectedsubjectsaswellastheirstatistics where the classcolumn represents the class in which the corresponding method is defined.
meanwhile the description column givesabriefdescriptionofeachmethodaccordingtothegoogle api document.
the last two columns show the open source android apps that usethe corresponding method and the line of code loc of these apps.
.
experimental setup we conduct two experiments to answer our research questions.
to answerrq1 we regard all the branches affected by the invocation of the given library method as targets.
we manually generate an event sequence that can reach the method in app code where the correspondinglibrarymethodisinvoked.basedonthegenerated event sequence concolic execution will generate data inputs environment inputs etc to reach the targets.
we evaluate how many targetscan be reached with three variants of concolic execution concrete concolic execution with concretely executing android library method without synthesis .
synthesise concolic execution with concretely executing android library method and on demand synthesis.
ja model concolic execution with jpf android models.
the comparison of the first two approaches aims to investigate whether our synthesis could help concolic execution explore more affected branches.
meanwhile the comparison with existing model evaluatesexistingmanual automatedmodelingstrategy.wechoose to use the jpf android models instead of the tool itself because jpf androidrequiresuserstomanuallywritetheinputsequence andapplication specificmodelswhichwouldrequirealmostone dayforeachsubjectapp and weneedtoensurethattheconcolicexecutionengineusedinallvariantsisthesametofacilitateafair comparison between the synthesized library methods and the jpf android models.
our synthesis terminates when we find new inputs that can coverthetargetbranchorwhenthenumberofiterationsexceedsa certainlimit weuse synthesisiteration 20forourexperiment .
to answer rq2 we evaluate synthesise by manually analyzing the synthesized expressions obtained from rq1.
our analysis evaluatesthecorrectnessofoursynthesizedexpressionscomparedto the real library and jpf android models.
weconductalltheexperimentsonarealandroiddevice lgg6 androidosv7.
api24 .fortheconcolicexecutionengine weconfigureittousez3forconstraintsolving symbolic.dp z3 andreuse otherdefaultconfigurations symbolic.dp.z3.bitvectors true .
we run our concolic execution engine on a desktop ubuntu .
intel core i7 .40ghz processor 8gb memory .
.
results target reachability.
as our synthesized models will only induce differencesincodecoverageforbranchesthataredependentonthe resultsofandroidlibraryinvocations weregardthosebranches astarget.
table 5shows the number of reached targetsfor each subjectbyeachvariant.the targetscolumnrepresentsthetotal number of targets whereas the synthesise ja model andconcrete columns indicate the number of reached targetsusing synthesis jpf androidmodelandconcretevalues respectively.ifwecompare thereached targetsbysynthesiseandconcolicexecutionusingjpfandroidmodel synthesiseoutperformsthejpf androidmodelsin itsabilitytoreachmore targetsformostofthesubjects.specifically synthesise reach more targetsin nine subjects.
for the subjects markedwith na synthesisecouldnotsynthesizeexpressionsto reach more targetsas it reaches its limit during the synthesis iterations.
specifically synthesise reach one more targetthan the jpf android model for the checksignatures method because the jpf android model throws an exception.
for the getintextra and comparesignallevel methods both synthesis and jpf android providecorrectmodels.comparedtoconcolicexecutionwithconcrete values synthesisereachmore targetsexceptfor twosubjects authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
android testing via synthetic symbolic execution ase september montpellier france table synthesized results method synthesis time s synthesis type synthesized correctness ja model calculatesignallevel arithmetic .
x1 c2 constant checksignatures reach limit no no exception comparesignallevel arithmetic x1 x2 c1 x1 x2 getattributeresvalue reach limit no no constant getcolor array access array x1 y c2 x2 getdefaultsize bitwise x2 0xbfffffff c2 c3 top int getdimensionpixeloff array access array x1 y c2 x2 getindex array access array x1 y c2 canstant getintextra set get put get c1 map getlayoutdimension array access array x1 y c2 x2 getoffsetforposition arithmetic x1 .
c2 top int nextspantransition arithmetic x2 c3 constant resolvesize bitwise x2 0xbfffffff c2 c3 top int resolvesizeandstate bitwise ite x2 ?
x2 0xbfffffff c2 c3 top int table5 affectedbranchesreachedwithsynthesizedmodels jpf android models and concrete values method targets reached targets synthesise ja model concrete calculatesignallevel checksignatures na exception comparesignallevel getattributeresvalue na getcolor getdefaultsize getdimensionpixeloff getindex getintextra getlayoutdimension getoffsetforposition nextspantransition resolvesize resolvesizeandstate thatsynthesisefailtosynthesizeexpressions onesubject getdimensionpixeloff where some targetsare unreachable in the single test input used for concolic execution.
synthesise is able to reach more targetsthat are affected by library output.
synthesis result.
table4shows the synthesis results where synthesis is the number of synthesis iterations and synthesis type indicate the type of synthesized expression.
the timecolumn represents the time taken to infer each of the stubs which is correlated with the number of synthesis iterations.
on average it takes 103s to synthesize the final expression.
the synthesized column shows the simplified expression where x1 x2 represent the first and second parameter respectively and y represents the output.
the supported synthesis type component includes constant arithmetic bitwise ite if then else and array access .
we also include set get explained in section .
as a synthesis type.
among the subjects four of the synthesized expressions are arithmetic threeofthemarebitwise operation fourexpressions are synthesized by array access one expression synthesized usingite and one is handled by set get.
table 4shows that the number of synthesis iterations for the arithmetic bitwise expression isless than the array access expression because we give higher priority to arithmetic bitwise component .
meanwhile library methods that require access to android resources are usually synthesized using array access.
for example the method getcolor which extracts color values based on resource id is synthesized using array access.
synthesisegeneratesexpressionsfor12outof14evaluated method libraries within the iteration limit.
correctness wemanuallycompareeachsynthesizedexpression withcorrespondingmethodinandroidframeworkandjpf android model.
if the semantic of the synthesized expression is different fromthereallibrary wefurtherinvestigatethecontext specificandconditionalcorrectness.givenasynthesizedexpression libsyn and itscorrespondingimplementationinandroidframework libreal we measure the correctness of libsynusing three criteria c1 correct libsyniscorrectifandonlyif libsynandlibreal always produce the same semantic behavior.
c2 conditionally correct libsynisconditionallycorrectif libsynandlibrealshow the same behavior for a range of inputs.
c3 context specific correct libsynis context specific correct iflibsynandlibrealshow the same behavior under certain context e.g.
global variables .
inthecorrectness column wemarktwocaseswith because our synthesis engine reaches its iteration limit for these cases.
specifically the correct expression of checksignatures andgetattributeresvalue should involveobject comparison which oursynthesis does not support.
these two cases do not synthesize code which can be classified as c1 c2 or c3.
thecorrectness column denotes the correctness category for eachsynthesizedexpression.overall oursynthesisenginegenerates correct expressions for two library methods.
meanwhile nine ofthesynthesizedexpressionsareconsideredconditionally correct expressions.
among these conditionally correct expressions three expressions are context specific at the same time.
our synthesis enginemaygenerateconditionally correctexpressionbecause the synthesis process terminates once new inputs exploring target authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france xiang gao shin hwei tan zhen dong and abhik roychoudhury patharegenerated and theinput outputpairmaynotbeableto cover all behaviors.
if more input output pairs are given then our synthesis engine will be able to generate more correct expressions.
for example the synthesized expression for calculatesignallevel is .
x1 .thissynthesizedexpressioniscorrectforallinputs except for cases where the real library will return if x1 is less than a constant variable min rssi.
given more input output pairs e.g.
min rssi synthesise will be able to generate a more precise expression.
meanwhile we synthesize four context specific correct expressions.
these expressions simulate the simplified behaviors of the library only under certain context global states .
alloftheexpressionssynthesizedwithintheiterationlimit are correct conditionally correct or context specific correct.
.
threat to validity internal validity there are several internal threats in the experimental methodology that may affect our results.
while there are several symbolic execution engines that rely on library models we only compare our synthesized models against the jpf android modelsbecausetheyarepubliclyavailableandarecraftedspecificallyforandroidlibraries.oursynthesisengineterminatesafter refinement iterations we did not investigate the effect of different iteration limits on the synthesis results.
nevertheless for most subjectsinourevaluation asmallnumberofsynthesisiterations is sufficient to synthesize the desired expression.
moreover we manually evaluate the correctness of the synthesized expression.
astheimplementationofandroidframeworkisopen source the analysis is relatively straightforward.
external validity ourstudyis limitedtotheevaluatedandroid appsandourresultsmaynotgeneralizebeyondtheevaluatedapps.
related work symbolic concolicexecution .thereexistsseveralsymbolic concolicexecutionframeworks.s2e embodiesthein vivoapproach toperformexplorationofprogramsinsidecomplexsystems.similar toourwork s2edoesnotrequiremodelingoflibrariesbutitdiffers from synthesise in two aspects.
first s2e performs symbolic execution while synthesise conducts concolic execution.
after symbolic variables are concretized for concrete execution s2e stops exploring paths constrained by these variables and uses a backtracking mechanism to alleviatethis issue.
synthesise solves this issue by maintaining both symbolic values and concrete values.
second synthesise leverages program synthesis for deducing the relations between inputs and outputs whereas s2e may obtain incomplete constraints when symbolic information flows into libraries.
klee embodies the in vitro approach which relies on manually written posix libraries.
symbolic pathfinder spf is an extension of jpf which uses java library models.
different from these approaches synthesise do not model libraries instead we synthesize expressions to capture the effect of libraries.
program synthesis for symbolic execution .
we use program synthesis whichembodiesprogramsynthesisviasecond order constraint solving to synthesize a representation for android library.toincreasethescalabilityofprogramsynthesis oursynthesis engineadaptsthecategorizationofcommoncomponentsinpriorwork that synthesizes program expression to patch software errors .
although the models synthesized by pasket a r e alsousedinasymbolicexecutionengine itssynthesisalgorithm is driven by several commonly used design patterns.
meanwhile synthesise synthesizes libraries to drive the program execution to unexploredprogrambranchesandtorelieftheprogramdivergence problem.
qi et al.
synthesize library models by sampling behaviorsoftheoriginalimplementationofafunction.synthesise synthesizeslibrarymodelusinginput outputspecificationsandthe feedback about branch reachability.
android testing via symbolic concolic execution .extensions of symbolic pathfinder e.g.
jpf android pathdroid and mirzaei s work conduct symbolic execution on android apps in jvm by modeling android libraries which require significant manual effort to adapt to the rapidevolution of android versions while synthesise is designed to solve this problem.
symdroid isasymbolicexecutorfordalvikbytecode whilejpf mobile attempts to run jpf on android systems.
both approaches have been evaluated only on small demo apps.
applying symbolic concolic execution to gui testing has beenexplored in several works acteve collider appintent condroid and sigdroid .thosetoolsuseseitherinstrumentationorsimplified models.
instrumentation based approaches including acteve etc maysufferfrompathdivergenceproblemasmissedinstrumentations could lead to the divergence between the concrete and symbolicexecutionpaths.therefinementprocessinsynthesise is able to address this problem.
approaches based on library stubs including condroid and sigdroid does not consider android framework in symbolic execution may miss many path constraints.inconstrast synthesiseleverageson demandsynthesisto deduce a model to simulate android libraries.
meanwhile crashes foundby ourapproach couldbeused asinputsfor existingrepair approaches for automatically fixing these crashes .
conclusion wepresent syntheticsymbolicexecution anditsrealizationviaaconcolic execution engine that leverages a novel on demand program synthesisfortestingandroidapps.programsynthesisisiteratively invoked to generate library code which can help achieve greaterbranch coverage in testing of android apps.
we believe our approach shows promise in terms of solving the rather hard problem of environment behavior capture in symbolic execution since libraries are a form of environment.
our work shows the promise of symbolic executiontechniques whichneither manuallymodel the environment nordependonwholesystemexecutionstocapture the environment via under approximations.
acknowledgement thisresearchispartiallysupportedbythenationalresearchfoundation prime minister s office singapore under its corporate laboratory at university scheme national university of singapore and singapore telecommunications ltd.