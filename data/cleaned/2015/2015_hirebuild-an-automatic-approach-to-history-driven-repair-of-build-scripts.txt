hirebuild an automatic approach to history driven repair of build scripts foyzul hassan the university of texas at san antonio foyzul.hassan my.utsa.eduxiaoyin wang the university of texas at san antonio xiaoyin.wang utsa.edu abstract advancements in software build tools such as maven reduce build management effort but developers still need specialized knowledge and long time to maintain build scripts and resolve build failures.
more recent build tools such as gradle give developers greater extent of customization flexibility but can be even more difficult to maintain.
according to the travistorrent dataset of open source software continuous integration of code commits include changes in build script files to maintain build scripts or to resolve build failu res.
automated program repair techniques have great potential to reduce cost of resolving software failures but the existing techniques mostly focus on repairing source code so that they cannot directlyhelp resolving software build failures.
to address this limitation we propose hirebuild history driven repair of build scripts the first approach to automatic patch generation for build scripts using fix patterns automatically generated from existing build script fixes and recommending fix patterns based on build log similarity.
from travistorrent dataset we extracted build failures and their corresponding fixes which revise gradle build scripts.
among these build failures we used the earlier build fixes for automatic fix pattern generation and the more recent build failures fixes for evaluation of our approach.
our experiment shows that our ap proach can fix of reproducible build failures or of the reproducible build failures within comparable time of manual fixes.
ccs concepts software and its engineering automatic programming maintaining software keywords patch generation software build scripts build logs acm reference format foyzul hassan and xiaoyin wang.
.
hirebuild an automatic approach to history driven repair of build scripts.
in icse icse 40th international conference on software engineering may june gothenburg sweden.
acm new y ork ny usa pages.
.
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn .
.
.
.
introduction most well maintained software projects use build tools such as ant maven and gradle to automate the software building and testing process.
using these tools developers can describe the build process of their projects with build scripts such as build.xml for ant pom.xml for maven and build.gradle for gradle.
with growing software size and functionality build scripts can be complicated and may need frequent maintenance .
as software evolves developers make changes to their code test cases system configuration and dependencies which may all lead to necessary changes in the build script.
adams et al.
found strong co evolutionary relationship between source code and build script in their study.
since build scripts need to be synchronized with source code and the whole build environment neglecting such changes in build scripts often leads to build failures.
according to our statistics on travistorrent dataset on the continuous integration of open source software projects ofcode commits fail to go through a successful build on the integra tion server.
seo et al.
also mentioned a similar build failure proportion at google which is .
these build failures hinders a project s development process so that they need to be fixed as soon as possible.
however many developers do not have the requiredexpertise to repair build scripts .
therefore automatic repair of build scripts can be desirable for software project managers and developers.
automatic generation of software patches is an emerging technique and has been addressed by multiple previous research efforts.
for example genprog and par achieve promising result for automatic bug fixing.
but these works are designed for repai ring source code written in different programming languages.
in contrast repairing build scripts has its unique challenges.
first although the code similarity assumption both genprog and par are taking advantage of this assumption to fetch patch candidates from other portion of the project or other projects still holds for build scripts build script repair often involves open knowledge that do not exist in the current project such as a newly available version of a dependency or a build tool plug in see example .
second unlike source code bugs build failures does not have a test suite to facilitatefault localization and to serve as the fitness function .
third while different programming languages share similar semantics so that code patterns templates can be adapted and reused the semantics of build scripts are very different from normal programs so we need to re develop abstract fix templates for build scripts.
on the other hand there are also special opportunities we can take advantage of in the repair of build scripts.
first build failures often provide richer log information than normal test failures and the build failure log can often be used to determine the reason and location of a build failure.
second build scripts are programs in a acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden foyzul hassan and xiaoyin wang example gradle v ersion dependency change puniverse quasar 2a45c6f task wrapper type wrapper gradleversion .
gradleversion .
specific domain so it is possible to develop more specific build fix templates e.g.
involving more domain specific concepts such as versions dependencies instead of general concepts like parameters variables .
third many build failures are related to the build tools and environments.
these failures are not project specific and may be recursive in different projects so fix patterns can often be used beyond a project s boundary.
in this paper we propose a novel approach hirebuild to generate patches for build scripts.
our insight is that since many software projects use the same build tool e.g.
gradle similar build failures will result in similar build logs.
therefore given a build failure it is possible to use its build failure log to locate similar build failures from a historical build fix dataset and adapt historical fixes for these new failures.
specifically our technique consists of the following three phases.
first for a given build failure based on build log similarity we acquire a number of historically fixed build failures that have the most similar build logs.
we refer to these build fixes as seed fixes.
second from build script diffs of the seed fixes we extract a number of fix patterns based on our predefined fix pattern templates for build scripts and rank the patterns by their commonality among seed fixes.
to generate build script diffs our approach uses an existing tool gumtree which extracts changes of java source code xml javascript code change.
third we combine the patterns with information extracted from the build scripts and logs of the build failure to generate a ranked list of patches which are applied to the build script until the build is successful.
although following the general generation validation process for program repair our technique is featured with following major differences to address the challenges and take advantage of the opportunities in build script repair.
build log analysis.
build logs contain a lot of information about the location and reason of build failures and sometimes even provide solutions.
our build log analysis parses build logs and extracts information relevant to build failures.
furthermore hirebuild measures the similarity of build logs based on extracted information.
build fix pattern templates.
there are a number of common domain specific operations in build scripts such as including excluding a dependency updating version numbers etc.
in hirebuild we developed build fix pattern templates to involve these common operations specific to software build process.
build validation.
in build script repair without test cases we need a new measurement to validate generated patches.
specifically we use the successful notification in the build log and the numbers of compiled source files to measure build successfulness.
in our work we focus on repair of build scripts so we do not consider compilation errors or unit testing failures although theyalso cause build failures as they can be easily identified based on build logs and may be automatically repaired with existing bug repair techniques.
furthermore we use gradle based on groovy as our targeted build tool as it is the most promising java build tools now and recent statistics show that more than of top github apps have already switched to gradle.
in our evaluation we extracted reproducible build fixes with corresponding build logs and build script changes from travistorrentdataset on february the build fixes are from different projects .
to evaluate hirebuild we use the earlier build fixes as our training set and later actual build failures chronologically earlier and later bug fixes among the regardless of which project they belong to as our evaluations set.
among these build failures we reproduced build failures in our test environment.
empirical evaluation results show that our approach is able to generate a fix for of the reproduced build script failures which gives same build output as developers original fix.
overall our work presented in the paper makes the following contributions.
a novel approach and tool to automatic patch generation for build scripts to resolve software build failures.
a dataset of build fixes which can serve as the basis and a benchmark for future research.
an empirical evaluation of our approach on real world build fixes.
an abstract syntax tree ast diff generation tool for gradle build scripts which potentially have more applications.
the remaining part of this paper is organized as follows.
after presenting a motivation example of how build script repair is different from source code repair in section we describe the design details of hirebuild in section .
section presents the evaluation of our approach while section presents discussion of important issues.
related works and conclusion will be discussed in section and section respectively.
motiv ating example in this section we introduce a real example from our dataset to illustrate how patch generation of build scripts is different frompatch generation of source code.
example shows a build failureand its corresponding patch where the upper part shows the mostrelevant snippet in the build failure log and the lower part shows the code change to resolve the build failure.
the project name and commit id are presented after the example title.
in this build failure the build failure log complains that there are two conflicting versions of slf4j module and the bug fix is to add an exclusion of the module in the compilation of galaxy component.
although this build fix is just a one line simple fix it illustrates differences between source code repair and build script repair in the following aspects.
first it is possible to find from existing scripts or past fixes that we need to perform an exclude operation however since org.slf4j never appears in the script it is transitively referred and will be downloaded from gradle central dependency repository at runtime the string org.slf4j can be hard to generate and enumerating all possible strings is not a feasible solution.
the string can actually be generated by comparing the build failure log and available modules in gradle central dependency repository but this is very different authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hirebuild an automatic approach to history driven repair of build scriptsicse may june gothenburg sweden example a gradle build failure and patch puniverse quasar build failure v ersion 017fa18 build fix v ersion 509cd40 could not resolve all dependencies for configuration quasar galaxy compile .
a conflict was found between the following modules org.slf4j slf4j api .
.
org.slf4j slf4j api .
.
compile co.paralleluniverse galaxy .
...exclude group com.google.guava module guava exclude group org.slf4j module from source code patching where all variable names to be referred to are already defined in the code in the case when a generated fix contains a newly declared variable the variable can have any name as long as it does not conflict with existing names in the scope .
second in build script repair we are able to and need to consider build specific operations.
for example we should not simply deem exclude as an arbitrary method name but needs to involve its semantics into fix pattern templates so that we know a module name will follow the exclude command.
third the build log information is very important in that it not only provides the name of conflicting dependency but also provides the compilation task performed when build failure happens which can largely help patch generation tool to locate the build failure and determine where to apply the patch.
approach the overall goal of hirebuild is to generate build script patches that can be used to resolve build failures.
hirebuild achieves these goals with three steps log similarity calculation to find similar historical build fixes as seed fixes extraction of build fix patternsfrom seed fixes and generation and validation of concrete patches for build scripts.
in the following subsections we first introduce preliminary knowledge on gradle and then describe the three steps of hirebuild with more details in the following subsections.
.
gradle build tool gradle is a general purpose build management system based on groovy and kotlin .
gradle supports the automatic download and configuration of dependencies or other libraries.
it supports maven and ivy repositories for retrieving these dependencies.
this allows reusing the artifacts of existing build systems.
a gradle build may consist of one or more build projects.
a build project corresponds to the building of the whole software project or a submodule.
each build project consists of a number of tasks.
a task represents a piece of work during the building process of the build project e.g.
compile the source code or generate the javadoc.
a project using gradle describes its build process in the build.gradle file.
this file is typically located in the root folder of the project.
in this file a developer can use a combination ofdeclarative and imperative statements in groovy or kotlin code.
this build file defines a project and its tasks and tasks can also be created and extended dynamically at runtime.
gradle is a general purpose build system hence this build file can perform any task.
.
log similarity calculation to find similar fixes one of the most important characteristic of build script repair is that a lot of software projects use the same build tools e.g.
gradle so that build failure logs of different projects and versions often share the same format and output similar error messages for similar build errors.
so given a new build failure hirebuild measures thesimilarity between its build failure log and the build failure logsof historical build failures to find its most similar build failures in history dataset.
.
.
build log parsing.
gradle build logs typically contain thousands of lines of text.
gradle prints these lines when performingdifferent tasks such as downloading dependencies compiling source files and when facing errors during the build.
our point of interest is the error and exception part which typically accounts for onlya small portion of the build log.
so if we use the whole build log to calculate similarity the remaining part will bring a lot of noises to the calculation e.g.
build logs from projects that have similar dependencies may be considered similar .
therefore we use only the error and exception part of the build log to calculate similarity between build logs.
an example of the error and exception part in gradle build log is presented as below.
what went wrong a problem occurred evaluating project androidrest .
gradle version .
is required.
current version is .
.
if using the gradle wrapper try editing the distributionurl in home travis build deg appsly android rest gradle wrapper gradlewrapper.properties to gradle .
all.zip to extract the error and exception part hirebuild extracts the portion of the build log after the error indicating header in gradle e.g.
what went wrong .
hirebuild extracts only the last error as the earlier ones are likely to be errors that are tolerated and are thus not likely to be the reason for the build failure.
furthermore when there are exception stack traces in the error and exception part hirebuild removes the stack traces for two reasons.
first stack traces are often very long so they may dominate the main error message and bring noise as mentioned above .
second stack traces are often different from project to project so they cannot catch the commonality between build failures.
.
.
t ext processing.
after we extracted the error and exception part from the build failure log we perform the following processing to convert the log text to standard word vector.
text normalization breaks plain text into separate tokens and splits camel case words to multiple words.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden foyzul hassan and xiaoyin wang stop word removal removes common stop words punctuation marks etc.
for better similarity hirebuild also removes common words for building process including build failure and error .
stemming is the process of reducing inflected words to their root word.
as an example the word goes derived from word go .
the stemming process converts goes to its root word go .
for stemming we applied popular porter stemming algorithm .
.
.
similarity calculation.
with the generated word vector from the error and exception part of the build failure logs weuse the standard term frequency inverse document frequency tf idf formula to weight all the words.
finally we calculate cosine similarity between the log of build failure to be resolved and all build failure logs of historical build fixes in our training set and fetch the most similar historical fixes.
hirebuild uses the five most similar historical fixes as seed fixes to generate build fix patterns.
.
generation of build fix patterns to generate build fix patterns for each seed fix hirebuild first calculates the code difference between the versions before and afterthe fix.
the code difference consists of a list of elementary revi sions including insertions deletions and updates.
then for each revision hirebuild generalizes it to hierarchical pattern and merges similar patterns.
finally hirebuild flattens the hierarchical pattern to generate a set of build fix patterns and ranks these patterns.
.
.
build script differencing.
in this phase for each seed fix we extract gradle build script commits before and after fix and convert the script code to ast representation.
gradle build uses groovy based scripting language extended with domain specific features to describe software build process.
with support of the groovy parser ast representation of script code can be generated.
our goal is to generate an abstract representation of code changes between two commits.
having build script content represented as an ast we can apply tree difference algorithms such as changedistiller or gumtree to extract ast changes with sufficient abstraction.
in particular hirebuild uses gumtree to extract changes between two gradle build scripts.
gumtree generates a diffbetween two asts with list of actions which can be insertion de letion update and movement of individual ast nodes to transfer from a source version to a destination version.
however gumtree generates a list of ast revisions without node type information so we revise gumtree to include the information.
furthermore hirebuild also records the ancestor ast nodes of the changed ast subtree.
such ancestor ast nodes are typically the enclosing expression statement block and task of the change and they are helpful for merging different seed fixes for more general patterns and for determining where the generated patches should be applied.
as mentioned earlier in gradle scripts a task is a piece of work which a build performs and a script block is a method call with parameters as closure so keeping such information helps to apply patches to a certain block or task.
example shows an exemplar output of hirebuild s build script differencing module in which the operation node type and ancestor nodes are extracted.
note that hirebuild extracts only one level of parent expression to avoid potential noises.as shown in the example the task block name can be empty if the fix is not in any tasks blocks.
example build script differencing output buildcraft buildcraft 98f7196 ?xml version .
encoding utf standalone no ?
patch lineno id exp id operation update operation nodetype constantexpression nodetype nodeexp .
.
.
.
.
nodeexp nodeparenttype binaryexpression nodeparenttype nodeparentexp version .
.
.
.
.
nodeparentexp nodeblockname minecraft nodeblockname nodetaskname nodetaskname exp lineno patch .
.
hierarchical build fix patterns.
in some rare cases we can directly use the concrete build fix pattern to generate a correct patch.
example provides such a patch from project nohana laevatein a2aaca4 .
there exists an exactly same build fix in the training set from a different project .
example training project fix journeyapps zxing android embedded 12cfa60 lintoptions abortonerror false however in more common scenarios code diffs generated from seed fixes are too specific and cannot be directly applied as patches.
consider examples and changes made in different project are similar but if we consider concrete change of example as update .
.
.
.
.
then this change can hardly be applied to other scripts.
therefore we need to infer more general build fix patterns from them.
example gradle build fix buildcraft buildcraft 98f7196 version .
.
.
.
.
version .
.
.
.
.
example gradle build fix f orgeessentials f orgeessentialsmain fcbb468 version .
.
beta7 version .
.
beta8 specifically hirebuild infers a hierarchy of build fix patterns from each seed fix by generalizing each element in the differencing output of the seed fix.
for example the hierarchies generalized from examples and are shown in figure .
from the figure we can see that hirebuild does not generalize operations and the node type of expression that are involved in the fix i.e.
constantexpression because a change on those typically indicates a totally different fix.
hirebuild also does not include the task and block information in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hirebuild an automatic approach to history driven repair of build scriptsicse may june gothenburg sweden figure hierarchies of build fix patterns figure merged hierarchies the pattern as they are typically not a part of the fix.
given a hierarchy by choosing whether and which leaf node to be generalized we can generate patches at different abstract levels.
for example if we generalize the parent expression from version .
.
... toparentexp any we generate a pattern that updates a value .
.
... without considering its parent.
if we generalize both the parent expression and the node expression we generate a pattern that update any constants in the script.
note that hirebuild does not consider the cases where the node expression is generalized but the parent expression is not as such a pattern can never match real code.
.
.
merging build fix patterns.
after generating hierarchies of build fix patterns hirebuild first tries to merge similar hierarchies.
for example the two hierarchies in figure will be merged to a hierarchy shown in figure .
hirebuild merges only a pair of hierarchies with the same operation and node type update and constant expression in this case .
during the merging process hirebuild merges hierarchies recursively from their root node and merges nodes with exactly the same value.
if two nodes to be merged have different constant values hirebuild does not merge them and their children nodes.
if two nodes to be merged have different expression values hirebuild extracts their corresponding ast tree and merges the ast tree so that the common part of the expressions can be extracted.
in figure since the expressions version .
.
... andversion .
.
... share the same child nodes version and a node version is added.
note that more than two hierarchies can be merged in the same way if they share the same operation and node type.
.
.
ranking of build fix patterns.
after hierarchies are merged hirebuild calculates frequencies of build fix patterns amongseed fixes.
if a hierarchy cannot be merged with other hierarchies all the build fix patterns in it have a frequency among seed fixes as they are specific to the seed fix they are from.
in a merged hierarchy the frequency of all its patterns is always the number of originalhierarchies being merged.
after calculating the frequencies of all build fix patterns from hierarchies hirebuild ranks build fix patterns according to the frequency.
for each build fix pattern we counted nt s frequency among seed fixes.
then probability of is as follows.p nt n where n is the total occurrences of build fix patterns.
then we rank the fix patterns based on the probability so that we use higher ranked build fix patterns first to generate concrete patches.
when there are ties between pattern aandb i fais a generalization ofb ais generated by generalizing one or more leaf nodes of b we rank bovera.
the reason is that when a build fix pattern is generalized it can lead to a larger number of concrete patches e.g.
update gradleversion from any existing version to another existing version so hirebuild needs to perform more build trials to exhaust all possibilities.
as an example all build fix pat terns from the hierarchy in figure have the same popularity but the most concrete pattern update constant expression with parent expression version will be ranked highest.
if there is no generalization relation between patterns hirebuild ranks higher the build fix patterns from the seed fix with higher ranking the seed fix whose build failure log is more similar to that of the build failure to be fixed .
.
generation and validation of concrete patches before generation of concrete patches we need to first decide which .gradle file to apply the fix.
hirebuild uses a simple heuristic which always choose the first .gradle file mentioned in the error part extracted from the build failure log.
if no .gradle file is mentioned hirebuild uses the build.gradle file in the root folder.
given a build fix pattern and the buggy gradle build script as input to generate concrete patches hirebuild first parses the buggy gradle build script to ast and then hirebuild tries to find where a patch should be applied.
for updates and deletions hirebuild matches the build fix patterns to nodes in the ast.
for example the build fix pattern update constant expression with parent expression version can be mapped to an ast node of type constantexpression and its parent expression node has a value matching version .
when a build fix pattern can be mapped to multiple ast nodes very common for general build fix patterns and hirebuild generates patches for all the mapped ast nodes.
the only exception is when a build fix pattern is mapped to multiple ast nodes in one block.
in build scripts within the same block the sequence of commands typically does not matter so hirebuild retains only the first mapped node in the block to reduce duplication.
for insertions it is impossible to map a build fix pattern to an existing ast node so hirebuild matches the block and task names of the build fix patterns to the buggy build script.
when a build fix pattern is generated from a hierarchy merging multiple seed fixes hirebuild considers the task and block names of all seed fixes.
if a task or block name in the buggy script is matched hirebuild inserts the build patch at the end of the task or block.
after hirebuild determines which build fix pattern to apply and where to apply we finally need to concentrate on the abstract parts of the build fix pattern and determine the values of the abstract nodes e.g.
value of in the pattern update constant expression with parent expression version .
the most commonly authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden foyzul hassan and xiaoyin wang used values in build scripts are identifiers including task names block names variable names etc.
names of gradle plug ins and third party tools libraries file paths within the project and version numbers.
hirebuild first determines which typethe value to added belongs to based on the concrete values and ast nodes in the seed fixes leading to the build fix pattern to be applied.
hirebuild identifies version number and file paths basedon regression expression matching e.g.
hirebuild can determine that1.
.
beta8 is a version number and task block variable names by scanning the ast containing the seed fix.
other typesof values including dependencies plug in names and file paths are all specific to certain ast nodes so that they can be easily identified.
once the value type is determined hirebuild generates values differently for different types as follows.
identifiers hirebuild considers identifiers in the concrete seed fixes as well as all available identifiers at the fix location.
names of plug ins libraries tools hirebuild considers names appearing in the concrete seed fixes in the build failure log and in the buggy build script.
file paths hirebuild considers paths appearing in the concrete seed fixes in the build failure log and in the buggy build script.
v ersion numbers hirebuild first locates the possible tools libraries plug ins the version number is related to.
this is done by searching for all occurrences of the version variable or constant in the ast of the buggy script.
once the tool library plug in is determined hirebuild searches gradle central repository for all existing version numbers.
after the build fix pattern the location and the concrete value are determined a concrete patch is generated and added to the list of patches.
.
.
ranking of generated patches.
the previous steps generate a large number of patch candidates so ranking of themis necessary to locate the actual fix as soon as possible.
hirebuild ranks concrete patches with the following heuristics.
basically we give higher priority to the patches which involve values or scopes more similar to the buggy script and the build failure log.
patches generated from higher ranked build fix patterns are ranked higher than those generated from lower ranked buildfix patterns.
the initial priority value of a patch is the probability value of its build fix pattern.
if a patch pis to be applied to a location l andpis generated from a build fix pattern hierarchy merged from seed fixes a1 ... ai ... an.i flresides in a task block whose name is the same as the task block name in any ai hirebuild adds p s priority value by .
.
if a patch involves a value any one of the four types described in section .
which appears in the build failure log.
hirebuild adds the priority value of the patch by .
.
rank all patches with updated priority values.
note that since the initial priority value is from to in the heuristics we always add the priority value by .
when certaincondition meets so that it go beyond all the other patches which do not satisfy the condition no matter how high the initial priority value is.
.
.
patch application.
after the ranked list of patches are generated hirebuild applies the patches one by one until a timeout threshold is reached or the failure is fixed.
hirebuild determines the failure is fixed if the build process returns and the build log shows build success and all source files that are compiled in the latest successfully built version are compiled if they are not deleted in between.
we add the second criterion so that hirebuild can avoid trivial incorrect fixes such as changing the task to be performed from compile to clean up and to eliminate fake patches.
hirebuild stops applying patches after it reaches the first patch passing the patch validation.
though there may be multiple valid patches we apply only the first one that passes the validation.
hirebuild generally focuses on one line fixes as most other software repair tool does.
but it also includes a technique to generate multi line patches if the failure is not fixed until all single line patches are applied.
multi line patches can be viewed as a combination of single line patches but it is impossible to exhaust the whole combination space.
example shows a bug fix which can be viewed as the combination of three one line patches two deletions and one insertion .
to reduce the search space of patch combination hirebuild considers only the combination that occurs in original seed fixes.
consider two one line patches aandb which are generated from hierarchies ha andhb .
hirebuild considers the combination a b only ifha andhb can be generalized from a same seed fix.
after the filtering hirebuild ranks patch combinations by the priority sum of the patches in the combination.
example template with abstract node fix passy androiddirectorychooser 27c194f dependencies ... testcompile files testlibs robolectric .
snaps hot jar with dependencies.jar android testprovided files testlibs robolectric .
snaps hot jar with dependencies.jar android testcompile org.robolectric robolectric .
... empirical ev aluation in this section we describe our dataset construction in section .
and our experimental settings in section .
followed by research questions in section .
and experiment results in section .
.
finally we discuss the threats to validity in section .
.
.
dataset we evaluate our approach to build script repair on a dataset of build fixes extracted from the travistorrent dataset snapshot at february .
the tool and bug set used in our evaluation are all available at our website1.
travistorrent provides easy to use travis 1hirebuild dataset and tools authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hirebuild an automatic approach to history driven repair of build scriptsicse may june gothenburg sweden table dataset summary type count total number of projects maximum number of fix from single project minimum number of fix from single project average number of fix per project .
total number of fix training fix size testing fix size reproducible build failure size for testing ci build data to the masses through its open database.
though it provides large amount of build logs and relevant data our point of interest is build status transition from error or fail status to pass status with changes in build scripts.
from the version history of all projects in the travistorrent dataset we identified as build fixes the code commits that satisfy the build status of their immediate previous version is fail error the build status of the committed version is success and they contain only changes in gradle build scripts.
since hirebuild focuses on build script errors we use code commits with only build script changes so that we can filter out unit test failures and compilation failures.
our dataset may miss the more complicated build fixes that involve a combination of source code changes and build script changes or a combination of build script changes from different build tools e.g.
gradle and maven .
hirebuild currently does not support the generation of such build fixes cross programming languages.
actually fixing such bugs are very challenging and is not supported by any existing software repair tools.
from the commit history of all projects we extracted a dataset of build fixes.
more detailed information about our data set is presented in table .
we can see that these fixes are from different projects with maximal number of fixes in one project to be .
we ordered the build fixes according to the code commit time stamp and use earlier build fixes as the training set and the rest build fixes as the evaluation set.
therefore all the build fixes in our evaluation set are chronically later thanthe build fixes in our training set.
note that we combine all the projects in both training sets and evaluation sets so our evaluation is cross project in nature.
among these build fixes for evaluation we successfully reproduced build failures.
the remaining build failures cannot be reproduced in our test environment for the following three reasons a missing library or build configuration file was originally missing from the central repository and caused the build failure but theyare added later a flawed third party library or build configuration caused the build failure but the flaws are fixed and flawed releases are no longer available on the internet and the failure can bereproduced only with specific build commands and options whichare not recorded in the repository.
for case we were able toreproduce some bugs by trying common build command options.
we also contacted the travisci people about the availability of such commands options but they could not provide them to us.
for training set we did not reproduce build failures since we trust the software version history in travistorrent that human made changes resolved the build failures and we extracted only seed fixes from training set.table project wise build failure fix list project name failures correctly fixed aol micro server buildcraft buildcraft exteso alf.io facebook rebound griffon griffon btrace jmonkeyengine jmonkeyengine jphp compiler jphp netflix hystrix puniverse quasar rs485 logisticspipes total .
experiment settings travistorrent datset provides travis ci build analysis result as sql dump and csv format.
we use sql dump file for our experiment.
we use a computer with .
ghz intel core i7 cpu with 16gb of memory and ubuntu .
l ts operating system.
we use mysql server .
to store build fix changes.
in our evaluation we use minutes as the time out threshold for hirebuild.
.
research questions in our research experiment we seek to answer following research questions.
rq1 how many reproducible build failures in the evaluation set can hirebuild fix?
rq2 what are the amount of time hirebuild spends to fix a build failure?
rq3 what are the sizes of build fixes that can be successfully fixed and that cannot be fixed?
rq4 what are the reasons behind unsuccessful build script repair?
.
results rq1 number of successfully fixed build failures.
in our evaluation we consider a fix to be correct only if there is no build failure message in build log after applying patch and the build result i.e.
all compiled classes are exactly the same as those generated by the manual fix.
among reproducible build failures in the test set we can generate the correct fix for of them.
table shows the list of projects that are used for testing.
columns and represent the number of build failures and the number of those fixed successfully.
figure shows the breakdown of successful build fixes according the type of changes.
with hirebuild we can correctly generate fixes about gradle option changes fixes about property changes fixes about dependency changes and external tool option changes respectively and fix about removing incompatible statements.
example shows a build fix that is correctly generated by hirebuild falling in the category of external tool option changes.
the build failure is caused by adding a new option which is compatible only with java .
so the fix is to add an if condition to check the java version.
note that this fix involves applying the combination of two insertion patches but hirebuild still can fix it as there are a seed fix that contains both build fix patterns.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden foyzul hassan and xiaoyin wang figure breakdown of build fixes example a build fix correctly generated by hirebuild puniverse quasar 33bb265 if javaversion.current .isjava8compatible tasks.withtype javadoc options.addstringoption xdoclint none quiet figure patch list sizes rq2 time spent on fixes time spent on fixes is very important for build failures as they need to be fixed timely.
the size of patch list has impact on automatic build script repair.
if patch list size is too large it will take large time span to generate fix sequence.
wecompare patch list size of build failures we can correctly fix and patch list size of build failures we cannot correctly fix and present the result in figure .
from the figure we can see that for fixed build failures the patch list has minimum size of and maximum size of while median is .
for non fixed build failures patch list minimum median and maximum are and respectively which are lower than fixable build failure s patch list.
the reason behind this result is that for non fixable build failure hirebuild cannot find similar build fixes in the training set and thus the generated build fix patterns cannot be easily mapped to ast nodes in buggy scripts.
for the fixed build failures we compared in figure the time hirebuild spent on automatic fixing build failures with the manual fix time of the build failures in the commit history.
manual fix time comes from commit information and we use the time difference between build failure inducing commit and build failure fix commit as the manual fix time.
from figure we can see that build script fix generated by our approach takes minimum minutes maximum minutes and median value of minutes.
while human fix takesminimum less than one minute maximum minutes and median minutes.
we can see that for the fixable build failures hirebuild fixed them with time comparable to manual fixes.
figure amount of time required for build script fix figure actual fix sizes table cause of unsuccessful patch generation fix type of failures project specific change adaption no matching patterns dependency resolution failures multi location fixes rq3 actual fix size.
patch size has impact on automatic program repair.
according to le et al.
bugs with over six lines of fix are difficult for automatic repair.
in our dataset we have notperformed any filtering based on actual fix size.
but during resultanalysis we performed statistical analysis to find out the sizes ofbuild fix patches and the difference in size between the patchesour approach can correctly generate and the patches our approachcannot.
according to figure fixed build script failures contain minimum one maximum two and median one.
actually of the fixes contain only statement change and of the fixes contain only statement changes.
for non fixed gradle build script failures minimum change size is one while maximum and median change size is and respectively.
therefore our approach mainly works in the cases where the number of statement changes is small or which is similar to other automatic repair tools.
rq4 failing reasons for the rest build failures.
for .
of evaluated build failures our approach cannot generate build fix.
so we performed manual analysis to find out why our approach fails.
we check whether the reason is related to generation of version numbers dependency names etc.
then we categorize these failure reasons to four major groups project specific change adaption non matching patterns dependency resolution failures and multi location fixes as shown in table .
project specific change adaption indicates those changes that are dependent on project structure file path etc.
as build scriptmanages build and its configuration so there are project specific change issues and with our approach we cannot adapt the build fix patterns.
example shows such a build fix where it uses a specific path in build script.
non matching patterns indicates that our automatic patterns generation failed to provide required pattern that can resolve the build authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hirebuild an automatic approach to history driven repair of build scriptsicse may june gothenburg sweden example project specific change netflix hystrix if dep.modulename ser vlet api it.artifactid .text dep.modulename asnode .dependencies .dependency.find ... failure.
hirebuild could not generate appropriate patterns for failures which account of failures.
this may be due to limited size of training data and insufficient number of available build fixes that we used for template generation.
dependency resolution failures happens for some project when hirebuild did not find an actual dependency from central repository based on build log error.
even if we find dependency based on misscompiled classes that may not match with actual fixing.
example shows such a dependency update where our approach failed to generate the dependency name.
example dependency resolve issue buildcraft buildcraft 12f4f06 mappings snaps hot 20160214 mappings sta ble 22 multi location fixes happen when we need to apply multiple patches to fix a single build failure.
hirebuild considers only limited combinations of patches as introduced in section .
.
.
example shows such a case where our patch generation technique generated the two exclude statements in two different patches.
but this buildfailure is fixed only when we apply both exclude statement change simultaneously.
example dependency resolve issue joansmith quasar 64e42ef jvmargs xboot clas spathp sy stem.getproperty ser.home jsr166.jar testcompile org.testng testng .
.
tes tcompile org.testng testng .
.
exclude group com.google.guava module exclude group junit module .
threats of validity there are three major threats to the internal validity of our evaluation.
first there can be mistakes in our data processing and bugs in the implementation of hirebuild.
to reduce this threat we carefullydouble checked all the code and data in our evaluation.
second the successful fixes generated by hirebuild may still have subtledifferences with the manual fixes.
furthermore the manual fixes that we use as the ground truth may in itself has flaws.
to reduce this threat we used a strict criterion for correct fixes.
we need the automatically generated fix to generate exactly the same build results as those generated by the manual fix.
third the manual fixing timecollected in the commit history may be longer the actual fixing time as developers may choose to wait and not to fix the bug.
we agree that this can happen but we believe the difference is not large as developers typically want to fix failure as soon as possible so that it does not affect other developers.
the major threat to the external validity of our evaluation is that we use a evaluation set with limited number of reproducible bug fixes.
furthermore our evaluation set contains only build fixes where only gradle build scripts are changed.
so it is possible that our conclusion is limited to the data set gradle script fixes or gradle script only fixes.
figure shows that our evaluation set already covers a large range of change types and we plan to expand our evaluation setto more build failures and reproduce more bugs as travistorrent data set grows overtime.
gradle is the most widely adopted building system now and its market share is still increasing.
we also dida statistics on the number of build fixes with both gradle script changes and other file changes and found of them.
compared with build fixes in our dataset gradle script only fixes accounts for a large portion of build script fixes for gradle systems.
discussion patch validation and build correctness.
in the patch validation stage hirebuild deems a patch as valid if applying it results in asuccessful build message and all the files that are compiled in the most recent successful build are still compiled as long as they are not deleted.
our evaluation uses a more strict constraint which requires the compiled files in the automatically fixed build to be exactly the same as those in the manually fixed build.
the evaluation results show that our patch validation strategy is very effective because in all fixed builds in our evaluation the first patches passing validation are confirmed to be correct patches.
the reason is that based on the same compiler once a source file is successfully compiled it is unlikely to be compiled in different ways.
the only exception is that a library class reference is resolved to a wrong class when a wrong dependency is added.
furthermore to pass compilation the wrong class must accidentally have compatible behaviors e.g.
methods with the correct class.
such coincidence is not likely to happen.
build environment.
build environment defines the environment of a system that compiles source code links module and generates assembles.
from developer s point of view they install all required dependencies like java gcc and other frameworks.
but when projects are built in different environment then build problem canbe generated.
for example if certain project has dependency on java .
then building the project in build environment with java .
might generate build failure.
this a challenge for build automation as well as automatic build repair.
during software evaluation developers change environment dependency based on functional requirements or efficiency.
with version changes developers build the software having those changed dependencies.
but for build script repair if we change the version of any dependency and keep the build environment as it was before then the fix might not resolve build failures.
for android projects environment this issue creates greater impact as in most gradle build script it mentions sdk version build tool version etc.
inside build script.
as a result build script version dependency and build environment should be synced to avoid build breakage.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden foyzul hassan and xiaoyin wang related work .
automatic program repair automatic program repair is gaining research interest in the software engineering community with the focus to reduce bug fixing time and effort.
recent advancements in program analysis synthesis and machine learning have made automatic program repair apromising direction.
early software repair techniques are mainly specific to predefined problems .
le goues et al.
genprog which is one of the earliest and promising search basedautomatic patch generation technique based on genetic program ming.
patch generated by this approach follows random mutation and use test case for the verification of the patch.
later in authors optimized their mutation operation and performed systematic evaluation real bugs .
rsrepair performs similar patch generation based on random search.
d. kim et al.
proposed an approach to automatic software patching by learning from common bug fixing patterns in software version history and later studied the usefulness of generated patches .
ae uses deterministic search technique to generate patch.
pattern based automatic program repair p ar uses manually generated templates learned from human written patches to prepare a patch.
par also used randomized technique to apply the fix patches.
nguyen et al.
proposed semfix which applied software synthesis to automaticprogram repair by checking whether a suspicious statement canbe re written to make a failed test case pass.
le et al.
mines bug fix patterns for automatic template generation and uses version control history to perform mutation.
prophet proposed a probabilistic model learned from human written patched to generatenew patch.
the above mentioned approaches infers a hypothesisthat new patch can be constructed based on existing source.
thishypothesis also validated by barr et al.
that percent changes can be generated from existing code.
with this hypothesis we proposed first approach for automatic build failure patch generation.
tan and roychoudhury proposed relifix a technique that taking advantage of version history information to repair regression faults.
smith et al.
reported an empirical study on the overfitting to test suites of automatically generated software patches.
most recently long and rinard proposed spr which generates patching rules with condition synthesis and searches for the valid patch in the patch candidates generated with the rules.
angelix and directfix both use semantics based approach for patch generation.
to fix buggy conditions nopol proposes test suite based repair technique using satisfiability modulo theory smt .
although our fundamental goal is same but our approach is different than others in several aspects our approach is applicable for build scripts we generate automatic fix template using build failure log similarity with abstract fix template matching we can generate fix candidate lists with reasonable size.
.
analysis of build configuration files analysis of build configuration files is growing as an important aspect for software engineering research such as dependency analysis for path expression migration of build configuration file and empirical studies.
on dependency analysis gunter proposed a petri net based model to describe the dependencies in build configuration files.
adams et al.
proposed a framework to extract a dependencygraph for build configuration files and provide automatic tools to keep consistency during revision.
most recently al kofahi et al.
proposed a fault localization approach for make files which provides the suspiciousness scores of each statement in a make files for a building error.
wolf et al.
proposed an approach to predict build errors from the social relationship among developers.
mcintosh et al.
carried out an empirical study on the efforts developers spend on the building configurations of projects.
downs et al.
proposed an approach to remind developers in a development team about the building status of the project.
on the study of building errors seo et al.
and hassan et al.
carried out empirical studies to categorize build errors.
their study shows that missing types and incompatibility are the most common type of build errors which are consistent with our findings.
the most closely related work in this category is symake developed by tamrawi et al.
.
symake uses a symbolic evaluationbased technique to generate a string dependency graph for the string variables constants in a makefile automatically traces these values in maintenance tasks e.g.
renaming and detect common errors.
compared to symake the proposed project plans to develop build configuration analysis for a different purpose i.e.
automatic software building .
therefore the proposed analysis estimates run time values of string variables with grammar based string analysis instead of string dependency analysis and analyzes flows of files to identify the paths to put downloaded files and source files to be involved.on migration of build configuration files autoconf is a gnu software that automatically generates configuration scripts based on detected features of a computer system.
autoconf detects existing features e.g.
libraries software installed in a build environment and configure the software based on pre defined options.
conclusion and future work for source code automatic patch generation research is already in good shape.
unfortunately existing techniques are only concentrated to source code related bug fixing.
in this work we propose the first approach for automatic build fix candidate patch generation for gradle build script.
our solution works on automatic build fix template generation based on build failure log similarity and historical build script fixes.
for extracting build script changes we developed gradlediff for ast level build script change identification.
based on automated fix template we generated a ranked list of patches.
in our evaluation our approach can fix out of reproducible build failures.
in future we plan to increase training and testing data size for better coverage of build failures with better evaluation and perform study on patch quality for the patches generated by out tool.
moreover change patterns from general build script commits may also be useful and we have a plan to work on build script change patterns regardless of build status.
apart from that we are planning to apply search based technique such as genetic programming with fitness function on our patch list to better rank our generated patches and apply combination of patches.