revamping javascript static analysis via localization and remediation of root causes of imprecision shiyi wei university of maryland usa wei cs.umd.eduomer tripp google usa trippo google.combarbara g. ryder virginia tech usa ryder cs.vt.edujulian dolby ibm research usa dolby us.ibm.com abstract static analysis is challenged by the dynamic language constructs of javascript which often lead to unacceptable performance and or precision results.
we describe an approach that focuses on improving the practicality and accuracy of points to analysis and call graph construction for javascript programs.
the approach first identifies program constructs which are sources of imprecision i.e.
root causes through monitoring the static analysis process.
we then examine and suggest specific context sensitive analyses to apply.
o ur technique is able to to find that the root causes comprise less than of the functions in javascript library applications.
moreover the specialized analysis derived by our approach finishes within a few seconds even on programs which can not complete within minutes with the original analysis.
ccs concepts software and its engineering software testing and debugging theory of computation program analysis keywords javascript program analysis .
introduction dynamic programming languages such as javascript are now in widespread use for both client side and server side applications often together with cloud services and or mobile devices.
the flexibility of these languages for example for building prototypes is key to their popularity but their dynamic nature presents real challenges to static program analyses.
these challenges affect analyses used to ensure the security of applications e.g.
to optimize code for good performance e.g.
and to aid program theauthorwasemployedbyibmresearchwhenthepaper was written.understanding e.g.
.
for example javascript allows ob ject property accesses as associative arrays where the property name may be set as a result of execution.
making assumptions more accurate than worst case here may be difficult.
moreover javascript supports multiple programming paradigms including object oriented functional and procedural programming.
each programming paradigm requires specialized techniques for accurate analysis .
these are examples of how javascript features render accurate static analysis very difficult for many real world programs.
the effectiveness of a static analysis often is evaluated as a combination of its precision i.e.
low false positive rate andperformance i.e.
efficiencyinalimitedtime spacebudget .
with complex medium sized javascript programs especially those using real world libraries such as jquery static analysis cannot reach a useful solution within a reasonable time budget despite recent progress on improving the state of the art e.g.
.
often it is even difficult to obtain a good approximation of the program call graph which is a foundation of inter procedural static analysis and useful for tasks such as dead code elimination .
we present a new approach to tackle this problem for javascript programs.
by applying an imprecise static call graph construction and points to analysis algorithm to the program extra information about points to propagation is gathered in the points to graph under construction.1a heuristic process observes the analysis propagation phase in order to capture anomalous behavior i.e.
when the analysis is becoming too approximate through propagation of inaccuracy .
a diagnosis algorithm is applied to trace this bad behavior back to its root causes linked to specific functions.
by applying a well chosen context sensitivity polic y to use on these functions during a fresh analysis pass the anomalous behavior may be circumventable.
this process utilizes dynamic analysis results in addition to the static analysis self inspection to help choose the kinds of context sensitivity to propose.
we call this entire process root cause localization and remediation and it is crucial for designing effective new static analysis algorithms for javascript as well as for tuning existing analysis algorithms.
more specifically our systematic support for root cause localization and remediation focuses on points to analysis an enabling static analysis for various automated software tools.
when confronted with an unscalable and or too imprecisestaticpoints toanalysisonatargetprogram wekeep 1note that javascript points to analysis and call graph construction are often interleaved.
the accuracy of the pointsto graph directly determines the accuracy of the call graph.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
fse november seattle wa usa acm.
... .
487track of the history information in the propagation system labeling the origins of the points to relations.
while examin ingtheanalysispropagationasitisperformed heuristicsare applied to decide when to identify the sources of imprecision i.e.
when the analysis result begins to diverge .
our automatic root cause identification uses the intermediate points to results and the history labels to infer the variables and or reference properties that have big impact on overall analysis precision and performance as the root causes .
in addition we have designed an automatic approach that suggests specialized refinements to improve analysis precision for these root causes.
using a dynamic trace of program execution we build a set of dynamic points to graphs using various kinds of context sensitivity.
the idea is that the dynamic points to graphs can simulate the possible effects of applying a particular kind of context sensitivity to the root cause function in the re started analysis.
theautomaticroot causelocalizationrelievesastaticanal ysis designer from the chores of manually inspecting the program and the analysis implementation to understand the sources of imprecision.
moreover the automatic improvement suggestion provides possible context sensitive analy sis choices that may significantly improve the overall analysis performance and precision.
the specialized analysis configurations derived from the results of our approach with possible adjustment from the static analysis designer can be executed on the same program to observe if the performance and or precision issues have been resolved.
if necessary the same process can be iteratively performed to locate sufficiently many of the sources of imprecision in the analysis on the target program to achieve the desired accuracy and performance.
we have conducted experiments to evaluate the accuracy of the automatic root cause location and the subsequent improvement suggestions on real world javascript libraries and applications.
the major contributions of this work are we present the firstresearch that focuses on supporting static analysis design with automatic root cause localization identifyingthesourcessignificantlyaffecting analysis precision and performance.
our approach is the firstto use dynamic information to automatically suggest the kind of context sensitivity needed for significant precision improvement on identified root causes of analysis inaccuracy.
we present an evaluation of the proposed approaches on several benchmarks.
the experimental results on javascript library applications demonstrate that our root cause localization algorithm accurately identifies theprogramconstructsthatcauseaninitialstaticanalysistonotfinishina10minutetimeallotment.
applying specialized context sensitivity on these constructs significantly improves the analysis performance.
the results on javascript benchmarks also show that an analysis that selectively applies the recommended context sensitivity from our automatic improvement suggestion achieves a much better balance between precision and performance compared both to an imprecise analysis and a more precise analysis that applies context sensitivity over the entire program.1function extendbasic target source 2var name 3target target 4for name in source target source 7return target figure modifed extendfunction of jquery .
.
.
.
background motiv ation in this section we first introduce javascript points to analysis with an example.
we then discuss an empirical study of interesting static analysis behaviors that guided our design.
finally we illustrate our approach using a code example.
.
background points to analysis approximates the program s heap by calculating the set of abstract values a variable or reference property may have during execution.
context sensitivity is a general technique to achieve more precise program analysis by distinguishing between calls to a function .
it has been demonstrated that applying specialized context sensitivity in javascript points to analysis is an effective approach for improving its precision and performance.
for example sridharan et al.
used the values of a parameter pof a function as the calling context if pis the property name in a property access e.g.
v a special treatment for dynamic property accesses in javascript.
because this algorithm is designed to address the challenges caused by a specific language feature and performs well for the programs where this feature is present other program constructs found in real world javascript applications that require more accurate handling may render the analysis ineffective.
therefore an important stage of static analysis design is to identify the causes of unexpected results.
intuitively a root cause is a program construct that is a source of the precision and or performance loss for a static analysis.
specifically if the overall precision and performance of an analysis aimproves significantly via specialized handling of the program construct in a specific program location this construct is the root cause of imprecision of the analysis afor the program.
for example figure shows a small piece of code fromjquery the most widely used javascript library .
a whole program cfa analysis that separately analyzes each different call site of a function has scalability problems for any simple application that uses jquery .
applying the technique proposed by sridharan et al.
only to the property accesses at line resolves the performance issues.
therefore this program construct is a root cause of imprecision of cfa analysis for jqueryapplications.
unfortunately identifying root causes is a costly process requiring extensive experience in designing static analyses a s well as a deep understanding of the target program.
to the best of our knowledge there is little tool support for this process making it time consuming and unprincipled.
for example identifying the property accesses at line in figure as the root cause for cfa analysis is difficult because i thejquerylibrary consists of about lines of code and ii similar program constructs are used throughout the overall points to size no.
of evaluations cfa analysis combined cfa and specialized arg sensitive analysis figure points to size growth during the analysis lifetime.
jquerylibrary with less impact on the overall analysis results whereas this particular program location is critical.
therefore we are motivated to develop new techniques to assist in root cause localization by automating a significant part of the process of identifying the sources of imprecision.
.
static analysis behavior we have performed a brief empirical study to understand the behavior of javascript static analysis.
figures and show the different behaviors of two points to analyses of a simple application that uses jquery.
the two points to analyses in comparison are the cfa analysis i.e.
only use cfa analysis for the constructors to name objects by their allocation sites and the combined cfa and specialized argument sensitive analysis .
overall the cfa analysis experiences performance and precision issues e.g.
the analysis cannot finish analyzing the program within a time budget of minutes while the combined contextsensitive analysis performs significantly better.
figure shows the trend of overall points to size i.e.
total number of points to edges growth for these two analyses during their lifetimes.
the x axis presents the number of evaluations2and y axis presents the total points to size of all variables in the program.
the points to size of the goodcombinedcontext sensitiveanalysisgrowssteadily l inear throughout its lifetime.
on the other hand the overall points to size growth of cfa analysis exhibits jumps periods during which its overall points to size dramatically increases.
forexample betweenrounds23 000and25 000of evaluation the overall points to size of the cfa analys is grows about ten times.
the existence of such jumps indicates that the overly approximated results are frequently propagated resulting in significant overall precision loss.
in addition since the cfa analysis experiences scalability issues it remains incomplete at the end of the allocated analysis time and its overall points to size continues to grow after evaluations in figure .
figure shows the distributions of the points to sizes for eachvariableintheprogram.
thexaxispresentsthepointsto size of a variable and the y axis presents the percentage of the variables in the program with the corresponding pointsto size.
for the combined context sensitive analysis the points to size of the majority of the variables i.e.
is less than few variables are associated with large pointsto sets.
for the cfa analysis the points to sizes of only variables are less than and there are condensed 2an evaluation in the points to analysis solves a constraint that may result in changes of the points to results.
percentage of variables points to size cfa analysis combined cfa and specialized arg sensitive analysis figure points to size distribution.
occurrences of variables with extremely large points to sets e.g.
about of the variables points to sizes are .
thisresultalsoindicatesthatoverly approximatedresultsof specific program constructs may pollute many places in the program due to copying during the points to propagations.
the above results demonstrate the significantly different behaviorsbetweenpoints toanalyseswhentheirperformance and precision vary.
these results motivated us to design an automated approach to identify root causes of imprecision via the differences in static analysis behavior.
.
root cause localization remediation we now use the example in figure to illustrate the ideas on localizing root causes.
first the root cause localization should be performed during the period in which overall precision of the points to analysis starts to decrease reflected as the jumps in terms of the overall points to size in figure .
second we use the history information of points to propagations and the incomplete points to results to locate the program constructs that are root causes of imprecision.
intuitively two conditions should be met i the program construct has a wide reach within the propagation system e.g.
the values of the property access source are assigned to target at line and are transitively propagated to about other program variables or reference properties and ii the impact of its wide reach is significant e.g.
looking up the property nameofsourceat line produces the points to size of .
therefore the imprecision of this property access results in the overall imprecision of the cfa analysis when analyzing jqueryapplications becoming a root cause of imprecision.
in addition to further assist in the process of remedying static analysis we design an improvement suggestion algorithm that uses dynamic information to suggest appropriate context sensitivity to improve the analysis precision on the identified root causes.
dynamic information is used to simulate the benefits of different context sensitive analyses a generally applicable idea to quantify the potential precision of a specific context sensitivity.
.
technical overview figure summarizes the root cause localization and remediation process.
we first run the static analysis in its initial configuration which may lead to performance and or precision issues.
to monitor the behavior of the analysis we run it indiagnostic mode by instrumenting the propagation system with labels i.e.
labeled propagation system that keeps track of the history of points to propagations by saving the 489analysis configuration root cause identification labeled propagation system initial configuration improvement suggestion manual adjustment dynamic information perform identification?
adjusted configuration root cause localization root cause remediation figure overview of the root cause localization and remediation process.
origins of points to relations.
we avoid the common situation that the analysis crashes i.e.
runs out of time space budget causing the loss of the metadata for root cause localization by obtaining periodic snapshots of the analysis state.
insection4 wedescribeandmotivateourheuristicstodeterminewhethertheobservedpropagationbehaviorisanomalous.
intuitively an anomaly is flagged if a given variable or reference property collectively referred to as a program pointer is associated with a large points to set and the label corresponding to the pointer propagates to many other pointers within a small number of evaluations of the propagation system.
the labels record the transitive propagation of abstract objects across pointers.
our identification algorithm ranks the results by order of their impact on precision thereby reflecting how likely they are to be among the root causes of imprecision.
forroot causeremediation theoptional improvement suggestionstep that provides recommendations for improvement accepts as input i the candidate root causes ii a set of context sensitivity policies and iii one or more dynamic execution traces of the program.
the dynamic traces provide precise points to information such that the effect of different sensitivity policies can be evaluated.
intuitively the improvement suggestion process maps between the root causes identified statically and the concrete pointsinthetrace t andsimulatestheeffectofdifferentcontext sensitivity policies on t. for example given statement l y x in method mas the root cause the first step is to simulate the least precise treatment of lby merging together concrete points to information from all its occurrences in t. what follows is an iterative process wherein different kinds of context sensitivity and combinations thereof are applied and their effects are simulated.
a suggestion is output for l to utilize a certain combination cof context sensitive analyses if i cpartitions the points to set of x effectively and ii other combinations are only marginally better.
the final step is for the user i.e.
either the analysis designer or an end user capable of configuring the analysis to manually adjust the analysis configuration based on the localization results and or the improvement suggestions .
upon so the analysis can be rerun under the adjusted configuration to observe if the performance and or precision issues have been resolved.
the same process can be performed iteratively to locate all the root causes thereby leading to a specialized analysis that meets the performance precision requirements of the user.
in the next two sections we describe the details of the two automatic algorithms root cause localization and improvement suggestion.
we discuss each in turn.
.
root cause localization first we explain more technically how the labeled propagation system is implemented.
then we describe our indicators based on the labels which tell if anomalous propagation behavior is occurring.
the workflow of root cause localization is shown in procedure .
proc root cause localization workflow.
input config analysis configuration input i evaluation interval output r set of root causes sys initialize propagation system with config while c sys.
next constraint !
null do foreach assignment v1 v2 fromcdo ptsv1 ptsv1 uniontextptsv2 points to propagation lv1 lv1 uniontextlv2 uniontext v2 label propagation end for if k of evaluations mod i then grow points to size growth in past ievaluations ifgrow threshold then g intermediate static labelled points to graph foreach pointer node ningdo impact n compute the impact of nong end for r high impact nodes in g return end if end if end while .
labeled propagation system a propagation system for the points to analysis solves the constraints to reach a fixed point propagating the points to relations of the variables and reference properties in the program.
a majority of the constraints that exist in the propagation system are assignments.
for example to process an invoke instruction the generated constraints include assign ments from the actual arguments to the formal parameters from the callee s return values to the left hand side variable of the invoke instruction etc.
we assume a subset based aka inclusion based propagation system which means that the system solves a constraint that assigns a program pointer v2to another pointer v1by adding the points to set of v2to that of v1.
in a standard propagation system there is no provenance.
the points to set associated with a pointer may be the result of direct or transitive assignments and there is no telling in general how it evolved to its current state.
such information is critical however to identify root causes since frequent assignments involving an inaccurate points to set may pollute the overall precision of the points to solution as depicted in figures and .
to address this loss of information in our labeled propagation system each constraint that assigns the values of v2 tov1results in changes to v1 s points to relations.
moreover a label v2is associated with the points to set of v1that indicates some of the points to relations of v1were propagated through v2 lines in procedure .
as an example in wala intermediate representation ir which is in ssa form the statement at line in figure reduces to a vtmp source and b target v tmp wherevtmp source targetandnameare all local variables of the function.
490for the property read instruction a the analysis would firstquerythepoints tosetof source psource andthepointsto set ofname pname.
the pairs of each element in psourceand pname e.g.
psource i.pname j are returned as the results of looking up the reference properties of source .
note that the values of nameiterate over all the property names ofsource in theextendfunction these values are the large set function names loaded in jquery.
this ultimately results in a large points to set for vtmpdue to multiple assignments from various reference properties.
we retain all these reference properties e.g.
psource i.pname j as labels attached to the points to set of vtmp.
for the property write instruction b the analysis similarlylooksupthereferencepropertiesof target e.g.
ptarget i.pname j and adds the points to relations of vtmpto each of these reference properties resulting in an overly approximated points to set for each function name in jquery.
we retain both vtmpand the existing transitive labels from vtmp e.g.
psource i.pname j in the points to set of each reference property of target .
in addition to tracking the set of labels that are immediately or transitively propagated to the points to set of a given pointer we generate a propagation history graph for the points to set of that pointer which organizes the pointsto propagation history into a hierarchical structure.
intuitively a node in the propagation history graph is a program pointer that has bearing on the specific points to set.
an edge from node n1to another node n2represents that the points to set of n2was explicitly added to that of n1.
the entry points of the graph are the program pointers whose points to sets are directly propagated into the corresponding points to set.
for the same example in figure the propagation history graph for the points to set of vtmpconsists of all the reference properties of source as entry points.
vtmpis the entry point of the propagation history graph for the points to set of each reference property of target e.g.
ptarget i.pname j while there also are edges from vtmp to the properties of source .
as motivated above during the propagation process the labeled system is paused regularly upon completing cycles ofievaluations for a fixed value of i line in procedure .
we base our analysis of root causes of precision on the resulting intermediate states.
specifically we count the total number of points to relations i.e.
edges in the intermediate points to graph for thekthpause i.e.
after n kevaluations actual k .
we then compare the value of actual k with the value of predict k to decide whether to perform root cause identification.
for meaningful comparison we utilize the results from the previous k 1pauses in performing linear regression analysis to find the fitted line y intercept slope x where xis the number of evaluations and yis the total number of points to relations.
the number of points to relations of thekthpause can then be predicted predict k intercept slope kn.
ifactual k threshold predict k then we perform the root cause identification at thekthpause otherwise we continue the points to analysis under the labeled propagation system.
in practice we use threshold effective for our evaluation in section .
figure shows this prediction model when running the cfa analysis on a jqueryapplication.
the analysis is overall points to size no.of evaluations k actual results actual k predict k linear k actual results figure prediction via linear regression.
paused every evaluations and the fitted line in figure is calculated from the results of the first pauses i.e.
to evaluations .
the predicted total points to edges at the evaluations is while actual is88 significantlypassingthethresholdtoperformrootcause identification.
this prediction model can capture the jump phase of the points to analysis shown in figure which is important to localize the root causes accurately.
iflocalizationisperformedtooearly theover approximate results may not have surfaced yet.
if localization is performedtoolateduringtheanalysis thentheover approximate results may have polluted a large portion of the overall points to results making it difficult to identify the root causes of imprecision.
moreover the evaluation interval to pause the analysis i as well as the decision threshold may be tuned based on the budget and goals of root cause localization.
.
identifying root causes for divergence when performing root cause identification we use the intermediate points to graph and the associated labels to identify possible root causes line in procedure .
for each variable or reference property v we count i its points to size pv as well as ii its number of occurrences as labels in the points to sets of other variables and or reference properties lv .
lv measures how widely vreaches within the propagation system and pv measures if the impact of its wide reach is significant.
we therefore use the scoring heuristic sv pv lv as a measurement of the possibility ofvbeing a root cause lines in procedure .
the root cause identification stage reports a set of variables as root causes in descending order of their scores.
for example vtmp the result of the property read instruction at line in figure achieves an extremely high score with pvtmp 150and lvtmp 493when localization is performed after evaluations.
its score is x75 higher than the variable with the second highest score rendering it the only root cause candidate for imprecision of the cfa analysis for this jqueryapplication.
we report the variables and or reference properties whose scores are at least half the highest score as candidate or suspicious root causes .
.
improvement suggestion the next step is to automatically compute suggestions for how to improve the analysis per the program configuration and context sensitivity at hand.
this is the focus of this section whose workflow is shown in procedure .
491proc improvement suggestion workflow.
input r r ... r n root causes input cs context sensitivity policies output v s r s1 ... r n sn suggestions t collect a dynamic trace foreachcs csdo g g uniontext gen t cs end for foreachr rdo a r g foreachg gdo a r g queryr s points to size in gand measure its accuracy corresponding to g s context sensitivity a r g a r g uniontext a r g end for a r gmin min a r g v s v s uniontext r g min.cs end for first the target program is executed to collect a dynamic trace line in procedure recording the following runtime artifacts in order of occurrence i function entries and exits ii invocations and iii property reads and writes.
at a property read write instruction we record i the instruction location in the program ii the allocation site of the base object as its program location iii the property name and iv the allocation site of the value if it is a reference object or the type of the value if it is a primitive value.
at an invoke instruction we record i the location of the call site ii the location of the target function iii t he allocation site of the receiver object and iv the allocatio n sites and or the types of the actual arguments.
second dynamic points to graphs based on the dynamic trace are generated for the available kinds of context sensitivity lines in procedure .
procedure captures the algorithm that produces a dynamic points to graph with respect to a specific context sensitive analysis e.g.
cfa 1st argument sensitive or context insensitive anal ysis .
the inputs are the dynamic trace trace and the kind of context sensitivity cs.
the algorithm iterates through each instruction irecorded in the dynamic trace.
if iis an invoke instruction at line the call site and the argument are pushed into the call stack stack.
ifiexits a function then top element of stackis removed at line .
ifiis a property read or write instruction then lines to show how the appropriate calling context is determined thecallingcontextis everywhere forcontext insensitiveanalysis.
in the dynamic points to graph a variable is represented by i the location of the instruction ii the part of the instruction i.e.
base property or value and iii the calling context.
at lines to the object allocation site represented by program location of each part of the instruction collected at runtime is assigned to the corresponding variable node in the dynamic points to graph.
this algorithm is general in that various dynamic pointsto graphs can be generated under different context sensitivity policies.
now that we have obtained different contextsensitive dynamic points to graphs we can determine which of the policies including combinations thereof are beneficial.
for a program pointer rthat is identified as a root cause we locate its corresponding nodes via its program location in each dynamic points to graph and collect i the number of calling contexts associated with r ccr andproc dynamic points to graph generation gen t cs .
input t dynamic trace input cs context sensitivity policy output g dynamic points to graph stack while i next t !
null do switch kindof i caseinvoke stack.push call site and first arg of i casefexit stack.pop casepread pwrite ifcs cfa then context immediate call site on stack else ifcs 1st argument sens then context immediate argument on stack else ifcs context insens then context everywhere end if g iloc base context ibase g iloc property context iproperty g iloc value context ivalue end switch end while ii the sum of points to sizes under all calling contexts summationtext pr .
we then count ar summationtext pr ccr the average dynamic points to size per calling context to measure the accuracy of the points to relations of vunder the given context sensitivity line in procedure .
the context sensitivity with the smallest aris chosen for the function that contains ras the improvement suggestion lines and in procedure .
.
ev aluation we have implemented our root cause localization and remediation algorithms and conducted experiments to assess their efficacy.
in this section we present the experimental results of our analysis on various javascript benchmarks.
.
experimental setup .
.
metrics in our evaluation we compared the performance and precision of points to analysis that usually constructs a call graph as well as a points to graph.
for precision on a call graph we measured i high poly the number of highly polymorphic call sites i.e.
call sites with more than targets ii avg targ the number of targets averaged over all call sites and iii reac func the number of reachable functions as in .
for precision on a points to graph we measured pts size the overall points to size.
this is the total number of points to set sizes summed over all local variables in the program.
the points to set of a variable is the set of abstract objects i.e.
allocation sites it refers to representing the set of values it may have at runtime.
in addition we measured the performance of the points to analysis with its running time in seconds .
.
.
benchmarks we use two sets of javascript benchmarks.
benchmarks i. benchmarks i consists of applications that use javascript libraries generated by sridharan et al.
492table benchmarks i precision and performance results.
library cfa cfa 1st arg sens cfa selective 1st arg sens whole combined selective reac funcavg targhigh polyreac funcavg targhigh polyreac funcavg targhigh polytime sec jquery .
.
.
.
prototype.js .
.
.
.
script.aculo.us .
.
.
.
.
included are and simple web applications that invokejquery prototype.js andscript.aculo.us libraries respectively.
these libraries are among the most popular javascript libraries for developing real world web applications especially jquery .
sridharan et al.
performed manual code rewriting for improving precision and performance of their specialized analysis on these libraries.
in our experiments we reuse these manual transformations.
benchmarks ii.
benchmarks ii are javascript applications collected by kashyap et al.
.
twelve out of the programs from the original benchmarks were selected for our evaluation.
these programs are collected from opensource javascript repositories standard javascript benchmarks e.g.
sunspider3 and the emscripten llvm test suite4 the results of which benefit from various contextsensitive analyses .
.
.
experimental design root cause localization.
we performed experiments on benchmarks i to illustrate the accuracy of the root cause localization algorithm.
in this experiment we used wala s whole program1 cfaanalysisasthe baselineanalysis which experiencesscalabilityandprecisionproblemsforjavascript library applications.
for each of the benchmark i programs we performed the localization algorithm on the cfa analysis finding a set of functions that contain the root causes.
then for the root cause functions we applied additional argument sensitivity on the first arguments i.e.
1st argument sensitivity .
for the rest of the functions cfa analysis was performed resulting in a cfa and selective 1stargument sensitive analysis.
we compare the precision results among the cfa the whole program cfa and 1stargument sensitive analysis and the selective analysis using the call graph metrics for benchmarks i. we also compare the differences in terms of analysis performance.
improvement suggestion.
for the programs in benchmarks ii we applied the root cause localization as well as improvement suggestion algorithms on the baseline0 cfa analysis.
for the root cause functions we applied the suggested context sensitivity and for the rest of the functions the cfa analysis was performed comprising an autoselective analysis.
possible suggestions for root cause functions include i a context insensitive analysis ii a s ingle context sensitive analysis i.e.
cfa or argument sensit ivity on any argument of the function5 and iii a combined context sensitive analysis e.g.
cfa 1st argument sen sitivity .
we compare the performance and precision of 5object sensitivity applies calling contexts on the receiver argument.theauto selective analysis with the cfa analysis and thefull sensitive analysis i.e.
a whole program combined context sensitive analysis that applies cfa and argument sensitivity on all arguments for benchmarks ii to illustrate the effectiveness of the improvement suggestion.
our comparison experiments explored the following two hypotheses hypothesis i the root cause localization algorithm can accurately identify a small set of program constructs as the root causes of imprecision.
hypothesis ii guided by the root causes identified by the localization algorithm the improvement suggestion algorithm can recommend appropriate kinds of context sensitivity to significantly improve the analysis precision.
the experimental results were obtained on a .
ghz intel core i5 macbook pro with gb memory running the mac os x .
operating system.
.
benchmarks i results tables and show the experimental results of benchmarks i. for each javascript library the results are arithmetically averaged over all the applications that use the spe cific library.
for example the reachable functions of jquerylibrary from the cfa analysis i.e.
column of the jquery row in table is calculated by averaging the number of reachable functions the cfa analysis obtained for all jqueryapplications.
precision and performance.
table shows the precision and performance results of the analyses on benchmarks i. columns and show the results of call graph precision metrics for the cfa analysis the whole program combined cfa and 1st argument sensitive analysis i.e.
whole combined analysis and the cfa and selective 1stargument sensitive analysis respectively.
for each analys is we present its number of reachable functions i.e.
columns and average number of targets per call site i.e.
columns and and the number of highly polymorphic call sites i.e.
columns and .
in addition column shows the points to analysis time in seconds of the selectiveanalysis.
given the time budget of minutes both the cfa analysis and the whole combined analysis failed to complete analyzing each of the programs in benchmarks i therefore their precision results were calculated from the incomplete call graphs obtained after the timeout.
thereac func results of the whole combined and the selectiveanalyses in table are the same for all three libraries 6because the applications in benchmarks i are relatively simple programs that use the javascript libraries the analysis performance and precision results of these programs are dominated by the underlying libraries.
therefore we report the average results based on the corresponding libraries.
493they are significantly more precise than those of the cfa analysis.
only for script.aculo.us to for jquery functions considered reachable by the cfa analysis are produced by the whole combined and the selective analyses.
interestingly the number of highly polymorphic call sites is below50forthe selective analysisforallthreelibraries while the cfa analysis produces for script.aculo.us to forjquery and the whole combined analysis results in forscript.aculo.us to for jquery highly polymorphic call sites.
this result suggests that i cfa analysis is im precise to resolve the call targets in many cases and ii because the whole combined analysis applies 1st argument sensitivity over all the program it may create many calling contexts for the functions that are not identified as root causes which may not significantly increase the analysis precision e.g.
in terms of the reac func metric .
the average number of targets per call site from the selective analysis ranges from .
for jquery to .
for prototype.js indicating the selective analysis precisely resolves the targets for most call sites.
although the whole combined analysis reduces the avg targ of the cfa analysis from .
to .
and from .
to .
for prototype.js andscript.aculo.us respectively it still results in a higher average number of targets per call site comparing to the selective analysis.
for jquerylibrary applying argument sensitivity over the entire program results in significant increase of avg targ i.e.
on average targets per call site and high poly i.e.
highly polymorphic call sites due to the additional calling contexts.
the last column in table shows that the selective analysis finishes analyzing the libraries on average between seconds for prototype.js and seconds for jquery .
due to the fact that the cfa analysis could not finish analyzing any of these libraries in under minutes we claim that theselective analysis has significantly better performance because of the precision gained by applying 1st argument sensitivity to the root cause functions.
the whole combined analysis also could not complete within the minute time budget.
applying 1st argument sensitivity over all the program generates too many calling contexts for the propagation system to quickly converge.
table localization results of benchmarks i. libraryno.
of localized functionsno.
of evaluationsslope jquery .
prototype.js .
script.aculo.us .
root cause localization characteristics.
table2shows additional information that characterizes the results of the root cause localization algorithm.
for the experiments on benchmarks i we paused the cfa analysis every evaluations to decide if the root cause localization algorit hm should be performed.
columns and present the number of functions identified as root causes the number of evaluations until performing root cause localization and the slope of the last evaluations i.e.
the increase in the total number of points to relations divided by respectively.ouralgorithmidentifies2 4and4functionsasrootcauses forjquery prototype.js andscript.aculo.us respectively.
comparing to the number of reachable functions computed by any analysis in table i.e.
more than functions very small fractions of these functions were identified as root causes.
this result combined with the good precision and performance of the selective analysis support our intuition that a small number of complex constructs in the programs may contribute to significant loss of analysis performance and precision if not handled accurately.
therefore it is extremely useful for our automated localization algorithm to pinpoint these root causes as shown.
column shows that the slopes of the last evaluations range from .
for jquery to .
for prototype.js .
for example for prototype.js the large slope indicates that the precision of the cfa analysis significantly decreases during this period i.e.
about new points to relations per constraint while the slope of the simple linear regression for all previous evaluations is .
.
this result suggests that our heuristics accurately decided when to perform the rootcause localization for javascript libraries.
summary.
the results of benchmarks i suggest that i our root cause localization algorithm is capable of locating a small number of functions where the cfa analysis experiences significant precision and performance loss and ii becausetherootcausesarehighlyclusteredinthesejavascript libraries applying the selective 1st argument sensitive an alysis only on the localized functions achieved a much better balance between precision and performance comparing to thewhole combined analysis.
the above observations supporthypothesis i .
.
benchmarks ii results figures and show the precision and performance results of benchmarks ii respectively.
because the cfa analysis finishes analyzing all programs in benchmarks ii within the time budget of minutes the root cause localization was performed after the cfa points to analysis completed on each program.
figure presents the pts size precision improvement of thefull sensitive analysis i.e.
grey bars and the autoselective analysis i.e.
patterned bars over the cfa analysis.
because the full sensitive analysis applies cfa and argument sensitivity of all arguments over all the functions its results are at least as precise as the selective analysis.
in figure the y axis shows the precision improvement of the corresponding analysis yover the cfa analysis calculated as follows impy ptssize0 cfa ptssizey ptssize0 cfa therefore impymeasures the precision of analysis yin terms of removing the false positives from the cfa analysis results.
in figure the full sensitive analysis improves thepts size precision over the cfa analysis by between for sgefa to for cryptobench .
for all but five programs i.e.
fourinarow cryptobench linqfunctional linqaggregate andlinqenumerable the differences in precision improvement percentages are within .
between thefull sensitive and the auto selective analyses indicating that the auto selective analysis produces similar results to thefull sensitive analysis for most programs.
the results of the linqaggregate program exhibit the largest differ4940 fourinarow aha fasta sgefa llubenchmark fannkuch hashtest cryptobench linq functional linq aggregate linq dictionary linq enumerable precision improvement in percentage benchmarks ii full sensitive analysis precision improvement auto selective analysis precision improvement figure benchmarks ii precision results.
ence in terms of precision improvement i.e.
between thefull sensitive and the auto selective analyses.
the points to relations in the cfa solution that do not appear in the full sensitive solution are false positives.
more than of these relations also did not appear in the auto selective solution for linqaggregate demonstrating its greater accuracy over the cfa analysis.
figure7presentstheperformanceresultsofthe full sensitive i.e.
grey bars and the auto selective i.e.
patterned bars analyses comparing to the cfa analysis performance.
the y axis in logarithmic scale shows the overhead of the corresponding analysis y s time cost comparing to the 1cfa analysis time i.e.
timey time0 cfa .
the performance of an analysis on each benchmark program was obtained by averaging over repeated executions.
in figure the full sensitive analysis performs significantly worse than the cfa analysis for all the benchmark programs.
it could not finish analyzing linqaggregate andlinqenumerable under the time budget of minutes therefore the incomplete points to results of these two programs were obtained after the timeout for comparison.
the full sensitive analysis is at least two orders of magnitude slower for another three programs i.e.
linqfunctional aha andlinqdictionary and is between for fannkuch and forllubenchmark times slower for six programs than the cfa analysis.
for example it takes less than one second for the cfa analysis to finish analyzing linqfunctional while the full sensitive analysis needs almost minutes to complete analyzing the same program.
despite of the fact that the full sensitive analysis often results in relatively significantprecisionimprovement e.g.
for linqfunctional the performance issues outweigh the benefits of this wholeprogram combined context sensitive analysis in many cases.
on the other hand the auto selective analysis is capable of analyzing the benchmarks under the same order of magnitude as the cfa analysis for all but three programs i.e.
fourinarow ahaandlinqdictionary .
for example theauto selective analysis improves the precision over the cfa analysis by for cryptobench and it also finishes analyzing this program almost as fast as the cfa analysis.
in most cases the auto selective analysis results in a much better balance between performance and preci sion than the full sensitive analysis e.g.
the full sensitive analysis is more precise but performs times slower than the cfa analysis for cryptobench .
for three programs the auto selective analysis performs more than times slower than the cfa analysis i.e.
and times slower for aha fourinarow andlinqdictionary respectively the auto selective analysis is still an order of magnitude faster than the full sensitive analysis for ahaand about times faster than the full sensitive analysis for fourinarow .
an outlier is the auto selective analysis for linqdictionary whose performance is similar to the full sensitive analysis.
theauto selective analysis applied combined context sensitivity on out of i.e.
reachable functions of linqdictionary resulting in both precision improvement and performanceoverhead.
nevertheless the auto selective analysis has achieved significantly better performance than the full sensitive analysis for most of the programs in benchmarks ii.
ourlocalizationalgorithmidentifiesbetween6 for fourinarow to for linqaggregate of the functions as the sources of precision loss with an average of of the functions over all the programs in benchmarks ii a relatively small fraction.
our improvement suggestion algorithm recommends combined context sensitivity on single context sensitivity on and context insensitivity on of all the root cause functions in benchmarks ii respectively.
summary.
theauto selective analysis obtains similar precision results to the full sensitive analysis that improves the precision of the cfa analysis.
moreover the autoselective analysis performance is significantly better than the whole program combined fully context sensitive analysis.
this result supports hypothesis ii that our improvement suggestion algorithm can choose the appropriate context sensitivity that benefits the results both in performance and precision for benchmarks ii.
.
threats to validity although we used benchmarks collected by sridharan et al.
and kashyap et al.
in our experiments the representativeness of these benchmarks might threaten the validity of our conclusions as applicable to all javascript programs.
i the simple web applications invoking the li495 1x 10x 100x 1000x fourinarow aha fasta sgefa llubenchmark fannkuch hashtest cryptobench linq functional linq aggregate linq dictionary linq enumerable performance logarithmic scale benchmarks ii full sensitive analysis performance auto selective analysis performance figure benchmarks ii performance results.
braries i.e.
benchmarks i may not be representative of later javascript library versions or the behavior of realworld javascript websites.
ii benchmarks ii consisting of small and dated javascript programs in standard benchmarks may not be representative of non website javascript applications.
.
related work to the best of our knowledge we present the first work that focuses on automating the process of localizing and remedying the root causes when a javascript analysis is unscalable or too imprecise on a program.
nevertheless our work is related to i recent context sensitive static analyse s that unveiled difficult javascript program constructs and ii static analyses that identify the causes of precision los s for refinement.
.
javascript context sensitive analysis sridharan et al.
identified correlated dynamic property accesses e.g.
x y as a hard to analyze javascript code pattern and presented a specialized argument sensitive analysis along with program transformation that dramaticallyimprovesanalysisscalabilityandprecisiononjavascri pt libraries .
this work motivated us to design an automatic localization algorithm that identifies such program constructs causing the analysis imprecision.
we also have reused the library benchmarks collected by sridharan et al.
as benchmarks i in the evaluation.
esben et al.
inferred determinacy information i.e.
a variable and expression always has the same value at a given program point and improved static analysis precision on javascript libraries via various techniques .
for example argument sensitivity was selectively applied for the arguments whose abstract value was a concrete string or a single object address.
this specialized context sensitivity was proposed as a result of manually inspecting imprecise portions of an incomplete call graph obtained after a fixed number of evaluations.
in our work root causes of analysis imprecision are automatically localized and corresponding focused program constructs are provided for inspection.
wei and ryder presented a two stage context sensitive analysis for javascript that selectively applied specific kin dsof context sensitivity on the function level .
heuristics were used tochoose the context sensitivity based on function characteristics extracted from the results of a pre analysis.
our improvement suggestion may also result in applying different kinds of context sensitivity to the root cause functions.
however the adaptive analysis in required a preanalysis that could finish analysis of the target program while our approach does not.
in addition our goal is to apply the specialized context sensitivity only on the root cau se functions that may significantly improve the overall analysis scalability and precision while adaptive analysis selects a specific context sensitivity for each of the functions.. park and ryu presented another javascript static analysis that improved precision via loop sensitivity .
the authorsidentifiedonerootcauseofscalabilityproblemswith javascript analysis as the combination of imprecise results in loops and in dynamic property accesses.
their analysis improved precision in loops by distinguishing each iteration of a loop with different contexts based on the analysis results of loop conditional expressions.
our approach systematically assists in the process of locating such code patterns as root causes of analysis scalability problems.
madsen et al.
presented a static analysis for event driven node.js applications extending the traditional call graph with nodes and edges that reflect the flow of control due to event handling .
three context sensitivity policies va rying in precision and cost were introduced for constructing event based call graphs.
it would be interesting to explore if our root cause localization technique may generally be applied to this work.
.
refinement based analysis smaragdakis et al.
presented introspective analysis that aimed to improve the performance of a context sensitive analysis for java .
introspective analysis used heuristics to decide whether to refine an allocation site or a call site with context sensitivity based on the metrics computed from context insensitive points to results.
the heuristics focused on reasoning about the cost of applying additional context sensitivity.
instead we focus on identifying the constructs that originate significant loss of performance and or precision of an analysis.
therefore applying more accurate 496but expensive analysis techniques only on these constructs may result in the improvement of the overall analysis performance and precision.
sridharan and bod k presented a refinement based pointsto analysis for java that refined sensitivity for heap accesses and method calls .
the analysis was demand driven and client driven in that it focused on refining the analysis of relevant code.
we focus on improving overall points to analysis precision in terms of all possible queries for points to sets of program variables instead of precisely answering a specific query.
guyerandlinpresentedaclient drivenanalysisforcthat automatically adjusted its precision in response to the needs of client analyses .
this client driven analysis monitore d polluting assignments i.e.
the program points that result inaccuracy in the analysis and tuned context as well as flow sensitivity to improve precision.
our heuristics to locate the root causes consider not only the inaccurate results at a program point but also its impact on the overall points to analysis precision by tracking the labels in the propagation system.
liang et al.
found minimal abstractions needed to prove a set of queries using machine learning algorithms and showed that very few components of an abstraction were needed to proveaquery .
ourimprovementsuggestion incontrast is not driven by queries but rather by localization of the sources of imprecision.
.
conclusions future work staticanalysisofjavascriptisachallengingproblemgiven the dynamic nature of this language.
hence as we demonstrated experimentally neither coarse nor precise analyses are able to cope with javascript applications with acceptable precision and performance.
we have developed a technique to systematically identify root causes of analysis imprecision.
overrootcauses webuiltanalgorithmthatautomatically suggests a specific context sensitivity for a small fraction of the functions i.e.
root cause functions .
the results on library applications show that applying context sensitivity to a small set of root cause functions resolves the scalability problems that occur on both coarse and precise analyses.
the analysis that automatically applies the suggested kind of context sensitivity to the root cause function s achievesabetterbalancebetweenprecisionandperformance for most programs in benchmarks ii demonstrating the effectiveness of the improvement suggestion algorithm.
in the future we intend to improve the usability of our approach and make it more interactive by enabling a visual interface to review root causes etc.
we also intend to extend our recommendation algorithm to support more forms of static analysis techniques e.g.
the ability to perform semantics preserving transformations on the subject program for analysis purposes .
.