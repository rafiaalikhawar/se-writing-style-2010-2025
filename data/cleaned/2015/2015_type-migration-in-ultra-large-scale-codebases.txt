type migration in ultra large scale codebases ameya ketkar ali mesbah davood mazinanian danny dig and edward aftandilian oregon state university ketkara digd oregonstate.edu university of british columbia amesbah dmazinanian ece.ubc.ca google inc. eaftan google.com abstract type migration is a refactoring activity in which an existing type is replaced with another one throughout the source code.
manually performing type migration is tediousas programmers need to find all instances of the type to bemigrated along with its dependencies that propagate over as signment operations method hierarchies and subtypes.
existingautomated approaches for type migration are not adequate forultra large codebases they perform an intensive whole programanalysis that does not scale.
if we could represent the typestructure of the program as graphs then we could employ a m apreduce parallel and distributed process that scales to hundreds of millions of loc.
we implemented this approachas an ide independent tool called t2r which integrates withmost build systems.
we evaluated t2r s accuracy usefulness andscalability on seven open source projects and one proprietarycodebase of 300m loc.
t2r generated type migrationpatches of which the original developers accepted .
index t erms refactoring type migration mapreduce.
i. i ntroduction as programs evolve an existing type tmay need to be replaced by another type r because thas been deprecated orris more efficient.
for example a programmer might need to replace usages of hashmap with arraymap to improve runtime performance .
such a refactoring activity for going from ttoris known as type migration.
type migration modifies the declared types of variables or methods in aprogram and propagates the necessary changes throughout theprogram preserving the type correctness.
manually performing type migration can be quite tedious.
first programmers have to find all the instances of the typeto be migrated.
second they need to find all the dependenciesin the source code.
this is further complicated by typepropagation over assignment operations parameters of themethods overridden methods and class hierarchies.
third they need to make sure that every callsite has a counterpart inthe new type.
finally they must perform the transformation.these tasks can easily overwhelm developers.
for example when c orenlp developers replaced generic with specialized java s functional interfaces the type migration involved 34files containing declarations allocation sites callsites subclasses and lambda expressions.
with the sizeof the projects the complexity of type migration also increases.
type migration is a foundational step in class library migration fixing api breaking changes in clients e.g.
updatinga method s signature or correcting inefficient uses of anapi .
these refactorings are generally hard to automate .existing automated approaches for type migration fall shortwhen dealing with ultra large codebases.
modern ides pro vide little support for type migration often leaving out crucialanalysis required for safe type migration such as the map pings between the new and old types methods.
moreover state of the art type migration techniques require in depth whole program analysis.
for example researchers haveproposed techniques for class library migration a frequently applied type migration using type constraints analysis .
however type constraints analysis is resource in tensive and not scalable to ultra large scale codebases since it has to extract constraints for allprogram types.
while this was a great breakthrough for the program analysiscommunity in the previous decade it is less suitable for today scodebases e.g.
for large open source projects of hundredsof thousands loc which we used in our formative study or google s codebase of 300m loc.
another limitation ofthe current techniques is their extensive dependence on ides.these approaches perform resource intensive whole programanalysis locally inside of the ide and are unable to takeadvantage of the modern workflow of continuous integrationon dedicated servers thus hindering developers productivity.
in this paper we propose a scalable and ide independent technique for type migration that integrates with most buildsystems e.g.
a nt m av e n gradle and scales to ultralarge java codebases.
our technique is composed of three con secutive steps each amenable to m apreduce parallel processing.
to reduce the analysis space in the first step our approach passes over the entire codebase in search oflanguage constructs e.g.
method signatures method calls variables that match the to be migrated types.
we then serialize each matched language construct to the filesystem.in the second step we construct a graph representing thelanguage constructs collected in the first phase as nodes andthe relationships between them e.g.
a method declarationand its invocations as edges.
using a set of migration specific constraints we analyze the graph to yield a list ofrefactorable candidates.
finally in the third step our techniquepasses again over the codebase in search of matches with therefactorable candidates and applies the corresponding textualtransformations in place.
we implemented this approach in a tool called t2r t r .
our approach is generalizable to any type migration.
however to help the reader understand the complexitiesof type migration in this paper we use t2r to specialize the usage of functional interfaces across java codebases e.g.
replacing function integer integer with ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
import java.util.function.function interface linearsearcher double minimize function double double f class goldensectionlinesearcher implements linearsearcher override double minimize function double double f double val getvalue return f.apply val class svmlightfactory linearsearcher minimizer new goldensectionlinesearcher public double heldoutc function double double sq x x x return minimizer .minimize sq a before type migrationimport java.util.function.doubleunaryoperator interface linearsearcher double minimize doubleunaryoperator f class goldensectionlinesearcher implements linearsearcher override double minimize doubleunaryoperator f double val getvalue return f.applyasdouble val class svmlightfactory linearsearcher minimizer new goldensectionlinesearcher public double heldoutc doubleunaryoperator sq x x x return minimizer .minimize sq b after type migration figure motivating example intunaryoperator o r bifunction u v boolean withbipredicate u v .
we were inspired by our previous work where we studied lambda expressions used in open source java projects and observed that of the generic functional interfaces could be replaced with their specialized alternatives.
using generic functional interfaces causes autoboxing and unboxing between primitive and object types e.g.
int and integer which severely degrades performance .
specializing functional interfaces effectively avoids the imposed overhead.
to evaluate our approach we run t2r on google s codebase with 300m lines of java code.
we also run t2r on seven performance critical open source projects.
they are the bestin class in domains such as databases code quality analysis and nlp and are highly optimized totaling .6m loc.
t2r generated patches in total of which compile and pass tests successfully.
the original developers accepted of these patches.
this paper makes the following contributions a framework for type migration in ultra large codebases which employs a three step process to collect analyze and transform types.
each step is amenable to m apreduce processing thus making the approach scalable.
a graph modelling the type structure of the program facilitating analysis for safe type migration.
an instantiation of the framework t2r which migrates the uses of generic java functional interface types to their specialized forms.
an evaluation of the technique on seven open source projects and google s java codebase which shows our refactoring is scalable safe and useful.
ii.
m otiv ating example we show the intricacies associated with type migration through a real world example.
figure shows a simplified view of a t2r generated patch that we sent to the open source project c orenlp .
the original patch comprises seven java files involving nine variables three subclasses and nine call sites which we do not show because of space constraints.function x y is a generic functional interface introduced in java which accepts a value of type xand returns a value of type y. suppose that the developer considers migrating the type function double double source to its specialized counterpart doubleunaryoperator target from java.util.function .
essentially these two are semantically identical.
the difference is that the single abstract method apply declared in function double double accepts and returns values of the boxed double type while doubleunaryoperator deals directly with primitive double s. unboxing is the automatic conversion by the java compiler between the object wrapper classes and their corresponding primitive types e.g.
double todouble .
consequently using doubleunaryoperator improves performance as it avoids unnecessary unboxing operations.
a recent study shows that developers often use the more expensive generic functional interfaces instead of the specialized alternatives.
this is perhaps due to the fact that there are specialized functional interfaces available in java and developers are not fully aware of their existence.
going back to the example of figure 1a the interface linearsearcher line declares the method minimize with a parameter of type function double double .
the class goldensectionlinesearcher implements linearsearcher line and thus its minimize method line .
the class svmlightfactory line invokes minimize on an instance of goldensectionlinesearcher line .
assume a developer starts refactoring the code by changing the parameter function double double f oflinearsearcher.minimize line to the target type doubleunaryoperator as shown in figure 1b.
to make the code compile the developer has to propagate this change to all the types which implement linearsearcher e.g.
the type of parameter f ingoldenlinesectionsearcher.minimize line .
the developer then has to migrate the type of the arguments ofminimize at all the callsites across the codebase.
note that minimize is invoked in svmlightfactory authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
line but also at other locations in the code not shown in figure .
to migrate the invocation in svmlightfactory the developer must change the type of sq line .
in java a functional interface can be instantiated using a lambda expression which is an anonymous function that can be created and used without belonging to any class.
the initializer ofsqis a lambda expression in which its parameter of type double is used for a multiplication.
the developer would also need to check for potential uses of the methods invoked on the parameter within the lambda expressions body if there existed any e.g.
x x.doublevalue .
figure 1b illustrates the migrated code.
note that to apply this refactoring manually the developer would need to perform an in depth analysis on the entire source code to find all the callsites and perform several nontrivial and time consuming tasks including checking the places wherein object