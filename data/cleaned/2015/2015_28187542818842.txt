empirical study towards a leading indicator for cost of formal software verification daniel matichuk toby murray june andronick ross jeffery gerwin klein mark staples nicta sydney australia email firstname.lastname nicta.com.au unsw sydney australia abstract formal verification can provide the highest degree of software assurance.
demand for it is growing but there are still few projects that have successfully applied it to sizeable real world systems.
this lack of experience makes it hard to predict the size effort and duration of verification projects.
in this paper we aim to better understand possible leading indicators of proof size.
we present an empirical analysis of proofs from the landmark formal verification of the sel4 microkernel and the two largest software verification proof developments in the archive of formal proofs.
together these comprise individual lemmas and approximately lines of proof script.
we find aconsistent quadratic relationship between the size of the formal statement of a property and the final size of its formal proof in the interactive theorem prover isabelle.
combined with our prior work which has indicated that there is a strong linear relationship between proof effort and proof size these results pave the way for effort estimation models to support the management of largescale formal verification projects.
i. i ntroduction recent software attacks on critical systems such as cars and pacemakers have helped to increase demand for formal software verification whereby the security safety or reliability of software is demonstrated using mathematical techniques.
desired properties are given as formal statements which are then shown to be satisfied using formal proofs.
formal verification is recognised as providing the strongest guarantees about software behaviour it is mandated for the highest assurance level of the common criteria standard and its importance for complementing software testing is recognised in the do 178c certification scheme for avionics .
some recent landmark formal verification projects include the certified compiler compcert and the microkernel sel4 .
these were multi year efforts producing hundreds of thousands of lines of machine checked proofs.
such projects use interactive theorem proving which requires human creativity and effort to guide the proof but is not constrained to simple properties or finite state spaces.
this allows for proofs of strong properties about low level software.
most of the effort in these projects is spent in writing machine checked proofs.
despite these successes few projects have yet tackled the challenge of verifying the implementation code source or binary of sizeable real world software.
because there is little experience with large scale formal verification it is difficult to predict its required effort duration and cost.
earlier work has showed the need for a better understanding of how to measure artefacts in formal methods to inform costs and estimation models.
an analysis of the existing literature revealed ashortage of empirical studies to provide industry with validated measures and models for the management and estimation of formal methods projects.
as stidolph and whitehead state experienced formal methodologists insist that cost and schedule estimation techniques are unsatisfactory and will remain so until a large body of experience becomes available .
in short more research is required in the field of proof engineering.
our ultimate goal is to provide estimation models for proof effort.
in prior work we analysed proof productivity and revealed a strong linear relationship between effort in person weeks and proof size in lines of proof script for projects and for individuals.
proof size however is only known when the project is completed.
so in this paper we examine the inputs to software verification projects formal statements of the properties to be proved about programs and formal specifications of the programs.
our goal is to identify measures of these formal statements that relate to the final size of their interactive proofs.
we present results of an empirical analysis of a large number of proofs written in the isabelle interactive theorem prover .
we measure the size of each lemma in terms of the total number of concepts needed to state it and compare that to the total number of lines used to prove it.
we analysed four large sub projects of the sel4 verification work as well as two proofs from the archive of formal proofs afp an open collection of isabelle proofs.
from these projects we analysed a total of lemma statements and associated proofs covering a total of more than lines of proof.
we find a consistent quadratic relationship between statement size and proof size with the r2for the quadratic regressions varying from .
to .
.
one of the four sel4 sub projects stands out with a lower r2and a significant collection of outliers with proof sizes much smaller than would be expected given the statement size.
investigation revealed that these outliers were caused by over specified lemma statements see section iii e with large constants mentioned unnecessarily effectively inflating their statement size.
to test this hypothesis we defined an idealised measure for statement size that is an approximation of its minimum size.
using this measure greatly strengthens the relationship between statement size and proof size across all the projects with r2 between .
and .
.
this implies that there is a very strong quadratic relationship between statement size and proof size when statements are not unnecessarily over specified.
this confirms an early hypothesis formulated by the leader of the sel4 verification project.
towards the end of the project ieee acm 37th ieee international conference on software engineering .
ieee icse florence italy he was required to provide an estimation and justification of time effort and cost needed to complete the project.
the experience from the proofs done by that time suggested that for microkernel refinement proofs proof size scales roughly quadratically with code size .
microkernel code is highly nonmodular by nature and so verification is dominated by proving invariants.
each invariant needs to be preserved by each feature which in turn relies on and modifies data structures used by other features.
our current work provides empirical evidence for this hypothesis by correlating proof size to statement size.
our main contribution in this paper is the identification of a concrete measure for the size of formal lemma statements that we show has a strong quadratic relationship with proof size.
a formal statement of program correctness must be known before beginning its verification.
thus its size can serve as a leading indicator of proof size.
proof size has in turn been shown to be strongly correlated to proof effort the measure presented here is therefore the first potentially useful leading indicator for estimating proof effort for interactive verification projects.
ii.
r elated work research to date on formal methods measurement has concentrated on the measurement of formal specifications of programs and also on the relationships between these measures and system implementations.
in olszewska and sere the authors report on their use of halstead s software science model for the measurement of event b specifications.
they used this framework to measure the size of a specification the difficulty of modelling it as well as the effort .
the specification metrics developed were seen as useful descriptors of the specifications studied when applied in the deploy project .
some research has also been carried out on other specification metrics.
in samson et al.
investigated metrics that might aid in cost prediction for software developed.
they use mccabe s cyclomatic complexity metric and lines of code to measure the implementation of a small system and measures of operators and equations to measure the hope formal specification.
although their sample size was small they found a relationship between their measures of the specification and implementation.
tabareh s masters thesis contained an investigation of relationships between specification and implementation measures.
a number of specification metrics were defined for z specifications.
these were size based metrics such as lines of code and conceptual complexity structure based metrics such as logical complexity and semantic based metrics such as slice based coupling cohesion and overlap.
in a more recent paper bollin evaluated the use of specification metrics of complexity and quality in a case study comprising more than lines of z specification text.
in king et al.
an investigation of z and the use of testing in a commercial software development project revealed that the z proof was the most efficient phase at finding faults followed by the system validation phase.
in summary previous research has investigated relationships between specification measures and implementation measures.
often this has been motivated by the desire to predict effort from implementation characteristics e.g.
size .
research has also investigated the types of measures that can be used for formal specifications.
however we have been unable to find any research investigating the relationship between specificationand proof measures particularly size of proof.
our work aims to fill this gap.
iii.
a pproach and measures a. formal verification background a software verification project aims to establish that a program satisfies some property.
a property might state that a program meets a high level specification or satisfies an invariant or enforces security mechanisms.
in an interactive theorem prover itp such a property must be given as an unambiguous mathematical statement s which may refer to the formalised program code and its formal specification.
to proves we provide a proof pwhich appeals to the inference rules of the logic of the itp and may also appeal to intermediate lemmas.
the set of all the definitions intermediate lemmas and final proof pofsform the proof development establishing that the program satisfies the property expressed in s.sis then referred to as the top level statement or property of the proof development.
this p known as a machine checked proof is the strongest known support for the assurance of s. ultimately we wish to estimate the effort required to prove pfor a given s. to this end we chose to investigate the relationship between the complexity of sand the size of p. we make the simplifying assumption that proof developments can be divided into three stages.
all definitions are written.
statements about definitions are hypothesised aslemmas.
each lemma is proved correct by writing an interactive proof.
in practice proofs never proceed quite this neatly.
the validity of this assumption will be discussed insection vii.
b. proofs and specifications a proof development in an itp is comprised of definitions lemma statements andproofs of those lemmas.
definitions are used to introduce new constants and give them semantics such as function specifications program invariants or data structures.
these definitions are given in the term language of the theorem prover which has a precise syntax and semantics.
lemma statements relate constants positing a fact that is then proved.
similar to definitions lemma statements are written in the term language.
term and proof languages vary significantly between theorem provers however they all share similar traits.
a term can express logical statements with connectives e.g.
conjunction implication and quantifiers e.g.
universal existential .
proof languages have syntax for appealing to automated reasoning tools and previously proven results.
a proof in this context is a sequence of appeals which eventually demonstrate that a lemma statement is true.
as a running example consider the following definitions of two new constants cande which mention some propositions a andbfrom a previous proof development.
they also depend on the exclusive or operator and the usual logical connectives.
c a b e b c the constants implicitly form a dependency graph.
a constantcdirectly depends on another constant c ifc appears in the definition of c. this represents an edge in the constant icse florence italydependency graph from node cto nodec .
in our example edirectly depends on b c and the connective.
we say thatcdepends on c ifc is reachable from cin the constant dependency graph.
in other words c must be defined at some point in order to define c. in our example edepends on all of a b c and the three connectives and .
similarly lemmas also implicitly form a dependency graph a lemma ldirectly depends on another lemma l ifl is used to justify some step in the proof of l. lemma lis then said to depend on l if at any point l had to be proved for the proof of lto hold.
in our example one can state the following lemmas to be proved where the operator is logical implication .
e a b e b a the truth of statement andstatement simply relies on the definitions of eandcand standard propositional logic.
their isabelle proofs might look like the following lemma eq1 e a b unfolding e def c def apply rule hol.
impi apply elim xore hol.disje hol.
conje apply subst asm hol.
de morgan disj apply subst asm hol.
not not apply rule hol.
disji1 apply elim hol.
conje apply assumption apply rule hol.
disji2 assumption done lemma eq2 e b a apply metis eq1 done it is not necessary to understand these proofs.
we observe however that the proof of the lemma eq1 refers only to facts from the hol proof development which defines the higher order logic of isabelle as well as the facts that capture the definitions of cande c def ande def respectively plus the factxore that in this example has already been proved in an existing proof development on which it builds.
c. proof size in our analysis we consider a given lemma and relate its statement size to its proof size.
formally we define the size of the proof of a lemma lto be proof size of lemma l the total number of source lines used to state and prove l excluding definitions.
note that this includes the proofs of all lemmas that l depends on.
we exclude definition declarations such as cdef because although they are part of the proof source we are interested in the total number of new source lines written to complete stages and of a proof development definition declarations are all written in stage .
we refine this notion of size slightly by only counting source lines from a particular proof development d. we call this the proof size of lwith respect to d defined as follows.proof size of lemma lwith respect to proof development d the total number of source lines required to state and prove l excluding definitions as well as lemmas and proofs outside of d. the reason that we contextualise proof size this way is because proof development is cumulative and new proofs often build on old ones.
for example a proof development d proving the correctness of dijkstra s algorithm would appeal to lemmas and definitions from an existing proof development g a formalisation of graph theory.
gwould provide a definition of a graph edges paths and would have lemmas proved about reachability.
when measuring the size of the proof of a lemma fromdin order to gauge its effort one would consider the lemmas in gto have come at zero cost and not take their size into account.
more precisely in general we measure the size of any proof of a lemma from a proof development dwith respect to d in order to exclude from its size any pre existing lemmas on which it depends.
in our example all the facts used in the proof of eq1 come from an pre existing proof development except c def andddefthat are the definitions of canddrespectively.
thus none of the direct dependencies of the proof of eq1 are counted when computing its size.
the size of the proof of statement therefore is just its immediate size i.e.
11lines while the proof of statement would be measured as its immediate size summed with the size of statement i.e.
lines .
d. raw statement size here we define a measure for the statement of lthat we found correlates well with the proof size of las defined above raw statement size for lemma l the total number of unique constants required to write the statement forl including all of its dependencies recursively.
unique specifies that each constant is counted at most once per statement.
this measure importantly is computable after stage in the proof development as it only requires definitions to have been written and does not depend on proofs.
we refer to this as a statement s raw size.
this is distinguished from the statement s idealised size introduced later.
similarly to proof size it often makes sense to measure statement size with respect to some proof development d. so excludes all constants that fall outside of d. however while we measure the size of a proof in proof development d with respect to ditself it often makes more sense to measure statements indwith respect to a larger proof development d that includes d. in the example of the previous section when measuring the size of statement we might choose to count the sizes of aandb even though these constants have been defined in a pre existing proof development and even though proofs about aandbin this pre existing development will not be counted in the size of the proof of statement .
the reason is that the effort of proving a new fact about a constant c here e.g.
a might be highly impacted by the size of ceven though it has been defined in a pre existing development.
in the context of the sel4 proofs we observed this effect to be extremely strong where most statements referring to sel4 s abstract specification would have proofs which follow the structure of the abstract specification and carry the complexity of reasoning about it.
icse florence italyin the example of the previous section assume we choose to measure the size of statement and statement with respect to the entire proof development down to the axioms of the logic i.e.
including the definitions of aandband all the operators.
assume that aandbare complex constants with sizes and respectively.
for simplicity we assume their dependencies are disjoint so cwould have a size of where we add 1forcitself the size of a the size of band then the size of and we assume for simplicity that they are defined axiomatically .
we can then calculate the size of eas1 by adding1foreitself 1for also assumed to be defined axiomatically and then the size of c. note that we do not add the size of b as it already has been considered when calculating the size of c and we are only counting unique constant dependencies.
then statement would have a size of where we count the size of eand the size of the other constants being already considered in the size ofe .
similarly statement would have a size of .
note that both proof size and statement size are inherently recursive the proof size of lincludes the size of its dependent lemmas and the statement size of lis based on its dependent definitions.
no attempt is made to measure the immediate size of any lemma as this is far too susceptible to fluctuations in individual proof style.
in our example statement has a small immediate proof size 3lines but would be given the same statement size as statement .
by considering each in terms of all of its dependencies we get a much more robust measure.
e. idealised statement size most lemmas make stronger assumptions than are actually necessary.
in particular a lemma might have a concrete term where an abstract one will suffice the statement 1is odd is less general than the statement 2n 1is odd which has an abstract term 2n in place of the concrete term .
it is the job of the proof engineer to decide the appropriate level of generality for a lemma based on its intended use.
in cases where a constant with a large definition is included unnecessarily we observe a large discrepancy between statement and proof size.
in our example consider the statement c c. suppose it was proved in one step by appealing directly to the law of excluded middle an axiom of hol in isabelle.
the raw size of this statement is .
this is an over estimation of the statement s complexity because the statement mentions cunnecessarily ccould be abstracted without affecting the proof.
so by replacing the constant cby a variable x would yield a statement with size of just for each logical connective a much better indication of its proof complexity.
in practice over specificity can save effort in provers like isabelle as it can aid automated reasoning by simplifying higher order unification a primitive procedure in isabelle.
additionally it is not often worth the effort to generalise a lemma that will only be used once.
as a result it is common to see many over specific lemmas in large proof developments.
to address this we introduce idealised statement size.
the idealised size for the statement of some lemma lis the size it would have been given had it been stated in its most general terms.
more precisely it is defined as follows.idealised statement size for lemma l the raw size of the statement of lhad it been abstracted over all possible constants such that l s proof remains valid.
note that we apply this recursively conceptually removing mentions of redundant constants in all dependant constants of l s statement.
the idealised statement size of lis always smaller or equal to the raw size of l as it may only remove unnecessary constants from measurement.
unfortunately computing this size is undecidable as it would require a precise analysis of why lis true.
we show how it can be approximated in section iv c .
iv.
m easures in isabelle the definitions given in the previous section abstracted away from any specific theorem prover.
here we explain how we compute these measures for isabelle.
a. measuring proof size the interactive proofs in isabelle we are interested in begin with the keyword lemma ortheorem followed by a statement in isabelle s term language.
this is the lemma statement as described in section iii c .
this is followed by an isabelle proof which consists of structural proof elements and invocations of automated tools known as proof methods.
once the statement has been shown true the proof ends with the keyword done or qed.
this statement is now a factand is usable in other proofs.
to measure proof size we distinguish what we call isabelle facts from isabelle lemmas.
a lemma is explicitly stated by the proof engineer and then explicitly proved in isabelle.
a factis more general it is a statement that has been proved by any means.
this includes lemmas but also all the statements automatically generated and internally proved by isabelle.
for example defining a recursive function frequires a proof of its termination.
in many cases this termination proof can be done automatically with no manual invocations of tools.
this fact is implicitly used in any lemma lthat reasons about f but it does not have a proof size that can be measured in such a way that would correspond to the effort required to prove it since it is automatic .
therefore when computing the size of the proof of a lemma l we will only count the proof sizes of used lemmas.
lemmas are the only facts whose proofs require substantial human effort therefore they are the only ones relevant to our overarching goal of effort estimation.
for a given lemma lin isabelle we say that the lines between the beginning and ending keywords inclusive constitute the proof ofl.
the immediate size of lis therefore simply its line count.
then we compute all the lemmas which lrecursively depends on and add their sizes to get l s total size.
here we only count unique lemmas if multiple dependencies of ldepend on some l we only count the size of l once.
we compute lemma dependencies by examining proof terms produced by isabelle where a proof term is the internal formal representation of a proof.
the total size of lwith respect to some proof development dconsiders all lemmas outside ofdto have size .
simply put for each proof development lemmas not from that development e.g.
pre existing library lemmas do not contribute to the measured size of proofs.
this measure approximates the proof size of las described insection iii c .
it is incomplete however as it does not include icse florence italysource lines which must exist for lto be valid but for which this dependency relationship is not easily found.
for example the proof of lmay depend on certain syntax existing declared with one line using the notation keyword.
this is not factored into the total size of l. the impact of this on the validity of the measured proof size is assumed to be minimal as the size of isabelle proof developments is dominated by proof text.
b. measuring raw statement size simple definitions can be added to isabelle using the definition command where an equation is given in isabelle s term language introducing a new constant name and body.
additionally there are commands for installing co inductive datatypes and both partial and complete recursive functions .
internally these create simple definitions based on the user specification proving canonical facts for interpreting them.
in our running example the definition of cintroduces the new namecwith body a b and a new fact c def for the statement c a b .
to measure the size of a given lemma statement sas described in section iii c we recursively inspect all definitions mentioned in s. the number of unique definitions traversed will be the size of saccording to this measure.
c. approximating idealised statement size insection iii e we introduced idealised statement size as a refinement of raw statement size.
although computing the idealised size of sis in general undecidable it can be approximated by examining the finished proof of s. intuitively if srefers to cbut the defining fact c def of the constant cdoes not appear in the dependency graph of the proof ofs this means that the truth of sdoes not depend on the definition of c and that scould be rewritten by replacing the constant cby a variable x. we therefore exclude the size ofcwhen computing the approximate idealised size of s. for instance the approximate idealised statement size of the statement c c proved by appealing directly to the law of excluded middle without using c def is .
more generally for each constant c we have a set of defining equations.
these are isabelle facts which are the canonical interpretation of c. in the case of simple definitions this is just the equation that was given when cwas defined such as c def .
to compute the idealised size of a statement s we exclude all the constants whose defining equations are never used in the proof ofs.
this will always be an over approximation of the idealised size of s but is at worst the original statement size.
this approximation of idealised statement size cannot be a leading predictor of proof size as it requires stage of the proof to be complete.
however it is useful when trying to build an explanatory model for understanding the relationship between statement size and proof size.
the implications of using this measure are discussed in section vi v. d ata collected we applied our exploratory analysis to six projects four top level statements of the sel4 verification work and two proof developments in the archive of formal proofs.a.
sel4 project proofs the sel4 verification project produced a formal machine checked proof of the full functional correctness of the sel4 microkernel down to the binary level followed by proofs of security properties about the kernel.
sel4 is a small operating system kernel designed with explicit goals of high performance formal verification and secure access control.
it is comprised of approximately lines of c code.
the proof of its functional correctness shows that the binary correctly refines its high level abstract specification.
this proof was done in stages with a proof that binary refines c that c refines a design representation and finally that this design representation refines the abstract specification.
this last stage called refine is our first target proof.
the binary verification is not suitable for this analysis because it is not done in isabelle .
the c to design verification is not suitable for technical reasons the translation from c source to a semantic representation in isabelle does not create a constant dependency graph like one would expect.
the refine proof builds on a proof called ainvs expressing global invariants satisfied by the abstract specification.
this is the second target of our study.
the proof of functional correctness was followed by a proof that sel4 enforces integrity called access and confidentiality called infoflow .
these are the two remaining targets of our study.
we present the main characteristics of these four proofs below taken from the public release of the sel4 proofs .
the statements measured for each proof development are all the dependencies of its toplevel statement computed with respect to that development.
the statement sizes for these proofs are computed with respect to the whole sel4 verification development where the large kernel specifications are defined.
ainvs this proof shows that a global invariant invsis preserved by every possible execution of the abstract specification.
the top level statement in this proof therefore depends on both the abstract specification and invs.
we measured lemmas from ainvs including the top level statement with a raw size of ideal size of and proof size of lines measured as described in section iv .
refine this is a refinement property showing that the design specification correctly refines the abstract specification.
its toplevel statement depends on these two specifications in addition a corresponding global invariant for each of them.
refine builds onainvs but we compute the proof sizes for refine with respect to itself.
that is proofs from ainvs do not contribute to the size of proofs from refine.
we measured lemmas from refine including the top level statement with a raw size of ideal size of and proof size of lines.
access this proof shows that sel4 preserves the integrity of components data according to a security policy p i.e.
it shows that sel4 prevents unauthorised writes.
its top level statement depends on the abstract specification the definition of integrity as well as invs.
similar to refine we only measure access proofs with respect to itself taking proofs from refine and ainvs for granted.
we measured lemmas from access including the top level statement with a raw size of ideal size of and proof size of lines.
infoflow this proof shows that sel4 preserves the confidentiality of components data i.e.
sel4 prevents unauthorised reads.
its top level statement depends on the abstract specification the icse florence italytable i. r2and equations for figure 1and figure proof name size used r2 equation f x a x2 b x c a b c ainvsraw .
.
.
.
idealised .
.
.
.
refineraw .
.
.
.
idealised .
.
.
.
e accessraw .
.
.
.
idealised .
.
.
.
infoflowraw .
.
.
.
e idealised .
.
.
.
jinjathreadsraw .
.
.
.
idealised .
.
.
satsolver verificationraw .
.
.
.
idealised .
.
.
.
definition of integrity and invs.
additionally it includes a more involved discussion of program execution traces.
as previously done proof sizes from infoflow are measured with respect to itself.
we measured lemmas from infoflow including the top level statement with a raw size of ideal size of and proof size of lines.
b. proofs from the afp the archive of formal proofs afp is a collection of proofs in the theorem prover isabelle aimed at fostering the development of formal proofs and providing a place for archiving proof developments to be referred to in publications.
the afp counts over entries.
we investigated the two largest software verification proofs from the afp jinjathreads andsatsolververification .
jinjathreads jinja is a java like programming language formalised in isabelle with a formal semantics designed to exhibit core features of the java language architecture and formal proof of properties such as type safety and compiler correctness.
jinjathreads extends this development with javastyle arrays and threads and shows preservation of the core properties.
we measured lemmas from jinjathreads including the top level statement with a raw size of ideal size of and proof size of lines.
satsolververification this is a proof of correctness of modern sat solvers.
we measure the proof with respect to the functionalimplementation theory an implementation of a sat solver within isabelle s hol.
we measured lemmas from satsolververification including the top level statement with a raw size of ideal size of and proof size of lines.
vi.
r esults and discussion for each of the six projects analysed we computed the statement size and proof size of all of its lemmas using the measures described in section iv.
as explained we used two variants for the statement size a raw measure and an idealised measure where the latter represents what the size of the statement would be if stated in its most general form.
the results of the analysis are given in figure for the raw measure and in figure for the idealised measure.
the analysis demonstrates a consistent quadratic relationship between statement size and proof size across all the projects with a stronger relationship when using the idealised measure.
the respective r2and equations of the regression lines are given in table i. we now discuss the results in detail.a.
results using the raw measure for the first three results the regression for the raw size fits the data nicely as we can see in the plots and confirmed by the r2results.
however even in access some outliers can be seen in the lower right corner of the graph.
in infoflow this effect is even stronger a cluster of points with a large statement size and a negligible proof size.
this has the effect of flattening the regression line and obfuscating the relationship.
after a thorough examination we determined that these are statements that have been over specified see section iii e resulting in a larger statement size than expected.
there likely exist many other over specified lemmas but they have a less apparent effect on the overall shape of the graph.
the lemmas identified in this case were pathological they mentioned the entire abstract specification but were stating a general property.
the abstract specification is one of the largest constants in this development so including it in a statement makes its size completely dominated by the size of the abstract specification.
all of the lemmas in ainvs are similarly overspecified but more subtly so.
indeed the presence of this overspecification was only made clear after performing the idealised size analysis.
this over specification is a result of abstract specification being extensible embedding an optional deterministic implementation of certain operations which can be used in place of non deterministic ones when necessary.
however no proof in ainvs appeals to this deterministic implementation.
this is simply because by design the standard invariants do not discuss the program state required to resolve this determinism.
as a result these deterministic operations unnecessarily inflate the statement size as measured in ainvs.
b. effectiveness of the idealised measure the idealised size introduced in section iii e is meant to capture the idea that redundant constants do not contribute to the difficulty of a proof.
analysis using the idealised size shown in figure andtable i show improved results across all projects.
in particular the infoflow results are now much more aligned and consistent with the others.
r2now varies from .
to .
.
we can also see from the graphs that all of the statement sizes shrunk reflecting the fact that the idealised size is always smaller or equal to the raw size.
we made no attempt to investigate the outliers in the proofs from the afp simply because we do not know their proofs well enough to perform the same level of analysis.
despite this applying the idealised size measure had significant improvement on the clarity of the data in jinjathreads with a lesser effect insatsolververification which was already quite clear.
previously we showed a linear relationship between the size of formal specifications as measured in source lines of isabelle and the number of lines of source code.
although not measured we argue that the specification size as described insection iii d will scale linearly with source lines.
combined with the result above this indicates a quadratic relationship between code size property size and eventual proof size.
this confirms our intuition based on our experience developing the sel4 proofs the correctness of each property depends on its interaction with the entire program resulting in the observed quadratic relationship.
despite this intuition and the apparent shape of the data we investigated other regressions in the icse florence italy 30000ainvs statement size vs. proof size statement sizeproof sizer2 .
70000refine statement size vs. proof size statement sizeproof sizer2 .
8000access statement size vs. proof size statement sizeproof sizer2 .
20000infoflow statement size vs. proof size statement sizeproof sizer2 .
40000jinjathreads statement size vs. proof size statement sizeproof sizer2 .
20000satsolververification statement size vs. proof size statement sizeproof sizer2 .
fig.
.
relation between raw statement size and proof size measured as described in section iv for the six projects analysed.
icse florence italy 30000ainvs idealised statement size vs. proof size idealised statement sizeproof sizer2 .
70000refine idealised statement size vs. proof size idealised statement sizeproof sizer2 .
8000access idealised statement size vs. proof size idealised statement sizeproof sizer2 .
20000infoflow idealised statement size vs. proof size idealised statement sizeproof sizer2 .
40000jinjathreads idealised statement size vs. proof size idealised statement sizeproof sizer2 .
20000satsolververification idealised statement size vs. proof size idealised statement sizeproof sizer2 .
fig.
.
relation between idealised statement size and proof size measured as described in section iv for the six projects analysed.
icse florence italycourse of this study.
specifically we performed linear cubic and exponential regressions against the measured proof size and ideal raw specification sizes.
linear and exponential regressions were less compelling than quadratic with extremely low r2 values and clearly not fitting the data.
a cubic regression yielded a marginal increase in r2 but with an extremely small leading coefficient indicating that the relationship is indeed quadratic.
overall our measures of statement size while primitive are a promising leading indicator of proof size with a quadratic correlation that is strengthened with the idealised measure.
c. limitations more work can still be done to refine the measures tune them to specific application areas and further analyse outliers.
in particular a set of outliers that can be seen on the graphs is the data points with very low proof size for large statement size visible for instance in the graph for infoflow infigure andfigure as the points that drag down the regression line.
these points are a result of proof reuse they correspond to statements proved largely by just using facts from access the size of these access facts is not counted since they come from a development already in existence when starting the infoflow proofs see section iii c .
this re use could be captured by better measures as discussed in section viii.
although the relationship between proof and statement is consistently quadratic across the proof developments we analyzed it is important to note that it is not yet necessarily predictive.
it is not clear how to take a model from one proof and use it to predict proof sizes in another.
the sel4 proofs all have quadratic coefficients within the same order of magnitude indicating some potential for an overall model for sel4 style proofs.
however the afp results are quite different the largest statements in jinjathreads andsatsolververification have raw sizes of and respectively which are both an order of magnitude smaller than any top level statement in sel4.
their proof sizes however are comparable to that of refine andainvs.
without an in depth analysis of these proofs it is difficult to confidently say what causes this discrepancy.
d. other measures the measure for statement size was chosen based on its simplicity and because it was clear how an idealisation could be applied in order to address over specified lemma statements.
in the course of this work we investigated many other measures which attempted to capture our intuition about what makes a statement difficult to prove.
for example we gave extra weight to recursive functions with even greater weighting for mutual recursion to capture the intuition that inductive proofs are inherently difficult.
in practice however none of these measures correlated better than the naive one.
there is still significant room for exploration in this area and in section viii we discuss measures which might yield a predictive model.
vii.
t hreats to validity our results show a strong internal consistency amongst the projects analysed whose validity is strengthened by two factors.
firstly the analysis of the data collected has been set up by one individual and re run refined and checked by another.
secondly the derivation of measures has been mechanised andfully automated using a custom tool proofcount .
given the size of the data set manual counting would have been impossible.
proofcount gives us the guarantee of determinism and ease of use on any formal proof in the same language.
however it is quite intricate and could still contain errors.
a threat to internal validity is the simplifying assumption made in section iii that proofs proceed in three neat phases definition writing lemma statement writing and proof writing.
in practice these phases tend to be iterated to varying degrees.
for instance during phase one often finds a lemma unprovable meaning that definitions and lemma statements written earlier need further refinement and existing proofs written may need to be updated.
the noise introduced by this iteration would need to be taken into account when building an estimation model based on the results from this paper and is inherent when using results obtained from finished proofs which have already undergone the iteration mentioned above .
any such predictive model will therefore require experimental validation on new proofs by running it at the beginning of phase and comparing its predictions to the actual results obtained at the end of the proof.
an additional threat to internal validity is the justification of our idealised measure for statement size as a refinement of raw statement size.
this measure is shown to have stronger relationship to proof size across all projects.
the threat comes from the fact that we use information from the proof to identify overly specific statements.
this makes the application of idealised size as a leading measure less straightforward.
in practice however when attempting to estimate the eventual size of the proof of a statement we would apply domain specific knowledge to manually identify which parts might be overspecified.
in most cases the worst causes of over specification are readily apparent but require human intuition to identify.
the idealised size as we computed is an automated substitute for the application of this intuition.
with some manual effort applying the expertise of the proof engineer to identify cases of over specification an approximation of idealised size can be made without requiring a finished proof.
this approximation could therefore be applicable as a leading measure.
threats to external validity include the ability to generalize the results to other verification projects other project settings e.g.
team size and other interactive theorem provers.
in order to address the first two threats we have applied our approach to three completely separate verification projects including two independent open source projects from the afp.
results show that our raw measure for statement size does not have high correlation to proof size for jinjathreads.
however our idealised measure does have a strong quadratic relationship in both afp proofs consistent with the results for the sel4 verification project.
application to additional projects from the afp could also provide further data points however we are most interested in projects with large top level statements as is seen in formal software verification.
the largest proof in the afp apart from jinjathreads only has a top level proof size which is comparable to the smallest proof development we examined.
the last threat that of having applied our approach to only one interactive theorem prover namely isabelle has been partially addressed by choosing measures whose general principles are prover agnostic e.g.
number of constants number icse florence italyof proof lines and that have equivalents in other popular theorem provers such as coq.
however a notable difference between coq and isabelle is coq s native support for easily writing tactics proof procedures .
in isabelle most proofs appeal solely to built in automation with only recent work aiming to make writing custom automation more accessible.
investigating the effect of using custom proof tools on the observed relationship is planned future work.
to summarise the generalisation to other settings is yet to be investigated but the approach has been designed to be generalisable and initial steps have been taken to validate it on different types of projects.
viii.
f uture work although we have only presented simple measures in this paper we have a large degree of freedom in this area.
previously we chose to measure proof size as lines of proof because it correlated well with effort but only at the granularity of entire proof developments.
a more in depth analysis could establish a relationship between some size measure and effort for individual lemmas.
for instance we might try to incorporate some semantic information from proofs to calculate their size.
the source text of a proof describes invocations to automated reasoning tools which eventually must appeal to primitive inference rules.
these appeals can be stored as a formal representation of the proof often called a proof term .
a naive size measure of a proof term is unlikely to be indicative of the effort required to create it.
for example a single invocation of a first order prover might produce a large proof term but would be a trivial exercise from the perspective of a proof engineer.
despite this we anticipate that it would be possible to incorporate more semantic proof information in proof size measurement.
grov et al.
suggest that high level proof strategies could be extracted from finished proofs using statistical relational learning .
this was realised as ml4pg an extension to proof general which gathers on line statistics during the development of coq proofs and uses machine learning to provide hints when writing subsequent proofs.
they extract proof features such as goal shape at intermediate proof points as well as which automated tools were applied.
a similar analysis could be done to more precisely measure effort for individual proofs and provide a more accurate measure of proof size.
it is difficult to pick a good single measure of statement size given their complexity.
in general we could compute a feature vector which captures more fine grained information from statements.
one feature could be statement size as measured in this paper.
other features could include domainspecific information such as the size of function and invariant statements separately or the cyclomatic complexity of the programs.
we could also attempt to capture information from previously finished proof developments that we build on.
for example as a feature of a statement we might compute some measure of its similarity to statements of existing lemmas.
this would allow us to anticipate the degree of proof re use as mentioned in section vi c that would potentially appear in its proof.
the set of features chosen would dictate the class of proofs for which such an analysis is meaningful e.g.
program verification .
we hypothesise that well chosen feature vectorswould be robust against the fluctuations in statement design style that we see e.g.
between sel4 and jinjathreads.
although our analysis did not result in a universal predictive model for eventual proof size it does indicate the potential for iteratively building a project specific model due to the strong correlation within a given proof development.
the model could be updated as proofs are completed and the precise relationship between proof and specification size is better understood.
ix.
c onclusion in this paper we investigated the relationship between the size of formal statements and corresponding formal proofs in an interactive theorem prover.
our increasing trust on critical software systems has created a demand for software which is trustworthy.
formal software verification is the application of formal proof to guarantee the correctness of software behaviour.
however the cost of formal verification is not well understood due to the relatively low number of successful large scale applications.
the ability to accurately predict this cost is crucial to the wide spread application of formal methods.
in earlier work we established a linear relationship between proof size and proof effort.
expanding on this we sought leading indicators of proof size and thus turned to statement size.
we have established two measures for statement size raw and idealised and use them in an analysis of six isabelle proof developments.
raw size is the number of unique constants required to write a statement recursively including all dependencies.
this measure was shown to be highly susceptible to over specified statements having inflated sizes.
this prompted the introduction of idealised size a refinement of raw size which removes redundant constants in order to reduce the impact of over specified statements.
in total we examined the size of statements and compared them against their proof size.
our analysis shows a quadratic relationship between statement and proof size and that our idealised measure strengthens this correlation.
however the investigation did not yield a predictive model as the precise relationship changes between proofs.
combined with previous work we believe this is an important step in establishing a leading indicator for the effort and cost required to perform formal verification.
acknowledgment the authors would like to thank ihor kuz gernot heiser and thomas sewell for their feedback on drafts of this paper.
nicta is funded by the australian government through the department of communications and the australian research council through the ict centre of excellence program.
icse florence italyreferences s. checkoway d. mccoy b. kantor d. anderson h. shacham s. savage k. koscher a. czeskis f. roesner and t. kohno comprehensive experimental analyses of automotive attack surfaces in proceedings of the 20th usenix security symposium .
d. halperin s. s. clark k. fu t. s. heydt benjamin b. defend t. kohno b. ransford w. morgan and w. h. maisel pacemakers and implantable cardiac defibrillators software radio attacks and zeropower defenses in proceedings of the ieee symposium on security and privacy oakland ca usa may pp.
.
k. fisher hacms high assurance cyber military systems in proceedings of the acm conference on high integrity language technology ser.
hilt .
boston massachusetts usa acm pp.
.
common criteria for information technology security evaluation version .
revision .
.
available special committee of rtca do 178c software considerations in airborne systems and equipment certification .
x. leroy formal verification of a realistic compiler communications of the acm vol.
no.
pp.
.
g. klein j. andronick k. elphinstone t. murray t. sewell r. kolanski and g. heiser comprehensive formal verification of an os microkernel acm transactions on computer systems vol.
no.
pp.
feb. .
m. staples r. kolanski g. klein c. lewis j. andronick t. murray r. jeffery and l. bass formal specifications better than function points for code sizing in international conference on software engineering david notkin betty h. c. cheng klaus pohl ed.
san francisco usa ieee may conference paper pp.
.
r. jeffery m. staples j. andronick g. klein and t. murray an empirical research agenda or understanding formal methods productivity information and software technology to appear.
d. c. stidolph and j. whitehead managerial issues for the consideration and use of formal methods in in stefania gnesi keijiro araki and dino mandrioli eds.
fme international symposium of formal methods europe pp.
.
m. staples r. jeffery j. andronick t. murray g. klein and r. kolanski productivity for proof engineering in empirical software engineering and measurement turin italy sep. conference paper.
t. nipkow l. paulson and m. wenzel isabelle hol a proof assistant for higher order logic ser.
lecture notes in computer science.
springer vol.
.
g. klein t. nipkow and l. paulson the archive of formal proofs .
m. olszewska plska and k. sere specification metrics for event b developments in proceedings of the conquest software quality improvement i. schieferdecker r. seidl and s. goericke eds.
international software quality institute p. .
m. h. halstead elements of software science operating and programming systems series .
new york ny usa elsevier science inc. .
deploy industrial deployment of system engineering methods providing high dependability and productivity.
.
available w. b. samson d. g. nevill and p. i. dugard predictive software metrics based on a formal specification inf.
softw.
technol.
vol.
no.
pp.
jun.
.
t. mccabe a complexity measure software engineering ieee transactions on vol.
se no.
pp.
dec .
a. tabareh predictive software measures based on formal z specifications master s thesis university of gothenburg department of computer science and engineering .
a. bollin metrics for quantifying evolutionary changes in z specifications journal of software evolution and process vol.
no.
pp.
.
s. king j. hammond r. chapman and a. pryor is proof more cost effective than testing?
ieee trans.
softw.
eng.
vol.
no.
pp.
aug. .
s. berghofer and t. nipkow proof terms for simply typed higher order logic in theorem proving in higher order logics ser.
lecture notes in computer science m. aagaard and j. harrison eds.
springer berlin heidelberg vol.
pp.
.
s. berghofer and m. wenzel inductive datatypes in hol lessons learned in formal logic engineering in proceedings of the 12th international conference on theorem proving in higher order logics ser.
tphols .
london uk uk springer verlag pp.
.
t. sewell m. myreen and g. klein translation validation for a verified os kernel in acm sigplan conference on programming language design and implementation.
seattle washington usa acm jun.
conference paper pp.
.
t. sewell s. winwood p. gammie t. murray j. andronick and g. klein sel4 enforces integrity in proceedings of the 2nd international conference on interactive theorem proving ser.
lecture notes in computer science m. c. j. d. van eekelen h. geuvers j. schmaltz and f. wiedijk eds.
vol.
.
nijmegen the netherlands springer aug. pp.
.
t. murray d. matichuk m. brassil p. gammie t. bourke s. seefried c. lewis x. gao and g. klein sel4 from general purpose to a proof of information flow enforcement in ieee symposium on security and privacy san francisco ca may conference paper pp.
.
trustworthy systems team sel4 proofs for api .
release aug .
a. lochbihler jinja with threads archive of formal proofs dec. formal proof development.
f. maric formal verification of modern sat solvers archive of formal proofs jul.
formal proof development.
d. matichuk and t. murray extensible specifications for automatic re use of specifications and proofs in 10th international conference on software engineering and formal methods thessaloniki greece dec. conference paper p. .
d. delahaye a tactic language for the system coq in international conference on logic for programming artificial intelligence and reasoning ser.
lecture notes in computer science vol.
.
springer nov. .
d. matichuk m. wenzel and t. murray an isabelle proof method language in interactive theorem proving itp vienna austria jul.
conference paper p. .
y .
bertot and p. cast eran interactive theorem proving and program development.
coq art the calculus of inductive constructions ser.
texts in theoretical computer science.
an eatcs series.
springer .
g. grov e. komendantskaya and a. bundy a statistical relational learning challenge extracting proof strategies from exemplar proofs inicml12 workshop on statistical relational learning srl .
e. komendantskaya j. heras and g. grov machine learning in proof general interfacing interfaces in proceedings 10th international workshop on user interfaces for theorem provers uitp bremen germany july 11th .
pp.
.
d. aspinall proof general a generic tool for proof development in tools and algorithms for the construction and analysis of systems.
springer pp.
.
icse florence italy