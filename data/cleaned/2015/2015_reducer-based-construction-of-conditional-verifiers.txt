reducer based construction of conditional verifiers dirk beyer lmu munich germanymarie christine jakobs lmu munich germany thomas lemberger lmu munich germanyheike wehrheim paderborn university germany abstract despiterecentadvances softwareverificationremainschallenging.
tosolvehardverificationtasks weneedtoleveragenotjustone but several different verifiers employing different technologies.
to this end we need to exchange information between verifiers.
conditional model checking was proposed as a solution to exactly thisproblem theidea isto letthe firstverifieroutput a condition whichdescribesthestatespacethatitsuccessfullyverifiedandto instruct the second verifier to verify the yet unverified state space using this condition.
however most verifiers do not understand conditions as input.
in this paper we propose the usage of an off the shelf construction of aconditional verifier from a given traditional verifier and a reducer.
the reducer takes as input the program to be verified and thecondition andoutputsaresidualprogramwhosepathscover the unverified state space described by the condition.
as a proof ofconcept wedesignedandimplementedoneparticularreducer and composed three conditional model checkers from the three best verifiers at sv comp .
we defined a set of claims and experimentally evaluated their validity.
all experimental data and results are available for replication.
ccs concepts software and its engineering formal methods formal software verification keywords conditionalmodelchecking formalverification testing program analysis software verification sequential combination acm reference format dirk beyer marie christine jakobs thomas lemberger and heike wehrheim.
.reducer basedconstructionofconditionalverifiers.in proceedings of the 40th international conference on software engineering icse .
acm new york ny usa 12pages.
.
thisauthorwaspartiallysupportedbythegermanresearchfoundation dfg within the collaborative research centre on the fly computing sfb .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
introduction software model checking has received lots of attention in academia and industry in the past two decades yet there are many programs that are in principle verifiable but no existing verifier can solve them automatically.
there are many different approaches but none is superior.
the competition on software verification sv comp givesayearlyoverviewoverthestateof theart intermsofbothstrengthsofverifiersonvariouscategories and weaknesses as shown by a large amount of unsolved problems.
one promising idea is to combine the strengths of different verifiers by condition passing which was formalized as conditional model checking cmc six years ago.
the idea is simple and effective the first verifier reports what it had successfully verified andsummarizesitsworkdoneasa condition.thenextverifierreads theconditionandverifiesonlythepartofthestatespacenotyet coveredbythecondition.thistechniquewasshowntobeeffective and sometimes even more efficient.
unfortunately it is difficultto write a verifier that can parse the complicated conditions and effectively reduce the state space of the verifier.
this complication isresponsibleforthesituationthatthetechniqueisnotaswidely applied as it could be only a few conditional model checkers exist.
to solve this problem we developed an automatic construction templatethatcanbeusedtoconstructaconditionalverifierfrom a given arbitrary classical verifier.
the original work proposedto run a product analysis that guides the state space explorationsuch that it concentrates on the state space not covered by the condition.weproposeanalternativesolution inspiredbyearlier work on conditional modelchecking and testing wedefine a programreducer whichtakesasinputaprogramandacondition andcomputesaprogramwhoseexecutionsarerestrictedtothose not yet covered by the given condition.
having developed this component once it is easyto construct anew conditional verifier using the equation cmc v r whereris the reducer vis an arbitraryverifier and isthesequentialapplicationoffirst rtoa given program and then vto the output program of r. the new verifiercmcis a conditional verifier that takes as input a program andacondition.figure 1illustratesthiscompositionvisually.there can be different implementations of reducers and the reducers mightleverageanotionofabstraction causingtheresidualprogram to be more compact but less precise.
we implemented a reducer thatisbasedonaproductconstruction i.e.
programandcondition reducer verifierprogram conditional verifierprogram conditionresult figure construction of a conditional verifier acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden d. beyer m. c. jakobs t. lemberger and h. wehrheim int val nondet int if val int out val val else int out val assert out a source codeq0 q1 qf q2 q3 q4 int val nondet int val val int out val val assert out b condition1 int val nondet int if val int out val val assert out else c residual program figure2 example a fragmentofacpr ogram b conditiongeneratedby cpachecker withacceptingstatesasdoublecircles assumptions elided all true label subsuming all control flow edges and c residual program constructed by reducer are converted into automata and the reduced product automaton is converted back to a program.
inourstudy weshowthattheconstructionworksandiseffective.
we do not claim that our implementation of the reducer is the best possible butweshowforanumberofverifiershowtoincreasethe number of obtained results with the reducer based construction of conditional verifiers.
the approach can in some cases even reduce the resource consumption.contributions.
we make the following contributions weprovideareducerthatunderstandsmoreextensiveconditions than a reducer that was previously used in the context of conditional model checking and testing .
weconstructanumberofconditionalverifiersfromexisting verifiers in order to experimentally show that new combinationswithconditionpassingcansignificantlyincreasethe number of verified programs.
we apply the concept also to test case generation and show that the construction effectively works.
ourreducerandallexperimentaldataareavailableforotherresearchersandpractitionersforreplicationortostrengthen their own verification infrastructure by using newly constructed conditional verifiers that were not available before.
condition based reducers theobjectiveofourworkistheconstructionofconditionalverifiers.conditionalverifiersareverificationtoolsacceptingprograms together with conditions as input.
a conditional verifier shouldcheck the parts of the program not covered by the condition.
to this end we employ reducersconstructing residual programs from conditions.westartwithgivingaformalaccountofconditionsand reducers.
in our notation we follow previous work .
.
foundations programs are represented by control flow automata1 cfas c l lscript0 g that consist of a set of locations l an initial location lscript0 andasetofcontrol flowedges g l ops l whereopsistheset 1cfas are a variant of control flow graphs with operations attached to the edges.ofoperations.intuitively aprogramanditscfaaresemantically equivalent because the cfa contains exactly the operations ofthe program on its control flow edges and in exactly the sameorder.ourconstructionofreducersreliesonsoundlyconverting programs to cfas andback within tools.
we let cbe the set ofall cfas.inourpresentation weconsideroperationsfromasimple programming language with assume operations and assignments on integer variables.
our implementation covers c programs.
we letxbe the set of variables occurring in the operations ops.
a concrete data state cis thus a mapping of xtoz.a concrete program path of a cfa c l lscript0 g is a sequence c0 lscript0 1 ... n cn lscriptn such that c0assigns to all variables i lscripti opi lscripti g andci opi ci i.e.
a in case of assumeoperations ci opi opiistheassumption and ci ci and b in case of assignments ci spopi ci where spis the strongest post operatorof theoperational semantics.froma concreteprogrampath c0 lscript0 1 ... n cn lscriptn wecanderive anexecution ex c0c1...cn.w eletpath c bethesetofallconcrete program paths and ex c be the set of executions of a cfa c. acf acisdeterministic andhencerepresentableasacpr ogram if the following holds for all lscript l lscript op1 lscript1 lscript op2 lscript2 g either op1 op2and lscript1 lscript2 o rop1is an assume operation and op1 op2 is unsatisfiable.
conditionssubsumetheresultsofverificationrunsonprograms.
a condition basically states which paths have been explored.
in addition aconditionmightinvolve assumptions underwhichthe verifier has explored a certain path.
assumptions are given as state conditions from a set .
we write c to say that a concrete statecsatisfies a state condition .
definition .
.
acondition automaton ca short condition a q q0 f consists of a finite set qofstatesand an initial state q0 q analphabet 2g atransition relation q q and a setf qofaccepting states and satisfies the following well formedness condition qf q withqf f q nelementf.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
reducer based construction of conditional verifiers icse may june gothenburg sweden we let abe the set of condition automata.
accepting states in conditions are used to describe paths of the cfa which have already been successfully verified.
figure 2shows an example c programandaconditionautomatonasgeneratedby cpachecker .
theconditionshowsthattheverifierexploredtheelse branchof theif statement pathleadingtoacceptingstate qf andsuccessfully verified the assertion to hold on that path.
due to the non linear arithmetic the verifier could not handle the then branch which hence appears in the automaton on a path not entering qf.
definition .
.
a condition automaton a q q0 f covers apath c0 lscript0 1 c1 lscript1 2 ... n cn lscriptn ifthereisarun q0 g1 1 q1 g2 2 ... gk k qk k n i na s.t.
qk f i i k i gi and i i k ci i. thetaskofareducerisnowthegenerationofanewprogram that contains the paths of the original program except for at most those already covered by the condition.
definition2.
.
areducerisamapping red c a csatisfying the following residual condition res.
c c a a ex c ex acovers ex red c a ex c .
inthefollowing werefertotheoutputofareducerasthe residual program.
note that the identity relation on cfas i.e.
red c a c is a reducer though not a very effective one.
note also that contrary to czech et al.
the residual condition resis not specifictosafetyproperties i.e.
unreachabilityoferrorlocations.
it simply states a coverage property for the residual program.
our definitions allow us to use conditions and reducers as a meansfor various combinations of verifiers.
as one example both thecondition generating verifier aas well the condition processing verifierbcould be tools generating test vectors and together they managetoachievecompletecodecoverage.tools aandbcould ontheotherhand alsobothbeformalsoftwareverifiersproving validityofassertions andtogethertheyprovesafetyoftheprogram.
.
implementation a reducer takes as input a program in the form of a cfa together with a conditionautomaton and returns a residualprogram.
note that the definition of reducers gives us some freedom in constructingresidualprograms inparticular thereismorethanoneresidual program possible.
here we will present one such reducer.
ourreducerbuildsupontheideaofczechetal.
.itconstructs theresidualprogrambymeansofaparallelcompositionoforiginal programandcondition cuttingoffpathswheneverthecondition hasreachedanacceptingstate.theconstructioncalledreducer is given in alg.
.
in contrast to czech et al.
alg.1employs an additional residual state qrto subsume states that the condition automaton either has not investigated or has investigated but under a non true assumption.
note that czech et al.
do not need qrbecause they consider a restricted class of conditions which e.g.
only considers trueassumptions.
depending on the condition the reduction might restructure the program as to isolate paths which need to be cut off.
in our example the generatedalgorithm reducer input cfac l lscript0 g original program caa q q0 f s.t.qr nelementq condition automaton output cfacr lr lscript0 r gr residual program lr lscript0 q0 lscript0 r lscript0 q0 gr waitlist lr whilewaitlist nequal do choose lscript1 q1 waitlist remove lscript1 q1 from waitlist for each lscript1 op lscript2 gdo ifq1 q q1 g1 true q2 s.t.
g1then for each q1 g1 true q2 s.t.
g1do ifq2 nelementf lscript2 q2 nelementlrthen waitlist waitlist lscript2 q2 lr lr lscript2 q2 gr gr braceleftbig parenleftbig lscript1 q1 op lscript2 q2 parenrightbig bracerightbig else if lscript2 qr nelementlrthen waitlist waitlist lscript2 qr lr lr lscript2 qr gr gr braceleftbig parenleftbig lscript1 q1 op lscript2 qr parenrightbig bracerightbig returncr condition describes that paths taking the else branch have been successfully verified while paths taking the then branch still need to be explored.
hence the reducer generates a residual program wheretheassertionismovedinsidethethen branchsoastoensure that the assertion need not be checked again for the else branch.
theorem .
.
algorithm reducer is a reducer.
proof.assumec a cras used in alg.
.
we have to show ex c ex acovers ex cr ex c .
we separately look at the two set inclusions ex cr ex c letc0...cn ex cr .
then there exists a path c0 lscript0 q0 1 ... n cn lscriptn qn path cr such that i lscripti qi opi lscripti qi andci opi ci.
from this we inductively construct a path primeofc and hence the execution of c induction start take prime c0 lscript0 .
induction step assume path primeto be constructed up to some cj lscriptj j n. we know that j lscriptj qj opj lscriptj qj gr as isapathof cr .newelementsareinsertedinto grin lines and of the algorithm only while iterating over elementsof g line5 .hence lscriptj opj lscriptj g andwe can extend primeby cj lscriptj lscriptj opj lscriptj cj lscriptj .
ex c ex acovers ex cr letc0...cn ex c ex acovers .
then there is a path c0 lscript0 1 ... n cn lscriptn ofcthatisnotcoveredby a.notethatthus q0 nelementf as otherwise all paths are covered.
we inductively constructapath prime c0 lscript0 q0 prime ... prime n cn lscriptn qn ofcrwith prime i lscripti qi opi lscripti qi together with a run q0 g1 1 ... gm m qmofas.t.
m n. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden d. beyer m. c. jakobs t. lemberger and h. wehrheim they satisfy the following properties a i i n qi nelement f b i i n lscripti qi is an element of waitlist at some point in time during the algorithm and c at position mthepath is splitintotwoparts thesecondofwhich may beempty suchthat i i m qi nequalqr i i true i gi and ii j m qj qr.
inductionstart take prime c0 lscript0 q0 and q0.then q0 nelementf q0 nequalqr and lscript0 q0 is initially in waitlist.
induction step assume path primeto be constructed up to some cj lscriptj qj j n and up to some ql l m. we know that j lscriptj opj lscriptj gandcj opj cj as is path of c .
we have two cases to consider qj nequalqr hence qj qand by induction hypothesis qj nelementf qj ql j l. again two cases a qj gj true qj j gj line6 we extend primeby cj lscriptj qj j cj lscriptj qj and by qj gj true qj .
we have qj nelementf asthepath isnotcoveredby aand wouldwitness coverage otherwise.
hence lscriptj qj is added to waitlist unlessithasbeenintherebefore .westay in the first part of the path.
b else line we switch to the second part of the path.
we extend the path primeby cj lscriptj qj j cj lscriptj qr and let remain unchanged.
we haveqr nelementf as it is an extra state and lscriptj qr is added to waitlist unless it has been in there before .
qj qr then weareinthesecondpartofthepathand proceed as in case b .
square to be usable by the condition processing verifier the residual cfahastobetransformedbackintoacprogram.theresidualcfa obtained by reducer from a deterministic cfa i.e.
a c program isagaindeterministicsincetheconditiongeneratedby cpachecker is always deterministic.
moreover note that we currently inline procedure calls.
thus reducer may fail on recursive programs.
reducer based verifiers in the previous section we introduced two reducers identity and reducer.
next we introduce the second component of our conditional verifiers the off the shelf tools that we transform into conditional verifiers.
in this paper we transform four verifiers and three test generation tools.
as verifiers we use the best three tools cpaseq smack andultimate automizer from sv comp table1givesanoverview .additionally weusethevalueanalysis from the cpachecker framework which supports condition automataasinputconditions anin toolcmcsolution and allows us to compare the concept of reducer based conditional verifiers against an in tool solution.
as test generation tools we choseafl fuzz crest ppc andklee.
all three are open source and havelatelyattractedhighinterestbyresearch .inthenextparagraphs weexplainthetechnologiesunderlying the selected verifiers and test generation tools.
valueanalysis.
cpachecker svalueanalysisisaconfigurableprogram analysis .
its reachability analysis tracks the values of certainvariablesofinterestexplicitlywhileassumingthattheremaining variables may have any possible value.
the precision isincreasediteratively basedoncounterexample guidedabstraction refinement cegar and lazy refinement .
to get the best refinement the analysis applies refinement selection .
given an infeasible error path path prefix slicing is used to compute different overapproximations of the error path s.t.
each overapproximation replaces some assume operations with no ops.
for each overapproximation interpolation is used to compute arefinementcandidate.intheend thebestrefinementisselected.
cpaseq.cpasequsesthe cpachecker framework torunfour differentanalysesinsequence.wheneverananalysisgivesup due to timeout or unknown result the next analysis starts.
a definite answer feasible error path or proof of an analysis is returnedimmediately.
cpaseqstarts with a simple value analysis without refinement whichtracksallvariablevaluesimmediately.next a value analysis similar to the one described above is used.
the third analysis is a bit precise predicate analysis that uses adjustableblock encoding to compute predicate abstractions only at loop heads.thesetofpredicatesisdeterminedbyacombinationofinterpolation and cegar with lazyrefinement .
the last analysis runs k induction in parallel with invariant generation .
the invariants found so far are used to improve the k induction step and are provided by numerical and predicate analyses.
smack.thesmack verifierconsistsofatranslationfrontend andaverificationbackend.first ittranslatestheinputprogram to boogie code via intermediate llvm code .
based on heuristics the boogie code is either verified with boogie or corral.
boogie proves a verification condition generated with the weakest precondition calculus.
corral tries to find a property violation with a two stagedcegar approach.first itusesvariable abstractionto compute an overapproximation of the program which only considers a subset of the program variables.
the variable abstraction is adapted whenever the second cegar approach fails to rule out an infeasible error path.
on the second stage corral inlines functions summaries uptoagivenrecursiondepth loopsareassumedto be written as recursive functions .
functions are only inlined if the function summary appears in an infeasible error path.
ultimate automizer .ultimate automizer uautomizer usesanautomata basedverificationapproach.inprinciple itmain tainsanoverapproximationoferrorpathsinformofanautomaton.
a cegar approach successively refines the overapproximation i.e.
itremovesinfeasibleerrorpaths untilafeasibleerrorpathis foundortheautomatonlanguageisempty.ineachrefinementstep a generalization of an infeasible error path is excluded from thecurrent overapproximation.
the generalization of the error pathis described by a floyd hoare automaton which associates booleanformulasoverpredicateswithitsstates.theinitialstate is associated with true accepting states are associated with false and transitions describe valid hoare triples.
the predicates used in thehoaretriplesareobtainedviainterpolationalongtheinfeasible error path.
afl fuzz .afl fuzz is arandom fuzzingtester.
givena setof start inputs itperformsdifferentmutationsontheexistinginputs executesthesenewlycreatedinputs andcheckswhethernewprogram parts areexplored.
ifthis isthe case the inputsare keptand used for further mutation.
otherwise the inputs are discarded.
2afl american fuzzy lop is available at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
reducer based construction of conditional verifiers icse may june gothenburg sweden table overview of applied verification technologies in the verifiers refinement verifier technique cegar lazy abstraction interpolation bitprecise cpaseq arg explicit and numerical values predicates k induction check check check check smack property driven reachability bounded model checking check check check uautomizer automata predicates check check check check klee.klee usessymbolicexecutionfortest casegeneration.
symbolic execution is an extension to concrete execution of a program.foreveryunknowninputvaluetoaprogram anewsymbolic valueisintroducedthatinitiallyrepresentsanypossiblevalue.during execution the symbolic values are constrained by branching conditions along the program e.g.
if branches in a c program .
theseconstraintsareusedtocomputewhetheragivenprogram path is feasible and which class of input values will lead to executionsthattakethispath.wheneverbothbranchesarefeasiblein asymbolicexecution kleecopiesitscurrentsymbolicexecution stateandcontinuestoexploreonebranchwiththecurrentstateand the other with the copied state.
after each step in a program klee heuristicallychooseswithwhichoftheexistingexecutionstatesto continue.
given several heuristics klee alternates between them.
crest ppc .crest ppc is an improved version of crest .
crestuses concolic execution for testing and provides different heuristicstoachievehighercodecoverage.concolicexecutionis a combination of symbolic execution and concrete execution.
a programundertestisexecutedwithconcreteinputsthatdetermine one concrete execution path.
in parallel a symbolic execution is performed on that path to obtain constraints over program inputs on this path.
based on these path constraints a constraint solver computes new inputs that lead to the execution of another yetunvisited program part.
new executions are performed and newinputs are generated until all program parts are explored.
crest uses heuristics to choose which unvisited program part to explore next.
to increase the performance crest ppc adds a heuristic to crestthatsubmitsmorecallstotheconstraintsolverbutusesfewer constraints per call.
evaluation .
claims to be evaluated in the following we list our claims and how we plan to evaluate them.theclaimsarenotonefficiency butoneffectiveness.that is we provide means for solving additional verification tasks by investing more computing resources but without implementing or changing verification tools.
feasibilityhypothesis.
a reducer can be used to effectively construct conditional verifiers from existing verification tools.
evaluationplan weshowthisbyimplementingoneparticularinstanceof a reducer and apply our reducer based construction of conditional verifierstothreemodelcheckersandthreetesters.theresultisa setofsixconditionalverifiers andwetakestandardconfigurations out of the box without changing a single line of the verifiers.
null hypothesis.
applying a reducer has no effect.
evaluation plan we compare the results using our reducer against the results using the identity function as replacement for the reducer.claim1.
reducer basedconditionalverificationisnotmuchworse then native conditionalverification.
evaluationplan theoriginalproposal of cmc implements the restriction of the state space that the condition describes internally in the exploration engine oftheverifier.weclaimthatitalsoworksreasonablywelltouse an external reducer instead which opens the door for constructing new conditional verifiers without actual implementation work.claim2.
thetechniqueof conditionalverificationcaneffectively increasethenumberofoverallsolvedverificationtasksifadditionalresourcesareprovided.
evaluationplan weselectanumberofhardto solve verification tasks and perform experiments on them using the original verifiers and the constructed verifiers.
claim3.
conditionalverificationwithconditionpassingcansolve verification tasks that neither cpaseq smack norultimate automizercan solve.
evaluation plan we select from a given set of verification tasks those verification tasksthat none of the original verifiers but at least one of the conditional verifiers can solve.
claim .
the use of different conditional verifiers improves the overalleffectiveness.
evaluationplan wereportresultsfordifferent conditionalverifiersandconsiderverificationtasksthatonlyone conditional combination can solve.
claim .
reducer based conditional verification is also applicable to test case generation.
evaluation plan we construct conditional verifiers from three test generation tools and compare the number of generated crashing tests against the result of the test generation tools alone.
.
setup computing resources.
we performed our experiments on machines with an intel xeon e3 v5 cpu with processing units each afrequencyof3.4ghz 33gbofmemory andanubuntu16.
operatingsystemwithlinuxkernel4.
.welimitedeachanalysis runto15gbofmemoryandavaryingtimelimit dependingonthe experiment and allowed it to use all processing units.
we report cpu time and memory use with two significant digits.
verificationtasks.
togetarepresentativesetofverificationtasks we used all 5687programs from reachsafety categories of the svcompbenchmarkset3inrevisioncc496684.forallinputprograms we verify the property that function verifier error is never called.atotalof 1501ofthe5687programsareunsafe i.e.
thecall to verifier error is reachable and programs are safe.
tools.weusedapredicateanalysisforconditiongenerationand a value analysis for comparison with native conditional model checking both fromthe cpachecker project.
our implementation of a reducer is also available in the cpachecker project.
for all experiments we used cpachecker from branch reducer patch in revision r25656.
for the verifiers in the composition of our reducer with a verifier we use the three best tools from sv comp assubmittedtothecompetition5 withoutanymodifications and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden d. beyer m. c. jakobs t. lemberger and h. wehrheim 1000cpu time for identity s cpu time for reducer s a reducer vs.identity pure sequential combination 1000cpu time for native cmc s cpu time for reducer s b reducer vs. native cmc implementation in cpachecker figure comparison of cpu time of different cmc solutions for predicate 100s value analysis the three test generation tools described previously.
to streamline the testing process for the test generation tools we use the testing framework tbf 6in revision b60a924.
we run our experiments withbenchexec version .
.
availability.
all our experimental data are available online .
.
experiments feasibilityhypothesis.
wedesignedandimplementedaproof of concept reducer and licensed the reducer using the open source license apache .
such that other researchers can later use it.
whileourimplementationcertainlyhaspotentialforimprovement we show that the approach of composing a conditional verifier from an arbitrary verifier and our reducer works in practice.
wedemonstrated this by using the three best verifiers directly fromthe sv comp web site and composed the conditional verifiers without any change to the verifiers.
in addition we also composed conditional verifiers from test generation tools in order to help test generatorstoproducecrashingtestsformoreverificationtasks.
null hypothesis.
we have experimented with verification runs inwhichwereplacedourreducerbyanidentityfunctionidentity i.e.
thereduceriseffectivelyremovedfromthetoolchain.thefirst verifier which generates the condition is a predicate analysis that werestricttoatmost 100sofcputime.forthesecondverifier we usecpachecker s value analysis with a time limit of 900s.
figure3auses a scatter plot to illustrate the cpu times of the reducer basedapproachusingreducer x axis againstusingidentity i.e.
pure sequential combination .
the scatter plot shows results only for those verification tasks that at least one of the two combinationscansolveandthatnoneofthemsolvedincorrectly or crashed on.
thus the plot only displays results that have a useful result.
often the results are similar data points close to the in this case the predicate analysis alone already solved the verification task.
for some tasks reducer is slower or eventimes out due to the large size of residual programs.
the reason isthatreducerrestructurestheprogram e.g.
unfoldsloopsand the program structure.
the residual program becomes much larger andmorecomplexinitsstructure whichcomplicatesthetaskof the second verifier in these cases.
however there are also a set oftasksforwhichreducerissignificantlyfaster thedatapoints close to the upper border represent tasks for which the conditional combination with reducer solved the task while the combination with identity timed out.
thus the null hypothesis is rejected.
claim comparison against native implementation .
we compare our proposed reducer based approach to construct conditional verifiers against the approach of the original implementation whichwerefertoas native approachbecauseitimplements the restriction of the state space according to the condition internally inthe verifier.
we usethe same setupas above butreplacethesecondverifierby cpachecker svalueanalysiswiththe internalconditiontreatmentenabled.figure 3bshowstheuseful results as scatter plot again.
most of the data points are close to the diagonal i.e.
the two solutions perform similarly.
however as above whentheresidualprogramgetstoolarge thereducer basedsolutionsometimesusestoomuchtime rightside .forsometasks the reducer based solution is even faster than the native approach top .
thus claim is valid.
claim2 effectiveincreaseofnumberofverifiedprograms .
we now evaluate the claim that the use of two complementing verifiers joined by reducer based conditional verification can effectively solve additional verification problems if additional resources arespentonrunningacombinationaftertherunsoftheoriginal verifier.inourexperiments wealwaysfirstrunaconditionalverifier based on predicate analysis to output the conditions with atime limit of 100sof cpu time.
the predicate analysis combines lazy abstraction refinement with predicate abstraction with adjustable blockencoding abe .abeisconfiguredtoabstract authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
reducer based construction of conditional verifiers icse may june gothenburg sweden table results of using a verifier on its own vs. a combination with predicate analysis and condition passing cpaseq smack uauto predicate cpaseq smack uauto correct correct proof correct alarm incorrect incorrect proof incorrect alarm unknown total 800cpu time s n th fastest correct resultcpa seq smack ultimate automizer predicate cpa seq predicate smack predicate ultimate automizer figure quantile plots for the six verification approaches atloopheadsonly.letusrefertothisverifieras a.theconditional verifierinthesecondverificationstepisalwaysconstructedfrom our reducer and an off the shelf verifier we limit the cpu time to900s.
let us refer to this kind of verifier as b. verifier btries to solve all tasks that awas not yet able to solve with the help of the conditions generated by afor these tasks.
the time limit of900sof cpu time is considered a community standard cf.
svcomp becausemostverificationtaskscaneitherbesolvedway below this time limit or cannot be solved at all.
as verifier b w e composeourreducerwiththethreebesttoolsfromsv comp2017 on reachability properties cpaseq smack andultimate automizer .
manyoftheverificationtasksintheconsideredtasksetfromthe sv comp benchmarks are easy to solve for the standard verifiers.
for those tasks we do not need to further experiment because our aim is to show that the new approach can increase the overall numberofverifiedprograms.therefore werestrictourexperiment to verificationtasks that arehard to solve in particular we select those verification tasks for which at least one verifier bfails but the corresponding combination with condition passing of aandb solvesthetask.thisresultsinabenchmarksetcontaining 820hardto solve verification tasks.
table2breaks down the effectiveness of each verification approach.itliststhenumberofverificationtasksthateachverification approachsolvedcorrectly solvedincorrectly andwhichitcannot solve unknown .
the correct and incorrect results are further classifiedintoanswersthatreportedaproofandabug respectively.
inspecting the numbers we observe the following in all three cases the reducer based cmc combination with condition passingofverifiers aandbsolvessignificantlymoretaskscorrectlythan verifierbalone.atthesametime thenumberofwronganswers is not increased by the conditional verifier.
there are two possible reasonsforthisimprovement first verifier aalreadyaccomplished theverification task inwhich verifier bhasno work suggestedby thedatapointsonthediagonalwithlessthan 100sinfig3a .or second verifier averifiedasignificantportionoftheverification tasksuchthattheresidualprogramgeneratedbyreducerbecomes easier to analyze for verifier b suggested by the middle and lower part of table .
figure4shows quantile plots for all six verification approaches.
adatapoint x y onsuchagraphmeansthatthe xfastestcorrect results can be solved all in max.
ysof cpu time each.
we observe that all reducer based approaches significantly outperform their standalonecounterpartbyinvestingmax.
100sofcputime.these observations together with table 2validate our claim .
claim3 solvingproblemsthatnoneofthethreecansolve .
we consider a particular subset of the verification tasks namely those that none of the verifiers cpaseq smack andultimate automizercan solve as standard verifier but at least one combination can.thesetasksseemtobeparticularlyhardforverifierswhilenotbeing too hard for our approach.
table 3shows an excerpt of those 143programsofthetaskset.foreachverificationtask identified bynameandexpectedverificationresult thetablecontainsgroups of result cpu time and max.
memory usage for each of the three standardverifiersandtheirreducer basedcombinationwithcondition passing.
from the table it can be observed that claim is valid thereexistprogramsthatconditionalcombinationscansolve but none of the given standard verifiers can.claim4 differentbackendshavedifferentstrengths .
none oftheconditionalverifiersissuperior.eachverifierhasitsstrengths fortwoverifiers bthereexistverificationtasksthatonlyacombination with that verifier can solve and no other combination cf.
table2 .
and each verifier has its weaknesses for each verifier there are some verification tasks that the verifier even in combination cannotsolve.tosolvealldifficulttasks weneedtoleverage different technologies.
the experimental results validate claim .
this last observation makes the contribution of our reducerbasedapproachimportant itdoesnotmakesensetoextendexisting verifiers to become conditional verifiers in terms of accepting conditionsasinputs becauseweneed manyconditionalverifiers.our approachtotakean arbitrary verifieroff the shelfandconstruct aconditionalverifierwithoutimplementationworksignificantly improves the overall achieved verification power.claim5 reducer basedconstructionworksalsofortesting .
to demonstrate that our approach can be applied to tools other than model checkers we combine our reducer with three testgenerationtools namely afl fuzz v2.46b crest revision31c32f4 andklee v1.
.
.
as in the other experiments the first analysis which generates the condition is the predicate analysis again limited to 100s.
the test generation is limited to 900s.
analogous to claim we restrict the experiment to those verificationtasksthatarehard to solvewithtestgeneration weselect those tasks for which at least one test generator fails to uncoverabugin butthatthecorrespondingcombinationwithcondition passing can correctly solve.
in addition since testing cannot prove correctness we only consider verification tasks that are unsafe.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden d. beyer m. c. jakobs t. lemberger and h. wehrheim table3 resultsofverificationtasksforwhichallconsideredverifiersaalonecouldnotcomputearesult butforwhichatleast one verifier b succeeded in a reducer based combination with condition passing.
column rshows the expected result of the correspondingtask eithernopropertyviolationexists t intheprogramorapropertyviolationexists f .column sreports whether the task was solved by the corresponding verifier tis the cpu time in seconds spent to achieve the corresponding result and mthe used memory in gb.
task rcpaseq smack uautomizer cpaseq smack uautomizer s t s m gb s t s m gb s t s m gb s t s m gb s t s m gb s t s m gb loop acc overflow t .
.
.
.
.
.
.
.
.
mutex unbounded f .
.
.
.
.
.
.
.
.
.
mutex unlock f .
.
.
.
.
.
.
lin .
legousbtower f .
.
.
.
.
lin .
net2272 f .
.
.
.
.
fib longer f .
.
.
.
.
.
.
lin .
vivi f .
.
.
.
.
lin .
block loop f .
.
.
.
.
.
lin .
lm78 t .
.
.
.
.
lin .
synaptics f .
.
.
.
.
lin .
misdn t .
.
.
.
.
.
lin .
vfio f .
.
.
.
.
.
val .
g printer f .
.
.
.
.
.
val .
g printer f .
.
.
.
.
.
... problem19 label20 t .
.
.
.
problem19 label57 t .
.
.
.
problem19 label37 t .
.
.
.
problem19 label15 t .
.
.
.
problem19 label44 t .
.
.
.
problem19 label36 t .
.
.
.
problem19 label06 t .
.
.
.
problem19 label56 t .
.
.
.
problem19 label30 t .
.
.
.
problem19 label01 t .
.
.
.
problem19 label09 t .
.
.
.
problem19 label40 t .
.
.
.
problem13 label33 t .
.
.
.
.
problem19 label05 t .
.
.
.
... lin .
vlsi ir t .
.
.
.
lin .
vsp1 t .
.
.
.
.
lin .
vxge t .
.
.
.
lin .
w83781d t .
.
.
.
.
lin .
zd1211rw t .
.
.
.
.
lin .
vmxnet3 t .
.
.
.
.
lin .
skge t .
.
.
.
.
lin .
ath5k t .
.
.
.
.
lin .
ipw2200 t .
.
.
.
.
.
lin .
bttv t .
.
.
.
.
.
lin .
cciss t .
.
.
.
floodmax.
t .
.
.
.
.
sep20 t .
.
.
.
.
sum 100k 110k 110k 28k 24k 25k average .
.
.
.
.
the full version of this table can be found at .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
reducer based construction of conditional verifiers icse may june gothenburg sweden table test generation vs. cmc combination afl fuzz crest klee predicate afl fuzz crest klee correct alarm incorrect proof 0unknown total 1000cpu time for identity reducer with afl fuzz s cpu time for reducer with afl fuzz s figure5 cputimeforpredicateanalysisand afl fuzz combined with reducer cmc and with identity sequential as a result we get 480tasks.
table 4compares the performance ofthecmcscenarioswiththetesterperformance.similartota ble2 it shows the numbers of correct alarms incorrect proofs and unsolved tasks.
however it leaves out the rows related to safe verification tasks.
we see that for all three test generation tools the number of correct alarms of our reducer based combination withconditionpassingishigherthanfortherespectivetester.in general such an improvement is not only caused by the use of the verifiera but often a result of the combination of tools.
to further support this statement we present fig.
.
it shows the cpu time of tworeducer basedcmcsolutions bothusingthepredicateanalysismentionedabovetogenerateconditions usingthefullsetof 1501verificationtaskswithexpectedresult false.thefirstsolution x axis uses the reducer reducer with afl fuzz and the second solution y axis uses the identity reducer with afl fuzz pure sequentialcombination .
forbettervisualization weremovedthe results that the predicate analysis can solve on its own.
due to the mentioned blowup of the residual program the reducer based solution reducerplus afl fuzz performsworseforsometasks but it can also solve a significant amount of tasks faster than the pure sequential combination identity plus afl fuzz .
size of residual programs.
as already mentioned the residual programcreatedbyreducermaybecomesignificantlylargerthanthe original program.
the reason is a large amount of branching in thecondition i.e.
unfoldingofloopsandprogramstructure which is needed to record the verification work already performed.
to study this in more detail we compared the sizes of the originaland the residual program in terms of locations in the cfa.
at worst theresidualprogramwasmorethan 10timeslargerthanthe originalprogram 1934vs.22325locations .atbest thenumberof locations in the residual program is less than of the number of original program locations 200253vs.127locations .
on average theresidualprogramcontainsfewerlocations withameanof and a median of of the number of locations in the original program .
while the residual program can be much larger it is often much smaller.
.
threats to validity we did not cross check the reported verification results with an independent verifier because we currently do not know how toconstruct correctness or violation witnesses in the setting of reducer based conditional model checking.
while we are sure that the standalone verifiers did a proper inspection they successfully participated in sv comp or provide a test tools might have guessed the correct answer when run as part of the conditional verifier.yet wethinkthatguessingisunlikely.thetoolsarelaidout to provide witnesses and thus properly perform their verification.
thecorrectnessoftheresidualprogramisanotherthreat.like otheranalysistools werelyonthesoundnessofthetransformationfromprogramtocfaandback.additionally werelyonthesoundness of the existing condition generating tool in that the condition onlycoverspathstheverifierhasalreadyinspected.furthermore ourimplementationofreducerisaprototypewhichrevealedbugs during evaluation.
in principle the bugs might be the reason for theeffectivenessofthereducer base dapproach.ho wever thebugs we observed led the conditional verifier to report a wrong result.
additionally wecheckedthenullhypothesisandclaim1only withasingleconditiongeneratinganalysisandasingleconditional verifier.thus thecorrespondingresultsmightnotbeuniversally valid in any reducer based conditional model checking setup.
whenusingacombinationoftwoverificationtoolswithcmc it isalsopossiblethattheincreaseinsolvabletasksissimplybecause the different tools can solve a distinct set of tasks each in a very shorttime.e.g.
inourconfiguration itcouldhavebeenpossible that the full increase in additionally solvable tasks is only due toa competence of the predicate analysis in quickly solving a setof tasks that none of the other verifiers can solve.
to make surethat our considered tool combinations actually benefit from theuse of condition passing we provided a comparison with a pure sequentialcombination identity thatshowedthegeneralbenefit.
in addition cpaseqincludes a 200s run of predicate analysis in its configuration this ensures that all benefits for our combination ofcpaseqandpredicateanalysisareactuallyduetoourreducer approach.
of the tasks considered in the experiments backing claim2 143cannotbesolvedbyanyofthesequentialcombinations but only when using cmc with condition passing.
we onlyconsider asubset of thesv comp tasks andthe three best verifiers from sv comp.
these three verifiers might be tuned to sv comp tasks and may perform worse on our generated residualprograms.despitethispossiblebias ourapproachstillimproves the existing verifiers.
in addition the three test generation tools usedneverparticipatedinanyeditionofsv compandareunlikely biased.
our approach still shows improvements for them.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden d. beyer m. c. jakobs t. lemberger and h. wehrheim related work our concept of reducers allows us to combine a condition generating software verifier with an arbitrary second verifier.
techniques for combining different verification approaches have intensively been studied in the past.
the approaches are executed in parallel interleaved orsequentially.orthogonally theapproachesare integratedinawhite boxorblack boxstyle.white boxcombinations tightly integrate typically orthogonal approaches whereas black box combinations aim at a loose coupling of different tools.parallelcombinations.
parallelcombinationsareoftenusedina white boxstyleiftheanalysisalgorithmsaresimilar.typically combinations letdifferentdomainsinteroperatetoobtain analyses that are more precise than a product combination.interleavedcombinations.
interleavedcombinationsareoften white boxcombinationsthatunitedifferenttechniquesinonealgorithm.
for example synergy and dash perform an alternation of test generation and proof construction.
test generationisguidedbytheabstracterrorpathsandtheabstractionforthe proofconstructionisadaptedaccordingtothetests.smash combinesunderapproximationwithoverapproximation.incontrast abstraction driven concolic testing is a black boxintegration thatalternatesconcolictestingwithmodelchecking.themaingoal of the model checker is to identify and exclude infeasible paths.
giventheopentestgoals encodedaserrorlocations themodel checkerbuildsanabstractreachabilitygraph arg .thebuiltargssuccessivelyrestrictthe original programconsideredbythetester i.e.
after each model checking run the new program for the tester becomes the intersection of its previous program with the arg.sequential combinations testifying verification result.
manysequentialcombinationsaimatexcludingfalsealarmsafter animprecisestaticanalysis typicallyusingablack boxcombination.
for example blast check n crash dyta and sante try to build a test case for each alarm and only report those alarms that are backed by a test.
post et al.
and cpachecker use bounded model checking to check whether an alarm is realizable.
residual investigation tries to reduce the number of false or irrelevant alarms.
it only reports alarms for whichdynamicanalysisobservedprogrambehaviorindicatingthat a warning is appropriate.
in contrast proof carrying code pcc approaches checka completeproof.standardizedverifier exchange formatslike correctnessor errorwitnesses enable cross checks between different tools.sequential combinations splitting verification effort.
program partitioning suggests to use the test data to partition the control flowgraph cfg intotestedandnot tested.thenon tested partition a subgraph of the cfg is analyzed by a static analyzer.
conditional model checking uses a sequential combination a first verifier constructs a condition summarizing the performed verification thenextverifierusesthatconditiontosteeritsverification.
we use the same idea for the first verifier but we transform the condition into a residual program checked by the next verifier.
multi goalreachabilityanalysisfortesting reusestheverification effort of one test goal for another one.
the idea is to transform the arg that was built to achieve the test goal s.t.
it fitsforanewtestgoal.thetest goalautomatacanbeseenasconditions encoding sets of program paths.christakisetal.
proposethataverifiershouldaddprogram annotations stating which assertions under which conditions wereverified.intheexperiments thestaticanalyzerclousotproduces annotations that guide the exploration of the tester pex.
czechetal.
useconditionsandaresidual programconstructiontocombinemodelcheckingandtestinginthecontextofsafety checking.
they propose two basic program constructions.
theirsynchronouscompositionofconditionandprogramissimilartoour reducer.
however they consider a restricted class of conditionsandthusdonotneedtoconsiderassumptionsnorprogram paths that are not covered by the condition.
the second approach slices the program for assertions that are not fully verified.generatingprogramsfromverificationresults.
programpartitioning extracts a subgraph of the program which has not been tested.
abstraction driven concolic testing computes a program from the intersection of an arg and a program.
a similar idea namelyusingargstogenerateprograms hasalreadybeen proposed in a pcc context .
czech et al.
compute a synchronous combination of condition and program.
as alreadymentioned our residual program construction is similar to theapproach of czech et al.
.
our implementation constructs an arg representingthecombinationofconditionandcontrol flow graph whichis translatedintoaprogram.incontrast toprogram partitioning the generated programs need not be subgraphs.
conclusion softwareverificationisanundecidableproblem butstill almostalllive criticalsystemsarecontrolledbysoftware andthus weneedto verifytheselargesoftwaresystems.oneresearchdirectionistodevelop faster verification algorithms and theories another direction is to leverage existing results by combinations.
our contribution fallsintothesecondresearcharea.conditionalmodelcheckingisa promising approach to combine the strengths of different verifiers.
however it is a large effort to make a verifier understand and use theconditionthatdescribeswhatthefirstverifieralreadyachieved.
to solve this problem we propose an easy automatic template construction that turns an off the shelf verifier into one that understandsconditions.ourideaistouseapreprocessor thereducer which takes the condition and the original program to compute aresidualprogram.theresidualprogramencodestheremaining verificationtaskinaformatthatisunderstandablebyeveryverifier programcode.inthispaper wesuggestedonepossiblereducer.our experiments on hard tasks of the sv comp benchmark collection showthatourreducer basedcmcsolutioniseffective.usingthe new combination technique we can solve many verification tasks thatwerenotsolvablebefore andthusadvancethefrontierofwhat is possible with existing software verifiers.
themainconclusionfromourexperimentsisthatweneedmany conditional verifiers but that it is not worth the effort to changeexisting verifiers.
rather we can simply apply our constructionto get kconditional verifiers from karbitrary existing verifiers without changing one line of code.
even if the task is to find crashing test cases with state of the art test generation tools we cansignificantly increase the number of found bugs by using a plugand playconstructionthatdoesnotcostanydevelopmenteffort but increases the number of valuable test cases significantly.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
reducer based construction of conditional verifiers icse may june gothenburg sweden