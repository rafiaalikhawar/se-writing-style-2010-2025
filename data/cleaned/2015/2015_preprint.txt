model driven allocation engineering uwe pohlmann marcus h we software engineering project group mechatronic systems design fraunhofer ipt zukunftsmeile paderborn germany email ipt.fraunhofer.de abstract cyber physical systems cpss provide sophisticated functionality and are controlled by networked electronic control units ecus .
nowadays software engineers use component based development approaches to develop their software.
moreover software components have to be allocated to an ecu to be executed.
engineers have to cope with topology software and timing dependencies and memory scheduling and routing constraints.
currently engineers use linear programs to specify allocation constraints and to derive a feasible allocation automatically.
however encoding the allocation problem as a linear program is a complex and error prone task.
this paper contributes a model driven ocl based allocation engineering approach for reducing the engineering effort and to avoid failures.
we validate our approach with an automotive case study modeled with mechatronicuml.
our validation shows that we can specify allocation constraints with less engineering effort and are able to derive feasible allocations automatically.
i. i ntroduction cyber physical systems cpss behave smart by being controlled by software and collaborate with each other.
modern cars are examples for cpss.
the amount of safety critical software increases which makes the engineering more complex.
the software steers and controls the cars behavior.
therefore cars use sensor signals from many sensors that are located in different parts of a car and are connected to different networked electronic control units ecus .
in particular a hardware platform of a modern car consists of up to networked ecus .
in addition software has to be allocated to an ecu in order to be executed.
the task of specifying an allocation of software components to ecus is complicated because of complex software architectures and complex hardware platforms.
in the upper part figure shows the coarse engineering process for developing software for cpss.
in step software engineers define a software architecture for the system.
a software architecture consists of connected software components that could be specified using e.g.
autosar .
in step hardware engineers define a hardware platform.
a hardware platform consists of connected resources like ecus sensors and actuators.
in step allocation engineers define the allocation of software components to ecus.
autosar enables that each allocated software component is able to run on each ecu.
as a result specifying an allocating is complex.
there exist e c possible allocations for heterogeneous ecus e1 .
.
.
e and software components c1 .
.
.
c .
the amount of feasible combinations is reduced by defining mandatory and useful allocation constraints.
in step the developers implement the software components asprocess steplegendspecify allocation constraintssolve linear programderive linear equationsderive allocation modelartifactimplementationhardware engineeringsoftware engineeringallocation engineering1 allocation specification languagec1linear equations model and transformationc2transformation to solver inputc3backtransformationc4software artifacts contribution fig.
engineering process and paper contribution software artifacts or code generators derive the implementation automatically that fulfills the specification.
one major influence on the architecture of software systems used in the industry are constraints that need to be satisfied in order for the system to be accepted.
in particular engineers have to cope with topology software and timing dependencies and memory scheduling and routingconstraints at design time.
onstraint satisfaction is a crucial aspect in the design of embedded systems.
however constraints add more complexity to the problem.
in realistic automotive systems the constraint set is very large and could reach about thousand equations .
currently engineers use approaches like linear programming or sat based techniques to encode the allocation problem and to derive a feasible allocation automatically that fulfills all constraints.
encoding the allocation problem as a linear program is a complex and error prone task.
an example for a constraint is that each software component is allocated to exactly one ecu.
in terms of the previous example 100many binary decision variables xci ejare required to specify such a constraint.
xc1 e2 means that the software component c1is allocated to the ecu e2.
analogously xc1 e1 0means that the software component c1is not allocated to the ecu e1.
for all software components cithe constraint summationtext100 j 1xci ej 1must hold to be allocated exactly once.
this paper contributes a model driven allocation engineering approach to provide a means to the user for specifying allocation constraints in an easy and expressive way cf.
step figure .
it enables a model based specification of allocation constraints.
we derive an integer linear program ilp based on the allocation constraints that encodes the allocation problem.preprintwe solve the allocation problem automatically by solving the ilp and deriving an allocation model from the solution.
our approach consists of our new allocation specification language asl that uses ocl operations stored in a library cf.c1 figure .
we provide the library as a standard allocation constraint library that provides various operations which should ease the allocation constraint specification.
furthermore this paper contributes a meta model for linear programs cf.c2 figure .
we transform an allocation specification to a model instance of the linear program meta model by modelto model transformations cf.
c2 figure .
the linear program model decouples the problem description from concrete solving mechanisms.
we provide transformations from ilp models to lpsolve which is an existing ilpsolver to solve the linear program cf.
c3 figure .
finally we transform the solution of the linear program via a back transformation to an allocation model that maps software components to ecus cf.
c4 figure .
as a result the solving of the whole allocation problem becomes transparent for allocation engineers.
they get a feasible solution without having to know how to encode and solve the allocation problem as an ilp.
we validate our approach with a brake by wire automotive case study defined by aleti .
we specify the software component model the hardware platform model and the allocation specification with our software engineering approach m echatronic uml .
our validation shows that we can specify allocation constraints with less engineering effort compared to using ilp directly and are able to derive feasible allocations automatically.
the remainder of this paper is structured as follows first we introduce a brake by wire system in section ii which serves as a running example.
afterwards we present in section iii our key contribution of this paper the asl.
in section iv we explain how we derive an allocation from a given software architecture hardware platform and allocation specification.
we evaluate our results by describing an automotive case study in section v. section vi summarizes related work and compares it with our approach.
we conclude the paper in section vii and give an outlook to future work.
ii.
r unning example brake by wire for illustrating our approach we choose the brake by wire functionality from the automotive case study by aleti .
we choose m echatronic uml for implementing the system.
mechatronic uml is a development method for self coordinating cpss.
it supports a hierarchical software and a hierarchical hardware architecture.
a software architecture is described by a component instance configuration that consists of composed software component instances .
in the following we call component instances just components for simplicity.
a component is a software entity that encapsulates a part of the system behavior which implements a certain function.
each component defines a set of external interaction points called ports for accessing its functionality.
software components represent an application or a device.
application components represent specific functionality and handle messages for communication.
device components represent the software for accessing sensor or actuator values and handle signals.
a signal has a value that varies depending on the time andwheel brakepedalcalliper sc4 calliper control sc6 centralbrake control sc10 brakepedal controlsc8 wheelspin detector sc7 wheelspeed sensorsc2 calliperpositionsensorsc1 temperature sensor sc5 calliper clamp actuator sc11 pedalpositionsensor sc12 brakeforce sensorsc13 brakefeedbackactuatorsc9 parking brakesensor legend message porthybrid portsignal portapplication componentdevice component name t y p ename typename typeelectronic control unit xsensor actuatorbusportcommunication busname typesoftware component architecture hardware platform architecture xsc3 parkingbrake actuator b u s c a n humaninterface hw8 ecuhw9 ecu1112913 bus3 canassistance hw1 ecuhw2 ecuhw3 ecubus1 canbrake hw5 ecuhw6 ecuhw7 ecu271 bus2 canhw4 ecu fig.
brake by wire system architecture cf.
has always a value.
software components have a hierarchical architecture a software component is either atomic i.e.
it is implemented directly or it is structured i.e.
it is composed of other components that are called component parts.
in the left part figure shows the brake by wire software architecture.
it consists of the three structured components calliper brakepedal wheel the atomic application component sc6 centralbrakecontrol and the atomic device component sc9 parkingbrakesensor .
the structured component calliper consists of the atomic application component part sc4 callipercontrol and the atomic device component parts sc1 temperaturesensor sc2 calliperpositionsensor sc3 parkingbrakeactuator and sc5 calliperclampactuator .
the structured component brakepedal consists of the atomic application component part sc10 brakepedalcontrol and the atomic device component parts sc11 pedalpositionsensor sc12 brakeforcesensor and sc13 brakefeedbackactuator .
in the automotive industry an existing hardware topology is usually used because car models remain the same through parts of their lifetimes.
the hardware platform architecture defines on which hardware topology the software runs.
we use the m echatronic uml hardware platform description language for modeling the hardware architecture described by aleti .
in m echatronic uml a hardware architecture is represented by a hardware platform instance configuration .
it consists of a distributed set of resources and hardware platforms that are connected via networking connectors.
a resource represents a device like a sensor or actuator or a structured resource like an ecu that contains memory resources and computing resources.
software components can only be allocated to structured resources.
a hardware platformpreprintembeds a hardware platform instance configuration and enables hierarchical modeling.
networking connectors are either direct links that connect resources or hardware platforms directly or are communication buses.
in the right part figure shows the hardware platform for the brake by wire system.
it consists of the three subplatforms assistance brake and humaninterface .assistance consists of three structured resources hw1 ecu hw2 ecu and hw3 ecu that are connected by bus1 can .
the hardware platform brake consists of four structured resources hw4 ecu hw5 ecu hw6 ecu and hw7 ecu that are connected by bus2 can .
these ecus have access to the temperature sensor the wheel speed sensor the calliper position sensor the parking brake actuator and the calliper clamp actuator .
the hardware platform humaninterface consists of two structured resources hw8 ecu and hw9 ecu .
these ecus have access to the pedal position sensor the brake force sensor the parking brake sensor and the brake feedback actuator .
the structured resources hw2 ecu hw3 ecu hw4 ecu and hw8 ecu are additionally connected by bus4 can .
according to aleti the software components sc11 pedalpositionsensor and sc12 brakeforcesensor must be allocated to the same ecu.
the structured component wheel consists of the atomic application component part sc8 wheelspindetector and the atomic device component part sc7 wheelspeedsensor .
according to aleti both components must be allocated to the same ecu.
iii.
a llocation specification language contribution c1 during the allocation step engineers have to specify allocation constraints.
the primary design goal of the asl is to provide a means to the user for specifying allocation constraints in an easy and expressive way.
in order to achieve this the language embeds ocl which is widely used in the model driven world.
thus we assume that the potential users of the asl are already familiar with ocl.
a. constraint kinds we identified four different allocation constraint kinds from the literature .
the constraint kinds are collocation separatelocation requiredlocation and requiredresource which we introduce in the following paragraphs.
in a later step each kind has to be transformed in a different way to a set of constraints of an ilp.
knowing the limited number of possible constraint kinds enables to specify this transformation.
it handles each user defined allocation constraint that fits into our kind schema.
the general idea is that for each of the constraints an ocl expression is specified by the user which has a specific ocl type.
using the previously mentioned transformation the ocl expression is evaluated and its result is mapped to corresponding ilp constraints.
the collocation constraint is used to specify that two components have to be allocated to the same ecu.
thereby it is possible to avoid safety critical communication between components via an unreliable bus or it is possible to reduce communication latencies.
for example we have to implement a constraint that ensures that the componentsconstraint collocation collocatesc11andsc12 descriptors firstcomponent secondcomponent ocl self .allocatetosameecu sc11 sc12 listing a constraint of the kind collocation constraint separatelocation separatelocationsc6aandsc6b descriptors firstcomponent secondcomponent ocl self .allocatetodifferentecus sc6a sc6b listing a constraint of the kind separatelocation sc11 pedalpositionsensor and sc12 brakeforcesensor are allocated to the same ecu as defined by aleti .
thus we have to specify an ocl expression that evaluates to set tuple firstcomponent sc11 pedalpositionsensor secondcomponent sc12 brakeforcesensor .
listing shows this constraint with the name collocatesc11andsc12 of the kind collocation .
the constraint evaluates to a set that consists of a tuple whose concrete type is defined by the descriptors .
the elements of the tuple can be accessed via the names firstcomponent andsecondcomponent .
we use the ocl operation allocatetosameecu instance1 string instance2 string to define the allocation constraint that the components with the name sc11 andsc12 have to be collocated.
later the evaluation result of this operation call is transformed to corresponding ilp constraints.
the ocl operation allocatetosameecu ... is stored in the m echatronic uml specific allocation operation ocl library which we introduce in section iii c. the separatelocation constraint is used to specify that two components have to be allocated to different ecus.
thereby it is possible to avoid that redundant components are allocated to the same ecu and fail at the same time in the case of an ecu hardware fault.
for example a component which performs safety critical functionality like sc6 centralbrakecontrol is duplicated tosc6a centralbrakecontrol and sc6b centralbrakecontrol .
both should be allocated to different ecus.
thus we have to specify an ocl expression that evaluates to set tuple firstcomponent sc6a centralbrakecontrol secondcomponent sc6b centralbrakecontrol .
listing shows this constraint with the name separatelocationsc6aandsc6b of the kind separatelocation .
the constraint evaluates to a set that consists of a tuple.
the elements of the tuple can be accessed via the names firstcomponent andsecondcomponent .
we use the ocl operation allocatetodifferentecus instance1 s t r i n g i n s t a n c e s t r i n g to specify that the components with the names sc6a and sc6b cannot be collocated.
the allocatetodifferentecus tuple is syntactical the same as the allocatetosameecu tuple.
due to the distinguished kind its semantics is the exact opposite.
the requiredlocation constraint is used to specify that a component has to be allocated to specific ecus or ecus that are part of specific platforms.
thereby it is possible to avoid that safety critical components are allocated to nonsecure ecus that are designed for entertainment purposes and have e.g.
no trusted platform with appropriate authentication mechanisms for access control .
additionally we have to ensure that components which communicate with each other preprintconstraint requiredlocation requiredlocationsc8 descriptors component allowedresource ocl self .allocatecomponenttoplatform sc8 brake listing a constraint of the kind requiredlocation are allocated to the same ecu or to ecus that are connected via a bus or a direct link.
for instance the component sc8 communicates with the component wheel and sc7.
so for example we obtain a valid allocation with respect to the component communication and ecu interconnection if we allocate sc8to ecu hw4 wheel to ecu hw3 and sc7to ecu hw5.
furthermore not all ecus have access to all sensors.
for example only ecus which are connected to the same bus as a sensor can read the provided sensor values.
as a result e.g the component sc8 wheelspindetector has to be allocated to one of the ecus of the brake platform hw4 hw7 that can read the value of the wheel speed sensor via the bus.
thus we have to specify an ocl expression that evaluates to set tuple component sc8 wheelspindetector allowedresource hw4 ecu ... tuple component sc8 wheelspindetector allowedresource hw7 ecu .
listing shows this constraint with the name requiredlocationsc8 of the kind requiredlocation .
the constraint evaluates to a set that consists of several tuples.
the elements of a tuple can be accessed via the names component and allowedresource .
we use the ocl operation allocatecomponenttoplatform component string platform string to specify that the component with the name sc8has to be allocated to one of the ecus of the brake platform.
listing shows the communicatingcomponents constraint which ensures that communicating components are allocated to ecus that can communicate with each other.
basically the allocatecommunicatingcomponentstoconnectedecus operation computes the cartesian product of the set consisting of pairs of communicating components and the set consisting of pairs of connected ecus.
more precisely its return type isset tuple component1 component resource1 ecu component2 component resource2 ecu .
the semantics of a tuple from this set is that the component that is referred by the named part component1 can be allocated to the ecu referred by resource1 while the component referred by component2 is allocated to the ecu referred by resource2 .
since a tuple in ocl is unordered the tuple descriptors descriptors component1 resource1 component2 resource2 are used to group the corresponding component ecu pairs.
that is the semantics of the tuple tuple component1 sc8 resource1 hw4 component2 wheel resource2 hw3 is that the component sc8 can be allocated to hw4 while the component wheel is allocated to hw3.
changing the tuple descriptor to descriptors component1 resource2 component2 resource1 means that the component sc8can be allocated to hw3 while the component wheel is allocated to hw4.
the requiredresource constraint is used to specify that an allocation has to respect certain resource restrictions.
thereby it is possible to avoid that more main memory of an ecu is used by software components than an ecu pro constraint requiredlocation communicatingcomponents descriptors component1 resource1 component2 resource2 ocl self .allocatecommunicatingcomponentstoconnectedecus listing another constraint of the kind requiredlocation vides.
for example the component sc3 parkingbrakeactuator needs 64kbytes the component sc4 callipercontrol needs 512kbytes and the component sc5 calliperclampactuator needs 256kbytes according to aleti .
moreover the ecu hw5 ecu s amount of available memory is 512kbytes .
hence it is possible that sc3and sc5are both allocated tohw5 ecu but for example sc3and sc4cannot be both allocated to hw5 ecu .
thus we have to specify an ocl expression that returns for each ecu the available memory and a set that describes the memory consumption of each component if it is allocated to that ecu.
an excerpt of this ocl result for the ecu hw5 and the components sc3 sc5 is set tuple availablememory requiredmemory set tuple componentinstance sc3 resourceinstance hw5 requiredmemory tuple componentinstance sc4 resourceinstance hw5 requiredmemory tuple componentinstance sc5 resourceinstance hw5 requiredmemory .
in general for each component which can be potentially allocated to hw5 ecu the set that is referred by the outer tuple s requiredmemory named part should include a corresponding tuple.
listing shows a constraint with the name maxmemoryconsumption of the kind requiredresource that is used to guarantee that the components which are allocated to the same ecu do not exceed the ecu s available memory.
the constraint evaluates to a set that consists of nine tuples one tuple for each ecu .
such a tuple has the named parts availablememory and requiredmemory .
the named part availablememory represents an ecu s available memory.
the named part requiredmemory refers to a set that consists of 3tuples.
such a tuple has the named parts componentinstance resourceinstance and requiredmemory .
the requiredmemory named part represents the required memory of the component that is referred by the componentinstance named part if it is allocated to the ecu that is referred by the resourceinstance named part.
each tuple represents a constraint whose left hand side lhs has to be smaller than or equal to the right hand side rhs .
the left hand side is the sum over the referred 3tuples.
a tuple contributes its requiredmemory value to sum if its referred componentinstance is allocated to its referred resourceinstance and 0otherwise.
the right hand side is given by the tuple s availablememory named part.
referring to the excerpt of the previous ocl result we see that only certain combinations of the components sc3 sc5can be allocated to the ecu hw5 because e.g.
sc3 sc5 are allocated to hw5 does not hold while sc3 sc5are allocated to hw5andsc4is allocated to a different ecu holds.
b. ocl context we assume that all ocl expressions are specified in the syntactical context of the class oclcontext .
figure showspreprintconstraint requiredresource maxmemoryconsumption lhs requiredmemory rhs availablememory descriptors componentinstance resourceinstance ocl self .maxmemoryconsumption listing a constraint of the kind requiredresource that the class oclcontext has