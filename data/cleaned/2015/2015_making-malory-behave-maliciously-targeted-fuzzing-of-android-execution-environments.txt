making malory behave maliciously targeted fuzzing of android execution environments siegfried rasthofer steven arzt fraunhofer sit and tu darmstadt germanystefan triller fraunhofer sit germanymichael pradel department of computer science tu darmstadt germany abstract android applications or apps provide useful features to end users but many apps also contain malicious behavior .
modern malware makes understanding such behavior challenging by behaving maliciously only under particular conditions.
for example a malware app may check whether it runs on a real device and not an emulator in a particular country and alongside a specific target app such as a vulnerable banking app.
to observe the malicious behavior a security analyst must find out and emulate all these app specific constraints.
this paper presents fuzzdroid a framework for automatically generating an android execution environment where an app exposes its malicious behavior .
the key idea is to combine an extensible set of static and dynamic analyses through a search based algorithm that steers the app toward a configurable target location.
on recent malware the approach reaches the target location in of the apps.
in total we reach code locations within an average time of only one minute.
to reach these code locations fuzzdroid generates different environments too many for a human analyst to create manually.
i. i ntroduction android is the most popular platform for mobile devices1 and there are millions of applications or apps.
unfortunately the platform attracts not only benign but also malicious apps.
such malware tries to steal the user s sensitive information or money e.g.
by sending sms messages to costly premium rate numbers without the user s consent.
to avoid being detected as malware through automated or manual analysis many malware apps exhibit their maliciousness only when being executed in a particular environment.
for example some apps check whether they are running in an emulator or another analysis environment and behave benignly in these cases.
other malware apps target specific countries and remain harmless unless the sim card in the victim s phone is registered in one of the target countries.
yet another kind of malware targets devices with a specific app installed such as a vulnerable banking app.
these environment dependencies make it hard for dynamic analyses such as taintdroid droidscope and appsplayground to detect malware because an arbitrary execution is likely to be benign.
while static analyses such as androidleaks flowdroid or droidsafe do not have this limitation they usually suffer from false positives and must be complemented by dynamic approaches or manual investigation.
a human security analyst then faces the same id 37challenges as a dynamic analysis e.g.
when debugging an obfuscated app with non trivial environment dependencies.
due the large number of environment properties in android sim country code mobile network code location presence of apps and files on the phone etc.
it is practically infeasible to simply try all possible environments.
recent work proposes to generate input for malware apps by modifying the values provided by the device to the app.
unfortunately the approach relies on a limited set of techniques for finding such inputs and does not support apps containing anti static analysis techniques.
as a result the approach fails to generate an appropriate environment for many current malware apps.
furthermore the approach involves significant human effort making it unsuitable for automatically analyzing a large number of apps.
this paper presents fuzzdroid2 a framework for automatically generating an android execution environment where an app exposes its malicious behavior.
the main idea is to fuzz the values that the app obtains when interacting with its environment through an extensible set of static and dynamic analyses that provide possible values.
fuzzdroid chooses among these values using an evolutionary algorithm based search that leads the app to a specified target location.
if successful the approach reports an environment sufficient to reach the target location.
for example a security analyst may specify as target all locations that trigger potentially malicious behavior such as sending sms messages or aborting incoming sms messages.
the environment reported by fuzzdroid enables the analyst to understand the maliciousness of the app.
furthermore it enables a dynamic analysis to further investigate the app s behavior e.g.
for automated classification of apps.
we evaluate fuzzdroid with state of the art malware apps.
the approach effectively reaches a target location in of these apps while requiring only one minute per target location on average.
to reach these targets fuzzdroid generates different environments which contain four different values on average.
these results show that simply guessing arbitrary combinations of environment values is very unlikely to reach a specific target.
in summary this paper contributes the following a multi analysis framework to generate android environments that expose otherwise hidden malicious behavior.
2source code available at ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1string ha shvalue 389d90db090f0f0303030030d98676ie03 called when an s m s message arrives 3public void onreceive context c intent in tent string smsmessage intent .getmessagebody checks content of s m s message if smsmessage .
startswith ak40 string certificatehash this .
getcertificate .tostring integrity check whether the a p k got m odified if certificatehash .
equals hashvalue get m c c and m n c codes string mobileoperator getnetworkoperator file encryptedfile readfilefromstorage file decryptedfile decryptfile encryptedfile boolean containsmobileop false reader bf new reader decryptedfile string line checks whether file con tains mobile operator while line br.readline !
null if line .equals mobileoperator containsmobileop true break targeted attack against specific network if containsmobileop dynamic class loading expects a dex file even though file s uffix is .db dexclassloader dcl new dexclassloader anserverb .db class clazz dcl .
loadclass baseabroadcastreceiver method method clazz .
getm ethod onstart intent .
class boolean returnvalue boolean method .
invoke intent if returnvalue false target location aborts delivery message this .
abortbroadcast fig.
.
motivating example incoming sms messages are aborted only under certain circumstances.
a set of static and dynamic analyses that provide values for circumventing various checks in malware apps.
a search based fuzzing algorithm that selects environment values to steer an app toward a target location.
empirical evidence that the approach is efficient and effective for current malware apps and that it clearly outperforms the closest existing approach.
ii.
o verview and example this section illustrates several key challenges for reaching a particular target location in a state of the art malware app and outlines how we address these challenges.
figure shows a motivating example which we reverse engineered from several real world android malware apps from the anserver fakeinstaller and badaccents malware families.
the app intercepts sms messages sent to the device and under particular conditions aborts the delivery of the message to the user s inbox.
malware apps use such behavior e.g to intercept validation messages sent to bank customers.
the malware then silently uses the validation code to perform malicious transactions.
to understand an app s behavior a human analyst or an automated analysis is interested in the conditions under which the app aborts the delivery of messages.
in the example suppose that we mark the call to the abortbroadcast method line as the target location and want to trigger an execution where the app calls this method.
reaching this target location is difficult because the app requires a particular environment to expose its malicious behavior application target locations fuzzed apis fuzzing frameworkconstant value provider symbolic value provider file value provider ...environment to reach target location fig.
.
overview of the fuzzdroid approach.
the behavior must be triggered by an incoming sms message that starts with a particular string line .
the app checks whether the user s network operator is part of a pre defined list of targets lines to .
the problem is compounded by the fact that the app tries to evade analysis the app checks whether the apk file of the app has been modified by comparing its signature against a known value line .
such checks aim at preventing instrumentation based dynamic analyses from modifying the app.
the app loads an additional class from a file reflectively calls a method of the loaded class and checks whether the method returns a particular value lines to .
such behavior challenges static analyses which cannot easily reason about reflective methods calls and in particular about methods of classes that are dynamically loaded from an external file.
all these conditions are typically hidden in highly obfuscated code.
a naive dynamic analysis that simply executes the app possibly by sending a random sms does not reach the target location.
randomly fuzzing the environment is very unlikely to be successful because multiple non trivial conditions must be met.
a purely static analysis cannot easily reason about reflectively called methods and in particular about methods of classes that are dynamically loaded from an external file.
even a recently proposed approach that combines static and dynamic analysis cannot reach the target partly because it cannot deal with obfuscation through reflection.
figure gives a high level overview of the fuzzdroid approach.
given an app a set of target locations and a set of apis to fuzz the approach repeatedly executes the app while fuzzing the values returned by the specified apis until it finds an environment where the app reaches a target location.
to this end the approach intercepts calls of the app to apis and modifies their return values to steer the app toward the target.
an observation crucial for our work is that a single fuzzing approach is insufficient to reach target locations in realworld malware apps.
instead fuzzdroid consists of a generic framework and an extensible set of value providers.
each value provider is a static or dynamic program analysis that provides values to the fuzzed apis.
to decide which of the suggested values to use for a particular api call we present an evolutionary algorithm based search strategy.
the strategy authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iteratively refines the selection of values based on feedback from previous executions.
to illustrate fuzzdroid with the motivating example suppose we trigger the onreceive method with an empty sms message.
at line the approach intercepts the first call to the environment getmessagebody and queries multiple analyses for possible return values.
suppose that one analysis which extracts string constants from the app s bytecode suggests the value anserverb.db .
another analysis which reasons about string operations by extracting and solving constraints suggests a value ak40 1abc .
suppose that fuzzdroid randomly decides to return the value anserverb.db so the onreceive method returns without reaching the target.
next the approach re executes the method and again reaches the fuzzing decision at line .
suppose that now fuzzdroid fuzzes the getmessagebody call by returning ak40 1abc so the app takes the if branch and gets closer to the target location.
during all executions the approach keeps track of the distance of the executed path to the target location and exploits this knowledge to prioritize values.
for the example the approach may infer from the first two executions that ak40 1abc leads the execution closer to the target and is thus more likely to reach the target than anserverb.db .
to eventually reach the target fuzzdroid proceeds to fuzz environment calls while improving the selection of fuzzed values until it finds suitable return values for further environment calls at lines and .
key to reaching the target is to combine values extracted with several complementary analyses instead of relying on a single analysis.
sections iii and iv present our approach in more detail.
iii.
a t argeted fuzzing framework the fuzzdroid approach consists of a generic fuzzing framework and an extensible set of value providers for fuzzing particular apis.
this section presents the fuzzing framework.
at first we present the overall algorithm of the framework section iii a .
then we describe how the framework interacts with the app during the execution section iii b .
next section iii c presents how the framework steers the execution toward a target location by picking appropriate values for the fuzzed apis.
finally we present how fuzzdroid deals with dynamically loaded code section iii d .
the goal of fuzzdroid is to find an environment in which the app reaches a target location.
an android app interacts with its environment through api calls such as getdeviceid andgetmessagebody .
we control the environment of an app by fixing the values returned by such api calls definition environment an environment e l n v is a map that assigns a value v v to a pair l n where l l is a code location and n nis a counter of how often lhas been reached in the current execution.
for example suppose that lsms is a call site of getmessagebody .
the environment lsms mapsto abc lsms mapsto def specifies that the call toalgorithm find an environment ethat reaches location ltarget inapp.
input appapp setltarget of target locations and set afuzz of apis to fuzz output environment e q app queue whileq negationslash empty do app current q.pop staticpreanalysis app current instrument app current ltarget afuzz nbruns t trace pool whilenbruns maxruns do nbruns nbruns e initializeenvironment t trace executeandfuzz app current e q t t trace iftargetreached trace ltarget then report e trace exit end if end while end while getmessagebody returns abc and def when the location is reached for the first and second time respectively.
we call an environment that enables the app to reach a target location a successful environment .
note that we only consider a target location as reached if it can be executed without an exception.
a. main algorithm to find a successful environment fuzzdroid repeatedly executes the app while refining the environment as summarized in algorithm .
the outer loop of the algorithm will be explained in section iii d the reader should ignore it for now and focus on the steps starting from line .
at first the algorithm statically builds an inter procedural control flow graph of the app which will be used by the subsequent steps.
in addition each value provider plugged into the framework can perform further static analyses at this point.
next the framework instruments the app to keep track of the execution path and to intercept calls to the fuzzed apis.
the main loop of the algorithm starts at line .
the framework repeatedly executes the app until either a target location or a configurable maximum number of executions has been reached.
before each execution functioninitializeenvironment creates an environment.
section iii c describes this step in detail.
during the execution the instrumented app queries the framework for values to be returned at call sites of fuzzed apis.
section iii b presents theexecuteandfuzz function which implements this step in detail.
the framework summarizes each execution into an execution trace and maintains a pool of all previous executions.
after each execution the algorithm checks whether the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
target location has been reached line .
if the framework has reached the target the algorithm returns the successful environment.
otherwise the algorithm refines the environment based on the feedback obtained from previous executions and executes the app again.
b. executing and fuzzing apps the core of fuzzdroid s fuzzing happens in function executeandfuzz called at line of algorithm .
fuzzing the environment each execution starts with an initial environment ethat maps a subset of all possible api calls that may happen during the execution to return values.
during the execution the app queries the framework whenever the execution reaches a fuzzed api.
if the app requires a pair l n e i.e.
a value provided by the initial environment then the framework returns this value.
otherwise the framework queries the value providers selects one of the provided values and adds this value to the environment e. to help the framework select a value value providers associate with each value a weight that specifies the confidence the value provider has in the respective value.
the weights also allow for prioritizing particular value providers over others e.g.
if one value provider is generally more precise than others.
the framework selects a value by ordering all provided values and by picking randomly among the values with the highest weight.
to prevent the framework from permanently rejecting values with low weight the framework also considers all remaining values with a low probability per default and selects randomly among them regardless of their weight.
during the execution of the app in the fuzzed environment the framework summarizes the execution into a trace definition trace a trace t l e summarizes the execution of an app into the list l of executed code locations li l and the environment ethat has triggered this execution.
at the end of an execution the framework adds the trace to a trace pool .
these traces have two purposes.
first the framework creates future initial environments based on the traces of previous executions as described in detail in section iii c. second value providers can adjust the set of provided values based on the current trace and on the trace pool.
for example a value provider may reduce the weight based on values already used in previous executions or provide values based on the path taken in the current execution.
triggering events and services the approach described so far assumes that the target location is reachable by simply starting the app under a suitable environment.
however some target locations may only be reached when the app reacts to a particular event such as an incoming sms message or a click on a button.
to enable the approach to reach such target locations fuzzdroid programmatically triggers event handlers.
for this purpose the framework computes a static call graph of the app and traverses it backwards starting at the target location.
when reaching the beginning of a callbackmethod fuzzdroid checks the event for which the respective callback is registered and triggers the event programmatically.
we directly call the respective event handler method and thus do not need a model of the entire app and its ui.
even if several ui interactions would be necessary to trigger the event during normal execution fuzzdroid directly jumps into the handler.
properties of successful environments since fuzzdroid checks dynamically whether an environment reaches the target location a reported environment is guaranteed to reach the target.
in contrast fuzzdroid guarantees neither to find a minimal environment nor to generate a realistic environment i.e.
a reported environment may over constrain individual environment values possibly with values that may not occur in reality.
suppose an app requires the name of the network operator to contain the string tele .
in this case fuzzdroid may report an environment that sets the network operator to telefoo which is not an actual network operator.
our evaluation shows that the absence of these guarantees is a non issue in practice because most successful environments specify a manageable number of values.
c. steering toward the target since the set of possible environments that fuzzdroid can generate is too large to explore exhaustively it is crucial to steer the approach toward an environment that reaches the target location.
this section explains how fuzzdroid steers toward such an environment based on the trace pool.
these steps of the approach correspond to function initializeenvironment in algorithm .
measuring the fitness of environments to identify environments that are likely to lead the app to the target location we compute a fitness score for each environment based on the trace that the environment yields definition fitness of an environment given a trace l e and a target location ltarget the fitness of eis the minimum distance between ltarget and any location linl.
fuzzdroid computes the distance between code locations as the minimum number of edges between the locations in the inter procedural control flow graph.
the rationale for considering the minimum distance is that traces that get close to the target at some point during the execution are more likely to reach the target than traces that always remain far from the target.
other measures can be easily added to our approach.
evolutionary algorithm based on the fitness of environments an evolutionary algorithm creates new initial environments.
the intuition behind the approach is that traces which came close to the target are likely to have values in their environment that enable the app to reach the target.
the algorithm repeatedly combines such promising environments into new environments until fuzzdroid reaches the target.
algorithm summarizes the main steps.
given a trace poolt the algorithm computes an environment efor the next execution.
at first the algorithm checks whether the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm create an initial environment e. input trace pool t output environment e if t mintraces orrandomnb .25then return empty environment end if esorted sortenvsbyfitness t whileesorted negationslash empty do e1 e2 selectparentenvs esorted e crossover e1 e2 ifisnewenv e t then mutate e returne else remove esorted e1 end if end while return empty environment size of the trace pool exceeds a minimum value five in our evaluation and otherwise returns an empty environment.
the empty environment forces fuzzdroid to query value providers at runtime for values which yields additional traces to learn from.
if there are sufficiently many traces the algorithm sorts the environments of these traces by their fitness score.
next the main loop of the algorithm lines to performs the following classical steps of an evolutionary algorithm select two parent environments create a new environment through a crossover operation and check whether this yields an environment that has not yet been used in any previous execution.
if so the algorithm mutates the new environment and returns it.
otherwise the search continues until the algorithm runs out of possible parent environments.
in this case the algorithm returns an empty environment.
a selecting parents theselectparentenvs function line selects the two environments with the highest fitness.
if combining these environments yields an environment that has already been tried before then the algorithm removes the current best environment from the sorted list esorted of environments to consider.
as a result the next iteration of the algorithm s main loop selects the second best and third best environment as potential parents and so on until there are no more possible parent environments.
note that the sorted list esorted from line is a copy of the original trace pool t. therefore the removal of the environment does not influence the overall trace pool t. b crossover to combine two environments fuzzdroid first computes the union of all keys in the environments.
if a key is provided by only one environment then this environment contributes the values.
otherwise fuzzdroid randomly picks which environment contributes the value.
c mutation to avoid getting stuck in a local minimum i.e.
an environment that brings the execution close to the target but based on which the execution cannot reach the target the algorithm mutates the environment that results fromcrossover.
fuzzdroid mutates each value of an environment with a small probability .
in our evaluation .
to mutate a value for a particular api method the approach picks from an environment different from the two current parents a random value provided for this api method.
d. dealing with dynamic code loading some malware apps hide malicious behavior by storing the malicious code in an encrypted file and by decrypting and loading this code at runtime.
in this case the malicious code is unavailable to the static part of our framework.
in particular the target location may not be visible to static analysis making it impossible to e.g.
compute the distance between the target and already executed locations.
fuzzdroid deals with such packing by observing dynamically loaded code and by rewriting the app into an app that contains this code.
to this end fuzzdroid first takes all locations of dynamic code loading as targets and attempts to steer the execution to these parts of the code.
when reaching a location that dynamically loads code the framework merges this code with the original apk file enabling future runs to analyze the full not obfuscated code.
in algorithm the list qrepresents the queue of apps created by merging apps with dynamically loaded code.
to call methods from dynamically loaded code apps use the java reflection api.
as a further obfuscation step the method and class names often are computed or decrypted at runtime making them unavailable to static analysis even if all code is available.
to address this challenge fuzzdroid applies harvester to each app.
harvester uses a combination of static and dynamic analysis to precisely extract the targets of reflective method calls and replaces them with direct calls.
iv .
v alue providers this section presents value providers which create values to be returned at call sites of fuzzed apis.
a main contribution of fuzzdroid is to automatically combine multiple value providers.
a. symbolic v alue provider the way an app uses the values obtained from the environment often reveals the app s expectations about these values.
for example line in listing reveals that the incoming message must start with ak40 1 .
likewise a call to sendtextmessage nr body reveals that nris expected to be a number or to start with a e.g.
.
to exploit such information fuzzdroid contains a constraintbased symbolic analysis that reasons about uses of environment values in the app.
the basic idea is to encode the results of a local static analysis and values extracted at runtime into constraints and to query a constraint solver to find values for fuzzing.
the analysis computes for each call site lfuzz of a fuzzed api a set of values.
the approach consists of three steps explained in the following.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static data flow analysis the approach statically reasons about the uses of fuzzed values through an interprocedural data flow analysis.
given a set of source locations and a set of sink locations the analysis extracts sequences of statements that propagate and modify values between a source and a sink.
we call such a sequence of statements a data flow path.
the sources for our analysis are all call sites of fuzzed apis.
as sinks we consider all call sites of a configurable set of methods that reveal expectations by the app on values such asstring.startswith andsendtextmessage .
the static analysis yields a map lfuzz d from call sites of fuzzed apis to sets of data flow paths.
for example listing yields a data flow path that connects getmessagebody via smsmessage with startswith ak40 1 .
constraint solving the analysis translates the data flow paths into constraints and solves them to obtain values to be suggested at call sites of fuzzed apis.
at first the approach transforms each data flow path into ssa form.
next the approach translates data flow paths into conjuncts of constraints understood by the z3 solver similar to prior work .
specifically the initial call of a fuzzed api method in each data flow path is represented as a symbolic variable vfuzz.
any operations applied in the data flow path are translated into the corresponding z3 constraints.
for example we translate string operations into their corresponding constraints provided by the z3 string theory .
for api methods not supported by the z3 solver such as string.split we provide additional constraints that model the behavior of the respective api.
to encode the information revealed by the call of the sink method we translate this call into constraints.
for example a call to sendtextmessage is encoded as constraints that specify that the first argument provided to the method must be a number or followed by a number.
for data flow paths with sink methods that represent boolean checks such as string.equals we generate two conjuncts of constraints which represent the case that the check returns true and false respectively.
this translation yields a map lfuzz c from call sites of fuzzed apis to sets of symbolic constraints.
to compute values for fuzzing the approach queries the solver for each set of constraints to obtain a concrete value for vfuzz.
the solving yields a map lfuzz v that assigns to each fuzzed location a set of possible values.
whenever the framework queries the analysis for a value to be returned at a location l l fuzz the analysis returns one of the possible values.
to reduce the computational cost of constraint solving the analysis solves all statically extracted constraints before executing the app for the first time.
dynamic refinement of constraints the statically extracted constraints may contain symbolic variables in addition to the fuzzed value vfuzz.
for example suppose an app compares the return value of a fuzzed api to a dynamicallycreated string using string.equals .
without knowing the dynamically created string the constraint solver is unlikely to return a suitable value for vfuzz because it knows only that vfuzz is equal to another symbolic variable vc.
we address this problem by enriching the statically computed constraints with dynamically extracted values.
to this end the analysis obtains from the framework runtime values involved in calls of a configurable set of methods.
by default we include into this set of methods string operations such as string.equals andstring.substring because these operations are particularly important in various malware apps.
if an execution produces a concrete value cfor a symbolic variable vcin one of the statically computed constraints then the approach copies the constraint and in the copy replaces the vcwithc.b y solving the refined constraints the analysis is more likely to obtain a suitable value for vfuzz.
for the above example the refined constraints specify that vfuzz is equal to c making it trivial to find a precise solution.
to reduce the cost of constraint solving the analysis performs the dynamic refinement of constraints on demand.
that is whenever the framework queries the analysis for a value at a location the analysis checks whether the constraints for this location contain any symbolic variable for which concrete runtime values have been observed in previous executions.
only if such runtime values exist the analysis gives the refined constraints to the solver.
since the results computed from constraints that make use of dynamic values are usually more precise than those that rely only on static data flow paths the approach gives them a higher weight when providing them to the framework.
our constraint based analysis differs from traditional symbolic and concolic execution by applying a local symbolic analysis instead of reasoning about the entire execution path.
the benefit of avoiding path sensitivity is that our local analysis scales well to large apps.
however the approach cannot guarantee that values obtained from the solver will cause the app to reach the target.
for example our analysis does not reason about which of the two branches of a conditional leads to the target but instead suggests values for both branches.
since fuzzdroid dynamically validates whether an environment reaches the target the symbolic analysis does not have to provide this guarantee.
instead fuzzdroid iteratively selects values based on the fitness of executed environments section iii c .
b. constant v alue provider many apps compare runtime values against constants stored in the code.
these constants may not be directly in the conditional but e.g.
read from variables or fields.
to execute branches guarded by such conditionals a simple static analysis gathers from an app s bytecode all constants of primitive types and strings.
the value provider returns these constants when being queried for a value of a matching type.
if the app does not contain any statically extractable constants e.g.
due to obfuscation the analysis returns values from a pre defined pool of random values.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
for the example in figure the constant value provider helps pass by the integrity check at line .
the value provider extracts the hash value of the certificate at line and suggests it when the app queries the certificate hash at line .
as part of our future work we plan to also take dynamically computed values into account a feature that is already implemented in the symbolic value provider see section iv a .
c. file v alue provider for some malware apps the existence of a file possibly containing data of a particular file type is essential for triggering malicious behavior .
to prevent apps from failing when an expected file is missing the file value provider suggests values for apis that access the file system.
if the accessed file does not exist the provider emulates the file.
to this end the provider infers the expected file type and provides a dummy file of the inferred type.
during the static pre analysis the analysis approximates the set of expected file types using a forward data flow analysis that follows the data flow from the file access to an api call that reveals the expected file type.
for example a dataflow that reaches a sqlitedatabase.openorcreatedatabase calls reveals that the file is expected to be a database file.
we provide a manually assembled map between api calls and file types.
once the type is known a manually created dummy file of the correct type is picked and pushed onto the phone before the app accesses that file.
if the analysis fails to statically identify the expected file format it tries to create a suitable file based on the name of the accessed file.
note that this analysis aims at providing a file with the expected format not a file with the expected content.
further api calls that e.g.
read data from the file are intercepted separately.
other analyses such as the symbolic value provider section iv a can then provide the values expected to be read from the file.
d. v alue provider for integrity checks many malicious apps protect against code modifications by validating their own integrity through a check of the app s certificate which is used for signing an android app.
when modifying the app s bytecode one must re sign the app.
however without access to the original developer s private key it is practically impossible to use the same certificate for signing the app.
a common way to implement an integrity check is to compute the hash code of the signature certificate extracted from android s package manager and to compare it to an expected value.
alternatively an app may also use the computed hash to decrypt data e.g.
dynamically loaded code.
to circumvent such checks fuzzdroid contains a value provider that fuzzes api calls that access an app s signature.
instead of the real certificate of the actually running app the value provider returns the certificate that was used to sign the original uninstrumented app effectively fooling the check.
e. primitives as strings v alue provider java supports various api calls for data type conversion e.g.
to convert a string into a numeric value viainteger.valueof .
such conversions give hints on the expected format of unknown data.
the most common case are boolean flags that malware apps reads from android s shared preferences as strings true or false .
these strings are then converted to boolean flags that may determine whether the target location executes.
most of the time the behavior is disabled by default.
only upon e.g.
a request from a remote command and control server the app enables the flag in the file i.e.
changes the file contents to true in order to enable the malicious behavior.
the primitives as strings value provider uses static data flow analysis to track data flows from code locations where values are obtained e.g.
file reads or the properties.getproperty method to data type conversion methods.
if the analysis is able to identify the type of the primitive the value provider picks a value from a pre defined set of random values of the correct type.
v. i mplementation we use soot with the dexpler front end for android to statically analyze and dynamically instrument the apps.
for implementing data flow analyses we build upon flowdroid .
the fuzzdroid framework runs on a desktop computer while the app runs on an android emulator.
both communicate via a tcp connection e.g.
to request environment values or to report which path is executed.
to intercept fuzzed api calls we use a user space hooking library zhooklib3 based on the xposed framework4 .
some malware apps contain timing bombs i.e.
actions that are only executed after a certain time.
to avoid having to wait for this time span we statically patch those statements during our instrumentation phase and decrease the waiting time to a few seconds.
vi.
e v aluation we evaluate the effectiveness and efficiency of fuzzdroid by applying it to malicious android apps.
our evaluation focuses on the following research questions how effective is the approach at finding an environment that enables an app to reach a target location?
how effective are fuzzdroid s use of multiple analyses and the way these analyses are combined with each other?
how efficient is the approach?
what do the environments generated by the approach reveal about real world malware?
how does fuzzdroid compare to the best existing approach for generating inputs that steer an android app toward a particular location?
a. experimental setup we randomly collected recent malware apps from virustotal5in june .
as target locations we use call sites of seven api methods related to sms messages e.g.
5online malware database authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
approach launch launch triggerfuzzdroid apps with 1target reached .
.
.
target locations reached .
.
.
when target reached min avg max executions .
.
time to target seconds size of environment .
contributing analyses .
table i overview of results .for v alues summarized over multiple applications we provide the minimum av e r ag e maximum v alues .
sendtextmessage .
sending sms messages and aborting incoming sms messages are a common threat for android applications .
out of the apps apps contain at least one target location.
as environment apis we use api methods.
we run fuzzdroid on a server with intel xeon e5 cpus running at .
ghz and tb of physical memory.
we configured fuzzdroid to run at most executions and to start the genetic recombination after runs.
b. effectiveness in reaching a target location we evaluate the effectiveness of fuzzdroid at finding an environment where the application reaches a target location.
furthermore we compare the approach to two simpler approaches simply launch the app and hope that it will reach the target location without further intervention and launch the app and trigger specific events such as clicking a button or sending an sms message as described in section iii b2.
in neither of the two simpler approaches we generate a particular environment.
instead if the app calls environment apis the emulator s default values are returned.
table i shows our results.
we find that running the app under the right environment is crucial for reaching the target location.
the default environment of the emulator is insufficient for most current malware.
furthermore the results show that fuzzdroid is effective in generating an environment that successfully reaches the target location.
in total the approach reaches different target locations .
.
in some cases fuzzdroid fails to reach the target location.
for example several malware apps contain malicious behavior which is however not yet enabled and thus never called.
we conjecture that the app will be updated at some point to actually activate the malicious behavior that is already present in the code.
c. importance of multi analysis approach to evaluate how much the individual analyses of fuzzdroid contribute to the framework s overall effectiveness we first evaluate the framework with all analyses enabled.
then we disable each analysis in turn i.e.
run the framework with all but one analysis and then run it with a single analysis.
the result indicate how much the effectiveness decreases if thissymbolic constantfile integrity check primitives as strings all value providers020406080100 2962targets reached all except this value provider only this value provider fig.
.
effectiveness with different subsets of all value providers.
executions target locations fig.
.
executions required to reach target location.
analysis is left out.
the results in figure show that there is no single analysis that can be left out without a negative impact i.e.
all analyses are necessary.
this shows that only a framework supporting multiple interacting analyses such as fuzzdroid is able to find correct execution environments for state of the art malware.
d. efficiency table i shows how long fuzzdroid takes to find an environment under which the application reaches the target location.
on average it takes seconds to reach a target location.
most of the time .
seconds is spent for executing the app.
in contrast both instrumenting apps .
seconds and statically analyzing apps .
seconds are secondary for the overall time.
figure shows the number of executions required by fuzzdroid to reach the target location.
in many cases the target location is reached in a single execution i.e.
the first generated environment is sufficient.
for a substantial number of apps however the approach tries two to seven environments showing that incremental fuzzing is required to reach the target location.
the maximum number of executions needed during our evaluation is .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
environment size target locations fig.
.
size of environment to reach target location.
kind of environment values prevalence file access .
sim network operator code .
specific incoming sms message .
sim operator name .
timing bomb .
sim country .
integrity check .
admin check .
others .
table ii prev alence of different kinds of environment v alues .
e. environments generated by fuzzdroid number and size of environments the environments required to reach a target location range from trivial environments where simply starting the app in the default emulator is sufficient to complex environments with dozens of values.
across all apps where a trivial environment is insufficient fuzzdroid creates different successful environments which would be impractical to create manually by a human analyst.
figure shows the sizes of the environments generated by fuzzdroid.
for several target locations no particular environment is required i.e.
the environment size is zero.
for most others two to ten different environment values must be combined to reach the target location showing that fuzzdroid is highly beneficial for a security analyst interested in triggering malicious behavior.
in some cases the environment even consists of more than values.
examples of environments beyond being useful for security analysts fuzzdroid allows us to better understand how current malware interacts with the android environment.
the environments generated for several apps show that targeted attacks against a particular country network operator etc.
are common in current malware.
table ii summarizes the kinds of values we find in the environments that reach a target location.
the following discusses several representative examples.
a very common kind of interaction with the environment is to access information from files.
besides such file accesses various malware apps target particular sim network operators or check the sim country code.
for example some apps expect sim operator names to be mts or megafon two prominentnetwork providers in russia or to match the regular expression tele as in telecom .
we also find several malware apps that target specific countries either by attacking users in a particular country or by checking that users are not located in a particular country.
another interesting interaction with the environment are so called timing bombs where the malicious behavior only gets executed after a specified time has passed.
this technique has been crucial for many malware samples to be accepted into the official google play store without being detected .
perhaps surprisingly relatively few of the apps in our sample check whether the user grants the app device administration privileges.
packed malware during the evaluation we encountered a malware app with an unusually low number of classes.
since all api calls are obfuscated through reflection the malicious behavior is not directly visible.
instead the app uses two additional files to hide more code.
the original apk file generates a new dex file responsible for unpacking the encrypted malware.
the decryption key is derived from the hash of the certificate with which the original apk file was signed.
this dependency between certificate and decryption key is supposed to protect the integrity of the malware against e.g.
bytecode instrumentation.
after discovering through manual inspection that the malware may show a fake user interface asking about credit card information we set the showfakedialog call as the target location.
fuzzdroid then finds an environment that circumvents the integrity check and makes the malware app believe that the app of commerzbank a major bank is opened.
only if both conditions hold the phishing dialog is shown.
this example illustrates that fuzzdroid is able to handle applications with dynamically loaded dex files what kind of techniques current malware uses for hiding its malicious behavior.
f .
comparison with state of the art approach intellidroid is the conceptually closest approach to fuzzdroid.
still there are important differences.
first intellidroid is solely based on constraint solving and does not support multiple analyses.
second intellidroid has a different notion of runtime values.
while we consider all values that are dynamically computed inside the app as runtime values intellidroid obtains only the current device state such as the current time or the registered alarm managers.
only this information becomes part of the constraint system.
therefore if an app such as the one in listing dynamically decrypts data this data is unavailable to intellidroid.
third intellidroid does not intercept api calls made within the app but relies on externally triggered events such as sending an sms message.
this approach fails for the check on the mobile operator in our example.
fourth intellidroid runs the app under analysis only once and therefore cannot exploit runtime feedback.
finally intellidroid requires a lot of manual interaction with the tool and provides little automation.
due to the lack of automation we apply intellidroid to a random sample of of our malware apps.
we pick apps that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
contain at least one target location that is not immediately reached when starting the app or when triggering an event.
in total intellidroid reaches of the target locations in the sample whereas fuzzdroid reaches .
we conclude that our approach successfully addresses important limitations of intellidroid that prevent the state of the art tool from reaching various target locations.
vii.
l imitations fuzzdroid currently assumes that it is sufficient to trigger a single path to reach the target location.
for example if an app requires a first sms message to set a flag and then only executes the malicious code when a second sms message is received after the flag has been set fuzzdroid cannot trigger the malicious behavior.
analyzing dependencies between multiple events is subject to future work.
our current research prototype is based on an intracomponent callgraph generated with the help of flowdroid .
to detect environment checks that are distributed across multiple components fuzzdroid must be extended with inter component analysis tools such as epicc for callgraph construction or iccta for data flows.
viii.
r elated work a malware analysis inx f orce peng et al.
propose a binary analysis engine which forces the execution of a program into specific branches.
their approach makes the program agnostic of the execution environment revealing hidden behavior in malware.
goldeneye exploits several virtual environments executed in parallel.
the tool adaptively switches the analysis environment at runtime through a specially designed speculative execution engine.
moser et al.
tackles a similar problem for x86 code as we do in our work for android.
they use a dynamic approach in combination with system snapshots of the execution to execute code statements that produce a malicious behavior.
to explore different paths the program state is reset to earlier snapshots.
the values on which the conditionals depend are updated to force different branches when the execution is resumed.
kolbitsch proposes a hybrid approach that combines a light weight form of static symbolic execution with an instrumentation of additional code statements for a multi path execution on javascript code.
abraham et al.
also propose a hybrid approach for reaching a certain target location.
their approach has an success rate of and less on current android malware and does not report information about the environment.
triggerscope is a pure static approach that relies on symbolic execution for extracting environment information.
being purely static their approach does not support dynamically loaded code and cannot exploit runtime feedback.
fuzzdroid in contrast is a hybrid approach and the generated environments are validated dynamically.
b test generation and search based testing symbolic and concolic testing generate inputs by reasoning about path constraints .
in contrast fuzzdroid applies symbolic reasoning to individual data flow paths which improvesscalability.
evodroid also uses evolutionary testing for android apps.
mirzaei et al.
create an android system model in java pathfinder to apply symbolic execution to the whole app for increasing test coverage.
thummalapenta et al.
generating method call sequences through a combined dynamic static analysis.
similar to our approach malburg and fraser combine symbolic execution based on java pathfinder with a genetic algorithm that negates individual conditions during mutation.
all these approaches aim for high coverage whereas fuzzdroid aims at reaching a particular target location.
jensen et al.
concolically execute events handlers to find sequences of handlers that reach a given target.
in contrast to their work fuzzdroid reasons about the environment of an app not the order of triggered events.
baars et al.
combine symbolic execution with dynamic analysis to improve the efficiency of search based testing.
applying their fitness function to fuzzdroid is interesting research for future work.
extracting constants from the bytecode is a promising seeding strategy in search based software testing as shown by previous research .
however for current android malware applications this seeding strategy must be combined with other value providers as we have shown.
droidfuzzer also applies fuzzing to android but creates data for activities that accept mime data such as media data.
a related approach fuzz tests the messages provided to an app via intents.
both techniques aims at triggering bugs whereas fuzzdroid provides information for a security analyst.
ix.
c onclusions this paper presents fuzzdroid a framework for automatically generating an environment under which an android malware app exposes its otherwise hidden malicious behavior.
the framework uses an extensible set of value providers to fuzz the return values of apis used by the app to interact with its environment.
given a set of target locations an evolutionary algorithm based search strategy steers the app to a target by combining suitable environment values.
our evaluation with real world malware apps shows that fuzzdroid effectively and efficiently reaches target locations and that it outperforms the closest existing approach.