automatic runtime recovery via error handler synthesis tianxiao gu chengnian sun xiaoxing ma jian l zhendong su department of computer science and technology nanjing university china department of computer science university of california davis usa tianxiao.gu gmail.com cnsun ucdavis.edu xxm nju.edu.cn lj nju.edu.cn su cs.ucdavis.edu abstract software systems are often subject to unexpected runtime errors.
automatic runtime recovery arr techniques aim to recover them from erroneous states and maintain them functional in the field.
this paper proposes ares a novel practical approach for arr.
our key insight is leveraging a system s inherent error handling support to recover from unexpected errors.
to this end we synthesize error handlers in two ways error transformation andearly return .
we also equip areswith a lightweight in vivo testing infrastructure to select the promising synthesis method and avoid potentially dangerous error handlers.
unlike existing arr techniques with heavyweight mechanisms e.g.
checkpoint restart and runtime monitoring our approach expands the intrinsic capability of runtime error resilience in software systems to handle unexpected errors.
ares s lightweight mechanism makes it practical and easy to be integrated into production environments.
wehaveimplemented aresontopofboththejavahotspot vm and android art and applied it to recover from realworld bugs.
the results are promising aressuccessfully recovers from of them and incurs negligible overhead.
ccs concepts software and its engineering error handling and recovery keywords automatic runtime recovery jvm exception handling .
introduction deployed software systems are subject to runtime errors.
some of these errors can be anticipated and recovered by programmatically prepared error handlers.
for example reading a non existing file is invalid and the programmer needs to explicitly tackle this case by following the usagedescription of certain apis.
the other errors refer to unanticipated errors that are usually related to bugs in programs e.g.
divide by zero invalid memory access .
ideally these errors or bugs should all be eliminated before release but in reality some slip through the software testing phase and manifest after release and deployment.
different from anticipated errors handlers usually do not exist for unanticipated errors.
thus when triggered they may lead to system failures and incur expensive losses including security exploits data corruptions and system unavailability.
automatic runtime recovery tomitigatethisproblem a number of techniques have been proposed to make a deployed software system resilient to runtime errors.
that is once an unanticipated runtime error occurs in the field these techniques try to recover the system from the faulty state to a good one in which the system can still function for subsequent usage.
this process is usually referred to as automatic runtime recovery arr .
arr techniques typically consist of two stages amending runtime states to recover from an unanticipated error and validating the correctness or feasibility of the recovery action.
generally they can be categorized into two classes heavyweight and lightweight.
the former class relies on heavyweight mechanisms e.g.
checkpoint creation and restoration online validation by restart or re execution expensive instrumentation to validate the recovery.
for example armor dynamically replaces a piece of problematic code snippet with another equivalent code snippet provided by developers and uses checkpoint to rule out invalid recovery solutions.
although in this class various recovery techniques have been proposed the significant runtime overhead is still a major challenge for heavyweight approaches to be practical.
lightweight approaches are usually more efficient but may be less effective than heavyweight approaches due to their aggressive nature and insufficient validation of a recovery.
for example foc simply discards any invalid memory write and synthesizes a type specific default value for invalid memory read for server applications.
recently a novellightweightapproach rcv hasbeendemonstrated to be effective to some extent in practice.
however rcv has no proactive validation but passive error containment.
as the errorcontainmentonlytakesaccountofpartsofthedataflow persistent data may also be ruined by manufactured recovery indirectly.
besides the control flow may be impacted by the error and leads to infinite recurrences of erroneous states.
aresin this paper we propose a lightweight approach referred to as ares for runtime error recovery.
at the high permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
level our approach expands the intrinsic capability of runtime error resilience existing in software systems to handle unanticipated errors.
aresis lightweight barely incurring any overhead on normal program executions.
furthermore instead of relying on heuristics to generate a singlerecovery action aressynthesizes multiple error handler candidates at a time and uses a virtual testing technique to select the most promising one.
arescan successfully avoid infinite recurrences of erroneous states due to its adaptive and context sensitive nature.
concretely once an unanticipated error occurs we analyze the current call stack and synthesize a set of recovery solutions by collecting error handlers residing on the stack or synthesizing new error handlers .
next we determine which handler is the most viable in terms of minimizing the negative impact on the subsequent computation.
we perform an in vivo testing to analyze the impact of every handler.
that is we continue the execution by interpreting the buggy program after applying each recovery solution in a confined virtual execution environment viz.
a sandbox .
note that this in vivo testing is invoked in an on demand manner only if an unanticipated error occurs so it will not impact the performance of normal program executions.
finally we choose the most promising recovery solution apply it to and continue the host execution.
in this paper we use the following two lightweight strategies to synthesize error handlers error transformation transforms an unanticipated error to an error of another type which has a proper handler on the method call stack.
early return simply ignores the unanticipated error and returns to the caller with a default value i.e.
nullfor reference types.
we have realized the proposed technique on top of java hotspot vm in openjdk.1we embed java pathfinder jpf into hotspot vm and use it as the virtual execution environment for in vivo testing.
the system is evaluated on bugs in large real world programs and can successfully recover from of them.
we have also implemented a mobile version of areson top of android art.2it can successfully recover from out of real android app bugs avoiding crashing these apps.
compared to regular java programs recovering from these app bugs is equally important.
a survey on mobile apps shows that of mobile users would not use a mobile app any more if it is unable to work at the first or second time.
in order to ensure reproducibility we have made all the data used in this paper i.e.
source code of aresand the program subjects for evaluation publicly available at http lab.artemisprojects.org groups ares .
these large real world buggy programs will also benefit the research community by providing a benchmark suite for evaluating various bug detection recovery and fixing techniques.
contributions our main contributions are as follows we propose a lightweight framework to perform arr by exploiting and extending the intrinsic error resilience of software systems.
we propose a sandbox approach to evaluating the effectiveness of multiple recovery solutions and also a set of ranking strategies to choose the most viable one.
implementation ares is built on top of the widely deployed java hotspot vm and android art making it easy to be integrated into production environments.
aresintercepts the internal exception handling mechanisms in the two vms so the runtime overhead is negligible during normal program executions.
the evaluation of aresis promising.
we have applied aresto real world bugs from large software projects anditcansuccessfullyrecoverfrom39ofthem.
because their software systems lack intrinsic error resilience the non recoverable bugs by aresrequire more advanced recovery strategies which we leave as future work.
paper organization the remainder of this paper is organized as follows.
section introduces necessary background on exceptions in java and section demonstrates how ares recovers from runtime exceptions via two illustrative examples.
section describes the design and implementation of ares.
section presents our evaluation results.
section discusses the limitation of aresand other design decisions.
section surveys related work and section concludes.
.
exceptions in ja va this section briefly introduces necessary background on java exceptions to provide proper context for our work.
.
exception handling mechanism the java programming language has a built in exception handling mechanism.
the basic construct is a try catch block composed of a tryblock and a catchblock that catches exceptionsthrowninsidethe tryblock.
a catchblockdeclares a catchable exception type eh that is any exception of type ehor a subtype of ehis catchable by the catchblock.
we denote a try catch block as ls le lc eh try catch block where lsandleare the start inclusive and end inclusive of thetryblock lcis the start inclusive of the catchblock eh is the catchable exception type.
note that multiple try catch blocks can share the same tryblock.
without ambiguity we use exceptions and errors interchangeably in the remainder of this paper.
in jvm once an exception of type eis thrown at a location l jvm looks up an exception handler inside the current method on the top of the call stack.
if there exists a trycatchblock ls le lc eh where ls l l le e eh the execution jumps to this handler lc.
otherwise the stack frame of this method is popped out and the exception is delivered down to the stack.
the same procedure repeats for each method frame until an exception handler is located or the stack becomes empty.
.
exception hierarchy figure shows the hierarchy of exception types in java.
generally there are two types of exceptions checked exceptions checked exceptions are used to indicate that certain anticipated errors may happen and must be noticed by programmers.
therefore programmers should explicitly use a try catch block to catch and handle these exceptions or deliver them up to the caller.
this is enforced by the type system of java.
for example reading a non existing 3the operator denotes subtyping relation.
685throwbale error exception ioexceptionruntime exceptionclass notfound exception filenot found exceptionnullpointer exceptionchecked exception unchecked exception figure java exception type hierarchy.
file will throw an exception of filenotfoundexception .
thus when reading a file the programmer needs to either catch this exception or let the caller handle it.
unchecked exceptions unchecked exceptions do not require programmers to explicitly handle them as they are often assumed not to occur during execution.
thereby such an exception may crash the program unexpectedly.
unchecked exceptionsinjavacanbefurtherclassifiedintotwocategories error i.e.
java.lang.error and runtimeexception .
the former category refers to errors related to java virtual machines such as outofmemoryerror and stackoverflowerror which are usually not recoverable for programmers.
on the other hand runtimeexception and its subclasses are often symptoms of programmers bugs which are not expected to manifest at runtime e.g.
nullpointerexception .
for simplicity we will use unchecked exception to refer to the latter category.
in this paper we focus on the recovery of the unchecked exceptions namely maintaining the system functional for subsequent usage by surviving unanticipated unchecked exceptions.
when there is no ambiguity we use error and unchecked exception interchangeably in the remainder of this paper.
.
illustrative example this section presents two examples to illustrate how ares recovers a software system from unanticipated runtime exceptions with its two types of error handler synthesis strategies i.e.
error transformation and early return.
.
recovery via error transformation we use a real security bug of tomcat to demonstrate how aresrecovers the system from the manifestation of this bug via error transformation.
figure 2a shows this information disclosure security bug cve .
themethod fireoncomplete online5realizesthe observer design pattern.
the listeners are registered to be called on some events and may be implemented by third party developers.
a listener may be buggy and therefore it is possible that the method call on line abnormally exists with an unchecked exception.
however the catchblock on line only handles ioexception .
this exception will be propagated along the stack and results in the server failing to recycle the data of the current web request.
consequently the leaked data later becomes accessible for the next web request.
ifaresis deployed this security exploit can be prevented.
errortransformationwillautomaticallyconverttheunchecked1for asynclistenerwrapper l listenerscopy try bug an unchecked exception may be thrown in the call below.
l.fireoncomplete event catch ioexception e a tomcat bug cve 1for asynclistenerwrapper l listenerscopy try l.fireoncomplete event catch ioexception ioe catch throwable t exceptionutils.handlethrowable t b patch figure tomcat bug cve and its patch.
bug getdigest ... may return null stringmd5a1 getdigest username realm .tolowercase locale.english 3if md5a1 null return null a tomcat bug string md5a1 getdigest username realm fix check value of 3getdigest ... 4if md5a1 null return null md5a1 md5a1.tolowercase locale.english b patch figure tomcat bug and its patch.
exception thrown on line into an ioexception object which will be immediately processed by the handler on line preventing information leakage.
in fact the official patch shown in figure 2b is very similar to our recovery process.
it just makes the catchblock capable of handling every exception i.e.throwable .
the recovery strategy error transformation aims to exploit the error resilience existing in software systems i.e.
existing exception handlers to handle unanticipated unchecked exceptions.
it is also similar to one of the common ways developers cope with unchecked exceptions namely catching the unchecked exception converting it to another type and re throwing the new exception.
.
recovery via early return this subsection shows another tomcat bug which can be recovered by the strategy early return .
figure 3a displays tomcatbug54438.
online2 themethodcall getdigest may return nullif the username does not exist.
this nullfurther triggers a nullpointerexception when we use the returned digest i.e.
null to invoke another method tolowercase .
to recover from this exception aresintercepts the internal exception handling of jvm.
it then ignores the exception and returns nullfor the call to tolowercase .
however from the perspective of overhead ares s synthesized error handler does not incur additional overhead on normal program executions.
figure 3b shows the developer s patch to this bug which is equivalent to our synthesized error handler although in 686virtual machine java pathfindercall stackpatchercall stack rankerexceptionsynthesizer .error handlers .copy program states .most viable error handler figure the overall framework of ares.
different representations.
it first checks whether the return value of getdigest isnull.
if yes then it returns from the current method.
similar to error transformation the strategy early return is inspired by another common way in which developers handle unchecked exceptions that is catching an unchecked exception and returning from the current method with a default value e.g.
for numerics types and null for reference types .
.
approach this section describes our approach for arr.
figure shows the overall framework of ares.
jvmour approach is built on a regular java virtual machine jvm .
it is used to execute programs in normal mode.
aresonly intercepts the exception handling of the underlying jvm.
once an error of interest occurs e.g.
unanticipated unchecked exceptions aresstops jvm takes over the execution and starts the recovery process.
synthesizer basedonthethrownexceptionandthecontent of the call stack in jvm the synthesizer generates a set of candidate solutions for recovery i.e.
error handlers which will be tested in a sandbox to assess their capabilities of recovering from the exception.
jpfwe use java pathfinder jpf as the sandbox because it supports checkpoint and restoration facilitating program state exploration and rollback.
in detail once we start the recovery process a jpf instance is created and initialized with the program states in the host jvm.
we apply a synthesized error handler in jpf each time until all handlers are tested.
ranker after the testing of jpf we propose an effective heuristic to rank these error handlers and return the most promising one.
patcher the patcher will realize the error handler returned by the ranker in the host jvm on the fly.
then the program execution resumes.
.
identifying errors of interest arespiggybacks on the internal exception handling mechanism of jvm.
when an exception is thrown aresfirst checks whether the exception is of interest and then attempts to recover from it if yes.
aresonly checks and recovers from the exceptions that satisfy the following two conditions .the exception must be an unchecked exception an object of runtimeexception or its subtype.
we omit checked exceptions as they have been explicitly handled by programmers which is enforced by the java type system.algorithm force throwable error transformation input angbracketleftm1 mn angbracketright the recovery context input e an unchecked exception output an exception type to which ecan be transformed 1fori 2tondo h exception handlers in method mi li the location of the call to mi foreach handler ls le lc eh hdo ifls li li lethen return eh 7return null .the unchecked exception should have no correspondingeffective error handler.
apparently an unchecked exception is of interest if it has no error handler in the whole call stack.
we also consider another type of unchecked exceptions that are handled by a trivial overly stated catchblock e.g.
unchecked exceptions caught by catch throwable e ... .
we refer to the first type as uncaught exception and the latter as trivially handled exception .
.
error handler synthesis we synthesize error handlers in two ways error transformationandearly return .
before detailing them we introduce a notion recovery context to facilitate the description.
recovery context given a thrown exception e lethbe the stack frame which has a catchblock to handle e. then the recovery context of eis the sequence of frames in the stack from the top frame tto the frame above h exclusive ofh i.e.
t h .
we also use angbracketleftm1 mn angbracketright m1is the top frame to denote a recovery context.
take figure as an example.
an unchecked exception is thrown in the method call fireoncomplete event on line .
this exception cannot be handled by the existing handler for ioexception on line and is handled by a catch block for throwable in a method frame endnear the bottom of the call stack.
therefore the recovery context for this exception is the stack frames from the top frame to the frame right aboveend.
for a trivially handled exception we only try to recover from it before the last frame of its recovery context.
if we fail to synthesize a proper error handler we will honor the original semantics of the program and let the programmed error handler take charge of the execution.
.
.
force throwable error transformation the simplest way to reuse existing error handlers is to make every catchblock catch throwable .
thus we propose the force throwable error transformation ftet in algorithm .
ftet ignores the type of the raised exception and usesonlythelocationinformationtosearchforerrorhandlers.
as java is type safe we also need an error transformation that converts the unchecked exception to the exception that thecatchblock declares.
.
.
stack based error transformation a method should only throw a checked exception that is declared by the method.
therefore we propose the stackbased error transformation sbet in algorithm .
in 687algorithm stack based error transformation input angbracketleftm1 mn angbracketright the recovery context input e an unchecked exception output a set rof checked exception types to which e can be transformed 1r ?
2fori 2tondo h exception handlers in method mi s checked exceptions declared by method mi li the location of the call to mi foreach handler ls le lc eh hdo ifeh s ls li li lethen r r the type of eh 9return r 1public void printmultiln string s int index look for hidden newlines inside strings while index s.indexof n index javaline index writer.print s figure tomcat bug sbet not any arbitrary checked exception can be the target exception of error transformation.
first the target exception should have a proper error handler in the recovery context.
second the checked exception must be declared by one of the active methods in the recovery context.
in algorithm once an unchecked exception eis thrown in the method m1 we check whether its callers from m2to mn have available exception handlers which we can leverage to handle e. specifically if a method mideclares to throw an exception eh tested by eh son line and there is a handler for this exception then we can transform etoeh.
.
.
early return this recovery strategy takes as input two parameters a number n n of stack frames to pop out of the call stack and a value vof the return type.
once an unanticipated error occurs this strategy pops nstack frames from the call stack and returns vas the return value.
if n we name this early return as first early return fer .
these two parameters should be carefully chosen otherwise early return will result in dense cascaded exceptions or introduce other unexpected program behavior after recovery.
in particular the major challenge of early return is how to fabricate a good return value.
in foc and rcv they use the default value of a type e.g.
0for integers nullfor object types.
however this may be problematic.
take figure i.e.
tomcat bug as an example.
the bug happens when the parameter sisnull leading to a nullpointerexception when we call indexof on line .
if we choose v 0and return it as a default value implemented in foc and rcv then the loop becomes infinite.
different from foc and rcv which propose a single recovery solution aresproposes a bounded number of parameters to perform early return recovery.
we then use jpf to evaluate these parameters which is able to weed out inappropriate parameters.
more details are available in section .
.
void only early return voer although it is difficult to choose a good value to return from the domain ofa type it is easy to choose a value for type void which is voiditself.
we specialize early return by only returning from a method with voidreturn type.
void only early return voer just walks along the stack to locate the first method with void return type and then makes an early return there.
there may not be such a method.
hence voer may fail to recover from some exceptions.
.
evaluating synthesized handlers as shown in figure after generating a set of error handlers for a runtime error we invoke jpf to test the applicability of each handler.
specifically areswalks through the stack in the host jvm to collect necessary information to quickly instantiate an instance of jpf.
each time jpf applies one error handler and checks whether it can recover the system from the bug.
thanks to the built in support for state checking and restoration of jpf to test a handler we first save the current state in which the buggy thread is about to crash and then apply the error handler.
if the execution stops jpf restores the state and starts over to test another error handler.
after all error handlers are tested jpf returns a set of viable error handlers which are later ranked by the ranking strategy elaborated in section .
.
.
.
.
evaluating an error handler given a runtime error thrown in the top stack frame m1 let angbracketleftm1 mn angbracketrightdenote its recovery context.
before jpf executes any code of the synthesized error handler a number dof call stack frames need to be popped out.
take error transformation as an example if the target error handler is inmi then stack frames should be popped out first.
the same procedure also applies to early return.
the jpf execution begins at the target error handler in mi.
theexecutionmaycallnewmethods createnewstackframes and increase the stack size.
but these new stack frames do not belong to the recovery context.
during the execution there is a lowest stack frame mjin the recovery context.
we use mi mj in measuring the length of testing as they are related to the context in which the exception is thrown.
the length j i is denoted as c. besides we also record the number of executed instructions as s. intuitively these two metrics are complementary in measuring the confidence of the jpf testing execution.
the handler evaluation may stop in one of the following scenarios no error all methods in the recovery context complete their execution normally.
timeout in order to maintain responsiveness of the system underrecovery westoptestingthecurrenterrorhandler if a maximum number of instructions specified by the parameter timeout has been executed.
uninterpretable behavior the jpf execution encounters a vm behavior that it cannot interpret e.g.
a call to uninterpretable native code.
cascaded error the applied error handler in jpf execution triggers another runtime error.
finally the testing result of an error handler is represented as a tuple t r d s c where tis the type of the error handler either error transformation or early return ris the stop scenario of the jpf execution dis the number of discarded stack frames in the recovery context sis the number of 688executed instructions cis the number of stack frames in the recovery context that have completed their execution.
.
.
ranking error handlers the ranking heuristic is designed based on observation that the most promising error handler usually outperforms others in two aspects fewer discarded stack frames which is measured by d and longer jpf testing which is measured bysandc.
first we classify testing results as either benignormalignant.no error andtimeout are straightforwardly treated as benign.
for uninterpretable behavior andcascaded error their executed instructions smust exceed a threshold steps.
forcascaded error despite steps their exercised stack frames cmust further exceed another threshold frames .
any other result is treated as malignant.
for benign error handlers their online testing reflects high confidence.
thus we prefer the one with fewer discarded stack frames d. if two testing results have the same d we choose the one with more executed instructions.
malignant error handlers are only used when there is no benign one.
for these error handlers their online testing brings poor confidence.
thus we simply prefer the one with more executed instructions.
.
implementation we have implemented areson two popular platforms java hotspot vm and android art.
this design decision enables our approach to be a drop in substitute for standard vms and easy to deploy in production environments without complex configurations.
.
.
areson java hotspot vm thejavahotspotvmisanopen sourceindustrial strength jvm.
it has been distributed as the default jvm vendor for popular linux distributions e.g.
ubuntu and fedora .
we intercept the standard exception handling mechanism of hotspot to identify errors of interest and perform recovery.
in this way our recovery system has little impact on the performance of software systems in normal execution i.e.
when no unanticipated errors occur .
there is even no overhead when no anticipated or unanticipated exceptions occur which is usually the case for majority of execution time.
we embed jpf in the host jvm to test synthesized error handlers and invoke it on demand when recovery is required.
when a thread is about to crash due to an unanticipated error of interest we intercept the error handling process and start a jpf instance to continue the execution by applying an error handler in the same thread.
specifically we first create a call stack for jpf by duplicating the stack frames of the recovery context the top frames in the call stack of the about to crash thread in the host jvm.
then the program execution is altered with an error handler and resumed in this jpf instance.
this process is repeated with each iteration applying a different error handler.
lastly we rank these error handlers and choose the most promising one.
as jpf and jvm have different object models when jpf needs to access an object in the host jvm at runtime aresconverts that object to the representation of jpf.
in order to reduce runtime overhead we only convert jvm objects on demand that is we only convert the minimally sufficient objects when they are requested.
after the testing for a handler completes aresresets all values of objectstable programs used in our experiments.
bugs recovered tomcat web application server jetty web application server jmeter gui application ganttproject gui application android various mobile apps total for the next testing.
interactions with external resources e.g.
files databases are uninterpretable behaviors that are not supported by jpf.
these behaviors should indeed be forbidden as they may induce side effects on the host execution during online testing which are difficult to revert when jpf tests another error handler.
if a synthesized error handler is applied for recovery ares does not persist it in the buggy method for future program execution.
this is mainly because the error handler is synthesized based on the context e.g.
method call stack in which the error manifests.
next time the method encounters the same error areswill synthesize another error handler based on the context which may be different from the previous handler as the context may differ.
.
.
areson android art the mobile version of aresis implemented on top the new android art released in android .
.
.
we modify the art runtime and deploy it in a nexus mobile phone.
however currently we only implement a conservative strategy in art instead of embedding jpf.
android art uses a different byte code representation i.e.
dalvik and a different layout of stack frames which is not supported by jpf.
our conservative strategy in android art first attempts toapplysbet.ifsbetisnotapplicable itthenattemptsto apply voer.
if both fail we just abort the recovery process.
our evaluation on nine bugs in real world android apps shows that this strategy is always able to find an appropriate error handler.
.
experiments to demonstrate the effectiveness of ares this section presents our extensive evaluation of areson widely used web servers desktop gui applications and mobile apps.
the experiments on server and desktop applications were conducted on a linux machine with intel quad core i7 .4ghz cpu and gb memory those on mobile apps were done on a nexus smart phone.
we have evaluated aresonall exception related bugs that we were able to reproduce from several widely adopted projects and aressuccessfully recovered from of them e.g.
the program can continue running to serve new user requests.
the non recoverable bugs are mainly due to lack of intrinsic error resilience in these software systems.
tackling them requires more advanced recovery strategies besides error transformation and early return which we leave as future work.
program subjects table lists the details of the program subjects used in our evaluation.
both tomcat and jetty are popular java web servers that have been under active development for over ten years and widely deployed in production environments.
jmeter is a web testing tool.
ganttproject 689table acronyms of exception names exception name acronym arrayindexoutofboundsexception aio bufferoverflowexception boe concurrentmodificationexception cme clientabortexception cae deploymentexception de exception e eofexception ee filenotfoundexception fnf illegalargumentexception iae illegalaccessexception ice illegaljidexception ije illegalstateexception ise illegaluseractionexception iua interupptedexception ie ioexception ioe jasperexception je malformedurlexception mue malformedcachepatternexception mcp mpxjexception mpx numberformaterror nfe nullpointerexception npe runtimeexception re servletexception se stringindexoutofboundsexception sio sqlexception sqe throwable t unavailableexception ue unsupportedencodingexception uee unsupportedoperationexception uoe xniexception xni is a project planning tool.
the android apps include web browsers instant messengers and productivity tools.
collection of bugs in order to collect these bugs we first searched the bug repositories revision logs and release notes with the keywords exception or npe .
this step yielded bugs.
then we attempted to reproduce all these bugs according to the instructions recorded in their bug reports.
at last we obtained bugs that were reproducible in our testing environment.
besides almost all bugs were reproduced in a standalone server with a deployed web application or by manually exercising a gui application.
for the other bugs we directly used unit tests provided in bug reports.
to save space and facilitate description we use acronyms of exceptions in the rest of this section as shown in table .
.
evaluation on java hotspot vm we evaluate areswith real world bugs on the java hotspot vm.
in order to better understand the effectiveness of ares we also evaluate four basic strategies with the same set of bugs i.e.ftet sbet fer and voer.
in each basic strategy evaluation given a buggy program we apply the strategy to recover the program from not only the unanticipated exception triggered by the bug but also the cascaded exceptions that are of interest for recovery.
in contrast on each exception of interest areswill adaptively select the most promising error handler based on the context of the exception rather than sticking to a single strategy.
theparametersof aresareconfiguredasfollows timeout step frames .
as algorithm shows sbet returns a set of exception types to transform to.
in the evaluation of the basic strategy sbet we only use the first exception type in the nearest call stack frame as the transformation target.
similarly fer and voer also propose a list of call stack frames to return from as described in section .
.
and we select the top frame as the target in their evaluations.table summary of recovery results on java hotspot vm result ftet sbet fer voer ares n.a.
failure repair plausible recovery repair rate .
.
.
.
.
plausible rate .
.
.
.
.
success rate .
.
.
.
.
the result of a recovery is analyzed in two steps step one we manually check whether the recovery makes software functional for later use.
take ganttproject as an example.
after recovery if we still can make planning we then classify this recovery as effective if the application crashes or we cannot make planning we then classify the recovery as ineffective.
step two if the recovery is effective we further compare thesynthesizederrorhandlerwiththedeveloper spatch.
if they are semantically equivalent then we classify the error handler as a repair otherwise as a plausible recovery.
table summarizes the recovery results.
the row n.a.
represents the number of cases where the corresponding strategy is not applicable e.g.
no existing exception handler for ftet and sbet the row failure represents the number of cases where the corresponding strategy fails to recover from the bugs.
the recovery row is the sum of repairand plausible the repair rate is computed as repair recovery failure the plausible rate is computedas plausible recovery failure andthe success rateis computed as recovery recovery failure .
among the four basic strategies fer is the most effective one.
this observation contributes much to our ranking algorithm.
however fer may result in a catastrophic infinite loop e.g.
the bug in figure .
an infinite loop should be prevented in advance as it may propagate bad effects rapidly.
voer is also effective.
however it results in fewer repairs but more plausible recoveries.
although ftet has more applicable scenarios its repair rate and success rate are slightly lower than sbet.
areshas the best overall recovery result and also results in fewer cascaded exceptions especially compared to fer will be discussed in the following section together with table .
although our ranking heuristic of aresoverall works well in the evaluation it rejects two repairs i.e.
bug and in table and accepts two plausible recovery handlers with fewer cascaded errors than the repairs.
we believe that with an enhanced ranking mechanism the evaluation results will be further improved which we leave as future work.
.
.
details of evaluation table shows the details of our evaluation on the bugs.
the first column shows the unique ids of these bugs in order to conveniently refer to them in this paper and the second column shows the real bug ids in their corresponding bug repositories.
the third column lists the types of exceptions thrown when these bugs manifest themselves.
the multi column basic strategy shows the statistics of recoveries with the four basic strategies.
we only show the 690table recovery of bugs on the java hotspot vm.
bug id errorbasic strategy ares ftet sbet fer voer ftet sbet fer voer final time tcr tcr tcrtcrrdscrdscrdscrdsc trdsccr ms 1tc iae e0fice0fvoid0p10pc42110c42110c15831c15833void1c158330p723 2tc npe e0fje0f0 f21ru14210u14210c1160u21200void2u212001r887 3tc npesqe0rsqe0rvoid0p10pt2 0t2 0u14545u14545void1u145450p862 4tc aio t0fn.a.
void2p11ft3 0n.a.
n1503n1503void1n15032p766 5tc uoe le0fle0fnull7p64pt11 0t11 0t1 1t6 1null1t1 17p249 6tc iae e5fn.a.
void5p15pc12110n.a.
u11600u11600void1u116005p803 7tc npe e10fn.a.
null22fn.a.c11130n.a.
c160n.a.
ec1113010f679 8tc iseioe0fioe0fnull45f50fn86831n86831t1 7t5 3void1t1 75f969 9tc npe t0fioe0fvoid1r10rc73940n77611n15077n15077void1n156770r313 10tc isecae0fioe0fvoid14f114fn24101t2 0n1932n1932void1n19324f869 11tc reioe0rioe0rvoid0p10pc22390c22390t1 4t1 4void1t1 40p1277 12tc npe t0fioe0fnull0r50fn59951t5 0t1 2n52941null1t1 20r766 13tc npeioe0pioe0pnull0p30pc18233c18233c18243c38061null1c182430p836 14tc npe e1pioe0pnull4p40pn161n.a.
c110n.a.
en1611p854 15tc iae t0fioe0fvoid0f10fu330u330u1330u1330void2n2421f635 16tc npe n.a.
n.a.
null0rn.a.
n.a.
n.a.
t1 0n.a.
null1t1 00r591 17tc iseioe0fn.a.
00r20pc47030n.a.
t1 3t2 01t1 30r1131 18tc npede1fn.a.
null4f22fc3480n.a.
c110t1 1void2t1 11f1043 19tc npemue0fn.a.
null39p20fu210n.a.
c1850u210null1c18507p532 20jt npeee0fioe0fvoid16p12ft6 0t6 0u1110u1110void4t4 20p797 21jt npeee0fioe0fnull6f20pc41960t4 0c1100c21872void2c218720p775 22jt npeioe0ffnf0fnull0f20fn1350n1350u1880n242ioen13500f620 23jt ise t3fioe0f02p22pt2 2t4 0t1 3t2 01t1 31p1082 24jt npeiae0fioe0fnull0r20pt4 0c87670u11901u21121null1u119010r1065 25jt sioue0fje0f00f70ft7 0c880u1110u71720null1t2 22f763 26jt boe e0fn.a.
null0pn.a.t1 0n.a.
u150n.a.
et1 01f630 27jt npeioe0rn.a.
void0r10rt1 0n.a.
u19742u19742ioet1 00r714 28jt aio n.a.
n.a.
void0p10pn.a.
n.a.
t1 0t1 0void1t1 00p500 29jt npe t0fioe0fnull5r30fu2930n.a.
c1121n.a.
tu29301p518 30jt npeue0fse0fnull1r31pu49070u49200u121n362null2u214500p765 31jt npe e0fioe0f00f20fc83540u87520t1 0u25796 01t1 00f900 32jm cmeiua0fiua0fnull2p20pt8 0t8 0u15477u29246null1u154772p579 33jm iaeiua1fiua1fnull1r33ft8 0t8 0t1 3u35483null1t1 33r588 34jm npeuee0ruee0rnull0r30pu13010u13010t1 1u32251null1t1 10r745 35jm npemcp0pn.a.
void1p11pu33020n.a.
c11820c11820void2t2 30r494 36gp npe e0fioe0fnull36p29pc61270c61270t1 0t2 0null1t1 036p725 37gp aio ie0fn.a.
null2f30fn.a.
n.a.
u110n.a.
06t6 20f381 38gp npeioe0fioe0f05f52fc91300c91300c170u59230null3u299332f433 39gp reioe1fioe0fnull20p21pc71300c71300c1470c22250void3c348701p361 40gp npexni1rxni1rvoid0f10fc21904c21904t1 5t1 5void1t1 50f703 41gp npempx0fmpx0fvoid1p11pc61280c61280c12576c12576void1c125761p502 42gp npe ie0fn.a.
void0p10pn.a.
n.a.
t1 2t1 2void1t1 20p590 43gp npe e0fioe0fvoid2p11pn.a.
t11 4c1652c1652void4t4 50p417 tindicates the type of error handler.
specifically tis the target exception type for sbet and ftet the return type for fer the discarded stack frames for voer and a pair of the return type and the number of discarded stack frames for generic early return.
cindicates the number of the actual cascaded errors in the host jvm.
rindicates the recovery result.
for recovery result we use f for failure r for repair and p for plausible recovery .
t r d s c is the testing result of the jpf execution described in section .
.
.
for the stop scenario r we use n for no error t for timeout u for uninterpretable behavior and c for cascaded error .
type of the first error that is triggered by the bug.
for each basic strategy we list a tuple including the typeof recovery solutions the number of cascaded errors and the recovery result.
forares we first list the testing result r d s c for each basicstrategy.
notethatsbetandvoermayfailfirst e.g.
bug .
at last we use a tuple for the most promising error handler determined by the ranking including the testing result t r d s c the actual cascaded errors in the host jvm after applying the error handler and the recovery result.
as jpf has its own implementation of a small set of library classes aresmay fail to apply all basic strategies in jpf e.g.
bug and and also result in false cascaded errors that disappear in the host jvm.
ares versus fer the major advantage of aresover fer is the significantly reduced number of cascaded exceptions induced by the recovery handler.
table shows the statisticstable statistics of cascaded exceptions of fer and ares min max stddev mean median fer .
.
ares .
.
of the cascaded exceptions by the two strategies.
we also conducted wilcoxon signed rank test.
the pvalue for the 1tail test is .
showing that the improvement is statistical significant.
note that the results in table are computed by excluding bug in which fer causes an infinite loop triggering infinite number of exceptions.
this bug further demonstrates the advantage of aresover basic strategies.
overhead aresperforms recovery on demand and requires no instrumentation into programs.
thus it imposes no overhead on normal program executions.
the overhead intro6911 method processmatches list matches new arraylist 3if isscopevariable string inputstring vars.get getvariablename bug inputstring may be null if inputstring null log.warn ... return collections.emptylist matchstrings ... matches ... inputstring else ... 12return matches figure jmeter bug and its patch.
1try setformatter formatter cl.loadclass formattername .newinstance catch exception e ignore ignore and fallback to defaults setformatter new simpleformatter figure tomcat bug and its patch.
duced by aresonly occurs when an exception is thrown and the recovery is performed.
as table shows the recovery pausing time of all basic strategies is less than one millisecond and that of aresranges from to milliseconds which is mainly used to bootstrap jpf.
.
.
analysis of bug samples in addition to the bugs discussed in previous sections we further discuss three bugs in detail as follows.
jmeter as shown in figure processmatches calls matchstrings on line to find substrings that match inputstring on line and saves the results in matches which is allocated as an empty list on line .
matchstrings first uses inputstring to create a matcher object.
if the value ofinputstring is null the constructor results in an npe.
fer and voer return from the constructor abnormally and results in a cascaded error in matchstrings .aresdetects the cascaded error and returns from matchstrings directly.
finally the execution returns from the processmatches on line with an empty list.
thus it has the same behavior as the patch except the log on line .
ganttproject this bug makes ganttproject not responsive to any of the bug reporter s requests.
the patch to this bug is two fold it first fixes the broken logic to calculate the correct value for a date range and then adds a catch and ignore error handler surrounding buggy methods as the calculation of date range is non trivial and there may still be bugs.
although arescannot calculate the correct date range it lets users continue editing and saving their work by using early return.
once the edited file is opened with a fixed version helpful warnings will lead users to manually refill the nullified broken date ranges.
thus we claim that ares produces a plausible recovery.
tomcat this bug cannot be fixed by any default error handlers in this paper.
as shown in figure the patch assigns a non default value to the formatter.
currently ares cannot allocate an object instead of null.
using a newallocated object requires to update all related