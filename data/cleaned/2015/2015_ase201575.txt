model checking task parallel programs using gradual permissions eric g mercer and peter anderson brigham young university provo utah usa email eric.mercer anderson.peter byu.edunick vrvilo and vivek sarkar rice university houston tx usa email nick.vrvilo vsarkar rice.edu abstract habanero is a task parallel programming model that provides correctness guarantees to the programmer .
even so programs may contain data races that lead to non determinism which complicates debugging and verification.
thispaper presents a sound algorithm based on permission regions toprove data race and deadlock freedom in habanero programs.permission regions are user annotations to indicate the use ofshared variables over spans of code.
the verification algorithmrestricts scheduling to permission region boundaries and isolationto reduce verification cost.
the effectiveness of the algorithmis shown in benchmarks with an implementation in the javapathfinder jpf model checker .
the implementation uses averification specific library for habanero that is tested using jpffor correctness.
the results show significant reductions in cost where cost is controlled with the size of the permission regions at the risk of rejecting programs that are actually free of anydata race or deadlock.
i. i ntroduction despite the explosion in multi core hardware for general purpose computing writing programs to take advantage of the available processing power is often a task reserved forexpert developers.
the first programs from the uninitiatedoften have more in common with sequential execution thanparallel performance due to excessive synchronization orworse those programs are fraught with concurrency errors dueto an absence of needed synchronization.
the habanero extreme scale software research project intends to bring multi core programming to the masses throughlanguages and frameworks for non experts.
habanero javaitself is a task parallel programming model built aroundlightweight asynchronous tasks and data transfers .
theprogrammer in the habanero framework focuses on the high level task constructs using simple annotations and delegatesto the habanero run time the burden of how to correctly andefficiently implement and synchronize those constructs.
the habanero programming model offers correctness guarantees by defining safe subsets of the language that preserveproperties over concurrent interactions such as determinism serialization and deadlock freedom however many of theseproperties rely on the absence of data races.
regardless ofusing a safe subset of the language there is no easy way todetermine when and if a program is free of data races.
assuch the problem of verification reduces in practice to printf debugging inefficient code inspection and run time failures.
permission regions are program annotations that announce how a task interacts with specific shared objects i.e.
readingor writing and over what region of code that interaction takesplace .
during execution auxiliary data structures trackaccesses at the region on the indicated variables and signalan error on any accesses that conflict with the permissionannotations.
permission regions have been shown effective indynamically detecting data races at run time while requiringonly a small number of programmer annotations for a javaimplementation of habanero hj .
this paper presents a sound model checking algorithm to prove a program for a given input free of data races dead locks failed assertions and exceptions based on permissionregions.
the algorithm treats permission regions as atomicblocks of read write operations on shared memory to reducethe number of schedules that must be considered in the proof.the algorithm also enumerates all outcomes that arise fromnon determinism in sequencing isolated atomic blocks i.e.
non determinism that is intended by the programmer to verifyuser defined assertions and exceptions.
this paper includes aproof that the algorithm is sound for any habanero programwith a fixed input.
as such the cost of model checking ahabanero program is controlled with the size and number ofthe permission regions at the risk of rejecting some programsthat are actually free of data races.
the effectiveness of the algorithm is explored using a new implementation of hj in the form of a verification library hj v and the java pathfinder model checker jpf .
hj v is in tended for debugging testing and verification so it trades per formance for simplicity and correctness by using java threadsfor each task and using global locks with conditions for fea tures of habanero that require mutual exclusion and complexsynchronization.
the library supports all of the constructs inthe habanero model including phasers.
the implementation ofpermission regions with the new model checking algorithm isin an extension to jpf named jpf hj.
an empirical study overseveral benchmarks comparing the cost of verification betweenjpf and jpf hj both using hj v show a significant reductionin the cost when using jpf hj that is dependent on the sizeand number of the permission regions with their interactions.the implementations of both hj v and jpf hj are availableat ii.
h abanero java the habanero programming model is built around a taskparallel view of concurrency.
figure is an hj program usinghabanero s most basic task constructs finish and async.
the finish construct is a generalized join operation for collective 30th ieee acm international conference on automated software engineering .
ieee 1public static void main final string s stack stk initstack launchhabaneroapp finish async stk.push stk.peek fig.
.
an hj program snipet using the async andfinish statements.
synchronization the parent task executes and then waits until all tasks created within the finish construct have completed including transitively created tasks .
theasync construct is a mechanism for creating a new asynchronous task the calling task parent creates a new task child to execute in parallel with the parent.
the child can reador write any data in the heap and can read but not write anylocal variable belonging to the parent s lexical scope.
a taskcreated in an async construct becomes ready for scheduling at the point it is declared in the program.
the program in figure enters a finish construct line where it creates a child task line to write to thestack line .
the parent task then inspects the stack line .the two stack operations are not ordered and execute logicallyin parallel.
the parent blocks at the end of the finishconstruct until the child task completes.
other constructs in the habanero model include isolated and actors for mutual exclusion future for passing data between tasks and phasers for arbitrary point to point synchronization .
iii.
p ermission regions permission regions are programmer added annotations on shared objects .
the regions are indicated as accessingshared objects in read or write mode.
when the programexecutes with run time checking of permission regions en abled a state machine is associated with each shared object totrack permissions on that object as indicated by the programannotations.
if accesses from distinct tasks on the same objectconflict i.e.
a read with a write or a write with a write thena permission violation indicative of a data race is detected.an absence of violations implies an absence of any data races.
to annotate the program in figure with permission regions line and line are wrapped in separate regions writing and reading respectively as follows acquirew stk stk.push releasew stk fig.
.
different schedules for a permission region annotated version of the program in figure with the schedule in the right branch reporting apermission violation.
acquirer stk stk.peek releaser stk the state machine associated with each region to track accesses and detect violations is not shown due to space limitations but it is intuitively understood from the two possibletask schedules in figure for an annotated version of theprogram in figure .
the solid filled ovals and solid linesrepresent the parent task and the dotted filled ovals and dashedlines represent the child task created by the async statement on line .
the squares indicate the current state of the statemachine that is tracking accesses to the shared object stk.
the left branch of the tree is the schedule where the parent task runs until it is blocked to wait for the child task.
theparent task acquires and releases private read privileges on theregion and then the newly created task runs acquiring andreleasing private write privileges.
if this schedule is followedin the run time then the permission violation in the programis undetected.
the right branch is another possible schedulein the run time.
here the child task runs just after the parenttask acquires private read privileges on stk.
when the child task tries to acquire write privileges on stk its state machine detects the violation.
permission regions are distinctly different from mutual exclusion primitives such as locks and the habanero isolatedconstruct.
the isolated construct defines an atomic region that runs mutually exclusive to any other isolated construct and can be used to express non determination that is intendedby the programmer.
as such isolated atomic regions areserialized with respect to one another.
permission regions donot include any serialization or synchronization semantics bythemselves rather they check if concurrent accesses obey thepermission annotations.
536algorithm permission region informed search function search t h t loop h t run t h t s status t t permission violation false ifs prentry then h t permission violation acquire t h t else if s prexit then h t release t h t goto loop end if ifpermission violation then report permission violation and exit end if r runnable t ifr then ifblocked t negationslash then report deadlock and exit else report any uncovered sharing and exit end if end if if h t negationslash sthen sis a global variable s s h t ifs prentry s isolated then for allti rdo search t i h t end for else ti random r search t i h t end if end if end function iv .
jpf hj s earch algorithm permission regions create natural scheduling boundaries for model checking that can be leveraged to mitigate state explosion while preserving the essential behaviors of theprogram that lead to data races deadlocks assertion violations or exceptions since they represent points of execution wheresharing is expected.
the intuition is that given a fixed programinput erroneous behavior can only arise from interactionsbetween tasks on shared memory.
as such it is only necessaryto preempt running tasks at the entrance to permission regionsandisolated constructs.
if a program has any deadlocks data races assertion violations or exceptions for a fixedprogram input then such a deadlock data race assertionviolation or exception exists in one of the schedules that isexplored from those preemption points.
algorithm is the pseudo code for the algorithm to explore all task schedules created at entry to permission regionsandisolated constructs.
the pseudo code only covers the detection of data races i.e.
permission region violations ordeadlocks though assertion violations and exceptions can bedetected similarly.
the state of the program in the pseudo code is simplified for clarity it is represented by a heap h and a set of tasks t. the lowercase tindicates a task.
line updates the heap and pool of tasks by running task tuntil it blocks exits reaches a permission region boundary i.e.
entryor exit or reaches an isolated construct.
at the entry point of the permission region pr entry line updates the state machine for the acquired permissionson the object in the heap and checks to see if the acquisitionsignals a permission violation.
at the exit point of the per mission region pr exit line updates the state machine for the released permissions on the object in the heap and thealgorithm restarts task trunning anew at line .
if there is a permission violation then it is detected on line .
similarly line detects a deadlock.
a deadlockstate is indicated when there are no runnable tasks i.e.
r and there exists tasks that are blocked.
a report for either apermission violation or a deadlock includes a witness trace forvalidation and debugging.
in the absence of a deadlock or apermission violation and when there are simply no more tasksto run line terminates the search and reports any detectedsharing that was not annotated by a permission region orcovered by an isolated construct.
such sharing is detected by tracking tasks on every heap access.
the setson line is a global set to track the visited states.
line does the actual scheduling by considering allrunnable tasks including the currently running task t a sa next task to run.
note that in the current state if the task t is preempted because it enters a permission region then thatstate reflects the acquired permissions on that region.
in thecase that task tblocked line chooses a random runnable task to schedule next.
figure shown previously is the state space explored by the search algorithm for the permission region annotatedversion of the program in figure .
recall that the example hastwo tasks that access the shared object stk one reading and the other writing.
the ovals in the diagram represent schedul ing points and as before the blocks on the left represent thestate of the state machine tracking permissions.
as indicatedby the pseudo code the algorithm only preempts runningtasks at the entrance to permission regions.
in this example it schedules the child task after the main task acquires readpermissions to elicit the permission violation.
by observation if the permission regions in the annotated program werereplaced with isolated constructs then the explored state space would no longer include the violation but it wouldinclude all schedules that interleave the atomic blocks definedby the isolated constructs.
algorithm is a procedural flow describing the process of program validation using the new search in algorithm .when algorithm finishes the algorithm reports any heaplocations that have been accessed by more than one distincttask outside a permission region or an isolated construct with the input program location where that access occurs.using this information a user is able to manually annotate theprogram location appropriately and then repeat the search.
theprocess terminates when a permission violation or a deadlockis discovered or no more sharing outside of permission regionsorisolated constructs exists.
537algorithm procedure to validate a program procedure v alidate p h t init p r runnable t t random r s search t h t while uncovered sharing is reported do add permissions or isolated on sharing h t init p s search t h t end while end procedure theorem .
algorithm is sound in that it only accepts programs that have no permission violations or deadlock on a given input under the restriction that the programs terminateand have all sharing correctly annotated with permissionregions or wrapped in isolated constructs.
proof the soundness proof reasons over a slightly modified version of the algorithm that is iterative and takes as anadditional input a search tree which is similar to figure that captures all possible sequences of release and acquirestatements explored thus far.
the algorithm traverses that inputtree and at each leaf node tries to extend that node by onegeneration if possible.
after the traversal the algorithm returnsthe new tree.
the algorithm is called in an iterative manneruntil the tree reaches a fix point which is guaranteed sincethe program terminates .
letp n be the statement that this modified search algorithm returns all interesting sequences of acquire and releasestatements of length nor less for a given input program where interesting means containing a permission violation ordeadlock.
basis step the algorithm produces all interesting sequences of lengthn .
this case is trivially established with the initial state of the program that represents a sequence of length n and cannot contain a permission violation or deadlock since the program has not yet done anything.
as such it includesall interesting sequences.
inductive step assume the modified algorithm has correctly generated a tree representing all interesting sequences of nor less it is necessary to show that from such a tree the algorithm is able to generate all interesting sequences of length n or less.
there are three possible outcomes at any leaf of theinput tree the leaf cannot be extended as it is already an interesting sequence having a permission violation or deadlock the leaf cannot be extended as there are no more tasks to run in which case it is not interesting or the leaf is able to be extended with one or more immediate descendants.
the first two cases are directly covered by line throughline of the algorithm there is no way to have anydescendants in those situations and the sequences are alreadyclassified as interesting or not.for the third case first consider line of the algorithm that creates the next generation in the tree for permissionregions and isolated constructs.
every runnable task is scheduled line and each of those tasks must reach animmediate successor.
such a successor may be a permissionviolation or a deadlock making it an interesting sequence apreemption a block condition or exit by the constraint thatthe input program must terminate.
as such any n 1length sequence that exists is generated.
further any interesting n sequence is generated.
to see this outcome it is important to understand that the orderof acquisition relative to read or write does not matter indetecting a violation.
the state machines on the objects arenot dependent on acquisition order they only depend on whattasks hold read or write permissions at the time of acquisition.as the algorithm always first acquires a permission and thenschedules other tasks it generates all the interesting n sequences if any exist.
in this case a sequence is interestingdue to a permission violation.
if a permission violation doesnot exist in a sequence then a deadlock is detected as usual.
to complete the inductive step the code under line must be considered.
that code covers a blocked or exited task.the input program has all sharing annotated or isolated by the theorem statement meaning that any non determinismdue to scheduling is enumerated by line so all reachableprogram paths on the input are considered.
if an interestingsequence exists because of a deadlock then it is either foundin then step by having selected the correct task or in a later step when the correct task is chosen.
if the deadlockdepends on a particular sequence of task executions then thosesequences are enumerated by line .
as such the deadlock iseither deterministic i.e.
independent of the schedule or non deterministic i.e.
a product of a data race on some sharedobject .
in the former the choice of task does not matter and in the latter line enumerates all possible orders overpermission region blocks and isolated blocks.
as a side note algorithm is complete when all regions cover a single operation i.e.
an individual byte code in thecase of java .
such completeness is at the cost of the numberof explored schedules.
v. r esults a new java library was implemented to evaluate algorithm in the jpf model checker hj v .
the library useslambda support in java and it is purposed for verification injpf.
algorithm itself is an extension to jpf that implementspermission regions and the search jpf hj .
each is brieflydiscussed before the results from several benchmark programsare presented.
a. hj library for v erification hj v is a new java library implementation of the habanero model designed specifically for debugging and verification.
it consists of roughly lines of code in classes.
most ofthe classes address the programmer interface rather than thelibrary internals.
figure is the interface using java lambdafunctions and is identical to other java library implementationsof the habanero model .
538hj v supports all of the constructs in the habanero model including phasers.
to increase confidence in the correctness of hj v test cases were created to utilize specific features of theruntime.
each of these test cases were run within jpf withfull scheduling enabled i.e.
it schedules on every bytecoderelated to thread synchronization or sharing .
thus for eachcase jpf is used to determine that hj v is free of data racesand deadlocks.
in total test cases were created consistingof approximately lines of source code.
b. jpf implementation the implementation of permission regions in jpf spans lines of code and covers distinct class objects.
it leverages jpf s ability to track thread ids of all accesses toobjects so it not only reports violations on the permissionregions but it also identifies shared accesses that are notannotated by permission regions or covered by isolatedconstructs.
in this way jpf updates the user when a sharedaccess has been missed in the annotations.
the implementation uses two key features of jpf bytecode listeners and object attributes.
it installs a byte codelistener to watch for instances of the byte code that callsmethods.
the actual methods for the permission regions in terface are empty stubs and when the listener activates onthe interface it gets the method s parameters from the stackand updates the associated state machines appropriately.
thestate machines themselves reside in an attribute of the object .
the important property of attributes is that they followheap objects through the entirety of state space exploration.for arrays a separate permissions state machine is stored forevery index.
the jpf implementation of algorithm exploits the extensible nature of the tool by providing a new scheduling factory.
a scheduling factory is activated on preemption when a threadis no longer able to run or if there is input non determinism.it decides what threads are scheduled by inserting choicegenerators into the state search to enumerate the available choices.
the search iterates over those choices starting a newsearch for each choice.
the default scheduling factory of jpf is replaced with a new factory that does not insert any choices on thread actions locks synchronization or shared accesses to objects.
anythingrelated to concurrency is turned off except for forced contextswitches such as a thread exiting or a thread blocking.
in thosecases the new scheduling factory inserts a choice generatorwith a single choice that represents a random thread that isrunnable.
to insert the preemption points for permission regions and isolated constructs the byte code listener from the imple mentation of permission regions is extended to also listen forthe calls to isolated.
at the entrance to permission regions the permission regions state machine for the object is updatedas before but after the update a choice generator is insertedinto the search that includes choices for all runnable threads.similarly a choice generator is inserted at the isolated call.
the entire factory with the listener extension is only a fewhundred lines of code but significantly reduces the verificationcost.
benchmark resultsjpf s default code to detect data races is named preciseracedetector.
table i compares the performance of jpf hjwith preciseracedetector over several benchmark programs taken from materials used to teach the habanero model or testthe habanero runtimes.
these programs are not necessarilyindicative of actual habanero programs in the real world butdo contain the breadth of hj constructs async isolated finish future and phasers.
many benchmarks also include arrays and shared arrays.
the sizes of the benchmarksare indicated by the sloc column i.e.
the number of program locations and the tasks column i.e.
the number of tasks created .
in table i an entry of n a in the time column indicates a running time greater than minutes on a macbook pro corei7 with gb of ram.
the error column indicates if a data race or deadlock is discovered.
an entry of detected race is an incorrect result the program is actually free from dataraces.
the first thing to notice in the table is that the preciseracedetector is more likely to not complete in the time bound due to exploring an excessive number of task schedules itschedules on individual byte codes where jpf hj scheduleson regions.
the second thing to notice is that the preciseracedetector reports data races in twodimarrays add and scalarmultiply benchmarks where no data races exists.
this error report is a limitation of preciseracedetector where it is not able to discern accesses to the arrays on disjoint indexes rather it reports an error because the access on the array objectlooks like a data race and exits.
if jpf is configured to not exiton error discovery then the entries become n a. that is whythe time entries on those examples appear to improve over the entries for jpf hj.
the final thing to notice in the table is that the cost of verification is difficult to predict based solely on the staticnumber of region annotations as it depends not just on thatnumber but the size of the regions and how many taskscontain the regions.
for example the primenumbercounter and its variants have very few regions as defined by theannotations in the code but those regions are part of everycreated task so those benchmarks have a much larger numberof schedules to explore.
vi.
r elated work the algorithm introduced in this paper is related to existing algorithms that only schedule on synchronizations .
grouping synchronizations in regions trades com pleteness for efficiency in a manner similar to bounding.
priormethods using permission regions only detect violations atrunning time and do not search the schedule space thoughit is possible to use a gradual type system to enforce guaranteesat compile time .
an early version of a verification specificrun time for habanero requires a specialized habanero javacompiler and does not implement all the habanero constructs most notably future and phasers .
a preliminary version of jpf hj details how to extend jpf but does not definethe search algorithm prove its correctness provide support forarrays or provide support for isolated constructs .
other approaches to verify task parallel languages create new virtual machines with verification support or spe539table i. p erformance comparison between jpf hj and preciseracedetector permission regions preciseracedetector test id sloc tasks states time regions error note states time error note primitivearraynorace no race no race primitivearrayrace no race detected race twodimarrays no race detected race forallwithiterable no race n a n a n a integercounterisolated no race n a n a n a pipelinewithfutures no race n a n a n a substringsearch detected race n a n a n a binarytrees no race n a n a n a primenumcounter no race n a n a n a primenumcounterforall detected race n a n a n a primenumcounterforasync no race n a n a n a reciprocalarraysum no race n a n a n a add no race detected race scalarmultiply no race detected race vectoradd no race no race asynctest1 no race n a n a n a asynctest2 detected race detected race finishtest1 no race no race finishtest2 no race no race finishtest3 no race no race clumpedaccess no race n a n a n a cialize existing verification tools to work with existing runtimes .
these assume the run times correctly implementthe language.
dynamic methods that intercept the run timecalls or instrument the program input can be effective forverification using stateless search or bounding techniques .
bounded techniques apply equally well to the algorithmin this paper.
static method to find data races often have betterperformance but are more likely to reject correct programs vii.
c onclusions f uture work this paper presents a model checking algorithm to prove when a habanero program does not contain any data races deadlocks assertion violations or exceptions for a givenprogram input.
the algorithm based on permission regions only considers scheduling points in the search tree at theboundaries of permission regions and isolated constructs.
the paper includes a proof of soundness for the algorithm meaning that the algorithm may reject a correct program dueto the size of the permission regions.
the effectiveness of the algorithm is shown in several benchmark programs that cover many of the habanero concur rency constructs.
the analysis is done using a new java libraryimplementation of the habanero runtime that is intended fordebugging and verification.
the new algorithm with permis sion regions is implemented as an extension to the jpf modelchecker.
the results from the benchmark programs indicate asignificant cost reduction when using the new algorithm.
future work includes automating the annotation of permission regions based on the sharing detection in jpf au tomating the validation of any counter example developingtechniques to automatically refine permission regions fromcounter examples when needed a partial order reduction overpermission regions static analysis to prevent scheduling on re gions that cannot race applying symbolic techniques to reasonover input and studying benchmarks that are representative ofreal world habanero programs.
r eferences v .
cav e j. zhao j. shirako and v .
sarkar habanero java the new adventures of old x10 in proceedings of the 9th international conference on principles and practice of programming in java ser.
pppj .
new york ny usa acm pp.
.
e. westbrook j. zhao z. budimli c and v .
sarkar permission regions for race free parallelism in proceedings of the second international conference on runtime verification ser.
rv .
berlin heidelberg springer verlag pp.
.
practical permissions for race free parallelism in proceedings of the 26th european conference on object oriented programming ser.ecoop .
berlin heidelberg springer verlag pp.
.
s. imam and v .
sarkar habanero java library a java framework for multicore programming in proceedings of the international conference on principles and practices of programming on the javaplatform virtual machines languages and tools ser.
pppj .
newyork ny usa acm pp.
.
c. s. p as areanu w. visser d. h. bushnell j. geldenhuys p. c. mehlitz and n. rungta symbolic pathfinder integrating symbolicexecution with model checking for java bytecode analysis autom.
softw.
eng.
vol.
no.
pp.
.
s. vakkalanka g. gopalakrishnan and r. m. kirby dynamic verification of mpi programs with reductions in presence of split operations andrelaxed orderings in proceedings of the 20th international conference on computer aided v erification ser.
ca v .
berlin heidelberg springer verlag pp.
.
m. musuvathi and s. qadeer iterative context bounding for systematic testing of multithreaded programs.
in pldi j. ferrante and k. s. mckinley eds.
acm pp.
.
m. emmi s. qadeer and z. rakamari c delay bounded scheduling inproceedings of the 38th annual acm sigplan sigact symposium on principles of programming languages ser.
popl .
new york ny usa acm pp.
.
p. godefroid model checking for programming languages using verisoft.
in popl pp.
.
c. flanagan and s. n. freund fasttrack efficient and precise dynamic race detection sigplan not.
vol.
no.
pp.
jun.
.
p. anderson b. chase and e. mercer jpf verification of habanero java programs sigsoft softw.
eng.
notes vol.
no.
pp.
feb. .
p. anderson n. vrvilo e. mercer and v .
sarkar jpf verification of habanero java programs using gradual type permission regions sigsoft softw.
eng.
notes vol.
no.
pp.
feb. .
t. zirkel s. siegel and t. mcclory automated verification of chapel programs using model checking and symbolic execution in nasa f ormal methods ser.
lecture notes in computer science g. brat n. rungta and a. venet eds.
springer berlin heidelberg vol.
pp.
.
m. gligoric p. c. mehlitz and d. marinov x10x model checking a new programming language with an old model checker.
in icst g. antoniol a. bertolino and y .
labiche eds.
ieee pp.
.