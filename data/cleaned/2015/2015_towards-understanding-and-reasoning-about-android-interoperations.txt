towards understanding and reasoning about android interoperations sora bae kaist daejeon south korea bsora92 kaist.ac.krsungho lee kaist daejeon south korea eshajlee gmail.comsukyoung ryu kaist daejeon south korea sukyoung.ryu gmail.com abstract hybrid applications apps have become one of the most attractive options for mobile app developers thanks to its support for portability and device specific features.
android hybrid apps for example support portability via javascript devicespecific features via android java and seamless interactions between them.
however their interoperation semantics is often under documented and unintuitive which makes hybrid apps vulnerable to errors.
while recent research has addressed such vulnerabilities none of them are based on any formal grounds.
in this paper we present the first formal specification of android interoperability to establish a firm ground for understanding and reasoning about the interoperations.
we identify its semantics via extensive testing and thorough inspection of android source code.
we extend an existing multi language semantics to formally express the key features of hybrid mechanisms dynamic and indistinguishable interoperability.
based on the extensions we incrementally define a formal interoperation semantics and disclose its numerous unintuitive and inconsistent behaviors.
moreover on top of the formal semantics we devise a lightweight type system that can detect bugs due to the unintuitive inter language communication.
we show that it detects more bugs more efficiently than hybridroid the state of the art analyzer of android hybrid apps in real world android hybrid apps.
index t erms android hybrid applications interoperability multi language systems operational semantics type system i. i ntroduction taking the best out of both web and native apps portability and device specific features hybrid apps have become prevalent .
in hybrid apps javascript code handles user interactions to be run on multiple browsers native code accesses device specific features such as accelerometer and they can communicate via interoperations.
however understanding the interoperation behaviors of hybrid apps is not trivial because the implementation languages have different semantics.
because the semantics of javascript is different from that of native languages like android java it is quite easy for developers to make errors like passing wrong number or wrong types of arguments to foreign function calls.
consider fig.
an excerpt from the adobe acrobat reader source code which is downloaded using the playdrone project .
it shows an interaction between java1and javascript.
fig.
a shows java code where class arjsapp declares method alert that can be used in javascript 1while android java is different from java we use android java and java interchangeably when their differences do not matter.class arjsapp javascriptinterface public final int alert string paramstring int paramint ... ... a java class arjsapp declares method alert that can be injected to javascript contexts.
this.mwebview.addjavascriptinterface new arjsapp this app b java code injects a java object new arjsapp this into the javascript context with name app .
app.prototype.alert function cmsg nicon return window.
app.alert cmsg nicon var app new app app.alert calert c javascript invokes the injected java method window.
app.alert .
fig.
interaction between android java and javascript as denoted by annotation javascriptinterface .
fig.
b shows another java code where an instance of arjsapp is injected to the javascript context as top level variable app via method addjavascriptinterface of class webview .
then fig.
c illustrates an actual interaction in javascript code.
javascript object app calls its function property alert with a single argument calert while the function declaration expects two parameters cmsg andnicon .
calling a function expecting two arguments with only one argument is a valid semantics in javascript the second parameter nicon gets value undefined .
then the function body calls the injected java method window.
app.alert expecting a string and an integer with cmsg and nicon .
the second argument from javascript does not satisfy the type requirement of the java method.
moreover inter language communication introduces various design choices to make.
consider fig.
once again.
when value undefined is passed to function window.
app.alert would it throw an exception?
if method alert is overloaded in the java side would it be still overloaded after the injection to the javascript side which does not support overloading?
when the same java object is injected to javascript twice as app and app would the injected objects be still the same object in the javascript side?
and so on.
however existing research for android hybrid apps ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and even the official android documentation do not clearly specify the interoperation behaviors and its design choices.
the existing works focus on handling real world android apps and various engineering decisions for scalability they do not aim to cover the inter communication semantics.
the state of the art static analyzer for android hybrid apps hybridroid analyzes inter communication between android java and javascript and detects misuses of foreign function calls but it addresses interoperations partially it does not consider for example multiple injections of single java object.
the android documentation is neither exhaustive nor consistent it does not address any design choices discussed above.
in this paper we present the first formal specification of android interoperability to provide a firm ground for understanding and reasoning about inter language communication in android hybrid apps.
we identify the interoperation semantics via extensive testing and inspection of the publicly available android source code .
to formally specify its key features dynamic and indistinguishable interoperability we extend the existing multi language calculus .
for dynamic interoperations the extension dynamically builds bridge s across java and javascript which allow accesses to java objects from javascript.
for indistinguishable interoperations it creates a javascript object for a bridge to support an interchangeable switch of languages from javascript to java.
based on the extension we present an operational semantics of android interoperability.
moreover we discuss its numerous unintuitive and inconsistent behaviors that have not been disclosed by the existing research.
taking advantage of the semantics we also present a lightweight type system that detects interoperation bugs including methodnotfound bugs defined by hybridroid .
while hybridroid uses an expensive points to analysis our type system is light weight with linear time traversal over target apps.
we evaluate our type system on real world android hybrid apps and show that it detects about twice as many true bugs than hybridroid with the average speed up of .7x compared to hybridroid .
the contributions of this paper include the following we identify complex but under documented behaviors in android hybrid apps.
it requires extensive testing and thorough investigation of android source code due to incomplete android documentation.
we extend the existing multi language semantics for dynamic and indistinguishable interoperability.
it may give an example to specify various inter language communications beyond the android hybrid mechanism.
we present the first formal semantics for android interoperability.
it provides a formal ground to reason about android hybrid apps and it allows us to uncover their unintuitive surprising and inconsistent behaviors.
we develop a precise and efficient type system that detects interoperation bugs.
the type system detects more true bugs more efficiently than hybridroid .
in the rest of the paper we present key interoperation features of hybrid apps section ii and a formal operational semantics of android interoperability from core to wild be haviors section iii .
using the formal semantics we present a type system for safe interoperability in android hybrid apps section iv .
we evaluate the type system section v discuss related work section vi and conclude section vii .
ii.
a ndroid interoperability we describe the android hybrid mechanism and introduce its key features that are not expressible in the existing multi language semantics .
a. from android java to javascript android java code can execute javascript code using two methods.
first evaluatejavascript takes two arguments public void evaluatejavascript string script valuecallback string resultcallback it executes the first string argument denoting javascript code and invokes the second callback if any when the execution completes.
second loadurl loads a given url public void loadurl string url possibly with given http request headers for the url public void loadurl string url map string string additionalhttpheaders it executes javascript code embedded in the web page at the url.
to focus on the core interaction functionality we ignore the callback argument for evaluatejavascript and the http request headers argument for loadurl .
also while loadurl can take a string argument representing javascript code rather than a url we ignore such case because it is the same as using evaluatejavascript .
we assume that java and javascript code run synchronously for simplicity.
b. from javascript to android java javascript code executed by evaluatejavascript or loadurl can invoke java methods via objects injected by method addjavascriptinterface public void addjavascriptinterface object object string name it injects the first object argument into the javascript context using the second string argument as a name which then beh a v e sa sa bridge for inter language communication.
injected java objects can be removed from the javascript context by the following method public void removejavascriptinterface string name for example an instance of class bridge can be injected to the javascript context by addjavascriptinterface new bridge brg and it is mapped as a javascript object named brg.
we call such mapped javascript objects bridge objects .
javascript code invokes java methods via bridge objects in the same way as it calls function properties of javascript objects.
for example for java method foo in class bridge javascript can invoke the method by brg.foo .
while android versions .
and above allow only public methods annotated with javascriptinterface to be accessible from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
javascript we assume that every method is accessible from javascript for simplicity.
note that java fields are not accessible from javascript.
c. dynamic and indistinguishable interoperability we identify two distinct key features in the android hybrid mechanism dynamic and indistinguishable interoperability which are not expressible in existing multi language semantics .
we call the existing semantics mfin this paper.
first java code accessible from javascript changes dynamically for example by addjavascriptinterface and removejavascriptinterface .
for example access to class bridge from javascript code varies over runtime.
on the other hand mfcan statically determine the accessibility via fixed and static bridges.
note that android supports flexible and dynamic bridges for inter language communication.
second javascript code invokes java methods in the same way as it calls function properties of javascript objects.
such syntatically indistinguishable interoperations switch languages interchangeably while mfintroduces a new kind of expressions called syntatic boundaries to support a switch of languages.
iii.
a ndroid interoperability semantics we present android interoperation semantics by extending mfwith bridges.
for simplicity we omit android specific features like activity life cycles.
a. models for java and javascript we first present base models for java and javascript in fig.
.
following the convention of mf we have typeset non terminals of java model using a bold font with serifs and those of javascript model with a light sans serif font.
occasionally we use subscripts and superscripts when the font difference is too subtle to differentiate java and javascript v for java and sfor javascript.
java and javascript models are based on featherweight java and js respectively.
java code pconsists of a sequence of object declarations odfollowed by a sequence of expressions e. for presentation brevity we use singleton objects instead of classes because the interoperations do not utilize features like class inheritance constructors and fields.
an object declaration contains a sequence of method declarations md.
we use afor an object name and mfor a method name.
a method body is an expression e which is either a constant c a variable x o r method invocation.
a constant is a number n an object ornull .
a java type vmay be a primitive type an object a o r void for internal value .
we describe the operational semantics in the felleisen hieb small step operational semantics with evaluation contexts .
the operational semantics is conventional using the following matchtype v v true if v n v v v a v null v afor any a v v void false otherwise that checks whether a given value has a given type.p ode od object a md md vm vx e e c x e.m e c n null v c v a void e v e.m e v.m ve e object a md vm vx e md x v matchtype v v e .m v v e a java model e c x let x ein e e.m e.m e e.m e c n function x e null v c undefined e s let x ein e e.m e.m e v.m e e.m e v.m ve e oe s oe o a.m v oe .m s oe a.m negationslash dom o oe .m s oe oe .m v s o e o a.m function x e oe .m v s oe b javascript model fig.
models for java and javascript p odt t e add remove evaluate e i vvs e e vvs e a extensions to fig.
a i sv v e v bridge m e sv v e b extensions to fig.
b fig.
extended models for interoperability a javascript expression eis a constant c a variable x variable binding property load property store or property call.
a constant is a number n an object a first class function function x e o r null .
we omit features like property deletion and prototypes that do not affect the interoperations.
the operational semantics is conventional as well using object tableothat maps object properties to their values.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. extended models for interoperability to support interoperations we extend each base model.
fig.
a and fig.
b show extensions to the base java and javascript models respectively.
they introduce additional expressions vvs e and sv v e to indicate switches of languages.
vvs e denotes a java boundary expression of type vthat contains javascript expression e. similarly sv v e denotes a javascript boundary expression that contains java expression eof type v. for indistinguishable interoperability external syntax edoes not include its cross language boundary sv v e is an internal expression icreated at run time.
for dynamic interoperability fig.
a specifies dynamic creation and destruction of a bridge using add and remove respectively add enables access to a java object from javascript and remove withdraws the accessibility of .
without loss of generality we assume that javascript code uses a javascript object to exploit a bridge for .
we call such javascript objects bridge objects .
another additional expression evaluate e in fig.
a indicates two methods loadurl andevaluatejavascript that android provides to execute javascript code from java code.
because both loadurl andevaluatejavascript always return values of type void the extended model initiates interoperations via evaluate e instead of boundary vvs e .
thus fig.
a includes evaluate e in external syntax eand hides vvs e under internal syntax i. using this model we can simplify android interoperations.
consider the following android java code class a javascriptinterface public int m int x return x webview webview ... webview.addjavascriptinterface new a a webview.evaluatejavascript a.m undefined which injects an instance of class ainto the javascript context with name a and evaluates javascript code a.m undefined invoking java method m. we encode it as follows in our model object a m x x add evaluate .m undefined we will describe reduction steps of such code in following subsections using context sensitive reduction rules as with mf we use an evaluation context efor java and efor javascript.
also we establish eas a top level evaluation context eto indicate that the top level program is written in java.
note that our model prohibits nested interoperability by separating bridging operations add remove and evaluate e from normal operations even though android allows nested interoperations.
however our model still can represent the exact android interoperation behaviors because of the asynchronous feature that we discuss in section iii d. c. core interoperation semantics we present the core interoperability semantics first and then extend it to describe quirky behaviors that we discovered.
b prime b boe v b primeoe b prime b boe v b primeoe b object a vm vx e o prime a.m bridge m boe v bo primee boe v boe boe v boe v negationslash n boe v boe b boe v boe v negationslash dom b boe v boe b negationslash boe v squigglerighterror incompatible object a extended java semantics o a.m function x e boe .m v s boe o a.m bridge m primeb object a md vm prime vx e md x v boe .m v s boe .m prime vvs v o a.m bridge m primeb object a md vm prime vx e negationslash md x v boe .m v s squigglerighterror no bridge method o a.m bridge m prime negationslash dom b boe .m v s squigglerighterror non bridge object boe s boe boe s boe b boe s boe negationslash b object a vm vx e b prime b o prime o a.m bridge m boe s b primeo primee b extended javascript semantics fig.
core interoperation semantics fig.
a shows the semantics of bridge creation destruction and provision.
rules and create and destruct bridges respectively by updating bridge table b. rule provides available bridges in bto the javascript context by updating object table owith properties of bridge objects.
a bridge object contains methods of as its properties a.m bridge m where bridge m denotes a java method named min the javascript context called a bridge method .
fig.
b shows the semantics of bridge objects and bridge methods which intermingle with those of javascript expressions for indistinguishable interop226 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
erability.
while we present the intermingled semantics in the android hybrid mechanism in this paper we can describe various interoperability semantics based on our formalization.
for example consider javatm plug in and rhino supporting communication between javascript code and java applets running on a web page.
while they have different semantics from that of android they also provide dynamic and indistinguishable communication between java and javascript.
thanks to such common ground we can use the android interoperation semantics as a reference when specifying their semantics.
as an example we present an operational semantics of javatm plug in in a companion report .
method overloading resolution in javascript while java supports overloaded methods having the same name but with different signatures javascript does not provide overloaded functions.
moreover javascript allows any number of arguments for a function call regardless of the number of function parameters at its declaration site.
the android hybrid mechanism partially supports overloaded java methods it selects a java method to invoke from a list of available method declarations in a given java object using the name and the arity of a method call.
when there are multiple method declarations with the same name and the same arity but with different parameter types it does not guarantee which method is called.
when no method declarations have the same name and the arity of a given method call it throws a method not found exception.
rule in fig.
b specifies a successful java method call from javascript code calling a bridge method bridge m primeon a bridge object with javascript values v. first it searches for a java method vm prime vx e to invoke using the bridge method name m primeand the number of arguments v .
then it converts the arguments to java values by vvs v invokes the java method with the converted values and converts the method call result via sv v. rule specifies exception no bridge method when it cannot find the java method.
we use squigglerightfor exception throwing rules to distinguish them from normal reduction rules.
first class java methods while javascript functions are first class values java methods are not.
java methods injected to the javascript context which we call bridge methods are considered as first class values we can assign them to variables or set them as object properties.
however they do not behave like normal javascript functions.
for example we can set a javascript object property with a bridge method foo of a bridge object brg as follows jsobj jsobj.bar brg.foo but calling the property jsobj.bar throws a java bridge method can t be invoked on a non injected object exception.
rule throws exception non bridge object for bridge method calls on non bridge normal objects.
v alue conversion between java and javascript java and javascript have different values with different type systems.
while java provides user defined types by staticallydeclared classes javascript does not support them but it allows users to construct and update objects at run time.
android provides implicit value conversion between java and javascript.
when javascript code invokes a java method with javascript values android converts the arguments to java values of the method s parameter types.
when values to be converted are inconsistent with given types android uses default values like 0for a number and null for an object as shown in rules and in fig.
a .
rule shows an unacceptable value conversion converting a bridge object to a java object of an incompatible type throws exception incompatible object .
after invoking a java method from javascript code its result is converted to a javascript value.
this conversion may implicitly inject java objects to the javascript context.
consider rules and in fig.
b representing conversions from a java object to a javascript object.
if the java object is already injected to the javascript context android uses the corresponding bridge object .
otherwise it dynamically injects the java object to the javascript context on demand .
d. extensions for wild interoperation now let us extend the core semantics to express wild android interoperation behaviors.
multiple bridge objects for single java object a single java object can be bound to multiple bridge objects.
for example the following code 1bridge obj new bridge 2addjavascriptinterface obj b1 3addjavascriptinterface obj b2 4loadurl file android asset www index.html injects the same java object obj into the javascript context with two different names b1and b2on lines and .
because android creates a new bridge object for a given name rather than for a given java object it maintains many to one mappings from bridge objects to java objects.
thus javascript code can make independent updates on b1and b2 which do not reflect to each other nor to the original java object obj.
this functionality may be useful but it incurs unintuitive semantics.
for instance suppose that the above obj contains method identity that returns itself as it is and that loading the above index.html executes the following javascript code b1.print function console.log b1 b2.print function console.log b2 b2.identity .print the code adds a property named print with a javascript function value to both bridge objects b1and b2.
one may expect that b2.identity would return b2as it is thus b2.identity .print would log b2 to the console.
however unfortunately it may log b1 rather than b2 because when b2.identity returns a java object android does not guarantee to find the correct bridge object b2 from multiple bridge objects b1and b2 .
in short android uses many to227 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
one mappings from bridge objects to java objects which bring buggy results from java method calls.
we can extend the core semantics to specify many toone mappings from bridge objects to java objects.
while the core semantics represents one to one mappings by the implicit correspondence between a java object and its bridge object we can extend it to the correspondence between a java object and its multiple bridge objects .
then rule does not guarantee which bridge object among multiple ones would be returned.
bridge objects without matching java objects android provides two methods loadurl and evaluatejavascript to execute javascript code from java code but they provide bridges to the javascript context differently.
loadurl always provides new bridges while evaluatejavascript provides new bridges only when android executes javascript code for the first time.
with these new bridges javascript code cannot access previous implicitly injected java objects.
also loadurl clears the javascript context except for its first call but evaluatejavascript does not clear the javascript context.
therefore sequentially invoking methods evaluatejavascript and loadurl may lead to unintuitive behaviors.
for example addjavascriptinterface new bridge brg evaluatejavascript var b brg.create ... loadurl file android asset www index.html javascript code executed by evaluatejavascript implicitly injects a java object as a result of brg.create b u t loadurl disallows access to the injected object while preserving its bridge object b. in short even though the java object is no longer accessible from javascript its corresponding bridge object is retained in the javascript context.
thus if the javascript code in index.html invokes java methods via b it results in application crash.
we can describe such wild behaviors by classifying evaluate e according to its behaviors and defining its semantics differently.
we distinguish three kinds of evaluate e it provides new bridges to a new javascript context which represents evaluatejavascript that executes javascript code for the first time and loadurl after the first call it provides new bridges to the existing javascript context which represents the first call of loadurl and it provides the existing bridges to the existing javascript context.
rule in fig.
a specifies the first case where a javascript expression is executed under newly constructed object table a.m bridge m .
the second case is as follows be object a vm vx e b b prime be o prime o a.m prime a.m bridge m beboe v beb primeo primee by separately maintaining explicitly injected java objects in be it identifies previous implicitly injected java objects negationslash dom b cboe .m s cboe m dom b a.m js c cboe .m s cboe m dom b a.m jv c cboe .m s cboe b a.m negationslash dom c object a md vm vx e md c prime c a.m jv cboe .m s c primeboe b a.m negationslash dom c object a md vm vx e negationslash md c prime c a.m js cboe .m s c primeboe m fig.
cached property accesses of bridge objects and disables accesses to them while retaining their bridge objects by mapping the bridge objects to dummy objects .
note that the javascript code is executed with new bridges on top of the existing object table o. finally for the third case we use the existing object table as it is for the javascript code execution.
because the javascript context may contain bridge objects without corresponding java objects various unexpected behaviors may happen.
cached accesses of bridge object properties bridge objects behave differently for different properties.
consider a bridge object brg for a java object obj bridge obj new bridge addjavascriptinterface obj brg where obj contains a method named foo but no methods named bar.
it is okay to add a property named bar tobrg t o modify it and even to delete it from brg though such actions do not get reflected to obj.
however modifying or deleting properties whose names already exist in the corresponding java object is silently ignored.
thus javascript code brg.foo 4evaluates to but it does not change the value of brg.foo to .
moreover reconsidering the example in section iii d2 addjavascriptinterface new bridge brg evaluatejavascript var b brg.create ... loadurl file android asset www index.html one more quirky semantics exists here.
if bridge object property b.print has a non java value such as a javascript function evaluation of b.print inindex.html produces different results depending on whether b.print was accessed or not in the ... part.
this surprising behavior is due to the cached lookup process because android caches access of bridge object properties b.print is still accessible in index.html if it was accessed before loadurl .
fig.
formally specifies cached access of bridge object properties in android.
cache crecords accessed properties of a bridge object c a.m jsdenotes that property a.mwas accessed and has a usual javascript value and c a.m jv denotes that property a.mwas accessed and its value comes from the java context.
rule specifies that the prop228 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
erty accesses of normal javascript objects behave the same where access m follows rules and in fig.
b .
rules and represent when a property of a bridge object has a cached javascript value and a cached bridge method respectively.
the last two rules are for cache misses where the cache is extended with a new property information a.m jv or a.m js .
using caches for bridgeobject lookup may be efficient but given the unintuitive semantics actual benefits may be questionable.
asynchronous boundaries android s loadurl and evaluatejavascript execute javascript code asynchronously making nested interoperations behave in an unintuitive manner.
consider java class nestedbr having the following method javascriptinterface public void inter evaluatejavascript brg.name function console.log brg and consider the following java code addjavascriptinterface new nestedbr brg evaluatejavascript brg.inter brg.name one may expect that brg.name would log brg to the console because call to evaluatejavascript inbrg.inter stores a log function to property brg.name .
however it throws a type error rather than printing brg .
because the evaluatejavascript method executes javascript code asynchronously brg.inter terminates without the property assignment it updates the property after the previous evaluatejavascript call finishes.
thus brg.name raises an exception for calling the undefined value.
since asynchronous boundaries do not affect the interoperation semantics besides the nested interoperation we exclude them in this paper.
iv .
t ype system for safe hybrid apps in this section as an application of the formal semantics we define safety of android interoperability and devise a type system that detects unsafe interoperations.
a. preventing the bugs detected by hybridroid we define the safety as absence of error methodnotfound that hybridroid detects from android hybrid apps and we design a type system detecting the methodnotfound errors.
safety safe interoperations involve no methodnotfound errors defined by hybridroid when a bridge method call cannot find any target java method to call the bug detector reports error methodnotfound which may be due to three reasons.
the first case is when a developer makes a typo in the bridge method name or indeed calls an undefined method of an injected object.
the second case is when a target java method is inaccessible either because it is private or it does not have the javascriptinterface annotation when the target android version is .
or later.
finally b o turnstileleft add void b o b o turnstileleft remove void b o b object a vm vx e b a.m funv m turnstilelefte s b prime o prime b o turnstileleft evaluate e void b prime o prime b o turnstileleft e s b prime o prime b o turnstileleft vvs e v b prime o prime fig.
type system for java the third case is when a bridge method call has a wrong number of arguments.
the three cases represent possible failure scenarios in finding a corresponding java method from a given property call on a bridge object.
the first two cases stand for undefined property calls and the third case indicates bridge method calls with a wrong number of arguments.
formally speaking definition safety top level expression eis safe in terms of interoperability if for any oandb e negationslash e .m v swhere b a.m negationslash dom o and e negationslash e .m v swhere b o a.m bridge m prime object a md vm prime vx e negationslash md x v .
type system for simplicity the type system detects only unsafe interoperations it does not detect traditional type errors but extending it to detect them as well is straightforward.
java and javascript expressions share type environments type table maps variables to their types bridge table bkeeps bridges and object table omaps object properties to their types.
fig.
presents a type system snippet for java the rest rules are conventional.
the full type system is available in a companion report .
rules and maintain bridges in b. rule builds an object table based on bto type check javascript code it checks the type ofeunder a newly constructed object table a.m funv m where funv m denotes a javascript type for java methods named min the javascript context.
the typing rule for java boundary vvs e checks the type of the wrapped javascript expression e. to focus on interoperability we assume that java objects and their method declarations are well typed.
fig.
presents a type system snippet for javascript.
we introduce a simple type hierarchy with six kinds of javascript type s funs x e for javascript function funv m for bridge method bridge m objs a for pure javascript object objv a a for bridge object obj a for encompassing objs a and objv a a and latticetopfor encompassing all javascript types.
we use helper function checktypes to type check a series of expressions.
three typing rules for e.m e in fig.
check the type of the callee function e.m. if the type is funs x e it checks the argument expressions and the function body .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
s funs x e funv m objs a objv a a obj a latticetop s latticetop objs a obj a objv a a obj a b o turnstileleft function x e funs x e b o b o turnstileleft bridge m funv m b o negationslash dom b b o turnstileleft objs a b o b b o turnstileleft objv a a b o b o turnstileleft e obj a b prime o prime a.m funs x e prime o prime sb prime prime o prime prime checktypes b prime o primee x s b prime prime o prime prime turnstilelefte prime s b prime prime prime o prime prime prime b o turnstileleft e.m e s b prime prime prime o prime prime prime b o turnstileleft e objv a a b prime o prime a.m funv m prime o prime object a md vm prime vx e md x e vb prime prime o prime prime checktypes b prime o prime vvs e x v b prime prime o prime prime turnstileleftsv v e s b prime prime prime o prime prime prime b o turnstileleft e.m e s b prime prime prime o prime prime prime b o turnstileleft e objs a b prime o prime a.m funv m prime o prime sb prime prime o prime prime checktypes b prime o primee b o turnstileleft e.m e latticetop b prime prime o prime prime v negationslash a b o turnstileleft sv v e latticetop b o b b o turnstileleft sva e objv a a b o negationslash b object a vm vx e b prime b o prime o a.m funv m b o turnstileleft sva e objv a a b prime o prime fig.
type system for javascript if the type of the callee is funv m the callee is a bridge method named m. when a receiver object is a bridge object the corresponding java object should contain a declaration of method m .
rule checks the types of the converted arguments vvs e and of the converted result sv v e .
note that typing rules and correspond to and respectively there is no typing rule for denoting the methodnotfound error.
the typing rule for sva e with a not yet injected java object injects the java object to the javascript context by introducing it to the object table .
based on the formal semantics and the type system we can show that a well typed android hybrid app does not contain any evaluation contexts that lead to error methodnotfound .
the full type system and proof using well typed object tables are available in a companion report .
b o turnstileleft e objs a b prime o prime b prime o prime turnstilelefte prime s b prime prime o prime prime b o turnstileleft e.m e prime s b prime prime o prime prime b o turnstileleft e objv a a b prime o primeobject a md vm vx e negationslash md b prime o prime turnstilelefte prime s b prime prime o prime prime b o turnstileleft e.m e prime s b prime prime o prime prime fig.
extensions to fig.
b. extensions for preventing quirky behaviors of cached property access we show how to extend the type system to prevent unintuitive behaviors discussed in section iii d. we focus on quirks caused by cached access of bridge object properties in section iii d3 because the other quirks can be simply avoided multiple bridge objects for a java object in section iii d1 can be syntactically checked and bridge objects without corresponding java objects in section iii d2 never happen in android versions .
and above.
note that we do not consider asynchronous boundaries in section iii d4 either because the asynchrony is orthogonal to the android interoperation semantics.
safety reconsider the quirky behaviors due to cached property access bridge objects behave differently for different properties.
...however modifying or deleting properties whose names already exist in the corresponding java object is silently ignored.
such ignored property assignments make property accesses to bridge objects difficult to understand leading to programming errors.
thus we extend the safety with coherence between assignments and accesses to bridge object properties in safe android hybrid apps javascript changes bridge objects only with properties whose names do not overlap with those of the corresponding java objects.
we extend definition as follows definition safety top level expressions eis safe if e negationslash e .m v swhere b object a md vm vx e md .
type system we now extend the type system in section iv a for the new safe interoperability.
we change only the typing rules for property assignment as shown in fig.
.
property assignment to javascript objects can be conducted without any constraints .
on the other hand assignment to bridge objects are constrained to use properties whose names do not exist in the corresponding java objects .
we show that the extensions provide the new safe interoperability with the proof in a companion report .
v. e v aluation in this section we evaluate our implementation of the type system in terms of soundness precision and efficiency.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i interoperation bug detection results hybridroid ours target bugstime bugstime speedhybrid appfp tp sec.
fp due to fp due totp cause sec.
uphybridroid rules com.app.sophosi .
com.appliclub1410 .
com.dhobilite .
com.eclectictt .
com.gameloft.android.anmp.glofta3hm .
obfuscation .
.
com.gameloft.android.anmp.gloftpehm .
no annotation .
.
obfuscation com.ibs.sketch .
.
.
com.lenovo.anyshare.cloneit .
no method .
.
com.officeon b .
com.prankfingerpregnancytest2 .
.
.
com.wirelesstag.android3 .
europe.de.ftdevelop.aviation.toolknife .
no annotation .
.
mediavision.handwallet .
obfuscation .
.
pozdravuha.ru.pozdravleniya .
obfuscation .
.
total fig.
overview of the type system implementation a. implementation we implemented our type system using two open source tools hybridroid and safe .
as rule in fig.
specifies we need to collect bridges in bridge tableband to construct object table oin order to typecheck javascript code.
we use the front end of hybridroid to extract javascript code and its available bridges from android hybrid apps.
we modified hybridroid to extract only necessary information without running its full analysis and to record this information in json format.
we also use the front end of safe to generate javascript intermediate representation that is suitable for type checking.
then we implemented a type checker that constructs a bridge table and an object table from the recorded information and checks the type of the javascript code received from safe.
fig.
illustrates the overall architecture of the implementation.
the source code of our tool is open to the public .
to address complex and extremely dynamic features of javascript we extend the javascript typing rules in fig.
and fig.
.
first we revise the simple type hierarchy of javascript to address functions as objects by making function types and bridge method types subtypes of object types.
second we extend typing rules for function calls so that constructor calls recursive calls and unknown function calls have type latticetop which may be imprecise but sound.
third we extend typing rules for property read and write so that any accesses with non literal property names have type latticetop.
finally any language constructs joining multiple values such as conditional expressions and loops have type latticetop.
even though our revised type system is aggressively losing precision the experimental results in thenext section show that it works well in practice.
b. interoperation bug detection to evaluate the soundness precision and efficiency of our type system we compare its bug detection results with those of hybridroid .
the state of the art static analyzer for android hybrid apps hybridroid conducts a costly flow insensitive pointsto analysis but with no formal ground while our type system performs a light weight linear traversal based on the formal interoperation semantics.
for fair comparison our experiments use the latest version of hybridroid which is much faster than its predecessor.
we performed all the experiments on a linux machine with .4ghz intel core i7 and 32gb memory.
for analysis targets we collected real world android hybrid apps apps from playdrone and apps from androzoo .
because hybridroid collected hybrid apps from playdrone we used playdrone for the fair comparison.
in addition because playdrone crawls apps from the google play store we used androzoo as well to collect more up to date hybrid apps.
from androzoo we selected apps that are deployed more than times in because they are likely to be well maintained.
table i summarizes the experimental results for androzoo dataset especially for hybrid apps that either hybridroid or the type system fails to terminate or reports interoperation bugs for.
the first column shows target apps and the rest presents the numbers of false and true bugs and the execution time in seconds for both hybridroid and the type system.
the execution time does not include the preparation time of hybridroid such as crawling javascript code to analyze that is common for both hybridroid and the type system.
all figures in the table are averaged over runs and a dash indicates a failure of analysis to terminate within hours.
we do not present the evaluation results for playdrone dataset in this paper because they show similar results to those for androzoo.
a soundness the type checker detects true interoperation bugs for the target subjects while hybridroid reports only true bugs.
all the true bugs are methodnotfound bugs caused by calling obfuscated methods with non obfuscated authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
names methods not annotated with javascriptinterface or undeclared methods.
we reported these bugs to the corresponding developers.
note that the type checker did not find any bugs caused by cached property accesses.
we manually investigated inter language communication patterns in the target subjects and observed that developers use simple patterns defensively which may explain why the type checker detected only methodnotfound bugs.
also the type checker finds all the true bugs detected by hybridroid except one in mediavision.handwallet .
we manually examined the missed true bug and found out that it is wrapped in an event callback registered by html dom method addeventlistener .
because the type system does not handle addeventlistener unlike hybridroid it considers the buggy code unreachable.
we believe that we can detect the bug when we introduce a model for event callbacks to the type system.
the type checker also finds more true bugs that hybridroid fails to detect.
we found a soundness bug in hybridroid confirmed by the authors.
b precision the type checker reports more false positives than hybridroid but only five of them are due to the type checking rules themselves as shown in table i. we manually investigated them and found out that they are due to the imprecise type checking rule for dynamic property call obj ... where prop is not a literal.
the type system simply gives type latticetopfor such dynamic property accesses and forbids property calls of type latticetop which is sound but imprecise.
the other false positives are due to the incorrect bridge information extracted by the imprecise front end of hybridroid .
while hybridroid and our type system share the imprecise front end hybridroid reports only two of false positives in common.
it does not report the rest nine false positives because of its soundness bug ironically hybridroid does not analyze some inter language communications.
we believe that we can remove the false positives by replacing the front end ofhybridroid with a precise analyzer.
c efficiency while hybridroid takes .
seconds to more than hours in analyzing hybrid apps the type checker takes .
seconds to .
seconds.
as expected the type checker detects interoperation bugs much faster than hybridroid for all the subjects.
the type checker shows the average speed up of .8x compared to hybridroid we omitted the apps that hybridroid fails to analyze within the time limit from the calculation of the average speed up.
vi.
r elated work a. analysis of android hybrid apps researchers have revealed security vulnerabilities in android hybrid apps and developed analyzers that defend the apps against the vulnerabilities.
and reported the security issue that no access control policy governs the android interoperability and proposed alternative policies.
reported new code injection attacks exploiting the android interoperability and they developed an analysis that detects potential injection flaws.
while they propose defence mechanisms for security vulnerabilities utilizing the interoperability we formalize the interoperation semantics.recent research has developed static analyzers that address control flows between java and javascript.
while built control flow graphs of javascript and java separately and added edges between them in a heuristic matter hybridroid tracked flows seamlessly and detected interoperation bugs in real world android hybrid apps.
unlike hybridroid our type system is based on a formal semantics which enables to uncover unintuitive surprising interoperation behaviors and to detect the bugs efficiently.
b. semantics for multi language programs researchers have studied multi language semantics using javatm native interface jni .
jeannie is a language that integrates java and c by compiling jeannie to jni but its inter language communication semantics are described informally using examples.
jni light jnil formally describes interoperations between java bytecode and assembly code.
similarly for jnil we formally describe interoperability in java and javascript code but our semantics is for high level languages in particular for typed and untyped languages.
researchers also studied the interaction between typed and untyped languages.
used a syntactic boundary as a key construct for interoperations and used a guard for the boundary to preserve type soundness.
while separated interoperations from normal operations via explicit syntactic boundaries we do not distinguish them syntactically because the android hybrid mechanism identifies such interoperations at run time.
we also provide a way to control the interoperability granularity via bridges .
proposed a safe inheritance model between typed and untyped languages.
we may apply the model to android by creating javascript objects that inherit properties of java classes and by calling bridge methods using super calls.
however because the model prohibits bridge objects from using javascript s object prototype they may behave differently from original bridge objects.
vii.
c onclusion we presented a formal specification for inter language communication in android to provide a firm ground for understanding and reasoning about android hybrid apps.
we identified complex but under documented interoperation behaviors via extensive testing and inspection of the android source code.
we extended the existing multi language semantics to formally specify key interoperation features dynamic and indistinguishable interoperations.
based on the extensions we presented an operational semantics of the android interoperability and it enabled us to uncover quirky and error prone behaviors in the android hybrid mechanism.
on top of the formalization we designed and implemented a type system that detects interoperation bugs.
we showed that it detects about twice more true bugs than hybridroid with the .8x average speed up.
moreover our type system is just one application of the presented formal semantics.
we believe one can design static analyzers or more expensive type systems based on the formalization in this paper.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
acknowledgment this work has received funding from national research foundation of korea nrf grants nrf 2017r1a2b3012020 and 2017m3c4a7068177 .