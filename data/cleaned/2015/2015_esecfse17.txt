kmax finding all configurations of kbuild makefiles statically paul gazzillo yale university usa paul.gazzillo yale.edu abstract feature oriented software design is a useful paradigm for building and reasoning about highly configurable software.
by making variability explicit feature oriented tools and languages make program analysis tasks easier such as bug finding maintenance and more.
but critical software such as linux coreboot and busybox rely instead on brittle tools such as makefiles to encode variability impeding variability aware tool development.
summarizing makefile behavior for all configurations is difficult because makefiles have unusual semantics and exhaustive enumeration of all configurations is intractable in practice.
existing approaches use ad hoc heuristics missing much of the encoded variability in makefiles.
we present kmax a new static analysis algorithm and tool for kbuild makefiles.
it is a family based variability analysis algorithm where paths are boolean expressions of configuration options called reaching configurations and its abstract state enumerates string values for all configurations.
kmax localizes configuration explosion to the statement level making precise analysis tractable.
the implementation analyzes makefiles from the kbuild build system used by several low level systems projects.
evaluation of kmax on the linux and busybox build systems shows it to be accurate precise and fast.
it is the first tool to collect all source files and their configurations from linux.
compared to previous approaches kmax is far more accurate and precise performs with little overhead and scales better.
ccs concepts software and its engineering software configuration management and version control systems interpreters software testing and debugging keywords kmax makefiles kbuild variability configuration static analysis acm reference format paul gazzillo.
.
kmax finding all configurations of kbuild makefiles statically.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn .
.
.
.
introduction feature oriented software design fosd is a paradigm that provides a principled way to develop highly variable software .
a line of software products can be produced from a single codebase by combining a selection of features.
by making features explicit and carrying them through the build process variability in fosd programs is easier to reason about and more amenable to automated software engineering tools.
some of the most critical software infrastructure however does not use fosd friendly tools instead relying on brittle languages such as makefiles to encode variability impeding variability aware analysis.
linux busybox apache and other systems that use makefiles have been shown to harbor variability bugs that are not exposed unless a particular configuration is tested .
even bugs easy to find for a single configuration bugfinder have been unwittingly committed into these codebases from simple bugs such as linker errors to more pernicious buffer overflows and testing all configurations is infeasible.
beyond bug finding many other software engineering tasks depend on a complete picture of makefile variability measurement of the scale evolution and interactions of features in variable systems program analyses such as dataflow analysis code coverage and feature model validation code maintenance such as evolution and dead code elimination and translating existing variability to new variability encodings .
all of these analyses use ad hoc tools or ignore makefile variability altogether resulting in an incomplete feature model that necessarily excludes configurations.
for instance several studies on the linux .
.
.
x86 kernel source explicitly report using or fewer c source files while our new results show that there are c source files more that have been missed in previous experiments.
while makefiles are widely used they remain a pain point for automated reasoning about build system variability.
brute force enumeration is intractable because configurations are exponential in the number of configuration options.
static analysis is hard because makefiles are written in an expressive programming language that has unusual semantics.
for instance variable names can be constructed at runtime via string operations.
previous attempts to analyze build system makefiles such as fuzzy parsing and brute force have been ad hoc and incomplete .
their heuristics elide the complexities of the makefile language.
as a result they miss much information limiting the completeness and correctness of downstream analysis tools.
to be fair these tools were not designed to be a complete analysis of configurations and provide enough precision for the experimental evaluation of their respective contributions.
in contrast our aim is an accurate and precise configuration analysis that can be used for variability analysis of build systems themselves and for downstream tools.
279esec fse september paderborn germany paul gazzillo our goal is to enable family based analysis of build system variability .
a family based analysis reasons about the space of possible configurations as a whole typically in a single pass as opposed to reasoning about configurations separately.
previous heuristics for kbuild makefile analysis have difficulty covering the configuration space tractably so are less useful for reasoning about variability.
an example of the utility of a variability aware analysis is finding unreachable code.
the linux kernel contains source that can never be compiled either due to bugs in the makefiles or infeasible combinations of configurations.
more subtly many source files are only feasible when building for a specific architecture.
this is useful information for software tools e.g.
a bug found in an infeasible configuration is a false positive.
reasoning about the entire space of configurations makes handling such issues feasible.
kbuildminer and golem represent state of art approaches to analyzing kbuild makefile configurations.
kbuildminer works by parsing common makefile usage patterns.
but parsing alone invariably misses much by not accounting for makefiles semantics even when makefiles are manually adjusted to fit the parser s grammar.
golem uses heuristic brute force enumeration.
it enables one or more features at a time and executes the makefiles recording the resulting output.
but this approach is very slow and still only covers a fraction of all configurations because of the sheer number of combinations of configuration options.
in contrast we approach variability in makefiles as a static analysis problem.
this is a natural fit features are makefile variables and variability is encoded with if then else statements and variable expansion.
we introduce a new family based static analysis algorithm called kmax for kbuild makefiles that yields a precise description of variability.
kmax provides abstractions for the configuration and string domains and its data flow results yield a precise summary of all possible configurations of a makefile.
the analysis is path sensitive where paths model the reaching configurations i.e.
the combinations of configuration settings that lead to a particular point in the makefile program.
by using binary decision diagrams bdds to concisely represent paths we can model all configurations with good performance in practice even on the highly configurable build system for linux.
kmax s abstract state enumerates all configurations of string values which localizes configuration explosion to the statement level instead of the entire makefile.
this enables precise analysis of complex string operations in makefiles such as runtime variable name construction.
in a single pass kmax collects a bdd representation of the space of configurations from kbuild makefiles.
with this representation it can incorporate further constraints on the space due to developer policy e.g.
drivers that only apply to a specific platform.
kmax s analysis approach is implemented in a new tool which analyzes makefiles written for the kbuild build system used by many highly configurable projects including the linux kernel busybox and coreboot.
the kmax tool collects all c files comprising the codebase and boolean expressions of configuration options that control them i.e.
the feature model.
we evaluate kmax for accuracy precision and performance on the build systems for the linux kernel and busybox.
kmax takes only minutes on the linux build system and is the first to correctly find all c files for the linux kernel and their configurations.
kmax is compared againstthe state of art heuristic approaches kbuildminer and golem and is shown to be much more accurate and precise with better or little performance overhead and better scalability.
because of its principled approach to variability kmax is able to identify dead and orphaned code due to infeasible configurations.
the contributions of this paper are as follows a new static analysis algorithm for kbuild makefiles section .
an implementation of the algorithm in a new tool kmax for the makefile based kbuild build system that collects all c source file names and the configurations in which they are built section .
an experimental evaluation of kmax on two build systems that demonstrates its precision accuracy and speed taking minutes for the linux build system and seconds for busybox section .
a comparison of kmax to previous kbuild analysis tools kbuildminer and golem on two versions of the linux source code showing that kmax is substantially more accurate and precise with little performance overhead and better scalability section .
kmax is available online for download1.
overview figure is a small representative example drawn from the thousands of individual makefiles comprising the linux build system2.
for brevity this example involves two configuration options aandb but makefiles in practice may have dozens or hundreds of configuration options making exhaustive enumeration of all configurations infeasible.
aandbare boolean linux configuration options which in linux means that the option is set either to yfor yes to include the feature or is left unset to exclude the feature.
makefiles do not have any other variable type besides string so boolean is a convention describing this range of values for a configuration option.
when executed this makefile determines given inputs aandb which source code files to include in the build.
lines programmatically construct the set of filenames and store them in the variable obj y which is used in the rule on lines to perform the actual build.
the first statement line is an assignment that initializes obj y tofork.o the object file corresponding to the fork.c source file.
the following if then else block tests whether aequals y line i.e.
whether feature ahas been enabled.
variables are referenced expanded in makefile terminology with the a syntax.
depending ona s value bits is either set to to line or to line .
the next statement line is another type of assignment that appends to an existing variable value.
looking first at the right hand side the value of the assignment is computed by first expanding any variable