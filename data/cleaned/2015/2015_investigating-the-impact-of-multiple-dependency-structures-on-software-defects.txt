investigating the impact of multiple dependency structures on software defects di cui ting liu yuanfang cai qinghua zheng qiong feng wuxia jin jiaqi guo y uq u school of electronic and information engineering xian jiaotong university xian china cuidi wx jin jasperguo2013 stu.xjtu.edu.cn tingliu qhzheng.
quyuxjtu mail.xjtu.edu.cn department of computer science drexel university philadelphia usa yc349 qf28 drexel.edu abstract over the past decades numerous approaches were proposed to help practitioner to predict or locate defective files.
these techniques often use syntactic dependency history cochange relation or semantic similarity.
the problem is that it remains unclear whether these different dependency relations will present similar accuracy in terms of defect prediction and localization.
in this paper we present our systematic investigation of this question from the perspective of software architecture.
considering files involved in each dependency type as an individual design space we model such a design space using one drspace .
we derived drspaces for each of the apache open source projects with revision commits and bug reports in total and calculated their interactions with defective files.
the experiment results are surprising the three dependency types present significantly different architectural views and their interactions with defective files are also drastically different.
intuitively they play completely different roles when used for defect prediction localization.
the good news is that the combination of these structures has the potential to improve the accuracy of defect prediction localization.
in summary our work provides a new perspective regarding to which type s of relations should be used for the task of defect prediction localization.
these quantitative and qualitative results also advance our knowledge of the relationship between software quality and architectural views formed using different dependency types.
index terms software structure software maintenance software quality.
i. i ntroduction over the past decades numerous approaches were proposed tohelp practitioner to predict or locate defective files and various dependency structures were used as the basis for bug prediction localization algorithms.
to the best of our knowledge three types of dependency relations have been frequently and intensively used by researchers syntactic relation derived from source code such as inheritance and method call history relation derived from the commit history of a project mainly co change frequency among files and semantic relation derived from identifiers and comments and calculate the similarity among software entities .
all of these three relations have been used as features to predict or locate software defect.
the problem is that it is not clear if and to extent these dependency relations differ from each other.
prior research focused on prediction localization algorithms but not on the underlying dependency types a more fundamental question.
ting liu is the corresponding author.in this paper we explore the following research questions f or these three dependency relations to what extent are their structures similar to each other?
there are a large number of publications on using one of them to predict locate defects and reported reasonably performance.
it is intuitive that these dependency structures should be highly similar.
we are interested in quantifying the similarity among these dependency structures to test this intuition.
if and to what extent will these three dependency relations present similar performance in defect prediction and localization tasks?
it is unclear whether they have similar relations with error prone files.
if the answer is yes it means that there is no fundamental difference among these dependency relations.
however if the answer is no we need to further investigate the next question.
whether the combination of these three dependency structures has the potential to improve the performance of defect prediction and localization?
if the answer is no it implies that these different structures can not be effectively and efficiently used together and we should consider which one to choose.
if yes we further explore how the intersection and union of these three relations contribute to software defects prediction localization.
to answer these questions we need to systematically investigate the impact of these dependency structures and their relations with defective files.
the ideal approach would be using these dependency types to conduct bug prediction location analyses and make a comparison.
however it is not realistic given the large number of existing tools and algorithms.
moreover these prediction classification models are black boxes hiding the intrinsic relations between these software structures and defective files.
instead we try to reveal the relations by reversely explaining defects from the perspective of software architecture views white box as shown in fig.
.
we employ the drspace model a state of the art reverse engineering and architecture modeling technique to support our study.
a drspace can be used to model the overall software architecture as multiple overlapping design spaces.
each design space can only capture one of many possible relations.
the drspace model is also an effective approach to analyzing software structures in a fine grained way.
in this paper we report our comprehensive empirical study to investigate the relation of three dependency types syntactic ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
history and semantic with software defects.
we intensively studied apache open source projects with revision commits and bug reports.
using drspaces for each dependency type we calculate the interaction between its design space and defective files.
based on these data we answer the three research questions as follows first comparing the structures formed by syntactic relation history relation and semantic relation only of these structures are similar.
this result implies that these three dependency relations form drastically different architecture views.
intuitively their effectiveness on defect prediction localization should be very different and it is imperative to explore their influences on software defects.
second the syntactic history and semantic relations capture different subsets of defective files.
the syntactic structure captures the largest number of defective files but with the lowest accuracy.
by contrast the history structure covers the least number of defective files but with high accuracy.
the semantic structure is in between.
it implies that although there are rich literature on using one dependency structure to predict locate software defects we should be aware of their significant differences.
we need a comprehensive understanding regarding to the relation between dependency types and defects.
third the combination of syntactic structure history structure and semantic structure has the potential to effectively improve the performance of defect prediction localization the union of them can cover most of the defective files and their intersections can capture files with most severe problems.
we present the detailed results in section iii.
the design of strategies to flexibly combine these three structures to improve the prediction localization accuracy is future work.
the contribution of our work is a systematic comparative analysis of different types of dependencies and their impact on defects.
our empirical study has revealed for the first time their drastically different relations with defective files which advanced our understanding of three dependency types.
a new perspective to analyze the software defects.
our empirical study revealed that different dependency structure captures drastically different subsets of defective files.
when a bug prediction localization algorithm is devised the designer should take their differences into account.
the union of all three relations can capture more buggy files but their intersection may capture most severe bugs.
each option comes with costs and benefits.
a benchmark to investigate the relation between software defects and various dependency structures.
we collected apache open projects involving revision commits and bug reports.
all original data and extracted dependencies are publically available1.
the rest of the paper is organized as follows section ii presents the related work.
section iii and iv introduce our methodology and experiment results.
section v presents the lj d w t d z w d fig.
predicting defects vs explaining defects discussion.
section vi presents the threats to validity.
section vii concludes the paper.
ii.
r elated work a. using dependency structures to predict defects over the past decades using various dependency structures to predict software defects has been widely studied .
we summarized classical defect prediction framework in fig.
which contains three steps generating dependency structures deriving structural measurements and training prediction models.
in each step researchers designed various strategies to improve the accuracy of defect prediction.
for example within the first two steps selby and basili first studied syntactic metrics to predict bug prone files.
nagappan et al.
also derived complexity metrics based on syntactic structures to improve prediction accuracy.
zimmermann et al.
reported that syntactic based network measures could be used to construct successful defect predictor.
furthermore cataldo et al.
derived change density metrics to measure history structures for defect prediction.
lin et al.
used advanced machine learning algorithms to automatically measure semantic structures to improve prediction accuracy.
for the third step researchers also employed several machine learning algorithms to train classification models to improve the accuracy of defect prediction.
for instance li et al.
leveraged ensemble and kernel learning algorithms in defect prediction to improve the training model.
di nucci proposed an adaptive method to dynamically select classifiers for defect prediction tasks.
our work aims to advance our understanding regarding to the impact of different software dependency types on defect prediction localization but not to propose a new prediction localization approach.
b. reverse engineering techniques reverse engineering is a technique to recover high level design from source code.
over the past decades there are rich literature about reverse engineering techniques .
these techniques first aggregate program entities such as files or classes into modules based on different rationales.
for example algorithm for comprehension driven clustering acdc is a pattern driven technique proposed by tzperpos and holt which clusters entities based on naming conventions and syntactic structures.
architecture recovery using concerns authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
lj lj d w d fig.
classic defect prediction framework arc is a nlp based techniques proposed by joshua et al.
that leverages semantic structures.
back et al.
first leveraged the combination of history and syntactic structures to improve the quality of recovered design.
mitchell et al.
also proposed a genetic method named bunch which improves reverse engineering results by optimizing objective functions .
researchers also made systematic comparisons of these techniques nenad et al.
conducted a comparative study of reverse engineering techniques and claimed that arc and acdc outperformed others in terms of accuracy.
luttellier et al.
conducted another comparative study and made similar observations.
our work uses reverse engineering methods to understand different dependency types but not to recover architecture.
c. architectural smells architectural smells were proposed to describe problematic relations among files that may have negative impact on software quality.
researchers proposed architectural smells based on different dependency types.
for instance garcia et al.
first defined a suite of code smells based on syntactical structures.
ran et al.
integrated history and syntactical relations and proposed a suite of architectural smells called hotspot patterns .
oizumi studied architectural smells by clustering classical code smells using syntactic and semantic structures.
fontana et al.
summarized the previous work and developed a tool named arcan to support the automatic detection of these smells.
our work explores the independence and combination of different dependency types but not summarizing architectural anti patterns.
iii.
m ethodology in this section we present our systematical study regarding to the impact of different dependency structures on software defects.
it is not possible for us to directly answer this question by executing defect prediction tools given the large number of them.
instead we leverage drspace a state of the art reverse engineering technique to investigate different types of relations among files and their interaction with the set of buggy files.
fig.
shows the overview of our research framework that includes three components data collection drspaces generation and issue analysis .
a. data collection here we introduce the subjects we studied the three types of relation we extracted and the defect information collected from these subjects.
subjects we studied the latest versions of projects from the apache community2.
these projects vary in sizes domains and functionalities and most of them are widely used in defect prediction research.
the number of files in these projects varies from to .
the number of lines of code loc in these projects varies from 11k to 1m.
we additionally crawled the revision history of these projects from the version control system git3 and bug reports from the issue tracking system jira4 .
we only study bug reports that have been fixed.
in total we collected commits and valid bug reports.
software relation extraction for each subject we extract its structural relation history relation and semantic relation as follows a syntactic relation syntactic dependency is the most commonly used relation among source files including inheritance implementation method call field access type reference instance creation etc.
we employed understand5 a commercial reverse engineering tool to extract structural relations among source files and denote the collected syntactic relation as e1.
b history relation history relation also known as evolutionary coupling is derived from the revision history of a project modeling the co change probability among files.
in our study we employed the history coupling probability hcp matrix a conditional probability model to manifest how likely a change to a file may influence other files.
we implemented this algorithm and configure the hcp parameters following the work of xiao et al.
.
we denote the collected history relation as e2.
c semantic relation semantic relation is derived from the source code lexicon to capture the textual similarity between files.
here we employed relation topic model rtm a probabilistic topic modeling technique to capture the semantic relation among files based on source code identifiers and comments.
we crawled the lexical information using the lexicon parser in understand and implemented rtm using the lda6package of r. we configure the rtm parameters following the work of bavota et al.
and denote the collected semantic relation as e3.
we can thus model a software system as a directed multigraph v e1 e2 e3 where vrepresents the set of files within the system and e1 e2 e3represent the syntactic authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
d lj lj z lj z lj lj z z lj z lj z z lj z lj lj z lj fig.
research framework relation history relation and semantic relation among these files respectively.
defect information extraction from each project we also extracted defect information from bug reports recorded in its issue tracking system.
for each bug report br i we collect the set of files changed to fix it and the lines of code loc spent on these fixes.
we model these data as follows br i fj churn br i fj j ... m where mrepresents the number of files involved in the bug br i .
here each bug is modeled as a set of pairs each containing two elements fjand churn br i fj representing the fixed file and the number of lines of code spent on it to fix the bug.
we also model the relation between bugs and source files as follows fj br i churn br i fj i ... n where nrepresents the number of bugs a file fj is involved.
here each file is mapped to a set of pairs each containing two elements br iand churn br i fj representing an involving bug and the number of lines of code spent to fix it.
b. drspace generation in this section we introduce our method of managing various dependency structures using design rule spaces drspaces a new architecture model.
generating drspace xiao et al.
proposed that a software system can and should be viewed as multiple overlapping design spaces that can be reverse engineered from source code.
for example a feature implemented or a pattern applied can be viewed as an individual design space that contains all the files participating in the feature pattern .
they also mentioned that different dependency types such as inheritance and method call can form their own design spaces.
based on this rationale they proposed a design rule space drspace model each capturing one design space of thesystem.
in a drspace the files are clustered into hierarchical layers and each layer is decoupled into independent modules.
files in lower layers only depend on the files in higher layers.
files in different modules within the same layer are mutually independent from each other.
moreover each drspace has one or a few leading files and all other files are directly or indirectly depend on the leading files.
for example an observer pattern drspace must contain an observer interface upon which all other pattern participants depend.
the files within a drspace can have one or more types of dependencies.
this architecture model is consistent with the definition proposed by bass et al.
the architecture of a software system is a set of structures and each drspace is one of many module structures within the system.
in our study we examine a software structure through the lenses of drspaces.
for each subject using the three types of relations extracted we model the project using a suite of drspaces syntactic drspaces syndr history drspaces hisdr and semantic drspaces semdr in which source files only have syntactic relation history coupling relation and semantic coupling relation respectively.
generating sub drspace using each file as a leading file we further split each drspace into a set of sub drspaces drspace braceleftbig sub drspacej j ... m bracerightbig where mis the total number of sub drspaces.
each subdrspace sub drspacej consists of two elements sub drspacej fj suboridnate fj where fjrepresents the leading file of the sub drspace and suboridnate fj represents the files that directly or indirectly depend on the leading file.
for each subject with xfiles that have syntactic relation with other files yfiles having history coupling with other files andzfiles having semantic relation with other files we will generate xsyntactic sub drspaces yhistory sub drspaces andzsemantic sub drspaces .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a syntactic b history c semantic fig.
three dependency structures of log4j a syntactic b history c semantic fig.
three drspaces of log4j c. issue analysis for each subject given the three drspaces and their subdrspaces we now present our method of analyzing their relations with defective i.e.
error prone files.
following the work of xiao et al.
we first use a bugspace to model the set of files involved in bug fixing.
we use bugfre x ileto model the set of files within the top xthpercentile of a bugspace ranked based on the number of times they were changed for bug fixing bug frequency .
we also use bugchurn x ileto model the most expensive files ranked within the top xthpercentile based on their lines of code loc spent on bug fixing bug churn .
archroot is a greedy algorithm designed to extract a set of sub drspaces that covers a target set of errorprone files that is files within a bug space bugfre x ile o r bugchurn x ile.
the input of this algorithm is a drspace containing all the files within the system and a target bug space.
archroot iteratively inspects each sub drspace and calculates its intersection with the target bug space and return a set of sub drspaces.
in our study we denote the union of all the files within the sub drspaces calcuated from archroot as a rootspace .
d. running example in this section we demonstrate these concepts and our method using a running example log4j .
.
a distributed logging system.
data collection.
we extracted the syntactic relation and semantic relation from log4j version .
.
.
in this snapshot there are files and pairs of them have structural relations and pairs have at least semantic similarity.
to extract history coupling relation we collect revision commits from may to aug .
within this time period there are file pairs having at least co change probability.
within the same history period we collected bug reports that have been resolved and there are files changed to fix these bugs.
employ gephi8 an open source graph visualization platform to model these three relations as graphs as shown in fig.
a c .
these graphs depict the syntactic structure history structure and semantic structure among log4j source files in which vertexes represent files and edges represent different relations among them.
as we can see from these graphs the overall structure formed by these relations are very different.
drspace and sub drspace extraction.
for each relation we generate its drspace using titan a visualization tool that present file structures using design structure matrices dsms .
a dsm is a square matrix in which rows and columns are labeled by the same set of files in the same order.
a marked cell in row xand column y cell x y means that the file in row xdepends on the file in column y. the marks in the cells can be used to denote different types of relations.
fig.
.
a c depicts the syntactic drspace history drspace and semantic drspace of log4j.
similar to fig.
we can observe that these structures are drastically different.
for each drspaces we decouple it into a set of subdrspaces each led by one file within the drspace.
fig.
depicts the syntactic sub drspace history sub drspace and semantic sub drsubpaces led by the same leading file filemanager of log4j.
we explain these dsms as follows fig.
shows the syntactic sub drspace led by filemanager .cell is labeled with dp which means that defaultrolloverstrategy syntactically depends on filemanager .
fig.
shows its history sub drspace.
cell is labeled with hc .
hc means that defaultrolloverstrategy is historically coupled with filemanager and the co change probability is .
means that these two files changed together times as recorded in the commit history.
fig.
shows the semantic sub drspace led by the same file.
cell is labeled with sc which means that defaultrolloverstrategy has lexical similarity with filemanager .
issue and root analyses.
the sub drspaces shown in fig.
are among the output sub drspaces of the archroot algorithm.
the input of this algorithm includes each drspace and all the files involved in bug fixing e.g.
bugfeq ile.
this means that these sub drspaces cover all the error prone files and reveal their relations.
for example the columns frand crillustrate the rankings of each file based on its bug frequency and bug churn.
as we can see in addition to the leading file defaultrolloverstrategy and rollingfilemanager are ranked within top ile and top ile resprectively and are captured by all three subdrspaces.
other than that however the files captured by these sub drspaces are very different.
next we explore if and to what extent their ability of capturing buggy files are different.
iv .
e xperiment in this section we present our exploration of the following three research questions to understand the impact of different authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
z z d z d z z d z lj t z lj z z nj d fig.
syntactic sub drspace of filemanager z z d z d z z d k d z lj d ljd d fig.
history sub drspace of filemanager dependency types syntactic history and semantic on software defect prediction localization rq1 what is the structural similarity among these different types of relations?
the answer to this question will advance our understanding regarding to the overall differences of these three relations.
rq2 does each dependency structure present similar performance in terms of capturing defective files?
the answer to this question will shed lights on their differences in terms of locating or predicting bugs.
rq3 can the combination of these three structures improve the accuracy of predicting locating defects?
what about their intersection and union?
the answer to this question will provide suggestions regarding to how different relations can be better leveraged.
a. structural similarity approach to answer rq1 we measure the overall similarity among these three different relations using mojofm and use c2c to measure the local similarity among sub drspaces lead by the same file.
as