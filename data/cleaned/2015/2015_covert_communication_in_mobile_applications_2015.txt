mit open access articles covert communication in mobile applications the mit faculty has made this article openly available.
please share how this access benefits you.
your story matters.
citation rubin julia michael i. gordon nguyen nguyen and martin rinard.
covert communication in mobile applications.
30th ieee acm international conference on automated software engineering november .
as published publisher institute of electrical and electronics engineers ieee persistent url version author s final manuscript final author s manuscript post peer review without publisher s formatting or copy editing terms of use creative commons attribution noncommercial share alike covert communication in mobile applications julia rubin michael i. gordon nguyen nguyenxand martin rinard massachusetts institute of technology usa xglobal infotek inc usa mjulia mit.edu mgordon mit.edu nguyen uwinsoftware.com rinard mit.edu abstract this paper studies communication patterns in mobile applications.
our analysis shows that of the external communication made by top popular free android applications from google play has no effect on the user observable application functionality.
to detect such covert communication in an efficient manner we propose a highly precise and scalable static analysis technique it achieves precision and recall compared to the empirically determined ground truth and runs in a matter of a few minutes.
furthermore according to human evaluators in out of cases disabling connections deemed covert by our analysis leaves the delivered application experience either completely intact or with only insignificant interference.
we conclude that our technique is effective for identifying and disabling covert communication.
we then use it to investigate communication patterns in the top popular applications from google play.
i. i ntroduction mobile applications enjoy almost permanent connectivity and the ability to exchange information with their own backend and other third party servers.
this paper shows that much of this communication does not deliver any tangible value to the application s user disabling it leaves the delivered application experience completely intact.
yet this covert communication comes with costs such as potential privacy breaches bandwidth charges power consumption on the device and the unsuspected presence of continued communication between the device and remote organizations.
in fact we observed that several popular applications e.g.
walmart and twitter spawn services that covertly communicate with remote servers even when the application itself is inactive and the user is unaware that the spawned services are running in the background.
this paper focuses on distinguishing between overt communication that contributes to the application functionality anticipated by the user and covert communication that is hidden and unexpected from the user s point of view.
we start by analyzing communication patterns of popular applications in the google play app store.
motivated by the significant amount of covert communication we found in these applications we develop a highly precise and scalable static analysis that can identify such communication automatically.
we use our analysis to further investigate this unfortunate phenomenon and report on our findings.
the following research questions drive this investigation rq1 how frequent is covert communication?
we conduct an empirical study that focuses on investigating the nature of communication in thirteen of the top twenty most popular applications in google play twitter walmart spotify pandora etc.
.
for each connection statement triggered by these applications we compare the dynamic execution of the original application to that of the application with the corresponding statement being disabled.we consider all visual content delivered by the application including advertisement as essential and necessary avoiding any subjective judgment on the relevance of that information to the user.
that is we consider application executions as equivalent if they differ only in contextual information such ascontent of advertisement information and or messages in social network applications e.g.
twitter.
our study reveals that of the exercised connection statements are covert disabling them has no noticeable effect on the observable application functionality.
interestingly less than half of such covert connections correspond to communication initiated from known advertisement and analytics a a packages included in the application.
thus looking at the package information only is not sufficient for distinguishing between overt and covert communication.
rq2 can covert communication be detected statically?
detailed investigation of multiple detected cases of covert connections inspired us to develop a novel static application analysis that can detect such connections automatically.
the core idea behind our analysis is to look for cases when both connection success and failure are silently ignored by the application i.e.
when no information is presented to the user neither on success nor on failure of the connection.
for a connection statement we analyze the portion of the program s control flow graph that corresponds to the direct processing of the connection.
this includes forward stack processing andfailure handling executions.
the former is the nonexceptional execution reachable after the connection statement but limited to processing of the android runtime events that trigger the connection statement.
the latter traverses methods up all possible call stacks from the connection statement but stops at points at which the exception raised by the connection statement and all related rethrown exceptions are cleared.
the direct processing of the connection call is searched for method call invocations that could target a predefined set of api calls that affect the user interface.
if such a call is found the connection call statement is deemed overt.
furthermore if the exception could be propagated back to the android runtime causing the application to exit the connection call is deemed overt.
otherwise it is deemed covert.
there are two reasons for the analysis to misclassify a connection as covert.
first it does not take into account user interface ui updates that occur outside of the connection s direct processing but are caused by the connection altering a local or a remote state.
second the semantics of the direct processing itself is defined solely by the application s byte code i.e.
it does not consider native code and inter application executions.
our experiments show that these cases are rare which together with the high scalability of the technique justifies our design choices.rq3 how well does static detection perform?
to assess the precision and recall of the static analysis technique we evaluate it on the truth set established during the in depth dynamic study described above.
the results show that our technique features a high precision of the covert connection calls identified by the static analysis are indeed classified as covert during the dynamic study.
moreover even though the technique is designed to be conservative and favor high precision over high recall it is still able to identify of all covert connections in the studied applications.
there are only two connections that were misclassified as covert both due to the reasons mentioned above.
the first one occurs because a ui update in this case presenting icons of additional apps that can be downloaded from google play happens outside of the connection s direct processing.
the second case which is responsible for presenting advertisement material via the google ads component installed on the device occurs because the direct processing of the connection does not extend to asynchronous rpc communication with google services installed on the device.
to gain further insights on the quality of the technique we apply it to additional top popular applications from google play.
for these applications we disable all connection statements deemed covert by the analysis.
we then employ humans to perform a usability assessment we provide them with two identical devices one running the original and the other the modified version of the application.
we ask them to track and report on any observable differences between the runs of an application on two devices.
the results of this assessment are encouraging there are no observable differences in .
of the applications cases .
in .
of the applications cases differences are related to absence of functionality considered minor by the users e.g.
ads or decorating images.
only .
of the applications cases miss functional features considered essential by the users.
this result implies that our static analysis produces actionable output that could already be applied to eliminate many cases of covert communication.
rq4 how often does covert communication occur in reallife applications and what are its most common sources?
we apply the analysis on the top popular applications from google play.
this experiment reveals that of connection statements encoded in these applications are deemed covert.
most common sources of covert communication are google services and various a a services.
yet these are not the exclusive source of covert communication and not all communication made from these packages is covert.
significance of the work.
in the authors state that the system should continuously inform the user about what it is inspired by this principle the goal of our work is to identify application functionality hidden from the user.
this paper studies the extent of that problem in benign applications downloaded from popular application stores and installed by millions of users.
we believe that our findings help focus the effort of improving transparency and trust in the mobile application domain.
contributions.
the paper makes the following contributions it sets a new problem of distinguishing between overt and covert communication in an automated manner.
it proposes a semi automated dynamic approach for detecting covert communication in android applications.
the approach relies on interactive injection of connection failures in application binaries and identification of cases in which such injections do not affect the observable application functionality.
it provides empirical evidence for the prevalence of covert connections in real life applications.
specifically it shows that of the connections attempted by thirteen toppopular free applications on google play fall into that category.
it proposes a static technique that operates on application binaries and identifies covert connections.
the technique is highly scalable and precise out of highly popular applications on google play .
worked without any interference and further .
worked with only insignificant interference when disabling all covert connections identified by the technique.
the technique also features precision and recall when evaluated on the truth set established dynamically.
it provides quantitative evidence for the prevalence of covert connections in the top popular free applications on google play and identifies their common patterns.
ii.
c ommunication in android in this section we describe the design of the study that we conducted to gain more insights into the nature of communication performed by android applications.
we then discuss the study results.
a. design of the study connection statements table i lists the base classes and their corresponding methods that we consider in our study.
we also include all sub classes of those listed in the table.
when a connection failure occurs e.g.
when the desired server is unavailable or when a device is put in disconnected or airplane mode each of these methods throws a java.io.ioexception exception.
thus for investigating the significance of a connection for the overall behavior of an analyzed application we inject a connection failure by replacing the connection statement with a statement that throws such an exception.
this approach was chosen as it leverages the applications native mechanism for dealing with failures thus reducing side effects introduced by our instrumentation to a minimum.
application instrumentation as input to our study we assume an android application given as an apk file.
we use the dex2jar tool suite to extract the jar file from the apk.
we then use the asm framework to implement two types of transformations a monitoring transformation which produces a version of the original application that logs all executions of the connection statements in table i. table i. c onsidered connection statements .
class or interface method .java.net.url openconnection .java.net.urlconnection connect .org.apache.http.client.httpclient execute .java.net.socket getoutputstream a screen .
b screen .
c diff.
for a and b .
fig.
.
visual differences.
a blocking transformation which obtains as additional input a configuration file that specifies the list of connection statements to disable.
it then produces a version of the original application in which the specified connection statements are replaced by statements that throw exceptions.
the jar file of the transformed application is then converted back to an apk using the dex2jar tool suite and signed with our own signature using the jarsigner tool distributed with the standard java jdk.
as a known side effect of resigning applications their authentication for services such as google plus apis might be broken .
as a result users might be unable to sign in with their google plus account or perform in app purchases from the google play store.
for that reason we refrain from executing such scenarios in our analysis.
automated application execution and comparison comparison of user observable behavior requires dynamic execution of the analyzed applications.
the main obstacle in performing such comparison is the ability to reproduce program executions in a repeatable manner.
to overcome this obstacle we produce a script that automates the execution of each application.
we experimented with android s monkey tool but it was unable to provide a reasonably exhaustive coverage as it quickly locked itself out of the application by generating gestures that the analyzed application cannot handle.
we thus recorded the desired application execution scenario manually including in the recording any semantic user input required by the application e.g.
username and password.
we used the android getevent tool that captures all user and kernel input events.
we made sure to pause between user gestures that assume application response.
we then enhanced the script produced by getevent to insert a screen capturing command after each pause and between events of any prolonged sequences.
for the comparison of application executions we started by following the approach in where screenshots from two different runs are placed side by side along with a visual diff of each two corresponding images as shown in fig.
for the walmart application.
we used the imagemagick compare tool to produce the visual diff images automatically.
we then manually scanned the produced output while ignoring differences in content of widgets that are populated by applications in a dynamic manner because such widgets areexpected to differ between applications runs.
that is weignored differences in the exact content of the advertisement messages but not their overall presence absence and position content of social network messages e.g.
tweets and the status of the device e.g.
the exact time.
as such the screenshots in figs a and b were deemed similar they differ only in the content of the advertisement information and the information in the status bar.
in one of the analyzed cases we had to revert to manual execution and comparison of the application runs.
that case involved interactions with a visual game that required rapid response time thus the automated application execution was unable to provide reliable results.
execution methodology we performed our study in three phases.
in the first phase we installed the original version of each analyzed application on a nexus mobile device running android version .
.
.
we manually exercised the application for around minutes exploring all its functionality visible to us.
our goal was to a achieve sufficient coverage and b keep the application active long enough to allow any background data fetch processes to manifest themselves in the application s ui.
yet we refrained from executing functionality related to signing in into the user s google plus account or performing in app purchases due to the resign related limitations mentioned above.
we recorded the execution script that captured all triggered actions.
we then re installed the application and re ran the script to collect screenshots that were used as the baseline for further comparisons.
in the second phase we used the monitoring transformation to produce a version of the application that logs information about all existing and triggered connection statements.
we ran this version using the recorded execution script and collected the statistics about its communication statements.
in the third phase we iterated over all triggered connection statements disabling them one by one in order to assess the necessity of each connection for preserving the userobservable behavior of the application.
that is we arranged all triggered connection statements in a list in a lexical order and then applied the blocking transformation to disable the first connection statement in the list.
we ran the produced version of the application using the recorded execution script and compared the obtained screenshots to the baseline application execution.
if disabling the connection statement did not affect the behavior of the application we marked it as covert kept it disabled for the subsequent iterations and proceed to the next connection in the list.
otherwise we marked the exercised connection as overt and kept it enabled in the subsequent iterations.
we continued with this process until all connections in the list were explored.
as the final quality measure we manually inspected the execution of the version in which all covert connections were blocked to detect any possible issues missed by the automated analysis.
subjects as the subjects of our study we downloaded the top popular applications available on the google play store in november .
we excluded from this list chat applications as our evaluation methodology does not allow assessing the usability of a chat application without a predictably available chat partner.
we also excluded applications whose asm based instrumentation failed most probably becausetable ii.
a nalyzed applications .
applications jar size mb total of connection statements of triggered connection statements of covert of trig.
of covert in known a a of total covert air.com.sgn.cookiejam.gp .
.
.
com.crimsonpine.stayinline .
.
.
com.devuni.flashlight .
.
.
com.emoji.smart.keyboard .
.
.
com.facebook.katana .
com.grillgames.guitarrockhero .
.
.
com.jb.emoji.gokeyboard .
.
.
com.king.candycrushsaga .
.
com.pandora.android .
.
.
com.spotify.music .
.
.
com.twitter.android .
.
.
com.walmart.android .
.
.
net.zedge.android .
.
.
total .
.
they use language constructs that are not supported by that framework.
the remaining thirteen applications are listed in the first column of table ii their corresponding archived byte code sizes are given in the second column of the table.
b. results the quantitative results of the study are presented in table ii.
columns and of the table show that only a relatively small number of connection statements encoded in the applications are in fact triggered dynamically.
some of the non triggered statements correspond to execution paths that were not explored during our dynamic application traversal.
yet the vast majority of the statements originate in thirdparty libraries included in the application e.g.
google and facebook services for mobile developers and various a a libraries.
such libraries are often only partially used by an application which could explain the incomplete coverage.
an interesting case is the facebook application row in table ii where most of the application code is dynamically loaded at runtime from resources shipped within the apk file.
our analysis was unable to traverse these custom packed resources and we thus excluded the application from the further analysis noting that the only three connection statements in the application jar file are never triggered.
we also excluded from the further analysis the candy crush saga application row in table ii as it did not exhibit any covert connections.
classification of the triggered statements column of table ii shows the number of connection statements that we determined as covert during our study.
averaged for all applications .
of the connections fall in that category.
this means that only of the connection statements triggered by an application affect its observable behavior when executed for the exact same scenario with the connection being either enabled or disabled.
determining the original purpose of these covert connections is a non trivial task as implied by their nature they do not exhibit any observable behavior.
due to obfuscation virtually no semantic insights about the purpose of these connections can be drawn from the manual analysis of the application binaries either.
in an attempt to shed some light on the essence of these connections we inspected package and class names as well as execution stack traces of the methods containing the covert connection statements.
we also inspected the data traffic that corresponds to these connections by routing the communication through a proxy that is able to sniff the data and decrypt the ssl encoding if needed .we discovered that only out of connections originate from the known a a libraries as shown in the last column of table ii.
another connections appear to be responsible for the a a content as well.
however they come either from application specific packages or from thirdparty libraries that cannot be immediately linked to a a. for example the walmart application triggers a covert connection from the com walmartlabs analytics package which appears to be a proprietary analytics service.
analytics services collect information about application performance crash and usage data as well as the exact actions the user performs within the app.
while this information has a clear value to the developer no apparent description specifying the nature and frequency of the data collection is presented to the user.
in fact some applications start collecting analytics information even before they get activated.
for example twitter walmart and pandora start their data collection as soon as the phone is booted and continue periodically during the phone s entire up time even if the applications themselves were never used.
in most cases the user cannot opt out from such data sharing without uninstalling the application.
beyond a a several applications release information to their own and or third party services without causing any effect on the applications observable behavior.
for example twitter uses covert connections to collect information about videos and other rich media attachments followed by the users in tweets.
the go keyboard application sends via a covert connection a set of ids to the launchermsg.3g.cn server it also sends some encrypted data which we could not decode tonextbrowser.goforandroid.com .
both pandora and spotify music players use facebook s social graph services sending out information about the application usage.
as another example the walmart application incorporates the barcode scanner library provided by red laser an ebay company that specializes in comparing prices.
this library causes the application to send out information about the scanned barcode to the data.redlaser.com server.
yet blocking that release of information does not harm the scanning capabilities.
to answer rq1 we conclude that covert communication often occurs in real world applications .
of the triggered connection statements can be deemed covert.
lessons learned as shown in the last column of table ii only of the covert connections originate in the known a a libraries.
as such distinguishing between overt and covert connections only by considering their package name schema is ineffective.
moreover some malicious applications deliberately hide their payloads by using package names which look legitimate and benign .
we conclude that a more sophisticated technique for identifying the covert communication performed by the applications is required.
we manually investigated binaries of the analyzed applications to gain more insights into the implementation patterns of covert connections.
we noticed that in a large number of cases neither successes nor failures of such connections trigger visual notifications to the user.
for the failures the triggered exception is often either caught and silently ignored in the method that issues the connection or more commonly propagated upwards in the call stack and then ignored by one of the calling methods.
in several cases an error or warning message is written to the android log file.
however this file is mostly used by developers rather than end users.
to answer rq2 we conjecture that covert connections can be detected by inspecting updates to ui elements on both the success and the failure path of a connection statement.
lack of such ui updates is indicative for a connection being covert for the application execution as the user is unaware of both the success and the failure of the communication.
iii.
s tatic analysis for classifying connections in this section we describe the static analysis algorithm we employ to automatically classify connections.
android applications are developed in java as a series of external event handler routines e.g.
button click and application exit.
given an android application the static analysis classifies each statement that may invoke a connection call as either overt or covert .
we begin by giving a precise definition of overt and covert connections assumed by the analysis.
definition overt and covert connections .
for connection statement s sis classified as overt if it meets at least one of the following criteria ui cue on failure when striggers an exception e the user may be notified of the failure via a user interface cue during failure handling ofsone.
program exit on failure when striggers an exception e the program may stop executing due to an execution path that propagates eback up to the android runtime.
ui cue on success when ssucceeds there exists a possible modification to the user interface before either a the next external event is handled by the application or b processing continues beyond the failure handling ofs.
conversely a covert connection call does not meet any of the criteria.
failure handling is defined precisely in section iii b. intuitively the failure handling of connection statement s on exception type eare the computation paths that handle eand any failures triggered by the handling of e through rethrown exceptions .
failure handling is finished when all exceptions triggered by eare handled and flow returns to normal execution.
in what follows we discuss how we compute a static call graph that represents possible method targets of each call expression in the android application.
we then discuss our analysis on top of this graph.
for each connection statement the analysis consists of three steps failure handler analysis success forward analysis and success backward analysis.
table i lists the target methods that are considered as connection calls.
the set of target methods that are considered as affecting the user interface are listed in table iii also included are all overriding methods .
a. constructing an accurate call graph for android apps static analysis of android applications is notoriously difficult because of the complexity and dynamic nature of the an droid runtime and api precise whole program analysis runs the high risk of missing dynamic program behavior and not scaling to real world android applications.
static analysis must either model the android execution environment or account for possible dynamic program behaviors with conservative analysis choices otherwise some runtime behaviors could be unconsidered.
our analysis over approximates the runtime behaviors of the applications and under approximates the connection calls that could be covert.
the analysis prioritizes high precision over high recall because we do not want to block connection calls that perform overt communication.
our analysis employs a class hierarchy analysis cha to build a call graph with refinement achieved by intra procedural data flow analysis as discussed later.
after much experimentation with higher precision though brittle points to analysis techniques this analysis combination gave us the best performance for the classification task.
our analysis is implemented in the soot analysis framework and utilizes the android api model provided by droidsafe .
the presentation of the analysis below assumes the application is represented in the jimple intermediate language .
to compute a call graph we augment the application code with the droidsafe android device implementation adi .
the adi is a java based model of the android runtime and api.
it attempts to present full runtime semantics for commonly used classes of the runtime and api.
our call graph construction begins at each application method that could be a target of the android runtime i.e.
the event handler methods of the application.
call graph construction does not traverse into android api methods.
as such the call graph is actually a forest of graphs each rooted at an event handler of the application and each graph includes only applicationdefined methods.
however we found it necessary to account for api calls that directly call back into the application e.g.
thread.start .
we achieve that by replacing the api call with a direct call to the application method s that the api call could invoke e.g.
thread.run .
the call graph is augmented to account for reflected method calls using the following policy.
when a reflected call is found we add edges to the graph that target all methods of the same package domain as the caller e.g.
com.google com .facebook .
the edges are pruned by the following strategy if the number of arguments and argument types to the call can be determined using a def use analysis then we limit the edges to only targets that have the same number and types of arguments.
this strategy works well for us in practice and aggressively accounts for reflection semantics.
b. failure handler analysis failure analysis determines if a connection call modifies the ui or could exit the application on exception.
we organize the static failure handling analysis as a recursive traversal on the call graph.
an iterator over all application statements calls the analysis separately for the combination of each statement in the application that could target a connection call and an exception that indicates communication failure.
conceptually the failure handling of soneis defined as a slice of instructions.
in the slice are all statements that aretable iii.
c onsidered ui e lements .
class or interface methods .android.app.dialog setcontentview .android.support.v7.app.
actionbaractivitydelegatesetcontentview .android.view.view onlayout layout ondraw onattachedtowindow .android.view.viewgroup addview addfocusables addtouchables addchildrenforaccessibility .android.view.viewmanager addview updateviewlayout .android.view.windowmanagerimpl.
compatmodewrapperaddview .android.webkit.webview loaddata loaddatawithbaseurl loadurl .android.widget.textview append settext .android.widget.toast maketext procedure findcatches meth stmt ex visiting stack cg if stmt ex 2visiting orstmt2overt then return end if visiting visiting stmt ex catchblockstart findcompat catch meth stmt ex ifcatchblockstart null then ifisevent handler meth then overt overt stmt return end if for predstmt predmeth 2getpreds cg meth do ifstack6 and predstmt predmeth peek stack then continue end if newstack stack p op newstack f indcatches predmeth predstmt ex visiting newstack cg ifpredstmt2overt then overt overt stmt return end if end for else catchstmts getcatch stmts catchblockstart meth a nalyze handler meth stmt catchstmts visiting stack cg end if end procedure fig.
.
find catch blocks for exception thrown at statement.
reachable from all catch blocks that can handle e. then for each reachable statement in the slice that could throw an exception of type f we recursively add to the slice all statements that are reachable from all catch blocks that could dynamically handle f. next we recursively process those newly added statements that could throw an exception.
in the processing android api methods are not considered and searching for a handler does not propagate into the android runtime environment.
the analysis starts with the f indcatches procedure listed in fig.
.
it employs a set of helper procedures the nonobvious ones are listed in fig.
and the full list is available in .
f indcatches is called separately for each connection statement and exception pair stmt and ex respectively.
the arguments to the procedure also include stmt s enclosing method meth the set of currently visiting statements and exception pairs visiting initially empty the call stack built when searching forward on a path of the call graph stack initially empty and the pre calculated call graph cg .
for stmt and ex the procedure first consults stmt s containing method to find an appropriate catch line .
if ex is not caught locally and meth is an event handler called from the android runtime then we conservatively calculate that stmt1 procedure analyze handler meth exceptstmt stmts visiting handledstmts stack cg ifstmts2handledstmts then return end if handledstmts handledstmts stmts foreach stmt2stmts do ifhasinvoke stmt then for succstmt succmeth 2getsuccs cg stmt do ifisuim ethod succmeth then overt overt exceptstmt return else if isnative method succmeth then fornativeex2getthrows exceptions succmethd do f indcatches meth stmt nativeex visiting stack cg end for else newstack stack p ush newstack succstmt succmeth succstmts getbodystmts succmeth a nalyze handler succmeth exceptstmt succstmts visiting handledstmts newstack cg end if end for else if isthrow stmt stmt then rethrowntypes fordefstmt2getlocal defs getop stmt do ifisalloc defstmt then rethrowntypes rethrowntypes gettype defstmt else if iscaught exception stmt defstmt then rethrowntypes rethrowntypes g etpossible thrown types meth defstmt else overt overt exceptstmt return end if end for forrethrowntype2rethrowntypes do f indcatches meth stmt rethrowntype visiting stack cg ifstmt2overt then overt overt exceptstmt return end if end for end if end for end procedure fig.
.
analyze reachable statements during failure handling.
could cause application exit and it is added to the overt set lines .
otherwise the analysis recursively visits all direct caller methods to find catch blocks that trap the call graph edge lines as discussed later.
if a compatible handler is found locally lines the analysis calls the procedure a nalyze handler on the statements of the compatible block.
this procedure analyzes the reachable statements of the handler.
if a call that could target a ui method is encountered then the statement that began the handler analysis is considered overt since the failure handling affects the user interface lines in fig.
.
if the analysis finds a call to a native method we assume that the method will throw all exceptions it is defined to throw and the handler analysis spawns a f indcatches instance for each exception declared throws lines .
when the analysis finds a call to an application method it pushes the current statement and method onto the stack and recursively calls itself for the new method to analyze the new method s statements lines .
if the analysis finds a throw statement it spawns a new findcatches analysis to find all the possible handlers of each rethrown exception lines .
towards this end it first calculates local def use chains to obtain the types of the exception.
in lines the analysis considers all local reaching defs of the thrown value.
if an allocation statementfindcompat catch meth stmt ex return the first statement of the catch block that will handle an exception of type exthrown at statement stmt in method meth.
getcatch stmts stmt meth given the start of a catch block defined in the trap table of method meth return all statements that were defined in the source code for the catch block of stmt .
this method calculates an over estimation of catch block extents e.g.
it includes finally blocks.
getpossible thrown types meth stmt calculate the possible exception types caught at the catch block that begins with stmt ofmeth .
the statements of thetry block that associates with the catch block that encloses stmt for a call statement the procedure adds to the return list all exception types declared throws by all methods that the call can target for a throw statement the reaching definitions of the thrown value are calculated.
if the reaching definition is an allocation then add to the return list the type of the allocation.
if the reaching definition is a caught exception statement then g etpossible thrown exceptions recursively calls itself to find the nesting try block statements and continue the calculation.
if a definition of any other statement type can reach the thrown value then return null to denote that it cannot calculate the thrown.
fig.
.
failure handling analysis helper functions.
reaches the throw then the allocated type is added to the set of possible types of the rethrown exception.
if a caught exception reference c reaches the throw statement then the try block associated with catch block of cis analyzed for all checked exceptions that could be thrown.
this is performed in the g etpossible thrown types call in line of a nalyze handler .
if only allocations and caught exception statements reach the thrown value then the handler analysis spawns a new f indcatches instance to analyze the failure handling.
a stack of pairs of method call statement and target method is maintained.
the analysis uses the stack to focus the handler search in f indcatches after a method call has been performed by a handler further up the stack lines in fig.
.
when we initiate the analysis for a connection call the stack is empty and the analysis in f indcatches has to search all possible stacks predecessor of the containing method for handlers of the connection statement s exception.
however once a handler is found and the handler calls a sequence of methods that ends in a possible rethrown exception the sequence of methods defines the only stack that should be searched for a handler of the rethrown exception line .
the stack is pushed in line of a nalyze handler for each method call of a reachable handler code.
during the handler search of the execution stack in f indcatches the stack is consulted to guide the search in line only visiting the edge at the head of the stack.
the stack is popped when visiting a caller method of the current method in f indcatches line .
c. success analysis for connection statement stmt if the failure handling analysis concludes that no ui call could be invoked during failure handling and all stacks handle stmt s exception then the analysis continues with the success paths of stmt.
the success analysis determines if there is any ui modification after the connection succeeds but before control returns to the android runtime environment and before control merges back to the failure handling paths.
here we summarize the success analysis of connection call stmt enclosed in method meth by presenting a high level description of two conceptual phases success forward analysis code reachable from the statement immediately after stmt is searched for a connection call.
this is accomplished by traversing all paths in the interprocedural control flow graph cfg starting at stmt and following method invoke expressions via the call graph.
we follow both normal and exceptional control paths when analyzing the cfg.
success backward analysis for all methods caller such that there is a path from caller to meth in the call graph and caller was searched during the failure handling analysis examine all statements of caller for calls that affect the user interface.
this has the effect of traversing the call graph backwards from meth at stmt for ui calls stopping at event handlers that are called by the android api and on a path stopping once the exception of stmt is handled.
if the success forward and success backward analysis do not find any calls that could affect the user interface then the connection call is classified as covert.
d. design discussion the intuition for our static analysis is that overt connection calls always affect the user interface either on success or failure.
another insight gleaned from the study in section ii is that normal processing of a connection often ends when the exceptional and non exceptional control flow paths merge.
hence the success backward analysis only examines methods that were analyzed by the failure analysis.
furthermore we use the enclosing runtime event handlers to bound the connection call processing.
iv.
e xperiments we start by assessing the quality of our static analysis technique.
we then apply the technique to gather information about common patterns of covert communication in the most popular android applications on google play.
a. quality of the static analysis we first evaluate the accuracy i.e.
precision and recall of our technique on the truth set established during our in depth case study see section ii .
then via a usability assessment we evaluate the user experience when running a version of an application in which all connections deemed covert are disabled.
accuracy for the accuracy evaluation we look again at the applications listed in table ii excluding facebook and candy crush because these applications did not exhibit any covert communication.
we limit the set of results reported by the static analysis to those that were in fact triggered dynamically as only for these we have the ground truth established.
we assess the results for each application individually and averaged for all applications using the metrics below precision the fraction of connection statements correctly identified as covert among those reported by the technique.
recall the fraction of connection statements correctly identified as covert among those expected i.e.
marked as covert during the dynamic study.
execution time the execution time of the analysis measured by averaging results of three runs on an intel xeon cpu e5 v2 .00ghz machine running ubuntu .
.
.
the machine was configured to use at most 16gb of heap and to perform no parallelization for a single application i.e.
each application uses one core only.
the results of this experiment are summarized in table iv.
the second column of the table shows that the overall averaged precision of our analysis is .
.
the analysis correctly identifies all but two covert connections.
the first one in com.devuni.flashlight is responsible for presenting icons of application extensions that can be downloaded from google play.
the misclassification stems from the fact that ui updates for these icons happen after the success and failure paths unify and thus are missed by our search.
the second misclassified connection in net.zedge.android is responsible for presenting advertisement material and belongs to the com.mopub.mobileads a a service library packaged with the application.
that library relies on asynchronous rpc communication with google services installed on the same device.
our static analysis is not designed to track interapplication communication between various applications and services on the device hence the false positive result.
even though our analysis is designed to be conservative it is able to correctly identify .
of statements deemed covert in the empirical study see column in table iv .
the major reasons for why we do not achieve higher recall are a conservative though feasibly analyzable definition of direct processing related to a connection call and conservative call graph construction specifically w.r.t.
reflection.
such solution is aligned with our goal of providing actionable results which are safe albeit under approximate.
finally the analysis is highly efficient and runs in a matter of minutes even on large applications as shown in the last column of table iv.
usability assessment to check whether our technique is able to provide actionable results we further selected applications that persisted in the list of the most popular free applications on google play in the january and may samples.
we installed the original version of each application on a nexus device running android v4.
.
.
on an identical device we installed a modified version of each application that was produced by employing the blocking transformation see section ii to disable all calls identified as covert by the static analysis.
we recruited two human subjects both experienced software developers and paired each with an author of this paper.
each pair was given one device with the original and one with the modified versions of the applications.
we asked them to execute the same application simultaneously on both devices for around minutes and to record all differences observed during the execution.
similar to the experiment described in section ii our goal was to ensure sufficient coverage and manifestation of background data fetch processes in the application s ui.
we asked the participants to avoid signing in with a google plus account or performing in app purchases from the google play store as these features are not supported in resigned applications as discussed in section ii.table iv .
c omparison withthemanually established results .
applicationscorrectly detected covert execution time precision recall air.com.sgn.cookiejam.gp .
.
2min 11s com.crimsonpine.stayinline .
.
2min 24s com.devuni.flashlight .
.
1min 44s com.emoji.smart.keyboard .
.
1min 16s com.grillgames.guitarrockhero .
.
6min 14s com.jb.emoji.gokeyboard .
.
3min 22s com.pandora.android .
.
2min 41s com.spotify.music .
.
2min 51s com.twitter.android .
.
3min 3s com.walmart.android .
.
3min 2s net.zedge.android .
.
4min 13s average .
.
2min 48s to analyze the results of that experiment in a reliable manner we exclude applications that were non operational either did not run in the original version or required payment to continue running applications for which asm based instrumentation failed or the instrumented version did not run due to the issues related to the resigning process google applications that we could not re install on a device chat applications applications that either contained no connection statements or had no covert connection statements detected and applications for which no covert connection statement were triggered during the dynamic execution of the application.
information about the remaining applications is below.
identical .
.
our participants did not observe any noticeable differences in these applications which confirms that the connection statements deemed covert by the static analysis have indeed no effect on the user observable application behavior.
missing advertisement .
.
advertisement information was missing in cases for the same reason as in the zedge example described above.
missing minor functionality .
.
the participants observed the absence of features that they perceived as minor cases of missing icons in talkingben as well as in the flashlight application discussed above and case where they were unable to create an account for the antivirus application but the core functionality of that application was intact.
missing essential functionality .
.
only applications were missing essential functionality battery saver spider man and minion rush games microsoft office mobile and picsart photo studio.
we conjecture that the last case is related to resigning issues.
other cases stem from the limitations of our static analysis techniques performing intra application analysis ignoring stateful communication and restricting the search for ui updates only to statements that occur before the success and failure paths unify.
we believe that the low number of such cases together with the high scalability of our analysis justifies these choices.
on average .
covert call statements per application were triggered at runtime min max mdn .
as each statement can be executed multiple times we also counted all dynamic call instances of these statements obtaining the average of covert call instances per application min max mdn .
the high average numbers are due to applications that once installed are constantly executed in the background and as it turns out attempt network communication.
examples of such applications are com.cleanmaster.mguard and com.ijinshan.kbatterydoctor en.to answer rq3 we conclude that the static analysis proposed in this paper can be applied for an accurate detection of covert connections.
the technique is precise highly scalable and provides actionable output that can be directly used for disabling covert communication in a vast majority of cases.
b. covert communication in the wild we next apply our technique to the most popular android applications downloaded from the google play store in january .
by considering such a large data set our goal is to investigate how often covert communication occurs and what its most common sources are.
our analysis reveals that .
of all connection statements in these application can be considered covert connections out of in total .
these results adjusted by the precision and recall rates of the analysis are consistent with the observation of our empirical study described in section ii.
table v presents the top packages in which covert connections occur.
as we analyzed free applications that frequently use third party packages and then aggregated the numbers for such applications it is no surprise that google services gaming and a a services are at the top of the list the number of applications that use each of these packages is shown in the third column of table v. more surprising is the com.gameloft package row of table v even though it is part of only different mobile applications published by the same company the number of covert connection statements these game applications contain is notable.
the last column of table v shows the percentage of covert connections out of all connection statements in the corresponding package.
this number varies between and confirming again our initial observation in section ii that the source of a connection cannot be used to determine its impact on the application behavior.
to answer rq4 we conclude that covert communication is common in real life applications.
such communication is not exclusive to a a packages and not all communication stemming from these packages is covert.
v. l imitations and threats to validity empirical study our empirical study has a dynamic nature and thus suffers from the well known limitations of dynamic analysis it does not provide an exhaustive exploration of an application s behavior.
even though we made an effort to cover all application functionality visible to us we might have missed some behaviors e.g.
those triggered under system settings different from ours.
to minimize unexpected results we performed all our dynamic experiments on the same device at the same location and temporally close to each other.
we also automated our execution scripts in order to compare behaviors of different variants under the same scenario and settings.
we only report on the results comparing these similar runs.table v .
t op10 c overt communication callers .
package description used in of appscovert calls of total calls .com.google.android google services .
.
.com.gameloft mobile games .
.
.com.inmobi a a services .
.
.com.millennialmedia.
androida a services .
.
.com.mopub.mobileads a a services .
.
.com.tapjoy a a services .
.
.com.facebook facebook services .
.
.com.unity3d gaming services .
.
.
default default package of an application .
.com.flurry a a services .
yet due to the limitations of dynamic analysis we could encounter false positive results a connection statement that we classified as covert could have an effect on an unexplored part of an application.
at the same time we could also have falsenegative results changes in user interface could stem from the non determinism in an application itself rather than the absence of communications.
moreover by focusing on individual connection statements we cannot distinguish between multiple application behaviors that communicate via the same statement in code.
we thus conservatively deem a connection as overt if it is overt for at least one of such behaviors.
exploring more sophisticated techniques for identification of covert connections could be a subject of possible future work.
finally our study only includes a limited number of subjects so the results might not generalize to other applications.
we tried to mitigate this problem by not biasing our application selection but rather selecting top popular applications from the google play store and by ensuring that we observe similar communication patterns in all analyzed applications.
a static technique for detecting covert connections our technique deems as covert stateful communication that toggles the state of a connection target but does not present any information to the user.
in many cases detecting such communication statically is impossible because the code executed on the target is unknown and unavailable.
for a similar reason in this work we do not consider rpc communication with applications installed on the same device.
we might explore that direction as part of future work.
moreover our analysis searches for communication that affects the application ui in a direct manner rather than transitively through other resources.
extending the analysis to cover such cases while maintaining its scalability and precision is another subject for possible future work.
some of the covert connections that we identified statically might never be triggered dynamically.
a large percentage of these connections originate in third party libraries that are included in the application but only partially used.
as such analyzing them is still beneficial as this code might be used in other applications.
vi.
r elated work work related to this paper falls into three categories user centric analysis for identifying spurious behaviors huang et al.
propose a technique asdroid for identifying contradictions between a user interaction function and the behavior that it performs.
this technique associates intents with certain sensitive apis such as http access orsms send operations and tracks the propagation of these intents through the application call graph thus establishing correspondence between apis and the ui elements they affect.
it then uses the established correspondence to compare intents with the text related to the ui elements.
mismatches are treated as potentially stealthy behaviors.
in our work we do not assume that all operations are triggered by the ui and do not rely on textual descriptions of ui elements.
ko and zhang propose a system feedlack for identifying usability problems in web applications.
the system looks for control flow paths that originate from user input but lack ui affecting code.
our work is similar as it relies on the same underlying principle of user feedback necessity and also searches for code affecting the ui.
yet our goal is different we look for any hidden behavior rather than missing feedback loops for user triggered operations.
also our analysis is tailored for mobile rather than web applications and unlike feedlack focuses not only on success paths but takes failure paths into account as well.
chabada compares natural language descriptions of applications clusters them by description topics and then identifies outliers by observing api usage within each cluster.
essentially this system identifies applications whose behavior would be unexpected given their description.
instead our approach focuses on identifying unexpected behaviors given the actual user experience not just the description of the application.
elish et al.
propose an approach for identifying malware by tracking dependencies between the definition and the use of user generated data.
they deem sensitive function calls that are not triggered by a user gesture as malicious.
however in our experience the absence of a data dependency between a user gesture and a sensitive call is not always indicative for suspicious behavior applications such as twitter and walmart can initiate http calls to show the most up todate information to their user without any explicit user request.
moreover malicious behaviors can be performed as a sideeffect of any user triggered operation.
we thus take an inverse approach focusing on identifying operations that do not affect the user experience.
information propagation in mobile applications the most prominent technique for dynamic information propagation tracking in android is taintdroid which detects flows of information from a selected set of sensitive sources to a set of sensitive sinks.
several static information flow analysis techniques for tracking propagation of information from sensitive sources to sinks have also been recently developed .
our work is orthogonal and complimentary to all the above while they focus on providing precise information flow tracking capabilities and detecting cases when sensitive information flows outside of the application and or mobile device our focus is on distinguishing between overt and covert flows.
the authors of appfence build up on taintdroid and explore approaches for either obfuscating or completely blocking the identified cases of sensitive information release.
their study shows that blocking all such cases renders more than of the applications either less functional or completely dysfunctional blocking cases when information flowsto advertisement and analytics services hurts of the applications and blocking the communication with the advertisement and analytics services altogether more than of the applications.
our work has a complementary nature as we rather attempt to identify cases when communication can be disabled without affecting the application functionality.
our approach for assessing the user observable effect of that operation is similar to the one they used.
both mudflow and appcontext build up on the flowdroid static information flow analysis system and propose approaches for detecting malicious applications by learning normal application behavior patterns and then identifying outliers.
the first work considers flows of information between sensitive sources and sinks while the second contexts i.e.
the events and conditions that cause the securitysensitive behaviors to occur.
our work has a complementary nature as we focus on identifying covert rather than malicious behaviors aiming to preserve the overall user experience.
shen et al.
contribute flowpermissions an approach that extends the android permission model with a mechanism for allowing the users to examine and grant permissions per an information flow within an application e.g.
a permission to read the phone number and send it over the network or to another application already installed on the device.
while our approaches have a similar ultimate goal to provide visibility over the holistic behavior of the applications installed on a user s phone our techniques are entirely orthogonal.
exception analysis for java a rich body of static analysis techniques has been developed to analyze and account for exceptional control and data flow .
most of these techniques define a variant of a reverse data flow analysis and use a program heap abstraction e.g.
points to analysis or class hierarchy analysis to resolve