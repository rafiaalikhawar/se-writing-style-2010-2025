bug synthesis challenging bug finding tools with deep faults subhajit roy computer sc.
and engg.
iit kanpur india subhajit cse.iitk.ac.inawanish pandey computer sc.
and engg.
iit kanpur india awpandey cse.iitk.ac.inbrendan dolan gavitt computer sc.
and engg.
nyu tandon usa brendandg nyu.eduyu hu computer sc.
and engg.
nyu tandon usa yh570 nyu.edu abstract in spite of decades of research in bug detection tools there is a surprising dearth of ground truth corpora that can be used to evaluate the efficacy of such tools.
recently systems such as lava and evilcoder have been proposed to automatically inject bugs into software to quickly generate large bug corpora but the bugs created so far differ from naturally occurring bugs in a number of ways.
in this work we propose a new automated bug injection system apocalypse that uses formal techniques symbolic execution constraint based program synthesis and model counting to automatically inject fair can potentially be discovered by current bug detection tools deep requiring a long sequence of dependencies to be satisfied to fire uncorrelated each bug behaving independent of others reproducible a trigger input being available and rare can be triggered by only a few program inputs bugs in large software code bases.
in our evaluation we inject bugs into thirty coreutils programs as well as the tcas test suite.
we find that bugs synthesized by apocalypse are highly realistic under a variety of metrics that they do not favor a particular bug finding strategy unlike bugs produced by lava and that they are more difficult to find than manually injected bugs requiring up around more tests to discover with a state of the art symbolic execution tool.
ccs concepts software and its engineering software testing and debugging formal software verification keywords bug injection program synthesis symbolic execution constraintbased synthesis acm reference format subhajit roy awanish pandey brendan dolan gavitt and yu hu.
.
bug synthesis challenging bug finding tools with deep faults.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
introduction decades of research has gone into eliminating bugs in software through automated bug finding tools such as static analyzers runtime sanitizers symbolic execution tools and fuzzers.
despite this ongoing effort there is a surprising dearth of ground truth corpora that allows us to evaluate the efficacy of such tools most existing corpora are small do not come with triggering inputs or feature bugs that are often unrealistic.
moreover the value of any individual dataset drops over time as tools adapt to it.
as a result in many cases we are forced to judge bug finding tools on how many previously unknown bugs they find which leaves us in the dark about how many they missed.
the lack of ground truth datasets also means that it is difficult to perform large scale studies of bug discovery.
for example we cannot run bug finding tools on corpora of millions of bugs and then attempt to draw conclusions about their relative strengths and weaknesses or statistically correlate features of bugs and programs with their difficulty of discovery.
in recent work two new systems lava and evilcoder have sought to address the need for ground truth corpora through automated vulnerability addition .
briefly these techniques take existing programs and seed them with vulnerabilities either by adding new vulnerable code or by identifying and removing safety checks to make existing code vulnerable.
these systems are an important step forward.
we consider that injected bugs should have the following properties fair an injected bug is fairwhen it is possible to unearth it by practical bug detection techniques.
for example a bug guarded by a famous mathematical theorem say fermat s last theorem is not fair as it requires the proof of a difficult mathematical theorem to detect the bug common bugs in programs do not resemble this.
deep an injected bug is deep if it requires a long sequence of data and control flow conditions to be met for it to trigger.
a bug guarded by a single branch condition is for the same reason not a challenging bug.
uncorrelated multiple injected bugs must be uncorrelated that is finding one of the bugs by a tool should not increase or decrease the chances of catching the other injected bugs.
reproducible an injected bug must come with a triggering input that proves the existence of the bug.
rare the bug should be triggered on a very small fraction of all possible program inputs.
considering these properties we find that existing bug injection techniques can be improved in several ways.
evilcoder for example cannot produce triggering inputs and hence fails to be reproducible related techniques such as mutation testing also fail to satisfy esec fse november lake buena vista fl usa roy pandey dolan gavitt hu this requirement .
and we find that bugs injected by lava although rare uncorrelated and reproducible fail to be fair and deep the triggers used a comparison against a bit magic constant are unusually difficult for techniques such as random testing to find and although the bugs manifest deep within programs the injected guard is a single branch that can be systematically targeted .
in this work we introduce a new technique for bug injection based on symbolic execution program synthesis and uniform sampling.
we build our ideas into a tool apocalypse and use it to introduce bugs in thirty coreutils programs.
apocalypse uses constraint based program synthesis to embed a transition system that we refer to as the error transition system ets on a judiciously chosen program path.
when the program is executed the ets is advanced at certain locations along this execution path leading to a crash if the final state is reached.
the state transitions on the ets are guarded by carefully synthesized predicates that ensure that only a few executions can successfully reach the final state and therefore trigger the bug.
we do so by enabling the synthesis engine to perform a multi variate hill climbing on the space of predicates at the transition locations searching for predicates that prevent most executions from reaching the bug location.
we estimate the set of inputs that a predicate blocks from reaching the error location by model counting approximated by uniform sampling .
model counting and uniform sampling are not mature technologies yet but are quickly making progress with some significant contributions in recent years.
we use apocalypse to inject multiple bugs in thirty coreutils programs and then attempt to detect these bugs using state of theart symbolic execution klee and greybox fuzzing afl tools.
many of the injected bugs were discovered by the above tools showing that the injected bugs were fair klee and afl were able to discover and of the bugs respectively at the same time many bugs were elusive showing that these bugs can act as subjects for further research of the bugs could not be discovered by either of the tools.
similar to real bugs different bugs showed affinity to different tools out of the bugs discovered of the bugs could be discovered only by klee while of the bugs could be found only by afl.
bugs synthesized by apocalypse needed about more tests to be discovered than the manually seeded bugs on our benchmarks .
we also compared our tool with lava and found that the bugs injected by lava tend to be biased to one of the bug finding tools about of the bugs injected by lava were discovered by klee while only about of these bugs were discovered by afl bugs injected by apocalypse on the other hand responded almost uniformly to both klee and afl showing the bug corpora produced by apocalypse do not favor a particular bug finding strategy.
as most bug finding tools do not target any attributes of realworld bugs but are driven solely by code coverage like klee and afl apocalypse synthesizes bugs that challenge the codecoverage heuristics of these tools stressing their competence at uncovering deep paths.
the contributions of this paper are as follows we propose a symbolic execution based strategy to automatically inject fair deep uncorrelated reproducible and rare bugs in programs we propose a model counting based strategy to reduce the number of bug inducing inputs to make the injected bugs difficult to find we build our ideas into a tool apocalypse and use it to inject bugs into coreutils programs we attempt to gauge the quality of the bugs synthesized by apocalypse using a symbolic execution engine klee and a greybox fuzzer afl .
overview our bug injection system apocalypse begins with a concrete input and a program trace induced by that input.
this input which can be taken from the program s test suite or as in our current implementation discovered through symbolic execution serves as a path along which we add one or more bugs to the program.
one can envisage bug synthesis as a game between the injector who wishes to add hard to find bugs to the program and the bug finder who would like to find the bugs added by the injector the concrete input serving as a source of asymmetric advantage in favor of the injector armed with a concrete input the injector has knowledge of an entire program path and all dynamic values along that path whereas the bug finder must search for the same program path in the space of all program paths.
apocalypse embeds a state machine which we refer to as the error transition system ets within the subset of the program statememts described by the trace this ets is designed such that the execution of the program on a pre selected fault revealing input would incrementally advance this state machine towards an error state i.e.
the program point where the injected bug will manifest .
a transition in the state machine is triggered whenever the current values of pre existing program variables that are in scope at the current location meet certain conditions.
to create a bug satisfying the requirements described in these conditions must be simple cause minimum perturbation to the dataflow and control flow of the existing program non trivial are not always true or always false and useful satisfied by a relatively small number of inputs .
apocalypse achieves these goals by using program synthesis to create candidate predicates from variables that are in scope at different points transition points along the trace.
not all points in the trace are equally promising as transition points we scan the trace looking for program points that are deep in the program call graph guarded by many branch conditions and have many variables in scope.
to ensure that the synthesized constraints that trigger each transition meet our requirements we use model counting to estimate the number of solutions to the conjunction of ets constraints so far and iteratively improve the constraint set by reducing the number of possible solutions.
the state machine is tracked using the global program variables.
we encode the state machine to match the lexical charateristics of the subject program for example if the program primarily manipulates integer values we use entities of the integer type integer variables elements of integer arrays integer fields in structures etc.
to track the state this is the encoding supported by our current prototype .
but we could also track the state using string matching or the position of some node in an aggregate data structure such as a list or a tree depending on what data structures and operations 225bug synthesis esec fse november lake buena vista fl usa 1vo id alim 3othcap c l i m b a l t v a l l6 i f ownrate o t h e r a l t s t a t e s t a t e i n t i n h i b i t b i a s e d c l i m b i n t up down up upsep a l t v a l down upsep o t h e r t r a c k e d a l t l16 i f othcap c l i m b s t a t e s t a t e r e t u r n c l i m b ?
up down vo id main i n p u t cursep ownalt ownrate o t h e r a l t a l t v a l upsep downsep othcap c l i m b l0 s t a t e u p p r e f i n h i b i t b i a s e d c l i m b downsep upcross ownalt o t h e r a l t ownrate ownrate cursep alim i f u p p r e f r e s u l t a l t v a l l19 i f c l i m b r e s u l t s t a t e s t a t e l21 i f o t h a l t upcros s t a t e s t a t e upcross ownalt o t h e r a l t l30 i f s t a t e a s s e r t listing program with synthesized bug the statements commented in green are statements inserted by apocalypse as per the ets in figure figure ets for the program in listing present in the subject program.
we give some concrete examples of possible state machine encodings in .
.
finally we create a buggy version of the program by adding at each transition point a snippet of code that checks one of our ets transition predicates and then accordingly advances the state machine.
when the state machine reaches its accepting state we trigger a pre defined buggy behavior.
in our current implementation we force an assertion failure simply by adding an assert false however other buggy behaviours like out of bounds memory accesses double free memory leaks dereferencing of freed pointers floating point exceptions can also be added depending on the class of the bug detector employed.
listing shows a program with an injected bug the statements synthesized by apocalypse are shown commented in green the program is instrumented with the ets shown in figure .algorithm apocalypse procedure main p identifytrace p l identifytransitionpoints sym pc symbolicexec l synthesizeets sym pc p instrumentets p returnp end procedure algorithm we define a program trace or simply a trace as a sequence of dynamic instructions.
we assume each trace to have a triggering input ip that causes the program to execute the given trace and a symbolic path constraint sym pc that encodes the conditions on the inputs that would follow the given trace.
given a map v7 e from program variables vi vto symbolic expressions s e we use the notation to denote the symbolic constraint formed by replacing each vi vby the respective symbolic expression from the map .
.
error transition system apocalypse injects bugs in programs by interweaving an error transition system along a path in the program.
the ets is a tuple l p l0 lbu where l the set of states corresponds to program locations that drive a transition on the ets p is a set of all predicates that can be constructed using the program variables array elements and structure fields in the current scope l p lis the transition function that dictates the transition on the ets given a predicates p p at a location li l l0 lis the initial state of the ets the ets is set to this state at the entry point of the program lbu lis the program location that is instrumented by the buggy action say simulating a program crash .
figure shows the ets for the program in listing the labels l6 l16etc.
marked in red show the transition locations where the ets makes its moves the program entry point l0 sets the ets to the initial state l16 .
the transition on location l16is guarded by the predicate othcap climb if this predicate holds the ets transitions to state l6.
finally if the execution can drive the ets to the final state l30 an error is raised say by simulating a crash or violating an assertion .
.
identify a program trace the algorithm driving apocalypse is shown in algorithm .
given a programp the algorithm starts off by using identifytrace p to identifying a trace on which an ets will be embedded.
identifytrace p uses symbolic exploration to collect multiple possible interprocedural paths in the program and selects a path based on the following parameters complexity of the path we prefer program paths that contain a large number of dynamic instructions pass through 226esec fse november lake buena vista fl usa roy pandey dolan gavitt hu a large number of procedures and hit a large number of branching instructions.
as this path represents the secret information that the adversary bug detection tool will need to discover a complex path makes the injected bugs more elusive.
number of useful variables this refers to the quality and quantity of the variables including array elements and structure fields that are used by the participating instructions along this path.
the quality of a variable is dictated by distance of the instruction that defines the variable in theprogram dependence graph from the input statements.
in essence it captures the complexity of constructing a required value into this variable from the program inputs.
we select paths with abundant good quality variables as these variables are eventually used by the ets synthesizer to construct transition predicates.
.
identify transition points in the program next identifytransitionpoints attempts to find good program locations on the error trace to embed ets transitions.
a location is selected if it meets the following criteria abundant useful variables are available at that program location the program location is deep in the call graph making it hard for bug detection tools to reach this location the program location appears deep in the control dependence graph a location deep in the control dependence graph is guarded by multiple predicates making reachability challenging for bug detection tools.
the above metrics on identifying a trace and transition locations can be tuned to inject bugs of varying degrees of difficulty thereby allowing one to gauge the effectiveness of different bug detection techniques.
in this project we have attempted to inject bugs that are hard to find we plan to investigate on the above questions in future work.
.
collect symbolic constraints in the next phase we run a symbolic execution engine on trace to collect the following symbolic path condition sym pc the path condition sym pc for the trace contains a symbolic summarization of all possible input values that would drive a program execution along .
symbolic expression dictionary this dictionary l7 v7 e maps each identified transition location li lin the program to a dictionary of symbolic expressions efor each program variable v v. concrete value dictionary c this dictionary c l7 v7 maps each identified transition location li lin the program to a dictionary of concrete values observed for each program variable v valong the execution trace.
.
synthesize the error transition system ets in this phase we use constraint solving to synthesize an error transition system ets that can be embedded in the program.
the synthesis algorithm is shown in algorithm .
synthesis of the ets essentially involves identification of the transition predicates that guard the automata transitions.
the identified predicates should satisfy the following properties simple the predicate should be simple to compute so as to not change the control flow and dataflow behaviour of the existing program by much.
non trivial the predicates should be non trivial for example x x x x etc.
should not be produced.
useful the predicate should effectively reduce the number of inputs that could trigger the bug.
for all the transition locations li l letpred l predicate denote a dictionary of the predicates synthesized such that pred is the predicate at the ithlocation li .
this map is initialized to pred l.true .
we synthesize the predicates for the different locations in a round robin manner each predicate pred is synthesized subject to the current values of all other predicates.
the predicate for the kthtransition location denoted as v1opv2 k is synthesized using the following synthesis condition v1opv2 k 1 ... n sym pc y li l i kpred jck v1 opck v2 k j k v1 op k v2 k where jv1opv2k jv1k jv2kforop jv1k jv2kforop jv1k jv2kforop the above constraint synthesizes a guard v1opv2 for the kth transition location if there exists a feasible execution i.e.
feasible values of the input symbolic variables 1 .
.
.
n that meets the above condition.
let us explore each term in the synthesis condition the first term ensures that by satisfying sym pc the synthesized path preserves the seed execution path as the faultrevealing run and the respective input is secured as the triggering input the second term q li l i kpred ensures that this path satisfies the guard conditions synthesized at all other transition locations thereby creating an augmented path that is traversed by fewer inputs the next term jck v1 opck v2 k synthesizes a guard condition by searching for variables v1andv2 and an operatorop such that the concrete value of this predicate with the current values of v1 andv2 corresponding to the seed input is consistent with the seed execution path this ensures that 227bug synthesis esec fse november lake buena vista fl usa algorithm synthesis algorithm procedure synthesizeets sym pc c v for all li ldo pred true sols end for tries while tries max t ri es do tries tries for all lk ldo v1opv2 k q sols ifissat then p else continue end if sym pc q li l i kpred count old modelcount pred count new modelcount p ifcount new count oldthen pred p sols sols end for end while return pred end procedure the injected bug would continue to be triggered by the seed input with this freshly synthesized guard condition the final term j k v1 op k v2 k ensures that there exists a feasible execution along the false path of the synthesized guard this term is designed to ensure that the symbolic values of the variables v1andv2are capable of generating an execution along the false branch of the guard condition thereby preventing generation of trivial predicates that always evaluate to true .
now we lay out the complete synthesis algorithm in algorithm .
lines initialize the dictionaries pred that remembers the current selection of the transition predicates and sols that remembers the set of all solutions seen earlier .
then the procedure enters into an iterative refinement loop to inductively search for good guards for transition predicates for each transition location lk l apocalypse tries to find a feasible guard v1opv2 as per eqn synth .
to ensure monotonicity it searches for a solution line while ensuring that any new solution does not include a solution that we have seen earlier cached in sols .
if is satisfiable the predicate is extracted from the model associated with lines else we move to the next location.
thepred andsolsdictionaries are finally updated at lines as per the new solution found.
figure provides a simplified view on the operation of our synthesizer assuming trigger as the seed input the synthesis constraint attempts to search for a point p1and predicate denoted by the line that divides the input space into two partitions white region that would induce the bug and blue region that would not.
the existence of the point p1is important to prevent generation of trivial predicates that do not divide the input space say as lines that are tangents to the input space .
further in the next iteration figure input space pruning 1i n t approxmodelcount oldpred newpred sample i s a s e t o f i n p u t s c o n s t r u c t e d by uniform sampling on t h e path c o n d i t i o n while inp sample .
next i f o l d p r e d countold i f newpred countnew r e t u r n countnew countold listing approximate model counting we further shrink the bug inducing region by searching for another point p2from the bug inducing region such that the new predicate separates trigger from both p1andp2.
to estimate the usefulness of the synthesized predicates we perform a hill climing search over the multi variate predicate space corresponding to each location lines .
this search uses a model counter to estimate the number of feasible inputs corresponding to the newly synthesized predicate and the older predicate cached in pred we select a predicate that maximally shrinks the space of bug inducing inputs.
the search is designed similar to a gibbs sampler for multi variate problems wherein we make the decision about one variable conditioned on the current values of every other variable.
as invoking a model counter twice in each iteration is quite expensive in our implementation we approximate the relative usefulness of the predicates by performing uniform sampling on sym pcto create a sampled space of inputs tests that follow the same path as the seed input.
we then generate and execute a program on these tests to count the number of inputs satisfied by the competing guard predicates we show a sketch of our generated program in listing .
an important design decision was to ensure that our algorithm generates the guard predicates such that the seed input ends up as the trigger for the bug.
this is crucial as the symbolic execution engines often concretize parts of the execution state for instance return values from external library calls results of floating point operations effects of system calls etc.
.
the map then captures only an incomplete symbolic model potentially leading to path divergence .
let us explain the problem in listing assuming sqrt as an external function its output will concretized.
hence the path condition of an execution where both branches evaluate to true would be an incomplete a rather than a c .
if we desire inputs that would trigger the bug by hitting locations l0 l6 and l10 we would need to solve the respective path condition a for which a constraint solver can return a solution a z unaware of the branch constraint c .
this 228esec fse november lake buena vista fl usa roy pandey dolan gavitt hu 1l0 s t a t e 3make symbolic a z i f a c s q r t z 5i f c l6 i f c a s t a t e s t a t e 9l10 i f s t a t e a s s e r t listing problem of path divergence input fails to trigger the bug as the program diverges to a different path at the branch if c .
we handle this problem by maintaining the seed input which is consistent with all concretizations as the trigger for the bug.
for simplicity the above algorithm assumes that each program location is hit at most once.
in our implementation if a program location is hit multiple times say in a loop or a procedure we use only the first few bounded instances when the location is reached as possible transition points.
.
embed the synthesized ets in the program in the final phase apocalypse embeds the synthesized ets in the program by instrumenting the transition locations with guarded state transitions dictated by the synthesized ets .
listings and show two possible instrumentation schemes listing is a better scheme as it avoids creating path explosion and hence creates buggy programs that are closer to the input program in terms of the total number of paths.
different instrumentation scheme can be adopted to camouflage the ets transitions listing shows a possible camouflage for the ets transitions for string processing programs and listing for bit manipulating programs.
as our current prototype was meant to study the properties of our injected bugs for automated bug detection systems and not human subjects all our experiments were conducted on the instrumentation scheme shown in listing .
.
running example to begin with apocalypse needs to be provided with a seed input that drives the program through a path on which we are interested in inducing a fault a good seed path for bug injection can be discovered by symbolic execution see .
.
let us work our way through the program in listing assume that select the seed inputs as cursep ownalt ownrate otheralt altval upsep downsep otherrac climb .
the symbolic and concrete values selected for the inputs are shown in table .
to embed an error transition system ets along this path apocalypse also needs a set of good program locations to drive the ets transitions see .
.
our system identifies the lines marked as l16 l6 l19andl21as the transition locations.
armed with the seed inputs and the set of transition locations apocalypse runs symbolic execution along the seed path to collect the symbolic path condition sym pc and the symbolic and concrete expression maps andc see table .table symbolic and concrete inputs for the trace variable value variable value cursep 0 ownalt 3 ownrate 4 otheralt 5 altval 6 upsep 7 downsep 8 othcap 10 climb 11 table symbolic and concrete maps variable loc16 loc6 loc19 loc21 sym conc sym conc sym conc sym conc othcap 10 0 6 11 2 6 11 2 6 11 ownrate 4 174 0 4 1432 0 4 1432 0 4 climb 11 1 11 1 11 1 11 othalt 5 5 5 5 up 6 7 down 5 77882 uppref 6 7 5730 6 7 8 8 upcros 3 5 8150 3 5 result 6 1 6 apocalypse now synthesizes an ets as follows for the location l16 it finds a predicate othcap climb to move the transition system by a step.
it does so by building a synthesis constraint that ensures that the predicate is simple non trivial disallowing predicates like uppref downsep that are invariants and useful discussed next .
similarly it synthesizes predicates ownrate otheralt uppref upcros and othcap climb for locations l6 l19andl21.
next apocalypse makes more passes over these locations in a search for better predicates.
attempting another synthesis cycle over l19 and disallowing the previous solution it synthesizes a new predicate climb result .
now it checks the model count for sym pc 10 11 6 8 5 3 8 6 1 sym pc 11 6 10 11 0 4 5 5 3 5 and 2 sym pc 6 7 8 3 5 10 11 0 4 5 5 3 5 .
in this case it finds that the model count of 2is smaller than that of 1 and hence it goes about replacing the older predicate uppref upcros by the newer climb result predicate.
on the other hand if the count of 1was smaller it would have rejected it and persisted with the older predicate.
this hill climbing over the multi variate space of predicates at the different locations allows us to shrink the space of inputs that would trigger the bug.
table shows the set of all predicates produced by apocalypse with the ones finally selected marked in blue.
in our experiments this procedure increased the bug detection time of the injected bugs by about on afl .
the synthesized ets is shown in figure .
finally the generated ets is inserted into the existing code.
we show the statements injected by apocalypse as comments in green in listing these statements drive the program to a crash at l30.
229bug synthesis esec fse november lake buena vista fl usa i n t s t a t e vo id buggy 4i f p1 s t a t e s t a t e 6i f p2 s t a t e s t a t e 8i f p3 s t a t e s t a t e 10i f p4 s t a t e c r a s h listing ets encoding for integer programsi n t s t a t e vo id buggy 4s t a t e p1 !
s t a t e s t a t e p2 !
s t a t e 6s t a t e p3 !
s t a t e s t a t e p4 !
s t a t e i f s t a t e c r a s h listing ets smart encoding for integer programs1char s h e l l o world f o r bug 3vo id buggyfunction i f p1 !
cmp s h e l l o l s t r l e n s i f p2 !
cmp s l world l s t r l e n s i f p3 !
cmp s l f o r l s t r l e n s i f p4 !
cmp s l bug c r a s h listing ets encoding for string based programsi n t s t a t e x f f f f 2vo id buggy i f p1 s t a t e x f f f f s t a t e x f f 6i f p2 s t a t e x f f f f s t a t e x f f f f i f p3 s t a t e x f f f f c r a s h listing ets encoding for bit manipulating programs table synthesized predicates at ets locations loc predicates loc predicates l16 othcap climb l6 ownrate otheralt l19 climb result l21 othalt upcros uppref upcros climb othcap experiments apocalypse is based on multiple tools it uses clang for instrumentation for dynamic analysis for selecting good transition locations as well as for embedding the ets in the program .
we modified crest for running symbolic execution to collect the symbolic path conditions and the expression maps.
the ets synthesizer uses z3 for constraint solving.
we use a modifed version of boolector to create sat encodings of smt constraints and quicksampler for uniform sampling on the boolean path conditions.
for the purpose of our experiments we insert assert false statements at our bug injection points.
our experiments were conducted on a ghz intel xeon r machine with cores and gb ram.
to understand the quality of the bugs injected by apocalypse we attempted to uncover the injected bugs using two popular bug finding techniques symbolic execution we use the state of the art symbolic execution engine klee to unearth the bugs.
klee is run with the default search strategy within a timeout of hr.
greybox fuzzing coverage guided fuzzing tools perform executions on randomly mutated inputs guided by coverage metrics.
we use the popular greybox fuzzer afl for our experiments running it with default settings and a timeout of hr.
our experiments attempt to answer the following research questions rq1 are our automatically synthesized bugs fair?
rq2 is there any correlation between multiple injected bugs?
rq3 are the bugs injected by apocalypse reproducible?
rq4 are our bugs deeper and rarer than manually seeded bugs?
rq5 what is the effect of sampling on the difficulty of an injected bug?
rq6 how does apocalypse compare with state of the art bug injection tools?
.
rq1 fairness of our synthesized bugs we demonstrate that our bugs are fair by employing two state ofthe art bug detection tools klee based on symbolic execution and afl employing greybox fuzzing for discovering the bugs synthesized by apocalypse in thirty gnu coreutils programs .
we use apocalypse to inject four bugs in each program we then challenge klee and afl discover the bugs running them for one hour each .
the results are shown in figure .
the first bar for each benchmark shows the time spent by afl to hit each of the bugs normalized to the time taken to reach the last bug or timeout when no bug is found .
the second bar for each benchmark shows the number of test cases that must be generated by klee to find the first test that reveals a bug normalized to the number of tests required to reach the last bug that it could find.
for example for the experiments on klee second bars in the program cat klee is able to find only one bug so the bar for the first bug reaches all the way to one .
in cases where all bugs are found for example in df the first bug is found at the second bug at and the third at of the total number of testcases needed to find the last bug.
cases where we were unable to find any bug like test are shown as timeout to .
for the experiments involving afl first bars because afl generates tests only for failing executions we show the amount of time spent to reach a bug instead of the number of tests .
the first bar of each cluster shows how much relative time afl has invested in finding each bug compared to the last bug.
if afl is not able to find any bug the whole bar is set to timeout to .
for example in the case of cat the first bug is found at the second bug is found at and the third is found at of the time at which the final bug was found.
overall klee could find of the bugs while afl found .
of the bugs of the bugs were found only by one of the two tools while of the bugs could not be found by either.
this illustrates common traits exhibited by real bugs discoverability state of the art bug detection tools have been successful in dicovering many bugs in large programs.
even for our injected bugs all in all of the bugs are discovered by at least one of the tools.
elusiveness certain bugs are still elusive showing that these injected bugs resembling real bugs can now be employed to stress tools for new bug detection techniques about of the bugs could not be discovered by either of the tools.
230esec fse november lake buena vista fl usa roy pandey dolan gavitt hu affinity to tools certain bugs are more likely to be found by one type of technique than by another of the bugs were only discovered by afl while of the bugs were only discovered by klee.
variance in tool effort some bugs require more effort to be discovered than others on the discovered bugs afl shows a standard deviation of seconds on a total running time of hour for each program .
.
rq2 correlation of bugs injected by apocalypse figure shows that the number of tests using klee and the time taken by afl to discover the different bugs is almost uniformly distributed also in many cases even after discovering a few bugs the tools fail to unearth the rest of the bugs.
this shows that there exists almost no correlation among the different bugs injected by apocalypse .
together klee and afl are able to catch of all bugs there are programs out of where none of the tools is able to catch any bug.
.
rq3 reproducibility because apocalypse generates triggering inputs for each bug it creates reproducibility is satisfied by design.
nevertheless we checked that the generated inputs really did trigger each bug and found that we could reproduce all the injected bugs.
.
rq4 comparison with manually seeded bug to compare with manually seeded bugs we used the tcas benchmark.
tcas contains buggy versions each version containing exactly one manually seeded bug.
as the seeded bugs produce an incorrect output but not a crash or assertion failure we use klee to generate a set of tests any test that that produces an incorrect output or reaches our injected bug location is designated as a failing test.
we use apocalypse to inject two additional bugs into each tcas version.
klee was able to discover all the injected bugs as well as the manually seeded bugs in all versions except versions and .
figure shows the number of test cases klee had to generate before hitting the test case that triggers the bug ploted on the logscale for the average of three runs of klee .
this experiment shows the elusiveness of our bugs with respect to the manually seeded ones on an average the bugs injected by apocalypse require more tests than the manually seeded bugs.
table shows the rarity of our bugs this table shows the number of generated test cases on which a bug induced a failure.
f s and msb denote the number of failing testcases on our 1st f and 2nd s injected bug and manually seeded bug respectively.
on an average the bugs injected by apocalypse induce failures on fewer tests over the manually seeded bugs.
.
rq5 searching for stronger transition predicates figure shows how our hill climbing search for guard conditions improves the rarity of the bugs on the different versions of thetable number of testcases generated by klee that reveal our bugs f s and manually seeded bug msb .
v f s msb v f s msb v f s msb tcas program.
we conducted the experiment by comparing the bugs generated when we always picked the first predicate found red line versus when the hill climbing searcher is switched on blue line .
the search for good predicates is effective as it increases the time needed to find the triggering inputs for the bugs by about on average.
.
rq6 comparison with lava we compare apocalypse with lava on nine coreutils programs shown in figure .
let us discuss the results on the two tools separately klee klee uses constraint solving to discover newer paths.
in lava as the bug location is essentially guarded by a magic number it is quite easy for klee to use the constraint solver to guess this magic number.
hence on most of the benchmarks klee is able to discover almost all bugs.
on an average klee discovers of the bugs.
afl afl uses random mutations to discover test cases guided by coverage information .
hence afl finds it hard to guess the magic numbers by random mutations thereby finding many fewer bugs.
on an average afl discovers of the bugs.
as can be seen the bugs injected by lava in general show affinity towards a certain tool klee .
over a set of injected bugs each bug may show affinity towards a certain tool but overall all bugs injected by a tool should be unbiased.
for the bugs injected by apocalypse though a certain bug may be discovered by a certain tool more easily than the other overall both tools are almost equally effective of bugs discovered by klee of bugs discovered by afl on these nine programs at discovering the bugs injected by our tool.
this shows that the bugs synthesized by apocalypse are more natural than those injected by lava as they do not exhibit artificial attributes that can be exploited by bug finding tools.
related work the work most directly related to our current work is lava and evilcoder .
as we discuss the relationship of our work to these systems in detail elsewhere in the paper we omit a complete discussion here noting only that while our system shares the goals of this prior work we improve upon the state of the art by 231bug synthesis esec fse november lake buena vista fl usa .
.
.
.
catcutdfduechoexpandexprfmtheadidkilllnlsnlpathchkpinkyprprintfseqstatsumtailtouchptxunexpanduniqwhotestwcchmodtime program1st 2nd 3rd 4th to 22aflklee .
figure normalised time afl or testcases klee needed to find the respective bug the first bar is for afl and second for klee.
the venn diagram shows the distribution of the bugs found by klee and afl.
testcase programwith hill climbing without hill climbing figure effect of the hill climbing search on the time to find the bug using afl in tcas .
.
.
.
testcase program1stbug 2ndbug actualbug figure number of tests generated before hitting a bug plotted on log scale for the average of three runs of klee cat cut uniq sum unexpand head tail expand nllava klee apocalypse kleelava afl apocalypse aflfigure percentage of bugs found by klee and afl among bugs injected by apocalypse and lava generating deep bugs that do not favor a particular bug finding approach.
bug injection systems are intended to automate the creation of bug corpora however it should be noted that there are a number of existing public corpora of buggy programs as well and studies have been performed to evaluate bug finders using these systems.
for example wilander and kamkar performed a pair of studies using synthetic bugs that evaluated the effectiveness of static and dynamic bug finding tools.
nist s samate group hosts a collection of buggy software data sets known as the software assurance reference datasets sard .
and in darpa hosted an automated bug finding cyber grand challenge cgc this competition resulted in a collection of programs with known vulnerabilities and triggering inputs and has been used extensively since its creation for evaluating new bug finding techniques .
the cgc corpus is very high quality but it is expected that bug finding software will eventually improve to be able to find all known bugs in the programs.
and all of these corpora suffer from one or more of the following issues they contain few programs or each 232esec fse november lake buena vista fl usa roy pandey dolan gavitt hu n u m i n p u t f i l e s a r g c o p t i n d .
.
.
c a s e r i n p u t r e f e r e n c e .
.
.
state12 num input files input reference state12 a ptx1c a s e a need deadprocs .
.
.
3trimmed name extract trimmed name u t e m p b u f f e r .
.
.
5state12 trimmed name need deadprocs !
state12 b who 1c a s e d o u t p u t u n i q u e .
.
.
t h i s f i e l d f i n d f i e l d t h i s l i n e .
.
.
state12 thisfield output unique !
state12 c uniqi f o p t a r g f r o m s t a r t .
.
.
i f !
x s t r t o d optarg s c s t r t o d s s l e e p i n t e r v a l s .
.
.
6state12 sleep interval from start !
state12 d tail c a s e f i n t e r a c t i v e .
.
.
ok s y m b o l i c l i n k ?
symlink source d e s t l i n k source d e s t .
.
.
6state12 remove existing files ok !
state12 e uniqi f o p t a r g f r o m s t a r t .
.
.
i f !
x s t r t o d optarg s c s t r t o d s s l e e p i n t e r v a l s .
.
.
6state12 sleep interval from start !
state12 f tail figure some of the predicates synthesized by apocalypse for bugs in injected on some coreutils programs individual program is small the bugs may be shallow or unrealistic or the bugs may not come with triggering inputs.
another technique for creating bugs is found in the field of mutation testing in which random mutation operators are applied to a program.
the resulting presumably incorrect program is then run against its test suite in an attempt to judge the robustness of the test suite.
in some sense bug injection is an extension of mutation testing in that it automatically creates buggy versions of a program.
however the effects of the mutants created by mutation testing are difficult to predict and do not come with triggering test cases in other words they fail to be reproducible under the definition given in .
while mutation testing is good for evaluating the quality of a test suite it is less clear how to apply it to the task of evaluating effectiveness of a bug finding system such as klee .
finally our bug synthesis strategy is based on the formal techniques like program synthesis andmodel counting .
techniques for automatically generating programs have a long history dating back perhaps as early as if one includes church s discussion of the problem of circuit synthesis but have recently seen a flurry of activity due to the emergence of fast sat and smt solvers combined with the work of solar lezama which showed that program synthesis could be cast in terms of satisfiability.
since then program synthesis has been applied to a wide variety of problems including automating string processing in spreadsheets heapmanipulations and automated program repair .
model counting and uniform sampling have elicited huge interest due to their applications in bayesian inference and probabilistic programming.
model counting has been successfully employed for probabilistic symbolic execution that assigns probabilities to program paths to aid understanding.
we use model counting in a similar context to synthesize a low probability path for the buggy executions.
discussion figure shows some the predicates synthesized for a few of the bugs injected by apocalypse in the coreutils programs.
one can see that the predicates are non trivial spanning array accesses pointer deferences and access to fields of aggregate structures.
the asymmetric advantage enjoyed by apocalypse as explained in allows it to expend all its reasoning ability on one trace to create challenging bugs while the bug finder is required to reason on the whole program.
hence even with similar compute resources and reasoning ability as the bug finding tools apocalypse is capable of constructing challenging bugs for even state of the art bug finding tools.
we believe that large corpus of injected bugs from apocalypse will help us better understand the pecularities and relative merits of different bug detection tools.
there exist threats to validity to our experimental results in particular from the choice of the subject programs and the seed inputs.
we were careful to select a large number of programs and inject multiple bugs nevertheless more extensive experiments can be performed.