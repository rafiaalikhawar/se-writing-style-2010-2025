marble mining for boilerplate code to identify api usability problems daye nam amber horvath andrew macvean brad myers and bogdan v asilescu carnegie mellon university usa dayen ahorvath bam cs.cmu.edu vasilescu cmu.edu google inc. usa amacvean google.com abstract designing usable apis is critical to developers productivity and software quality but is quite difficult.
one of the challenges is that anticipating api usability barriers and realworld usage is difficult due to a lack of automated approaches to mine usability data at scale.
in this paper we focus on one particular grievance that developers repeatedly express in online discussions about apis boilerplate code.
we investigate what properties make code count as boilerplate the reasons for boilerplate and how programmers can reduce the need for it.
we then present marble a novel approach to automatically mine boilerplate code candidates from api client code repositories.
marble adapts existing techniques including an api usage mining algorithm an ast comparison algorithm and a graph partitioning algorithm.
we evaluate marble with java apis and show that our approach successfully identifies both alreadyknown and new api related boilerplate code instances.
i. i ntroduction almost all modern software programs adopt and use a large number of apis.
therefore dimensions of api usability including learnability effectiveness of use and errorproneness are increasingly becoming significant concerns for api designers .
to investigate api usability issues and to improve apis researchers have used several methods such as lab studies and api design reviews .
the understanding gained from such studies along with the insights from experienced api designers have led to the development of guidelines for api designs and heuristics for evaluating apis .
however despite these efforts many apis are still difficult to use .
in particular api designers have reported that anticipating how developers will use their api in the wild is difficult and leads to usability challenges when developers use the api in unexpected ways .
api designers have also reported significant trouble discovering what are the usability barriers at scale .
although online sources such as stack overflow and g ithubmay contain ample amounts of real client code or insights into how programmers perceive apis designers report that there are not so many automated approaches to mine usability data from these repositories at scale nor to gauge the severity of the usability issues .
in contrast mining software repositories techniques have long been used to identify api usage patterns .
for example existing api usage pattern mining tools such as examplecheck and pam automatically identify api methods that are frequently called together in client code.
import org.w3c.dom.
import java.io.
import javax.xml.transform.
import javax.xml.transform.dom.
import javax.xml.transform.stream.
dom code to write an xml document to a specified output stream.
private static final void writedoc document doc outputstream out throws arrowhookleft ioexception try transforme rt t ransformerfactory.newinstance .newtransformer t.setoutputproperty outputkeys.doctype system doc.getdoctype .
arrowhookleft getsystemid t.transform new domsource doc new streamresult out catch transformerexception e throw new assertionerror e can t happen!
listing .
writing an xml document to a specified output stream in java may involve significant boilerplate code for initialization and error handling .
primarily these tools have been designed to help users learn a new api by identifying idiomatic usage examples as well as to help api designers gain insights into how their apis are being used.
in this paper we argue that api usage pattern mining tools may also help reveal certain api usability issues.
specifically we focus on one particular grievance that developers express repeatedly in online discussions about apis and programming languages more generally boilerplate code .
wikipedia refers to boilerplate as sections of code that have to be included in many places with little or no alteration and code the programmer must write a lot of to do minimal jobs.
one stack overflow user calls boilerplate any seemingly repetitive code that shows up again and again in order to get some result that seems like it ought to be much simpler most users agree that boilerplate is tiresome to write and error prone .
listing shows a typical example whenever one wants to write an xml document to a specified output stream in java which is a common usage scenario this requires significant boilerplate code.
one could imagine that this use case could be accomplished natively by calling a single api method such as writexml .
from an api designer s perspective the existence of boilerplate code may serve as an indicator of poor api usability .
this is because the need for boilerplate code often indicates that the api does not directly provide the methods that programmers need so the extra code is needed to do even 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
common tasks.
another cause may be that the api designers assume users will need the flexibility to put things together in multiple ways but most users do not so everyone uses the same collection of methods in the same way .
users may also use boilerplate code even though there are already implemented api methods that can succinctly perform the task which indicates discoverability problems .
however despite general consensus on the undesirability of having to write boilerplate code as well as api design guidelines explicitly mentioning boilerplate as an anti pattern the concept remains largely undefined and understudied.
we start by reviewing boilerplate code examples and definitions from multiple sources section iii .
through qualitative analysis we confirm that boilerplate involves sections of code that have to be written repetitively to accomplish common and otherwise simple tasks that users largely do not want to think about.
moreover we find that the main reasons for boilerplate code are underlying language and api limitations.
we also find that developers and api contributors make efforts to reduce the amount of boilerplate code by introducing new helper functions and abstractions.
next we present marble m ining a pi r epositories for boilerplate l essening e ffort an automated technique for identifying instances of boilerplate api client code.
since a key property of boilerplate is that it is repetitive we designed marble on top of an existing api usage pattern mining approach specifically pam which is automated and can be run at scale.
however not all idiomatic api usage patterns that an approach like pam extracts of which there are typically many should be considered boilerplate.
therefore we developed novel filters using ast comparison and graph partitioning section iv to identify among the frequent api usage patterns those which are most likely to involve boilerplate.
by reducing the number of false positives api designers could then focus manual review on the most likely candidates.
the source code of marble is available online .
we evaluated marble on java apis for which we mined around client code files from g ithub opensource projects with client code files per library on average after random sampling.
our results section v show that not only does marble return a sufficiently short list of boilerplate candidates for manual review to be feasible but also that more than half of these candidates are considered boilerplate by two experienced java programmers the first and third authors of this paper where the third author is an api designer at a large software company.
to further the discussion about what boilerplate is and how it impacts apis we discuss some of the boilerplate candidates and suggest potential api design improvements.
the full list of boilerplate candidates mined is available online .
note that we are notclaiming that all boilerplate code is bad or that boilerplate code should always be eliminated.
in fact some of the patterns we identified as boilerplate are important to leave as is to achieve other code quality requirements such as increased readability or separation of concerns.
however as has been proposed elsewhere we argue that these kinds of api design decisions are best made with full knowledge of the tradeoffs.
we argue that marble provides data which may be used in practice by api designers as a basis for such discussions.
we also recognize that our method like any other data mining approach is only applicable after an api has sufficient client code using it and is therefore complementary to lab studies and api design reviews.
in summary we contribute i the boilerplate api code mining problem ii properties which can be used to identify boilerplate code iii an automatic boilerplate code mining algorithm iv an empirical evaluation on java libraries.
ii.
r ela ted work to our knowledge our work is the first to automatically mine potential boilerplate code instances from software repositories.
we contribute to the literature on api usability which serves as the motivation for our work and api usage pattern mining.
our work is also related to code clone detection which can be helpful for identifying some api usability problems but has limitations for boilerplate code mining.
a. api usability studies previous research and industrial work have sought to aid api designers in creating more intuitive learnable and usable apis see e.g.
for surveys .
researchers have investigated ways of evaluating api usability in lab based studies including diagramming the concepts used in the api and combining interviewing and observational studies during a programming task .
while these methods have been successful in the lab it remains unclear how they might scale for evaluating larger apis.
peer reviews are also often used to evaluate apis .
for example macvean et al.
developed a peer review process at google called apiness that assigns two reviewers to asynchronously provide feedback on the api s design.
while this approach has proven to be effective at google it requires a level of expertise for both the api reviewer and api designer which may not be available.
moreover such approaches are mainly designed to be used before the api is released therefore they are not ideal to identify potential usability issues of the api in client code at scale after an api has been released.
there are also many publications that discuss general api design processes and guidelines but these still require expertise in api design and the methods introduced in those articles may be hard to operationalize .
heuristics are also used to evaluate apis after their creation sometimes automatically .
b. mining api usage patterns significant previous research has addressed mining of api usage patterns which has proven to be useful for detecting both correct and incorrect api uses .
api misuse detectors automatically mine incorrect uses of an api which deviate from normal patterns.
however these authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithms focus on detecting potential anomalies or bugs in the programs mainly mistakes made by developers rather than focusing on the design of the api itself.
there are also algorithms for automatically mining api usage patterns which identify api methods that are frequently called together .
for example pam uses a probabilistic model and an expectation maximization algorithm to mine sequences of api calls that are not only frequent but also occur more often together in a sequence than would be expected by chance.
examplecheck uses the closed frequent sequence mining algorithm bide combined with an smt solver to mine api usage patterns as well as guard conditions that protect an api call.
however while these algorithms can help users learn apis more effectively they are not very useful for api designers in that it is hard to filter out which instances are directly related to api usability issues given the long list of api usage patterns they return.
particularly noteworthy is google s stopmotion tool which focuses on identifying api usability issues in a scalable fashion by analyzing the developers work history.
stopmotion analyzes editor logs from developers focusing specifically on instances where code edits relate to api method usage.
although this approach is able to identify instances of usability issues from client code it currently only considers changes made for a single method call.
it is therefore not ideal for capturing usability issues involving multiple api calls in a block of code or identifying code which surrounds api method calls namely boilerplate code.
c. code clone detectors code clones have long been regarded as harmful to a system s design so researchers have studied them extensively including their causes and detection algorithms .
kapser and godfrey found that some code clones are caused by limitations of the programming language .
kim et al.
further found that programming language limitations partially explain why many long lived clones are not easily refactored.
this suggests that api design issues could be identifiable in client code among the code clones.
there are also approaches to detect code clones from large code bases that could potentially be used to identify clones indicative of api design issues given a large repository of client code.
deckard is a tree based code clone detection algorithm that measures the similarity of subtrees in syntactic representations.
deckard clusters characteristic vectors which are transformed from parse trees of the source code to detect code clones based on this clustering.
more recently white et al.
devised a learning based code clone detection technique that uses deep learning by training an autoencoder to encode the lexical level information and syntactic level information into vector representations and match them to detect the code clones.
sourcerercc on the other hand uses a bag of tokens technique to detect type clones.
it exploits an optimized inverted index and filtering heuristics to quickly query the clone candidates with less computation for more scalable clone detection within large codebases.
both ofthese detectors successfully find code clones and scale well.
however these techniques are designed to detect all kinds of clones not just api related or boilerplate related ones.
therefore false positive rates for boilerplate candidates would likely be high and additional filtering would be needed to identify the clones indicative of api design issues.
we choose to base our boilerplate approach on automatic api usage pattern mining techniques rather than code clone detection tools since the former are specifically designed for apis which we expect would require less filtering of false positive boilerplate candidates.
iii.
s tudying boilerpla te code as far as we have been able to find studies of boilerplate code or studies that even mention boilerplate code are scarce exceptions include .
mostly we have found it to be i know it when i see it with the existing explanations being vague and abstract rather than deterministic.
at the same time although boilerplate code is regarded as something that programmers want to avoid and api design guidelines suggest that api designers should reduce the need for boilerplate code we still have not seen any studies of whether some boilerplate code is induced by apis and if so whether it is possible to reduce it at the api level.
thus to help understand the characteristics of boilerplate code and the impact of api design on the need for boilerplate in client code we first investigated three research questions rq what is a good definition and what are common properties of boilerplate code?
rq what are reasons for needing boilerplate code?
rq how do api users and api authors deal with boilerplate code?
a. resources we reviewed the literature surveyed our social media contacts and reviewed stack overflow questions and g ithub commits.
mainly we looked for boilerplate code examples but when available we also collected the rationale behind the boilerplate designation reasons for the boilerplate and how programmers dealt with boilerplate.
we looked for java boilerplate code examples involving at least one api call.
we chose java because the api usage pattern mining technique we build on section iv was tested for java.
in some communities e.g.
web developers boilerplate code is used as a synonym for template code but we exclude this context as we are looking for boilerplate related to api usability.
literature we searched for definitions or explanations of boilerplate code in google scholar blog posts online discussion boards e.g.
reddit and wikipedia.
when available we also collected boilerplate code examples.
survey we asked our twitter contacts to share boilerplate code examples and the reasons behind the boilerplate designation.
overall participants submitted to boilerplate examples each and all provided the reason why they thought each example qualifies as boilerplate.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
stack overflow the first author identified five popular java api tags android swing jdbc spring mvc jsp in stack overflow and manually collected questions asking about how to reduce boilerplate code using stack overflow search queries e.g.
boilerplate .
we checked the first page questions of the results for each java api tag and collected boilerplate code examples and the reasons why the questioner thought it was boilerplate.
github commits we identified and cloned the top most starred java repositories from g ithub using the march version of ghtorrent details in section v .
then we identified all commits including the keyword boilerplate in the commit message.
finally the first and second authors manually coded all the matching commits.
b.rq what is a good definition and what are common properties of boilerplate code?
we investigated the available definitions of boilerplate code from the literature and iteratively discussed the boilerplate examples among the research team which includes an experienced api designer in a large software company who is often involved in large software projects using apis distilling common properties.
we did not use g ithub commit data in this analysis because it does not explicitly express the characteristics of boilerplate and it does not indicate the exact location of boilerplate code in many of the code changes.
undesirable commonly boilerplate code is identified using subjective properties sometimes explicitly it s a subjective definition .
mostly such properties have negative connotations .
one source calls it uninteresting unchanging repetitive and or tedious .
another common but subjective property is that boilerplate code is needed even for simple functionality.
the highest voted answer from stack overflow defines it as it ought to be much simpler .
we summarize all of these properties as being undesirable.
high frequency most of the definitions and explanations require that boilerplate code occurs frequently in client code such as shows up again and again or code that has to be included in many places .
frequency is a particularly intuitive property given the negative connotation of boilerplate code indeed if it were rare its impact would likely be reduced.
the high frequency property also implies that boilerplate api code examples should be found among idiomatic api code examples as the latter are by definition frequent hence our choice to base our approach on an existing api usage pattern mining tool .
localized the statements constituting boilerplate code are usually closely located near each other rather than spread over multiple methods or files.
all examples from stack overflow and the survey and three examples from google scholar were parts of a single method.
the wikipedia example of getters and setters within a class is the only one not limited to a single method.
little structural variation the boilerplate code instances appear in similar form without significant variation .
many sources describe that it gets copied and pasted andis used with little or no alteration .
we also found that many explanations of boilerplate code describe the examples as i find myself writing the same ugly boilerplate code or a lot of code that must be duplicated .
in fact this corresponds to the definition of code clones especially templating clones .
however while code clones need not occur with high frequency to be considered clones boilerplate should occur frequently property .
c.rq what are reasons for needing boilerplate code?
method the first and second authors performed closed coding for all of the boilerplate related commits we collected from g ithub.
as one property of boilerplate code rq property corresponds to a subcategory of code clones we borrowed roy and cordy s reasons for cloning as our starting set of codes development strategy reuse approach programming approach maintenance benefits avoiding ensuring reflecting overcoming underlying limitations language limitations programmers limitations and cloning by accident protocols to interact with apis and libraries programmers working style .
as there were commits referring to different types of boilerplate e.g.
boilerplate license we also coded the commits with types of boilerplate boilerplate client i.e.
reduce the boilerplate code using the api comment i.e.
boilerplate in the comments such as license javadoc and non java.
each commit was assigned one type and one reason based on its commit message and code diffs.
the first and second authors started coding collaboratively and after agreements each separately coded half of the data.
in total we randomly sampled and coded commits and the two coders reached .
agreement jaccard index both for boilerplate types and for reasons on of the data.
results among commits of them were commits to reduce the use of boilerplate code.
we found that the predominant reason for needing boilerplate was overcoming underlying language limitations mentioned in commits .
examples of this include needing to initialize many getters setters and verbose error handling in java.
were induced in order to interact with apis for example tagged as protocols to interact with apis .
some of the boilerplate code was due to questionable api designs e.g.
requiring the client to cast the output by providing an abstract object but some seemed inevitable due to the design patterns or apparent trade offs in the design of the apis.
for example an api adopting a builder pattern usually involves a lot of boilerplate to set properties of an object.
another were due to programmers using the api inefficiently such as using an api call which is not ideal that requires more code.
since most of boilerplate code instances are by products of language and api limitations analyzing boilerplate code can help review their designs and find usability issues.
despite some of the limitations being unavoidable such as error handling in java there are many other situations where api designers can reduce the need for boilerplate such as by adopting annotation libraries or introducing helper functions.
boilerplate code due to programmers using the api ineffi618 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ciently may be a signal that there are discoverability issues so the documentation and tutorials might need to be improved to overcome the conceptional gap between the api designers and api users.
note that while we were able to code every boilerplate instance with codes from reasons for code cloning which indicates that boilerplate can be considered a type of code clone the two are not identical as clearly not all code clones can be considered boilerplate under our definition high frequency localized api related .
therefore while our approach to automatically mine boilerplate candidates section iv starts from an existing api usage pattern miner future work could also consider boilerplate mining approaches that start from code clone detectors but exploring this goes beyond the scope of the current work.
d.rq how do programmers and api contributors deal with boilerplate code?
method to answer rq the first and second authors performed descriptive coding on the changes that were made to reduce the amount of boilerplate code either boilerplate within the source code itself or boilerplate that is needed by the client to use the library.
we used the same boilerplate instances found in commits from rq i.e.
attempts to reduce the boilerplate code by editing the project code and commits that changed the api itself i.e.
attempts to reduce the boilerplate code using the api .
we coded based on the code diffs and commit messages and extracted the means used to reduce boilerplate code.
results the majority of boilerplate code reductions within a project were made by introducing new helper functions or classes either by writing new ones or by including a function or class from an external api.
for the simple java specific boilerplate such as getters setters some used annotations e.g.
project lombok or injection to reduce the amount of boilerplate.
when changing the api to reduce the client side boilerplate programmers added more processing into the library thereby reducing the need for pre post processing for the input output of api calls.
some made the interfaces more specific to reduce the need for parsing or casting in the client code.
also like within project boilerplate reduction some commits added a set of helper functions or new classes to allow users to have a more specific but simpler interface which can usually be done without making breaking changes to the api.
iv .
m ining boilerpla te code using the results from the previous section section iii b we seek to find code instances that contain calls to a target api and satisfy the properties of boilerplate code we identified are undesirable occur frequently in client code occur within a relatively condensed area and are used in similar forms without significant variations.
to this end we designed marble which combines an api usage pattern mining technique with a graph partitioning algorithm to identify candidate boilerplate code from softwarerepositories.
marble consists of several steps depicted in figure and described below.
in summary we first identify a large set of api usage patterns which represents our initial set of boilerplate candidates.
we then filter out any patterns that are spread over multiple methods or which have many variants to finally provide a short list of boilerplate candidates that satisfy all of the properties above except for property undesirable .
these candidates could then sorted and contextualized with the real world client code and delivered to the api designers so they can review the candidates for property .
we intentionally designed the process in this order because testing property little structural variation is computationally expensive.
by filtering out the candidates that do not satisfy the other properties we are able to reduce the number of ast comparisons section iv c1 .
a. api usage pattern mining we start from an existing api usage pattern mining technique to collect boilerplate candidates containing one or multiple target api calls and satisfying the high frequency property.
specifically we chose pam probabilistic api miner a state of the art parameter free probabilistic approach which is fully automated and available open source.
in their evaluation fowkes et al.
found that pam returns less redundant and less numerous results compared to other api usage pattern mining algorithms the authors compared.
the pam core pam uses a probability model over api call sequences to identify interesting sequences of api calls api usage patterns.
given a target api the model can be trained unsupervised on a corpus containing code from open source g ithubrepositories.
concretely pam first parses each source file and extracts the sequence of target api calls within each method only java code is currently supported using a depth first traversal of the abstract syntax tree ast .
at the same time frequency information for each api call over methods is recorded.
for example given javax.xml.transform as a target api and listing as one client method using it pam s api call extractor returns javax.xml.transform.transformerfactory.newinstance javax.xml.transform.transformerfactory .newtransformer javax.xml.transform.transformer .setoutputproperty javax.xml.transform.dom.domsource.
init javax.xml.transform.stream.streamresult.
init javax.xml.transform.transformer.transform then pam uses expectation maximization em to iteratively infer interesting api usage patterns i.e.
sequences of api calls and learn the probability model.
that is an api call sequence is interesting if the two api calls a andboccur together more often than expected by chance given the individual frequencies of aandb.
the em algorithm iteratively interleaves api call sequences and searches for the set of patterns that maximizes the probability that the model assigns to all client methods in the input dataset.
for more details we refer to the original paper by fowkes et al.
.
pam returns a ranked list of api usage patterns p where pi i sa n authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
fig.
.
overview of our mining process and the steps involved.
api call sequence.
for example when we run pam on javax.xml.transform it returns p1 javax.xml.transform.dom.domsource.
init javax.xml.transform.stream.streamresult.
init p2 javax.xml.transform.transformerfactory.
newtransformer javax.xml.transform.transformer.transform p3 p4 ... modifications to the pam core as our main goal is to help api designers identify the patterns that are likely to reflect api usability issues the list of candidates to beconsidered must be relatively short since such reasoningrequires designers manual effort.
we modified the base pamalgorithm to reduce the number of false positive boilerplatepatterns returned.
this step involved setting two thresholdsempirically which we did after reviewing a sample of pam results first if there is a pair of patterns such that one fully contains the other e.g.
p 1andp3above we remove the sub pattern p unless the number of occurrences is more than different from its super pattern s to avoid reportingmultiple small variations of one boilerplate candidate.
forexample if there is a sequence which occurred times among the client code files and another sequence occurred times we keep and ignore because a b and care mostly used all together.
however if occurred times we do not ignore it because it is likely that there are other uses not involving c. second to avoid reporting rare and project specific boilerplatecode candidates we also ignore patterns that occurred in lessthan of client code methods for a given api.
limitations the returned api usage patterns are sequences of api calls without any structural information.
thisensures that the returned patterns are robust to variations in local context e.g.
conditionals loops exception handling etc.
which is desirable when the goal is mining generic api usage examples.
however this is at odds with our thirdboilerplate requirement that the call sequence should appearin similar form without significant variation.
another limitation of pam for boilerplate mining is that the order of api calls matters.
when a boilerplate instanceinvolves multiple api calls that can be used in any order such as getheight andgetwidth pam would consider and getwidth getheight to be different sequences and the interestingness of this api usage would be lower than it should be.
finally pam was originally designed to capture the usage patterns of a single library whereas api usage patterns orboilerplate can have multiple libraries involved.
we address these limitations in the following steps by also considering the context around the interesting api call sequences.
b. ast extraction to decide whether an interesting api usage pattern involves boilerplate we should also consider the structural context around the api calls.
for example if other methods e.g.
built in language apis are always used around or between the target api calls or if the sequence of target apicalls is always used inside a certain loop construct we shouldalso consider this context as part of the candidate boilerplateinstance.
therefore to determine this context given a list ofapi usage patterns and a list of client code files containinginstances of those patterns p f1 p2 f2 ... pn fn respectively for each piwe extract and post process the asts of the files in fi.
moreover since we are only interested in code that occurs in local areas property above i.e.
the areas around the target api calls we restrict this analysisto individual methods and split the file level asts whichcorrespond to entire classes into method level subtrees.
still the method level ast subtrees may contain nodes unrelated to target api calls and the candidate boilerplate pattern.
to narrow down the relevant parts of the method level ast subtrees s we use a simple slicing heuristic we extract the smallest sub subtrees of eachsubtree s which completely encompass the target api call pattern.
for example given an ast of the client codein listing figure and an api usage pattern p javax.xml.transform.dom.domsource.
init javax.xml.transform.stream.streamresult.
init we extract the first common ancestor of the domsource and streamresult nodes i.e.
the subtree rooted at method invocation .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
!
fig.
.
a part of the ast for the code in listing and the extracted subtree colored for the api usage pattern domsource.
init streamresult.
init using our slicing heuristic.
for patterns with a single api call the smallest subtree is the same as the api call which means we do not acquire further contextual information.
therefore we modify the smallest subtree heuristic for these patterns and find the smallest if loop try subtree containing the api call.
however this heuristic may not always extract a smaller subtree than the entire method e.g.
i fn o if loop try is used in the method .
based on the third property that statements constituting boilerplate code are closely located near each other we applied another heuristic when the subtree has over method invocations trim the sub subtrees that are far from the sub subtrees containing the api calls.
we chose the threshold informed by the examples collected from the qualitative study in section iii.
if an api call of a pattern occurred multiple times in a client file there might be multiple potential subtrees.
in this case we use the smallest one following property the further the calls are apart the less probable it is that they form a single pattern.
in the case that the full smallest pattern occurs multiple times in a client code file we keep multiple subtrees.
c. graph partitioning as the third step in our approach we check property whether the api call sequence is used consistently in similar contexts i.e.
structures throughout the client code.
to capture this property we devise an approach to compute the similarity between all pairs of subtrees containing the api call sequence contexts and cluster together similar subtrees.
intuitively if there are many clusters with low similarity this indicates that there are many different ways a sequence of api calls is being used at the code level suggesting that the pattern is less likely to be a part of boilerplate as per property .
in contrast if there is a cluster having a number of subtrees and the similarity between them is high the cluster i.e.
specific use case can be a boilerplate candidate.
pairwise similarity given a list of subtrees for each client file in ficontaining a same api pattern p we compare every pair of subtree lists from angbracketleftfi fj angbracketrightinfi and calculate the similarity between them.
we use ap ted all path tree edit distance as our distance inverse similarity measure since it is memory efficient and fast.
other tree differencing algorithms such as gumtree could be applied as well.
to calculate the ap ted we visit each subtree in preorder collecting the types of each node e.g.
methoddeclaration or ifstatement .
to avoid noise from lexical details such as variable names we only collect nodes for loops e.g.
forstatement error handling e.g.
trystatement conditions e.g.
ifstatement casts and method invocation types.
for the methodinvocation nodes we also collect the names e.g.
newinstance to compare different api calls used in the boilerplate candidate.
to overcome pam s limitation that it only considers the usage patterns of one target api we also collect the names of method invocations that are not from the target api.
by this even though pam is not able to capture external api calls as part of a sequence our approach can still use them to calculate the similarity and the external calls will be seen in the boilerplate candidate if they frequently occur together with the target library s api calls.
it also helps mitigate pam s other limitation not capturing a set of api calls into a usage pattern unless they occur in the same order.
to calculate the similarity using the tree edit distance we invented tes the tree edit similarity.
when sis a list of subtrees in f each of which encompass the target api given two lists of subtrees angbracketlefts1 s2 angbracketrightfor angbracketleftf1 f2 angbracketright we define tes as tes s1 s2 max parenleftbigg1 eap ted s1i s2j .
parenrightbigg in the case that the client code file uses the pattern multiple times so there are multiple subtrees for si we calculate the distance between every pair of subtrees and use the maximum value for the next step.
clustering with these pairwise similarity values we build a weighted graph for each pattern in which nodes niare client code files and edges ni njare weighted bytes ni nj .
we then cluster the nodes in this graph to capture the different contexts structures in which an api call sequence is being used.
as the similarity values between client code files are computed based on the asts boilerplate candidates that are structurally similar would likely be clustered together.
on the other hand even if the same api calls are used in two client files if their structures are significantly different or external api calls around the pattern are significantly different which the edge weight captures they would likely be clustered separately.
therefore after graph partitioning the clusters would indicate structurallydifferent usage patterns given a sequence of target api calls.
for clustering we use the louvain community detection algorithm a heuristic method based on modularity optimization given a weighted graph of nnodes louvain first assigns a different cluster to each node.
then for each node ni louvain calculates the gain in modularity by removing nifrom its cluster and placing it into its neighboring nj s cluster.
if the gain is positive and maximum among the gains from other neighbor nodes the algorithm removes ni s cluster and merges niinto nj.
the process repeats and is applied until there is no further improvement in modularity.
secondly louvain adjusts the weights of the edges.
the weights of the edges between the new clusters are the sum of the weights of the edges between nodes in the corresponding two clusters.
the algorithm keeps iterating the first phase merging clusters and second phase adjusting weights until a fixed point.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we applied this technique for three main reasons i unlike most other graph clustering algorithms for which the number of clusters should be given as input louvain determines it as part of the algorithm ii its computation time is short iii it was originally designed for large networks e.g.
million nodes hence we expect it to scale up well.
additional filtering the clustering algorithm does not guarantee that within a cluster the client code instances of the api usage pattern are allhighly similar among each other i.e.
that they all represent the same boilerplate candidate instance.
to further prune spurious clusters which may increase noise in the results we require that the average pairwise within cluster similarity is greater than a threshold.
empirically we observed that patterns involving many api calls would have more variance in the subtrees and thus the similarity would be lower than short usage patterns even though qualitatively they would appear similar therefore when the pattern is longer the similarity threshold should be lower.
we set this threshold for average tes equation to be e2 x .
where xis the number of api calls in the sequence.
for example when a usage pattern contains only one api call the threshold is e .
.
i.e.
we discard clusters with average within cluster similarity below .
.
d. viewer since boilerplate code has the subjective properties discussed in section iii that cannot be automatically tested manual review of the candidates is necessary.
to help api designers efficiently review them we implemented a viewer for the boilerplate candidates.
based on the intuition that more verbose boilerplate candidates should be reviewed first by api designers marble s viewer ranks all the boilerplate candidates by their length and for each one displays usage examples from three representative client code files from different g ithubprojects.
v. e v alua tion in this section we evaluate the accuracy and potential usefulness of our mining algorithm by answering rq4 v alidation how well does marble identify known boilerplate examples?
rq5 precision how many of the boilerplate candidates found by marble would human experts agree with?
rq6 practicality does marble return a reasonably short list of boilerplate candidates for manual review?
rq7 usefulness does marble identify informative boilerplate candidates that could help review an api?
rq4is to test whether marble finds the boilerplate examples corresponding to java apis we collected from the literature survey and stack overflow in section iii.
rq5evaluates marble s false positive rate.
quality assurance tools such as defect prediction or static analysis should generate few false warnings to be usable in practice.
rq6evaluates marble s practicality.
reviewing boilerplate candidates and investigating potential usability issuesrequire manual effort from the api designers as labelling something as boilerplate is ultimately a judgement call.
on the same set of apis for which we collected known boilerplate examples we evaluate whether marble returns a sufficiently short list of candidates in the right order so that it may be usable in practice.
specifically we test to what extent our filtering steps involving ast comparison and graph partitioning discussed above will help to substantially reduce and rank the list of candidates for manual review compared to the baseline pam .
rq7is to qualitatively evaluate marble s usefulness.
the first and third authors manually reviewed all the mined boilerplate candidates for the same apis and analyzed to what extent the candidates signal places where the apis might be improved.
a. experimental setup dataset to collect api client code we identified and cloned the top most starred java repositories from github using the march version of ghtorrent excluding forks and repositories marked as deleted.
we then mined the java source files importing the apis by matching import statements e.g.
import javax.xml.transform .
for apis with more than client code files to reduce the runtime of our experiments we sampled files randomly ensuring confidence level and margin of error.
table i gives an overview of our dataset.
each row in the table is a separate api on which we ran marble one api per each of the known boilerplate examples.
the api patterns column shows the number of api usage patterns returned by just running pam and the boilerplate candidates column shows the number of boilerplate candidates that marble identifies.
the found known boilerplate column shows whether marble found the known examples.
the precision column shows the percentage of boilerplate candidates that the first and third authors labeled as actual boilerplate among the number of the candidates that our approach retrieved for each api.
the client files column shows the number of client code files that were used for boilerplate mining.
the files w bp column shows the number of client code files that involve at least one boilerplate instance.
the avg.
len.
column shows the average length of the boilerplate candidates.
the precision on the total row is the micro average precision that is the average precision after aggregating the data of all libraries.
implementation details for the api usage pattern mining part section iv a we adjusted the output generation part of pam s public implementation without modifying the core algorithm.
we ran pam using default parameter settings iterations with a priority queue size limit of candidates.
for the ast comparison section iv b we wrote a java program to parse and traverse asts and extract subtrees with our heuristics.
to compare the subtrees we used the apted library but customized the cost model to weigh insertion deletion and rename operation equally.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i summary sta tistics on the number of candida te boilerpla te instances for the api si no u rd a t a s e t .
apiapi patternsboilerplate candidatesfound known boilerplateprecision client files client w bp avg.
len.
android.app.progressdialog true .
.
android.database.sqlite true .
.
android.support.v4.app.activitycompat true .
.
android.view.view true .
.
com.squareup.picasso false java.beans.propertychangesupport true .
.
java.beans.propertychangeevent true10.
java.io.bufferedreader true .
.
java.sql.drivermanager false javax.swing.jframe false javax.swing.swingutilities false .
.
javax.xml.parsers true .
.
javax.xml.transform true .
.
total .
.
.
1during the evaluation authors came to the conclusion that the known boilerplate instance for java.beans.propertychangeevent from stack overflow is not a strong boilerplate code.
therefore even though marble mined the similar pattern from the client code found known boilerplate true none of the candidates from this library is labeled as boilerplate code precision .
.
for the graph partitioning section iv c we wrote a python program to build a graph preform graph partitioning using the networkx package and filter spurious clusters using our heuristics.
the final boilerplate candidate viewer generator for the api designers is implement in python and generates a html page for each api.
b. results and discussion rq v alidation how well does marble identify known boilerplate examples?
we ran marble on all apis represented in the discovered boilerplate examples table i and manually compared the returned candidates to the known examples.
among the known boilerplate examples marble could identify .
three out of four false negatives were not caught by marble because they incorporate a variety of real code i.e.
non boilerplate code inside them like invokelater in javax.swingutilities .
although the boilerplate wrapping the real code was repetitive and the same for every usage the non boilerplate part varied widely among the client code files which lowered the similarity between the client code ast subtress containing this pattern.
this could be improved in the future by applying program analysis to more accurately slice the api call related and unrelated parts of the code we discuss more in section vi .
eliminating irrelevant non boilerplate code by applying program analysis and we discuss more in section vi.
another false negative was a builder pattern which marble did not identify because client code files used different combinations of setter calls.
a stack overflow user complained about this because the same builder was needed multiple times within the project which does not necessarily mean that other programmers use it in the same way in other projects.
since marble s goal is more general to inform api designers about potential boilerplate in a wide range of client code this example was not exactly in scope.
however marble could be extended to also identify these withinproject boilerplate examples if api designers feel the need by adding the within project pattern frequency to the algorithm.
we conclude that marble is valid.
rq precision how many of the boilerplate candidates found by marble would human experts agree with?
marble returned boilerplate candidates overall for the apis in our sample table i .
to compute marble s precision the first and third authors labelled each candidate as potentially boilerplate or not.
the authors first separately labelled all of the candidates inter rater agreement then discussed disagreements until reaching consensus finally updating the labels.
the main criteria for the boilerplate designation were whether it potentially reduces the api usability and whether it could be further abstracted.
as a limitation note that we labelled some candidates as false positives even though they resemble boilerplate verbose and seemingly abstractable because we could not confirm that these could significantly lower the api usability without looking at the number of occurrences within a single file or a single project which goes beyond the scope of this work.
as discussed above we designed marble to identify boilerplate candidates across a large number of client code files projects to help api designers focus on boilerplate that might affect more users.
however while we were reviewing the candidates we found that within project boilerplate might also impact api usability.
for example as a programmer it could be annoying if three lines of an api sequence need to be duplicated across many methods within a project even though those three lines might be rarely used in other projects.
overall marble s precision is the two annotators agreed that out of candidates could be considered boilerplate.
we conclude that marble has acceptable precision.
rq practicality does marble return a reasonably short list of boilerplate candidates for manual review?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
if activitycompat.shouldshowrequestpermissionrationale this manifest.permission.read external storage else activitycompat.requestpermissions this new string manifest.permission.read external storage 6m y permissions request read external storage listing .
boilerplate code instance of android activitycompat client codes.
comparing the marble results to pam s the api sequence miner our approach is built on section iv a we observe that marble significantly reduces the number of resulting instances by applying further filtering on the pam output using ast comparison and graph partitioning.
the reduction is from a mean of usage patterns per api with pam down to a mean of .
boilerplate candidates with marble median down from to the largest reduction is for android.view.view from down to table i .
we also measured the time it takes to label the boilerplate candidates to roughly estimate the time needed for a designer s manual review.
the third author who is an expert api designer took less than minutes per boilerplate candidate and the first author a software engineering ph.d. student took around minutes per candidate.
since we did not have enough experience with some of the apis it took more time to read the documentations and use cases.
however for api designers we believe that it would take less time to review the boilerplate candidates and find potential usability issues.
we conclude that marble returns a sufficiently short list of candidates for manual review to be feasible.
rq usefulness does marble identify informative boilerplate candidates that could help a designer review an api?
we manually reviewed all boilerplate candidates identified full list available online looking for causes and potential improvements.
given the space constraints we discuss only three boilerplate candidates returned by marble.
android activitycompat.
listing shows potential boilerplate involving android s activitycompat with two api calls activitycompat.shouldshowrequestpermissionrationale andactivitycompat.requestpermissions .
this boilerplate is to ask a certain permission to a user but also provide an explanation if a user has already denied the permission request from this app.
shouldshowrequestpermissionrationale returns true if the user has previously denied the request but did not select the don t ask again option in the permission request dialog or false if the app has never asked a permission a device policy prohibits it or the user has selected the option.
marble identified that out of files importing activitycompat this pattern is used in the same format in .
one potential redesign for better usability in this case is to abstract this into the api by adding a simpler method which handles permission checking and request rationale internally if the permission is not granted it checks if the permission request has been already denied or not requests the permission with or without explanation and sends the results to the client.
override public void onupgrade sqlitedatabase db intoldv ersion intcurrentv ersion log.w tag upgrading test database from version oldv ersion to currentv ersion which will destroy allold data db.execsql drop table ifexists data oncreate db listing .
boilerplate code instance of android database sqlite client codes.
however we hypothesize that there could be a design rationale behind the current design e.g.
possibly to improve the privacy of the users of android applications.
although our proposed abstraction could help new android developers get started with the api lead to less code and be less error prone in these common cases this could also give an impression that providing rationale on permission requests to the android application users is not critical.
we argue that this trade off is only valid when users understand the api designer s rationale or at least that the rationale actually plays out as expected.
if most users just copy and paste this boilerplate code without much thought this design decision could reduce api usability without any benefits.
therefore alerting api designers to situations where their design decisions result in boilerplate may help them review to what extent their design rationale is valid.
android database sqlite is an open source relational database library in android.
listing shows a boilerplate code instance to upgrade a database by dropping tables and creating a new one which requires using sqlitedatabase.execsql andsqliteopenhelper.oncreate .
although onupgrade was intended to provide flexibility for users marble found that client code files out of overrode it in the same way similar to listing by dropping tables using execsql and creating new ones with oncreate .
to mitigate this boilerplate as discussed in section iii api designers could make the common usage such as logging the update dropping the table and recreating the database with a new version as the default functionality of onupgrade .
this would allow users to write less code in general and also give them some flexibility if needed.
another way to reduce this type of boilerplate is to use annotation libraries e.g.
the spring framework or orm object relational mapping libraries which offer an objectoriented interface to the relational database.
annotations and orm tools reduce the need for simple crud create read update and delete boilerplate and many libraries have adopted them e.g.
neo4j ogm .
in fact while reviewing the client code using this boilerplate we observed that of the client code files have adopted greendao which is an orm tool for android.
the fact that many clients adopt a certain helper function or a tool can be a signal for api designers to update their api similarly or recommend these tools to their clients for better usability.
this boilerplate also shows that seeing the common patterns of use and whether they could be abstracted by an annotation framework might be authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
if videocontrolsview !
null this.seekbar seekbar this.videocontrolsview.findviewbyid r.id.vcv seekbar this.imgfullscreen imagebutton this.videocontrolsview.findviewbyid r.id.
arrowhookleft vcv img fullscreen this.imgplay imagebutton this.videocontrolsview.findviewbyid r.id.
arrowhookleft vcv img play this.texttotal textview this.videocontrolsview.findviewbyid r.id.
arrowhookleft vcv txttotal this.textelapsed textview this.videocontrolsview.findviewbyid r.id.
arrowhookleft vcv txtelapsed listing .
boilerplate code instance of android view client codes.
useful for the helper library designers as well in understanding the needs of users and developing a new library.
android view.
notably as the apis we used for evaluation are popular and actively maintained in some cases we could actually find the improvements that had already been made by the api designers.
the boilerplate candidate was still detectable in our dataset because the clients had yet to upgrade to the newer version of the api.
listing shows a classic boilerplate code for android view.
these lines of code are to find the views from the xml layout resource file with the given ids.
the pattern consists of multiple uses of one api call android.view.view.findviewbyid .
we could observe that files out of files use this method at least three times in a row.
it is already verbose since developers need to call this method multiple times but even worse because null checking and typecasting are also needed.
a straightforward way to reduce this verboseness is to make the return type of findviewbyid to a generic t to eliminate the need for manual typecasting.
in fact android changed the method s definition from view findviewbyid int id to t findviewbyid int id starting with android .
.
this shows that api designers care about the boilerplate code instances which reduce the api usability and informing api designers about the boilerplate candidates can actually lead to usability improvements.
like the previous boilerplate candidate another way to reduce this type of boilerplate is to use annotation libraries.
there are several libraries providing annotation supports for this boilerplate e.g.
bindview of butterknife by helping users easily map the view id declared in an xml layout file with the java variable.
c. threats to v alidity our approach may be biased by the small number of apis we tested it on.
however the boilerplate examples cover various domains and design patterns and we believe that the properties we identified will generalize.
note also that we only used externally known boilerplate examples to extract boilerplate properties and as a validation set to empirically choose the different thresholds involved.
still marble was able to discover many previously unreported boilerplate examples which reduces the threat of overfitting.as we only evaluated our algorithm with popular java apis which have hundreds to tens of thousands of client files it is possible that the usefulness or performance of our algorithm varies for other libraries that are relatively new or less popular.
also as we analyzed the boilerplate instances with a single api designer and a ph.d. student others may disagree that our tool identifies boilerplate that is worth looking at.
vi.
c onclusions and future work we presented the novel problem of mining software repositories to identify candidate boilerplate code as a potential api usability issue.
we devised marble a new boilerplate mining algorithm based on four properties of boilerplate code that we identified from many sources undesirable high frequency locality and limited structural variation .
we evaluated our algorithm on java apis finding many api usage patterns indicative of potential improvements to the api designs.
our study opens up several directions for future research.
first we expect that integrating program analysis techniques especially program slicing into marble will be helpful.
one could run control and data flow analyses to identify and extract the statements that are dependent on the target api calls or provide parameters and variables used by them which could improve the precision of our mining algorithm.
second the definition and properties of boilerplate could also be refined.
future work could survey api designers and developers to get wider input on what properties of boilerplate code they are most interested in having a tool capture and adjust the algorithm accordingly.
future work could also extend the tool to support other languages especially javascript.
we expect that javascript apis might have more boilerplate code instances since the language has a huge ecosystem with a variety of apis which leads to frequent interactions among them and also to frequent version changing.
finally a more extensive evaluation could involve deploying the tool for use by many real designers in industry in hopes of actually helping them identify and eliminate some boilerplate code from clients of their apis and review their design decisions.
we plan such a large scale empirical evaluation as part of our future work.
vii.
a cknowledgement we gratefully acknowledge support from google faculty research awards.
we also thank joshua bloch for guidance about api design as well as our survey respondents for their time and input.