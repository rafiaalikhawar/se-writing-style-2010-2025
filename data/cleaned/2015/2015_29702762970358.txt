usage costs and benefits of continuous integration in open source projects michael hilton oregon state university usa hiltonm eecs.oregonstate.edutimothy tunnell university of illinois usa tunnell2 illinois.edukai huang university of illinois usa khuang29 illinois.edu darko marinov university of illinois usa marinov illinois.edudanny dig oregon state university usa digd eecs.oregonstate.edu abstract continuous integration ci systems automate the compilation building and testing of software.
despite ci rising as a big success story in automated software engineering it has received almost no attention from the research community.
for example how widely is ci used in practice and what are some costs and bene ts associated with ci?
without answering such questions developers tool builders and researchers make decisions based on folklore instead of data.
in this paper we use three complementary methods to study the usage of ci in open source projects.
to understand which ci systems developers use we analyzed opensource projects from github.
to understand howdevelopers use ci we analyzed builds from the most commonly used ci system.
to understand whyprojects use or do not use ci we surveyed developers.
with this data we answered several key questions related to the usage costs and bene ts of ci.
among our results we show evidence that supports the claim that ci helps projects release more often that ci is widely adopted by the most popular projects as well as nding that the overall percentage of projects using ci continues to grow making it important and timely to focus more research on ci.
ccs concepts software and its engineering !agile software development software testing and debugging keywords continuous integration mining software repositories .
introduction continuous integration ci is emerging as one of the biggest success stories in automated software engineering.
ci systems automate the compilation building testing anddeployment of software.
for example such automation has been reported to help flickr deploy to production more than times per day.
others claim that by adopting ci and a more agile planning process a product group at hp reduced development costs by .
these success stories have led to ci growing in interest and popularity.
travis ci a popular ci service reports that over projects are using travis.
the state of agile industry survey with participants found of respondents use ci.
the state of devops report nds ci to be one of the indicators of high performing it organizations .
google trends shows a steady increase of interest in ci searches for continuous integration increased in the last decade.
despite the growth of ci the only published research paper related to ci usage is a preliminary study conducted on projects which compares several quality metrics of projects that use or do not use ci.
however the study does not present any detailed information on how projects use ci.
in fact despite some folkloric evidence about the use of ci there is no systematic study about ci systems.
not only do we lack basic knowledge about the extent to which open source projects are adopting ci but also we have no answers to many important questions related to ci.
what are the costs of ci?
does ci deliver on the promised bene ts such as releasing more often or helping make changes e.g.
to merge pull requests faster?
do developers maximize the usage of ci?
despite the widespread popularity of ci we have very little quantitative evidence on its bene ts.
this lack of knowledge can lead to poor decision making and missed opportunities.
developers who choose not to use ci can be missing out on the bene ts of ci.
developers who do choose to use ci might not be using it to its fullest potential.
without knowledge of how ci is being used tool builders can be misallocating resources instead of having data about where automation and improvements are most needed by their users.
by not studying ci researchers have a blind spot which prevents them from providing solutions to the hard problems that practitioners face.
in this paper we use three complementary methods to study the usage of ci in open source projects.
to understand the extent to which ci has been adopted by developers and which ci systems developers use we analyzed opensource projects from github.
to understand howdevelopers use ci we analyzed builds from travis ci the most commonly used ci service for github projects section .
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
to understand whyprojects use or do not use ci we surveyed developers.
with this data we answer several research questions that we grouped into three themes theme usage of ci rq1 what percentage of open source projects use ci?
rq2 what is the breakdown of usage of di erent ci services?
rq3 do certain types of projects use ci more than others?
rq4 when did open source projects adopt ci?
rq5 do developers plan on continuing to use ci?
we found that ci is widely used and the number of projects which are adopting ci is growing.
we also found that the most popular projects are most likely to use ci.
theme costs of ci rq6 why do open source projects choose notto use ci?
rq7 how often do projects evolve their ci con guration?
rq8 what are some common reasons projects evolve their ci con guration?
rq9 how long do ci builds take on average?
we found that the most common reason why developers are not using ci is lack of familiarity with ci.
we also found that the average project makes only changes to their ci conguration le and that many such changes can be automated.
theme bene ts of ci rq10 why do open source projects choose to use ci?
rq11 do projects with ci release more often?
rq12 do projects which use ci accept more pull requests?
rq13 do pull requests with ci builds get accepted faster in terms of calendar time ?
rq14 do ci builds fail less on master than on other nonmaster branches?
we rst surveyed developers about the perceived bene ts of ci then we empirically evaluated these claims.
we found that projects that use ci release twice as often as those that do not use ci.
we also found that projects with ci accept pull requests faster than projects without ci.
this paper makes the following contributions .research questions we designed novel research questions.
we are the rst to provide in depth answers to questions about the usage costs and bene ts of ci.
.data analysis we collected and analyzed ci usage data from open source projects.
then we analyzed in depth all ci data from a subset of projects and their builds commits and pull requests.
moreover we surveyed open source developers about why they chose to use or not use ci.
.implications we provide practical implications of our ndings from the perspective of three audiences researchers developers and tool builders.
researchers should pay attention to ci because it is not a passing fad.
for developers we list several situations where ci provides the most value.
moreover we discovered several opportunities where automation can be helpful for tool builders.more details about our data sets and results are available at eecs oregonstate edu cisurvey .
overview of ci .
history and definition of ci the idea of continuous integration ci was rst introduced in by grady booch in the context of objectoriented design at regular intervals the process of continuous integration yields executable releases that grow in functionality at every release... this idea was then adopted as one of the core practices of extreme programming xp .
however the idea began to gain acceptance after a blog post by martin fowler in .
the motivating idea of ci is that the more often a project can integrate the better o it is.
the key to making this possible according to fowler is automation.
automating the build process should include retrieving the sources compiling linking and running automated tests.
the system should then give a yes or no indicator of whether the build was successful.
this automated build process can be triggered either manually or automatically by other actions from the developers such as checking in new code into version control.
these ideas were implemented by fowler in cruisecontrol the rst ci system which was released in .
today there are over di erent ci systems and some of the most well known ones include jenkins previously called hudson travis ci and microsoft team foundation server tfs .
early ci systems usually ran locally and this is still widely done for jenkins and tfs.
however ci as a service has become more and more popular e.g.
travis ci is only available as a service and even jenkins is o ered as a service via the cloudbees platform .
.
example usage of ci we now present an example of ci that comes from our data.
the pull request we are using can be found here com restkit restkit pull .
a developer named adlai holler created pull request named avoid flushing in memory managed object cache while accessing to work around an issue titled duplicate objects created if inserting relationship mapping using rkinmemorymanagedobjectcache for the project restkit .
the developer made two commits and then created a pull request which triggered a travis ci build.
the build failed because of failing unit tests.
a restkit project member segiddins then commented on the pull request and asked adlai holler to look into the test failures.
adlai holler then committed two new changes to the same pull request.
each of these commits triggered a new ci build.
the rst build failed but the second was successful.
once the ci build passed the restkit team member commented seems ne and merged the pull request.
.
methodology to understand the extent to which ci is used and which ci systems developers use we analyzed open source projects from github with our breadth corpus .
to understand how developers use ci we analyzed builds on the most popular ci system in our depth corpus .
to understand whyprojects use or do not use ci we surveyed developers.
.
breadth corpus the breadth corpus has a large number of projects and information about what ci services each project uses.
we use the breadth corpus to answer broad questions about the usage of ci in open source projects.
we collected the data for this corpus primarily via the github api.
we rst sorted github projects by their popularity using the star rating whereby users can mark or star some projects that they like and hence each project can accumulate stars .
we started our inspection from the top of the list rst by manually looking at the top projects.
we collected all publicly available information about how these projects use ci.
we then used what we learned from this manual inspection to write a script to programmatically classify which ci service if any a project uses.
the four ci services that we were able to readily identify manually and later by our script are sorted in the order of their usage travis ci circleci appveyor and werker .
all of these services provide public api s which we queried to determine if a project is using that service.
moreover we wanted to ensure that we had collected as complete data as possible.
when we examined the data by hand we found that several projects were using cloudbees a ci service powered by the jenkins ci.
however given a list of github projects there is no reliable way to programmatically identify from the github api which projects use cloudbees.
in contrast travis ci uses the same organization and project names as github making it easy to check correspondence between travis ci and github projects.
we contacted cloudbees and they sent us a list of open source projects that have cloudbees build set up.
we then wrote a script to parse that list inspect the build information and search for the corresponding github repository or repositories for each build on cloudbees.
we then used this data to identify the projects from our breadth corpus that use cloudbees.
this yielded unique github repositories projects.
to check whether these projects refer to cloudbees we searched for case insensitive cloudbees in the readme les of these projects and found that only of them contain cloudbees .
in other words had we not contacted cloudbees directly using only the information available on github we would have missed a large number of projects that use cloudbees.
overall the breadth corpus consists of projects.
for each project we collected the following information project name and owner the ci system s that the project uses if any popularity as measured by the number of stars and primary programming language as determined by github .
.
depth corpus the depth corpus has fewer projects but for each project we collect all the information that is publicly available.
for this subset of projects we collected additional data to gain a deeper understanding of the usage costs and bene ts of ci.
analyzing our breadth corpus as discussed in section .
we learned that travis ci is by far the most commonly used ci service among open source projects.
therefore we targeted projects using travis ci for our depth corpus.
first we collected the top projects from github ordered by their popularity.
of those projects we identi ed projects that use travis ci use appveyor usecircleci and use werker.
we used the travis ci api1to collect the entire build history for each project in our depth corpus for a total of builds.
using ghtorrent we collected the full history of pull requests for each project for a total of pull requests.
additionally we cloned every project in our corpus to access the entire commit history and source code.
.
survey even after collecting our diverse breadth and depth corpora we were still left with questions that we could not answer from the online data alone.
these questions were about whydevelopers chose to use or not use ci.
we designed a survey to help us answer a number of such why questions as well as to provide us another data source to better understand ci usage.
we deployed our survey by sending it to all the email addresses publicly listed as belonging to the organizations of all the top github projects again rated by the popularity .
in total we sent emails.
our survey consisted of two ows each with three questions.
the rst question in both ows asked if the participant used ci or not.
depending on the answer they gave to this question the second question asked the reasons why they use or do not use ci.
these questions were multiple choice multiple selection questions where the users were asked to select all the reasons that they agreed with.
to populate the choices we collected some common reasons for using or not using ci as mentioned in websites blogs and stack over ow .
optionally the survey participants could also write their own reason s that we did not already list.
the third question asked if the participant plans on using ci for future projects.
to incentivize participation we ra ed o a usd gift card among the survey respondents.
.
response rate participants responded to our survey.
of those responses .
indicated that they do use ci and .
indicated that they do not use ci.
.
results in this section we present the results to our research questions.
section .
presents the results about the usage of ci.
section .
discusses the costs of ci.
finally section .
presents the bene ts of ci.
rather than presenting implications after each research question we draw from several research questions to triangulate implications that we present in section .
.
usage of ci to determine the extent to which ci is used we study what percentage of projects actively use ci and we also ask developers if they plan to use ci in the future.
furthermore we study whether the project popularity and programming language correlate with the usage of ci.
rq1 what percentage of open source projects use ci?
we found that of all the projects in our breadth corpus use ci.
table shows the breakdown of the usage.
thus ci is indeed used widely and warrants further investigation.
1we are grateful to the travis ci developers for promptly resolving a bug report that we submitted prior to them resolving this bug report one could not query the full build history of all projects.
428table breadth corpus projects ci usage project uses ci?
percentage number of projects yes .
no .
additionally we know that our scripts do not nd all ci usage e.g.
projects that run privately hosted ci systems as discussed further in section .
.
we can reliably detect the use of public ci services only if their api makes it possible to query the ci service based on knowing the github organization and project name.
therefore the results we present are a lower bound on the total number of projects that use ci.
table ci usage by service.
the top row shows percent of all ci projects using that service the second row shows the total number of projects for each service.
percents add up to more than due to some projects using multiple ci services.
usage by ci service travis circleci appveyor cloudbees werker .
.
.
.
.
rq2 what is the breakdown of usage of di erent ci services?
next we investigate which ci services are the most widely used in our breadth corpus.
table shows that travis ci is by far the most widely used ci service.
because of this result we feel con dent that our further analysis can focus on the projects that use travis ci as a ci service and that analyzing such projects gives representative results for usage of ci services in open source projects.
we also found that some projects use more than one ci service.
in our breadth corpus of all the projects that use ci use more than one ci.
we think this is an interesting result which deserves future attention.
rq3 do certain types of projects use ci more than others?
to better understand which projects use ci we look for characteristics of projects that are more likely to use ci.
ci usage by project popularity we want to determine whether more popular projects are more likely to use ci.
our intuition is that if ci leads to better outcomes then we would expect to see higher usage of ci among the most popular projects or alternatively that projects using ci get better and thus are more popular .
figure shows that the most popular projects as measured by the number of stars are also the most likely to use ci kendall s p .
.
we group the projects from our breadth corpus into even groups ordered by number of stars.
we then calculate the percent of projects in each group that are using ci.
each group has around projects.
in the most popular starred group of projects use ci.
as the projects become less popular the percentage of projects using ci declines to .
observation popular projects are more likely to use ci.
ci usage by language we now examine ci usage by programming language.
are there certain languages for figure ci usage of projects in github.
projects are sorted by popularity number of stars .
which the projects written primarily in such languages use ci more than others?
table shows projects sorted by the percentage of projects that use ci for each language from our breadth corpus.
the data shows that in fact there are certain languages that use ci more than others.
notice that the usage of ci does not perfectly correlate with the number of projects using that language as measured by the number of projects using a language with its rank by percentage kendall s p .
.
in other words some of the languages that use ci the most are both popular languages like ruby and emerging languages like scala.
similarly among projects that use ci less we notice both popular languages such as objective c and java as well as less popular languages such as viml.
however we did observe that many of the languages that have the highest ci usage are also dynamically typed languages e.g.
ruby php co eescript clojure python and javascript .
one possible explanation may be that in the absence of a static type system which can catch errors early on these languages use ci to provide extra safety.
observation we observe a wide range of projects that use ci.
the popularity of the language does not correlate with the probability that a project uses ci.
rq4 when did open source projects adopt ci?
we next study when projects began to adopt ci.
figure shows the number of projects using ci over time.
we answer this question with our depth corpus because the breadth corpus does not have the date of the rst build which we use to determine when ci was introduced to the project.
notice that we are collecting data from travis ci which was founded in .
figure shows that ci has experienced a steady growth over the last years.
we also analyze the age of each project when developers rst introduced ci and we found that the median time was around year.
based on this data we conjecture that while many developers introduce ci early in a project s 429table ci usage by programing language.
for each language the columns tabulate the number of projects from our corpus that predominantly use that language how many of these projects use ci the percentage of projects that use ci.
language total projects using ci percent ci scala .
ruby .
go .
php .
co eescript .
clojure .
python .
emacs lisp .
javascript .
other .
c .
swift .
java .
c .
c .
perl .
shell .
html .
css .
objective c .
viml .
development lifetime it is not always seen as something that provides a large amount of value during the very initial development of a project.
observation the median time for ci adoption is one year.
rq5 do developers plan on continuing to use ci?
is ci a passing fad in which developers will lose interest or will it be a lasting practice?
while only time will tell what the true answer is to get some sense of what the future could hold we asked developers in our survey if they plan to use ci for their next project.
we asked them how likely they were to use ci on their next project using a point likert scale ranging from de nitely will use to de nitely will not use.
figure shows that developers feel very strongly that they will be using ci for their next project.
the top two options de nitely and most likely account for of all our survey respondents and the average of all the answers was .
.
while this seems like a pretty resounding endorsement for the continued use of ci we decided to dig a little deeper.
even among respondents who are not currently using ci said that they would de nitely or most likely use ci for their next project.
observation while ci is widely used in practice nowadays we predict that in the future ci adoption rates will increase even further.
.
costs of ci to better understand the costs of ci we analyze both the survey where we asked developers why they believe ci is too costly to be worth using and the data from our depth figure number of projects using ci over time.
data is tabulated by quarter months per year.
figure answers to will you use ci for your next project?
corpus.
we estimate the cost to developers for writing and maintaining the con guration for their ci service.
speci cally we measure how often the developers make changes to their con guration les and study why they make those changes to the con guration les.
we also analyze the cost in terms of the time to run ci builds.
note that the time that the builds take to return a result could be unproductive time if the developers do not know how to proceed without knowing that result.
rq6 why do open source projects choose notto use ci?
one way to evaluate the costs of ci is to ask developers why they do notuse ci.
in our survey we asked respondents whether they chose to use or not use ci and if they indicated that they did not then we asked them to tell us why they do not use ci.
table shows the percentage of the respondents who selected particular reasons for not using ci.
as mentioned before we built the list of possible reasons by collecting information from various popular internet sources.
interestingly the primary cost that respondents identi ed was not a technical cost instead the reason for not using ci was that the developers on my project are not familiar enough with ci.
we do not know if the developers are not familiar enough with the ci tools themselves e.g.
travis ci or if they are unfamiliar with all the work it will take to add ci to their project including perhaps fully automating the build.
to completely answer this question more research is needed.
the second most selected reason was that the project does not have automated tests.
this speaks to a real cost for ci in 430table reasons developers gave for not using ci reason percent the developers on my project are not familiar enough with ci .
our project doesn t have automated tests .
our project doesn t commit often enough for ci to be worth it .
our project doesn t currently use ci but we would like to in the future .
ci systems have too high maintenance costs e.g.
time e ort etc.
.
ci takes too long to set up .
ci doesn t bring value because our project already does enough testing .
figure number of changes to ci con gs median number of changes is that much of its value comes from automated tests and some projects nd that developing good automated test suites is a substantial cost.
even in the cases where developers had automated tests some questioned the use of ci in particular and regression testing in general one respondent p74 even said in years our tests have yet to catch a single bug.
observation the main reason why open source projects choose to not use ci is that the developers are not familiar enough with ci.
rq7 how often do projects evolve their ci con guration?
we ask this question to identify how often developers evolve their ci con gurations.
is it a write once and forget it situation or is it something that evolves constantly?
the travis ci service is con gured via a yaml le named .travis.yml in the project s root directory.
yaml is a humanfriendly data serialization standard.
to determine how often a project has changed its con guration we analyzed the history of every .travis.yml le and counted how many times it has changed.
we calculate the number of changes from the commits in our depth corpus.
figure shows the number of changes commits to the .travis.yml le over the life of the project.
we observe that the median of number of changes to a project s ci con guration is times but one of the projects changed the ci con guration times.
this leads us to conclude that many projects setup ci once and then have minimal involvement of projects have or less changes to their ci con guration but some projects do nd themselves changing their ci setup quite often.
observation some projects change their con gurations relatively often so it is worthwhile to study what these changes are.table reasons for ci con g changes con g area total edits percentage build matrix .
before install .
build script .
build language con g .
build env .
before build script .
install .
whitespace .
build platform con g .
noti cations .
comments .
git con guration .
deploy targets .
after build success .
after build script .
before deploy .
after deploy .
custom scripting .
after build failure .
after install .
before install .
mysql .
after build success .
allow failures .
rq8 what are some common reasons projects evolve their ci con guration?
to better understand the changes to the ci con guration les we analyzed all the changes that were made to the .travis.yml les in our depth corpus.
because yaml is a structured language we can parse the le and determine which part of the con guration was changed.
table shows the distribution of all the changes.
the most common changes were to the build matrix which in travis speci es a combination of runtime environment and exclusions inclusions .
for example a build matrix for a project in ruby could specify the runtimes rvm .
rvm .
and jruby the build environment rails2 and rails3 and the exclusions inclusions e.g.
exclude jruby with rails2 .
all combinations will be built except those excluded so in this example there would be di erent builds.
other common changes included the dependent libraries to install before building the project what .travis.yml calls before install and changes to the build script themselves.
also many other changes were due to the version changes of dependencies.
431figure build time distribution by result in seconds observation many ci con guration changes are driven by dependency changes and could be potentially automated.
rq9 how long do ci builds take on average?
another cost of using ci is the time to build the application and run all the tests.
this cost represents both a cost of energy2for the computing power to run these builds but also developers may have to wait to see if their build passes before they merge in the changes so having longer build times means more wasted developer time.
the average build time is just under seconds.
to compute the average build times we rst remove all the canceled incomplete manually stopped build results and only consider the time for errored failed and passed completed builds .
errored builds are those that occur before the build begins e.g.
when a dependency cannot be downloaded and failed builds are those that the build is not completed succesfully e.g.
a unit test fail .
to further understand the data we look at each outcome independently.
interestingly we nd that passing builds run faster than either errored or failed builds.
the di erence between errored and failed is signi cant wilcoxon p .
as is the di erence between passed and errored wilcoxon p .
and the di erence between passed and failed wilcoxon p .
.
we nd this result surprising as our intuition is that passing builds should take longer because if an error state is encountered early on the process can abort and return earlier.
perhaps it is the case that many of the faster running pass builds are not generating a meaningful result and should not have been run.
however more investigation is needed to determine what the exact reasons for this are.
.
benefits of ci we rst summarize the most commonly touted bene ts of ci as reported by the survey participants.
we then analyze empirically whether these bene ts are quanti able in our depth corpus.
thus we con rm or refute previously held beliefs about the bene ts of ci.
2this cost should not be underestimated our personal correspondence with a google manager in charge of their ci system tap reveals that tap costs millions of dollars just for the computation not counting the cost of developers who maintain or use tap .rq10 why do open source projects choose to use ci?
having found that ci is widely used in open source projects rq1 and that ci is most widely used among the most popular projects on github rq3 we want to understand why developers choose to use ci.
however why a project uses ci cannot be determined from a code repository.
thus we answer this question using our survey data.
table shows the percentage of the respondents who selected particular reasons for using ci.
as mentioned before we build this list of reasons by collecting information from various popular internet sources.
the two most popular reasons were ci makes us less worried about breaking our builds and ci helps us catch bugs earlier .
one respondent p371 added acts like a watchdog.
you may not run tests or be careful with merges but the ci will.
martin fowler is quoted as saying continuous integration doesn t get rid of bugs but it does make them dramatically easier to nd and remove.
however in our survey very few projects felt that ci actually helped them during the debugging process.
observation projects use ci because it helps them catch bugs early and makes them less worried about breaking the build.
however ci is not widely perceived as helpful with debugging.
rq11 do projects with ci release more often?
one of the more common claims about ci is that it helps projects release more often e.g.
cloudbees motto is deliver software faster .
over of the respondents from our survey claimed it was a reason why they use ci.
we analyze our data to see if we can indeed nd evidence that would support this claim.
we found that projects that use ci do indeed release more often than either the same projects before they used ci or the projects that do not use ci.
in order to compare across projects and periods we calculated the release rate as the number of releases per month.
projects that use ci average .
releases per month while projects that do not use ci average .
releases per month.
that is more than double the release rate and the di erence is statistically signi cant wilcoxon p .
to identify the e ect of ci we also compared for projects that use ci the release rate both before and after the rst ci build.
we found that projects that eventually added ci used to release at a rate of .
releases per month well below the .
rate at which they release now with ci.
this di erence is statistically signi cant wilcoxon p .
observation projects that use ci release more than twice as often as those that do not use ci.
rq12 do projects which use ci accept more pull requests?
for a project that uses a ci service such as travis ci when the ci server builds a pull request it annotates the pull request on github with a visual cue such as a green check mark or a red x that shows whether the pull request was able to build successfully on the ci server.
our intuition is that this extra information can help developers better decide whether or not to merge a pull request into their code.
to determine if this extra information indeed makes a di erence we compared the pull request acceptance rates between pull 432table reasons for using ci as reported by survey participants reason percent ci makes us less worried about breaking our builds .
ci helps us catch bugs earlier .
ci allows running our tests in the cloud freeing up our personal machines .
ci helps us deploy more often .
ci makes integration easier .
ci runs our tests in a real world staging environment .
ci lets us spend less time debugging .
table release rate of projects uses travis versions released per month yes .
no .
table comparison of pull requests merged for pull requests that had or did not have ci information ci usage pull requests merged using ci not using ci requests that have this ci information and pull requests that do not have it from the depth corpus.
note that projects can exclude some branches from their repository to not run on the ci server so just because a project uses ci on some branch there is no guarantee that every pull request contains the ci build status information.
table shows the results for this question.
we found that pull requests without ci information were 5pp more likely to be merged than pull requests with ci information.
our intuition of this result is that those 5pp of pull requests have problems which are identi ed by the ci.
by not merging these pull requests developers can avoid breaking the build.
this di erence is statistically signi cant fisher s exact test p .
this also ts with our survey result that developers say that using ci makes them less worried about breaking the build.
one respondent p219 added that ci prevents contributors from releasing breaking builds .
by not merging in potential problem pull requests developers can avoid breaking their builds.
observation ci build status can help developers avoid breaking the build by not merging problematic pull requests into their projects.
rq13 do pull requests with ci builds get accepted faster in terms of calendar time ?
once a pull request is submitted the code is not merged until the pull request is accepted.
the sooner a pull request is accepted the sooner the code is merged into the project.
in the previous question we saw that projects using ci accept fewer i.e.
reject or ignore more pull requests than projects not using ci.
in this question we consider only accepted pull requests and ask whether there is a di erence in the time it takes for projects to accept pull requests with and without ci.
one reason developers gave for using ci is that it makes figure distribution of time to accept pull requests in hours integration easier.
one respondent p183 added to be more con dent when merging prs .
if integration is easier does it then translate into pull requests being integrated faster?
figure shows the distributions of the time to accept pull requests with and without ci.
to compute these results we select from our depth corpus all the pull requests that were accepted both with and without build information from the ci server.
the mean time with ci is hours but the median is only .
hours.
similarly the mean time without ci is hours but the median is .
hours.
comparing the median time to accept the pull requests we nd that the median pull request is merged .
hours faster than pull requests without ci information.
this di erence is statistically signi cant wilcoxon p .
observation ci build status can make integrating pull requests faster.
when using ci the median pull request is accepted .
hours sooner.
table percentage of builds that succeed by pull request target pull request target percent passed builds master .
other .
rq14 do ci builds fail less on master than on other nonmaster branches?
the most popular reason that participants gave for using ci was that it helps avoid breaking the build.
thus we analyze this claim in the depth corpus.
does the data show a di erence in the way developers use ci with the master branch vs. with the other branches?
is there any di erence between how many builds fail on master vs. on the 433other branches?
perhaps developers take more care when writing a pull request for master than for another branch.
table shows the percentage of builds that pass in pull requests to the master branch compared to all other branches.
we found that pull requests are indeed more likely to pass when they are on master.
observation ci builds on the master branch pass more often than on the other branches.
.
implications we o er practical implications of our ndings for researchers developers and tool builders.
researchers rq1 rq3 rq4 rq5 ci is not a fad but is here to stay.
because ci is widely used and more projects are adopting it and has not yet received much attention from the research community it is time for researchers to study its use and improve it e.g.
automate more tasks such as setting up ci .
we believe that researchers can contribute many improvements to the ci process once they understand the current state of the practice in ci.
rq2 similarly with how github has become the main gateway for researchers who study software we believe travis ci can become the main gateway for researchers who study ci.
travis o ers a wealth of ci data accessible via public api.
therefore researchers can maximize their impact by studying a single system.
rq7 rq8 we found evidence of frequent evolution of ci con guration les similar evolution was found for makeles so researchers can focus on providing support for safe automation of changes in con guration les e.g.
via safe refactoring tools.
rq8 we con rmed that continuously running ci takes a non trivial amount of time and resources so the testing research community should investigate methods for faster build and test similar to the ongoing e orts on tap at google tools for software engineers tse at microsoft or regression testing .
rq6 table the most common reason why developers do not use ci is unfamiliarity with ci so there is tremendous opportunity for providing educational resources.
we call upon university educators to enrich their software engineering curriculum to cover the basic concepts and tooling for ci.
developers rq3 table the data shows that ci is more widely embraced by the projects that use dynamically typed languages e.g.
of ruby projects use ci compared with only of objective c projects that use ci .
to mitigate the lack of a static type system developers that use dynamically typed languages should use ci to run tests and help catch errors early on.
rq13 our analysis of the depth corpus shows that the presence of ci makes it easier to accept contributions in open source projects and this was also indicated by sev eral survey respondents e.g.
ci gives external contributors con dence that they are not breaking the project p310 .
considering other research that reports a lack of diversity in open source projects attracting new contributors is desirable.
thus projects that aim to diversify their pool of contributors should consider using ci.
rq7 rq9 because the average times for a single ci build is fairly short and ci con gurations are maintainable it appears that the bene ts of ci outweigh the costs.
thus developers should use ci for their projects.
rq3 rq11 rq12 rq14 the use of ci correlates with positive outcomes and ci has been adopted by the most successful projects on github so developers should consider ci as a best practice and should use it as widely as possible.
tool builders rq6 ci helps catching bugs but not locating them.
the ci build logs often bury an important error message among hundreds of lines of raw output.
thus tool builders that want to improve ci can focus on new ways to integrate faultlocalization techniques into ci.
rq1 rq7 rq8 despite wide adoption there are many projects that have yet to use ci.
tool builders could parse build les and then generate con guration les necessary for ci.
by automating this process tool builders can lower the entry barrier for developers who are unfamiliar with ci.
.
threats to v alidity .
construct are we asking the right questions?
we are interested in assessing the usage of ci in open source projects.
to do this we have focused on what how and whyquestions.
we think that these questions have high potential to provide unique insight and value for di erent stakeholders developers tool builders and researchers.
.
internal is there something inherent to how we collect and analyze ci usage data that could skew the accuracy of our results?
once a ci server is con gured it will continue to run until it is turned o .
this could result in projects con guring a ci server and then not taking into account the results as they continue to do development.
however we think this is unlikely because travis ci and github have such close integration.
it would be di cult to ignore the presence of ci when there are visual cues all throughout github when a project is using ci.
some ci services are run in a way such that they cannot be detected from the information that is publicly available in the github repository.
this means that we could have missed some projects.
however this would mean that we are underestimating the extent to which ci has been adopted.
despite a .
response rate to our survey still over of our targeted population did not respond.
we had no control over who responded to our survey so it may su er from self selection bias.
we think this is likely because of our survey participants reported using ci much higher than the percentage of projects we observed using ci in the data.
in order to mitigate this we made the survey short 434and provided a ra e as incentive to participate to get the most responses as possible.
.
external are our results generalizable for general ci usage?
while we analyzed a large number of open source repositories we cannot guarantee that these results will be the same for proprietary closed source software.
in fact we consider it very likely that closed source projects would be unwilling to send their source over the internet to a ci service so our intuition is that they would be much more likely to use a local ci solution.
further work should be done to investigate the usage of ci in closed source projects.
because we focused on travis ci it could be that other ci services are used di erently.
as we showed in rq2 travis ci was the overwhelming favorite ci service to use so by focusing on that we think our results are representative.
additionally we only selected projects from github.
perhaps open source projects that have custom hosting also would be more likely to have custom ci solutions.
more work is needed to determine if these results generalize.
.
related work we group our related work into three di erent areas i ci usage ii ci technology and iii related technology .
ci usage the closest work to ours is by vasilescu et al.
who present two main ndings.
they nd that projects that use ci are more e ective at merging requests from core members and the projects that use ci nd signi cantly more bugs.
however the paper explicitly states that it is a preliminary study on only github projects and treats ci usage as simply a boolean value.
in contrast this paper examines projects builds and survey responses to provide detailed answers to research questions about ci usage costs and bene ts.
a tech report from beller et al.
performs an analysis of ci builds on github speci cally focusing on java and ruby languages.
they answer several research questions about tests including how many tests are executed per build?
how often do tests fail?
and does integration in di erent environments lead to di erent test results?
.
these questions however do not serve to comprehensively support or refute the productivity claims of ci.
two other papers have analyzed a couple of case studies of ci usage.
these are just two case studies total unlike this paper that analyzes a broad and diverse corpus.
lepp anen et al.
interviewed developers from software companies about what they perceived as the bene ts of ci.
they found one of the perceived bene ts to be more frequent releases.
one of their participants said ci reduced release time from six months to two weeks.
our results con rm that projects that use ci release twice as fast as projects that do not use ci.
beller et al.
nd that developers report testing three times more often than they actually do test.
this overreporting shows that ci is needed to ensure tests are actually run.
this con rms what one of our respondents p287 said it forces contributors to run the tests which they might not otherwise do .
kochhar et al.
found that larger java open source projects had lower test coverage rates also suggesting that ci can be bene cial.
ci technology some researchers have proposed approaches to improve ci servers by having servers communicate depen dency information generating tests during ci or selecting tests based on code churn .
also researchers have found that integrating build information from various sources can help developers.
in our survey we found that developers do not think that ci helps them locate bugs this problem has been also pointed out by others .
one of the features of ci systems is that they report the build status so that it is clear to everyone.
downs et al.
developed a hardware based system with devices shaped like rabbits which light up with di erent colors depending on the build status.
these devices keep developers informed about the status of the build.
related technology a foundational technology for ci is build systems.
some ways researchers have tried to improve their performance has been by incremental building as well as optimizing dependency retrieval .
performing actions continuously can also bring extra value so researchers have proposed several activities such as continuous test generation continuous testing continuously running regression tests in the background continuous compliance and continuous data testing .
.
conclusions ci has been rising as a big success story in automated software engineering.
in this paper we study the usage the growth and the future prospects of ci using data from three complementary sources i open source projects from github ii builds from the most commonly used ci system and iii survey respondents.
using this rich data we investigated research questions.
our results show there are good reasons for the rise of ci.
compared to projects that do not use ci projects that use ci i release twice as often ii accept pull requests faster and iii have developers who are less worried about breaking the build.
therefore it should come as no surprise that of the most popular projects on github heavily use ci.
the trends that we discover point to an expected growth of ci.
in the future ci will have an even greater in uence than it has today.
we hope that this paper provides a call to action for the research community to engage with this important eld of automated software engineering.
.