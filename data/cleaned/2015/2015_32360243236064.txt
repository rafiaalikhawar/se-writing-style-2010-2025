parameterized model countingfor stringand numeric constraints abdulbaki aydin microsoft usa abakiaydinn gmail.comwilliameiers universityofcaliforniasantabarbara usa weiers ucsb.edulucasbang universityofcaliforniasantabarbara usa bang ucsb.edu teganbrennan universityofcaliforniasantabarbara usa tegan ucsb.edumiroslav gavrilov universityofcaliforniasantabarbara usa mvg ucsb.edutevfikbultan universityofcaliforniasantabarbara usa bultan ucsb.edu fangyu national chengchi university taiwan yuf nccu.edu.tw abstract recently symbolic program analysis techniques have been extended to quantitative analyses using model counting constraint solvers.
given a constraint and a bound a model counting constraint solver computes the number of solutions for the constraint withinthebound.wepresentaparameterizedmodelcountingconstraintsolverforstringandnumericconstraints.wefirstconstruct amulti trackdeterministicfinitestateautomatonthatacceptsallsolutions to the given constraint.
we limit the numeric constraints to linear integer arithmetic and for non regular string constraints we over approximate the solution set.
counting the number of acceptingpathsinthegeneratedautomatonsolvesthemodelcounting problem.ourapproachisparameterizedinthesensethat wedonot assumeafinitedomainsizeduringautomataconstruction resulting in a potentially infinite set of solutions and our model counting approach works for arbitrarily large bounds.
we experimentally demonstrate the effectiveness of our approach on a large set of string and numeric constraints extracted from software applications.weexperimentallycompareourtooltofiveexistingmodel counting constraint solvers for string and numeric constraints and demonstratethatourtoolisasefficientandasormoreprecisethan this material is based on research supported by an amazon research award and bydarpaundertheagreementnumberfa8750 .theu.s.governmentis authorized toreproduceanddistributereprints forgovernmentalpurposesnotwithstandinganycopyrightnotationthereon.theviewsandconclusionscontainedherein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements either expressed or implied of darpa or the u.s. government.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse november 4 9 lake buenavista fl usa associationfor computing machinery.
acm isbn ... .
stringandintegervariables that noothertoolcan.
ccs concepts theory of computation logic and verification software andits engineering software verification keywords modelcounting constraint solving quantitative programanalysis acmreference format abdulbaki aydin william eiers lucas bang tegan brennan miroslav gavrilov tevfik bultan and fang yu.
.
parameterized model counting for string and numeric constraints.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november 4 9 lake buena vista fl usa.
acm new york ny usa 11pages.https introduction quantitativeprogramanalysisarisesinmanycontextssuchasprobabilistic analysis reliability analysis and quantitative informationflow .quantitativeprogramanalyses require efficientmodel countingconstraintsolverstohandlecomplex and diverse constraints generated during program analyses.
a modelcountingconstraintsolvercomputesthenumberofsolutions for agiven constraintwithin agiven bound .
inthispaper wepresentamodelcountingconstraintsolverthat can handle both numeric and string constraints and their combinations.
given a constraint we construct amulti track deterministic finiteautomaton dfa thatacceptstuplesofvaluesthatcorrespond tothesolutionsofthegivenconstraint.fornumericconstraints we focus on linear integer arithmetic constraints and the constructed automatonacceptsabinaryencodingofthenumbersthatsatisfy the given numeric constraint.
since some string constraints can havenon regularsolutionsets ourautomataconstructionapproach over approximatesthesolutionsetinsuchcases.hence ourmodel esec fse november4 lake buena vista fl usa a.aydinet al.
countingconstraintsolverprovidesasoundupper boundforthe number ofsolutions for agiven constraint.
sinceweusemulti trackdfa wecanrepresentrelationalconstraintsthatspecifyrelationshipsamongvariables.moreover our approach handles interactions between numeric and string constraintsinthepresenceofoperationssuchasstring lengthwhich can be usedtogetherwithnumeric variables inaconstraint.
automata based constraint solving reduces the model counting problemtopathcounting.tocountthenumberofvaluesthatsatisfy the given constraint withina given domainbound we count the numberofacceptingpathsintheautomatonwithinthepathlength bound that corresponds to said domain bound.
we use techniques from algebraic graph theory to solve the pathcountingproblem.
we implemented the techniques we present in this paper in a tool called multi track automata based model counter mtabc .
we experimented on a large set of constraints generated during symbolic execution of java and javascript programs and compared mt abc with five existing model counting constraint solvers .
our experiments demonstrate that mtabc is as efficient and as or more precise than existing tools.
more importantly mt abcistheonlytoolcanhandletheunionofall constraints that existing tools can handle and mt abc is the only tool that can handle mixed numeric and string constraints that contain both stringandintegervariables.
our novel contributions in this paper are an extended constraint language that is more expressive than constraint languages supportedbyothermodelcountingconstraintsolvers section2 handlingofrelationalstringconstraintsusingmulti trackautomata section handling of mixedstring and integer constraintsusing multiple automata section model counting for tuples ofvariables section4 heuristicsforconstraintsimplification section5 and6 anextensiveexperimentalevaluation section6 .
amotivatingexample.
letusgiveanexampledemonstrating the use of model counting constraint solvers for quantitative information flow analysis and how this type of analysis can be used to quantify information leakage through side channels.
this example isbasedonasecurity vulnerabilityknownas compressionratio info leak made easy crime .
many web server requests are compressed and encrypted for efficiency and security before transmission asanetworkpacket.despitethe encryption amaliciousattackerwhocanobservenetworkpacketsizescanusethe compression size to learn secret web session information.
assume an attacker can inject and concatenate his own text with the secret text prior to compression.
the smaller the resulting packet the more compressionmust have occurredprior to encryption and so theattacker controlledinputmustcontainsubstringswhichmatch substrings of the secret text.
in the crime attack encryption does not significantly change the size of the packet as many encryption protocolsaresize preserving.thus bycarefullycraftinginjected inputs an attackercan incrementally reveal the secrettext.
forinstance supposethesecretisthetext sessionkey iftheattackerisabletoinjectthetextstring sessionkey he will observe less compression than if he injects sessionkey because there is a longer prefix match between the attacker string and the secret string.
in this way the attackerisabletomakerepeatedguesses andincrementallylearn more information aboutprefixesofthe secret.consider a simple method for compressing the concatenation of twostrings.forstrings sandt wecompresstheirconcatenation s t by checking if tis a prefix of s and if so encoding their concatenation as s wherekis the length of t. iftis not a prefix ofstheyaresimplyconcatenated.thenotation s isinterpreted as a pointer which indexes into s indicating how many characters ofstoexpandinordertorecover t.forexample if sisthestring hello world!
and tis the string hello s tis encoded as hello world!
.
the following is a simple java function for performing this combinedconcatenation andcompression public string compress string s string t if s.startswith t return s else return s t this function results in an exploitable vulnerability similar to the crime attack.
suppose that sis a secret string of numeric characters and a malicious adversary has control over t. if the adversaryisabletoobservethesizeoftheresultingcompression hecan learn information about sbyvarying t. we will assume that the alphabet for sandtis the set of numericcharacters ... .by performingsymbolic executionof compress s t wecandeterminepathconstraintswhichleadto differentpossibleobservationsonthesizeoftheresult.forexample usingtheconstraintlanguagewedefineinsection2 wecansee that if length s begins s t length t then the length of the resulting string is .
one may verify that there are 005possible pairsof strings s t that satisfythis constraint.if begins s t length s length t then the resulting stringwillhavelength10 andthereare99 999possible s t which satisfythisconstraint.assumingthat sisuniformlydistributed we can compute the probability of each observation by dividing the number ofsolutions bythe total domainsize.
prior work in quantitative information flow has proposed using entropyasameasureofinformationleakage .given aprobabilitydistributionoverprogramobservables the shannon entropyof the distribution is defined as h p summationtextn i 1pilogpi.
applyingthistotheprobabilitiescomputedusingamodelcounting constraintsolver wecanquantifytheamountofinformationleaked for our example as .
bits.
note that in addition to a standard symbolic execution tool all we need in order to be able to perform thiskindofquantitativeinformationflowanalysisisamodelcounting constraint solver and for this particular example we need a modelcountingconstraintsolverthatcanhandlestringconstraints andnumeric constraintstogether.
constraintlanguage we define our constraint language using the grammar shown in fig.
where denotes a formula denotes a numeric term denotes a string term zdenotes a numeric constraint an atomic formula constructed from terms and expressions sdenotes a stringconstraint anatomicformula constructedfromtermsand expressions denotes a constant regular expression ndenotes an integerconstant and denoteconstants trueandfalse andvi andvsdenoteintegerandstringvariables respectively.weuse to denote z s or .
given alphabet s denotes a string value and denotes theemptystring.acharacterisastringthathaslengthone.the stringoperations barshort and correspondtoregularexpression 401parameterizedmodel counting esec fse november4 lake buena vista fl usa z s z s match contains begins ends vi n n length toint indexof lastindexof vs reverse tostring charat substring replacefirst replacelast replaceall s barshort figure constraint language grammar operationsconcatenation alternation andkleeneclosure respectively.
comparators and on string terms correspond to lexicographicalcomparisons.an atomicconstraint referstoaformulawithoutanybooleanconnectives.noticethatanintegerterm producedfromtheproductionrule maycontainstringterms and vice versa aconstraint producedin thisway is calleda mixed constraint .
the constraint language from fig.
1is rich enough to capturecommonconstraintsthatappearin javaandphpprograms.
formalsemantics ofthis constraintlanguageisdescribedin .
thesetofvariablespresentin isgivenbyv .amodelfor is an assignment of all variables in v where evaluates to true.
thetruthsetofaformula denoted llbracket rrbracket isthesetofallmodelsof .the goalofmodelcountingisto determinethe size of llbracket rrbracket.
constraintsolving viaautomata a multi track dfa ais a tuple q q0 f whereqis the set of states kis thek track input alphabet where is thesetofalphabetsymbolsforonetrack nelement isapaddingsymbol thatappearsonlyattheendofastringineachtrack q q is the transition relation q0 qis the initial state and f q is the set of accepting states.
multi track dfa are closed under intersection union and complement .
with each track of a we associateauniqueidentifier vi whichwerefertoasthevariable for track i. the set of track variables for ais denotedv a .
the language of all strings recognized by ais denotedl a where l a .
givena word w l a we usew to denote the value of track i. hence w l a denotes a tuple of values w w ... w one valuefor eachvariable in v a .
givenaformula ourgoalistoconstructanautomaton a such thatl a llbracket rrbracket where the tracks of acorrespond to the variables of .
we call this dfa the solution automaton for .
some mixed constraintsandsomepurestringconstraintshavenon regulartruth sets .
for such constraints we provide a sound over approximationbyconstructing an automaton asuch that llbracket rrbracket l a .
duringourconstruction inadditiontohavingonetrackforeach variableoftheformulainthemulti trackautomaton wealsocreate onetrackforeachstringterm shownas infigure andonetrack foreach numeric term shown as infigure .
actually forthe termsthatcorrespondtoaddition subtractionandmultiplication withaconstantwedonotcreateseparatetracksaswediscussin section3.
.
given a term or we uset andt to denote the tracks that thoseterms are associatedwith.
wedefineaprojectionoperation suchthat givenanautomaton aanda variableset v a v isanautomaton a wherev a algorithm1 solve a procedureoperatesonanautomaton awhichispassedbyreferenceand has atrackforeachvariableandterm in .
is one of thefollowing a conjunction of numeric andstring constraints a string constraint a numeric constraint a string term or a numeric term.
nequal match match contains contains begins begins ends ends length toint indexof lastindexof reverse tostring charat substring replacefirst replacelast replaceall if 1 2then solve a 1 solve a 2 propagate a 1 propagate a 2 else if 1 2then solve a 1 solve a 2 refine a t 1 t 2 modifiestracks t 1 andt 2 propagate a 1 propagate a 2 else if 1 .. .
n then for all i 1 .. .
n do solve a i endfor restrict a t t 1 .. .
t n modifiestrack t endif algorithm2 propagate a procedureoperatesonanautomaton awhichispassedbyreferenceand has atrackforeachvariableandterm in .
length toint indexof lastindexof reverse tostring charat substring replacefirst replacelast replaceall if 1 .. .
n then refine a t t 1 .. .
t n modifiestracks t 1 tot n for all i 1 .. .
n do propagate a i endfor else if 1 2then propagate a 1 propagate a 2 else if 1 2then a 1 a a 1 a 2 a a 2 propagate a 1 1 propagate a 2 2 endif v.letx1 ... xn v v a bethevariablesin vbutnotinv a andy1 ... ym v a vbe the variables in v a but not in v. that is we wish to add new unconstrained xitracks to aand removeyjtracksfrom a.then wedefine a v tobeamulti track dfaa withv a vsuch that w l a w l a v v a v a w w .
.
automata construction since the negation operator is non monotonic and since we sometimesover approximatethesolutionsetsofsubformulas beforethe automataconstruction weconverttheinputformulatonegation normal form bypushingnegations to atomicformulas.
wefirstdescribeourautomataconstructionalgorithmforconstraints which are conjunctions of numeric and string constraints i.e.
zand sin fig.
respectively .
we describe how we handle combinationsofconjunctions anddisjunctionslater.
let be a formula which is a conjunction of numeric and string constraints.
the automata construction procedure solve algorithm1 recursively constructs a multi track automaton asuch that when aisprojectedtothevariablesof i.e.
v itaccepts anoverapproximationof solutionsset i.e.
llbracket rrbracket l a v .
402esec fse november4 lake buena vista fl usa a.aydinet al.
procedure solvepasses the automaton aby reference so there is a single automaton athat is being modified.
before the first call tothesolveprocedure aisinitialized sothat alltracksaccept all strings i.e.
initially l a .
the procedure solveuses three other procedures during the construction of automaton a restrict refineandpropagate .
again theautomaton aispassedbyreference soalltheseprocedures modify the same automaton aduringconstruction.
theprocedure restrict isusedtocomputetheresultofastring ornumericoperator.notethat thereisatrackin aforeachterm in so the result of each string or numeric operator has a track reserved for the corresponding term.
let us denote the string or numeric operator with the symbol where 1 ... n .
then restrict a t t 1 ... t n restricts the track in athatcorrespondstotheterm 1 ... n basedonthetracksof thearguments 1 ... nina.forthistowork weneedtomake sure that the arguments tracks are processed first and this is done inthe for loopbefore restrict iscalled.
for example consider the term charat v i .restrict a t charat v i charat t v t i restricts track t charat v i in ato string values that correspond to characters that can appear at locationiofstringv wherepossiblevaluesfor vandiarespecified bythe valuesrecognizedbytracks t v andt i respectively.
the procedure refineis used toreflect theconstraint imposed by astring ornumeric predicate orits negation to its arguments.
let us denotethe string ornumeric predicate with the symbol where 1 2and 1and 2are string or numeric terms.
then refine a t 1 t 2 reflects the constraint imposed by the predicate 1 2to the tracks t 1 andt 2 .
beforerefineis calledarguments ofthe predicate are processed.
for example for the equality predicate charat v i a refine a t charat v i t a restricts the set of values for trackt charat v i to the string a .
note that since a is a constant wedonotactuallyneedatrackforit butforsimplicity of presentation let us assume that constants are also assigned a track which accept just the value that corresponds to the constant.
afterrefineis called the set of strings recognized by the arguments tracks may have changed and must be propagated to the other tracks as arguments can be terms constructed from other arguments .thisisdoneusingthe propagate procedure.forexample once we refine the set of values for track charat v i based on the predicate charat v i a we have to propagate this change totheargumentsoftheoperator charatandrefinethevaluesfor t v andt i .we callpropagate a charat v i to do this.
in general we use the propagate procedure when the result of a string or numeric operator is refined due to a string or numeric predicate and this refinement has to be propagated to the argumentsoftheoperator.asshowninalgorithm propagate a 1 ... n firstcallsrefine a t t 1 ...t n which refines the tracks for the arguments of the operator based on the trackforthe term.afterthisrefinement itrecursivelycallsthe procedure propagate ontheargumentsofthe termtofurther propagatethe refinement.
as shown in algorithm we extend the solveprocedure to combinationsofconjunctionsanddisjunctions.forconjunctions we use a single automaton.
after a conjunction is solved it isalgorithm3 solve a procedureoperates on an automaton awhichis passed by reference.
disjunctions createaseparate automaton foreachdisjunct.
conjunctionsuse asingle automaton forallconjuncts.
if 1 2then solve a 1 1 solve a 2 2 a a 1 a 2 union computed using automataproduct else if 1 2then solve a 1 solve a 2 propagate a 1 propagate a 2 solve a 1 solve a 2 endif i j 2b a baa bv figure automataconstructed forexample necessarytopropagatetheresulttothechildrenoftheconjunction.
after propagation the conjunction is solved again so that the final automatoncaptures allthe refinements.
fordisjunctions eachdisjuncthasitsownautomaton.then the automatonforthedisjunctioncorrespondstotheautomatonthat accepts the union of sets accepted by each disjunct automaton.
we compute the union automatonusing automataproduct.
letusconsiderthe following example constraint charat v i a i j we show the resulting automata in figure .
note that to make the example more readable we split the automaton to two one for string variables and one for integer variables.
in fact in our implementation we also split the automata to multiple automata basedonthedependenciesamongvariables whichwediscusslater withotherheuristics.
.
string constraintsolving wenowdiscusshowalgorithm 1handlesatomicconstraints 1 2 when is a sterm is a string predicate and 1and 2 are string terms .
in particular we will focus on the restrict andrefineproceduresonstring termsandstringpredicates and discussarepresentativesubsetofstringtermsandstringpredicates.
let us use the notation introduced in figure 1where denotes integerterms denotesstringterms and denotesregularexpression terms.
given an automaton a function t represents the possiblevaluesoftheterm thatisencodedasatrackinthegiven automaton.
let t represent the result of a restrict orrefine procedure call on the corresponding track.
the prefixes function computes the set of prefixes for a given set of strings and thesuffixes function computes the set of suffixes for a given set of strings.
both functions can be implemented using projection determinization and minimization operations on dfas.
letusconsidertheoperations length indexof substring charat and stringconcatenation operations.
restrict a t length length t t length i s t i s i t length 403parameterizedmodel counting esec fse november4 lake buena vista fl usa restrict a t indexof 1 2 indexof t 1 t 2 t indexof 1 2 i s prefixes t 1 u t 2 v suv t 1 s1 suffixes prefixes s s1 u i s i t indexof 1 2 restrict a t substring 1 2 substring t t 1 t 1 t substring 1 2 s t t t1 prefixes t t2 t t1t2 t1 t 1 v prefixes t2 v t 2 s v s t substring 1 2 restrict a t 1 2 1 2 t 1 2 s s1 t 1 s2 t 2 s s1s2 s t 1 2 notethat charatoperationcanberewrittenas substring wherethelastparameteristhelengthofthesubstring hencethe restrict andrefineforcharatcanbecomputedusingcorrespondingoperations for substring .
let us now discuss the refineprocedure.
consider the string predicates match andcontains.
predicate operations create a booleanrelationbetweentheinputtracks.wedefinetherelation withtuples ofstrings that correspondto valuesfrom inputtracks.
refine a t 1 t 2 s t s t 1 t t 2 s t wecanimplementthesemanticsoftheequalitypredicateusingthe multi trackdfasprecisely.procedure propagate mustbecalled when tracks represent terms that include stringterm operations.
refine a match t t s s t s t notethat matchoperationtakesaconstantregularexpressionas an argument.
we do not need to create a relation between a string termandaconstantregularexpressionconstant.hence weonly refine the stringterm inthe matchpredicate.
refine a contains t 1 t 2 s t s t 1 t t 2 s t 2 t suffixes prefixes t 1 here semanticsofthe contains operationdoesnotenforcetherelation between the input tracks values.
in other words if one of the tracks is updated by another operation we need to propagate that update back to the contains operation.
the propagate procedure callsafterconjunctionsmakesurethatrefinementforthe contains operation isexecutedagainoncethere isan update.
next wedefinethe refinesemanticsforthestringtermoperations.letusconsidertheoperations length indexof substring charat and again.
refine a t length length t t s t t length s t s t refine a t indexof 1 2 indexof t 1 t 2 t 1 s t u v t t indexof 1 2 u t 2 s tuv s t 1 t 2 s t v t t indexof 1 2 tsv t 1 s t 2 refine a t substring 1 2 substring t t 1 t 1 t s t u v t substring 1 2 t t 1 v t 2 s tvu s t t 1 i t u s t v t substring 1 2 v t 2 s tvu i t i t 1 t 2 i t u s t v t substring 1 2 t t 1 s tvu i v i t 2 i j figure automatonbuilt forthe constraint 1 i j refine a t 1 2 t 1 t 2 t 1 s t t 1 2 v t 2 t sv s t 1 t 2 s t t 1 2 v t 1 t vs s t 2 the algorithms for the restrict andrefineprocedures are basedonpre andpost imagecomputationinstringanalysissimilar to the ones usedin .
let us consider the string constraint example charat v i a again.
initially t v andt i are unconstrained.
based on the semantics restrict a t charat v i computes the set fort charat v i as .
next the refine a a refines t charat v i as a .notethat wearenotablekeeptherelation betweencharat v i v andionce they are computed.
as equality predicate updates the t charat v i we need to propagate the resultbackto vandi.inthefinalstep refine a a charat is called to refine vandi.
the final refinement sets the t v as a andt i as i i .
.
integerconstraintsolving wenowfocusoutattentiontothebranchofalgorithm 1for 1 2 when is a zterm is an integer term comparison operator and 1and 2arelinearcombinationsof atomicinteger terms.anysuchintegertermconstraintcanberewrittenbymoving alltermstoonesideof anddecomposingitintoasemantically equivalentconjunctionofconstraintsinwhich is .thus without loss of generality we focus on integer term constraints of the form z n summationdisplay i 1ci i wherecidenotesanintegerconstantcoefficientand iisanatomic integerterm.
algorithm 1iswritteninawaythatitwouldprocesseachbinary term separately.
however in the case of integer constraints of the form in expression we construct a dfa for all terms of z at once.
that is when we call refine a t 1 ... t n we useanautomatonconstructionthatupdatesall itrackssimultaneously.thisautomataconstructionmethodisbasedonalgorithms that construct a binary adder state machine .
given zas in expression we use those algorithms to directly construct a multitrackautomaton aoverthebinaryalphabet suchthateach track corresponds a i andl a is the set of tuples of satisfying assignments for 1 ... n encoded as binary integers in s complementform reads from leastto mostsignificant bit.
forinstance considertheconstraint i jforintegervariables iandj.thebinarydfaforthisconstraintisdepictedinfigure .
onepossibleacceptingsequenceofstatesis0 .bytaking theright handconcatenation asthedfareadsleastsignificantbits first ofthepairsofbitsalongthecorrespondingtransitions weget 404esec fse november4 lake buena vista fl usa a.aydinet al.
in binary which is in decimal.
the dfa captures allpossibleintegersolutionsinthisway withleading1 sindicating negative numbers inthe standard2 s complementencoding.
.
binaryandunaryencodings astringtermcanhaveintegersub termsandaintegertermscan containstringsub terms.as describedintheearlier discussionof algorithm wecallpropagate refine andrestrict toupdate therelationshipbetweenthestringandintegervariables.however ourbinaryintegerarithmeticrepresentationisnotdirectlycompatible withautomatonoperations over standardstringautomata.
as just described we can precisely solve multi variable linear integer arithmetic constraints by constructing a multi track binary integer automaton that recognizes tuples of solutions.
however integervariablesolutionscanberelatedtostringvariablesthrough operations that have both string and integer parameters such as lengthorindexof.
given the dfa representing the solutions for integervariables wemustpropagatetheconstraintsimposedby the integer solutions to each related string variable.
we do so by first converting the binary dfa solution representation afor an integervariable ito asetcomprehensionrepresentation s. our conversion from binary integer dfa ato a set comprehensionsuses algorithms from which show how to construct a description of a semilinear set from a binary dfa whichwenowdescribeatahighlevel.alinearset liisgivenby a0 a1k1 ...ankn kj z wherethe ajconstantintegers are calledthe periodsofthelinearset.asemilinearset sisafiniteunion of linear sets s ili.
for any binary integer dfa aconstructed fromlinearintegerarithmeticconstraints theacceptedintegersfor eachtrackofaformasemilinearset.furthermore foranytrack which corresponds toan integerterm we canrecover asetcomprehension for the semilinear set sthat it represents .
intuitively this works by examining the periods of the loops in the strongly connected components of the binary dfa inorder to find the periods for a linear set li l a .
a dfa representing the setliis then subtracted from ausing dfa complement and intersection andwe iterate this procedure until l a .
oncewehave s forasingletrackofthebinarydfa a which correspondstoasingleintegerterms wethenconvert sintoaunary dfaa whichforanyinteger m sacceptsallstringsoflength m. theunarydfa a isthencompatiblewithstringautomataandcan beusedtorestrictorrefinethesetofstringmodels.forexample if s 5k1 4k2 the corresponding unary dfa is shown below which has an initial segment of length and two interleaved loops ofperiods4and5.
0123456 we described how to propagate solutions from binary integer dfa to string dfa.
in order to propagate solutions from string dfa to binary integer dfa we reverse this process by converting astringdfaintoaunarylengthdfa extractingthesemilinearset andconstructing the corresponding binary integerdfa.
considerthe following example constraint i j length v i vl i j a b a bv figure final automataconstructed forexample example 3isaconjunctionofanatomicintegerconstraints 1 i jand 2 length v i. the constraint 2is also a mixed constraintas itcontains both astringandan integervariable.
figure4shows the final automata constructed for the input formula i j length v i. the auxiliary variable vl representsbitwiseencodingsofthelengthsofthestringsthatare representedwiththe variable v. model counting inthissection wedescribehowtoperformparameterizedmodel countingbymakinguseoftheautomataconstructedbyourconstraintsolvingprocedure.the modelcountingproblem istodeterminethesizeof llbracket rrbracket whichwedenote llbracket rrbracket.whileaformulacan haveinfinitelymanymodels wecancountthenumberofmodels inaninfinitespaceofsolutionsrestrictedtoafiniterangeforthe freevariables.hence weperform parameterizedmodelcounting for stringandintegerconstraints where llbracket rrbracket bs bz isafunctionover parameters bs whichboundsthelengthofstringsolutions and bz whichbounds the bit lengthrepresentation of integersolutions.
theconstraintsolvingprocedureproducesafinaldfa a that contains multi track solution sub automata asandaz.
the separation of string and integer automata may lose some relational information between string and integer variables we can multiply themodelcountsforeachautomatoninordertogiveasoundupper bound on the number of models for tuples of integer and string variables.
we use functions fas k and faz k to count string andintegermodels respectively.
we rely on the observation that counting the number of strings oflength kinaregularlanguage l isequivalentto countingthe numberofacceptingpathsoflength kinthedfathataccepts l. thatis byusingadfarepresentation wereducetheparameterized modelcountingproblemtocountingthenumberofpathsofagiven length in a graph.
in a dfa there is exactly one accepting path for every recognized string.
thus if we are interested in computing only string models or only integer models there is no loss of precisionduetothethemodelcountingprocedure anylossofprecision for strings comes from the over approximations of non regular constraintsinthesolvingphase andforpureintegerconstraints themodelcountingprocedureisprecisebecauseintegersolution automataconstruction isprecise.
given a string automaton as computation of fas k the number of accepted strings of length k can be done by constructing the transfer matrix of the automaton based on its transition relation .letasbeadfawith nstates.thetransfermatrix tof ais a matrix where ti jis the number of transitions from state ito statej.thenumberofpathsoflength kthatstartinstate iandend in statejis given by tk i j. then the number of strings of length kaccepted by acan be computed using matrixmultiplication.
we compute utkv whereuis the row vector such that ui if and 405parameterizedmodel counting esec fse november4 lake buena vista fl usa i nequalj nequal i j vs1.vs2 vs1 vs2 .
.
match t t 1.t 2.v contains 2.
1.
3 1 nequal 1.t nequal 2.v begins 1.
2 1 t v t. 1 v. 2 ends 2.
1 1 t nequalv t. 1 nequalv.
2 t. 1 t. 2 1 2 t1.t2 t1t2 1.t 2.t 1 2 figure term reductionrules onlyifiisthestartstateand0otherwise and visthecolumnvector wherevi 1ifandonlyif iisanacceptingstateand0otherwise.
notethatforrelationalstringconstraints thetransitionalphabetis over tuples of characters and the method described here will count thenumberoftuplesofsolutionsofagivenlength.ourcounting method is parameterized in thefollowing sense after a constraint is solved we can count the number of solutions of any desired size kbycomputing utkv withoutre solving the constraint.
themethoddescribedabovecomputes fas k thenumberof string solutions of length exactlyk.
it is of interest to compute fas k the number of solutions withina given bound.
this is accomplishedeasilyusingaknown trick oftenusedtosimplify graphalgorithms.weaddanartificialacceptingstate sn 1toas resulting in a new dfa a s with transitions from each accepting statetosn anda cycleonsn .thenonecanseethat fas k fa s k andsowe apply the transfer matrixmethodon a s. themethodforcountingstringsofagivenlengthallowsusto performmodelcountingforlinearconstraintsaswell.however we mustinterpretthebound kinaslightlydifferentmanner.asolution dfaazfor a set of integer tuples encodes the solutions as bitstrings.thus pathsoflength kinanintegerautomatoncorrespond to bit string of length k. since we are using a s complement representationwithleadingsignbits bitstringsofexactlylength k correspondtointegersintherange 2k 2k .thus thetransfer matrixmethodallowsustoperformmodelcountingoverinteger domains parameterized by intervals of this form by computing faz k .tocountmodelsforarbitraryintervals a b weintersect azwiththedfarepresenting a xi bforanyvariable xi and then count pathsinthe resultingdfa.
the methods described above allow us to compute fas k and faz k independently.
now we can compute bs bz fas bs faz bz .
constraintsimplification weuseseveralheuristicstosimplifytheconstraintsbeforeautomataconstruction andmodelcountingsteps.
termre writerules alltermsarefirstreducedwithrespect to a re write system based on a set of rules .
these rules includebothtermnormalizationrulesandtautologicalsimplifications of atomic constraints.
here i jare distinct integer constants t varedistinctstringconstantsand 1 2 3are notnecessarily distinct stringterms.
dependencyanalysis toreducetheamountofworkrequired tosolveaconstraint wenotethatnotallvariablesofaconstraint 1.begins 2 1 2 1.contains 2 1 2 1.ends 2 1 2 .ends t nequalt .contains t .begins t 1.
2 3.
4 1 2 3 4 1.
2 3 1 2 3 3.begins 1 figure implicationrules needbecountedtogether.wedefinethe constraintgraph ofaformula tobethegraphdefinedonthesetofvariablesof where an edge exists between any two variables if they appear in the same clauseof .thisconstraintgraph canbe decomposedintoa finitesetofconnectedcomponents.aconnectedcomponent cis amaximalsubgraphsuchthatif u v cthenthereexistsapath betweenuandvinc.
constraints on any given variable depend only on variableswithin its connected component.
this allows us todecomposeaformulabasedonconnectedcomponents solveand counteachcomponentindividually andthentaketheproductof the results to obtain accurate counts for tuples of variables.
this results insmallerautomataandfaster computation.
equivalence classes when no disjunctions are present the variablesof a formula can be partitionedinto equivalence classes so that any pair of given variables x yare in the same equivalence classonlyiftheyhavethesamesolutionset.inourimplementation weconstructtheseequivalenceclassesbasedonequalityclauses.
every term variable or otherwise begins in its own equivalence classandforeveryequalityclause theequivalenceclassesofthe left and right sides are merged.
from each equivalence class a representative is chosen.
each variableinthe equivalence classis then replaced by this representative in the formula .
this optimization canresultin the eliminationof variablesfrom andhencetracks from its dfa withoutany lossof precision incounting.
term elimination via substitution constraints generated fromsymbolicexecutioninthepresenceofloopsresultintheaddition of many intermediate variables and terms usually due by loopunrolling.theseintermediatetermsformacontinuouslink betweenthestate ofvariablesbeforeand after theloop body represented as conjunctions between word equations.
if the variables donotappearelsewhereintheconstraintformula wecollapsethis chain intoasinglewordequality.
implication rules as noted previously our automata constructionforsomeconstraintscanbeimprecise.precisioncanbe improved for some of these constraints by augmenting the original formula withclausesimpliedby .wepresentasetofimplication ruleswhichdefine theaugmentingclausesaddedto inthepresenceofcertainimpreciseconstraintsinfig.
.weonlyaddaclause to ifwecansolveitpreciselyandifitcanpotentiallyimprovethe precisionforanotherconstraint.implicationsonstringvariables appearing in multiple word equations under the same conjunction are combinedintoasingleimplicationwhenever possible.
implementation and experiments we implemented the techniques we presented in this paper in a tool called multi track automata based model counter mtabc 1by extending an existing tool called automata based model counter abc .weevaluatedtheprecisionandperformanceofmtabcusingthreetypesofconstraints constraintssolelyonstring 1available at 406esec fse november4 lake buena vista fl usa a.aydinet al.
variables constraintssolelyonintegervariables andconstraints that contain both stringandintegervariables.
we experimentally compared mt abc with five existing model countingconstraintsolvers abc asingle trackautomatabasedmodelcounterforstrings s3 amodelcounterfor strings with some capability of handling relations between strings and integers smc a string model counter latte amodelcounterforlineararithmeticconstraints and smtapproxmc an approximate model counter for the theory of fixed widthwords.
our experiments show mt abc is as or more precise with comparableefficiencythanexistingstringmodelcounters.
multitrack automata enables mt abc to capture relations between variables more precisely than single track automata used in abc.
parameterizedmodelcountingenablesmt abctocomputemultiple length bounds for the same formula efficiently without resolving.
mt abc and s3 are the only tools that support mixed constraintswithstringandintegervariables.mt abcisasormore precisethans3 formodelcountingconstraintsinvolvingrelations between string and integer variables mt abc can handle a richer setofconstraintsthans3 ands3 produces unsoundresults.
allexperiments otherthanthoseinvolvings3 weredoneon anubuntu16.04machinewithinteli53.5ghzx4processorsand 32gb ofmemory.
we were unableto run s3 onubuntu .
all experiments involving s3 were done on the same machine but within an ubuntu14.
virtual machine with8gb ofmemory.
.
string constraints security benchmark constraints in this benchmark are taken fromvarioussecuritycontexts .forexample twoconstraints extracted from string manipulation utilities within the busyboxy v. .
.1package wcandgrep andoneconstraintextractedfroma utilityinthecoreutilsv.
.21package csplit areusedtoquantify information leakage for homomorphically encryptedinputs.
table1shows the results of mt abc abc s3 smc for the security benchmark.
second column shows the string length value usedformodelcounting i.e.
thetoolscountthenumberofsolution strings with the specified length last column indicates scale for largerlengths.bothmt abcandabcreportanupperboundon the numberof solutions while both smc and s3 give both lower andupperbounds s3 reportsanexactcountwhentheboundsare the same .
both mt abc and s3 generate bounds which are as or moreprecisethanthosereportedbysmc.inallcases mt abcisas ormoreprecisethanabc.theboundsgeneratedbybothmt abc ands3 agreeforallconstraintsexceptghttpdandghttpd wo len whereghttpd wo lenisderivedfromghttpdbyremovingthepart of the constraint that uses the string length function.
for solution stringsoflength620 thetwosolversgivedifferentcounts.wecould notconfirmthemodelcountfortheseconstraintsastheyaretoo complextomanuallycount.however whileexperimentingwith variations of these constraints we found out that s3 computes an erroneous count for a simplified version of these constraints.
so we believe that the count that s3 reports iserroneous.
therunningtimesforallfourmodelcountersarecomparable forsmallconstraints obscure strstr regex contains .forlargeconstraints ghttpd wc csplit nullhttpd abceithertimesoutafter20 minutes or runs out of memory while both mt abc and s3 produceresultsfasterthansmc.whentheinputconstraintcontains a high concrete value for the string length ghttpd wc grep mt abc generates a large automaton which leads to a higher running time whereas without the length constraint ghttpd wo len both mt abc andabc produce results quickly.
simplifiedkaluzabenchmark simplifiedkaluzabenchmark isasetofsatisfiableconstraintsgeneratedviasymbolicexecutionof javascript and originally solvedwith the kaluza string solver .
the authors of smc simplified the kaluza benchmark by replacing integer variables with constants and by removing disjunctions since smc cannothandle integervariables andloses precision for disjunctiveconstraints.then theytranslatedtheseconstraintsinto theirinputformatandseparatedthemintotwosets smcsmalland smcbig.wetranslatedthemfromsmcformattomt abcinput format.
the smcsmall set contains constraints and smcbig contains1342constraints.eachconstraintcontainsaqueryvariable tomodelcounton.wecomparedtheperformanceandupperbounds producedbymt abc abc andsmc using this benchmark.
table2compares mt abc to abc and mt abc to smc for solution strings less than or equal to .
we did not include s3 in this comparison since s3 can only model count solution strings havinglength exactly equal to the given given length.
for smcsmall constraints abc takes .0036s per constraint smc takes .42s per constraint and mt abc takes .011s per constraint on average.
for smcbig constraints abc takes .09s per constraint smctakes4.08sperconstraint andmt abctakes1.35s per constraint on average.
for smcsmall constraints mt abc generates a more precise count than abc for of the constraints and mt abc generates a more precise count than smc for .
oftheconstraints.forsmcbigconstraints mt abcgeneratesa moreprecisecountthanabcfor78 oftheconstraints andmtabc generates a more precise count than smc for .
of the constraints.
mt abc reported a higher count than smc for one constraint we manually determined mt abc reports the exact countinthiscaseandconcludedthatthecountreportedbysmcis erroneous.insummary forsmallconstraintstheperformanceof allthreesolversarecomparable butforbigconstraints mt abc is more efficient than abc and smc and produces more precise countsthanabcandsmcformorethan75 ofthebigconstraints.
.
integerconstraints comparison with latte we compare the performance of mtabcwithlatteformodelcountinglineararithmeticconstraintson benchmarkscontainingconstraintsgeneratedduringreliability and side channel analyses of java programs using the symbolic executiontoolspf .weextendedthereliabilitybenchmarkby addingmergesort quicksort andbinarysearchfunctions.password lawdb and crime come from side channelanalysis .
password lawdb andbinaryhave and13constraints respectively the othersrange from 2000constraintseach.
some of the constraints e.g.
the constraints coming from the sorting functions require a data structure with a certain size in orderto enablesymbolic execution.
we fixedthe size of such structuresto6.wecountedsolutionstothepathconstraintsgivenbitlengths and .
mt abc and latte return identical counts 407parameterizedmodel counting esec fse november4 lake buena vista fl usa table experiments with mt abc abc s3 andsmcon securitybenchmark.unsound results are highlighted.
program lensmc abc mt abc s3 lower upperbound time upper bound time upper bound time exact count time countscale ghttpd620 .
1031904473 .
.
.
.
.
.
.
ghttpd wo len620 .
.
.
.
.
.
.
.
.
nullhttpd .
.
.
csplit .
.
.
grep .
.
.
.
.
wc .
.
.
.
.
obscure1 .
.
.
.
.
.
.
obscure2 .
.
.
.
.
.
.
strstr1 .
.
.
.
strstr2 .
.
.
.
regex .
.
.
.
contains .
.
.
.
table2 abc uabc mt abc umt abc andsmc usmc upperbounds comparison.
benchmark constraints umt abc usmcumt abc usmcumt abc usmc smcsmall .
.
.
smcbig .
.
.
umt abc uabcumt abc uabcumt abc uabc smcsmall .
smcbig .
table mt abc and latte average time seconds per numeric constraint for different bit lengths.
the last two columnsdenotethecombinationofalllengths columnsfor lengths4 16omittedforspace .foreachbit length theexecution timeofthefaster toolisinbold.
bit length bit length bit length 32benchmarkmt abc latte mt abc latte mt abc latte lawdb .
.
.
.
.
.
heap .
.
.
.
.
.
booking .
.
.
.
.
.
bubble .
.
.
.
.
.
binary .
.
.
.
.
.
daisychain .
.
.
.
.
.
selection .
.
.
.
.
.
crime .
.
.
.
.
.
merge .
.
.
.
.
.
flap .
.
.
.
.
.
quick .
.
.
.
.
.
insertion .
.
.
.
.
.
robotgame .
.
.
.
.
.
alarmclock .
.
.
.
.
.
password .
.
.
.
.
.
forallconstraintsasbothmodelcountersarepreciseincounting lineararithmeticconstraints.wefocusonthetimingcomparison between mt abc and latte.
as a side note the latte input format does not support disequalities and thus needs a preprocessing step whensuchconstraintsarise.thelatteintegrationwithspfuses omega we refer the reader to for integration details.
figure3shows that in general mt abc performs better than latte though there are exceptions such as lawdb binary .
note that mt abc always outperforms lattewhen counting multiple bit lengths.
since mt abc is a parameterized model counter it first solves a constraint without constraints on bit length and thentable4 mt abcandsmtapproxmcaveragetime seconds per numeric constraint for different bit lengths.
for each bit length theexecution timeofthe faster toolis inbold.
bit length bit length 3benchmarkmt abc smtapproxmc mt abc smtapproxmc bubble .
.
.
.
booking .
.
.
.
selection .
.
.
.
password .
.
.
.
merge .
.
.
.
flapcontroller .
.
.
.
binary .
.
.
.
insertion .
.
.
.
heap .
.
.
.
quick .
.
.
.
alarm .
.
.
.
reusesthegeneratedautomatontocountformultiplebit lengths.
in contrast latte needstobecalledseparately foreachbit length.
comparison with smtapproxmc we compare the performanceofmt abcwithsmtapproxmcusingthesameprogram analysisbenchmarksweusedincomparisonofmt abcwithlatte.
since smtapproxmctargetsthe theoryof fixed widthwords we translated each benchmark into the smt2 bitvector format that smtapproxmc is able to handle.
we ran both mt abc and smtapproxmcusingbit lengthsof2and3sincesmtapproxmcdoes notscaletolargerbit lengths.assomeofthebenchmarkscontains constants which require more than or bits to be represented in bitvector format we omit them from our comparison.
table showstheexecutiontimeofbothtools.forbothbit lengthsandall benchmarks mt abcissignificantlyfasterthansmtapproxmc.
mt abc produces an exact count in every case while smtapproxmcreportsanapproximatecountwhichvariesinprecision.
theaveragedifferenceinmodelcountaspercentageofthedomain size between the two tools is .
and .
for bit lengths of and respectively with a maximum difference of .
and .
for bit lengths of and for the flapcontroller.
for every constraint in these benchmarks mt abc significantly outperforms smtapproxmc whileproducing as ormore precise counts.
.
mixed string andintegerconstraints for our final tool comparison we use the unmodified smt2 kaluza benchmark usedin whichrequiresconstraintsolverstoreason 408esec fse november4 lake buena vista fl usa a.aydinet al.
aboutconstraintsovermixedstringandintegervariables.in thisbenchmarkwasusedbytheauthorstodemonstratethats3 canhandlemixedstringandintegerconstraints.however forthese constraints no model counting was performed only a satisfiability check was done in .
when we used s3 to model count by givingastringlength wefoundoutthats3 reportederroneous results for manyconstraints.
we focused on a subset of the smt2 kaluza benchmark.
we compared mt abc and s3 on of the smaller constraints withinthebenchmark givenaqueryvariableandastringlength boundof50 solutionsforthequeryvariablemusthaveanexact length of 50characters .
mt abc and s3 agree on of theconstraints.ineachofthesecases s3 wasabletogiveanexact count matchingtheupperboundgivenbymt abc.intheother constraints s3 reportedbothalowerandupperbound neither ofwhichmatchedthe upper bound reportedbymt abc.
for the constraints where mt abc and s3 produce different counts the lowerbound reportedbys3 wasbetween models while the upper bound seemed entirely random fluctuating either beloworabovethecountreportedbymt abc.inthesmt2kaluza benchmark therearemanysetsofconstraintswhichareessentially equivalent to each other some differing only in variable naming.
we manually confirmed the upper bound returned by mt abc for manyoftheconstraintswastheexactcount whiletheupperbound reportedbys3 betweenidenticalconstraintsvariedwildly with manyofthembeingunsound.additionally wefoundthats3 gives different results for identical files with different names.
consider a constraint from the smt2 kaluza benchmark length s i where sisanstringvariable ianintegervariable.wecreatedthreefiles eachcontainingthissingleconstraint differingonlyinname.for queryvariable sandquerylength5 thenumberofmodelsis2565 or .
while mt abc gives the exact count for all three files s3 reports three differentupper bounds all unsound .
.
.
.weobservedsimilarbehaviorfrom s3 given differentconstraintsfrom the kaluzadataset.
we reached out to the developer of s3 for a possible explanation.oneissueisthattheyassumedthatconstraintsfrom thekaluzadatasetcouldbetransformedintotheirsolvedform but theydidnot verifythis northesoundness oftheirresultsfor this datasetin .thus itispossiblethateitherthekaluzaconstraints cannot all be transformed into solved form or s3 has a faulty implementation.
additionally the authors of s3 were unable to explainwhytheirtoolwasproducingnon deterministicunsound upper bounds when the input constraint cannot be transformed intotheirsolvedform.ourexperimentssuggestthatthetechniques presentedin andtheirimplementationins3 arenotableto handle mixed numeric and string constraints withboth string and integer variables.
hence to the best of our knowledge mt abc istheonlymodelcountingconstraintsolverthatcanhandlethis class ofconstraints.
related work there has been significant amount of work on string constraint solvinginrecentyears however none of these solvers provide model counting functionality.
meanwhile due to the importance of model counting for quantitativeprogramanalyses modelcountingconstraintsolversaregaining increasing attention.
smc and s3 are model counting constraints solversforstringconstraints .ourmodelcountingapproach ismorepreciseandmoreexpressivethansmcsincesmccannot propagate string values across logical connectives and cannot handlecomplexstringoperationssuchas replace.s3 handlesstring constraintsinvolvinglengthconstraints butsuffersasevereloss in precision when length constraints include symbolic integers.
although the expressiveness of s3 is comparable to that of mtabcforstringconstraints unlikemt abc s3 cannothandlepure numeric constraints and it produces unsound results for mixed constraints.
latte is a model counting constraint solver for linear integer arithmetic.latteusesthepolynomial timebarvinokalgorithm forintegerlatticepointenumeration.lattecannothandlestring constraints soour approach ismore expressive thanlatte.
automata based constraint solving and model counting techniques we use in this paper are not domain specific like the approaches used in latte smc and s3 but general in the sense that they can handle any setof constraints that can be mapped to automata.
as we present in this paper it is possible to map both numericandstringconstraintsandtheircombinationstoautomata.
whilelinearalgebraicmethodsforcountingpathsinagraphare well established this paper is the first to implement those methods for the purpose of parameterized model counting for relational string and integer constraints.
there has been earlier work on integer constraint model counting by counting paths in numeric dfa but this earlier approach can only count models when there are finitely many models.
we built mt abc by extending an existingtoolcalledautomatabasedmodelcounter abc .abc uses a single track automata representation.
abc cannot model countrelationalconstraintsandnumericconstraintsasprecisely as mt abc and it cannot handle constraints with integer variables.
abc has been integrated with symbolic pathfinder spf andappliedto side channel analysisin .
smtapproxmc is a model counting constraint solver for thetheoryoffixed widthwords anditusesadifferentapproach formodel countingbasedonsolutionsampling .sincesmtapproxmc cannot handle string constraints we compared smtapproxmcwithmt abconasetofnumericconstraints.mt abc producesprecisecounts forlineararithmeticconstraintswhereas smtapproxmccanonlyproduce approximations andour experimentsdemonstratethat mt abc issignificantly faster.
conclusion model countingis a crucial problem in quantitative program analysis.using automata asa representation for allsolutions ofa given constraintreducesthemodelcountingproblemtopathcounting.in this paper we show that using automata based constraint solving onecanconstructamodelcountingconstraintsolverthatisable tohandlebothstringandnumericconstraintsandtheircombinations.ourexperimentsonalargesetofconstraintsgeneratedfrom java and javascript programs indicate that automata based model counting approach is as efficient and as precise as domain specific modelcountingmethods whileitisabletohandlearichersetof constraintsthanany othermodelcountingconstraintsolver.
409parameterizedmodel counting esec fse november4 lake buena vista fl usa