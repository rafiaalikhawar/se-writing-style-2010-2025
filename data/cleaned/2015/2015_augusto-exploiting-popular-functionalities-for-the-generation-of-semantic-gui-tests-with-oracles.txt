augusto exploiting popular functionalities for the generation of semantic gui tests with oracles leonardo mariani university of milano bicocca mariani disco.itmauro pezz university of milano bicocca usi universit della svizzera italiana mauro.pezze usi.chdaniele zuddas usi universit della svizzera italiana daniele.zuddas usi.ch abstract testingsoftwareapplicationsbyinteractingwiththeirgraphical user interface gui is an expensive and complex process.
current automatictestcasegeneration techniques implementexplorative approachesthat althoughproducingusefultestcases havealimited capability of covering semantically relevant interactions thus frequently missingimportant testing scenarios.
thesetechniques typicallyinteractwiththeavailablewidgetsfollowingthestructure ofthegui withoutanyguessaboutthefunctionsthatareexecuted.
inthispaperweproposeaugusto atestcasegenerationtechniquethatexploitsabuilt inknowledgeofthesemanticsassociated with popular and well known functionalities such as crud operations toautomaticallygenerateeffectivetestcaseswithautomated functionaloracles.empiricalresultsindicatethataugustocanreveal faults that cannot be revealed with state of the art techniques.
ccs concepts software and its engineering software testing and debugging keywords gui testing automatic test case generation semantics oracles acm reference format leonardo mariani mauro pezz and daniele zuddas.
.
augusto exploitingpopular functionalitiesforthegenerationof semanticguitests withoracles.in icse icse 40thinternationalconferenceonsoftware engineering may june gothenburg sweden.
acm new york ny usa pages.
introduction testingsoftwareapplicationsatthe systemlevel requiresexecuting theapplicationsthroughtheirinterfacestoverify thecorrectness ofthefunctionalitiesandstimulatingallthelayersandcomponents involved in the execution.
since the number and complexity of the entities typically involved in a system level execution could be significant definingtestcasesthatthoroughlysampleandverify thebehaviorofanapplicationisadifficultandexpensiveprocess.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
just part of this process can dramatically improve the effectiveness of software verification activities and significantly reducedevelopmentcosts partiallyalleviatingsoftwaredevelopers from their verification effort.
inthispaperweaddresstheproblemofautomaticallygenerating system test cases for interactive applications that is applicationsthatinteractwiththeusersthroughgraphicaluserinterfaces guis .
interactiveapplications from nowon simply applications are commonly available in several contexts including desktop and mobile environments and are exploited in many domains ranging from leisure and travel to banking and insurance.
techniques for automatically testing interactive applications exploit structural information extracted from either the gui orthe code to generate system test cases.
the techniques that ana lyze the structure of the gui generate test cases that cover guielements based on combinatorial interaction testing and variousheuristics .
those that analyze the source code instead exploit search based and symbolic execution to generate test cases that exercise code items .
state of the art techniques suffer from two relevant limitations theineffective exploration of the execution space and thelack of oracles.to illustratetheselimitationslet usconsiderafault inthe signupfunctionalityofonshop ademoe commerceapplication available on git hub .
listing shows an excerpt of the code that handles the user registration in onshop.
private void signup if isvalidform insertintodb joptionpane.showmessagedialog signuppanel please login to get started!
congratulations joptionpane.default option ... card.show this.getparent startcard return to initial window else resetform private void insertintodb ... if resultset.next user already exists joptionpane.showmessagedialog signuppanel username already exists resetform listing faulty user registration in onshop when a new user registers the signupfunction is executed line300 .ifthesignupformhasbeencorrectlyfilledin function isvalidform returnstrue line301 andfunction insertintodb is invoked line .if the usernamechosen bythe user hasbeen already taken by another user this function correctly shows anerror message to the user line .
the execution then returnsto function signupand a message that informs the user that the registration has been completed correctly is also shown to the user line303 .finally theapplicationisredirectedtotheinitialwindow acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden leonardo mariani mauro pezz and daniele zuddas expectingtheusertologin line308 .thisfaultisquiteconfusingfor auserbecausetheapplicationshowsboththebehaviorofacorrect and incorrect registration in response to a single user request.
this fault cannotbe automatically detected with state of the art techniques.
to reveal this fault a testing technique has to produce a test case that performs a correct sign up twice while filling the username field always with the same value.
in onshop this test scenariorequiresasequenceofatleast20specificguiactionsto be covered.
considering the number of gui actions that can be executed at every step of the execution it is very unlikely that this scenario is covered with explorative approaches.
indeed in our experimentsnoneofthecompetingtechniqueshavebeenableto cover this scenario ineffective exploration of the execution space .
moreover evenifthisscenarioiscoveredbychance noneofthe available techniques would interpret the response of the system as a failure.
the application produces an erroneous result in terms of awrongoutputmessageandanincorrecttransitiontotheinitial window whilestateoftheartsolutionslookforuncaughtexceptions and system crashes which is not the case for the onshop signupfault.thus evenwhenthescenarioiscovered nofailure would be reported to the user lack of oracles .
toaddressboththeineffectiveexplorationoftheexecutionspace andthelackoforacles thispaperproposes augusto automaticgui semantic testing and oracles an approach that exploits common sense knowledge to automatically generate semantically relevant test cases equipped with functional oracles that can reveal faults suchastheonediscussedabove.inparticular augustoisableto i cost effectivelyproducetestcaseswithusefulcombinationsof actionsonly incontrastwithtechniquesthatgeneratetestcases with many unrelated and irrelevant actions and ii detect failures thatdependonthesemanticsoftheapplication incontrastwith techniques revealing crash like failures only.
augustoreliesontheintuitionthatthereexistsmanypopular functionalitiesthatareimplementedinsimilarwaysandrespond to a same semantics when they occur in interactive applications.
duetotheirpopularity thesemanticsofthesefunctionalitiesisnottypicallyprovidedexplicitlysinceusersanddevelopershavealready clear expectations.
we indicate this shared expectation as common senseknowledge andthesefunctionalitiesas applicationindependent functionalities aif .examplesofaifsareauthenticationoperations crud create read update delete operations and search and bookingoperations.thesefunctionalitiesarepervasivelypresentin softwareapplications and despiteminordifferences theirbehavior remains always the same .
onatestingperspective aifsrepresentauniqueopportunity theirsemanticscanbespecified onceforall accordingtocommon senseknowledge tobethen automaticallyadaptedandreused to test the specific aifs present in the applications under test.
in this way a relevant subset of the features present in an application e.g.
considerthenumberofcrudoperationsthataretypicallypresentin an application can be tested automatically alleviating the tester from part of the verification effort.
for instance the authenticationbugpresentintheonshopapplicationcanbe revealedusing augusto with virtually no effortfor the tester.
augusto exploits the characteristics of aifs to define an automatic testing process by introducing i an encoding of the semanticsofaifswithalloy whichprovidesaflexibleandpowerfulwaytospecifyhowafunctionalityaffectsthestateofanapplication ii a technique to discover the aifs by analyzing the gui of the application under test iii a strategy to extract the specific semantics of aifs and to automatically reflect the discovered information intothealloymodel and iv asolutiontogenerateeffectivetest suites equipped with a functional oracle.
note that augusto is not alternative but complementary to otherautomatic techniques augustocan efficiently andeffectively testaifs whiletherestofthe functionalities can still be addressed with existing approaches.
in our evaluation augusto automatically recognized and effectivelytestedseveralaifsacross7interactiveapplicationsand revealed real faults1.
we compared augusto to guitar and abt tworepresentativestate of the arttechniques anddisoveredthatonly2ofthesefaultscouldberevealedbythecompeting approaches whiletheineffectiveexplorationoftheexecutionspace andthe lackofaoracle preventedtheidentification oftheother5 faults.
this result corroborates our hypothesis that augusto can be significantlymoreeffectivethanstate of the artapproacheswith aifs andthatanautomaticsystemtestingprocessshould exploit bothaugusto to test aifs and other approaches to test non aifs.
the paperis organizedas follows.section discussesthe characteristics of aifs.
section presents augusto.
section describes the empirical results.
section discusses related work.
section provides final remarks.
application independent functionalities inthisworkweusetheterm functionality torefertoasemantically cohese and correlated set of user operations available on the gui of an application for instance a set of crud operations all referring to the same entity type e.g.
money transactions .
thus a single aif may correspond to several user operations.
manyfunctionalitieshaveaconsistentlysimilarbehaviorthat cannot be distinguished across applications once abstracting away fromconcretedetails.forinstance searchandsaveoperationsmay affectdifferentkindsofentities butinallcasestheysearchandsaveanentityofsometype.werefertothemas applicationindependent functionalities aif .
aifs satisfy the following properties theyarecommonlypresent inseveralapplications somemight be more common in certain domains for instance the cart functionality is very common in the e commerce domain whereas others are generally common such as crud functionalities theirsemanticsislargely applicationindependent thusitcanbe defined abstractly in a way that is independent on the specific application.forexample thegeneralsemanticsofcrudfunctionalities does not depend on the type of the handled object theycanbeactivatedfromtheguiaccordingtostructural gui patternsthatuserscanrecognize .forinstance thesign inandsignupfunctionalitiesinmanyapplicationsusesimilar setsofwidgets althoughthesewidgetshavedifferentlookand feel and placements in the windows.
becauseoftheirpopularity thesemanticsofaifsispartofusers common sense knowledge thus they can be intuitively used without requiring special documentation and manuals.
1toolandexperimentalmaterialareavailableat authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
augusto icse may june gothenburg sweden match finalizing te s t i n g ripping structural matching gui model raw match interactive application test reportsaif recognition full match reification concrete matchaif archive gui pattern abs.
semanticsaif ... aif aif read read figure augusto logical architecture theauthentication aif composed of the sign in sing up and signoutoperations isagoodexampleofaifsince i itprovides an overall functionality authentication which can be found in many applications ii its semantics is well known and mostlyindependent on the specific application and iii its presentation on the gui is predictable and easily recognisable.
apartfrom authentication thereare severalotherexamplesof aifs thefunctionalityofcreating reading updatinganddeleting crud objects of a type the functionality of saving the work on a fileandthenreloadingit thefunctionalityofsearchingandthen booking a certain service car hotel flight the functionality of handling an e commerce cart etc.
despite their diffusion aifscaneasilyincludefaults eveninextremely popular applications andthusrequirecarefultesting.forinstance faultsimpactingan extensivenumberofusershavebeenreportedforcrudoperations in jenkins and for authentication operations in dropbox .
thegeneralideathatfunctionalitiesrecurinasimilarwayinthe guiofdifferentapplicationshasbeenalreadyinvestigatesinthe fieldofuidesign.thereexistscatalogsofuidesignpatterns anddesigningtools thatallowtocreateanewguibycomposing thesepatterns.eveniftheconceptofuidesignpatternisnotexactly thesame ofaif manyuidesign patternsturn outtobe alsoaifs.
augusto exploits the presence of aifs to automatically generate semantically relevant test cases equipped with functional oracles.
augusto automated aifs testing augustoisanautomatictestcasegeneratorforapplicationindependentfunctionalities aifs itexploitsthe application independent semanticsofaifstoautomaticallyidentifyandtesttheaifspresent in interactive applications.
the intuition is that ideally an aif can be modelled once for all and then be exploited to effectively testany occurrence of the modeled aif in any application.
augusto supports this intuition by offering the capabilities to discover aifs to automatically adapt the models to the application under test aut and to generate effective test cases equipped with oracles.
to study the effectiveness of the approach we provide an initial definition for several aifs.
of course the set of the defined aifs canbefurtherextended toincreasethescopeandapplicability of the approach.
note that testers do not have to do any modelingeffort because they can benefit from the aif definitions already present in the tool.
intherestofthissection wefirstprovideanoverviewofaugusto and thendiscuss the individualelements andsteps of theapproach.
.
overview figure1showsthelogicalarchitectureofaugusto.the aifarchive istherepositorythatcontainsthesetofaifssupportedbyaugusto.
eachaifismodelledasapair guipattern abstractsemantics where the gui pattern specifies the set of windows and widgets that may refer to the aif section .
and the abstract semantics specifies the behavior of the aif section .
.
augustoworksinfivesteps.the rippingstepexecutestheapplicationundertesttodynamicallyextracttheguimodel which is a partial model of the structure of the gui section .
.
the structural matching step exploits the gui model to identify the aifs by searching for instances of the gui patterns in the gui model section3.
.thisstepproducesasetofrawmatches which canbepartial thatis onlyasubsetofaguipatternmightmatch the gui model.
augusto supports partial matches because the gui model extracted through ripping might be incomplete.
the match finalizing step generates additional executions aiming to complete the partial matches while verifying the consistency between the behaviorsspecifiedintheabstractsemanticsmodelandthebehavioroftheapplication section3.
.thisstepproducesasetoffull matches whichincludeseveryaifsthathavebeenfullymatchedin terms of its gui pattern and its abstract semantics.
the reification step further refines the full matches extracting properties about the concrete behavior of the application section .
.
for instance everycrudoperationmayincludeadifferentnumberofunique andmandatoryfieldsforthecreationofanentity.augustoextracts these properties by stimulating the application with different combinationsofinputs.thisstepproducesasetofconcretematches each being an aif that occurs in the application under test.
the concretematchesareassociatedwithsemanticsinformationthat takes intoconsideration the specificcharacteristics of theapplicationundertest.finally the testingstepgeneratesandexecutestest cases that both combine multiple operations in a semantically relevant way and include a functional oracle to check the correctness of the results produced by the application section .
.
.
gui pattern model theguipatternmodelspecifieshowacertainaifgenerallyoccurs on the gui of interactive applications and it is used by augusto toautomaticallyrecognizewhethertheautimplementstheaif.
even though there exists powerful ui modelling languages such asifml theselanguagesaremeanttomodelthe concreteui of a specific application and they are not meant to model abstract portions of uis that must be general and flexible and that can fit authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden leonardo mariani mauro pezz and daniele zuddas multipleapplications.forthisreasonwedefinedanadhoclanguage for the gui pattern model.
thelanguagewedefinedfortheguipatternmodelsspecifies how aifs occur in guis as sets of abstract windows that contain abstract widgets and are connected through abstract edges .
anabstractwindow identifieswindowsoftheapplication.itis definedas asetof abstractwidgetsthat arerequiredto bepresent inthewindow.an abstractwidget abstractlyreferstoawidgetin the gui and might be of type i action which represents widgets thatcanbeclicked forinstancebuttons ii input whichrepresents widgets that can be used to enter data for instance text fields and iii selectable which represents widgets that can be selected for instancelistsortables.abstractwidgetsareannotatedwithboth regularexpressions whichspecifythelabelsthatmustbeassociated withthewidgets andcardinality whichexpressesthequantityof that particular widget that can be in a window and can be either one exactly some or more none no occurrences lone or or any or more .
window id loginform card one action widget id signup card lone label register signup sign up .
label action widget action widget id login card one label login enter sign in .
label action widget input widget id pass card one label pass password .
label input widget input widget id user card one label user username email .
label input widget window window id signupform card one action widget id register card one label ok save record signup sign up label action widget input widget id signupuser card one label user username email .
label input widget input widget id signuppass card one label ?
!re enter repeat pass password .
label input widget input widget id signuppass2 card lone label repeat re enter confirm .
label input widget input widget id otherfields card any label .
label input widget window window id loggedpage card some action widget id logout card one label logout exit sign out signout .
label action widget window edge type uncond from signup to signupform edge type uncond from logout to loginform edge type cond from register to loginform loggedpage edge type cond from login to loggedpage figure auth gui pattern model figure shows a simplified gui pattern for the authentication aif for the complete model see augusto .thepatternisdefinedinxmlformat.the windowxmlelementsdefinetheabstractwindowsthatcorrespondtothewindows of the application.
for instance the loginabstract window corresponds to the presence of a window that includes an input field for the username an input field for the password an action widget to login andanoptionalactionwidgetforregistering.thedefinitions are flexible.
they are not bound to specific gui widgets for instance buttons but refer to general classes of widgets for instance1 gui elements definition 2sigloginform signupform loggedpage extends window 3siglogin signup register logout extends action widget 4siguser pass pass2 ... otherfields extends input widget 5one sig curr win current window 6is in window one time functionality internal state elements 9sigusr 10username onevalue 11password onevalue 13sigusers 14list usr set time semantic property 17one sig required 18fields setotherfields 20predpreconditions 21winregister notuser.content.t none notpass.content.t none us users.list.t user.content.t nequalus.username 23pass.content.t pass2 iw required.fields notiw.content.t none 25predpostconditions 26winregister oneus users us.username user.content.t 27us.password pass.content.t users.list.t users.list.t us curr win.is in.t loginform curr win.is in.t loggedpage figure auth abstract semantics model action widgets and allow elements to be optional for instance the registeractionwidgetinthe loginwindow.theflexibilityinthe definition of the cardinality is also useful for abstraction for example the cardinality of the otherfields field in the signupform abstract window allows the pattern to match an arbitrary number offields.thepatterndefinitionallowsforadditionalelements that is awindowmatchinganabstractwindowmayincludeelements not specified in the pattern.
abstract edges connect an action widget of an abstract window to another abstract window to indicate possible execution flows.
unconditional abstract edges indicate that the target window is always reached when interacting with the source action widget for example clicking on a navigation menu.
conditional abstract edges indicate that the target window is reached only if certainpreconditions are satisfied for instance successfully submittinga form.
the definition in figure uses two conditional and two unconditionaledges.uncertaintyisrepresentedasalistofpossible targetwindows.for exampletheedgeassociated withthe register action widget indicates that once registered the execution may reach either the welcome page automatic login or the login form.
abstract windows are logical windows thus a same concrete windowofanapplicationmayhostmultiplelogicalwindows forinstance the login and registration abstract windows might be found in a same concrete window.
windows may have a cardinality to indicate that they are not required to be present in the target application.
this might be useful for example in cases like confirmation windows which might or might not be shown in an application.
.
abstract semantics model theabstractsemantics modeldescribesthebehaviorofanaif and formallyspecifiestheeffectontheapplicationoftheinteractions withthewidgetsdefinedinthecorrespondingguipatterninterms of i the condition necessary to successfully execute an operation authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
augusto icse may june gothenburg sweden precondition ii the window that is shown after the execution ofanaction transition iii thestateoftheapplicationafterthe execution of the action postcondition .
augusto uses the abstract semantics model to generate test cases and oracles.
we specifytheabstract semanticsmodel usingthealloy specificationlanguage chosenbecauseofbothitssimplicityand expressiveness andtheefficiencyofthealloyanalyzer anautomatictoolabletoanalyzeanalloymodelandsimulatetheexecution of the operations defined in the model.
figure shows an excerpt of the abstract semantics model of theauthenticationaifwhosepatternmodelisshowninfigure2 for the complete model see themodeldeclaresthewindowsandthewidgetsrelevanttothe specified functionality lines .
the widgets defined in the gui patternareannotatedwithatag notshownintheexample whose value is the identifier of the corresponding widget in the alloy model.
in this way after mapping a gui pattern to the concrete gui of the application every action on a widget can be associated with its semantics expressed inalloy.
then the model defines the statevariablesthatarenecessarytodefinethebehaviorofthefunctionality lines5 .inthefigure themodeldefinesthecurrent window lines and the list of registered users lines .
finallythemodeldefinesthepreconditions lines20 andthe postconditions lines of the operations.
the figure showspre and postconditions only for the registration operation.
the preconditionrequirestheusername user andthepassword pass tobenotempty therepeatedpassword pass2 tobethesamethan thepassword alltherequiredfields required.fields tobenot empty andtheusernametobeunique.thepostconditionaddsa new user to the set of registered users and changes the current windowtoeitherthe loginform ortheloggedpage window.for simplicity we omitted some of the checks in the precondition such as the individual validity checks on the input fields.
the behavior of an aif can be specified only partially since it may depend on some specific semantic properties that change fromapplication toapplication.
augustocan enrichthemodel by automatically plugging in semantic properties inferred during the reificationstep.tosupportsemanticproperties themodelspecifies in advance one or more items that might be affected by a property that will be fully defined at a later stage.
in a sense the model mustbereadytoincorporatethepropertiesthataredynamically extracted by running the application under test.
in the model in figure the item required which expresses the concept of some fieldsrequiredto befilled in tosubmit the registrationform is an exampleofapropertythatisindicatedinadvancesimplyasaset of fields from line to line and that is refined based on the interactionwiththeactualapplication.wediscussthesupported properties and the strategy to infer them in section .
.
.
ripping therippingstep produces a graph that represents the structure of theguioftheinteractiveapplicationininput followingthegui ripping technique defined by memon et al.
.
augusto creates the graph by recursively clicking on all the widgets in the gui accordingtoadepthfirststrategyandcreatinganodeforeverytraversed window and an edge for every observed transition betweenwindows.augustoannotatesthenodeswithdetailedinformation about all the widgets displayed in the windows.
ripping may not be able to discover all the edges and windows.
in particular it might be unable to traverse some conditional edges becauseitmightfailinsatisfyingthepreconditionofthefunctional ityassociatedwiththeedge.augustoaddressesthisincompleteness when recognizing aifs in the next steps of the process.
.
structural matching thestructuralmatching stepsearchesfor rawmatches betweenthe aifs defined in the aif archive and the gui model produced in the rippingphase.
inparticular a rawmatchisa subgraph ofthe gui model i.e.
a subset of its windows and edges that includes all the elements of a gui pattern that can be discovered through ripping.
morerigorously awindow wintheguimodel i.e.
anodeofthe graph matchesanabstractwindow awifthereexistsamatching widgetin wforeachabstractwidgetin aw.awidgetmatchesan abstractwidgetifthewidgetisofthetypedefinedintheabstract widget eitheraction inputorselectable anditslabelisaccepted by the regular expression defined in the abstract widget.
when the label is not on the widget itself the label is identified by searching foradescriptorplacednearbythewidgetaccordingtothealgorithm definedbybecceetal.
.thematchingbetweenawindowand anabstractwindowconsidersthecardinalityofthewidgets.the left part of figure shows a match between the definition of the loginform abstract window and the sign in window of onshop.
since the gui model extracted through ripping does not include conditionaledges thestructuralmatchingconsidersonlytheunconditional edges defined in the gui pattern.
in practice augusto finds a raw match if it recognizes all the windows reachable by navigatingtheunconditionaledgesoftheguipatterninthegui model.theconditionaledges ifpresentinthepattern aresearched in the next step.
forexample theportionofguirelevanttotheauthentication pattern discovered through ripping in the onshopapplication corresponds to the two windows shown in figure inside the grey frame.
these windows are the windows reachable by navigating unconditionaledgesonly unconditionaledgesareshownwitha greenthicklineinfigure4 .thesetwowindowscorrespondtotwo oftheabstractwindowsthatcomposetheauthenticationpattern reportedinfigure2 thusgeneratingarawmatchbetweenthegui model and the auth pattern.
ingeneral theproblemofidentifyingguipatternsinthegui model is an instance of the subgraph isomorphism problem which isproventobenp complete .however sincethenumberofdistinct windows in an application is commonly low the problem can be solved in few seconds as confirmed in our empirical experience.
.
match finalizing thematch finalizing step aims to complete the raw matches that is eachrawmatchiseitherdiscardedorextendedtoafullmatch by including the conditional edges.
foreachconditionaledgetobeconfirmed augustogenerates a probing gui interaction that samples the edge.
a probing gui interactionisatestcasethatterminateswithanexecutionofthe conditionaledgeintheautwhenitspreconditionissatisfied.if authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden leonardo mariani mauro pezz and daniele zuddas window id loginform card one input widget id user card one label user username email .
label input widget input widget id pass card one label pass password .
label input widget action widget id login card one label login enter sign in .
label action widget action widget id signup card lone label register signup sign up .
label action widget window figure a simplified version of the onshop gui.
the windows in the grey frame are those that are discovered by the ripping.
dashed red edges are discovered during the match finalizing step.
itsexecutionreachestheexpectedwindowandsatisfiesthepostconditionassociatedwiththeedgeintheabstractsemanticsmodel augustoconfirmsthepresenceoftheconditionaledge andaddsthe edge aswellasanynewlydiscoveredwindow totheguimodel.
if augusto succeeds in confirming every conditional edge relevant to the pattern that originated the raw match it transforms the raw match into a full match otherwise it discards the raw match.
in some cases a conditional edge may have more than one possible resulting window such as for the conditional edge associated withtheregisterwidgetdefinedinfigure2.accordingtothepatternafteraregistrationhasbeensuccessfullycompleted aprogram is expected to reach either the login or the welcome abstract window.inthesecasesaugustoexpectsaconsistentbehaviorfromthe application thatis whensuccessfullyexecutingaconditionaledge it expects the application to always reach the same window.
augustogeneratestheprobingguiinteractionsexploitingthe alloy analyzer which can be instructed to generate a sequence of guiactionsthatcoversacertainoperationorconditionofthealloymodel.thealloyanalyzerrequiresininputtheabstractsemantics model a condition that must be covered and the maximum length of the interaction sequence that must be produced.
in this case the alloy analyzer is asked to generate sequences of length up to a given boundary that execute the patterns conditional edges.
ifthetestedaifisnotavailableintheinitialwindowoftheaut augusto analyzes the gui model to find the shortest sequence of actions that reaches the window with the aif from the initial window and adds this sequence as a prefix of the probing gui interaction generated with the alloy analyzer.
when executing a gui interaction that requires input values such asfilling a textfield augustouses an archiveof input values organized according to their type e.g.
emails are distinguished from dates and divided between valid and invalid values.
the archive includes predefined values for most common data types but it can be extended with values specific for an aut.
inthecaseofthesamplerawmatchoftheauthpatternwith theonshopapplication augusto successfully generates probing gui interactions that confirm the two conditional edges present in thepattern shownwithdashedredarrowsinfigure4.thisalso leadstotheidentificationofanewwindowandfinallyturnedtheraw match into a full match.
.
reification thereification step adapts a full match to the specific semantics of theapplication byfocusingonthe semanticproperties definedintheabstract semantics model.
the abstract semantics model encodes thesemanticpropertiesinageneralway thatis semanticproperties mayhaveunspecifiedpartsthatareautomaticallyadaptedtothe specific characteristics of the aut.
for instance the property that requiressomefieldstobenon emptyisdefinedinfigure3asbeing associatedwithasetofinputwidgets buttheexactsetofwidgetsisleftunspecified.thereificationstepadaptsthesemanticproperties to the behavior observed for the aut.
augusto starts by generating a probing gui interaction that coversthebehavioraffectedbyasemanticproperty andexploits the result of the execution to guess the semantic property.
for example aprobingguiinteractionmaytrytoexecutethe sign up operationpresentinthe sign upwindowoffigure4withanonemptyfull name beingfull name theonlyfieldthatneedstobe determined as required or not.
in fact fields username password andrepeated password areknowntoberequired seefigure3 .
afterexecutingthisprobingguiinteraction augusto usingthealloy analyzer constraint solver makes a guess consistent with thecollectedevidence.forinstanceitmayguessthatthefield full nameismandatory.augustoautomaticallyincludestheguessinthe alloymodelbyaddingsomefieldstothesetoffieldsaffectedbythe property inthisexampleitadds full name torequired.fields andtriestogenerateanewprobingguiinteractionthatviolates the newly guessed semantic property.
the new interaction can either confirm or refute the guess.
if the interaction refutes theguess augusto makes a new guess based on the newly collected evidence.thisprocessiteratesuntileitherthereisonlyonepossible guess consistent with all the collected observations or a timeout is reached.inbothcasesaugustoincorporatestheguessinthemodel.
intheexample thefirstguessiscorrectanditisconfirmedbyan interaction that fails to sign up with an empty full name .
this process is quite general and can discover several classes of semantic properties.
the current version of augusto supports any semanticpropertythatcanbeexpressedasapropertyassociated with a possibly empty set of elements of the gui for instance the property that an input field in a form is either requiredorunique.
.
testing thetestingphasegeneratestestcasesthatstimulatethediscovered aifs within semantically relevant usage scenarios.
in particular augusto generates a test suite that satisfies the following criteria.
conditionaledge coverage .this criterionrequires samplingthe aifsineveryexecutioncontext foreachconditionassociatedwith a conditional edge of the model and for each combination of truth authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
augusto icse may june gothenburg sweden values computed according to mc dc there must exist a test case that exercises that combination.
we selected mc dc because it offers a good compromise between cost and completeness.
pairwise edge coverage .
this criterion requires combining the execution of multiple edges to test combinations of actions.
for each ordered pair of edges in the concrete match there must exist atestcasethatexercisesthepair.ifanedgeisaconditionaledge it mustbeexecutedtwice withasatisfiedandaviolatedprecondition.
augustogeneratesguitestcasesthatsatisfythesecriteriausing the alloy analyzer in the same way as it generates the probing gui interactions of the previous steps.
note that the generated test cases cover the semantics of the operations by construction.
in addition augusto generates a functional oracle for each test casebymappingthepostconditions whichdefinethewindowthat mustbedisplayedaftertheexecutionofaguiactionanditscontent into assertions that are checked after the execution of every action.
letusconsiderourrunningexample.inordertocovertheconditional edge about the registration operation with mc dc see line of figure augusto generates a non trivial test case that first registers a new user and then registers again a user with the same usernameofthealreadyexistinguser.thetestcaseisalsoequipped withafunctionaloraclethatchecksthatthecurrentwindowisstill the window with the registration form after an error message has beenpossiblydisplayed.theexecutionofthetestcausesafailure detected by the oracle because the onshop application in addition toshowing anerrormessage behaveslikeiftheregistrationhas been completed successfully which violates the generated oracle.
empirical evaluation our empirical evaluation addresses research questions rq1 howeffectiveisaugustoin detecting applicationindependent functionalities?
this research question investigates the capability of augusto to automatically detect the presence of the modelled aifs in the tested applications.
rq2 how effective is augusto in testingapplication independent functionalities?
thisresearchquestioninvestigatesaugusto sabilitytoautomatically generate test cases and find faults in the detected aifs.
rq3 howdoesaugusto comparetostateofthearttestingtechniques in testing aifs?
this research question investigates if testing the aifs present in an application with augusto delivers better results than testing the same functionalities with other approaches thus motivating the adoptionofaugustoinadditiontoexistingtechniques.weusedthe guitar and abt testing techniques for the comparison.
toanswertheseresearchquestionswedevelopedaprototype of augusto for java desktop applications.
for the purpose of theevaluation we populated the aif archive with the definition of three aifs crud that is adding removing updating and deleting objects of a type auth that is signing up signing in and signing out from applications and save that is saving data in files andloading them.
we produced these definitions before identifying the subject applications.
these aifs are modelled according to the common sense knowledge by the authors of this paper.forourempiricalstudy weselectedassubjectsseveninteractive applicationsfromdifferentapplicationdomains fiveofwhichwere already used in previous studies buddi v3.
.
.
a personal finance and budgeting program upm v1.
a password manager rachota .
personal tasks and activities management application timeslottracker v1.
.
another personal tasksmanagerapplication pdf samv0.
atoolformerging andsplittingpdfs onshop ademoe commerceapplication availableongit hub andsparkv2.
.
alanchatclient.since a database is required to enable all the functionalities in buddi and upm weconfiguredaninitialdbwithcustomdataforbuddiand an empty db for upm.
thethreetechniquescomparedinrq3requiredthesameconfigurations thatis apoolofinput valuesthatcanbeusedduring the testing activity and the definitions of some configuration parameters.forallthetechniques wepopulatedthepoolofinputs value with the same valid and invalid values defined coherently with the nature of the data processed by the subject applications.
in our evaluation we used the best configuration possible for eachtool basedonourknowledgeofthetechniques.inaugusto weusedatestcaselengthof15guiactionsforallapplicationswith theexceptionofonshopthathasbeentestedwithatestcaselength of22actions.wesetto30minutesthemaximumamountoftime forthereificationstep.inabtweusedepisodesof30actions note that since each episode can start from any state of the system the resulting test cases can have an arbitrary length and the greedy policy with .
as used in abt original paper .
in all the experiments abt has been executed for the same time than augusto.
finally for guitar we generated the test cases using theefgmodeland3 wisecoveragefortestcasegeneration which guarantees guitar to be executed for a longer time in some case significantly longer thanaugusto thusfavouringguitar over augusto.
notice that we tried to use guitar also with other types of models but we failed since the tool always produced corrupted test suites despite our best effort including the attempt to receive support from the developers of the tool .
since guitar and abt are not limited to aifs simply running the tools on the full applications would produce incomparable data for rq3.
we know by construction that guitar and abt can test applicationsmorebroadlythanaugustoandanyresultobtainedbythesetoolswithnon aifscouldnotbeachievedwithaugusto.thepurposeofrq3istoinvestigateiftheoppositeisalsotrue thatis if augustocandeliverbetterresultsthancompetingapproacheswhen testingaifs.onlyforthepurposeofrq3 tomakethiscomparison as fair as possible and have guitar and abt spending all thetimetestingaifsonly asaugustodoes wemodifiedthesubject applications disabling every functionality that is not an aif.
finally tomitigatetherandomnessintheresults werepeated all the experiments three times and reported average values.
.
rq1 aif detection to answer rq1 we studied the completeness and precision of the algorithmfordetectingaifs.wefirstidentifiedtheaifsactually presentinthesubjectapplicationsbyopeningandinspectingevery window of every application looking for instances of the three defined aifs crud auth save .
we identified a total of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden leonardo mariani mauro pezz and daniele zuddas table rq1 aif detection aut aif id match structuresem.
properties compl.
fp upmcrud yes precise save yes precise n a n a spark auth yes precise rachota crud4 yes precise yes precise .
6n o onshop auth yes precise .
buddicrud8 yes lack delete button .
yes precise yes precise yes precise .
yes precise save yes lack replace file window n a n a pdfsam crud yes precise ttrackercrud yes precise crud no crud no occurrencesacrosstheapplications.notethatanaifoccurrence istheoccurrenceofthesetofoperationsspecifiedintheaif.for example an instance of a crud includes operations to create read update and delete the entities of a kind.
the applications and their aifs are reported in the autandaifcolumns of table respectively.
each aif is associated with an identifier column id .
we then executed augusto on the applications and checked the discovered matches.
we indicate the result of this check incolumnmatch yescorresponds to the generation of a concrete match that can be used for generating test cases noindicates that nomatchisfound and yes meansthatthematchrequiredmanual interventiontobefound.outof17cases augustomissedonly3 aifs.forttrackerthemissedmatchesarecausedbythelimitation of therippingphase that was not able to discover the gui portions that contain the aifs.
the missed aif in rachota was caused by twocrudaifssharingsomewindows acasenotsupportedby augusto.
augusto never identified a non aif functionality as an aif that is it never produced false positives during aif detection.
augusto required manual intervention to deal with cases not supportedbytheprototypein3ofthe14identifiedaifs.inthecase of buddi case we manually excluded a combo box producing behaviors that are not supported by our technique.
to addresscases and we extended the definition of two gui patternsto accept labels that are not typically used for the operations of crudandauth.forinstance wesetthelabel accounts asavalid alternative of sign up register in auth.
although these are small interventions they prevented the fullyautomatic execution of the approach in three cases.
we also evaluated the accuracy of the discovered matches in terms of the widgets included in the aif match column structure indicates if the match includes all and only the widgets that we manually identified as related to the aif.
the value preciseindicates a perfect match that is no missing neither unrelated widgets associatedwiththeaif.notethatin12outof14casesaugustoproducedaperfectmatch.incase8augustomissedonlyanelement reportedinthetable duetoparticularimplementationchoicesin theapplication andincase13augusto missed awindowbecause ofabugintheapplication thebugwasthenreportedinthetestingtable rq2 effectiveness aut aif id avg tc avg fail avg fa avg fault fault crash upmcrud .
.
.
.
save .
.
.
.
spark auth .
.
.
rachota crud .
.
.
.
.
.
onshop auth .
.
.
.
buddicrud8 .
.
.
.
.
.
.
.
.
.
.
.
save .
.
.
pdfsam crud .
ttracker crud .
overall phase .
in no case augusto associated unrelated widgets to the aif that is augusto never confused the additional elements present in a window with the ones that refer to the identified aif.
we also evaluated the ability of augusto to identify semantic properties inthiscasetoidentifytherequiredanduniquefieldsfor crud and auth aifs.
we evaluated this aspect by considering completeness defined as the percentage of required and uniquefields identified correctly by augusto column compl.
and false positives definedastheaveragenumberoffieldswronglyassociated with a required or unique property column fp .
we report thevalue n awhentheaifdoesnotincludeanysemanticproperty to be discovered.
the results obtained with semantic properties show that augusto is quite effective both in terms of completeness only in one case some fields have not been associated with the corresponding property and rate of false positives only in four cases there are false positives.
note that completeness and the number of falsepositivesassociatedwithsemanticpropertiescouldbeimproved by allocating more time to the reification phase.
in a nutshell augusto has been able to identify the aifs present inthesubjectapplicationsin82 ofthecases in3casesrequiringamanualintervention producinghighlyaccuratematches including perfectmatches.moreover ithasbeenabletoidentifythevast majority of the semantic properties present in the application.
.
rq2 effectiveness the effectiveness of testing techniques is typically assessed consideringcodecoverageandtheirfaultrevealingability.sinceaugusto does not target the whole application code coverage metrics are notinformative.thus toanswerrq2weevaluatedaugustoconsidering its fault revealing ability.
in particular we measure the number of faults revealed in the subject applications.
table2reportsforeachaifidentifiedbyaugusto theaverage number of generated test cases column avg tc the average number of test cases that fail because of the violation of a functional oracle column avgfail theaveragenumberoffalsealarmsproduced thatis thenumberoffailingtestcasesthatdonotexpose anyfaultintheprogram column avg fa theaveragenumberof faultsdetectedperaifinarun column avgfault andthetotal number of faults detected in the three runs column fault .
column faultsalsoindicatesthenumberoffaultsthatcauseprogram authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
augusto icse may june gothenburg sweden table rq3 comparison aut time h augustoabt guitar reported covered reported covered upm .
spark .
rachota .
onshop .
buddi .
pdfsam .
ttracker .
overall reported crashes.
the classification of a failing test case as fault revealing or as false alarm was performed manually by this paper s authors.
the average number of test cases generated by augusto varies a lot rangingfrom8 .3to76.
.thisbigvariability whichmightbe observed even for aifs of the same kind in the same application e.g.
see number of test cases for the cruds in rachota depends on the specific structural match concrete semantics and semantic properties that are extracted.
this shows how augusto although it usesabuilt insemanticsfortheaifs isabletoflexiblyadaptthese definitionstothespecificcase generatinganumberoftestcases that depends on the actual complexity of the tested functionality.
augustomayproducefalsealarms asreportedinthetable.this is due to two main reasons acceptable mismatches between the semantics model and the concrete behavior of the application and imprecise semantics properties inference.
both these sources of imprecision cause the generation of an imprecise functional oracle.
note that in several cases sets of failures refer to a same cause e.g.
asingleimprecisepropertymaycausethefailureofmultipletest cases and identifying the cause of the failure for one test can beused to drastically reduce the inspection time of the other tests failing for the same reason.
in the evaluation augusto has been able to reveal a total of faults with only two faults causing program crashes.
this resultshows that the automatic functional oracle included in the test cases is an essential element for revealing failures beyond crashes.
augusto revealed some interesting faults such as the one described in the introduction of this paper.
another interesting fault was detected in upm when editing the identifier of an account ifthechangeisundoandtheaccountissaved theoperationfails withanerrormessagestatingthattheidentifieralreadyexists even though the identifier is the current identifier of the edited account.
in a nutshell augusto has been able to generate a number of test cases for the aifs present in several applications and revealed multiple faults including several non crashing faults.
.
rq3 comparison table 3shows the resultsobtained byaugusto abt andguitar whentestingaifs.column sutindicatesthesubjectapplication.
columntimereports the time spent by augusto to test the application.
abt has been executed for the same amount of time while guitar has been configurated to be executed at leastfor that time.
column augustoindicates the number of faults detected by augusto.
for abt and guitar the table distinguishes between reported and covered faults.
a reported fault is a crashing fault revealedbyabtorguitar abtandguitardonotincludeafunctional oracle and can onlyreveal crashing faults .
acovered fault is a fault that has been activated by a generated test case but no failure has been reported due to the lack of an oracle.
allthefaultsreportedandcoveredbyabtandguitararea subset of the faults reported by augusto confirming the higher effectiveness of semantics approaches when testing aifs.
augusto hasbeenabletotestinterestingcasesandinterestingcombinations ofactionsrevealing7faults whilefor4ofthesefaultsabtandguitar have not been even able to produce the sequence that covers thefaultycase.moreover evenwhenabtorguitarmanageto cover the fault there is a good chance that the fault is not reported due tolack of non trivial oracles.in our evaluation togetherabt and guitar reported crashing faults and covered but did not report another fault.
finally noticethataugustocomputationtimeiscompatiblewith server side quality assurance sessions as well as with overnightusageofthetechnique.augustomainperformancebottleneckis theconstraintsolvingperformedbythealloyanalyzertogenerate test cases.
this aspect might be potentially improved employing a formulacachingframeworktoreducetheneedofconstraintsolving andthusspeedingupthetechnique .
in a nutshell compared to other state of the art techniques augustohasbeenabletosampletheexecutionspaceoftheaifs moreeffectivelyandtoreportfailuresthatcouldnotbereported bythecompetingapproaches atthecostofreportingsomefalse alarms.augustoprovedtobeaneffectivecomplementtocurrent general purpose gui testing techniques.
limitations.
augusto most obvious limitation is that it can be exploited totest onlyaifs and cannotbe used totest anarbitrary functionality whileotherapproachescouldinprinciplebeexploited to test any kind of operation although their effectiveness depends on the complexity of the tested operations.
inaddition augustodependsontheaifarchive whichassumes thattheguiofthetestedapplicationfollowscommonsense while in practice people might do choices against common sense.
moreover the patterns exploit labels which makes the archive sensitive to thelanguage of thetested application andto the choiceof terms.
thislimitationcanbemitigateddefiningmultiplepatternsfordifferent languages and or using automatic strategies to find synonyms in a specific context as done in the work by mariani et al .
threats to validity.
athreattointernalvalidityisthegeneralityof theaifsmodelsthatweusedinourevaluation.tomitigatetherisk ofdefiningmodelsthatfittheapplicationsusedintheevaluation but not others we defined the aif archive before selecting the subject applications.
another threat to internal validity is related to the manual activitiesperformedbytheauthorstoclassifythefailingtestcasesreported by augusto as faultyorfalse alarm and to modify the subject applications for rq3.
for the first threat to reduce any bias only the failing test cases for which all the authors agree that they expose a fault were classified as faulty.
for the second threat after modifying the applications we verified that the aifs continue working the same including the presence of the faulty behaviors.
theexternalvaliditythreatsofourstudyrelatetothegenerality of the results with respect to the set of aifs and set of applications authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden leonardo mariani mauro pezz and daniele zuddas that we used.
although we cannot make claims about the generalizability of the results to other aifs the aifs that we used were all successfullymatchedandhavebeenallusefultorevealfaults.we thus expect augusto to be able to effectively exploit other aifs too.
in terms of subject applications to mitigate any issue with generalizability we selected applications that belong to a variety of domains most of which were already used in other studies which facilitates comparison and experimented with a relatively high number of aifs per application.
related work automation has been investigated extensively in software testing .
techniques for the automatic generation of system test caseshavefocusedontwoclassesofcomplementaryapproaches techniquesthatsampletheexecutionspaceaccordingtoamodel derived from the guiof the aut and techniques that samplethe executionspaceaccordingtoamodelderivedfromthesourcecode.
thetechniques thatusea model extractedfrom aguisample the execution space according to a coverage criterion defined onthe model such as covering every gui action or every pair ofdependent gui actions .
these approaches can uniformlysampletheportionoftheexecutionspacerepresentedin themodelbutprovidenoguaranteeonthesemanticrelevanceof the generate tests.
on the contrary augusto includes mechanisms tocompletetheinitialguimodelanddirectlygeneratetestcases that cover semantically meaningful scenarios thus avoiding to waste time and resources on testing irrelevant scenarios.
instead of generating the model and generating the test cases intwosequentialsteps abtusesq learningtobuildthemodel while generating system test cases alternating exploration and exploitationactivity .althoughthetestgenerationstrategy is different abt still generates test cases that may cover scenarios thatarerelativelyrelevantonatestingperspective.asreportedanddiscussedinthispaper augustocanbedramaticallymoreeffective than these approaches in the domain of aifs.
other techniques exploit the aut source code to apply symbolic execution or search based algorithms to test case generation .
although these techniques may cover meaningful testing scenarios in the attempt to cover code statements they are stilllimitedintheirabilitytocapturethesemanticsofaprogramand mighthardlyscaletocomplexguisandlargeprograms.augusto overcomesbothproblemssinceitexploitssemanticsinformation and does not depend on the source code.
more in general none of these test case generation techniques can reveal failures that do not cause crashes which is a key ability of augusto as reported in this paper.
the need of moving from explorative approaches mainly using structuralinformationtoadifferentclassofapproachesthatcan directlyaddressthesemanticsoftheautisalsosupportedbystudies such as the one by choudhary et al.
.
the study shows that even though there exist elaborated techniques that use complex structural information the most effective testing technique for android applications is still a technique that simply performs random clicks on the gui.
we interpret this result as a clear evidence of theineffectivenessofautomatictestingtechniquesiftheyarenot guided by semantic information and as a motivation for this work.other researchers approached the problem of generating semanticallyrelevantexecutionsinacomplementary althoughrelated situation that is generating complex and semantically relevantinput data for testing .
in particular link can exploit semantic web technologies to generate sets of coherent and semantically relevant input values to execute forms.
these solutions could be used to populate augusto s input values archive.
previousworkspartiallyinvestigatedtheuseofpatternstofacilitatetesting .ermuthetal.proposedatechnique to infermacro events that is gui operations composed of several low level gui events e.g.
open drop down menu and click on a menuitem fromusagetraces.differentlyfromaifs macro events are application specific and do not include information on how theymayaffecttheapplicationstate.zaeemetal.introducedthe conceptof user interactionfeatures thatis sequencesofoperations without input data that bothhave little impact on the application state e.g.
double screen rotationandpause and resume andhave a known effect.
compared to aifs user interaction features are rathersimple donotneedtobediscoveredfromthegui andhave a semantics that does not require adaptation.
moreira et al.
instead exploited ui design patterns .
this approach shares some ideas with augusto although augusto has several unique capabilities the automaticdetectionofknownaifsinagui theautomaticadaptation ofaifsdefinitionstotheactualsemanticsoftheapplication and the automatic generation of test cases equipped with oracles.
finally augusto is not the only technique that uses alloy to generate test cases.
for instance testera can generate test cases for java methods from pre post conditions written in alloy.
conclusions this paper presents augusto a gui test case generation technique that can automatically produce system test cases for applicationindependentfunctionalities aif that i systematicallycoversemantically relevant scenarios and ii include precise functional oracles that can reveal non crashing faults.
to obtain this result augustoencodesthehigh levelcommonlyexpectedsemanticsof aifs into models that are automatically adapted to the specific characteristics of the application under test.
ourempiricalevaluationshowsthataugustocanpreciselyidentify aifs and then generate complex test cases able to exercise and reportrealnon crashingfailuresthatcannotbedetectedwithother state of the art techniques.
indeed of the faults discovered by augusto only could be reported by the competing approaches.
our evaluation also shows that aif models are quite resilient to the minor differences that might occur between the different implementations of a same aif across different applications.
for instance in the evaluation our aif models required minor changes only in cases.