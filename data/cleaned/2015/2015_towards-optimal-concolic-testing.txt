towards optimal concolic testing xinyu wang zhejiang university wangxinyu zju.edu.cnjun sun singapore u. of tech.
and design sunjun sutd.edu.sgzhenbang chen national u. of defense technology zbchen nudt.edu.cn peixin zhang zhejiang university zhangpeixin zju.edu.cnjingyi wang singapore u. of tech.
and design jingyi wang mymail.sutd.edu.sgyun lin national university of singapore llmhyy gmail.com abstract concolic testing integrates concrete execution e.g.
random testing and symbolic execution for test case generation.
it is shown to be more cost effective than random testing or symbolic execution sometimes.
a concolic testing strategyis a function which decides when to apply random testingor symbolic execution and if it is the latter case which program path to symbolically execute.
many heuristics based strategies have been proposed.
it is still an open problem what is the optimal concolic testing strategy.
in this work we make two contributions towards solving this problem.
first we show the optimal strategy can be defined based on the probability of program paths and the cost of constraint solving.
the problem of identifying the optimal strategy is then reduced to a model checking problem of markov decision processes with costs.
secondly in view of the complexity in identifying the optimal strategy we design a greedy algorithm for approximating the optimal strategy.
we conduct two sets of experiments.
one is based on randomly generated models and the other is based on a set of c programs.
the results show that existing heuristics have much room to improve and our greedy algorithm often outperforms existing heuristics.
acm reference format xinyu wang jun sun zhenbang chen peixin zhang jingyi wang and yun lin.
.
towards optimal concolic testing.
in icse icse 40th international conference on software engineering may june gothenburg sweden.
acm new york ny usa pages.
introduction concolic testing also known as dynamic symbolic execution is an integration of concrete execution a.k.a.
testing with symbolic execution .
concrete execution and symbolic execution naturally complement each other.
on one hand permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
execution is computationally cheap.
that is we keep sampling test inputs according to a prior probabilistic distribution of all test inputs and concretely execute the program with the test inputs until certain test coverage criteria is satisfied.
the issue is that if a certain program path has very low probability a huge number of test inputs must be sampled to cover the program path.
on the other hand symbolic execution solves this problem by identifying the constraint which must be satisfied in order to cover the program path and solving the constraint to obtain the test input.
in other words the probability of covering the program path with symbolic execution is one1.
the issue is that symbolic execution is often computationally expensive.
intuitively an effective concolic testing strategy should symbolically execute those program paths with low probability and concretelyexecute those program paths whose path conditions are hard to solve.
it is still an open problem on what is the optimal concolic testing strategy.
in the literature there have been multiple attempts on solving the problem .
for instance several heuristics have been developed to answer thequestion which program paths among all program paths do we symbolically execute in concolic testing?
to name a few burnimet al.proposed the cfg strategy which calculates the distance from the branches in an execution path to any of the uncovered statements and selects a branch that hasthe minimum distance.
in godefroid et al.proposed the generational strategy which measures the incremental coverage gain of each branch in an execution path and guidesthe search by expanding the branch with the highest coverage gain.
in liet al.introduced a technique which steers symbolic execution to less traveled paths.
while existingheuristics have been shown to be effective empirically it is unclear whether better performance is achievable or how far they are from the optimal performance.
furthermore existing work has largely neglected the other part of the problem i.e.
how do we switch between concrete execution and symbolic execution to achieve the optimal performance?
to the best of our knowledge this problem wasonly recently discussed in .
the authors compare the effectiveness of random testing and systematic testing methods including but not limited to symbolic execution based on a probabilistic view of programs and present a hybrid strategy which switches from random testing to systematic 1for simplicity we assume that the constraint encoding and solving are perfect and thus there is no divergence.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden xinyu wang jun sun zhenbang chen peixin zhang jingyi wang and yun lin testing when the latter is expected to discover more errors per unit time.
their approach however takes a very abstract view of systematic testing methods and do not consider for instance different strategies on applying symbolic execution.
furthermore their algorithm is very high level and is only validated on simulated models.
in this work we aim to develop a framework which allows us to define and compute the optimal concolic testing strategy.
that is we aim to systematically answer when to apply concrete execution when to apply symbolic execution and which program path to apply symbolic execution to.
in particular we make the following technical contributions.
firstly we show that the optimal concolic testing strategy can be defined based on a probabilistic abstraction of program behaviors.
secondly we show that the problem of identifying the optimal strategy can be reduced to a model checking problem of markov decision processes with costs.
as a result we can reuse existing tools and algorithms to solve the problem.
thirdly we evaluate existing heuristics empirically using a set of simulated experiments and show that they have much room to improve.
fourthly in view of the high complexity in computing the optimal strategy we propose a greedy algorithm which approximates the optimal one.
we empirically evaluate the greedy algorithm based on both simulated experiments and experiments with c programs and show that it gains better performance than existing heuristics in klee .
the remainders of the paper are organized as follows.
section defines the research problem and shows its relevance with an example.
section reduces the problem to a model checking problem and compares existing heuristics to the optimal strategy.
section develops a greedy algorithm which allows us to approximate the optimal strategy.
section presents our implementation and evaluates the greedy algorithm.
section reviews related work and section concludes.
problem definition in the following we define the problem.
without loss of generality we define a program e.g.
java c as follows.
definition .
.
a program is a labelled transition system p c init v t w h e r e cis a finite set of control locations init cis a unique entry point i.e.
the start of the program vis a finite set of variables is a predicate capturing the set of initial valuations ofv t c gc cis a transition function2where each transition is labeled with a guarded command of theform g fwheregis a guard condition and fis a function updating valuation of variables v. a concrete execution a.k.a.
a test of pis a sequence angbracketleft v0 c0 gc0 v1 c1 gc1 vk ck gck angbracketrightwherevi is a valuation of v ci c gci fiis a guarded command 2we focus on deterministic sequential programs in this work.such that ci gci ci t vi satisfiesgi a n dvi fi vi for all i a n dv0 satisfies andc0 init.w es a y covers a control location cif and only if cis in the sequence.
a control location cis reachable if and only if there exists a concrete execution which coversc.
the initial variable valuation v0is also referred to as a test case.
a rooted program path of pis a sequence of connected transitions angbracketleft c1 gc1 c2 c2 gc2 c3 ck gck ck angbracketright such that c1 initand ci gci ci tfor alli.t h e corresponding path condition is pc v2 vk .g1 v2 f1 v1 g2 g k vk fk vk .wewrite path p to denote all paths of program p. example .
.
figure shows a simple java program.
the corresponding transition system is shown in the middle offigure where the commands are skipped for readability.
the transition system contains control locations corresponding to the numbered lines in the program.
we assume that each line is atomic for simplicity.
the initial condition isx int y intwhereintis the set of all integers.
for simplicity we assume that the goal is to generate test cases so that the corresponding concrete executions cover all reachable control locations i.e.
statement coverage .
in the literature there have been many approaches on test case generation .
in this work we focus on two ways of generating test cases.
one is random testing.
to conduct random testing we fix a prior distribution on all the test cases and then randomly sample a test case each time according to .a f t e r w a r d s we execute the program with the sampled test case until it finishes execution.
for instance if we assume a uniform distribution on all test cases for the program shown in figure random testing is to randomly generate a value for x andyand then concretely execute the program.
the cost of random testing in terms of time is often small.
in this work we simply assume that the cost is time unit3.
assume that every test case is associated with certain non zero probabilityin it is trivial to show eventually we can enumerate all test cases through random testing and cover all reachable control locations.
unfortunately in practice we have limited timeand budget and thus we may not be able to cover certain control locations with a limited number of random test cases.
for instance with a uniform probability distribution among all possible values for xandy on average it takes 232random test cases to cover line in figure .
another way of generating test cases is symbolic execution .
given a program path a constraint solver is employed to check the satisfiability of the path condition and construct a test case if it is satisfiable.
afterwards we execute the program with the test case until it finishes execution.symbolic execution may sometimes be more cost effective than random testing.
for instance with the constraint solver z3 we can easily solve the path condition i.e.
x y for visiting line in figure to generate the required test 3the cost of one random testing varies widely in practice.
we will extend our work with variable random testing cost in the future work.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards optimal concolic testing icse may june gothenburg sweden void myfunc int x int y .
if x y .
x .
if x x .
return .
if x y y x .
i f x y .
x x y .
return figure abstraction case.
however symbolic execution may not always be costeffective.
for instance to obtain a test covering line we can apply symbolic execution to solve the path condition which includes the condition at line .
it is likely to be non trivial due to the non linear constraint.
in comparison generating a random test case to satisfy the condition at line is much easier i.e.
on average random test cases are needed.
in general the cost of symbolic execution is considerably more than that of random testing as constraint solving could be time consuming.
furthermore when symbolic execution is applied to generate a test case for covering a certain control location we can either solve the path condition of a path ending withthe control location or the path condition of its prefix.
forinstance in order to cover line we can either solve the p a t hc o m p o s e do fl i n e1 6a n d7 o rt h ep a t hc o m p o s e d of line and once or multiple times to generate test cases.
the latter might be more cost effective as the constraint to be solved has fewer clauses.
in this particular example solving the latter once is sufficient to cover line .
concolic testing is the integration of random testing and symbolic execution.
in this work we define a strategy for concolic testing to be a function which generates a choice between random testing or symbolic execution on a certain path repeatedly until the testing goal is achieved.
two extreme ones are applying random testing always and applying symbolic execution for each program path.
there are many alternative ones .
multiple strategies have been adopted in existing concolic testingengines e.g.
klee pex a n dj d a r t .
as we show above one strategy might be more cost effective than others for certain programs.
for instance for the example shown in figure a better strategy would apply symbolic execution to the path composed of line and to coverline apply symbolic execution to the path composed of and to cover line and apply random testing to cover the rest of the lines.
the question is then how to compare different strategies.
in this work we investigate theeffectiveness of different strategies for concolic testing and answer the following open questions.
rq1 what is the optimal concolic testing strategy given a program?
rq2 can we efficiently compute the optimal strategy?rq3 are existing strategies good approximation of the optimal strategy?
rq4 is it possible to design a practical algorithm to approximate the optimal strategy?
rq5 if the answer to rq4 is positive how does the algorithm compare to existing heuristics?
we answer these questions in the following sections.
we remark that we do not consider strategies which simplify complex symbolic constraints using concrete values in this work.
furthermore we assume that the path condition encoding and solving are perfect and thus there is no divergence.
considering these would considerably complicate the discussion and thus we leave it to future work.
optimal strategy in this section we show that the optimal concolic testing strategy can be defined based on the probability of program paths and the cost of constraint solving.
furthermore it can computed through model checking.
.
markov chain abstraction to answer rq1 we first develop an abstraction of programs in the form of markov chains.
definition .
.
a labeled discrete time markov chain dtmc is a tuple m s pr w h e r esis a finite set of states pr s s r is a labeled transition probability function such that s prime spr s s prime for all s s a n d is the initial probability distribution such that s s s .
a states sis called a sink state if there are no outgoing transitions from s.w eo f t e nw r i t e pr s s prime t od e n o t et h e conditional probability of visiting s primegiven the current state s. the conditional probability pr s s prime is also called as one step authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden xinyu wang jun sun zhenbang chen peixin zhang jingyi wang and yun lin transitionprobability.apathof misasequenceofstates angbracketlefts0 s1 s2 angbracketright.w ew r i t e states to denote the set of states in .l e tpath m d e n o t ea l lp a t h so f m. the probability of written as pr is the product of all the one step transition probability i.e.
pr s0 ipr si si .
given a finite path w ew r i t e last to denote the ending state in the sequence and last to denote the second last state.
we say that a finite path is maximal if last i sa sink state.
we write pathmax m denote all maximal paths ofm.w ew r i t e pathmax s m denote all maximal paths ofmstarting with s.f u r t h e r m o r e w es a yt h a t isnonrepeating if every state in appears at most once.
we write path m s to denote all finite paths which end with state s. the accumulated probability of all paths in path m s i s the probability of reaching s written as prm reach s for simplicity.
similarly we write path m s s prime t od e n o t ea l l finite paths which start with state sand end with state s primeand prm reach s s prime to denote the accumulated probability of all paths in path m s s prime .
in the following we develop a dtmc interpretation of a program which forms the basis of subsequent discussion.
definition .
.
letp c init v t be a program and be a prior probability distribution of the test inputs.
the dtmc interpretation of pis a dtmc mp s pr such that a state in sis a pair v l w h e r e vis a valuation ofvandlis a control location in c a n dpris defined as follows pr v l v prime l prime if and only if there exists a guarded command gc fsuch that t l gc l primeandv satisfiesg andv prime f v otherwise pr v l v prime l prime .
note that in the above definition each one step transition has probability or except the initial probability distribution .
our optimal concolic testing strategy is defined based on one particular abstraction of mp i.e.
the one which abstracts away the variable valuation defined as follows.
definition .
.
letp c init v t be a program andmp s pr be its dtmc interpretation.
the dataabstract dtmc interpretation of pis a dtmc ma p sa pra a such that sa c. it is useful since we focus on statement coverage in this work.
a l 1i flisinit a n d0o t h e r w i s e andprais defined as follows for all l candl prime c pra l l prime i s pr s s prime.
path mp s prime l prime 2last s l pr s. path mp s l intuitively pra l l prime is the probability of visiting land immediately followed by l prime over the probability of reaching l. for instance the dtmc shown on the right of figure is the data abstract dtmc interpretation of the program on the left where each control location in the program becomes a state in the dtmc and each control flow between two control locations is associated with the corresponding conditional probability.
for instance the probability1 232labeled with the transition from state to states that the probability of visiting state after state is1 if we assume a uniform distribution among all test inputs .the following proposition states that the probability of reaching a control location lis preserved in ma p. proposition .
.
letp c init v t be a program and be a prior probability distribution of the test inputs.
for alll c prma p reach l v va l v prmp reach l v wherevalvis the set of all possible valuations of v. square the correctness of the proposition can be established by showing the probability of reaching any l primeis l c prmap reach l pra l l prime at e s te x e c u t i o no f pcan be naturally mapped to a path of ma p. for instance the test execution with input x y given the program shown in figure is mapped to the path c o m p o s e do fs t a t e1 a n d8 .w es a yt h a tat e s t execution covers a state of mapif it covers the corresponding control location of p.f u r t h e r m o r e ap a t hi n mapuniquely corresponds to a program path in p. .
optimal strategy recall that a concolic testing strategy is a sequence of choices among different test case generation methods.
in this work we define the space for the choice to be rt se p p path p wherertdenotes random testing and se p denotes symbolic execution by solving the path condition associated with pathp.
to compare the cost of different choices we need a way of measuring them.
we focus on time cost in this work.
letcostbe a function which given a rt se p p path p returns its time cost.
for simplicity the time cost of generating a random test case is set to be unit.
the time cost ofse p includes the time cost of encoding solving the path condition.
we measure the effectiveness of a choice in terms of the probability of covering a set of states in p. given a choice a rt se p p path p and a set of states xof ma p we can compute the probability of covering exactly the set of states xwith random testing as follows.
pr rt x pathmax ma p states xpr for the example shown in figure pr rt i s1 andpr rt is since there is no test case which covers and at the same time.
if the choice is symbolically executing program path p i.e.
se p we know that all states in the path p written asstates p must be covered.
let s last p pathmax s ma p states states p x be the set of all maximal paths which start with the last state of path p and together with p cover all and only states in x.t h e probability of covering all and only states xwithse p written as pr se p x is defined as follows.
pr se p x 0i f states p negationslash x 0i f states p negationslash x 1i f states p x pr e l s e authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards optimal concolic testing icse may june gothenburg sweden figure mdp with cost model for the example shown in figure pr se is4 i.e.
by symbolically execute path and we have probability4 5of covering state and .
for another example pr se i s0s i n c ew em u s tc o v e r3 .
in this work we assume that the choice can be made depending on whether certain states have been covered or not.
this makes sense intuitively since if all states along a pathhavebeencovered itisagoodideanottoapplysymbolic execution to that path.
a strategy is thus a function which takes as input information on whether each control location inphas been covered or not and returns a choice of test case generation methods.
to compare different concolic testing strategies systematically we build the following model in the form of a markov decision process mdp with costs.
definition .
.
letma p s pr be the data abstract dtmc interpretation of a program p. we define dp covered act t c be an mdp with costs such that covered ps w h e r e psis the power set of s i.e.
each member of psis a set of states in s i.e.
those which have been covered act rt se p p path p covered is the initial state which is tis defined such that t m a w h e r e m covered anda actis a probability distribution defined as follows n x ps.
x m npr a x for all n covered .pr a x is defined by and above.
cassociates a cost for each a actas defined by function cost.
for instance given the following simple program void myfunc2 int x .
if x .
x .
else x .
return x we can obtain the data abstract markov chain model shown on the left of figure and the corresponding dpshown on the right.
the initial state of dpis i.e.
none of the states have been covered.
applying rtat the initial state we have a distribution such that with probability .
we reach state i.e.
state and are covered and with probability .
we reach state .
if instead symbolic execution on path angbracketleft1 angbracketrightis applied i.e.
se we have probability of reaching state .
note that if we apply symbolic execution on path angbracketleft1 angbracketrightat state w e reach again with probability which is represented by the self looping transition at state .
assuming thatcost rt cost se cost se and cost se cost se we can then compute the expected cost of a concolic testing strategy based on the accumulated cost of each choice.
for instance the expected cost of always applying rtis whereas the expected cost of applying se and then se is .
with definition .
we can see that a strategy for concolic testing is equivalent to a policy of dp i.e.
a function from s primetoact.
the following then answers rq1.
answer to rq1 the optimal strategy is the policy of dp which has the minimum expected cost.
for instance in the example shown in figure the optimal strategy is the one which applies rtalways with an expected cost .
the problem of finding the optimal strategy is thus reduced to the problem of finding the policy with the minimum expected cost which can be solved using existing methods like value iteration policy iteration or solving a linear programming problem.
the computational complexity of finding the optimal strategy is thus bounded by the complexity of identifying the optimal policy.
answer to rq2 the complexity of identifying the optimal strategy is strongly polynomial in the number of states in dp which in turn is exponential in the number of control locations in p. .
evaluating existing heuristics in the following we conduct experiments to answer rq3empirically.
that is we compare the performance of the optimal strategy with that of the heuristics based ones .
the goal is to see whether existing heuristics are reasonably effective.
we randomly generate a set of markov chain models with no unreachable states which we take as abstractions of programs.
due to the high complexity in computing the optimal strategy we generate models containing to 20states only using the method in .
for every state with probability .
we generate a branch i.e.
the expectedbranch density is .
.
we randomly generate a transitionprobability for each transition.
to mimic low probability program paths we generate transitions of probability as low as 1e with probability .
for states models to avoid not having low probability transitions and .
to avoid not having too many low probability transitions for or 20states models.
in order to simplify the experiments instead authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden xinyu wang jun sun zhenbang chen peixin zhang jingyi wang and yun lin of associating a cost of symbolic execution for each path we associate each transition in the model with a positive integer cost4within .
we construct the corresponding mdp with cost models for each markov chain and use prism t o compute the optimal strategy.
the results are shown in table where first column shows the strategy and the rest shows the results obtained with random state markov chains random state markov c h a i n s e t c .r o w optimalis the expected cost of the optimal strategy which has been normalized to .
the rest of the rows are the result of random testing rt the four strategies in klee the default random cover new rcn random state search rss random path selection rps and depthfirst search dfs the directed automated random testing in dart generational search gs in sage context guided search cgs in and sub path guided search sgs in .
the length of sub path in sgs is set to be of the the total number of states in the model.
the last row is to be ignored for now.
we use java to implement all approaches.
for each markov chain model we repeat each strategy times and obtainthe mean cost to cover all the states .
note that for randomtesting it may take an extremely long time to cover all states thus we set a limit of test cases .
from the results we observe that all existing heuristics result in significantly higher costs than the optimal cost.
even the best performance heuristics has a cost which is one order of magnitude higher than the optimal one.
among all strategies the strategy which adopts random testing every time performs the worst when there are states.
the results show that existing heuristics have much room to improve.
note that the results show in table should be taken with a grain of salt sincethey are based randomly generated markov chain models which may not be representative of real programs.
answer to rq3 existing heuristics could be improved.
approximating optimality based on the discussion in section it is clear that identifying the optimal strategy in practice is infeasible due to its high complexity as well as difficulties in identify the probability of program paths and the cost of symbolic execution.
in the following we propose a method to approximate the optimal strategy in practice.
our proposal includes a way of approximating ma p a way of approximating function cost and a greedy algorithm for identifying optimal policy.
.
estimating ma pand function cost in the following we present an approach to estimate ma p s pr .
note that this is the subject of a recent line of research known as probabilistic symbolic execution .
however probabilistic symbolic execution has a high complexity due to the underlying model counting techniques .
4this effectively assumes solving a constraint takes less time than solving which may not be always true.
states states states states optimal rt .
.
.
.7rcn .
.
.
.
rss .
.
.
.
rps .
.
.
.5dfs .
.
.
.
dart .
.
.
.
gs .
.
.
.3cgs .
.
.
.
sgs .
.
.
.
g .
.
.
.
table simulated experiments we thus apply a lightweight approach i.e.
we estimate pr based on the test cases which have been obtained.
the essential problem that we would like to address is if we have observed certain events i.e.
test cases which cover certain program paths how do we estimate the probability of the seen events and those unseen events i.e.
test cases which cover other program paths ?
this problem has been studied for decades and a number of methods have been proposed e.g.
the laplace estimation and good turing estimation .
we refer the readers to for comprehensive discussion on when different estimations are effective.
in the following we show how to estimate ma pbased on the laplace estimation.
assume that we have obtained a set of test executions x we can estimate pras follows.
definition .
.
given any state s s l e t sbe the number of times state sis visited by samples in x. for any t s l e t s t be the number of one step transition from statestotinx.
for any state s if it is impossible for s to reach another control location tinp w es e t pr s t t o be otherwise the laplace estimation sets pr s t t ob e s t s n w h e r enis the total number of states scan reach with one step.
intuitively if a transition i.e.
a control flow from state s totis not observed in xbecausepr s t is small the laplace estimation sets the transition probability to be1 s n.i ti s easy to see that the estimated prconverges to the actual pr with an unbounded number of samples.
in the following we writeestimate p x to denote the estimated map.
estimating function cost i.e.
the cost of constraint solving is highly nontrivial due to the sophisticated constraint solving techniques adopted by constraint solvers like z3 .
it is itself a research topic .
in this work we adopt the approach in which works as follows.
firstly the authors of collectedthetimecostsofsolvingconstraintsgenerated from analyzing a set of real world programs through symbolic execution.
assuming the cost of constraint solving is the weighted sum of the primitive operations e.g.
the addand muloperation in the constraint they then estimate the weight of each primitive operation type through function fitting.
afterwards given a constraint c its solving cost is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards optimal concolic testing icse may june gothenburg sweden estimated as the weighted sum of all primitive operations in c. for example if cisa b its solving cost is the sum of weighted cost of multiplication and that of the greater than comparison.
we refer the readers to for details.
.
a greedy algorithm even with a reasonable approximation of ma pand function cost the algorithm for identifying the optimal strategy remains overly complicated refer to the answer to rq2 .
in the following we present a greedy algorithm with much lower complexity.
the idea is to estimate ma pon the fly and apply a test case generation method which improves test coverage in the most cost effective way locally based on the estimation.
the details are shown in algorithm .
at line we start with an empty set of test cases.
at line we initialize a settoignore for storing paths which are to be ignored for symbolic execution.
the loop from line to iteratively generates test cases until the coverage criteria is achieved.during each iteration we first construct an estimation of ma pat line .
afterwards we call function localoptimal to choose the local optimal test generation method.
if the choice is random testing we generate a random test case at line otherwise we apply symbolic execution to the selected program path.
if the selected path is infeasible or solving the path condition times out we add the path into toignore.
function localoptimal m x toignore is shown in algorithm .
intuitively we define the reward of a test generation method to be the number of uncovered states which is expected to be covered with the newly generated test case and select the method with the largest expected reward per unit of cost.
at line we first compute the expectedreward of random testing based on the current estimation m s pr .
it is computed by extending mwith reward i.e.
unit reward is associated with one unvisited state and solving the problem of expected reward using existing methods .
in the following we show how it can be solvedby solving an equation system.
letr swheres sbe the reward of visiting s. we build an equation system as follows.
rs braceleftbigg t s pr s t rt ifs negationslash visited t s pr s t rt ifs visited the expected reward of random testing is then s s s rs .
note that we associate one reward for visiting each unvisited state since our goal is to cover every state.
next we compare the expected reward of random testing to that of symbolic execution.
ideally we would compute the cost of symbolically executing every path as well as the corresponding reward and then choose the most profitable one.
however the number of such paths is often huge i.e.
infinite if there are loops .
thus we heuristically focus on paths which contain no uncovered states except the ending state.
this way it is guaranteed to visit at least unvisited state if symbolic execution is applied.
note that similar to we assume that a bound on the number of iterations for any loop is provided and we only consider paths withalgorithm greedy p w h e r e pis a program and a prior distribution on test inputs 1letxbe an empty set of test cases 2lettoignore be an empty set of paths 3whilethere is an unvisited control location do 4letmbeestimate p x 5leta localoptimal m x toignore ifais random testing then randomly generate a test case taccording to addtintox ifaisse p then solvepcpto generate a test case t ifpis unsatisfiable or solving pcptimes out then addpintotoignore else addtintox 15returnx algorithm localoptimal ma p x toignore 1letvisitedbe the set of visited states given x 2letrewardbe the expected reward of random testing 3lettoreturn berandom testing 4forall path s.t.
the only uncovered state is last do if negationslash toignore then letreward be the expected reward of solving ifreward cost r e w a r d then toreturn se reward reward cost 9returntoreturn fewer iterations.
the expected reward of applying symbolic execution to the path ending with state sis denoted as rs which can be obtained using the same equation system discussed above.
the details are shown in algorithm line to .
at line we check if the selected path is to be ignored.
if it is not we compute the expected reward of solving b ys o l v i n gt h e same equation system to obtain rswheresis the ending state of .
intuitively this is because by solving the path we have probability one of visiting sand obtaining all of its expected reward.
that is if last i ss reward isrs.a t line we compare the reward per unit cost where function costis approximated as discussed in section .
of se and the current best choice and keep the better one.
note that we assume the path condition is precise.
if a test input generated by solving the path condition diverges and thus not reach s w ea d dt h ep a t ht otoignore as well.
in the following we illustrate how the algorithm works for the program shown in figure .
for illustration purpose we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg swedenxinyu wang jun sun zhenbang chen peixin zhang jingyi wang and yun lin figure abstraction assume that solving a linear in equality or their conjunctions has time cost solving a non linear in equality has cost of and solving a boolean combination of non linear in equalities has cost of .
initially since we have no test executions yet the estimation mis shown at the left of figure where uncovered states are dash lined.
note that all outgoing transitions from the same state have the same probability.
based on this estimation we compute that the expected reward of random testing by solving the following equation systems.
r1 .
r2 .
r3 r2 r3 r3 .
r4 .
r5 r5 .
r8 .
r6 r6 .
r8 .
r7 r7 r8 r4 r8 the expected reward of random testing is s1 r1which is .
.
since all states are unvisited the candidate path we select for symbolic execution is the one containing state only.
since the path condition is true applying symbolic execution to this path is the same as random testing.
note that this implies that we always start with random testing.
assume that the random test case we generate covers control location and .
the estimation is then updated as shown on the middle of figure .
next we compute the expected reward of random testing by solving the following equation systems.
r1 r2 r3 r2 r3 r3 r4 r5 r4 r5 r8 r6 r6 .
r8 .
r7 r7 r8 r8 0we have r1 r2 r4 1a n d r6 .
.
the candidate paths for symbolic execution include the path from 1t o2 t h ep a t hf r o m1 t o4 a n dt h ep a t hf r o m1 t o6 .
the costs are and respectively.
the expected rewards are5 and .
respectively.
thus the chosen method is random testing.
for simplicity assume that the first random test executions all cover and .
as a result mis updated as shown on the right of figure .
the expected reward of random testing is computed as .
whereas the e x p e c t e dr e w a r do fs o l v i n gt h ep a t hf r o m1t o2i s1 .
.w e thus conclude that the latter is more cost effective with a reward per cost .
and thus apply symbolic executionto the path.
intuitively we switch from random testing tosolving certain program path only when covering the path requires a large number of random test cases which would cost more than that of symbolic execution.
the complexity of algorithm is reasonable.
in order to choose the right test case generation method during each round we pay the price of solving an equation system whosenumber of variables equals to the number of control locations in the program.
modern equation system solvers are often rather efficient and the overhead is reasonable.
we can further optimize the algorithm for solving the equation system since rschanges after one iteration only if scan reach a state which has been newly covered.
evaluation to answer rq4 we first compare the performance of our greedy algorithm against the optimal strategy using the randomly generated markov models as in section .
.
that is we run the greedy algorithm assuming that we know the cost of constraint solving but not the transition probability and measure its performance.
in other words the transition probability is estimated on the fly as shown in algorithm .
the results are shown in the last row of table .
it can be observed that compared with the existing heuristics the greedy algorithm offers better performance.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards optimal concolic testing icse may june gothenburg sweden answer to rq4 it is possible to design a practical algorithm to approximate the optimal strategy.
so far we have experiment with different strategies on abstract models.
in order to answer rq4a n drq5 based on real world programs we implement our approach based on klee .
note that klee is a symbolic execution engine i.e.
it only maintains the symbolic values of symbolic variables.
we thus first extend klee with a concolic execution engine which maintains both the symbolic and concrete values of each variable.
as a result we are able to switch between random testing and symbolic execution at runtime according to the greedy algorithm if necessary .
during symbolic or concrete execution when a branching statement is encountered we fork a state which corresponds to the un selected branch without considering its feasibility.
to estimate ma p we first construct the inter procedural control graph icfg whose nodes are the states of map.
the transition probability is then estimated on the fly as in algorithm .
recall that we need to solve an equation system to select the local optimal test generation method.
in our implementation we use eigen to solve the equation system.
when the choice is symbolic execution the path constraint of the symbolic state is solved to check the state s feasibility.
if the state is not feasible the path is marked infeasible.
if the choice is random testing we generate a random test case with concrete values.
experimental setup to evaluate the effectiveness of different concolic testing strategies we need a set of programs which contain complicated path conditions so that constraint solving the path conditions takes a non trivial amount of time as well as non trivial control flow so that different strategies may choose different test generation methods or paths .
we use the programs in gnu scientific library gsl .
functions in gsl often have both complex arithmetic operations and complex control flow.
gsl has been previously analyzedusing klee .
we rank the functions in gsl using the code coverage which was achieved in the previous study for each function and choose the functions with the lowest cover age.
table lists the functions used in our experiment wherethe second column shows the number of nodes in the icfg of the function i.e.
the number of basic blocks in the function or invoked functions .
note that we filter functions which have complex input types such as function pointers complex arrays and complex struts.
to analyze these programs wehave implement the method in for analyzing floating point programs.
the basic idea is to convert floating point operations to the integer simulation functions.
we use softfloat as the library in our implementation.
furthermore under constrained symbolic execution is implemented for analyzing arbitrary functions.
for baseline comparison we compare our approach with the four search heuristics supported in klee as explainedtable programs in the experiments name nfunction in gsl fg0 ser coulomb fg0 series fgmhalf coulomb fgmhalf series dilog xge0 dilog xge0 chi e gsl sf chi e bessel inu gsl sf bessel inu scaled asymp unif e bessel jy gsl sf bessel jy mu restricted bessel knu gsl sf bessel knu scaled asymp unif e bessel cos gsl sf bessel cos pi4 e bessel sin gsl sf bessel sin pi4 e coupling gsl sf coupling 6j e elljac e gsl sf elljac e exprel n e gsl sf exprel n e hyperg u gsl sf hyperg u large b e lngamma e gsl sf lngamma e lnpoch sgn gsl sf lnpoch sgn e lnpoch pos lnpoch pos cyc solve cyc tridiag cyc non solve cyc tridiag nonsym tri solve tridiag tri non solve tridiag nonsym in section .
.
notice that tools implementing other searching strategies e.g.
are either not maintained or target different programming languages.
each function is analyzed using strategies and we measure the instruction coverage achieved with different timeouts.
our experiments were conducted on a server having 64gb ram and .2ghz xeon cpus with cores.
the timeout for each constraint solving is seconds.
the cost of constraint solving is estimated using the formula in .
each experiment is repeated times and we report the average as the result.
our implementation and programs are available at .
evaluation results table shows the coverage achieved for each function with a timeout of minutes minutes and minutes respectively where column gis the result of our greedy algorithm and r is the always random testing strategy.
the winner for each setting is highlighted in bold.
note that due to randomness it is not always guaranteed that better coverage will be achieved with more time.
it can be observed that our greedy algorithm not only achievesmuch better coverage but also achieves it much faster.
for instance after minutes our greedy algorithm covers .
of the instructions whereas all klee strategies cover less than .
after minutes our coverage is .
whereas klee strategies are less than .
note that random testing achieves better performance than klee strategies as well although worse than our strategy .
this result suggests that existing concolic testing strategies should better integraterandom testing and our strategy offers an effective way to achieve that.
figure visualizes the trend of coverage over time for each strategy.
it can be observed that within one minute ourgreedy strategy is able to achieve a much higher coveragethan those in klee.
this is because we are able to strategically choose the most rewarding method each time and cover those easier to cover instructions quickly.
afterwards our strategy slowly gains more coverage by solving path authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden xinyu wang jun sun zhenbang chen peixin zhang jingyi wang and yun lin 30average coverage analysis timeg rcn rss rps dfs r figure average coverage w.r.t.
analysis time.
programs5 minutes minutes minutes se rt se rt se rt fg0 ser fgmhalf series dilog xge0 chi e bessel inu bessel jy mu bessel knu bessel cos bessel sin coupling 6j elljac e exprel n e hyperg u lngamma e lnpoch sgn lnpoch pos cyc tridiag cyc tridiag non tridiag tridiag non table number of times of rt and se conditions which are hard to solve or generating random test cases.
in general other strategies gain slightly more coverageafter the first minute too although not always.
in a few cases e.g.
dilog xge0 a boost in the coverage is observed with the rps strategy at minutes timeout.
this is likely because the strategy switches to solving a different path which leads to many uncovered instructions.
in order to get a view on the choice of test case generation methods by our strategy we summarize in table the number of times random testing and symbolic execution are applied.
note that each entry in the table correspondsto a different run with different timeout and thus it is not guaranteed that the numbers in the minutes column are the largest.
it can be observed that our strategy does not always favor one method over another.
furthermore the ratiobetween the number of times random testing is chosen and that of symbolic execution varies significantly from function to function.
for instance for the last four functions due to the complex path conditions random testing is consistently the choice which turns out to be effective in achieving high coverage.
function exprel n e shows another extreme i.e.
symbolic execution is often the choice due to its simple constraints.
this suggests that our strategy adapts to different functions.
answer to rq5 our greedy algorithm outperforms existing heuristics in klee.
threats to validity.
our test subjects are all numeric functions and thus the results could be biased.
we plan to apply the proposed approach to other programs e.g.
programs operating on non trivial data structures to further validate its effectiveness in general.
related work this work is closely related to many existing searching strategies for concolic testing.
besides those mentioned inprevious sections there are other search heuristics.
in liuet al.proposed to empirically predict the cost of solving a path constraint and prioritizes those paths with smaller solving cost.
in parket al.proposed the carfast strategy which always selects a branch whose opposite branch is not yet covered and has the highest number of statements control dependent on that branch.
xie et al.
introduced a fitness guided path exploration technique which calculates fitness values of execution paths and branches to guide the next execution towards a specific branch.
the fitness function measures how close a discovered path is to a not yet covered branch.
marinescu et al.
guides symbolic execution towards the software patches.
it exploits a provided test suite to identify a good test case and uses symbolic execution with several heuristics to generate more related inputs to test the patches.
in seoet al.proposed the context guided search strategy which selects a branch under a new context i.e.
a lo cal sequence of branch choices for the next input generation.in cadar et al.applies a best first search strategy which checks all execution states and forces symbolic execution towards dangerous operations e.g.
a pointer de reference .
compared with the above mentioned approaches ours is the first one to formally define what is the optimal strategy and subsequently develop a practical algorithm.
we provide a framework for systematically comparing the effectiveness of random testing and symbolic execution.
this work is related to work on combining random testing and symbolic execution.
besides which have been discussed in section kong et al.
discussed different strategies on combining random testing and symbolic ex ecution in the setting of verifying hybrid automata.
they too make use of transition probability and cost in choosing where to apply symbolic execution.
however their approach remains a heuristics i.e.
choosing a branch with low cost authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards optimal concolic testing icse may june gothenburg sweden programs5 minutes minutes minutes grcn rss rps dfs r grcn rss rps dfs r grcn rss rps dfs r fg0 ser .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
fgmhalf .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
dilog xge0 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
chi e .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bessel inu .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bessel jy .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bessel knu .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bessel cos .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bessel sin .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
coupling .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
elljac e .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
exprel n e .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
hyperg u .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
lngamma e .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
lnpoch sgn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
lnpoch pos .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
cyc .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
cyc non .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tri .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tri non .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
t a b l e3 c o v e r a g er e s u l t s similar to the approach in as there is no definition of the optimal strategy.
hybrid concolic testing combines random testing and concolic testing.
the idea is to start with random testing to quickly reach a deep state of the program by executing a large number of random test cases.
when the random testing stops improving coverage for a while it switches to concolic testing to exhaustively search the state space from the current program state.
garg et al.
proposed to combine feedback directed unit test generation with concolic testing.
they start with random unit testing similar to randoop and switches to concolic testing when the unit testing reaches a coverage plateau.
a similar i d e aw a sp r o p o s e di n .
compared to the above mentioned approaches our method formally analyzes the effectiveness of random testing and symbolic execution and allows us to choose the more effective in every iteration.
this work is remotely related to work on reducing the cost of symbolic execution and concolic testing through methods like pruning paths and parallelism .
conclusion in this work we propose a framework to derive optimal concolic testing strategies based on which we analyze existing heuristicsandproposeanewalgorithmtoapproximatetheoptimal strategy.
the evaluation on randomly generated modelsand a set of real world c programs shows that our algorithm outperforms most existing heuristic based algorithms often.
for future work we would like to investigate alternative ways of estimating probability and solving cost of program paths.
furthermore we would like to extend our framework to other test case generation methods.
acknowledgement this research was supported by singapore ministry of education grant moe2016 t2 and the national basicresearch program of china the program under grant 2015cb352201 nsfc program no.
.
the third author is supported by nsfc program and .