conc ise incremental symbolic execution of concurrent software shengjian guo markus kusano department of ece virginia tech blacksburg va usachao wang department of cs university of southern california los angeles ca usa abstract software updates often introduce new bugs to existing code b ases.
prior regression testing tools focus mainly on test case sel ection and prioritization whereas symbolic execution tools only h andle code changes in sequential software.
in this paper we propo se the first incremental symbolic execution method for concurrent software to generate new tests by exploring only the executions a ffected by code changes between two program versions.
specifically we develop an inter thread and inter procedural change impa ct analysis to check if a statement is affected by the changes and the n leverage the information to choose executions that need to b e reexplored.
we also check if execution summaries computed in t he previous program can be used to avoid redundant exploration s in the new program.
we have implemented our method in an incremental symbolic execution tool called conc ise and evaluated it on a large set of multithreaded c programs.
our experiments s how that the new method can significantly reduce the overall symb olic execution time when compared with state of the art symbol ic execution tools such as klee.
ccs concepts software and its engineering software verification and validation software testing and debugging software evolution keywords symbolic execution concurrency partial order reduction weakest precondition .
introduction as software evolves updates made from the addition of new fe atures or patches may introduce new bugs.
while some regressi on testing tools can leverage code changes between two softwar e versions to reduce the testing cost they focus primarily on sel ection and test case prioritization as opposed to the creation of ne w test cases.
in contrast symbolic execution is a technique for au tomatically generating new tests and more recently has been used in regression testing to reduce the overall cost fo r sequential software testing.
specifically prior work uses a c onservative static analysis to estimate the impact of the code chang es andnew program p old program p concurrent change impact analysissummaries of p transferred to p symbolic executionpruning the redundant state current input in sch generate new input in sch figure summary based incremental symbolic execution.
then leverage the information to avoid re executing progra m paths that are not affected by these code changes.
however these m ethods only handle code changes in sequential software.
furthe rmore they rely on an overly conservative analysis to estimate the change impact without making use of the more accurate information available from previous symbolic execution runs.
in this paper we propose conc ise an incremental symbolic execution method for concurrent programs.
figure shows th e overall flow of our new method.
we take old p and new p program versions together with a set of execution summarie s of p as input and iteratively explore new execution paths throu ghp .
as we will show we use supplementary information from p the execution summaries as well as code changes between pandp to perform the incremental analysis.
the standard and non incremental symbolic execution proce dure is shown in the lower half of figure which starts from an arbitrary initial test in sch ofp and repeatedly generates new tests forp .
here indenotes the data input and schdenotes the thread interleaving schedule.
we assume p is a deterministic program whose execution is completely decided by the pair in sch .
during symbolic execution new states are generated to expl ore alternate branches and alternate thread interleaving schedu les.
for each new state the symbolic execution engine generates a ne w pair in sch containing the data input and thread schedule to reach the new state.
in the non incremental approach no informat ion about previously explored executions in pand code changes made top are used to determine if a state is redundant program executions equivalent to behavior in pare re explored in p .
incremental symbolic execution in contrast considers tw o program versions pandp while assuming pis a prior version that has already been explored symbolically.
the goal is to explo re only the new behavior in p .
prior works on incremental symbolic execution for sequential programs used a f orward change impact analysis built on the idea of program slicin g to determine if a statement in p was affected by a modification only affected portions of the code in p were explored again during permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
symbolic execution.
our first insight is that performing a ch angeimpact analysis using a conservative static analysis alone often results in the testing of redundant executions.
this is becaus e a conservative static analysis such as program slicing ignore s the actual values of variables in the program.
as we will show in section even if a statement is modified from ptop it may be that paths affected by this modification are equivalent to some paths in the previous version.
to define a more accurate equivalence class of execution paths we make use of the execution summaries from pwhile testingp as opposed to performing only a conservative changeimpact analysis.
at a high level the execution summaries d efined at each global control state capture the set of all explored executions starting from s. the summaries are computed backwardly using a weakest precondition computation.
we also propose an inter thread and inter procedural chang e impact analysis for handling both sequential and concurrent p rograms.
it consists of a forward analysis and a backward analysis.
th e forward change impact analysis computes the set of statements that may be affected by code changes from ptop this is used to avoid executing portions of p unaffected by statements that are changed fromptop .
the backward change impact analysis computes the set of statements that may affect statements that are changed from ptop this is used to determine if an execution summary from the old version pcan be carried over to the new version p .
intuitively in both cases if a code modification in p only affects a small number of statements then much of p is the same as p. the combination of execution summaries and change impact a nalysis as well as their interaction with the baseline symbo lic execution procedure is shown in figure .
recall that prior in cremental symbolic execution techniques only hand led sequential programs whereas conc ise is the first incremental symbolic execution algorithm capable of handling concurrent p rograms.
specifically when a new state in p is generated we check both the change impact information and the execution summaries to s ee if the state is in the unmodified section of the program or if it i s equivalent to some previously explored execution in p. if either condition is true then the new state is redundant and can be skippe d. conc ise differs from the prior works on regression testing of multithreaded programs .
in jagannath et al.
and yu et al.
for example the primary focus was on test case selection and test case prioritization i.e.
to detect certain c oncurrency bugs quicker by heuristically selecting test cases and sche duling them in certain orders as opposed to generating new test cas es.
in contrast our method focuses on making symbolic executio nincremental which will benefit test case generation.
our method also differs from the work by terragni et al.
which symb olically analyzes the alternative interleavings of some conc rete executions based on the trace logs.
unlike our method it does no t perform symbolic execution based test input generation to e xplore both intra thread program paths and inter thread interlea vings.
we have implemented our method in a software tool using llvm and cloud9 .
we used llvm to implement our forward and backward change impact analysis algorithms and used the k lee symbolic virtual machine in cloud9 as the baseline to implem ent our incremental symbolic execution algorithm.
we also exte nded klee to robustly handle posix thread routines and implement the state of the art dynamic partial order reduction dp or technique .
we evaluated conc ise on a large set of multithreaded c programs including benchmarks from the software verifica tion competition and real world applications that are open source implementations of non blocking data structures .
in t otal our benchmarks contain programs with a total of different versions and lines of code.
empirically we showed our me thod can significantly reduce the overall testing time when compa red with state of the art symbolic execution techniques.
to sum up this paper makes the following contributions x y a x y x b y a x y x modified b y assert a assert b figure example program old left and new right versio ns.
a x n1 n2 n4 n7n5n3 n6 n8 n9x y y b y b y y 1 4 5x b y a x a x a x 2 3 6 figure interleaved executions of old version 1 ... .
we propose an incremental symbolic execution algorithm capable of handling code changes in both sequential and concurrent programs.
we develop a new execution summary based algorithm for pruning away redundant paths and thread interleavings during incremental symbolic execution.
we implement our new method in a software tool and evaluate it on a large set of benchmarks to demonstrate its effectiveness at decreasing regression testing time.
.
motiv ating examples in this section we illustrate the main ideas behind our new m ethod.
.
pruning with change impact analysis consider the example in figure .
the old program on the lefthand side has two threads accessing the shared variables xandy.
they are initialized to and respectively.
after execut ing both threads the two assertions are checked.
the new program is s hown on the right hand side the only modification between the two programs is on line where x is changed to x .
first note that although the modification is in the second thread due to the s haring of variable x line in the first thread is also affected.
such impacted instructions cannot be identified by existing algori thms since they were not designed for analyzing concurren t programs our new change impact analysis solves this problem.
second there are six possible executions of the old program as shown in the abstract state transition graphs in figure .
st ate ofthe art partial order reduction por techniques can reduce the number of executions to four.
our method does even be tter by reducing the number of executions to two.
specifically in figure each node denotes a global control state e.g.
n1 means thread is at line and thread is at line while n2 means they are at lines and .
after por only four executions remain as shown in the left hand side execu tion tree in figure .
the reason why 2and 6are skipped is because they are equivalent to 1and 5 respectively.
that is executing the two independent instructions y andx in different orders lead to the same result.
532n1 n2 n4n3 n6y n5 n7 n7 n7 n8 n8a x n8a x n5 x x b y y y n9 n9 n9 n9 n9 n9 a a b y y b y a a 1 4 3a x x b y a 5b y b y y y a modified x modified x modified n1 n2 n4n3 n6y n5 n7 n7 n7 n8 n8a x n8a x n5 b y y y n9 n9 n9 n9 n9 n9 a a a a b y b y a a 1a x b y y y b y y x 4 figure executions explored by incremental symbolic exec ution in the old program left and the new program right .
by leveraging the concurrent change impact analysis our m ethod can identify even more redundant executions than por.
speci fically since the code change on line does not impact line or line or assert b we do not need to re explore the different execution orders of y andb y. because of this reason as shown in the right hand side tree in figure our method c an reduce the four executions to two 1and 4 .
in this work we assume that assertions are embedded in the in dividual threads.
as such the assertion conditions always re fer to local variables or local copies of global variables which is consistent with the assumptions made in prior works on por .
it is worth pointing out that in this example the assertion co nditions are also important if the assertion were assert a b then it is no longer safe to skip 3and 5. details of our new change impact analysis algorithm and its application to incremental symb olic execution are presented in section .
.
pruning with execution summary in addition to leveraging the forward change impact analys is we also propose an orthogonal pruning technique based on a back ward change impact analysis.
that is instead of computing the s et of instructions that may be affected by the changed instructions we compute the set of instructions that may affect the changed instructions .
details of the backward change impact analysis and its application are presented in section .
here we briefly illust rate the main ideas using an example.
consider the two versions of a sequential program in figure where the old version is on the left and the new version is on t he right.
the only modification is on line the condition is cha nged from x to x .
from the forward change impact analysis described in section .
or for that matter existing me thods for incremental symbolic execution we know that al l the other lines in the new program are affected by the change.
the refore it seems that no redundant executions can be pruned awa y. however if we divide the initial program state into three su bsets denoted x x and x respectively then it is clear that only when x the modified program behave different from the original program.
in the old version such case w as handled by paths 3and 4 but in the new version it is handled by paths 1and 2. therefore instead of re exploring all four paths we only need to re explore 1and 2. the question then is how to figure out algorithmically that paths 3and 4are indeed redundant.
our solution in conc ise is to compute for each global control state s a summary of all the explored executions starting from sin the old program version.
for example the summary at n4 with respect to assert b ne ationslash would beps y x ne ationslash y x ne ationslash .
this summary is created from the union of the weakest preconditio n of b ne ationslash along the two outgoing paths.
if x a x else a x if y b a else b a assert b!
if x modified a x else a x if y b a else b a assert b!
b a n1 n2 n5n4 n5a x n6 n8 y n9 n9b a 1 4 x 2n6 b negationslash 3n8a x n9 b negationslash b negationslash y y y or x x b negationslash moved b a b a n9 figure although all instructions are impacted by the code change on line not all four paths need to be re explored.
since the code changes on line does not affect the aforementioned weakest precondition computation the summary can b e carried over to the new program.
during the analysis of the new pr ogram we can stop an execution as soon as the path condition d enotedpcon x falls within the set ps of explored executions.
this early termination is safe because if pcon ps is unsatisfiable re exploring the executions starting fro m n4would not lead to any new error.
.
preliminaries in this section we establish the notation and review our bas eline symbolic execution algorithm for multithreaded programs.
.
multithreaded programs we assume each program pconsists of a finite set of threads t1 ... t m and a set svar of shared variables.
each thread ti where1 i m has a set lvariof local variables.
instructions from different threads are executed in an interl eaved fashion.
each time an instruction stis executed it produces an event e an bracketle ttid st l l an bracketri ht wheretidis the thread id while landl are the program locations before and after executing st. if there are multiple execution instances of st each instance is represented by a different event.
533a concrete state of the program pconsists of the program locationliof every thread ti where1 i m and the values of all variables in svar andlvari.
in contrast the abstract state or the so called global control state gcs s an bracketle tl1 ... l m an bracketri ht consists of the program locations only.
in other words each gcs represe nts the set of all concrete states that share the same program loc ations but have potentially different values of the program variab les.
letvlandcondlbe the thread local variables and conditions whilevgandcondgbe the shared global variables and conditions respectively.
depending on whether an event accesses share d variables we classify it into one of the following categories operation a local assignment vl expl operation a local branch assume condl operation a global operation defined as either a global write vg explor readvl vg or a thread synchronization operation.
given a program p the set of all possible executions is captured by a generalized interleaving graph gig where nodes are global control states and edges are events.
the root node cor responds to the program s initial state.
leaf nodes correspon d to the end of normal faulty executions.
each internal node may hav e one outgoing edge corresponding to an operation koutgoing edges corresponding to operations or koutgoing edges where k is the number of enabled operations from different threads.
we make a distinction between thread local operations and g lobal operations since they have different impacts during symbol ic execution.
global operations directly affect the thread interleaving order while operations directly affect the path taken by each thread.
in contrast operations do not directly affect the selection of any program path or thread interleaving.
without loss of generality we assume all conditional expre ssions use local variables or local copies of global variables .
the execution of an if c else statement for example can be represented byassume c if we take the then branch and assume c if we take the else branch.
properties of interest are represented by assertions of the form assert c which means if !c abort .
therefore we can use the special event abort to denote faulty program termination and halt to denote normal program termination.
.
baseline symbolic execution following the majority of prior works on symbolic execution we assume that the program under test is terminating and thus each execution has a finite length .
we also assume the program i s deterministic i.e.
the sequence of instructions will be c ompletely determined by in sch whereinis the data input and sch is the thread schedule.
therefore in sch implicitly represents a concrete execution of a program.
in contrast sch represents a symbolic execution where is the symbolic data input and sch e1...enis an order of the executed events.
algorithm shows the baseline procedure for concurrent pro grams which follows prior works such as .
initial ly explore is invoked with the symbolic initial state s0.
then depending on the type of the current state s we either explore a threadlocal branch or schedule a context switch.
a pivot point is a gig node with multiple outgoing edges.
a node corresponding to operation is called a branching pivot point b pp a node corresponding to operation is called an interleaving pivot point i pp .
specifically if sis an i pp node we recursively explore the next event from each thread if sis ab pp node we recursively explore the next thread local branch and if sis a non branching node we explore the unique next event.
upon reaching a leaf node the c urrent execution ends.
at this point the procedure pops the cu rrent statesfrom the stack sbefore returning from e xplore s .
during backtracking we always stop at the last unexplored p ivot point i pp or b pp and try to flip a previous decision to comp ute a new execution.
by flipping a previous decision at an i pp node weget in sch wheresch is a new thread schedule.
by flipping a previous decision at a b pp node we get in sch wherein is a new data input.
in both cases the new execution will be the sa me as the previous one up to the pivot point.
after the pivot poin t however it will be an uncontrolled execution.
algorithm baseline symbolic execution.
initially stack s s0 run e xplore s0 with the symbolic initial state s0.
explore s s.push s if sis an i pp node while t s.enabled s.done s nextstate s t explore s s.done s.done t else if sis a b pp node while t s.branch s.done s nextstate s t explore s s.done s.done t else if sis an internal node s nextstate s t explore s else end of execution do nothing s.pop nextstate s t lets a bracketle tpcon m enabled branch done a bracketri ht if tishalt s normal end state else if tisabort s faulty end state else if tisassignment v exp s a bracketle tpcon m a bracketri ht else if tisassume c andm is satisfiable s a bracketle tpcon c m a bracketri ht else s infeasible state returns we assume that each symbolic program state s sis a tuple an bracketle tpcon m enabled branch done an bracketri ht wherepcon is the path condition from s0tos mis the memory map enabled is the set of events when sis an i pp node branch is the set of events when sis a b pp node and done is the set of explored or events.
the initial state s0is an bracketle ttrue minit ... an bracketri ht wheretrue means the state is always reachable and minitis the initial memory map.
each instruction t is executed by n extstate s t as follows iftishalt the current execution ends without error.
iftisabort we have detected an error.
iftis an assignment v exp we update the memory map m by changing the content of vtoexp.
iftisassume c we set the path condition to pcon c .
.
the incremental symbolic execution algorithm our incremental procedure shown in algorithm has two sig nificant differences from the baseline procedure in algorit hm .
for brevity we only highlight the parts that are different.
first the input has changed.
instead of taking one program a s input we take both the old and the new programs pandp .
prior to our symbolic execution of the new program p we compute the forward impacted set isfwdand the backward impacted set isbwd.
in addition we transfer the table psof execution summaries computed inpto the new program p .
for each state s the set of explored executions starting from sis denoted ps .
second we add lines and inside n extstate .
they leverageisfwd isbwd andps to decide at each symbolic execution step st s if all executions starting at the next state s 534are redundant.
specifically if t.inst ne ationslash isfwd the current branching statement is not in the impacted set.
since which branch to ex ecute atsis immaterial if one of the branches has previously been explored we can force an early termination of the current exec ution.
similarly if t.inst ne ationslash isbwd the weakest precondition computation upon which the execution summary is computed would no t be affected by the code changes.
therefore we can carry the s ummaryps fromptop .
if the current path condition pcon in the modified program is subsumed by ps then continuing the execution from swould lead to no new errors.
in such case we can force an early termination of the current execution.
algorithm incremental symbolic execution.
isfwd compute forward impacted set p p isbwd compute backward impacted set p p ps the summary at scomputed in previous program p ... nextstate s t lets a bracketle tpcon m enabled branch done a bracketri ht if tishalt s normal end state else if tisabort s faulty end state else if tisassignment v exp if t.inst e atio slash isbwd andpcon ps s early termination state else s a bracketle tpcon m a bracketri ht else if tisassume c andm is satisfiable if t.inst e atio slash isfwd and another branch has been explored s early termination state else s a bracketle tpcon c m a bracketri ht else s infeasible state returns example.
for the program in figure the code changes on line would only invalidate the summary ps .
therefore although we cannot force an early termination at n1 we can leverage the summary at other nodes to prune away redundant executions.
i n particular when the execution reaches either n2orn4 we can terminate the execution immediately.
this is because both pcon ps andpcon ps are unsatisfiable.
specifically ps y x ne ationslash y x ne ationslash ps y x ne ationslash y x ne ationslash furthermore pcon x andpcon x .
therefore we can check pcon ps as follows x y x y x false we can also check pcon ps as follows x y x y x false the above checks indicate that no new errors can be detected b y continuing from n2andn4.
therefore we terminate the symbolic execution immediately without exploring the remaining pat hs.
in the remainder of this paper we will present our algorithm s for conducting the forward and backward change impact analysi s as well as the redundancy pruning based on execution summaries .
.
change impact analysis the first important component of our incremental analysis is the detection and characterization of code changes called the changeimpact analysis cia .
the identification of code chang es re quires comparison of two program versions by matching their representations often in the form of flow graphs tree repr esentations or locations in source files.
.
computing the impacted sets our new change impact analysis for concurrent programs tak es two program versions pandp as input and returns two impacted sets.
one impacted set is isfwd the forwardly impacted set while the other impacted set is isbwd the backwardly impacted set.
we follow person et al.
to define three types of code chang es deleted added and modified.
our computation of the two impa cted sets consists of several steps.
algorithm forward and backward change impact analysis.
diff diff p p map map p p diff compute forward impacted set p p aifwd mifwd difwd for each inst diff if inst isadded aifwd aifwd fwddependencyanalysis p inst else if inst ismodified mifwd mifwd fwddependencyanalysis p inst else if inst isdeleted impacted fwddependencyanalysis p inst for each st impacted st querymap map st difwd difwd fwddependencyanalysis p st returnaifwd mifwd difwd compute backward impacted set p p aibwd mibwd dibwd for each inst diff if inst isadded aibwd aibwd bwddependencyanalysis p inst else if inst ismodified mibwd mibwd bwddependencyanalysis p inst else if inst isdeleted impacted bwddependencyanalysis p inst for each st impacted st querymap map st dibwd dibwd bwddependencyanalysis p st returndibwd mibwd dibwd first we compare pandp using a lightweight difftool that computes the set diffof changed instructions added deleted or modified .
since the remaining instructions exist in both pr ograms we construct a map mapthat maps every unchanged instruction inst pto its counterpart inst p .
second for each added instruction denoted instadd diff we perform a forward control and data dependency analysis in p to identify all instructions depending on instadd line .
details of this analysis are presented in the next subsection.
we also p erform a backward control and data dependency analysis in p to identify all instructions that instadddepends on line .
we denote the set of instructions as ai represented separately as aifwdandaibwd.
third for each modified instruction denoted instmod diff we perform a forward control and data dependency analysis inp to identify the instructions depending on instmod line .
we also perform a backward control and data dependency analy sis to identify all instructions that instmod depends on line .
we denote the set of instructions as mi.
fourth for each deleted instruction instdel diff we perform the forward control and data dependency analysis to compu te the set of instructions depending on instdel line .
we also perform the backward control and data dependency analysis to comp ute the set of instructions that instdeldepends on line .
for each instruction in this set which is in program p we retrieve its counterpart in p by querying the map the results form a new set di.
finally the union of ai mi anddiforms the complete set of impacted instructions denoted isfwdandisbwd respectively.
x z x y x if z z else z z x if x y modified else z assert y !
figure example for our new change impact analysis.
algorithm shows the actual pseudocode formalizing the abo ve descriptions.
for ease of comprehension we have divided th e computation of isfwdandisbwdinto two separate routines.
these routines in turn rely on two subroutines described in sectio n .
to perform the inter thread and inter procedural control and datadependency analysis.
example.
figure shows a program pthat starting with x y z may violate the assertion on line by executing lines and then .
to fix the violation we plan to change line from y toy to obtain the new program p .
during the change impact analysis diff and map ... .
since the type of change is modified we only need to compute mi.
specifically from the forward analysis we obtainmifwd which means the modification may affect lines and .
from the backward analysis we obtain mibwd which means they may affect the statement on line .
this is because line is control dependent on line due to variable x and data dependent on lines and due to variabley.
line in turn is data dependent on lines and .
.
computing the dependency relations the dependency relations are computed by an inter thread an d inter procedural static analysis.
we follow to comp ute the control dependencies using post dominance and data dep endencies by the transitive closure of use def chains.
our main contri butions however are reasoning about these dependencies in the conc urrent setting which also works on sequential programs and adap ting them to the forward backward change impact analysis.
we say that a statement s2is control dependent on s1if the computation of s1determines whether s2is executed.
for example in if c x the statement x is control dependent on if c specifically on the value of the predicate c .
on the other hand s4is data dependent on s3if the computation of s3influences the computation of s4.
for example in a x b a y the statement b a y is data dependent on the statement a x since the value of adetermines the value of b. to be conservative our baseline dependency analysis is flow insensitive which has the advantage of being scalable and c onsidering all ordering of statements.
since any statement fr om any thread can effectively execute at any time this over appro ximates the actual scheduling constraints thereby ensuring the so undness of our analysis for multithreaded programs.
however using a flowinsensitive analysis while sound may result in false depe ndencies across threads.
consider the program in figure thread one reads the value of xand then creates thread two which writes to x. in a flow insensitive analysis the read in thread one is data de pendent on the write in thread two.
but the write can never be visible to thread one since thread two does not exist until after the re ad.
to capture this situation we augment our baseline dependen cy analysis with a happen before relation.
we say that a statement s1 happens before a statement s2if on all program executions s1executes before s2 e.g.
the statement create thread2 happens beforex .
toward this end we refine the data dependency analysis as follows if s1happens before s2thens1must not be1int x 2void thread1 3int t1 x 4create thread2 6void thread2 7x figure example for false data dependencies across threa ds.
data dependent on s2.
this approach is comparable to recent works on using happens before to refine data race detection .
it is sound because the happens before relation ensures there do es not exist a program path from s2tos1 and thus s1cannot witness the effect of s2.
currently we deduce happens before constraints statically from the thread creation sites.
in the implementation we adopt the datalog based declarat ive program analysis framework we first build c trldep and d atadeprelations where a b datadepmeans the variableais data dependent on b. we traverse the control flow graph to generate the set of input items for these relations.
we use th e structure of each individual instruction to determine the contro l and data dependency relations associated with it.
for brevity we show only how we handle the binary operation r opv1v2 wherer v1 andv2are variables and opis an operator.
in this case the input items to d atadepare r v1 and r v2 .
similarly we provide input items to the happens before hb relation from thread creation sites.
within a thread we det ermine the hb relation using dominance and reachability on the cont rolflow graph.
specifically if s1dominates s2ands1is not reachable froms2 thens1happens before s2.
dominance ensures that all paths tos2contains1 reachability ensures that there is no path froms2tos1.
all in all they ensure s1always occurs before s2.
we compute the transitive closure of c trldepand d atadep relations while using the happens before relation to filter the false dependencies.
finally the forward resp.
backward depen dency analysis on some statement sis the forward closure from sof the combination of the control and data dependency relations .
.
summary based redundant path pruning the second important component of our incremental analysis is pruning of redundant executions.
in this section we explai n how to compute execution summaries in pand use them in the new programp .
first during the symbolic execution of p we summarize all the explored executions in a table denoted ps where each entryps stores a logical formula that represents all explored executions suffixes starting from s. then during the symbolic execution of p we leverage our backward change impact analysis to decide if these summaries can be carried over to p .
.
computing execution summaries we construct the summary ps at each state s based on the weakest precondition wp computation .
the wp is defined with respect to a predicate and an execution .
it can be regarded as a form of craig s interpolant to explain why th e execution cannot reach bad states.
when an explored executi on ends at an assert c statement we compute the wp of calong this execution otherwise we compute the wp of true.
definition .the weakest precondition of the predicate with respect to a sequence of instructions is defined as follo ws for an assignment t v exp wp t which is the substitution of vbyexpin intaltpress meter procedure update intpedalpos int bswitch intpedalcmd ifpedalpos then modified pedalcmd else if pedelpos then pedalcmd elsepedalcmd pedalpos pedalcmd pedalcmd ifbswitch 0then meter else if bswitch then meter ifpedalcmd then altpress else if pedalcmd then altpress elsealtpress n2 pedalpos 0nbegin n3 pedalcmd n4 pedalpos n5 pedalcmd n6 pedalcmd pedalpos n8 pedalcmd pedalcmd n10 bswitch n11 meter n12 bswitch n13 meter n15 pedalcmd n16 altpress n17 pedalcmd n18 altpress n19 altpress nendn2 modified true false true false true false true false true false true false figure the wbs example taken from dise .
for a branching statement t assume c wp t c and for a sequence of instructions denoted t1 t2 wp t1 t2 wp t1 wp t2 .
following guo et al.
we compute the execution summary by merging the wps at the pivot points as follows.
the weakest precondition at a branching pivot point b pp s with outgoing edges to s1 ... skand conditions c1 ... c k is defined as follows wp logicalordisplay i k ci wp where each wp is the weakest precondition at state si.
the weakest precondition at an interleaving pivot point i pp s with outgoing edges to s1 ... sk is defined as follows wp logicalanddisplay i kwp .
this is an underapproximation since the precise merging wou ld require an enumeration of all possible interleavings whic h is too costly for the summary based pruning.
nevertheless in practice this underapproximated summary often suffices fo r eliminating redundant executions.
finally the execution summary ps at nodesis computed as the union of the weakest preconditions along all explored ex ecutions starting from s. consider the wbs example in figure whose control flow graph is shown on the right hand side.
the baseline symbolic execu tion procedure needs to explore all paths.
following the metho d described above the execution summaries computed for the pro gram pcan be found in table .
for example the summary for node n17 denoted ps is the union of pedalcmd ps and pedalcmd ne ationslash ps .
prior to using the summary table computed in pin the new programp we need to check if recent code changes have invalidated some of these summaries.
if the answer is no we can safely reu se them to prune away redundant executions in p .
for example in figure since we changed only line i.e.
from if x toif x the weakest precondition computation is not affected at al l other nodes except for n1.
in other words we can reuse the previously computed summaries at these nodes.table execution summaries computed for pinconc ise .
entry summary ps true ps true ps pedalcmd ps pedalcmd e atio slash ps true ps true ps pedalcmd ps pedalcmd e atio slash ps true ps ps true ps bswitch ps bswitch e atio slash ps true ps ps true ps bswitch ps bswitch e atio slash ps true ps ps true ps ps true ps ps true ps pedalpos ps pedalpos e atio slash ps true ps ps true ps pedalpos ps pedalpos ps true table comparing the paths explored by dise and conc ise .
explored by dise explored by conc ise n2 n3 n8 n10 n11 n15 n16 partial up to n3 n2 n3 n8 n10 n11 n15 n17 n18 skipped n2 n3 n8 n10 n11 n15 n17 n19 skipped n2 n4 n5 n8 n10 n11 n15 n16 partial up to n4 n2 n4 n5 n8 n10 n11 n15 n17 n18 skipped n2 n4 n5 n8 n10 n11 n15 n17 n19 skipped n2 n4 n6 n8 n10 n11 n15 n16 skipped .
pruning with execution summaries our method for leveraging the summaries to prune away redundant executions has been shown on lines in algorithm .
here pcon represents the set of forwardly reachable states while ps represents the set of states that may lead to some previously unexplored errors.
if the intersection is empty however t here is no need to continue the current execution beyond s. in the actual implementation the validity of pcon ps is decided by checking the satisfiability of its negation pcon ps which can be solved efficiently by an smt solver.
to demonstrate the advantages of our method we show how it works on the wbs example from dise .
since dise works only for sequential programs the wbs example in figure is a sequential program and our method assumes it has a single thr ead.
in wbs the only code change is on line from pedalpos to pedalpos .
the red rounded rectangles represent the impacted cfg nodes in p while the white rounded rectangles represent nodes that are not impacted by the change.
the baseline s ymbolic execution procedure needs to explore all paths wher eas dise only needs to explore paths due to the reduct ion based on its forward impact analysis.
that is the nodes n10 n11 n12andn13are not affected by the code change at n2.
however there is still redundancy among the paths explore d by dise.
as shown in the third column of table certain commo n subpaths are explored repeatedly.
for example n8 n10 n11 n15 n16 is an already explored subpath in 1but it is re explored in 4and 7 also n10 n11 n15 n17 n18 is an already explored subpath in 2but it is re explored in 5 and n10 n11 n15 n17 n19 is an already explored subpath in 3but it is re explored in 6. in contrast our new method can reduce the seven executions further down to executions column in table .
specifically during the symbolic execution of p we incrementally compute the summaries at n17 n15 n10 n4 n2 and table shows the summary table of pin terms of these locations.
then in the symbolic execution of the new program p we first apply the forward change impact analysis for the modifi cation in line and then apply our backward change impact analysi s 537which indicates that the summary is invalid only at node n2 immediately before line for all other nodes we can safely reu se the summaries since these nodes are not in the backward slice of n2.
by checking the validity of pcon ps for all nodes except for n2during the execution we can reduce the seven runs further down to two partial runs.
more specifically the exec ution onp starts by visiting n2.
as the summary at n2is invalid since it is in the backward impacted set the execution continue s exploring without checking the summary.
consider that the true branch ofn2is first selected execution proceeds until reaching the nex t assignment statement at n3.
noticing that the summary at n3is still valid and pcon ps pedalpos true false the execution stops here generates the first partial run n2 n3 and backtracks to n2.
next the false branch of n2is selected and the execution runs until the following branch statement at n4.
as pcon ps pedalpos true false the execution also stops generates the second partial run n2 n4 then backtracks to n2.
since both outgoing edges of n2are explored and n2is the entry of the program the whole execution on p terminates.
therefore the two runs in p explored by our method are 1 n2 n3 and 4 n2 n4 shown in column of table .
.
experiments we have implemented the proposed method in a software tool named conc ise which builds upon llvm and cloud9 .
cloud9 relies on the klee symbolic virtual machine as backend.
we extended cloud9 to robustly handle posix threads the original implementation only coarsely considered differe nt thread interleavings at blocking operations.
in contrast our sym bolic execution procedure schedules threads at a finer granularity e.g.
the shared memory accesses and ensures that all interleavings are systematically explored.
furthermore we implemented the dyn amic partial order reduction dpor algorithm which cloud9 does not originally support.
in addition we have implemented ou r forward and backward change impact analysis to provide guidanc e to our incremental symbolic execution algorithm.
we also im plemented a flow insensitive pointer analysis for multi threa ded programs.
our dependency analysis is constraint based and dir ectly works on the llvm bit code.
we use the z3 s z fix point solver to compute the fix point of the datalog constraints.
to share the summary information between program versions we deployed the memcached distributed cache as an external p ersistent storage for the execution summaries.
the summaries are computed and encoded in klee kquery formula format during th e symbolic execution.
after the execution of the original pro gramp they are serialized as binary character sequences for memca ched storage.
before running the new program p they are loaded into main memory and mapped to the corresponding global control l ocations.
based on the results of our backward change impact analysis we implemented a summary renewal mechanism to check if the summary of a location has been invalidated by recent code cha nges and reset it to false in that situation.
.
subjects and methodology we have conducted experiments on two sets of benchmarks.
the first set consists of multi threaded c programs randomly cho sen from the software verification competition benchmark a nd benchmarks from .
the second set consists of three real w orld applications each with five different versions they are lo ck free data structure implementations nbds list nbds skiplist andnbdshashtable from .
each of these benchmark programs has between to lines of code with a total of application s different versions and lines of code.
each benchmar k program is first compiled to llvm bit code by clang before given to the symbolic execution engine.
runs baseline runs scia time s baseline time s scia figure conc ise scia versus the baseline algorithm.
for c programs from since there are no different versions available online we manually made three types of m utants to the programs acting as modified deleted and added statem ents.
for the real world applications from we studied the ev olution history from the code repository and used real updates comm itted by their developers as the changes to those programs.
.
experimental results table summarizes the experimental results of our evaluati on.
the program name version lines of code number of changes percentage of code impacted and the number of threads for each p rogram are shown in columns .
columns compare the experimental performance of four different methods in terms o f the number of explored executions runs and the time in seconds .
baseline denotes the baseline symbolic execution procedure in algorithm dpor denotes baseline symbolic execution augmented with dynamic partial order reduction cia denotes a variant of conc ise which augments baseline symbolic execution with dpor and pruning based on the forward change but without the backward summary based pruning.
finally scia denotes the fullblown implementation of conc ise which augments cia with the backward summary based pruning.
in all methods the sta tic analysis time and summary computation time if applicable are included in the total execution time.
we used a maximum time of minutes seconds for all experiments.
in the remainder of this section we present the results in mo re detail to answer the following research questions .
how effective is our incremental symbolic execution algorithm?
.
how does it compare to state of the art por techniques?
.
how effective is the backward summary based pruning?
first we compare the performance of baseline and scia with the two scatter plots in figure .
the x axis denotes the execution time or number of runs of the baseline symbolic execution while they axis denotes the execution time or number of runs of our new method scia .
in the scatter plots each dot represents a benchmark program and the dots below the diagonal lines are the winning cases of our new method.
from figure we see that our new method can significantly reduce the number of runs explor ed by symbolic execution as well as the total execution time.
in many cases our new method can finish the execution in seconds whil e the baseline algorithm does not stop after minutes.
second we compare the performance of dpor and scia with the two scatter plots in figure .
our goal is to show how much performance improvement was achieved by our new method over dpor alone.
similarly dots below the diagonal lines are the winning cases of our new method scia .
again our new method brings significant performance improvement compare d to dpor .
however there are some test cases where scia spent slightly longer time despite that it has the same or a smalle r number of runs.
this is due to the overhead of static analysis su mmary 538table comparing the two variants of conc ise cia and scia with baseline symbolic execution.
existing methods conc ise new baseline dpor cia scia name version loc changes impacted threads runs time s runs time s runs time s runs time s v1 .
.
.
.
.
v2 .
.
.
.
fibbench v3 .
.
.
.
v4 .
.
.
.
v5 .
.
.
.
v1 .
.
.
.
.
v2 .
.
.
.
.
account v3 .
.
.
.
.
v4 .
.
.
.
.
v5 .
.
.
.
.
v1 .
.
.
.
.
v2 .
.
.
.
.
lazy01 v3 .
.
.
.
.
v4 .
.
.
.
.
v5 .
.
.
.
v1 .
.
.
.
v2 .
.
.
.
indexer v3 .
.
.
.
v4 .
.
.
.
v5 .
.
.
.
v1 .
.
.
.
.
v2 .
.
.
.
.
readreadwrite v3 .
.
.
.
.
v4 .
.
.
.
.
v5 .
.
.
.
.
v1 .
.
.
.
.
v2 .
.
.
.
.
stateful01 v3 .
.
.
.
.
v4 .
.
.
.
.
v5 .
.
.
.
.
v1 .
.
.
.
.
v2 .
.
.
.
.
reorder v3 .
.
.
.
.
v4 .
.
.
.
.
v5 .
.
.
.
.
v1 .
.
.
.
.
v2 .
.
.
.
.
twostage3 v3 .
.
.
.
.
v4 .
.
.
.
.
v5 .
.
.
.
.
v1 .
.
.
.
v2 .
.
.
.
szymanski v3 .
.
.
.
v4 .
.
.
.
v5 .
.
.
v1 .
.
.
.
v2 .
.
.
.
bluetooth v3 .
.
.
.
v4 .
.
.
.
v5 .
.
.
.
v1 .
.
.
.
.
v2 .
.
.
.
.
circularbuf v3 .
.
.
.
.
v4 .
.
.
.
.
v5 .
.
.
.
v1 .
.
.
.
v2 .
.
.
.
nbds list v3 .
.
.
.
v4 .
.
.
.
v5 .
.
.
.
v1 .
.
.
v2 .
.
.
.
nbds skiplist v3 .
.
.
v4 .
.
.
.
v5 .
.
.
v1 .
.
.
.
v2 .
.
.
nbds hashtable v3 .
.
.
v4 .
.
.
.
v5 .
.
.
.
total runs dpor runs scia time s dpor time s scia figure conc ise scia versus baseline dpor .
runs cia runs scia time s cia time s scia figure conc ise variants cia versus scia .
computation as well as the pruning which makes the total ex ecution slower than dpor .
but overall the run time of scia versus dpor is smaller.
finally we compare the two conc ise variants cia and scia in figure .
these scatter plots show the effect of executio n summaries during an incremental analysis.
similar to the previ ous cases sometimes the summary based pruning technique is no t able to provide a significant reduction thereby causing the runt ime to be slightly higher this usually occurs when the backward impa ct analysis causes many summaries to be removed.
nonetheless for m ost test cases it is able to have a significant reduction in the nu mber of runs which in turn leads to a significant reduction in time.
discussion.
fundamentally an incremental analysis is only applicable when the code modification affects a subset of the entire p rogram if the entire program is modified then the incremental a nalysis degenerates to the non incremental one.
therefore ou r technique is suitable in a software development environment whe re the correctness of frequent but small code changes is checked be fore they are committed to the central repository.
in our experim ents the code modifications from the nbds application are all developermade modifications.
furthermore in these real world appli cations code modifications typically affected around .
to .
o f the entire program.
such code changes are small enough to allow conciseto be effective although it remains an open question whethe r they reflect the majority of the software development scenar ios in practice.
another interesting problem is when to schedule t ests e.g.
as in herzig et al.
which is an orthogonal but clos ely related problem.
.
related work change impact analysis has been widely applied in soft ware testing and verification.
the existing incremental symboli c execution tool dise uses an intra procedural static chang e impact analysis and then leverages it to reduce the cost of symbolic execution.
the extension of dise named idise improves it in two ways by making the change impact analysis inter proce dural and by using dynamic calling context information to increa se accu racy.
yang et al.
extend dise to a property guided symbo licexecution procedure for checking assertions in evolving pr ograms.
change impact analysis has been used in the context of progr am verification as well.
for example backes et al.
use a chan geimpact analysis to improve the functional equivalence chec king in regression verification.
specifically the change impact i s used to focus on the equivalence checking of affected portions of th e code.
similarly symdiff focuses on proving assertions in th e context of regression verification.
however none of these previous techniques were designed fo r concurrent programs they all target sequential software.
their extension to concurrent programs remains non trivial due to t he inherent difficulties in analyzing thread interferences.
our new technique in contrast is the first incremental symbolic execut ion for concurrent programs.
simrt is a regression testing tool for multithreaded p rograms targeting data races.
it compares the two program ver sions syntactically to identify a set of affected variables and t hen construct a list of potential data races to test.
during the test ing phase simrt prioritizes the selection of existing test cases and v isiting the most program points of the affected variables to speed up datarace detection.
capp uses a change impact analysis to p rioritize scheduler preemptions at impacted code points to dete ct concurrency bugs.
however capp only manipulates the prioriti zed thread scheduling rules with fixed data inputs.
furthermore simrt and capp focus on test selection and prioritization as opposed to generating new tests.
in contrast our method uses symbolic execution to generate new tests.
recontest is a regression testing technique to select new thread interleavings that are more likely to trigger concur rency bugs caused by recent code changes.
specifically it computes the affected code statements by comparing dynamic execution trac es on the two program versions.
then at each program point of the i mpacted set it identifies problematic memory access pattern s and use them to compute alternative interleavings e.g.
by reordering these concurrent memory accesses.
while r econtest has the capability of exploring new thread schedules it rel ies on user provided data inputs.
in contrast we use symbolic exe cution to generate new data inputs as well as new thread schedules.
we build upon prior works on constructing weakest precondi tion and similar interpolation based execution summaries during symbolic execution .
there is also a large b ody of work on symbolic analysis of concurrent software using sm t solvers .
however these pr ior works target a single program version.
in contrast we lever age the summary computed in the previous program version to prun e redundant executions in the new program version.
.
conclusion we have presented conc ise an incremental symbolic execution algorithm for concurrent programs.
our new change imp act analysis is both inter thread and inter procedural capab le of more accurately identifying instructions affected from code ch anges between two closely related program versions.
we also showed h ow summaries computed from the previous program can be used to prune away redundant runs during symbolic execution of the n ew program.
we implemented our method and evaluated it on a larg e set of multithreaded programs.
our experiments show that th e new method can significantly reduce the runtime cost when compar ed with the state of the art symbolic execution techniques.
.