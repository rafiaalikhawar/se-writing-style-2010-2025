b2sfinder detecting open source software reuse in cots software muyue feng zimu yuan feng li gu ban yang xiao shiyang wang qian tang he su chendong yu jiahuan xu aihua piao jingling xue and wei huo institute of information engineering chinese academy of sciences school of computer science and engineering university of new south wales fengmuyue yuanzimu lifeng bangu xiaoyang wangshiyang tangqian suhe yuchendong xujiahuan piaoaihua huowei iie.ac.cn jingling cse.unsw.edu.au abstract cots software products are developed extensively on top of oss projects resulting in oss reuse vulnerabilities.
to detect such vulnerabilities finding oss reuses in cots software has become imperative.
while scalable to tens of thousands of oss projects existing binary to source matching approaches are severely imprecise in analyzing cots software products since they support only a limited number of code features compute matching scores only approximately in measuring oss reuses and neglect the code structures in oss projects.
we introduce a novel binary to source matching approach called b2sf inder1 to address these limitations.
first of all b2sf inder can reason about seven kinds of code features that are traceable in both binary and source code.
in order to compute matching scores precisely b2sf inder employs a weighted feature matching algorithm that combines three matching methods for dealing with different code features with two importance weighting methods for computing the weight of an instance of a code feature in a given cots software application based on its specificity and occurrence frequency .
finally b2sf inder identifies different types of code reuses based on matching scores and code structures of oss projects.
we have implemented b2sf inder using an optimized data structure.
we have evaluated b2sf inder using binaries from popular cots software products and candidate oss projects.
our experimental results show that b2sf inder is not only precise but also scalable.
compared with the state of the art b2sf inder has successfully found up to .15x as many reuse cases in .
seconds per binary file on average.
we also discuss how b2sf inder can be leveraged in detecting oss reuse vulnerabilities in practice.
index t erms cots software oss code reuse one day vulnerability code feature binary to source matching i. i ntroduction with the widespread adoption of structural design patterns and the pressing need for shortening time to market more and more commercial off the shelf cots software products are being developed on top of open source software oss projects.
such a rapid application development leads to several undesirable problems including licence violations and zimu yuan is the corresponding author.
the authors from the institute of information engineering chinese academy of sciences are also affiliated with key laboratory of network assessment technology chinese academy of sciences beijing key laboratory of network security and protection technology and school of cyber security university of chinese academy of sciences.
1open sourced at issues .
among these problems oss reuse vulnerabilities are one of the most severe issues .
oss vulnerabilities can be introduced into cots software when some vulnerable oss code is integrated into and thus reused in the software.
such oss vulnerabilities which are referred to as oss reuse vulnerabilities are ubiquitous and can have a serious impact on the security of cots software.
for example adobe reader and windows defender were both found to be vulnerable as both had used some vulnerable versions of open source projects libxslt and unrar .
in fact most of oss reuse vulnerabilities remain in cots software even if their vulnerable oss versions have been patched already.
according to a synopsis report of the cots products audited have reused oss projects as their components containing unpatched oss vulnerabilities in oss projects released six years ago on average.
to detect oss reuse vulnerabilities it is imperative to identify the oss projects included in cots software as precisely as possible.
we are therefore motivated to address the underlying oss reuse detection for cots software problem in this paper.
while the number of mobile applications keeps increasing the traditional cots products that run on desktop computers and servers are still widely used.
so we focus on cots software in this paper.
a cots product usually consists of tens of stripped binaries most of which are either in the portable executable pe format for windows or the executable and linkable format elf for linux .
given a binary file for a target cots software product and a set of candidate oss projects there are two representative approaches to oss reuse detection.
one approach is to compute the similarity between the binary of a given target cots product and a compiled binary of a candidate oss project.
despite a lot of prior work on binary similarity detection we still see two challenges ahead.
first the fully automatic compilation for all the candidate oss projects is nontrivial and usually requires manual work to find appropriate compiler flags to enable their successful compilation.
in an experiment that we performed on a total of oss projects crawled from ubuntu packages we found that only approximately a quarter can be compiled automatically.
second any binary similarity analysis can be expensive.
for a moderate cots software product approximately billions of comparisons are needed for finding code reuses from many candidate oss 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
bin srcmatching score calculation appropriate features matching methods weighting algorithmsmatching scoresreuse type identification simple reuse partial reuse pseudo propagated reuseidentification reuse relationships figure the workflow of b2sf inder .
projects making the analysis unscalable if done naively .
the other approach is to compare the target binary of a cots software product with the source code of a candidate oss project directly.
in the absence of the compiler flags used for producing the cots software binary the prior work on binary to source matching relies heavily on code features including string type features like function names and string literals which are not usually correlated with the compiler flags used.
as a result the possibility of code reuses is measured as the number of common feature instances present in both the target binary and a given candidate oss where a feature instance denotes a concrete feature object like a function name jpeg start decompress .
while being scalable to tens of thousands of candidate oss projects applying it directly to oss reuse detection does not deliver the precision desired due to the lack of code features considered.
in this paper we address the following three problems .
how can we select as many code features as possible while ensuring that all the selected features are traceable in compiled binaries?
the key to binary to source matching lies in the code features considered.
for example bat considers string literals only and thus misses .
of code reuses that are not related to string literals as evaluated later .
osspolice which considers not only string literals but also exported function names performs well in the elf formatted libraries.
however the pe files for cots software are usually stripped of these clues making it impossible for osspolice to perform code matching needed in stripped binaries.
.
how can we precisely compute the matching scores with respect to different code features and their feature instances?
the prior work usually measures the degree of feature matching by computing a matching score.
however their score computation is imprecise for two reasons different kinds of features are usually matched by the same process and different feature instances of the same feature are assumed to contribute equally in feature matching.
.
how can we exploit the code structures of oss projects to improve reuse identification?
in general a higher matching score does not always imply a higher possibility for code reuse and vice versa.
for example as shown in the right side of figure every feature in libpng is matched with that of libopenjp2 .dll resulting in a high matching score.
however libopenjp2 .dll only reuses openjpeg rather than libpng .
this suggests that the complex code structures of oss projects should also be considered in order to decrease the number of false reuse identifications reported and increase the number of true reuse identifications found.to address the three aforementioned issues we propose a novel binary to source matching approach b2sf inder for detecting oss reuses.
as shown in figure b2sf inder proceeds in two phases matching score calculation and reuse type identification which are discussed briefly below.
in order to compute matching scores in the first phase precisely we have aggressively selected seven kinds of stable code features of which four kinds are not affected by compilation and three kinds are affected slightly during the compilation.
by dividing seven kinds of features into three types string type integer type and control flow type we have designed three corresponding matching methods exact matching search based matching and semantics based matching.
in order to describe the relative importance of different matched feature instances we introduce two feature instance attributes specificity and occurrence frequency .
the specificity attribute indicates that a special matched feature instance e.g.
0x6a09e667 is more helpful to distinguish one oss project from others than a trivial one e.g.
0x0001 .
the occurrence frequency attribute denotes the appearance of a matched feature instance across all the candidate oss projects.
the lower the occurrence frequency is the more significant it is in identifying the reused oss projects.
the effects of these two attributes on code reuses can be captured in a weight computation by combining a bitstream entropy algorithm and a tf idf like weighting algorithm.
overall we propose a novel feature matching algorithm that combines three matching methods with two importance weighting methods.
in order to identify different types of code reuses we take into account the code structures of oss projects to recognize two types of file groups self implemented groups and oss imported groups from a third party project.
by leveraging this information we construct exact reuse relationships between a target cots software binary and an oss project.
we have identified three types of reuse relationships simple reuse partial reuse and pseudo propagated reuse .
the former two are true reuse cases while the last one is a false reuse case that should be eliminated.
note that the partial reuse is usually missed by bat and osspolice due to its low matching score while the pseudo propagated reuse is often identified incorrectly by bat due to its high matching score.
we have implemented b2sf inder with an optimized data structure in terms of an inverted index and a trie a prefix tree .
we have evaluated b2sf inder on a custom dataset consisting of binaries from cots software products collected from the internet and popular oss projects crawled from ubuntu packages.
our experimental results show authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
if else if bits key round else if bits export ssl check chain ssl set ssl method rsa generate key openssl libcryptocryptlib.c ase cfb.c bf enc.c ... libsslssl algs.c ssl cert.c ssl rsa.c ...openssl libcryptocryptlib.c ase cfb.c bf enc.c ... libsslssl algs.c ssl cert.c ssl rsa.c ...dos header .text .data .rdata... ... string x resolution is set to ssl server missing jpeg tables export certcomparecertificate cryptdecodeobject pfximportcertstore if else cmp eax jnz loc a2a0aa cmp eax.
jnz loc a2a190 switch case cmp eax 0dh ja loc 4939e7 mov edx eax jmp ds off 4939fc foxitreader.exe switch case switch key type case key privkey case key cert enum array string array integer array cast s table2 0x8defc240 0x25fa5d9f string sha256 allocation error in s is an unknown a data fragment c2 ef 8d 9f 5d fa bf 3d eb c9 e8 ff 7f 4b e4 9f figure binary to source matching between foxitreader.exe andopenssl for the seven kinds of code features selected.
that b2sf inder achieves a precision of .
and a recall of .
thereby significantly outperforming state of the art approaches in all the configurations considered.
comparing with bat b2sf inder finds .15x as many reuse cases in top and .47x as many reuse cases in top in .
seconds per binary file on average.
in addition b2sf inder finds that .
of cots software products reuse oss projects with .
of them being reused more than times and moreover .
potential vulnerabilities are found to exist in the top frequently reused libraries on average.
overall this paper makes the following contributions we propose a novel binary to source matching approach by employing a weighted feature matching algorithm that combines three matching methods for dealing with different code features with two importance weighting methods for computing the weight of an instance of a code feature in a given software application based on its specificity and occurrence frequency .
we introduce a new concept of reuse type and utilize it to improve the precision of code reuse detection.
we have developed a prototyping open source implementation for b2sf inder and evaluated its efficiency and precision using binaries from popular cots software products and oss projects.
compared with the state of the art b2sf inder has successfully found up to .15x as many reuse cases in .
seconds per binary file on average.
b2sf inder is also shown to be capable of detecting oss reuse vulnerabilities in practice.
ii.
m otiv ation we walk through our binary to source matching approach and illustrate our insights for detecting oss reuses by using two real world motivating examples foxit reader and gimp .foxit reader is a well known viewing and editing tool for pdf files.
the two binaries the core executable filefoxitreader.exe and a dynamically linked libraryssleay32.dll selected from foxit reader both reuse openssl a widely used oss project implementing ssl.
gimp is a popular raster graphics editor used for image editing.
its dynamic library libopenjp2 .dll reuses an oss project openjpeg .
although the two examples are both in the pe format our approach is capable of dealing with all the other native binary files in a similar manner.
we explain how b2sf inder analyzes these two examples in its two phases as shown in figure .
a. matching score calculation since we compare directly the binary of a cots software application with the source code of an oss project code features selected from both must be matchable.
string literals and exported function names can be matched directly as they are not usually correlated to compiler flags.
however as discussed in section i such features are not applicable to many binaries in cots software.
in our approach one key observation is to identify a range of code features that are not likely to change during the compilation with the exception of string literals and exported function names .
as shown in figure there are no common exported function names between foxitreader.exe andopenssl .i n addition both share as few as .
of common string literals.
given these two facts both bat and osspolice are ineffective in analyzing foxitreader.exe .
in order to leverage more stable code features present in both binary and source code we have examined the foxitreader.exe .
except for the string literals in the .rdata segment and exported function names in the dos header segment we have found some other features potentially selectable from the .rdata .data and.text segments.
one of these newly selected features is numerical data.
these data items are usually the initial values of the global variables stored in the .data segment for non constant variables and the .rdata segment for constant variables .
therefore we have selected two kinds of such features global authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
integer arrays and global enumeration arrays.
for example in figure the global integer array cast s table2 0x8defc240 0x25fa5d9f ... inopenssl exists infoxitreader.exe as a bitstream with a prefix of 0x40c2ef8d9f5dfa25 .
we have opted for array variables instead of scalar variables for performance reasons as the number of array variables is significantly less .
we observe that we can also find some potential code features in the .text segment.
although control flow information can be changed by some compiler optimizations a sequence of branches representing some complex logic is relatively stable.
this is because such a sequence is usually complex and thus does not satisfy the underlying optimization criteria required.
for a given binary file we therefore search for its data or instruction sequences with the encoded complex switch case structures and sequences of consecutive if else conditional branches extracted from its code sections.
for example foxitreader.exe has a jump table which is found to contain the same labels as a switch statement in function aes ccm ctrl fromopenssl .
this shows that foxitreader.exe reuses openssl with a high possibility.
in total we have selected seven kinds of code features as shown in figure .
however how to match a feature in source code with the same feature that appears in its compiled binary remains challenging especially for those features that may be slightly changed during the compilation.
for a given code feature its feature instances in the binary of a cots software application are extracted by reverse engineering while its feature instances in the source code of an oss project are extracted by applying program analysis.
afeature instance is a concrete feature object belonging to a certain kind of features as illustrated in figure .
for different code features we will recognize them by applying three different matching methods.
for different instances of a code feature we will recognize their relative importance by applying two different importance weighting methods.
for strings string arrays and exported functions their feature instances are all in the form of strings which can be directly recognized by using string matching algorithms.
specifically an inverted index is used to accelerate string matching due to the existence of a large number of strings in practice.
on the other hand instances of two numeric features global integer arrays and global enumeration arrays are handled differently.
due to the lack of data structure information in binaries we encode these feature instances found in binaries into bitstreams of certain lengths in certain data types.
for each candidate oss project each bitstream is then searched in its source code to find its instances in either the big or little endian byte order.
finally matching the feature instances of control flow types constants in a switch case feature and constants in an if else feature is more complex.
we will compare semantically the corresponding constants in one feature instance of a control flow type in the binary of a cots software application and another feature instance of a control flow type in the source code of an oss project.
note that the matching results of feature instances are not directly related to how the underlying match libssllibcryptozlib opensslfoxitreader.exe simple reuse partial reuseincludezlib libpngsimple reusesimple reuseincludepseudo propagated reusesimple reuse partial reuse pseudo propagated reuse openjpeg pseudo propagated reuselibopenjp2 .dlloss oss cots cots ssleay32.dllpartial reuse figure three types of code reuses.
ing scores are computed.
for example a simple array can be easily matched with irrelevant data.
thus we will assign a small specificity weight to this array by computing the entropy of its bitstream.
in addition for some arrays that are commonly present in candidate oss projects e.g.
sqr tb ... in openssl also exists in at least other oss projects a tf idf like frequency weight is also used to assign relatively small weights to such feature instances.
with the weights thus determined the degrees of contribution from different features in binary to source matching can be distinguished.
b. reuse type identification when we have a feature match between a cots software application and a candidate oss project a high matching score may not always indicate a true reuse and a low matching score may not always indicate a false reuse.
to improve the precision in reuse detection we distinguish between different types of code reuses by exploiting the code structures of oss projects.
in many cases a high matching score indicates a true reuse.
we define such reuse as simple reuse which may also be discovered by existing approaches .
however we have found two other types of reuses that show inconsistency between their actual reuse relationships and their matching scores obtained as shown in figure .
for example libssl akassleay one of the openssl libraries is generated by only .
of openssl source files.
any binaries that reuse libssl e.g.
ssleay32.dll infoxit reader reuse openssl partially despite their relatively low matching scores.
in contrast the matching score is quite high between libopenjp2 .dll ingimp andlibpng because a code fragment in libopenjp2 .dll is similar to that in libpng .
however this code fragment is actually compiled by the libpng module of openjpeg which may be a variation of the original libpng .
so the reuse between libopenjp2 .dll andlibpng which is referred to as pseudo propagated reuse should be eliminated.
we observe that in order to identify partial reuse and pseudo propagated reuse it is necessary to consider the complex code structures of oss projects.
to do this we first decompose an oss project into independent library modules by analyzing its compilation process to build the mappings from source files to generated libraries.
for example how the source files inopenssl are mapped to the library libssl can be determined from its linker flags.
we then construct a so1041 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
called inclusion relationship among the oss projects.
this is established by comparing the sets of feature instances matched in two oss projects.
as shown in the right side of figure aninclude edge from openjpeg tolibpng is added since the set of matched feature instances in openjpeg contains the set of matched feature instances in libpng .
these two types of code structures are helpful in identifying such reuses.
iii.
d esign in this section we introduce our detailed design of b2sf inder for detecting oss reuses in cots software.
a. selecting code features due to significant differences between source and binary code representations code features selected are expected to provide a uniform way for enabling feature matching.
there are two criteria for selecting a code feature.
first a code feature must be present simultaneously in both binary and source code.
second a code feature in source code should not be changed drastically during the compilation.
table i lists a total of candidate code features covering all the features used in existing binary similarity analysis techniques .
all the features meet the first criterion but only of the features satisfy the second criterion.
table i candidate code features and their susceptibility.
feature class feature name susceptible?
selected?
symbol export not check constant datastring slightly check global string array not check integer number a lot global integer array not check global enum array not check control flowcontrol flow graph a lot call graph a lot consts in switch case slightly check consts in if else slightly check string literals and exported function names are traditional code features that are also suitable for cots software.
however some oss projects such as unrar andbzip2 may not contain any useful strings for matching purposes and in addition cots software applications often end up with string literals stripped away in order to hide their software composition.
in many oss projects exported function names are frequently hidden when the code in the oss projects is called internally.
thus new code features are called for.
numerical and control flow related features can be invaluable.
in the previous binary analysis work constants are widely used but not all of them are suitable in our setting.
we find that numeric constants in source code that appear as immediate values in instructions of its compiled binary code are heavily affected during the compilation.
in contrast global integer arrays global enumeration arrays and global string arrays are usually not affected.
furthermore these global arrays usually contain some key information in an oss project.
for example an oss project using the cast5 cipher must have an stable like cast s table2 0x8defc240 0x25fa5d9f ... inopenssl making arrays important code features in reuse detection.switch ax case axis namespace ... break case axis child case axis descendant case axis desc or self case axis ancestor case axis preceding ... break listing a switch case structure.if a 0x80 length else if a 0x800 length else if a 0x10000 length else if a 0x200000 length else length return listing an if else structure.
compared with numeric features control flow related features can be more easily changed by compiler optmizations applied during the compilation.
under different compiler flags the binary codes generated from the same source function may have completely different control flow structures.
a program s call graph will also be affected by function inlining.
hence the control flow graph cfgs and call graphs cgs between binary and source code are not directly comparable.
fortunately complex branch sequences such as complex switch case and if else statements structures as in listings and are relatively stable during the compilation.
the constants in such structures are also selected as code features.
all of the seven features mentioned above are extracted by analyzing binary and source code.
for the binary code its switch case features are found by parsing its jump tables and its if else features are found by analyzing its cmp and jump instructions.
for the source code all numeric features are extracted based on reasoning about the subtrees with specific patterns in its abstract syntax tree and all the controlflow related features are found by traversing the conditional branches in its intermediate representation.
b. matching code features we have divided seven kinds of code features into three different types strings integers and control flow as shown in colum of table ii.
different methods will be used for matching different types of code features.
table ii the weighting algorithms for seven kinds of code features.
feature name specificity wt.
frequency wt.
string type features stringnumber of specific substringss idf export global string array integer type features global integer array entropy of bitstreams idfglobal enum array control flow type features consts in switch case length of const sequencess idfconsts in if else exact matching for string typed features.
as a string always stays the same during the compilation phase a string extracted from binary code and a string extracted from source code are considered to be equivalent when they are identical.
search based matching for integer typed features.
global integer enum arrays are stored in the data segments of a binary file as searchable continuous bitstreams.
thus we encode each as a bitstream according to the width of its data type e.g.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
bytes bytes or bytes and search directly for the bitstream in the .data and.rdata segments of a binary file.
semantics based matching for control flow typed features.
switch case structures and if else sequences are compared semantically as follows.
for a switch case feature in the source code of an oss project we represent it as an unordered list of case label sets with a default branch appended.
the default branch can be considered to match with any set of case labels in the binary of a cots software application.
for example the switch case feature bracketleftbig bracketrightbig from source code is considered to match with bracketleftbig bracketrightbigfrom binary code since the default branch from the source code matches with the last branch from the binary code.
for an if else feature we calculate the longest ordered common subsequence for each pair of if else sequences with one from source code and one from binary code and then determine their equivalence according to the length of their common subsequence.
for example an if else sequence from binary code matches with 0x80 0x800 0x10000 0x200000 from source code with a length of .
c. determining the importance weights of feature instances as oss projects grow in size the number of feature instances extracted from these oss projects will increase rapidly.
in fact feature instances do not contribute equally in feature matching.
therefore we can reduce the time spent on feature matching by considering only relatively important feature instances.
to differentiate feature instances in terms of their contribution to feature matching each feature instance is assigned a specificity weight and a frequency weight .
these two weights measure the contribution of a feature instance based on the information carried and its occurrence frequency in an oss project respectively.
consider an stable in the cast5 cipher 0x8defc240 0x25fa5d9f ... a sa n example.
it is unique and less likely to be similar to other data.
thus this stable will have a relatively large specificity weight.
however cast5 is a popular cipher with at least oss projects containing this stable.
since such frequent appearance does not help much with reuse detection this s table will be assigned a relatively small frequency weight.
as shown in table ii columns and all code features rely on the same algorithm s idf a variant of tf idf for computing their frequency weights.
for three different types of features three different methods are used for computing their specificity weights.
for a string typed feature we use the number of its substrings including urls and copyright information among others .
for an integer typed feature the entropy for its bitstream is used.
for a control flow typed feature the length of its constant sequence is used.
below we explain the algorithm used for computing the entropy of a bitstream the specificity weight for an integertyped feature and s idf for computing frequency weights.
computing the specificity weights of bitstreams as entrophy although many global arrays e.g.
the stableof cast5 cipher are specific there are still many others containing little useful information.
for example 0x0001 0x0010 0x0100 0x1000 as a list of flag bits has the same bitstream as many unrelated data potentially resulting in some incorrect matches.
for this reason we propose an entropy algorithm for a bitstream in order to compute the specificity weight of an integer typed feature.
table iii examples for computing the entropy of global arrays.
array array array hex 67e6096a... ... bit ... ... fragment xi ... ... length li entropy1 ... ... during the process of feature matching an integer array will be converted into a bitstream as illustrated in table iii.
specifically a bitstream is partitioned into a list of bit fragments where each fragment represents a maximum sequence of the same bit value or .
we can then compute the entropy of a bitstream based on the information entropy in information theory .
let xibe a bit fragment.
its occurrence probability denoted p xi is the probability of xi appearing in a bitstream defined as follows p xi 2li whereliis the length of xi.
then the entropy s x of a bitstream xcan be calculated as follows s x summationdisplay p xi l o g2 p xi summationdisplay 2lilog2 2li summationdisplayli 2li s idf for computing frequency weights the occurrence frequency of a feature instance is another factor that determines its contribution in the overall feature matching process.
for example the constant table in the unrar project exists only in one oss project while the constant table in the cast5 cipher exists in at least oss projects.
if the former table is matched we can easily determine that the unrar project has been reused.
however if the latter table is found it will not be as easy to make a conclusive decision.
therefore we make use of an s idf algorithm a tf idflike approach for computing the frequency weight f x of a feature instance x. here tf stands for term frequency and idf stands for inverse document frequency.
let s x be the appearance frequency of xin a given candidate oss project s x n x kn x wheren x is the number of xappearing in the candidate oss project and kn x is the total number of feature instances contained in the oss project.
following we defined f x s x idf x s x log2n n x authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
wherenis the total number of oss projects and n x is the number of oss projects containing x. algorithm matching score calculation input a binary file band a set sof candidate oss projects output a setrof potential reuse relationships 1function reusedetect b s 2r foreachs sdo foreachf fdo match feature instances fm fb parsebinfeature b f fs parsesrcfeature s f foreachfb fs fb fsdo ifismatched fb fs f then fm.add fs calculate weights foreachfs fsdo w s fs f fs ws ws w iffs fmthen wm wm w calculate matching scores score f wm w s ifscore f threshold fthen r tuple b s r.add r break returnr 22function ismatched fb fs f iff fstring then iffb fsthen return true else iff finteger then bits encode fs iffb.find bits then return true else f fcontrol iffis switch case then ftemp adddefault fs iffb ftemp then return true iffis if else then c getcommonsub fb fs iflen c threshold ifthen return true return false d. computing matching scores a matching score is computed in terms of weighted feature instances matched and consequently increases as the number of matched feature instances increases.
therefore we bound it from above by a threshold which is determined empirically for each feature.
if the matching score of any feature is larger than its threshold then the target binary is considered to have a reuse relationship with the corresponding source code.
algorithm shows how to compute a matching score.
given a binary file band a set sof candidate oss projects our approach identifies a set of oss reuses r based on seven kinds of code features f. for each oss project s sand each feature f f we extract a set of feature instances fb fromband a set of feature instances fs froms lines .
for each feature instance from fb fband each feature instance from fs fs i ffbandfsare matched we add fsinto the set of matched feature instances fm lines .
meanwhile we compute the weight wof eachfsby using our importance weighting algorithm line .
then we calculate two weighted sums wmforfmandwsforfs and subsequently obtain the matching score score ffor the featurefby dividing wmwithws lines .
if score f is larger than threshold f the oss project sis considered to be potentially reused in the binary band the reuse r b s is added to r lines .
finally we identify the type of reuse in r. by exploiting the code structure of sand removing the pseudo propagated reuses from r which will be introduced in section iii e below.
let us examine the matching function ismatched .
for a string typed feature fbandfsare matched only if they are identical.
for an integer typed feature if fscan be found in the bitstream of fbas discussed in section iii b then a match is found.
for a switch case feature after we have introduced a default branch in fs which is considered to be equal with any branch section iii b fsis considered to match with fbwhen all their case labels are identical.
for an if else feature we first obtain the longest ordered common subsequence of fbandfs and then check whether both has a common subsequence that is longer than a pre determined threshold.
e. identifying reuse types the existence of a reuse relationship for a given feature instance is not always positively correlated with its matching score as illustrated in table iv.
in these three examples the simple reuse performs consistently well in terms of code similarities.
in contrast the partial reuse represents a true reuse but with a low matching score while the pseudo propagated reuse represents a false reuse but with a high matching score.
table iv partial reuses and pseudo propagated reuses that cannot be determined accurately based on only matching scores score reuse example reuse high check foxitreader.exe zlib simple reuse high libopenjp2 .dll libpng pseudo propagated reuse low check foxitreader.exe openssl partial reuse identifying partial reuses partial reuse is common since a cots software application often shares only part of an oss project.
in order to reduce the false negative rate caused by low matching scores for some partial reuses we recognize independent libraries by building a compilation dependency layered graph cdlg and taking a single library instead of the whole oss project as a code matching unit.
a cdlg captures the relationships between source files and compiler generated files.
by parsing the default compiler and linker command lines for oss projects from their auto build files i.e.
makefiles the relationships between source files with the .cand.cpp suffixes object files with the .o suffix and dynamic libraries with the .so and.asuffixes are established.
then the files related to the same library are grouped together and the files that are not involved during the compilation are eliminated with the help of cdlg.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
srcsrc testtesti18ni18nrbt.cpp tmunit.cpp cfrtst.c chashtst.crbt.cpp tmunit.cpp ufile.cpp ustdio.cpp cfrtst.c chashtst.crbt.o tmunit.o ufile.o ustdio.olibicuin libicuioicudirectory structurecompilation dependency layered graph ufile.cpp ioio ustdio.cpp figure a compilation dependency layered graph cdlg for icu .
table v .
of the source files in icu are separated into six libraries and .
are ignored during the compilation.
uses of related source files o fa l l source files libraries .
libicuin .
libicuuc .
libicutu .
libicuio .
libicutest .
libicudata .
samples tests and others .
all .
take the unicode supporting project icu as an example with its cdlg depicted in figure .
the source files belonging to different libraries are separated in different groups.
in addition .
of the source files that are not related to any libraries are no longer analyzed as shown in table v. identifying pseudo propagated reuses these are false reuses that are caused by a propagation of irrelevant reuse relationships among the candidate oss projects.
for example libopenjp2 .dll ingimp reuses openjpeg which includes libpng as a third party library.
the matching score between libopenjp2 .dll andlibpng is high but their relationship is a pseudo propagated reuse.
we recognize the inclusive relationships among the candidate oss projects by comparing the matched feature instances in these candidate oss projects.
let f y be the set of all feature instances in a library yandmf x y be the set of all the matched feature instances between a binary program xand the library y. give a pair of libraries y1andy2whose matching scores with xare both larger than their underlying score thresholds section iii d .
there are two cases.
ifmf x y andmf x y are nearly identical i.e.
mf x y mf x y then we have size f y1 lessmuchsize f y2 y2reusesy1andxreusesy1 ifmf x y mf x y then we have size f y1 lessmuchsize f y2 y2reusesy1andxreusesy2.
based on the above two rules we can recognize pseudo propagated reuses efficiently without having to perform another round analysis for the oss projects as in osspolice .iv .
i mplementation we have implemented a file level matching framework b2sf inder for oss reuse detection in cots software.
a. architecture figure depicts the architecture of b2sf inder .
there are three modules extractor matcher and detector .
the extractor extracts the code features from both binary and source code and then stores them using an effective storage model to improve efficiency section iv c .
the compiler and linker command lines are also parsed to enhance the robustness of the extractor section iv b .
the matcher is responsible for code feature matching between binary and source code by applying our matching methods and computing matching scores.
the detector identifies reuses based on the set of matched feature instances and the cdlg of an oss project and generates a list of reuse relationships for a target cots software.
b. feature extraction from large scale source projects we extract the code features from source code by developing some static analysis tools on top of llvm and clang.
however care must be taken with static analysis.
in many oss projects header files are stored in some independent directories rather than the directories where the oss projects reside causing some header files to be missed.
meanwhile a particular version of macros used for conditional compilation may depend on the environments and specific compilers used causing some macros to be missed or used incorrectly.
to avoid these problems we proceed in three steps.
first we search for files like cmakelists.txt andautogen.sh in the oss projects to automatically detect the makefiles used.
second we parse these makefiles to obtain the gcc or libtool commands used without actually compiling an oss project entirely.
finally we locate the include paths and macros used from the arguments provided to the compiler flags iand d. thus our static source code analyzer is capable of analyzing the most of the source code in an os project.
c. storage model for large scale code features the time complexity of feature matching is closely related to the storage model used for code features.
in a naive implementation analyzing a single cots product can take over one day.
to shorten this we make use of two data structures an inverted index and a trie a prefix tree .
inverted index.
in order to speed up string searching we build an inverted index for string features in cassandra a key value database .
as cassandra relies on a hash tree the average case time complexity for retrieving a string has been reduced effectively from o m too wheremis the number of string literals in an oss project.
trie.
we build a trie for two integer typed features global integer arrays and global enum arrays.
a trie is an ordered data structure based on the prefix of a target data.
when searching arrays in a binary file we traverse the trie and prune its subtrees if the prefix array does not exist.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
extractor matcher detector calculate similaritysource code featurescompilation arguments effective storage model feature databasefeature listextract feature store featurebin src matching resultscode similarity weight match featurereuse typecdlg reuse relationshipsidentify reuse typebinary code features figure the architecture of b2sf inder .
v. e v aluation we evaluate b2sf inder in terms of its precision and efficiency.
then we give our findings in detecting oss reuse vulnerabilities in a large number of real world cots software products.
we make use of two binary code datasets and one source code dataset described below.
dataset binaries with known reuses b1 .this dataset contains official stripped binaries compiled from commonly used open source projects that cover different application areas including video parsing e.g.
vlc pdf rendering e.g.
sumatrapdf and network protocols e.g.
openssl .
dataset real world cots software b2 .this dataset contains binaries from cots software products obtained from a collection of web sites.
we give a hashed list of these products at com 1dayto0day b2sfinder cots list.txt.
dataset public open source libraries s .this dataset contains open source libraries crawled from ubuntu packages the official package archive of ubuntu.
a. precision to measure precision of b2sf inder a benchmark suite consisting of official binaries dataset b1 and oss projects dataset s is used.
we have manually labeled a total of real reuses covering simple reuses partial reuses and pseudo propagated reuses in the benchmark suite.
based on the labeled reuses we compare b2sf inder with bat the only binary to source matching tool that can handle both pe and elf formatted executables and dynamic libraries.
we summarize our experimental results in table vi.
since bat simply ranks all the potential reuses without concluding which are reuses and which are not we introduce three criteria for bat the first one as a reuse top the first five containing a reuse top and the first xthat allows bat to achieve the highest precision highest p .
b2sf inder has successfully detected out of the reuses with only false positives obtaining a precision of .
and a recall of .
which significantly outperforms bat in all the settings.
bat reaches the highest accuracy f1 table vi comparing b2sf inder with bat with different criteria.
reuse tp1fp1fn1p2r2f1 b2sfinder .
.
.
bat top .
.
.
b a t t o p5 .
.
.
bat highest p .
.
.
1tp true positive.
fp false positive.
fn false negative.
2p precision.
r recall.
3highest pricesion mp matching percentage .
p possibility .
.
for top but detects only reuses while b2sf inder finds reuses in top .
even in the case of top bat still fails to detect out of reuses .
.
in contrast b2sf inder can detect of these reuses .
missed by bat.
osspolice is another existing binary to source matching tool targeting libraries by considering only string literals and exported function names as code features.
to compare with it we have configured b2sf inder to use only these two kinds of code features.
as a result b2sf inder fails to find .
of reuses demonstrating the necessity for also considering the other five code features in this research work.
unlike bat osspolice analyzes the relationships between a given binary and a candidate oss project independently making it difficult to handle partial reuses and pseudo propagated reuses precisely.
by relying on matching scores only these complex reuses may lead to a lot of false negatives and false positives.
by exploiting the code structures of oss projects b2sf inder has substantially improved precision by recognizing partial reuses and pseudo propagated reuses correctly.
as a result the false negatives have been reduced from to with a reduction of .
and the false positives have been lowered from to with a reduction of .
.
b. efficiency we have applied b2sf inder to analyze binaries from real world cots software products dataset b2 and public open source libraries dataset s on four virtual machines in an openstack cloud.
each virtual machine is equipped with two shared cores of intel xeon e5 v4 4gb memory and 128gb disks.
on average b2sf inder authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
7rs rwwrp figure the correlation between the number of feature instances and the size of it containing binary file.
takes .
seconds to analyze a binary file in the presence of open source libraries.
as shown in figure the number of feature instances correlates roughly linearly with the size of its containing binary file.
it takes less than seconds to analyze .
of all the binary files which is expected to be fast enough for an offline deployment.
to improve the efficiency of b2sf inder in detecting oss reuses in large scale oss projects we have employed two optimized data structures inverted index and trie.
compared with a naive matching algorithm in searching in libraries our implementation reduces the time spent on matching string types features for a cots software product from .
hours to .
minutes on average with a speedup of .5x from the inverted index used and the time spent on matching integer typed features for a cots software product from .
hours to .
minutes on average with a speedup of .5x from the trie used.
c. large scale analysis we now describe our findings in detecting oss reuse vulnerabilities in large scale real world cots software products.
oss reuses during the large scale analysis as discussed in section v b we have found pairs of reuse relationships between the binaries from dataset b2and the oss projects from dataset s. as shown in table vii .
of the binaries contained in .
of all the cots software products are found to have reused at least one open source library.
this shows that oss reuses are ubiquitous in cots software.
interestingly the reuse relationships in audio and video parsing software products are relatively more complex.
of the cots software products that reuse more than different oss projects out of them are audio or video parsing software products.
in addition .
of the binaries with some reuses contain at least two reuses indicating that multiple reuses coexist in a large number of binaries.
for the oss projects studied .
of them have been reused more than times.
however how frequent these oss projects are reused varies from project to project.
as shown in figure the top frequently reused libraries aretable vii the number of oss reuses in product and file level.
level all nr1cr1 1c r1 5c r1 cr1 product file 1nr no reuse.
cr count of reuses.
zlib libjpeg turbo libpng openssl sqlite freetype libtiff libsndfile unrar andexpat .
these libraries contain at least five previously disclosed vulnerabilities.
in particular openssl contains up to cves reported earlier.
on average these libraries have been found to contain .
vulnerabilities.
potential oss reuse vulnerabilities new vulnerabilities are continuously discovered in frequently reused oss projects.
by detecting oss reuses from a specific oss library we can discover potentially vulnerable cots software products with oss reuse vulnerabilities.
to demonstrate this we have selected three popular oss projects zlib a compression library pango a font parsing library and xerces c an xml parsing library against cots software products continually collected for two months as a case study.
in total we have found reuses of zlib reuses ofpango and reuses of xerces c all of which are versioned.
the version distributions are shown in figure in which each color refers to a unique version.
to our surprise of reuses for xerces c of reuses for both zlib andpango include the source codes released at least years ago earlier than .
almost all codes with those versions have unfixed vulnerabilities and are potentially vulnerable.
vi.
r elated work the previous work that is the most related to this work falls into two broad areas code clone detection and reuse detection.
a. code clone detection code clone detection aims at evaluating the similarity of two software programs and finding code clones based on a similarity score.
different techniques are applied in analyzing binary and source code due to their differences.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
jc jc uvscp jc1 0qfo44 juf sff5zqf jc5 6o3 yqbu jctoegjmf figure the top frequently reused oss projects.
source to source matching.
some techniques compare source code as plain text directly .
they can be efficient but not precise enough as the semantic information is completely ignored.
more techniques perform syntactic analysis on source code and then carry out a similarity analysis in terms of tokens abstract syntax trees asts and internal code dependencies .
some others combine machine learning and program analysis to learn the most important code features related to bugs and vulnerabilities .
binary to binary matching.
binary code analysis is harder than source code analysis.
disassembly is the first step for any binary analysis.
afterwards some techniques use directly the textual features in the assembly code to measure code similarity but most techniques opt to perform some semantic analysis in the assembly code.
for example control flow graphs and call graphs are commonly selected as code features and are often manipulated by graph based algorithms.
in addition binary raw data the i o behavior of basic blocks and execution traces are also good choices.
constants in code are also a good supplement .
in order to facilitate code searching self defined semantic hashing is commonly used in code indexing .
symbolic execution and theorem proving are being considered when trading efficiency for precision .
binary to source matching there are relatively few efforts on binary to source matching including bat osspolice and fiber .
bat takes string literals as the only code feature and produces a ranked list of potential oss reuses.
osspolice considers not only string literals but also exported function names as code features and introduces a hierarchical indexing scheme to index features.
fiber generates semantic signatures on control flow for functions to identify the syntax and semantic changes introduced by a patch under the assumption that the targeted functions are known.
b. reuse detection the objective here is to detect reuse relationships in software precisely.
although there has been a lot of research on detecting code reuses little has been done on detecting different types of reuse.
code matching scores can not always mjc 1bohp 9fsdft figure version distributions of zlib pango and xerces c accurately reflect the complex reuse relationships including partial reuses and pseudo propagated reuses.
some earlier attempts are concerned with partial reuses.
osspolice does not handle partial reuse and discuss the false negatives thus caused.
in a claim is made on detecting code theft where only partial code is reused but without providing any experimental evaluation.
in the case of pseudo propagated reuses osspolice builds a hierarchical index to record the inclusive relationships among the oss projects in order to eliminate pseudo propagated reuses.
vii.
c onclusion in this paper we propose a novel binary to source matching approach b2sf inder for detecting oss reuses in cots software.
b2sf inder proceeds by first computing matching scores and detecting different types of reuses.
to generate a precise matching score seven kinds of code features are selected and three matching methods are introduced for handling three different types of features.
then we assign a specificity weight and a frequency weight to each feature instance based on our importance weighting methods.
this enables us to compute a weighted sum of matched feature instances as the overall matching score.
in addition we present a precise reuse type identification method by exploiting the code structures of oss projects.
with b2sf inder we can discover oss reuses and potential oss reuse vulnerabilities in cots software.
acknowledgement we would like to thank all the anonymous reviewers for their comments on an earlier version of this paper and our shepherd dr junaid haroon siddiqui for helping us improve the presentation of the final version.
this work is supported in part by chinese national natural science foundation u1836209 national key research and development program of china 2016qy071405 strategic priority research program of the cas xdc02040100 xdc02030200 xdc02020200 xdc02010000 and australian research council grants dp170103956 and dp180104069 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.