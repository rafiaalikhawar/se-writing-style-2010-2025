finding and analyzing compiler warning defects chengnian sun vu le zhendong su department of computer science university of california davis usa cnsun vmle su ucdavis.edu abstract good compiler diagnostic warnings facilitate software development as they indicate likely programming mistakes or code smells.
however due to compiler bugs the warnings may be erroneous superfluous or missing even for mature production compilers like gcc and clang.
in this paper we propose the first randomized differential testing technique to detect compiler warning defects and describe ourextensive evaluation in finding warning defects in widely used c compilers.
at the high level our technique starts with generating random programs to trigger compilers to emit a variety of compiler warnings aligns the warnings from different compilers and identifies inconsistencies as potential bugs.
we develop effective techniques to overcome three specific challenges how to generate random programs how to align textual warnings and how to reduce test programs for bug reporting?
our technique is very effective we have found and reported bugs for gcc confirmed assigned or fixed and for clang confirmed or fixed .
this case study not only demonstrates our technique s effectiveness but also highlights the need to continue improving compilers warning support an essential but rather neglected aspect of compilers.
ccs concepts software and its engineering !compilers software testing and debugging human centered computing !usability testing .
introduction compiler warnings are diagnostic messages emitted during compilation on questionable constructs in language conforming code.
a warning message describes the reason of the warning and contains the location information of the problematic code fragment e.g.
column number line number and affected file .
developers use warning messages to detect bugs at compile time by matching their code against certain patterns which are either behaviors undefined in programming language standards or have been found to be likely programming mistakes.
for example the security engineering permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
2int f int a int i if a i else a stray semicolon here i return i gcc .
output s.c warning suggest braces around empty body in an else statement else a stray semicolon here figure bug of clang.
the function has an empty else branch.
the statement i 2on line is not controlled by the else branch due to the semicolon on line .
gcc emits a warning on this issue whereas clang misses it.
group at microsoft utilizes compiler warnings to discover potential security exploits in the process of security code reviews the maintenance engineers at hewlett packard improve the quality of code base in routine maintenance by correcting code on which compilers warn .
although compiler diagnostics is widely used and important it can still have bugs similar to the other compiler components e.g.
optimizers and code generators .
these bugs can negatively affect a compiler s usability and developer productivity.
figure shows an example of such a warning bug in clang .
.
in the code snippet of figure 1there is an inadvertent semicolon placed immediately after the else branch on line which makes the statement i on line unconditionally executed.
gcc emits a warning on this case whereas clang considers this code snippet free of problems.
this warning bug of clang delays the discovery of the coding error to the testing stage while it could have alerted the developer to the error earlier at compile time.
more details on compiler warning defects will be discussed in section .
.
although there has been extensive work on software testing and analysis little attention has been devoted to testing compilers diagnostic support.
this paper introduces the first effort in this direction a practical differential testing approach for validating warning support in compilers and an extensive evaluation in testing two production c compilers gcc and clang.
our technique and its 1this accepted test program was reported at show bug.cgi?id c5 which is different from the initial test program reported in the description of this bug report.
ieee acm 38th ieee international conference on software engineering accompanying tool epiphron2 leverage programs generated by a random program generator to detect inconsistent warning messages from different compilers under test.
the central assumption of our approach is that production compilers are mature and reliable and should emit same similar warnings on the same given program.
any inconsistent warning behavior indicates a likely compiler bug.
to effectively identify report compiler warning defects epiphron overcomes three key technical challenges how to generate adequate test programs to stress test compiler warning diagnostics how to align textual warnings from different compilers to identify inconsistencies and how to reduce test cases that trigger warning inconsistencies before reporting them to compiler developers?
challenge generating effective test programs.
testing compiler warning diagnostics mainly targets compiler front ends whereas traditional compiler testing focuses on the correctness of compiler optimizers and code generators.
this difference induces different requirements on the generated test programs.
for our purpose test programs should cover various language constructs to fully exercise the warning diagnostics yet it is unnecessary to execute them.
therefore we do not need to ensure that the test programs are free of undefined behaviors a critical requirement for traditional compiler testing .
furthermore to better design a program generator we have empirically studied the characteristics of all the historical warning bugs in gcc and clang fixed before .
we observe that most of these bugs are unrelated to the bodies of conditional statements and not within obviously dead code regions e.g.unreachable conditional branches .
we leverage this finding in our program generator which significantly reduces false positives in differential testing.
challenge aligning warnings.
we cannot directly compare the warning messages from different compilers to identify inconsistent warning behaviors because the messages are in natural language and different compilers may present them quite differently.
to tackle this challenge for each compiler we design specific parsers to extract computer recognizable warning records from its natural language warning descriptions.
we also design a warning taxonomy to assign each warning record a type.
based on the types of and the information in the extracted records we align the warning records from the two compilers.
any aligned pair with inconsistent records indicates a potential warning defect.
challenge reducing test cases.
once we find a warning bug before reporting it we need to reduce the bug triggering test program by removing parts of the program irrelevant to the bug.
the reduced program helps developers triage fix the bug.
however reducing warning bugs is much more complex than reducing regular compiler bugs.
in particular reducing miscompilation or crashing bugs only requires testing the behavior of the compiled executables or the exit code an integer of compilers .
however reducing warning bugs involves processing the textual warning output of compilers and needs expressive predicates to specify the inconsistency of interest which we would like to preserve after each iteration of reduction.
we base our reduction process on the alignment algorithm and further design a set of generic predicates over the aligned warning pairs.
we have applied epiphron to gcc and clang two mature and widely used production compilers.
our evaluation shows that epiphron is very effective in finding warning bugs even though both compilers code bases for c programming language standards c89andc99 have already been stable.
we have found and reported bugs to gcc accepted and bugs to clang accepted .
contributions.
below summarizes our main contributions 2epiphron was the greek god of prudence and shrewdness.
we introduce an effective random testing technique to validate the warning support of compilers and have realized it as a practical tool epiphron for testing c compilers.
epiphron includes a program generator specifically designed for testing warning diagnostics an alignment tool analyzing textual warnings to identify warning inconsistencies between compilers and a test program reducer to facilitate bug reporting.
epiphron has helped discover and report bugs to gcc and bugs to clang both of which are widely used and well tested production compilers.
specifically for gcc bugs have already been accepted fixed and bugs are pending developers response for clang bugs have been accepted fixed and bugs are pending developers response.
our evaluation itself i.e.reported bugs serves as a convincing empirical evidence calling for more attention on testing compiler warning diagnostics.
it opens up a new research direction to improve the usability of compilers to benefit both novice and experienced developers.
paper organization.
section presents the definition of warnings and how they are identified.
section introduces our approach for finding compiler warning defects while section presents the detailed results on our efforts in finding gcc and clang warning defects.
section discusses epiphron s false positive rate and applicability of static analysis checkers to detect warning bugs.
finally we survey related work section and conclude section .
.
compiler warnings a good compiler not only compiles source code correctly but also emits useful warnings to alert developers to potentially problematic code fragments.
a warning should contain the location information of the problematic code fragment i.e.
file name line number and column number and a message describing the potential problem.
some modern compilers may produce extra information such as the warning type and suggestions to eliminate the warning.
let us take the code in figure as an example.
gcc .
warns that the body of the else statement is empty.
the prefix s.c warning indicates that the current message is a warning and the problematic code is on line column of file s.c .
the potential problem is an else statement with an empty body.
the postfix is the name of the warning checker that emits this warning which can also serve as the warning type.
gcc also prints the problematic code fragment to help developers identify the problem easily.
it also provides a suggestion to silence this warning.
if the code is intended developers may suppress the warning by following the suggestion.
.
compiler warning mechanism matching code against certain patterns at the compilation stage underlies the mechanism of compiler warning generation.
these patterns can be classified into two general classes bad practice this type consists of patterns that have been found to be likely programming mistakes in practice.
the example in figure belongs to this category because although the code conforms to the c standard it is usually a bug or at least code smell in practice.
undefined behavior this type consists of behaviors that are undefined according to the programming language standard.
examples include using an uninitialized variable accessing an array index that is out of bound and dereferencing a null pointer.
file s.c 2char a 0xffff 0xeff gcc .
output s.c warning overflow in implicit constant conversion s.c warning overflow in implicit constant conversion a erroneous message gcc bug file s.c 2int f unsigned char a unsigned char b const unsigned l 4294967295u return l a !
b gcc .
output s.c warning comparison of promoted unsigned with unsigned b spurious warning gcc bug file s.c 2int f unsigned a int b return a !
b gcc .
output s.c warning comparison between signed and unsigned integer expressions c missing warning clang bug figure three compiler warning bugs compilers need different levels of program information to correctly generate warnings.
while some types of warnings only require syntactic information e.g.
the one in figure many others depend on semantic information only available via static program analysis.
.
importance of compiler warnings compiler warnings are important to both novice and experienced developers.
allain suggests that compiler warnings should be treated carefully because they provide a means to catch bugs early including those that are difficult to find during testing .
indeed large software companies have been using compiler warnings to improve code quality for years.
software maintenance.
software engineers at hewlett packard use compiler warnings to clean up source code in their routine maintenance .
during a maintenance activity they increase the level of compiler diagnostics to obtain a large number of compiler warnings.
a team of engineers is then assembled to resolve each warning.
so not only helps refactor buggy dangerous or wasteful code but also makes the system ready for new compilers.
security code review.
the security engineering group at microsoft utilizes compiler warnings to discover potential vulnerabilities during security code reviews .
they enable compiler diagnostics at the highest level to identify areas of code that require extra scrutiny.
their experience has shown that some warnings are actually bugs or at least hide real bugs which may be exploitable vulnerabilities.
.
categories of compiler warning bugs compiler warning bugs can negatively impact developers productivity and we categorize them into three general classes erroneous messages.
warning messages can be wrong.
the compiler may use a misleading or confusing sentence to describe figure overall framework of our approach the underlying problematic code fragment or produce an incorrect location.
figure 2a shows a gcc bug where the compiler emits two overflow warnings with incorrect locations.
incorrect or bogus warning messages frustrate developers wasting their effort in realizing that the warnings are incorrect.
modern integrated development environments ides are also impacted because they rely on compiler output to render errors warnings.
for example eclipse c c development tooling3parses the compilation output of gcc or clang to highlight problematic code.
this type of warning bugs will make eclipse behave bizarrely.
spurious warnings.
compilers emit superfluous warnings for benign code fragments.
in figure 2b gcc emits a sign comparison warning i.e.
comparison of promoted unsigned with unsigned in the returned expression.
however there is no bitwise not operation in the expression.
spurious warnings waste development time and resource.
for instance during a routine maintenance activity at hewlett packard a subsystem generated new warnings which took a team of engineers to resolve.
if a considerable number of warnings are superfluous a large amount of developers time will be wasted.
moreover bogus warnings may even cause the software build process to fail if the compiler is configured to treat warnings as errors i.e.
the flag werror of gcc and clang .
missing warnings.
compilers may overlook a potentially buggy code fragment and thus miss a warning.
figure 2c shows a clang bug where the compiler fails to report a problematic comparison between a signed integer and an unsigned integer.
note that a missing warning is not necessarily a feature request.
this example is a real bug as confirmed and explained by the developer.4missing warnings can prevent developers from finding bugs at early development stages.
for example the design decision of gcc not to warn on declared but unused static constants hides a bug in gdb .
in contrast clang has added a new warning flag wunused const variable to catch such unnoticed bugs.
all three types of warning defects above are exacerbated when novice developers are involved because they are usually unfamiliar with the programming language as stated by peter norvig .
.
approach our approach is based on the concepts of random and differential testing.
it takes as input a pair of compilers c fc1 c2gand a random program generator p and outputs inconsistent warning behaviors between c1andc2.
figure shows the overall framework of the proposed technique which contains two major steps random testing we first usepto generate a random program p. the two compilers c1andc2compile pand emit two raw warning output m1andm2 which are parsed into two sets of warnings w1andw2.
differential testing we compute the symmetric difference between the two warning sets w1andw2 i.e.
w1nw2 w2nw1 as potential warning defects for further investigation.
this process should be repeated indefinitely until reaching a global fixpoint i.e.
all inconsistencies are known or having exhausted the resource budget.
because the warning messages m1andm2are in natural language and have different natural language descriptions across different compilers it is difficult to directly compute set difference on m1 andm2.
therefore we first invoke a compiler specific parser to process the warning messages into a set of records m1tow1 and m2tow2 .
each record stores a warning s location type and other relevant information.
next the component warning aligner aligns w1andw2into a list of pairs based on the parsed records and computes the symmetric difference between w1andw2as potential warning bugs in either c1orc2.
the component filter removes known inconsistencies i.e.
false positives and reported bugs .
finally we reduce the test program that triggers each remaining inconsistency to obtain a minimized test program that still triggers the same inconsistency and report it if it is indeed a warning bug.
.
generating test programs testing compiler warning diagnostics mainly targets compiler frontends whereas traditional compiler testing usually focuses on the correctness of compiler optimizers and code generators.
this difference induces different requirements on the generated test programs.
for our purpose test programs should cover various language constructs to fully exercise the warning diagnostics yet it is not necessary to execute them.
therefore we do not need to ensure the test programs free of undefined behaviors a property otherwise critical to traditional compiler testing .
observations from historical warning bugs.
to design an effective program generator we empirically studied all historical warning bugs that were fixed before january .
in total we investigated bugs of gcc and of clang.
after analyzing the associated test cases we have the following two findings on the problematic statement son which compilers warn .sisnotwithin an obviously dead code region.
in other words there is no warning bug on an unreachable statement.
.sis usually notcontrol dependent on a conditional statement e.g.
if forandwhile .
that is compilers only analyze statements locally to emit warnings.
it does not matter whether the statements are within the body of a conditional statement or not.
epiphron program generator.
we design the epiphron program generator that supports nearly all the language constructs of the c language.
it produces random compilable test programs by unrolling the grammar of the c language.
at each step it picks a random viable grammar production to generate a construct e.g.
a statement or an expression .
epiphron generates much more diverse programs than csmith and orion .
we further improve epiphron by leveraging the two findings above to reduce false positives of differential testing.
in particular when epiphron generates a conditional statement it intentionally constructs warning free body such as an empty statement for if statements and break for loop statements.1char g char p hello p d segmentation fault here.
return p clang .
output s.c warning initializing char with an expression of type const char discards qualifiers figure bug of clang discovered by cvs.
the function tries to modify a string literal via a pointer referencing the literal.
according to the c standard the string literal hello always has static storage duration and is immutable on most architectures.
the statement on line modifies it which is undefined behavior and causes an illegal memory access on x86 linux.
in clang .
the command option weverything does not enable wwrite string thus missing the warning.
the above design is quite effective at differentially testing gcc and clang because it helps avoid certain false positives by construction.
indeed it is a compiler vendor s design decision whether to warn on problematic code in obviously dead code regions thus warning inconsistencies on dead code are often not confirmed as real bugs.
for example gcc might emit various warnings on dead code while clang only produces one warning that the code region is unreachable.
.
selecting reference compilers the assumption of our approach is that provided that the two compilers c1andc2are mature and defect free ideally they should emit the same set of warnings i.e.
w1 w2 for the same program p. this assumption is vital for effective differential testing which states that any discovered inconsistent warning behavior between c1 andc2is likely a bug in either c1orc2 or both .
the selection of c1andc2for differential testing is very important in our approach because a bad selection can cause many false positives that require manual investigation.
in this paper we adopt the following three strategies for choosing the right compilers for effective differential testing.
.
.
differential testing strategies cross compiler strategy ccs .
this strategy selects two different compilers that have been developed independently.
given a programming language we can select two of its mature and competing compilers for warning inconsistency checking.
gcc and clang are a good example here.
both compilers are mature and under active development for years.
in particular clang is designed to be a drop in replacement for gcc and supports all of the gcc command arguments and their semantics.
the motivating example shown in figure is uncovered using this strategy.
cross version strategy cvs .
this strategy selects different versions of a compiler for differential testing.
it specifically targets regressions in compiler warning support which correspond to bugs introduced in the newer version.
for example we can use clang .
as a reference compiler to test clang .
.
figure shows a bug in clang .
that is discovered by this strategy.
clang has a command option weverything which enables all diagnostics .
however in clang .
this invariant is broken 5clang .
is the current development version of clang the latest stable release is clang .
.
2061int const a 2unsigned fn1 unsigned short s 0x4578adbcaa1de677ll a return s a a function with an integer overflow at line s.c warning negative integer implicitly converted unsigned type s.c warning negative integer implicitly converted to unsigned type b duplicate warnings by gcc o0 non optimized s.c warning large integer implicitly truncated to unsigned type c a warning by gcc o1 optimized figure bug of gcc discovered by cos. gcc o0emits two duplicate warnings whereas gcc o1correctly emits only one warning as wwrite string is excluded from weverything which warns if an immutable string literal is assigned to a mutable pointer e.g.
char p hello .
the function gtries to modify a string literal via a non const pointer p which triggers a segmentation fault on line .
in order to fix the bug the developer should use an array to copy the string literal instead of using the pointer pto reference it i.e.char p hello .
clang .
is able to detect this problem with weverything and outputs the warning as shown below the function g. in contrast clang .
deems that the code is benign.
cross optimization strategy cos .
this strategy selects the same compiler but compiles the generated random program punder different optimization levels.
for example given gcc to test we can instruct gcc to compile pwithout optimizations with flag o0 asc1and compile pwith optimizations with flags o1 os o2or o3 as c2.
this strategy is inspired by discussions within the gcc and clang communities which state that warnings errors should be independent of optimization levels.
to quote some compiler developers we generally don t like for program validity or warnings to depend on the chosen optimization level by a clang developer6 i believe we strive for the warnings be independent of the optimization level by a gcc developer7 this strategy aims to find inconsistent warnings among different optimization levels.
figure shows a bug in gcc discovered by cos. for the integer overflow on line in figure 5a gcc o0 without optimization emits two duplicate warnings whereas gcc o1 with optimization enabled correctly emits a single warning.
.
.
relationship among the strategies ccs targets a general scope of warning defects cvs targets regressions of a single compiler and cos targets inconsistent warnings of a single compiler across different optimization levels.
each has a unique ability in finding compiler warnings defects.
in general cvs and cos have lower false positive rates because different versions and optimization levels of the same compiler are usually quite consistent in producing warning messages.
ccs can detect more types of warning defects than the other two but it can also report more false positives.
in particular it fails if the compilers c1andc2support different sets of warning types.
although gcc andalgorithm parsing the warning output of a compiler input text the textual warning output of a compiler output a set of parsed warning records 1function parse string text msg parsers a compiler specific set of warning message parsers list split the string textinto a list in which each element is a string representation for a single warning result ?
foreach warning w2listdo foreach message parser p2msg parsers do ifp accept w then ifwis parsable by p parse wto a record record p parse w result result frecordg break return result clang share a majority of flags they still have incompatibilities.
for example gcc has a command option wunused but set variable to warn on variables that are set but never used whereas clang does not.
as a result we cannot use differential testing to validate the correctness of this warning diagnostic.
in this regard the cvs and cos strategies may serve as good complements to ccs because they test the compiler warnings from different perspectives and only require a single compiler.
.
parsing warnings since compiler warnings are in natural languages and different compilers describe warnings in different ways it is difficult impossible to directly compute the symmetric difference of w1andw2.
to tackle this challenge we design a specific parser for each compiler to parse its warning messages.
algorithm presents the general workflow of parsing the warning output of a particular compiler.
initially we obtain a string text containing all the warning messages and then split it into a list where each element is a textual representation of an individual warning.
for each type of textual warnings we devise a specific message parser.
each message parser has two functions accept this function tests whether a string warning is parsable by this message parser.
for each type of warnings we design a regular expression re as a signature of the warning type.
if a warning message matches this re then it falls into this type.
the design of res is based on the warning messages embedded in the compiler source code.
for example we design the following re to parse the warning message component in figure 5c large integer implicitly truncated to .
type parse this function parses the warning string to a structured record by extracting the location i.e.
which file which line and which column the warning description and the type of the warning.
for example the warning in figure 5c can be parsed by a gcc message parser into the record in table .
table the warning record parsed from figure 5c file s.c line column type overflow message large integer implicitly truncated to unsigned type misc.
target unsigned in total we implemented distinct warning message parsers for gcc and ones for clang covering distinct types of 207algorithm aligning two sets of warning records input w1andw2 warning records parsed from two compilers output symmetric difference between w1andw2 1function align set w1 setw2 rm1 ?
a set of elements to remove from w1 rm2 ?
a set of elements to remove from w2 step .
remove equivalent pairs foreach a b w1 w2 do if a b is an equivalent pair then rm1 rm1 fag rm2 rm2 fbg step .
compute pairs with unmatched columns columns ?
a set of pairs with unmatched columns foreach a b w1nrm1 w2nrm2 do if a b has only unmatched columns then columns columns f a b g rm1 rm1 fag rm2 rm2 fbg step .
compute pairs with missing records missing ?
a set of pairs with missing records foreach a2 w1nrm1 do missing missing f a ?
g foreach b2 w2nrm2 do missing missing f ?
b g return columns missing warnings.
all parsers are precise at parsing target warnings as we design them by referring to the warning message templates encoded in the compiler source code.
our parsers also allow certain degree of variations flexibilities e.g.
different variable names in warning messages which significantly reduces the number of parsers we need to implement.
.
aligning warnings inconsistencies among compilers compiler versions or optimization levels are identified by aligning the warnings in w1andw2.
the result of alignment is a list of pairs of which the first element is either a warning in w1or?
i.e.
nothing and the other is either a warning in w2or?.
the alignment process produces the following three categories of pairs a b equivalence a2w1 b2w2 and both have the same warning type and the same location i.e.file line and column .
this category is not of interest.
unmatched columns a2w1 b2w2 and both have the same warning type and are on the same line in the same file but in different columns.
this category may indicate bugs of incorrect column numbers in warnings.
missing records a2w1 b ?
a ?
b2w2 .
this category constitutes the main body of inconsistencies for users to investigate.
algorithm describes the alignment process.
it first removes all equivalent pairs from w1andw2 between lines and .
it then computes pairs with unmatched columns between lines and .
finally it constructs the inconsistent pairs from the remaining warnings in w1nrm1 and w2nrm2 between lines and .
.
filtering warning inconsistencies after reporting an inconsistency to compiler developers we need to temporarily stop testing this type of inconsistencies until it is fixed.
we also need to eliminate false positive warnings to avoid unnecessary human inspection.
the filter component discards such warning pairs produced by the warning aligner component.
the filter determines whether to remove a warning pair a b based on its signature a triple pa pb category defined as follows algorithm reducing a test program input p a test program input c1andc2 two compilers under testing input pred a predicate over the aligned warnings of c1andc2specifying the symptom of a warning difference between c1andc2 output min a minimal test program reduced from psatisfying the predicate pred 1function reduce p pred c1 c2 min p while true do use c reduce or delta temp reduce min iftemp minthen cannot be further reduced break w1 parse c warn temp w2 parse c warn temp alignment align w1 w2 ifpred alignment then min temp return min pa the warning message parser that successfully parses a pb the warning message parser that successfully parses b category the category of this warning pair i.e.
equivalence unmatched column ormissing records this triple signature is able to precisely differentiate warning pairs because the parsers paandpbcapture the exact information of the warnings aandb e.g.
types content .
the filter component in figure maintains a set sof signatures of warning pairs to filter.
if a newly discovered warning pair matches any signature in sthen it is removed.
.
reducing test programs we generate large programs to increase the likelihood of triggering bugs.
once a test program ptriggers a warning inconsistency a b between two compilers c1andc2 it is necessary to reduce p to a smaller size by removing program elements irrelevant to the inconsistent pair a b .
this step is important as it not only helps us understand the bug and avoid reporting a duplicate but also assists developers in triaging fixing the bug.
this reduction process is generally more complex than the reduction process of compiler miscompilations and crashes .
test reduction for a miscompilation or a crashing bug only requires testing the behavior of the executables or exit statuses integers of compilers whereas in our case we need to tackle the textual warning output of compilations and need more expressive predicates to specify the symptoms of a b .
algorithm describes the overall procedure to reduce p. the invariant throughout the reduction process is that after reduction both compilers c1andc2still output the same inconsistent warning pair for the reduced program min.
this invariant is encoded in the parameter pred a predicate for testing whether the alignment of two warning sets w1andw2still preserve the inconsistency.
the reduce function on line can be implemented with standard reduction tools such as c reduce or delta .
we encapsulate all the parsing and aligning functionalities as a library and specify the invariant predicate as a boolean method in a modern programming language on top of the library.
our reduction process is effective.
a test program with several thousand lines of code can usually be reduced to a few lines usually within five lines .
.
empirical ev aluation we have been experimenting with epiphron on gcc and clang for six months.
although the two compilers are mature and stable 208in the past six months we are still able to report bugs to gcc of which have been confirmed assigned or fixed and bugs to clang of which have been confirmed or fixed.
.
testing setup hardware and compiler.
our evaluation has been conducted on a linux pc with intel r core tm i7 cpu .67ghz and 12gb ram.
for each compiler i.e.gcc and clang we test its daily built development trunk because developers fix bugs in trunk more promptly than in stable versions.
this reason further enables us to remove the filter on the reported bugs described in subsection .
timely so that we can stress test more warning types.
moreover developers usually implement new languages features or fix bugs in trunk yet the source code of warning diagnostics is much more stable than other components.
therefore the development trunk is not necessarily more buggy than stable versions in terms of warning diagnostics.
all our reported bugs except three affect the latest stable versions.
in the cross version strategy we use gcc .
.
and clang .
as reference compilers.
warning flags.
by default both gcc and clang do not enable all warnings.
for clang we use the following command flags to compile each source file clang weverything pedantic std c the flag weverything enables all the diagnostics available in clang std specifies which version of the c standard should be used for checking and compiling code and pedantic instructs the compiler to adhere strictly to the c standard.
gcc does not have a flag to enable all warning diagnostics.
even wall and wextra together only enable a subset of warnings.
we have to manually specify other warning flags of interest.
the whole command line of flags of gcc is shown below the interested reader may refer to for more information.
gcc wall wextra pedantic std c wpadded wundef wformat winit self wuninitialized wpacked wconversion wfloat equal wlogical op wswitch default wshadow wvla wmissing prototypes wcast qual wcast align wswitch enum wsign conversion wwrite strings wredundant decls wmissing field initializers testing period and testing strategies.
we spent non continuous six months on this project of which over four months was devoted to studying the characteristics of historical warning bugs designing algorithms and developing various tools e.g.
program generator aligner reducer .
the rest of time was spent in testing gcc and clang.
initially we tested all the three strategies ccs cvs and cos. all of them detected bugs.
however later we started to focus on ccs as both cvs and cos became saturated.
this is expected as discussed in subsection .
.
.
quantitative results we next discuss some statistical properties of the discovered bugs.
detected bugs.
table shows the details of all the bugs we reported so far.
in total we have reported bugs of which are confirmed by developers and are already fixed.
there are still bug reports pending developers response.
note for clang we only have out of confirmed which is likely due to limited human resources as we were told by active members of the llvm community that some apple developers went to work on swift.
information of all reported bugs gcc clang total reported confirmed pending rejected table further lists the details of all confirmed bugs including their identities bug triggering command flags priorities and severities assigned by developers current report statuses bug types and the differential testing strategies.
bug types.
we categorize warning defects into three classes as mentioned in section erroneous message spurious warning and missing warning.
table shows the breakdown of the bug types of all the confirmed bugs.
bug importance.
in gcc and clang s bug repositories the importance of bugs is described as the combination of two fields priority andseverity .
priority is used by developers to prioritize bugs to fix severity measures the impact of bugs ranging from the most severe release blocker to the least enhancement.
both fields are adjusted by developers when they confirm bugs.
as shown in table all our confirmed bugs have the default priority p3 and none of them is downgraded to p4 or p5.
only two of our bugs are labeled as minor by developers and the rest have the normal severity.
this demonstrates the importance and necessity of detecting compiler warning bugs.
compiler developers also care about warning bugs and in fact are already fixed in the latest gcc and clang releases.
size of reported test cases.
all of the test programs that we reported to gcc and clang bug tracking systems are under five lines of code.
the size of the original test programs generated by epiphron is around lines of code on average.
this demonstrates that our reduction process is quite effective at minimizing test programs.
.
assorted confirmed bug samples this section samples some bugs detected by epiphron to demonstrate its ability to find a broad range of warning defects.
these bugs have real impact on developers and some are even related to security critical problems such as clang bug discussed in section .
.
.
.
.
erroneous messages gcc bug .
gcc emits two warnings suggesting that the variables pfandpvmay be used before they are initialized.
however both warnings point to a wrong location line containing neither pfnorpv.
1void a int i int pf int pv i ?
pf two warnings here.
pv .
.
spurious warnings gcc bug .
the following function triggers a regression since gcc .
.
gcc emits a conversion warning on the expression f fn1 a on line suggesting that there is a conversion from unsigned int tointand it may cause the signedness of the result to change.
however as the sub expression fn1 a 209table confirmed bugs id flag priority severity status bug type strategy gcc pedantic p3 minor confirmed spurious ccs gcc wtype limits p3 normal fixed erroneous msg ccs gcc wunused value p3 normal fixed missing ccs gcc waggressive loop optimization p3 normal confirmed spurious ccs gcc wconversion p3 normal fixed erroneous msg ccs gcc woverflow p3 normal fixed erroneous msg ccs gcc wconversion p3 normal confirmed spurious cos gcc wsign compare p3 normal confirmed spurious cos gcc wsign conversion p3 normal fixed spurious cvs gcc wsign conversion p3 normal confirmed spurious cos gcc wsign compare p3 normal fixed erroneous msg ccs gcc wsign compare p3 normal confirmed spurious cos gcc wsequence point p3 normal confirmed missing cos gcc pedantic p3 normal fixed erroneous msg ccs gcc enabled by default p3 normal assigned erroneous msg ccs gcc pedantic p3 normal fixed erroneous msg ccs gcc wtype limits p3 normal confirmed missing cos gcc woverride init p3 normal fixed erroneous msg ccs gcc wuninitialized p3 normal confirmed erroneous msg ccs gcc wmaybe uninitialized p3 minor confirmed erroneous msg ccs gcc enabled by default p3 normal fixed erroneous msg ccs gcc wswitch p3 normal fixed missing ccs gcc wreturn type p3 normal confirmed spurious ccs gcc woverflow p3 normal fixed erroneous msg ccs gcc wimplicit function declaration p3 normal fixed erroneous msg ccs gcc pedantic p3 normal fixed missing ccs gcc wdiscarded qualifiers p3 normal confirmed erroneous msg ccs gcc wcovered switch default p3 normal confirmed missing ccs gcc wchar subscripts p3 normal fixed erroneous msg ccs gcc wdiv by zero p3 normal fixed missing ccs gcc wpadded p3 normal confirmed missing ccs gcc wbool compare p3 normal confirmed missing ccs gcc wbool compare p3 normal fixed missing ccs gcc wunused value p3 normal confirmed erroneous msg ccs gcc wunused value p3 normal confirmed missing ccs gcc wunused value p3 normal confirmed erroneous msg ccs gcc wsequence point p3 normal confirmed missing ccs gcc wvla p3 normal confirmed erroneous msg ccs clang wsign compare p3 normal confirmed missing ccs clang wtautological p3 normal confirmed missing ccs clang weverything p3 normal confirmed missing cvs clang wsequence point p3 normal confirmed missing ccs clang wempty body p3 normal confirmed missing ccs clang wformat p3 normal fixed missing ccs clang wc compat p3 normal confirmed missing ccs clang wshift count negative p3 normal fixed missing ccs clang wuninitialized p3 normal confirmed missing ccs clang winteger overflow p3 normal fixed missing ccs clang wstrict overflow p3 normal confirmed missing ccs clang wshift negative value p3 normal fixed missing ccs clang wtautological overlap compare p3 normal confirmed missing ccs clang error p3 normal confirmed spurious ccs table bug types of confirmed bugs gcc clang total erroneous message spurious warning missing warning total returns either or the scenario reported in the warning will never happen.
1extern int fn1 2unsigned fn int a unsigned f f fn1 a return f .
.
missing warnings compared to erroneous messages and spurious warnings which may take developers extra time to analyze missing warnings sometimes have a severe negative impact on software development as they hide bugs from developers and delay bug fixing.
clang bug .
in the following code the compiler is expected to emit a warning indicating that the expression a 0l is always false because the parameter ais unsigned and thus its minimum value is .
however as the two operands of the operator are of different types the parameter ais automatically promoted to a signed long of which the minimum value becomes a negative number.
as a result clang misses this warning.
int fn unsigned a return a 0l clang bug .
the following program has a bug which may lead to illegal memory access.
the problem is that the format string sis not null terminated i.e.not ending with and the function printf prints it.
the consequence of such a bug can be severe as it is also a type of software vulnerability which could be potentially used in security exploits.
clang fails to identify this problem.
void fn const char s format printf s .
unconfirmed bugs we still have a number of bugs pending developers confirmation.
this is especially true for clang.
the following shows two of them which we believe will be eventually accepted.
clang bug .
this bug is a missing warning.
in the following program the function fooon line accepts a parameter of type double .
but it is first cast to a function pointer which accepts a parameter of type int defined on line and then is called through this pointer on line .
this behavior is undefined in the c standard and is implementation dependent.
1int foo double x return int x 2typedef int f int 3int main int x incompatible pointer cast return f foo x gcc bug .
this bug is a missing warning of gcc.
the function call to strcpy on line uses the uninitialized variable s. however gcc does not warn on it as this call is optimized away based on its semantics i.e.
copying a string to itself is redundant before a warning can be generated.
this clever behavior hides the fact that the code is problematic and not portable.
when we compile it with clang the compiled program triggers a segmentation fault at runtime.
include string.h 2void f void char s strcpy s s .
debatable cases or compiler smells this section discusses two bugs that were not accepted but we believe that fixing them is still beneficial and can further improve the usability of compilers.
gcc bug .
the following code snippet has an obvious undefined behavior accessing an array with an index out of its bound.
however when gcc compiles it with an optimization level under o2 i.e.
at o0or o1 no warning is emitted on the illegal access on line .
the reason is that gcc needs to perform value range propagation analysis in order to emit the warning but the analysis is only enabled above o1.
in contrast clang has a better design that separates warnings from optimizations and thus the problem in the code is always alerted.
1int b 2int f return b gcc bug .
the following code snippet raises some debate whether to emit warnings for unreachable code.
the problem is at the function call fn1 a b on line .
it expects two unsigned parameters but the actual arguments are both of signedtype.
moreover the code is also unreachable as the left operand of the logical or operator is .
the current behavior of gcc just simply emits nothing for the code whereas clang emits three warnings two for the signedness changes of the parameters and one for the unreachable code.
a reasonable fix of gcc is to warn on the dead code but it is nontrivial and takes time as discussed at 1int a b 2int fn1 unsigned unsigned 3unsigned int fn2 return fn1 a b this example also demonstrates the importance and necessity of the program generator of epiphron.
the developers of both gcc and clang communities are aware of this difference between the two compilers and stand for their current designs.
therefore avoiding dead code in test programs can prevent such inconsistencies from reaching human investigation.
.
discussions in this section we discuss the precision of our technique i.e.
its false positive rate whether static rule checkers can help detect these warning bugs we have found and the comparison between epiphron program generator and csmith.
false positive rate.
the false positives of our technique are the warning inconsistencies that are rejected by compiler developers.
they generally originate from two sources the inconsistency is duplicate to an existing bug report the warning diagnostics of the inconsistency is not supported by both compilers.
as mentioned in section .
for the first case after reporting a bug we temporarily disable checking the same type of inconsistencies until the bug has been fixed for the second case we design a list of filters to weed out these known inconsistencies.
moreover the program generator of epiphron is designed to reduce false positives by generating warning free code in bodies of conditional statements cf.
subsection .
.
these two mechanisms work well in practice.
therefore we compute the false positive rate as a value within the following range rejected reported rejected pending reported in our evaluation the range is .
note that is simply an upper bound of the false positive rate which is mainly due to a relatively large number of pending bugs especially for clang .
when reporting a bug we have carefully checked its validity.
we believe some of the pending bugs will eventually be accepted.
static analysis checker.
static analysis checkers use static analysis to detect bugs in source code e.g.
findbugs clang static analyzer and pmd .
they can catch common program flaws and bugs at the early stage of development.
however allthe bugs reported in this paper are not detectable for them as these bugs are semantic bugs and specific to compilers.
that is in terms of warning diagnostics the manifestation of these bugs is just a symptom that the behavior of the compiler does not conform to the developers intention.
even though these tools were able to detect the type of these bugs the large code base and the complexity of gcc and clang would make the checkers hardly scale.
comparison with csmith.
csmith is a program generator aiming to stress test compiler optimizers and code generators.
it only supports a limited set of c language features.
for example it does not support enumerations or switch statements.
epiphron program generator outperforms csmith in terms of warning bug detection 211as it supports nearly all features of c language.
we have already found warning bugs that csmith cannot detect.
for example epiphron detected gcc that involves enumerations and switch statements.
cascaded compiler warnings.
a compiler emits an error if the program under compilation does not follow the grammar or the typing rules.
this error often results in other related errors referred to as cascaded errors.
differently compiler warnings are usually not cascaded.
each warning is generated locally and independent of others.
as the focus of our work is detecting bugs in compiler warning diagnostics rather than compiler errors all our test programs are syntactically valid and compilable.
therefore epiphron is not affected by this complex scenario i.e.
cascaded compiler warnings errors .
.
related work this section surveys related work on validating testing compiler and improving warning error message systems.
.
compiler testing compiler testing still remains the dominant technique for validating the correctness of production compilers.
besides internal regression test suites compiler developers may use commercial test suites for conformance checking and validation .
since it is expensive to maintain and develop such manually written test suites people recently leverage randomized testing to complementarily generate massive test cases to further validate compilers .
among them two notable efforts are csmith and orion .
both are proved to be very effective in practice each has found several hundreds of crashing and miscompilation bugs in production compilers gcc and llvm .
csmith is based on differential testing which has also been applied to test virtual machines and cpu emulators .
csmith generates random c programs and checks for inconsistent behavior across different compilers or compiler versions.
it has also been applied to find bugs in static analyzers such as frama c .
the major contributions of csmith are the number of c language constructs that it supports and the ability to generate complex programs that are free of undefined behavior most of the time.
orion presents a novel technique to systematically modify existing code either real or randomly generated and generate many test cases that are semantically equivalent to the original program w.r.t.
an input set.
instead of verifying different compilers or compiler versions behave exactly the same on a program it verifies that a compiler must behave the same on all test cases generated from a program under an input set.
although epiphron shares the same theme of differential testing it targets a different class of compiler bugs compiler warnings.
this brings up new technical challenges as we need to design a new program generator to stress test warning diagnostics a component in the frontend define the equivalence of compiler warnings across different compilers compiler versions and compiler optimization flags.
in contrast csmith and orion aim to test compiler optimizers and code generators with less focus on the diversity of language constructs used in test programs.
they pay more attention on validity of the semantics of test programs and only need to check for equivalence of the execution output which is well defined for integer programs.
another related program generator is ccg which produces random compilable programs to look for crashing bugs in c compilers.
however it only supports a limited set of c features.
therefore it is not as effective as epiphron in detecting compiler warning bugs.
mutation testing is also related .
in particular we can mu tate test programs so that more compiler warnings can be triggered.
however it is not clear how to design effective mutation operators yet.
we leave it as future work.
.
compiler errors and warnings the general problem of building good warning error message systems has been long acknowledged .
shneiderman presented a few guidelines on building such systems and showed that a good system could improve user productivity and satisfaction.
brown articulated the concern that little interest was paid by the community to error message design.
his analysis on pascal compilers showed that the messages were generally disappointing and did not clearly show suggestions for correction.
this problem is even more important in the context of learning and teaching as novice developers may spend hours on a simple error .
there have been some efforts to alleviate this problem.
for instance when a program is ill typed the compiler instructed by its type checker often reports error locations far away from the source problem .
lerner et al.
proposed a simple solution instead of reporting imprecise error messages provided by typecheckers they search for a similar programs that do type check and present them to users.
coull developed a database with common compilers errors together with their likely solutions.
when an error is encountered the system shows both the original message and its solution.
the authors demonstrated that the system has positive impact on the learning of students.
alternatively users may also look at how their peers fixed the warnings errors in the similar context and apply similar changes to their programs .
epiphron is complementary.
despite having the same general goal to improve warning error systems with previous work epiphron has a completely different execution.
it finds defects in such systems by finding their inconsistencies under the same configuration.
.
conclusion we have described an approach based on randomized differential testing to finding compiler warning defects and implemented it in the epiphron tool.
our empirical evaluation has shown that epiphron is very effective in detecting warning bugs in mature compilers.
within only six months of testing including four months development we have reported bugs of which have been confirmed assigned or fixed to date.
our work is the very first extensive effort in testing compilers warning support.
we believe that it opens up a new direction of research to improve the correctness and usability of compiler warnings and errors.
we are actively pursuing future work to extend the proposed technique to other languages such as c design a grey box approach to testing compiler warnings by incorporating coverage of compilers and support the testing of compiler error messages.
the data and source code used in this paper are publicly available at