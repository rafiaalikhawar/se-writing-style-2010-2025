pinpointing performance inefficiencies in java pengfei su college of william mary usa psu email.wm.eduqingsen wang college of william mary usa qwang06 email.wm.edu milind chabbi scalable machines research usa milind scalablemachines.orgxu liu college of william mary usa xl10 cs.wm.edu abstract many performance inefficiencies such as inappropriate choice of algorithms or data structures developers inattention to performance and missed compiler optimizations show up as wasteful memory operations.
wasteful memory operations are those that produce consume data to from memory that may have been avoided.
we present jxperf a lightweight performance analysis tool for pinpointing wasteful memory operations in java programs.
traditional byte code instrumentation for such analysis introduces prohibitive overheads and misses inefficiencies in machine code generation.
jxperf overcomes both of these problems.
jxperf uses hardware performance monitoring units to sample memory locations accessed by a program and uses hardware debug registers to monitor subsequent accesses to the same memory.
the result is a lightweight measurement at machine code level with attribution of inefficiencies to their provenance machine and source code within full calling contexts.
jxperf introduces only runtime overhead and memory overhead making it useful in production.
guided by jxperf we optimize several java applications by improving code generation and choosing superior data structures and algorithms which yield significant speedups.
ccs concepts general and reference metrics performance software and its engineering software maintenance tools .
keywords java profiler performance optimization pmu debug registers acm reference format pengfei su qingsen wang milind chabbi and xu liu.
.
pinpointing performance inefficiencies in java.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
introduction managed languages such as java have become increasingly popular in various domains including web services graphic interfaces and mobile computing.
although managed languages significantly improve development velocity they often suffer from worse performance compared with native languages.
being a step removed from the underlying hardware is one of the performance handicaps of programming in managed languages.
despite their best efforts programmers compilers runtimes and layers of libraries can easily introduce various subtleties to find performance inefficiencies in managed program executions.
such inefficiencies can easily go unnoticed if not carefully and periodically monitored or remain hard to diagnose due to layers of abstraction and detachment from the underlying code generation libraries and runtimes .
performance profiles abound in the java world to aid developers to understand their program behavior.
profiling for execution hotspots is the most popular one .
hotspot analysis tools identify code regions that are frequently executed disregarding whether execution is efficient or inefficient useful or wasteful and hence significant burden is on the developer to make a judgement call on whether there is scope to optimize a hotspot.
derived metrics such as cycles per instruction cpi or cache miss ratio offer slightly better intuition into hotspots but are still not a panacea.
consider a loop repeatedly computing the exponential of the same number which is obviously a wasteful work the cpi metric simply acclaims such code with a low cpi value which is considered a metric of goodness.
there is a need for tools that specifically pinpoint wasteful work and guide developers to focus on code regions where the optimizations are demanded.
our observation which is justified by myriad case studies in this paper is that many inefficiencies show up as wasteful operations when inspected at the machine code level and those which involve the memory subsystem are particularly egregious.
although this is not a new observation in native languages its application to java code is new and the problem is particularly severe in managed languages.
the following inefficiencies often show up as wasteful memory operations.
algorithmic inefficiencies frequently performing a linear search shows up as frequently loading the same value from the same memory location.
data structural inefficiencies using a dense array to store sparse data where the array is repeatedly reinitialized to store different data items shows up as frequent store followed by store operations to the same memory location without an intervening load operation.arxiv .12066v1 jun 2019esec fse august tallinn estonia pengfei su qingsen wang milind chabbi and xu liu 142for int bit dual bit logn bit dual ... for int a a dual a ... for int b b n b dual int i b int j b dual double z1 real data double z1 imag data double wd real w real z1 real w imag z1 imag double wd imag w real z1 imag w imag z1 real data data wd real data data wd imag data wd real data wd imag listing redundant memory loads in specjvm scimark.fft.
data is loaded from memory twice in a single iteration whereas it is unmodified between these two loads.
data data wd realvmovsd0x10 r9 r8 xmm2vsubsd xmm0 xmm2 xmm2... data wd real vaddsd0x10 r9 r8 xmm0 xmm0vmovsd xmm0 0x10 r9 r8 figure the assembly code at t style of lines and in listing .
suboptimal code generations missed inlining can show up as storing the same values to the same stack locations missed scalar replacement shows up as loading the same value from the same unmodified memory location.
developers inattention to performance recomputing the same method in successive loop iterations can show up as silent stores consecutive writes of the same value to the same memory .
for example the java implementation of npb .
benchmark is performs the expensive power method inside a loop and in each iteration the power method pushes the same parameters on the same stack location.
interestingly this inefficiency is absent in the c version of the code due to a careful implementation where the developer hoisted the power function out of the loop.
this list suffices to provide an intuition about the class of inefficiencies detectable by observing certain patterns of memory operations at runtime.
some recent java profilers identify inefficiencies of this form.
however these tools are based on exhaustive java byte code instrumentation which suffer from two drawbacks high up to runtime overhead which prevents them from being used for production software missing insights into lower level layers e.g.
inefficiencies in machine code.
.
a motivating example listing shows a hot loop in a jit compiled jitted method compiled with oracle hotspot jit compiler in specjvm2008 scimark.fft a standard implementation of fast fourier transforms.
the jitted assembly code of the source code at lines and is shown in figure .
notice the two loads from the memory location data 0x10 r9 r8 once into xmm2 at line and then into xmm0 at line .
data is unmodified between these two loads.
moreover iandjdiffer by at least 2and never alias to the same memory location see lines and .
unfortunately thecode generation fails to exploit this aspect and trashes xmm2 at line which results in reloading data at line .
with the knowledge of never alias we performed scalar replacement placed data in a temporary that eliminated the redundant load which yielded a .
speedup for the entire program.
without access to the source code of the commercial java runtime we cannot definitively say whether the alias analysis missed the opportunity or the register allocator caused the suboptimal code generation most likely the former.
however it suffices to highlight the fact that observing the patterns of wasteful memory operations at the machine code level at runtime divulges inefficiencies left out at various phases of transformation and allows us to peek into what ultimately executes.
a more detailed analysis of this benchmark with the optimization guided by jxperf follows in section .
.
.
contribution summary we propose jxperf to complement existing java profilers jxperf samples hardware performance counters and employs debug registers available in commodity cpus to identify program inefficiencies that exhibit as wasteful memory operations at runtime.
two key differentiating aspects of jxperf when compared to a large class of hotspot profilers are its ability to filter out and show code regions that are definitely involved in some kind of inefficiency at runtime hotspot profilers cannot differentiate whether or not a code region is involved in any inefficiency and pinpoint thetwo parties involved in wasteful work e.g.
the first instance of a memory access and a subsequent unnecessary access of the same memory which offer actionable insights hotspot profilers are limited to showing only a single party .
via jxperf we make the following contributions we show the design and implementation of a lightweight java inefficiency profiler working on off the shelf java virtual machine jvm with no byte code instrumentation to memory accesses.
we demonstrate that jxperf identifies inefficiency at machine code which can be introduced by poor code generation inappropriate data structures or suboptimal algorithms.
we perform a thorough evaluation on jxperf and show that jxperf with runtime overhead and memory overhead is able to pinpoint inefficiencies in well known java benchmarks and real world applications which yield significant speedups after eliminating such inefficiencies.
.
paper organization this paper is organized as follows.
section describes the related work and distinguishes jxperf .
section offers the background knowledge necessary to understand jxperf .
section highlights the methodology we use to identify wasteful memory operations in java programs.
section depicts the design and implementation ofjxperf .
section and evaluate jxperf and show several case studies respectively.
section discusses the threats to validity.
section presents our conclusions and future work.
related work there are a number of commercial and research java profilers most of which fall into the two categories hotspot profilers and inefficiency profilers.pinpointing performance inefficiencies in java esec fse august tallinn estonia hotspot profilers.
profilers such as perf asyncprofiler jprofiler yourkit visualvm oracle developer studio performance analyzer and ibm health center pinpoint hotspots in java programs.
most hotspot profilers incur low overhead because they use interrupt based sampling techniques supported by performance monitoring units pmus or os timers.
hotspot profilers are able to identify code sections that account for a large number of cpu cycles cache misses branch mispredictions heap memory usage or floating point operations.
while hotspot profilers are indispensable they do not tell whether a resource is being used in a fruitful manner.
for instance they cannot report repeated memory stores of the identical value or result equivalent computations which squander both memory bandwidth and processor functional units.
inefficiency profilers.
toddler detects repeated memory loads in nested loops.
ldoctor combines static analysis and dynamic sampling techniques to reduce toddler s overhead.
however ldoctor detects inefficiencies in only a small number of suspicious loops instead of in the whole program.
glider generates tests that expose redundant operations in java collection traversals.
memoizeit detects redundant computations by identifying methods that repeatedly perform identical computations and output identical results.
xu et al.
employ various static and dynamic analysis techniques e.g.
points to analysis dynamic slicing to detect memory bloat by identifying useless data copying inefficientlyused containers low utility data structures reusable data structures and cacheable data structures .
unlike hotspot profilers these tools can pinpoint redundant operations that lead to resource wastage.
jxperf is also an inefficiency profiler.
unlike prior works which use exhaustive byte code instrumentation jxperf exploits features available in hardware performance counters and debug registers that eliminate instrumentation and dramatically reduces tool overheads.
jxperf detects multiple kinds of wasteful memory access patterns.
furthermore jxperf can be easily extended with additional memory access patterns for detecting other kinds of runtime inefficiencies.
section details the comparison between jxperf and the profilers based on exhaustive byte code instrumentation.
remix similar to jxperf also utilized pmu while jxperf identifies intra thread inefficiencies such as redundant useless operations remix dentifies false sharing across threads.
background hardware performance monitoring units pmu .modern cpus expose programmable registers that count various hardware events such as memory loads stores cpu cycles and many others.
the registers can be configured in sampling mode when a threshold number of hardware events elapse pmus trigger an overflow interrupt.
a profiler is able to capture the interrupt as a signal known as a sample and attribute the metrics collected along with the sample to the execution context.
pmus are per cpu core and virtualized by the operating system os for each thread.
intel offers precise event based sampling pebs in sandybridge and following generations.
pebs provides the effective address ea at the time of sample when the sample is for a memory access instruction such as a load or a store.
this facility is oftenreferred to as address sampling which is a critical building block ofjxperf .
also pebs can capture the precise instruction pointer ip for the instruction resulting in the counter overflow.
amd instruction based sampling ibs and powerpc marked events mrk offer similar capabilities.
hardware debug registers.
hardware debug registers trap the cpu execution for debugging when the program counter pc reaches an address breakpoint or an instruction accesses a designated address watchpoint .
one can program debug registers to trap on various conditions accessing addresses accessing widths bytes and accessing types w trap andrw trap .
the number of hardware debug registers is limited modern x86 processors have only four debug registers.
linux perf event.
linux offers a standard interface to program pmus and debug registers via the perf event open system call and the associated ioctl calls.
a watchpoint exception is a synchronous cpu trap caused when an instruction accesses a monitored address while a pmu sample is a cpu interrupt caused when an event counter overflows.
both pmu samples and watchpoint exceptions are handled via linux signals.
the user code can mmap a circular buffer to which the kernel keeps appending the pmu data on each sample and extract the signal context on each debug register trap.
java virtual machine tool interface jvmti .jvmti is a native programming interface of the jvm.
a jvmti client can develop a debugger profiler aka jvmti agent in any c c based native language to inspect the state and control the execution of jvm based programs.
jvmti provides a number of event callbacks to capture jvm initialization and death thread creation and destruction method loading and unloading garbage collection start and end to name a few.
user defined functions are registered in these callbacks and invoked when the associated events happen.
in addition jvmti maintains a variety of information for queries such as the map from the machine code of each jitted method to byte code and source code and the call path for any given point during the execution.
jvmti is available in off the shelf oracle hotspot jvm.
methodology in the context of this paper we define the following three kinds of wasteful memory accesses.
definition dead store .s1ands2are two successive memory stores to location m s1occurs before s2 .s1is a dead store iff there are no intervening memory loads from mbetween s1ands2.
in such a case we call s1 s2 a dead store pair.
definition slient store .a memory store s2 storing a value v2to location m is a silent store iff the previous memory store s1performed onmstored a value v1 and v1 v2.
in such a case we call s1 s2 a silent store pair.
definition silent load .a memory load l2 loading a value v2 from location mis a silent load iff the previous memory load l1 performed on mloaded a value v1 and v1 v2.
in such a case we call l1 l2 a silent load pair.esec fse august tallinn estonia pengfei su qingsen wang milind chabbi and xu liu ...m...m...debug registerstore s1 pmu sample awatchpoint is armeda watchpoint exceptionmemory access sequencestore s2 figure jxperf s scheme for silent store detection.
the pmu samples a memory store s1that touches location m. in the pmu sample handler a debug register is armed to monitor subsequent access to m. the debug register traps on the next store s2tom.
ifs1ands2write the same values to m jxperf labels s2as a silent store and s1 s2 as a silent store pair.
silent stores and silent loads are value aware inefficiencies whereas dead stores are value agnostic ones.
we perform precise equality check on integer values and approximate equality check on floating point fp values within a user specified threshold of difference by default given the fact that all fp numbers under the ieee format are approximately represented in the machine.
for memory operations involved in the inefficiencies we typically use their calling contexts instead of their effective addresses to represent them which can facilitate optimization efforts.
figure highlights the idea of jxperf in detecting inefficiencies at runtime exemplified with silent stores.
pmu drives jxperf by sampling precise memory stores.
for a sampled store operation jxperf records the effective address captured by the pmu reads the value in this address and sets up a trap on store watchpoint on this address via the debug register.
the subsequent store to the same effective address in the execution will trap.
jxperf captures the trap and checks the value at the effective address of the trap.
if the value remains unchanged between the two consecutive accesses jxperf reports a pair of silent stores.
the watchpoint is disabled and the execution continues as usual to detect more such instances.
design and implementation figure overviews jxperf in the entire system stack.
jxperf requires no modification to hardware x86 os linux jvm oracle hotspot and monitored java applications.
in this section we first describe the implementation details of jxperf in identifying wasteful memory operations then show how jxperf addresses the challenges and finally depict how jxperf provides extra information to guide code optimization.
jxperf generates per thread profiles and merges them to provide an aggregate view as the output.
.
lightweight inefficiency detection silent store detection.
jxperf subscribes to the precise pmu store event at the jvm initialization callbacks and sets up pmus and debug registers for each thread via perf event api in the jvmti thread creation callback.
when a pmu counter overflows during the execution it triggers an interrupt.
jxperf captures the interrupt constructs the calling context c1of the interrupt and extracts the effective address mand the value v1stored at m. jxperf sets a w trap trap on store watchpoint on mand resumes the program execution.
java applicationoff the shelf oracle hotspot jvmoff the shelf linuxperf event apicommodity cpupmuoperating systemvirtual machinehardwareapplication debug registerjxperfjvmtifigure overview of jxperf in the system stack.
a subsequent store to mtriggers a trap.
jxperf handles the trap signal constructs the calling context c2of the trap and inspects the value v2stored at m. jxperf compares v1andv2.
ifv1 v2 a silent store is detected and jxperf labels the context pair c1 c2 as an instance of silent store pair.
jxperf disarms the debug register and resumes execution.
dead store detection.
jxperf subscribes to the precise pmu store event for dead store detection.
when a pmu counter overflows jxperf constructs the calling context c1of the interrupt extracts the effective address m sets a rw trap load and store watchpoint onm and resumes program execution.
when the subsequent access traps jxperf examines the access type store or load .
if it is a store jxperf constructs the calling context c2of the trap and records the pair c1 c2 as an instance of dead store pair.
otherwise it is not a dead store.
silent load detection.
the detection is similar to the silent store detection except that jxperf subscribes to the precise pmu load event and sets a rw trap watchpoint1to trap the subsequent access to the same memory address.
if the watchpoint triggers on a load that reads the same value as the previous load from the same location jxperf reports an instance of silent load pair.
the following metrics compute the fraction of wasteful memory operations in an execution fdeadstorepro i jdead bytes stored in ci cj i jbytes stored in ci cj fsilentstorepro i jsilent bytes stored in ci cj i jbytes stored in ci cj fsilentloadpro i jsilent bytes loaded from ci cj i jbytes loaded from ci cj fraction of wasteful memory operations in a calling context pair is given as follows fdeadstore cwatch ctrap dead bytes stored in cwatch ctrap i jbytes stored in ci cj fsilentstore cwatch ctrap silent bytes stored in cwatch ctrap i jbytes stored in ci cj fsilentload cwatch ctrap silent bytes loaded from cwatch ctrap i jbytes loaded from ci cj 1x86 debug registers do not offer trap only on load facility.pinpointing performance inefficiencies in java esec fse august tallinn estonia .
limited number of debug registers hardware offers a small number of debug registers which becomes a limitation if the pmu delivers a new sample before a previously set watchpoint traps.
to better understand the problem consider the silent load example in listing .
assume the loop indices iand j and the scalars sum1 andsum2 are in registers.
further assume the pmu is configured to deliver a sample every 1k memory loads and the number of debug register is only one.
the first sample occurs in loop iwhen accessing array which results in setting a watchpoint to monitor the address of array .
the second sample occurs when accessing array .
since the watchpoint armed atarray is still active we should either forgo monitoring it in favor of array or ignore the new sample.
the former choice allows us to potentially detect a pair of silent loads separated by many intervening loads and the latter choice allows us to detect a pair of silent loads separated by only a few intervening loads.
the option is not obvious without looking into the future.
a naive replace the oldest policy is futile as it will not detect a single silent load in the above example.
even a slightly smart exponential decay strategy will not work because the survival probability of an old watchpoint will be minuscule over many samples.
jxperf employs reservoir sampling which uniformly chooses between old and new samples with no temporal bias.
the first sampled address m1 occupies the debug register with .
probability.
the second sampled address m2 occupies the previously armed watchpoint with1 2probability and retains m1with1 2probability.
the third sampled address m3 either occupies the previously armed watchpoint with1 3probability or retains it m1orm2 with 3probability.
the ithsampled address misince the last time a debug register was available replaces the previously armed watchpoint with1 iprobability.
the probability pkof monitoring any sampled address mk k i is the same i ensuring uniform sampling over time.
when a watchpoint exception occurs jxperf disarms that watchpoint and resets its reservoir replacement probability to .
.
obviously with this scheme jxperf does not miss any sample if every watchpoint traps before being replaced.
the scheme trivially extends to more number of debug registers sayn .jxperf maintains an independent reservoir probability p for each debug register n .
on a pmu sample if there is an available debug register jxperf arms it and decrements the reservoir probability of other already armed debug registers otherwise jxperf visits each debug register and attempts to replace it with the probability p .
the process may succeed or fail in arming a debug register for a new sample but it gives a new sample nchances to remain in a system with nwatchpoints.
whether success or failure p of each in use debug register is updated after a sample.
the order of visiting the debug registers is randomized for each sample to ensure fairness.
notice that this scheme maintains only a count of previous samples not an access log which consumes o memory.
.
interference of the garbage collector garbage collection gc can move live objects from one memory location to another memory location.
without paying heed to gc events jxperf can introduce two kinds of errors it may erroneously attribute an instance of inefficiency e.g.
dead store to a1for int i i 10k i sum1 array 2for int j j 10k j sum2 array silent loads listing long distance silent loads.
all four watchpoints are armed in the first four samples taken in loop iwhen the sampling period is 1k memory loads.
naively replacing the oldest watchpoint will not trigger a single watchpoint owing to many samples taken in loop ibefore reaching loop j.jxperf employs the reservoir sampling to ensure each sample equal probability to survive.
location that is in reality occupied by two different objects between two consecutive accesses by the same thread it may miss attributing an inefficiency metric to an object because it was moved from one memory location to another between two consecutive accesses by the same thread.
ifjxperf were able to query the garbage collector for moved objects or addresses it could have avoided such errors however no such facility exists to the best of our knowledge in commercial jvms.
jxperf s solution is to monitor accesses only between gc epochs.
jxperf captures the start and end points of gc by registering the jvmti callbacks garbagecollectionstart and garbagecollectionfinish to demarcate epochs.
watchpoints armed in an older epoch are not carried over to a new epoch the first pmu sample or watchpoint trap that happens in a thread in a new epoch disarms all active watchpoints in that thread and begins afresh with a reservoir sampling probability of .
for all debug registers for that thread.
note that the gc thread is never monitored.
typically two consecutive accesses separated by a gc is infrequent for example the ratio of of gcs of pmu samplesis .4e in dacapo .
mr1 bach eclipse .
.
attributing measurement to binary jxperf uses intel xed library for on the fly disassembly of jited methods.
jxperf retains the disassembly for post mortem inspection if desired.
it also uses xed to determine whether a watchpoint trap was caused by a load or a store instruction.
a subtle implementation issue is in extracting the instruction that causes the watchpoint trap.
jxperf uses the perf event api to register a hw breakpoint perf event watchpoint event for a monitored address.
although the watchpoint causes a trap immediately after the instruction execution the instruction pointer ip seen in the signal handler context contextip is one ahead of the actual ip trapip that triggers the trap.
in the x86 variable length instruction set it is nontrivial to derive the trapip even though it is just one instruction before the contextip.
the hw breakpoint event in perf event is not a pmu event hence the intel pebs support which otherwise provides the precise register state is unavailable for a watchpoint.
jxperf disassembles every instruction from the method beginning till it reaches the ip just before the contextip.
the expensive disassembly is amortized by caching results for subsequent traps that often happen at the same ip.
the caching is particularly important in methods with a large body for example when detecting silent loads in dacapo .
mr1 bach eclipse without caching jxperf introduces runtime overhead.
.
attributing measurement to source code attributing runtime statistics to a flat profile just an instruction does not provide the full details needed for developeresec fse august tallinn estonia pengfei su qingsen wang milind chabbi and xu liu action.
for example attributing inefficiencies to a common jdk method e.g.
string.equals offers little insight since string.equals can be invoked from several places in a large code base some invocations may not even be obvious to the user code.
a detailed attribution demands associating profiles with the full calling context packagea.classb.methodc line .
... java.lang.string.equals line .
thus jxperf requires obtaining the calling context where a pmu sample occurs and the calling context where a watchpoint traps.
obtaining calling contexts without safepoint bias.
oracle jdk offers users two apis to obtain calling contexts officially documented getstacktrace and undocumented asyncgetcalltrace .
profilers that use getstacktrace suffer from the safepoint bias since jvm requires the program to reach a safepoint before collecting any calling context .
to avoid the bias jxperf employs asyncgetcalltrace to facilitate nonsafepoint collection of calling contexts .asyncgetcalltrace accepts u context obtained from the pmu interrupts or debug register traps as the input and returns the method id and byte code index bci for each stack frame in the calling context.
method id uniquely identifies distinct methods and distinct jitted instances of the same method a single method may be jitted multiple times .
with the method id jxperf is able to obtain the associated class name and method name by querying jvm via jvmti.
to obtain the line number jxperf maintains a bci line number mapping table for each method instance by querying jvm via jvmti api getlinenumbertable .
as a result for any given bci jxperf returns its line number by looking up the mapping table.
.
post mortem analysis jxperf produces per thread profiles to minimize thread synchronization overhead during program execution.
we coalesce these per thread profiles into a single profile in a post mortem fashion.
the coalescing procedure follows the rule two silent load silent store or dead store pairs from different threads are coalesced iff they have the same loads stores in the same calling contexts.
all metrics are also aggregated across threads.
typically it takes less than one minute to merge all profiles according to our experiments.
evaluation we evaluate jxperf on an core intel xeon e5 v3 cpu of .30ghz frequency running linux .
.
.
the machine has 128gb main memory.
jxperf is built with oracle jdk11 and complied with gcc .
.
o3 .
the oracle hotspot jvm is run in the server mode.
jxperf samples the pmu event mem uops retired all stores to detect dead stores and silent stores and mem uops retired all loads to detect silent loads.
we evaluate jxperf on three well known benchmark suites dacapo dacapo .
mr1 bach and scalabench .
additionally we use two real world performance bug datasets .
all programs are built with oracle jdk11 except dacapo bloat dacapo .
mr1 bach batik and eclipse and scalabench actors with oracle jdk8 due to the incompatibility.
we apply the large input for dacapo dacapo .
mr1 bach and scalabench and the default inputs released with the remaining programs if not specified.
parallel programs excluding threads used for the jit fraction 020406080100antlrbloatcharthsqldbavrorabatikeclipsefoph2jythonluindexlusearchlusearch fixpmdsunflowxalanactorsapparatfactoriekiamascalacscaladocscalapscalariformscalatestscalaxbspecstmtgeomeanmedian dead storesilent storesilent load dacapo 2006dacapo .12scalabenchfigure fraction of wasteful memory operations on dacapo dacapo .
mr1 bach and scalabench benchmark suites at the sampling periods of 500k 1m 5m and 10m.
the error bars are for different sampling periods.
fraction 020406080100antlrbloatcharthsqldbavrorabatikeclipsefoph2jythonluindexlusearchlusearch fixpmdsunflowxalanactorsapparatfactoriekiamascalacscaladocscalapscalariformscalatestscalaxbspecstmtgeomeanmedian dead storesilent storesilent load dacapo 2006dacapo .12scalabench figure fraction of wasteful memory operations on dacapo dacapo .
mr1 bach and scalabench benchmark suites by using different numbers of debug registers at the 5m sampling period.
the error bars are for different number of debug registers.
compilation and gc are run with four threads if users are allowed to specify the number of threads.
to deal with the impact of the non deterministic execution e.g.
non deterministic gc of java programs on experimental results we refer to georges et al.
s work to use a confidence interval for the mean to report results.
the confidence interval for the mean is computed based on the following formula where nis the number of samples xis the mean is the standard deviation and zis a statistic determined by the confidence interval.
in our experiments we run each benchmark times i.e.
n and use a confidence interval i.e.
z .
.
x z n in the rest of this section we first show the fraction of wasteful memory operations dead stores silent stores and silents loads on dacapo dacapo .
mr1 bach and scalabench benchmark suites at different sampling periods and different number of debug registers.
we then evaluate the overhead of jxperf on these benchmarks.
we exclude three benchmarks dacapo .12mr1 bach tradesoap tradebeans and tomcat from monitoring because of the huge variance in execution time of the native run tradesoap andtradebeans or runtime errors of the native run tomcat .
finally we evaluate the effectiveness of jxperf on the known performance bug datasets reported by existing tools.
fraction of wasteful memory operations.
figure shows the fraction of dead stores silent stores and silent loads on dacapo dacapo .
mr1 bach and scalabench benchmark suites atpinpointing performance inefficiencies in java esec fse august tallinn estonia runtime slowdown00.
.52antlrbloatcharthsqldbavrorabatikeclipsefoph2jythonluindexlusearchlusearch fixpmdsunflowxalanactorsapparatfactoriekiamascalacscaladocscalapscalariformscalatestscalaxbspecstmtgeomeanmedian .
.2dead store detectionsilent store detectionsilent load detection dacapo 2006dacapo .12scalabench a runtime slowdown.
memory bloat00.
.52antlrbloatcharthsqldbavrorabatikeclipsefoph2jythonluindexlusearchlusearch fixpmdsunflowxalanactorsapparatfactoriekiamascalacscaladocscalapscalariformscalatestscalaxbspecstmtgeomeanmedian .
.2dead store detectionsilent store detectionsilent load detection dacapo 2006dacapo .12scalabench b memory bloat.
figure runtime slowdown and memory bloat ofjxperf at the 5m sampling period on dacapo dacapo .
mr1 bach and scalabench benchmark suites.
table geometric mean and median of runtime slowdown and memory bloat ofjxperf at different sampling periods on dacapo dacapo .
mr1 bach and scalabench benchmark suites ds dead store ss silent store sl silent load .
500k1m5m10mslowdown1.
.
.
.
.
.
.
.03memory bloat1.
.
.
.
.
.
.
.05slowdown1.
.
.
.
.
.
.
.04memory bloat1.
.
.
.
.
.
.
.05slowdown1.
.
.
.
.
.
.
.05memory bloat1.
.
.
.
.
.
.
.06sampling periodds detectionss detectionsl detectiongeomean median table effectiveness of jxperf .
toddler and glider report and performance bugs from eight real world applications among which jxperf succeeds in reproducing and bugs respectively.
application of bugs reported by toddler glider of bugs reproduced by jxperfapache ant5 5apache collections21 16apache groovy1 6apache lucene0 1google guava4 9jfreechart1 2jdk1 0pdfbox0 5sum33 the sampling periods of 500k 1m 5m and 10m.
the following two takeaways are obvious the inefficiencies such as dead stores silent stores and silent loads pervasively exist in java programs.
the sampling period does not significantly impact the fraction of inefficiencies in java programs.
we further vary the number of debug registers from one to four to observe the variation in results at the same sampling period 5m as shown in figure .
we find the number of debug registers has minuscule impacts on the results except for a couple of shortrunning e.g.
2s benchmarks such as luindex andkiama which validates the strength of the reservoir sampling.
we checked the top five inefficiency pairs and their percentage contributions and found negligible variance across different sampling periods and different number of debug registers.
overhead.
runtime slowdown memory bloat is measured as the ratio of the runtime peak memory usage of a benchmark withjxperf enabled to the runtime peak memory usage of its native execution.
table shows the geometric mean and median of runtime slowdown and memory bloat at different sampling periods.
when the sampling period increases i.e.
sampling rate decreases the overhead drops as expected.
we emperically find the 5m sampling period yields a good tradeoff between overhead and accuracy which typically incurs runtime slowdown and memory bloat.
figure quantifies the overhead of jxperf on each benchmark at the 5m sampling period.
silent load detection typically has a higher overhead than the other two because loads are more common than stores in a program execution.
moreover jxperf sets the rw trap trap only on load watchpoints are unavailable in x86 processors which triggers an exception on both stores ignored and loads.
from the program perspective silent load detection for eclipse incurs higher runtime overhead than others because it executes more load operations and has more methods of large size that require jxperf to take more efforts to correct the off by one error at each watchpoint trap.
furthermore due to the non deterministic behavior of gc the peak memory usage for a couple of benchmarks with jxperf enabled is less than the native run e.g.
eclipse xalan or varies significantly among different runs e.g.
factorie .
effectiveness.
we investigate the performance bugs reported by several state of the art tools such as toddler clarity glider and ldoctor .
among them the developers of toddler and glider share their bug datasets and test cases that expose the bugs online .
therefore we validate the effectiveness ofjxperf by checking whether the bugs reported by toddler and glider can also be identified by jxperf .
toddler and glider are both built atop soot to identify a restricted class of performance issues redundant operations involved in java collection traversals of which the symptom is silent loads.
it is worth noting that the runtime overheads of toddler and glider are and respectively.
table shows the comparison results.
toddler reports bugs we exclude the bugs whose source codes or test cases are no longer available among which jxperf misses only two bugs apache ant andapache collections .
glider reports bugs among which jxperf misses only two bugs apache ant andjfreechart unknown bug id .
take apache collections one of the reported bugs as an example to illustrate how jxperf identifies it.
listing shows the inefficient implementation of method retainall in apache collections .
jxperf reports of silent loads are associated with method contains at lineesec fse august tallinn estonia pengfei su qingsen wang milind chabbi and xu liu 1public boolean retainall final collection ?
coll if coll !
null boolean modified false final iterator e e iterator while e. hasnext if !
coll .
contains e. next e. remove modified true return modified else return decorated .
retainall null listing inefficient implementation of method retainall in apache collections .
jxperf reports that of silent loads are associated with method contains at line when the parameter coll is of type list.
when the parameter collection coll is of type list.
for each element in iterator e contains performs a linear search over coll to check whether coll contains this element.
consequently elements in coll are repeatedly traversed whereas their values remain unchanged which shows up as silent loads.
converting coll to a hash set is a superior choice of data structure that enables o search algorithm and dramatically reduces both the number of loads and also the fraction of silent loads.
all the missed performance bugs fall into the same category inefficiency observed in adjacent memory locations rather than the same memory location.
we take apache ant as an example to illustrate why jxperf misses it.
the method a.addall int index collection b inant requires inserting elements of collection aone by one into the location index of collection b. in each insertion elements at and behind the location index ofbhave to be shifted.
consequently elements in bsuffer from the repeated shifts.
the symptom of such inefficiency is that the same value is repeatedly loaded from adjacent memory locations.
jxperf only identifies silent loads that repeatedly read the same value from the same memory location.
jxperf can be extended with a heuristic to record values at adjacent locations at the sample point and compare them in a watchpoint.
it is worth noting that inefficiencies identified by toddler clarity glider and ldoctor are mostly related to load operations whereas jxperf also identifies significant store related inefficiencies.
case studies in addition to confirming the performance bugs reported by existing tools we apply jxperf on more benchmark suites dacapo specjvm2008 npb .
and grande .
and real world applications sablecc .
findbugs .
.
jfreechart .
.
to identify varieties of inefficiencies.
table summarizes the newly found performance bugs via jxperf as well as previously found ones but with different insights provided by jxperf .
all programs are built with oracle jdk11 except dacapo bloat and findbugs .
.
which are with oracle jdk8.
we measure the performance of all programs in execution time except specjvm2008 scimark.fft which is in throughput.
we run each program times and use a confidence interval for the mean speedup to report the performance improvement.
in the rest of this section we study each program shown in table .
spec.harness.benchmarkthread.run benchmarkthread.java spec.harness.benchmarkthread.executeiteration benchmarkthread.java spec.harness.benchmarkthread.runloop benchmarkthread.java spec.benchmarks.scimark.fft.main.harnessmain main.java spec.benchmarks.scimark.fft.main.runbenchmark main.java spec.benchmarks.scimark.fft.fft.main fft.java spec.benchmarks.scimark.fft.fft.run fft.java spec.benchmarks.scimark.fft.fft.measurefft fft.java spec.benchmarks.scimark.fft.fft.test fft.java spec.benchmarks.scimark.fft.fft.inverse fft.java vmovsd 0x10 r9 r8 xmm2 ...transform internal fft.java redundant with spec.harness.benchmarkthread.run benchmarkthread.java spec.harness.benchmarkthread.executeiteration benchmarkthread.java spec.harness.benchmarkthread.runloop benchmarkthread.java spec.benchmarks.scimark.fft.main.harnessmain main.java spec.benchmarks.scimark.fft.main.runbenchmark main.java spec.benchmarks.scimark.fft.fft.main fft.java spec.benchmarks.scimark.fft.fft.run fft.java spec.benchmarks.scimark.fft.fft.measurefft fft.java spec.benchmarks.scimark.fft.fft.test fft.java spec.benchmarks.scimark.fft.fft.inverse fft.java vaddsd 0x10 r9 r8 xmm0 xmm0 ...transform internal fft.java figure a silent load pair with full calling contexts reported by jxperf in specjvm2008 scimark.fft.
.
specjvm2008 scimark.fft silent loads with the large input and four threads jxperf reports of memory loads are silent.
the top two silent load pairs are attributed to lines and and lines and in listing which account for of the total silent loads.
they both suffer from the same performance issue poor code generation detailed in section .
.
we take lines and as an example to illustrate our optimization of which the culprit calling contexts are shown in figure .
we employ scalar replacement to eliminate such intra iteration silent loads.
in each iteration we store the value of data in a temporary before performing line which enables data to be loaded only once in each loop iteration.
we also eliminate the silent loads between lines and using the same approach.
they together eliminate of the total memory loads and yield a .
.
speedup for the entire program.
.
grande .
euler dead stores euler employs a structured mesh to solve the time dependent euler equations.
jxperf identifies stores are dead.
one of the top dead store pairs is associated with the variable temp2.a at lines and in listing which appears in a loop nest not shown .
by inspecting the jitted assembly code shown in figure we find the value of temp2.a computed at line is held in a register which is reused at line .
however the memory store to temp2.a at line is not eliminated.
as a result the memory store to temp2.a at line overwrites the previous memory store to temp2.a at line .
although cpus buffer stores workloads with many store operations such as euler can cause cpu stalls due to store buffers filling up .
to eliminate the dead stores we use a temporary to replace temp2.a at lines and to avoid using temp2.a .jxperf also identifies other dead store pairs with the same issue and guides the same optimization.
our optimization eliminates of total memory stores and yields a .
.
speedup.
our optimization is safe because temp2 is a local object defined in the method calculatedamping line to store the intermediate results the object it refers to is never referenced by any other variable.pinpointing performance inefficiencies in java esec fse august tallinn estonia programinefficiency optimization code type root cause patch speedup macro benchmark specjvm2008 scimark.fft fft.java loop sl poor binary code generation scalar replacement .
.
npb .
is random.java randlc ss redundant method invocations reusing the previous result .
.
grande .
eulertunnel.java calculater tunnel.java calculatedampingds poor binary code generation scalar replacement .
.02real world application sablecc .7grammar.java lr0collection.java lr1collection.java lr0itemset.java lr1itemset.java sl poor data structure replacing treemap with linkedhashmap .
.
findbugs .
.
frame.java copyfrom ds inefficiently used arraylist improving arraylist usage .
.
dacapo bloat registerallocator.java loop ds useless value assignment in jdk removing the overpopulated containers .
.
jfreechart .
.
segmentedtimeline.java loop sl poor linear search linear search with a break check .
.
newfound performance bugs via jxperf .
ss silent store ds dead store sl silent load.
table overview of performance improvement guided by jxperf .
1private void calculatedamping double localpg statevector localug statevector temp2 new statevector if j j jmax temp localug .
svect localug temp2 .a .
localug .a localug .
a ... scrap4 .a tempdouble temp .a temp2 .a ... if j j jmax temp localug .
svect localug temp2 .a .
localug .a localug .a ... ... listing dead stores in grande .
euler.
successive memory stores totemp2.a without an intervening memory load.
temp2.a .
localug .a localug .a vsubsd xmm1 xmm0 xmm0vmulsd 0x1a76 rip xmm0 xmm0vmovsd xmm0 0x10 r8 ... scrap4.a tempdouble temp.a temp2.a vaddsd xmm0 xmm5 xmm5vmulsd xmm4 xmm5 xmm5vmovsd xmm5 0x10 r9 ... temp2.a .
localug .a localug .a vsubsd xmm1 xmm0 xmm0vmulsd 0x2077 rip xmm0 xmm0vmovsd xmm0 0x10 r8 figure the assembly code at t style of lines and in listing .
.
sablecc .
silent loads sablecc is a lexer and parser framework for compilers and interpreters.
jxperf profiles the latest stable version of sablecc by using the jdk7 grammar file as the input.
jxperf identifies that silent loads account for of the total memory loads and more than of silent loads are associated with method put of the jdk treemap class.
one of such top inefficiency pairs with calling contexts is shown in figure .
the silent loads occur at line in treemap.java whose source code is shown in listing .
treemap is a red black tree based map where a putoperation requireso logn comparisons to insert an element.
put is frequently invoked to update the treemap during program execution.
consequently previously loaded elements in the treemap are often org.sablecc.sablecc.sablecc.main sablecc.java org.sablecc.sablecc.sablecc.processgrammar sablecc.java ... mov 0x20 rbp r10d java.util.treemap.put treemap.java redundant with org.sablecc.sablecc.sablecc.main sablecc.java org.sablecc.sablecc.sablecc.processgrammar sablecc.java ... mov 0x20 rbp r10d java.util.treemap.put treemap.java figure a silent load pair reported by jxperf in sablecc .
.
561public v put k key v value entry k v t root ... do parent t cmp k. compareto t. key if cmp t t. left else if cmp t t. right ... while t !
null ... listing method put of the jdk treemap class.
a put operation requireso logn comparisons to insert an element.
re loaded to compare with new elements being inserted in different instances of put which shows up as silent loads.
by consulting the sablecc developers we choose an alternative data structure.
we replace treemap with linkedhashmap because the linked list preserves ordering from one execution to another and the hash table offers o time complexity and obviously reduces the number of loads as well as the fraction of silent loads.
we employ this transformation in five classes lr0itemset lr1itemset lr0collection lr1collection and grammar .
this optimization reduces the memory loads by and delivers a .
.
speedup to the entire program.
.
npb .
is silent stores is sorts integers using the bucket sort.
with the class b input and four threads jxperf pinpoints that of memory stores are silent of which more than are associated with method pow at lines in listing .
we notice method randlc is invoked in a hot loop not shown and the arguments passed to pow are loop invariant.
across loop iterations pow pushes the same parameters on the same stack location which shows up as silent stores.
to eliminate such redundant operations we hoist the four calls topow outside of randlc and memoize their return values inesec fse august tallinn estonia pengfei su qingsen wang milind chabbi and xu liu 1public double randlc double a double y r23 r46 t23 t46 ... r23 math .
pow .
r46 math .
pow r23 t23 math .
pow .
t46 math .
pow t23 ... listing silent stores in npb .
is.
method pow repeatedly pushes the same parameters on the same stack across loop iterations.
1union new hashset 2for int i i copies .
size i ... union .
addall ig.
succs copy union .
addall ig.
succs copy weight union .
size ... listing dead stores in dacapo bloat.
useless value assignment in the jdk hashmap class leads to dead stores.
private class variables.
jxperf further identifies other code snippets having the same issue and guides the same optimization.
these optimizations eliminate of memory stores and yield a .
.
speedup for the entire program.
.
dacapo bloat dead stores bloat is a toolkit for analyzing and optimizing java byte code.
with the large input jxperf reports dead stores.
more than of dead stores are attributed to the call site of method addall at lines and in listing where the program computes the union of hashset ig.succs copy andhashset ig.succs copy and stores the result in hashset union .
guided by the culprit calling contexts we notice the root cause of such dead stores is related to the field current of the jdk hashmap class as shown in listing .
method addall invokes the method nextnode of thehashmap class in a loop not shown .
in each iteration the field current is overwritten with the newly inserted value but never gets used during the execution which shows up as dead stores.
with further code investigation we find that hashset union is created for only computing the size of the union of ig.succs copy and ig.succs copy and elements in union are never used.
therefore we can eliminate the dead stores by avoiding creating union .
we declare a counter variable to record the size of the union of ig.succs copy and ig.succs copy .
the counter is initialized to the size of the larger one in ig.succs copy andig.succs copy .
then we visit each element of the smaller one and check whether that element is already in the larger one.
if not the counter increments by .
this optimization reduces of memory stores and yields a .
.
speedup for the entire program.
yang et al.
also identify the same optimization opportunity via the high level container usage analysis which is different from jxperf s binary level inefficiency analysis.
.
findbugs .
.
dead stores findbugs is a static analysis tool for detecting security and performance bugs.
we profile it using the jdk rt.jar as the input.1final node k v nextnode node k v t node k v e next ... if next current e .
next null t table !
null do while index t. length next t null return e listing method nextnode of the jdk hashmap class.
1private final arraylist valuetype slotlist ... 3public void copyfrom frame valuetype other int size slotlist .
size if size other .
slotlist .
size for int i i size i slotlist .
set i other .
slotlist .
get i else slotlist .
clear for valuetype v other .
slotlist slotlist .
add v ... listing dead stores in findbugs .
.
.
inefficiently used arraylist leads to dead stores.
1public void copyfrom frame valuetype other int a slotlist .
size int b other .
slotlist .
size int min a b ?
b a for int i i min i slotlist .
set i other .
slotlist .
get i if a min slotlist .
sublist b a .
clear else for int i a i b i slotlist .
add other .
slotlist .
get i listing optimizing the code in listing to eliminate dead stores.
jxperf reports dead stores in this program.
one of the top dead store pairs is attributed to the instance variable arraylist slotlist at lines and in listing .
with an investigation into the implementation of the jdk arraylist class we find that the method clear assigns the null value to all elements in slotlist and sets its size to zero instead of reclaiming the occupied space.
when an element is inserted into slotlist later by invoking the method add the null value at the given location of slotlist without any usage is overwritten which shows up as dead stores.
we redesign the code to eliminate the dead stores as shown in listing .
we first compare the size of arraylist slotlist say a with the size of arraylist other.slotlist say b to obtain the size of the smaller say min.
we then replace the first minelements in slotlist with the first minelements in other.slotlist line by invoking method set .
finally if a min we invoke clear to clear only the remaining elements in slotlist line otherwise we invoke add to append the remaining elements inother.slotlist toslotlist line .
with this optimization the total number of memory stores is reduced by and the entire program gains a .
.
speedup.
.
jfreechart .
.
silent loads jfreechart is a chart library.
jxperf reports of memory loads are silent on profiling the built in test casepinpointing performance inefficiencies in java esec fse august tallinn estonia 1private list exceptionsegments new arraylist ... 3public long getexceptionsegmentcount long frommillisecond long tomillisecond int n for iterator iter this .
exceptionsegments .
iterator iter .
hasnext segment segment segment iter .
next segment intersection segment .
intersect frommillisecond tomillisecond if intersection !
null n intersection .
getsegmentcount return n listing silent loads in jfreechart .
.
.
immutable arraylist elements are repeatedly loaded from memory across invocation instances of method getexceptionsegmentcount .
segmentedtimelinetest and of silent loads are attributed to method getexceptionsegmentcount as shown in listing .
getexceptionsegmentcount performs a linear search line over arraylist exceptionsegments to count the number of segments that intersect a given segment frommillisecond tomillisecond .
this linear search is called multiple times in a loop to become the performance bottleneck.
the symptom of such inefficiency is silent loads which is caused by the repeated loads of immutable arraylist elements in different invocation instances ofgetexceptionsegmentcount .
we notice that segments in exceptionsegments are stored in ascending order that is the end point of the segment exceptionsegments.get i the start point of the segment exceptionsegments.get j iffi j. therefore there is no need to traverse the remaining segments in exceptionsegments if the start point of the current segment is already greater than tomillisecond .
with this optimization we reduce the memory loads by and the entire program achieves a .
.
speedup.
nistor et al.
also identify the same performance issue with toddler.
however their optimization guided by toddler benefits the program only in two extreme situations tomillisecond the start point of the first segment in exceptionsegments orfrommillisecond the end point of the last segment in exceptionsegments .
threats to validity jxperf works on multi threaded programs since pmus and debug registers are virtualized by the os for each program thread.
jxperf detects only intra thread wasteful memory accesses and ignores inter thread ones because a watchpoint traps iffthe same thread accesses the memory address the watchpoint is monitoring.
interthread access pattern detection is feasible but unwarranted for the class of inefficiencies pertinent to our current work.
due to the intrinsic feature of sampling jxperf captures statistically significant memory accesses but may miss some insignificant ones.
usually optimizing such insignificant memory accesses yields trivial speedups.
furthermore not all reported wasteful memory operations need be eliminated.
for example compiler savvy developers introduce a small number of silent loads or stores to make programs moreregular for the purpose of vectorization and security savvy developers introduce a small number of dead stores to clear confidential data .
developers investigation or post mortem analysis is necessary to make optimization choices.
only high frequency inefficiencies are interesting eliminating a long tail of insignificant inefficiencies that do not add up to a significant fraction is impractical and probably ineffective.
conclusions and future work wasteful memory operations are often the symptoms of inappropriate data structure choice suboptimal algorithm and inefficient machine code generation.
this paper presents jxperf a java profiler that pinpoints performance inefficiencies arising from wasteful memory operations.
jxperf samples cpu performance counters for addresses accessed by the program and uses hardware debug registers to monitor those addresses in an intelligent way.
this hardware assisted profiling avoids exhaustive byte code instrumentation and delivers a lightweight effective tool which does not compromise its ability to detect performance bugs.
in fact jxperf s ability to operate at the machine code level allows it to detect lowlevel code generation problems that are not apparent via byte code instrumentation.
jxperf runs on off the shelf jvm os and cpu works on unmodified java applications and introduces only runtime overhead and memory overhead.
guided by jxperf we are able to optimize several benchmarks and real world applications yielding significant speedups.
as one of our future plans we will extend jxperf to other popular managed languages such as python and javascript which recently employ jitters pypy for python and v8 for javascript.