leveraging abstract interpretation for efficient dynamic symbolic execution eman alatawi harald s ndergaard and tim miller school of computing and information systems the university of melbourne victoria australia e.alatawi student.unimelb.edu.au fharald tmillerg unimelb.edu.au abstract dynamic symbolic execution dse is a technique to automatically generate test inputs by executing a program with concrete and symbolic values simultaneously.
a key challenge in dse is scalability executing all feasible program paths is not possible owing to the potentially exponential or infinite number of paths.
loops are a main source of path explosion in particular where the number of iterations depends on a program s input.
problems arise because dse maintains symbolic values that capture only the dependencies on symbolic inputs.
this ignores control dependencies including loop dependencies that depend indirectly on the inputs.
we propose a method to increase the coverage achieved by dse in the presence of input data dependent loops and loop dependent branches.
we combine dse with abstract interpretation to find indirect control dependencies including loop and branch indirect dependencies.
preliminary results show that this results in better coverage within considerably less time compared to standard dse.
index terms dynamic symbolic execution dse abstract interpretation path explosion test generation.
i. i ntroduction testing remains the most commonly used method to ensure software quality.
however direct construction of test inputs for a given program is a complicated task.
dynamic symbolic execution dse or concolic testing is a well known dynamic analysis technique for more systematic test case generation.
dse systematically explores a program keeping track of how the inputs forced execution to take the path it took so that it can find alternative inputs that will make execution take other paths.
in this task a dse tool is assisted by a suitable constraint solver.
the aim is usually to achieve high coverage for some chosen definition of coverage.
while high coverage in itself provides no guarantee of absence of bugs it is still considered a desirable goal in testing.
the problem.
scalability is a significant challenge for dse in practice.
even for a loop free program the number of execution paths may be exponential in the program size.
loops and in particular input dependent loops those where the number of iterations depends on an input of the program are a source of program path explosion .
an obstacle to high coverage is that dse maintains values of the symbolic variables during execution but does not track how these are related.
in effect data dependencies are tracked in particular dependencies on symbolic inputs but control dependencies are not.
this means that if a loop condition is not directly dependent on inputs large parts of the code may remain uncovered .
consider this program x y input while y x x y y if x action a else action b in its first round a dse tool might explore the branch that leads to action b. the information available just before the if statement does not suggest which inputs if any would execute action a. this is because x while dependent on y because ydetermines the number of iterations of the loop is never made to depend on other variables via assignments its dependence on yisindirect.
approach.
we wish to improve the coverage achieved by dse in the presence of input data dependent loops and loop dependent branches.
to this end we precede dse with static analysis to capture the indirect control dependencies including loop and branch indirect dependencies on the inputs of the program.
we exploit abstract interpretation based on wellknown relational numeric abstract domains .
at first sight it would seem that classical abstract interpretation has little to offer.
for a given program point p abstract interpretation provides an over approximation of the set of runtime states that may occur at p. every state actually met at pduring a concrete or symbolic execution must satisfy by definition hence it may appear that offers no real information.
however may expose non trivial relations among sets of variables and these relations can be used to strengthen generated path constraints.
consider again the program above.
a dse tool would be greatly helped if we were to express invariants directly using symbolic names for input values such as y0 for y s initial value x y input y0 y while y x x y y y y x y0 y if x action a else action b .
c ieeease urbana champaign il usa technical research new ideas619 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the assertion makes it clear that to reach action a we need to satisfy y y y0 y. a constraint solver can now find a solution such as y0 .
automated generation of powerful invariants such as the one used above is not beyond the capacity of static analysis tools.
our focus is on improving dse by tackling two main problems namely path explosion resulting from input data dependent loops where the number of iterations depends directly or indirectly on unbounded input and low coverage of a loop dependent branch whose condition depends indirectly on the number of iterations a previous input dependent loop has executed.
in our approach we aim to determine the number of symbolic iterations of input dependent loops to reach program statements.
this is achieved using abstract interpretation to calculate the number of required iterations to cover a given loop and to generate invariants that relate that number of iterations to the program inputs.
in addition we support dse by adding some relational information to cover branches that depend on an input dependent loop such as the branch condition given in the example above if x .
to cover this branch the value of xhas to be greater than and in fact the value of xhas been changed inside the loop whose number of iterations depends on the program input y. this loop has to be executed xtimes to enable dse to reach that branch.
such an indirect relation cannot be captured by classical dse.
thus we use abstract interpretation in this case to calculate in advance how many iterations are needed to enter that subsequent branch and to generate invariants that relate program inputs to other program variables included in the conditional statement of the branch.
these invariants are expressed in terms of symbolic values of program inputs.
as a result dse can more readily synthesize input that will steer execution toward a targeted branch.
for the analysis we use cousot and halbwachs s polyhedral domain as implemented in the apron library .
we assume the reader is familiar with the basics of abstract interpretation although this knowledge is not required to understand the paper.
a key component is the abstract domain which is a computer representable class of invariants or sets of runtime states .
the polyhedral domain is among the more expressive domains.
while it is also expensive and fails to scale to the analysis of large programs it is easily up to the task of analysing small to medium sized programs.
ii.
b ackground dynamic symbolic execution systematically executes a program simultaneously with concrete and symbolic values.
during execution dse collects symbolic constraints on the program inputs along the executed path.
this yields a conjunction called a path condition.
negating some conjunct corresponds to an alternative path which should be explored.
to check whether this path is feasible the perturbed path condition is sent to a constraint solver to check its satisfiability.
if it is satisfiable concrete test inputs are generated that will force execution to follow this new path.
if it is unsatisfiable the corresponding path is deemed infeasible1 and search is pruned.
a path condition can be simplified during dse by using concrete values instead of symbolic values in many cases that the symbolic reasoning is impossible or the underlying constraint solver cannot handle the generated path condition.
the number of feasible paths that can be executed by dse is significantly large as it could be infinite or exponential in the program size .
this path explosion problem leads to poor coverage in limited time.
program loops recursion and sequences of branches are three main causes for the problem of path explosion .
loops in particular pose a critical challenge for dse that may affect its coverage and fault detection ability owing to the exponential or infinite growth of the number of the explored paths especially in the presence of loops with an unbounded number of iterations .
as a result dealing with code containing loops is a key limitation of dse.
the problem is that even a single loop can generate a huge number of different execution paths corresponding to different numbers of loop iterations and taking various paths through the loop.
available approaches for solving unbounded loop problems include bounding loop iterations to reduce the whole search space to be finite by bounding loop iteration with the loss of completeness using search guiding heuristics to prevent dse from being stuck in loops by guiding dse toward exploring specific paths summarizing loops into a set of formulas that can be solved by using constraint solvers and using abstraction to model loop iterations states handling infinite loops with symbolic execution.
iii.
a pproach and motivating examples to illustrate our approach and the motivation for combining abstract interpretation and dse we introduce two examples to explain the details of our proposed method.
a. input data dependent loops indirect dependency input dependent loops where the number of iterations depends on unbounded input lead to large numbers of possible execution paths.
dse tools typically impose a bound on the number of iterations of input dependent loops so as to terminate in a reasonable amount of time.
however arbitrarily bounding the number of loop iterations might leave important execution paths unexplored.
we aim to solve the following problem given a piece of code containing loops whose number of iterations to reach particular statements is indirectly dependent on program unbound inputs the goal is to know in advance the minimum number of iterations that are needed to cover that loop and each branch presented within the loop and capture the relation between program inputs and that number.
consider the example in listing which is inspired by the examples given in .
the number of iterations of the while loop indirectly depends on the input value x0stored in 1however the lack of satisfiability can be due to other limitations such as the generation of constraints that are too difficult for the constraint solver to solve.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
void inputdependentloop int x int i p x while true if p break i i p p if i abort target listing .
input dependent loop while true x counter p counter counter counter i if p x counter p counter counter if i x counter p counter i counter abort x counter p counter counter counter i listing .
invariants generated for listing variable xat the beginning of the program execution.
suppose we start testing this program with x0 .
the loop condition triggers the generation of the following path constraints x x x x0 obviously x0appears in the path condition but p which appears in the loop exit branch does not because dse tracks only direct data dependencies on the program inputs.
then it negates each constraint in the path condition one by one to generate new tests to exercise new program paths.
this can be repeated in principle forever if x0can be any integer.
limited knowledge of the relations between program input and other variables in a program prevents dse from achieving high coverage.
this is manifest when dse reaches a control point branch or loop that depends on how many times some previous input dependent loop was executed.
for example our target in this example is to cover the abort statement which is guarded by i .
in fact the value of idepends on how many times the loop is iterated during the program execution.
the dse tool pex which we use as a representative for dse tools in this paper could not cover the branch for i when we set its exploration bounds maximum runs and maximum conditions to .
pex generated the test inputs and which could not cover the target.
abstract interpretation can help in maintaining the indirect data dependencies of program variables on inputs.
the key insight here is that it is possible through a combination of abstract interpretation and dse to obtain higher coverage.invariant generation first we add a new local variable called counter that represents the number of loop iterations.
it is incremented each time the loop body is entered.
its purpose is to explicitly express the relation between program variables and the number of times the loop body is executed.
second we run forward abstract interpretation on the program to generate loop invariants using the polyhedral abstract domain.
this produces invariants at each program point2.
the polyhedra domain is commonly used in static analysis to prove safety properties in programs like the absence of buffer overflow division by zero etc.
it is a fully relational numerical domain able to express arbitrary linear inequalities and equalities among program variables.
it is more expressive than weakly relational domains such as octagons pentagons or zones and it comes with a correspondingly higher cost.
listing shows the invariants generated for listing by polyhedral abstract interpretation as implemented in the interproc analyzer.
we are interested in discovering loop invariants and any invariants generated at each branch inside or after the loop.
note that abstract interpretation is able to generate a strong loop invariant relating the program input x the loop counter and the local variable p whose initial value depends on x and appears in loop exit branch.
in addition polyhedral abstract interpretation generated invariants at each branch location specifying the number of loop iterations required to reach that point of the program expressed using the loop counter.
augmenting the path condition with these new invariants guides dse successfully to find a test input that steers execution toward that targeted location.
in other words knowing the loop invariant x counter p and the calculated invariants at the targeted location counter the dse tool can produce the input x using the constraint solver.
the invariant x counter p counter counter guides dse to cover the input dependent loop with a minimal number of iterations.
thus to terminate the loop and for the break statement to be reached the counter has to be at least and in this case dse can generate the test input x .
invariants on the program counter can be exploited to identify the loop bounds and use that bound to ensure both coverage and execution termination with a minimum number of iterations.
considering the values assigned to the variable counter we can set the exploration bound to .
when we do that pex achieves full coverage in less test generation time.
program annotation we use program annotations to insert the necessary invariants at loop entry after the loop loop internal branches and branches after the loop.
these annotations can be added automatically or manually.
we add these invariants as assumptions in the code.
test input generation we use the annotated program to generate test inputs using dse.
pex needs bounds to ensure terminating the loop execution by setting the bound.
we arbitrarily set the bounds to and .
within iterations pex alone was able to generate only three tests 2in fact for integer variable counter interproc has counter counter 20after the second if which we translate to counter .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
void inputdependentloop int n int m int i k int j int limit while i n j while j m k k j j i i if k limit abort target listing .
nested loops x x x that could not cover the target.
a new testx is generated by pex when the invariants are added which leads to coverage of the target.
b. input dependent loops direct dependency we aim to solve the following problem given a piece of code containing a loop whose number of iterations is directly dependent on program inputs and a targeted loop dependent branch anywhere in the code after the loop whose condition depends on the number of times that the loops have iterated generate a test of that target.
the goal is to know in advance how many iterations are needed to enter that branch and to capture the relation between program inputs and that variables presented in the branch condition.
consider the program example shown in listing where nested loops have input data dependent termination conditions that is the number of the iterations of the loops directly depends on the input values m0andn0 stored in variables m andnat the beginning of the program execution.
the goal here is to generate inputs to cover the branch if k limit to steer the program execution toward the abort statement.
dse based reasoning will almost certainly not be able to generate such inputs as this requires relating the value of variable kto the values of the program inputs m0andn0.
pex for example was not able to reach that branch with different bounds including and .
the value of kis modified inside the inner loop.
so the question here is how many times do we need to iterate these two nested loops to reach the abort statement and what is the relation between the required number of iterations and the program inputs that could help dse hit that statement?
to answer this we want to find the linear relation between loop iteration counts program local variables and inputs that is relate program inputs to both kand loop counters.
to identify the linear relation between kand the program inputs nandm we introduce a new counter to the program to record the required number of iterations needed to reach any program control point after a loop using abstract interpretation.
we are interested in finding the minimum number of iterations while i n k j n i i j while j m k j n i m j j i k j n i j m i j k j i n i j if k limit k j k j m j i n i abort listing .
generated invariants for listing required to cover the loop and to cover any subsequent loop dependent control points.
abstract interpretation computes statically the number of required counts by relating it to other program variables.
we use forward abstract interpretation to compute sound invariants using the polyhedral abstract domain.
listing shows the invariants generated by the interproc analyzer.
note that we cannot hope to find the non linear invariant k mn.
the invariant k 5jis valid for both nested loops and knowing the invariants at the target location that is k 5j k j m j i n i gives dse a chance to find appropriate test inputs such as n m .
indeed once we annotate the program with such invariants pex can cover the targeted location and achieve coverage with only tests compared to coverage with tests for the original subject without the invariants.
iv.
p reliminary evaluation we performed a preliminary evaluation of our approach using polyhedral analysis as implemented in the apron library and the state of the art invariant generation tool interproc .
we used the interproc analyser to infer invariants for each program point automatically.
these invariants are intended to relate the program inputs to the established loop counter and other related variables in the program under test.
we used small examples taken directly from or inspired by the literature each subject contains an input dependent loop and at least one loop dependent branch and or an assertion.
subject has two nested loops subject has two sequential loops.
first we ran interproc on the subjects and then the code was annotated with the generated invariants at each marked target in the code.
second we ran pex on both the original and the annotated subject.
we set the maximum exploration bound maximumruns in pex to to limit the exploration so that the tool does not get stuck in loops that might have infinitely many execution paths.
we measured the size of the generated test suite the line coverage of the generated test inputs the time taken by pex to generate the test inputs and the number of runs attempted by pex during the exploration.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i preliminary evaluation results interproc pex pex abstractinterpretation subj invg time tests coverage testg time runs tests coverage testg time runs subj1 list.
.
.
.
subj2 list.
.
.
.
subj3 .
.
.
subj4 .
.
.
subj5 .
.
.
subj6 .
.
.
avg .
.
.
.
.
table i presents the results of our experimental evaluation.
the column labelled invg time indicates how long in seconds interproc took on each subject to generate the invariants.
the columns grouped under the section pex namely tests coverage testg time and runs indicate the size of the generated test suites coverage achieved by a pex generated test suite test generation time and number of runs that are attempted by pex during dse exploration respectively.
similarly the third section of the table list the results for pex supported by abstract interpretation.
these preliminary results show that pex with abstract interpretation was able to generate test inputs that achieved better coverage average of increase in the coverage .
moreover with the help of generated invariants pex was able to handle input dependent loops efficiently the testing time was clearly decreased compared with the time taken by pex alone.
for example when bounds were set to pex was able to reach coverage only for subject1 listing and it took comparatively longer time .
seconds compared to .
seconds for pex with abstract interpretation .
for the remaining subjects pex alone was not able to achieve full coverage it was unable to cover loop dependent branches as it consumed the available number of runs iterating the input dependent loop .
conversely pex with abstract interpretation achieved full coverage through the guidance of the added invariants.
these helped pex to iterate the input dependent loop enough to be able to terminate the loop execution and at the same time cover any loop dependent branches.
adding program invariants guides pex toward more interesting inputs that are able to satisfy the inferred relation between program inputs and other variables in the program under test.
for listing again static analysis allowed pex to generate fewer tests compared to the case without invariants but with better coverage.
in addition test generation time was slightly better in this case .
seconds compared to .
seconds .
in our experiments adding loop invariants did not increase the exploration time but it did lead to better tests that achieve better coverage even if pex in both cases reached to the limit of the assigned exploration bound.
however if we reduced the limit of runs to pex with abstract interpretation achieved coverage in only .
seconds.relating program inputs to other variables in the program is significant for dse tools to achieve good coverage especially in the presence of assertions that involve only non input variables.
subject provides an example of this the program has an input kand contains an assertion that includes only local variables.
here pex alone was not able to generate any test within the exploration bound.
on the other hand with only runs .
seconds and generated test inputs pex abstract interpretation was able to achieve coverage.
these results suggest that compared to dse alone our technique produces slightly smaller test suites with better coverage while reducing test generation time for code containing input dependent loops and loop dependent branches.
v. r elated work there are few approaches that are focused on how to deal with input dependent loops in dse.
saxena et al.
propose an approach called loop extended symbolic execution to capture the relation between program inputs and loops in dse.
they introduce a new symbolic variable called trip count for each program loop.
this count represents the number of times a loop body was executed at any given time.
saxena et al.
obtain the relationship between these variables and other variables in the program by running a separate static analysis.
they relate the trip counts to the program input format by introducing auxiliary variables to capture how loop dependent variables are related to the lengths and counts of elements in the program input based on an input grammar.
in contrast our approach infers loop invariants and captures the relations between program inputs and all program variables purely statically before dse.
symbolic execution is then guided by the inferred relations.
our method distinguishes between direct and indirect dependency of loops on the input data and introduces a loop counter as a new local variable to explicitly capture the relation between the program input and loop iterations.
the introduction of loop counter variables is also found in the context of abstract interpretation in the search for numerical abstract domains that trade away some expressiveness to avoid the heavy cost of polyhedral analysis.
the gauge domain offers a limited relational analysis in which relations among program variables cannot be expressed but authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
relations aremaintained between each program variable and specially introduced loop counter variables.
godefroid and luchaup use loop summaries to deal with certain types of unbounded loops that include induction variables whose values are modified by a constant value or constant times for each loop iteration.
their goal is to determine the number of iterations of input dependent loops by automatically guessing an input constraint using simple loop guard pattern matching rules.
this solution is performed dynamically without requiring any static analysis or inputformat specifications unlike .
loops are summarized by loop pre conditions and post conditions that are derived from inferred partial loop invariants relating the program inputs to the induction variables.
our approach is simpler and does not require detection of induction variables or loop structure.
we simply infer program invariants at each program point relating the value of input variables and all other local variables in the program within any loop that is not only induction variables .
in addition we determine the required number of iterations needed to reach any branch within or after the loop statically.
cadek et al.
propose an algorithm for computing upper bounds for execution counts of individual instructions of an analyzed program during any program run.
the algorithm is based on symbolic execution and the concept of path counters.
the upper bounds parameterized by input values of the analyzed program path counters are more general executions of a single program path in a loop can be counted by several path counters relative to some other program paths even in other loops.
vi.
c onclusion and future work we have proposed a way of improving the coverage achieved by dse in the presence of input data dependent loops and loop dependent branches.
the idea is to precede dse with well known analyses from abstract interpretation based on relational numeric abstract domains to capture the indirect control dependencies on the inputs of the program.
preliminary results suggest that compared to dynamic symbolic execution alone the outcome is better coverage achieved in considerably less time.
so far we have communicated static analysis results to a dse tool by manual transfer.
hence while the results are very promising the subjects on which we have tested the idea have been small single functions albeit non trivial from a reasoning perspective.
we plan to integrate the two components properly so that we can work on scaling up the method.
for very large programs the domain of convex polyhedra is likely to prove too expensive.
however a large number of relational abstract domains of varying expressiveness have been suggested and implemented and often made available as open source code.
one should be mindful however that while dse tools usually deal with programming languages that assume finite width integers most relational abstract domains are based on proper integers and this discrepancy has the potential to cause unsoundness of analysis.