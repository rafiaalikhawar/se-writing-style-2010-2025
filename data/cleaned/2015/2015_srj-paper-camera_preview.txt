see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation bingo cross architectu re cross os binary search conf erence paper no vember .
.
citations 233reads author s including chandr amohan mahinthan nany ang t echnologic al univ ersity publica tions citations see profile yinxing x ue univ ersity of scienc e and t echnolog y of china publica tions citations see profile zheng zi xu imperial colle ge london publica tions citations see profile yang liu nany ang t echnologic al univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y chandr amohan mahinthan on f ebruar y .
the user has r equest ed enhanc ement of the do wnlo aded file.bingo cross architecture cross os binary search mahinthan chandramohan1 yinxing xue1 zhengzi xu1 y ang liu1 chia yuan cho2 and tan hee beng kuan1 1nanyang technological university singapore 2dso national laboratories singapore mahinthan tslxuey yangliu hbktan ntu.edu.sg abstract binary code search has received much attention recently due to its impactful applications e.g.
plagiarism detection malware detection and software vulnerability auditing.
however developing an effective binary code search tool is challenging due to the gigantic syntax and structural differences in binaries resulted from different compilers architectures and oss.
in this paper we propose bingo a scalable and robust binary search engine supporting various architectures and oss.
the key contribution is a selective inlining technique to capture the complete function semantics by inlining relevant library and user defined functions.
in addition architecture and os neutral function filtering is proposed to dramatically reduce the irrelevant target functions.
besides we introduce length variant partial traces to model binary functions in a program structure agnostic fashion.
the experimental results show that bingocan find semantic similar functions across architecture and os boundaries even with the presence of program structure distortion in a scalable manner.
using bingo we also discovered a zero day vulnerability in adobe pdf reader a cots binary.
ccs concepts theory of computation !program analysis security and privacy!vulnerability scanners social and professional topics!software reverse engineering keywords binary code searching vulnerability matching .
introduction recently binary code searching has attracted much attention for its important applications in software engineering and security e.g.
software plagiarism detection reverse engineering semantic recovery malware detection and buggy vulnerable code identification in various software components where the source code is not available e.g.
legacy applications .
we can even search for zero day vulnerabilities in proprietary binary by matching the known vulnerability from open source software.
yinxing xue is the corresponding author.traditional source code search relies on the similarity analysis of some representations of source code e.g.
approaches based on token abstract syntax tree ast or program dependency graph pdg .
all these representations capture the structural information of the program and yield accurate results for source code search.
however code search in binary is much more challenging due to many factors e.g.
architecture and os choice compiler type optimization level or even obfuscation technique and limited availability of high level program information.
these factors have a substantial influence on the assembly instructions and their final layout in the compiled binary executable.
in the literature various approaches have been proposed to detect the similar binary code by using static or dynamic analysis.
static analysis relies on the syntactical and structural information of binaries especially control flow structures i.e.
organization of basic blocks within a function to perform the matching.
for example tracy is a syntax based function matching technique that uses similarity by decomposition cop is a plagiarism detection tool that combines program semantics with longest common subsequence based fuzzy matching and is a vulnerability matching tool that supports cross architecture analysis via the invariants of vulnerability signatures.
most recently discovre is proposed to find bugs in binaries across architectures in a scalable manner where it uses two filters numeric and structural to quickly locate the functions that are similar to the signature function.
apart from static analysis dynamic approaches inspect the invariants of input output or intermediate values of program at runtime to check the equivalence of binary programs.
for example blex is the latest dynamic function matching tool that uses several semantic features obtained during function execution e.g.
values read from written to the program heap in the matching process.
to better understand the existing approaches we identify three desired properties for an accurate yet scalable cross architecture and cross os binary search tool.
p1.resilient to the syntax and structural gaps introduced due to architecture os and compiler differences.
p2.accurate by considering the complete function semantics.
p3.scalable to large size real world binaries.
unfortunately none of the existing techniques can achieve all the desired properties above.
the structural information used by the static approaches e.g.
basic block structures used in and fixed length tracelet in fail p1.
most static analysis techniques cannot satisfy p2 as they ignore the semantics of relevant library and user defined function invocations in the matching process.
finally scalability p3 is a real challenge in semantic binary matching where for example coptook half a day tofind target functions in firefox for a few signature functions .
the details are further elaborated in .
.
in this paper we propose a binary search engine named bingo which performs semantic matching by combining a set of key techniques to address the challenges above.
given a binary function bingofirst inlines relevant libraries and user defined functions in order to capture the complete semantics of the function for p2 then shortlists the candidate target functions using an architecture and os neutral filtering technique for p3 and finally extracts length variant partial traces from the candidate target functions as function models for p1 and performs function similarity matching using machine learning techniques.
technically first to recover the complete semantics from the functions under investigation we propose a selective inlining technique where the callee both libraries and user defined functions are inlined into the caller such that the complete function semantics are captured .
to avoid code size explosion we selectively inline the callee functions based on the invocation dependency patterns which differs from the traditional compiler inlining optimization techniques for maximum speed or minimum size .
to our best knowledge this work is the first attempt towards investigating selective inlining in recovering binary semantics.
second to improve the scalability of our approach we propose an architecture and os neutral filtering technique that narrows down the search space by shortlisting the candidate target functions for binary semantic matching .
next to overcome the challenges arise due to basic block structure distortion we generate function models which are agnostic to the underlying program structure via the length variant partial traces1.
to this end for each function partial traces of length 1tokare extracted to form the function model such that it represents the function at various granularity levels.
here we also take measure to minimize the effects of infeasible paths and compiler specific code in calculating the function similarity scores.
finally semantic features are extracted from the function models of candidate target functions for function similarity scoring where semantic features capture the machine state transitions in the form of input output pairs .
we evaluate bingoon a number of real world binaries containing hundreds of thousands of functions.
the experimental results show that bingocan effectively perform cross architecture and cross os binary code search on these binaries where we demonstrate that bingooutperforms the state of the art binary matching tools such as bindiff and tracy .
further we also show that recent techniques such as and fail in case of program structure distortion while bingocan handle such cases swiftly.
last but not least using bingo we discovered a zero day vulnerability cve in the adobe pdf reader.
key contributions.
this work makes the following contributions we propose a selective inlining algorithm to capture the complete semantic of the binary functions.
we introduce an architecture and os neutral function filtering process that helps narrow down the target function search space.
we leverage on length variant partial traces to model the function at various granularity levels that is agnostic to underlying program structures.
we empirically demonstrate that bingooutperforms the stateof the art binary function matching tools and also report the zero day vulnerability discovered from adobe pdf reader.
1a partial trace refers to a sequence of basic blocks that lie along an execution path in the cfg .
a b inlined memcpy function call memcpy figure code segment responsible for heartbleed vulnerability cve appeared as in the binary a compiled with gcc and b compiled with mingw .
background and overview in this section we provide a motivating example that emphasizes on the need for complete semantics analysis of functions and necessity to have a function model that is agnostic to underlying program structure.
then we explain the basic idea of our proposed solution and sketch the system overview.
.
motivating example a binary program consists of a number of functions where each function is a directed graph of basic blocks i.e.
cfg control flow graph .
the instructions in a function are systematically grouped into several basic blocks which are considered as the building blocks of binary program and this representation is used by many static binary analysis tools.
interestingly the same source code may have different basicblock structures after compilation.
taking the infamous heartbleed vulnerability cve for example fig.
a and b show the basic block structures of the same source code compiled with gcc andmingw respectively2.
apparently these two binary code segments share no identical basic block structures with gcc the vulnerable code is represented as a single basic block with mingw represented as several basic blocks.
a detailed inspection suggests that the library function memcpy is inlined in mingw version while in gcc it is not.
the large syntactic and program structural differences between the two binaries pose the biggest challenge for the existing binary code search tools.
.
challenges for existing approaches syntax is the most direct information usable for binary matching.
most of existing approaches rely on syntax information have attempted to use instruction patterns .
as there is no consistent low level syntax representation i.e.
assembly instructions across architectures these approaches fail for crossarchitecture analysis.
to make the matching resilient to syntax differences in binaries semantics based matching has been proposed in which the machine state transition represents the semantics of a binary.
still three challenges are faced in semanticsbased matching.
c1 the challenge of using program structural properties.
existing approaches assume that basic block structure is pre2ignore the contents of the basic blocks this diagram is to illustrate the program structure cfg distortion arise due to compilation.selectiveinliningfilteringpartial trace generationfunction model generationsimilarity matchingbinaryrankspre processingtrace pruningfigure bingosystem architecture served across binaries thus the matching should be basic block centric.
based on this semantic features extracted from the signature function at basic block level are compared with the counterparts extracted from target functions in a pairwise way.
in practise the assumption is too restrictive to be applied for real world cases.
the following quote from clearly sums up the problem in such assumption our metric is sensitive to the cfg and the segmentation of the basic block which we found to be potentially problematic especially for smaller functions.
for example the basic block in fig.
a needs to be matched with several basic blocks in fig.
b .
c2.
the challenge of covering the complete function semantics.
most of the existing static techniques consider functions in isolation i.e.
semantics of callee functions are not considered as part of the caller s semantics.
this leads to partial semantics problem especially when the programmer makes the most commonly used code segment as an independent function or implements her own version of the standard c library functions e.g.
adobe reader has its own malloc implementation .
to address this one can blindly inline all the callee functions e.g.
in all the user defined functions are inlined .
unfortunately this approach does not work in practise due to two main reasons heavy inlining may lead to code size explosion which is not scalable to real world binary analysis and not all the callee functions are closely related to the caller function in terms of functionality.
for example memcpy is not inlined in fig.
a but it is in fig.
b .
thus memcpy needs to be inlined for matching with other semantically relevant functions.
c3.
the challenge of scalable searching in large real world binaries.
syntax based techniques in general are scalable .
however as discussed earlier they fail on cross architecture analysis.
to address this problem semantics based techniques are preferred however extracting semantic features incur heavy overhead and not scalable.
therefore to facilitate scalable semantic matching an efficient and architecture os and compiler neutral function filtering step is required.
however exiting approaches focus only on the efficiency aspect of the filter.
for example in only program structural features such as number of basic blocks are used as filters to speed up.
however as shown in fig.
such features are not robust enough for cross architecture os and compiler analysis.
.
proposed solution and system overview we propose bingoas a scalable binary search engine where given a binary function bingowill return the functions from the target binary ranked based on their semantic similarity.
fig.
shows the work flow of bingo.
first given a signature function bingowill pre process the binaries i.e.
disassemble and build cfgs from the functions for further analysis.
next for each function in the target binaries closely related library and other user defined functions are identified and inlined .
then from these inlined target functions a list of candidate functions that are similar to the signature function are shortlisted using three filters which consider different aspects of the program semantics .
next from the signature and the shortlisted target functions length variant partial traces are generated .
which are thengrouped to form the function models .
.
during the partial trace generation phase trace pruning is conducted to remove the irrelevant and infeasible partial traces from the analysis .
.
after that semantic features are extracted from the function models .
which are later used for semantic similarity matching .
.
finally based on the similarity scores obtained bingoreturns the target functions that are semantically similar to the signature function in a ranked order.
to sum up to address the syntax differences of instructions we lift the low level assembly instructions into a corresponding intermediate representation ir to facilitate cross architecture analysis.
to mitigate c1 e.g.
single basic block in the signature function matching to several basic blocks in the target function in fig.
we borrow the idea of tracelet used in tracy .
different from the original approach that uses a fixed length of tracelet we use length variant partial traces.
next to overcome c2 e.g.
whether to inline memcpy in fig.
a we propose a selective inlining strategy to strike a balance between the needed contextual semantics and the overheads due to inlining.
finally to address c3 we adopt three filters considering different aspects of the semantics to identify similar functions.
.
selective inlining inlining is a compiler technique to optimize the binaries for maximum speed and or minimum size .
this section presents our selective inlining technique which has a different goal and strategy compared with compilation process.
.
function invocation patterns in order to inline relevant functions we use the function invocation patterns to guide the inlining decision.
based on our study six commonly observed invocation patterns are identified and summarised in fig.
.
incoming outgoing edges in fig.
represent the incoming outgoing calls to from the function.
here we elaborate the six patterns as follows.
case fig.
a depicts the direct invocation of standard c library function s by the caller function under investigation.
to recover the semantics it is essential to understand the semantics of called library function s hence the library function is inlined into the caller function.
currently we only consider the most common standard c library functions from both linux libc and windows msvcrt for inlining.
case fig.
b depicts the case of a recursive relationship between the caller and the ud user defined callee function f. hence we inlinefinto its caller.
note that the recursive functions are unlike in compilers inlined only once.
for example gcc has a default inlining depth of for recursive functions.
case fig.
c depicts the common pattern of a utility function e.g.
the ud callee function fis called by many other ud functions whilefcalls several library functions and a very few or zero ud functions.
this suggests that fis behaving as a utility function as fhas some semantics that is commonly needed by other functions and hencefis likely to be inlined.
case the ud callee function fin fig.
d is a variant of c where it has several