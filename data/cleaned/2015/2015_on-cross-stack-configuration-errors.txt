on cross stack configuration errors mohammed sayagh noureddine kerzazi bram adams polytechnique montreal ensias univ mohammed v in rabat polytechnique montreal mohammed.sayagh polymtl.ca n.kerzazi um5s.net.ma bram.adams polymtl.ca abstract today s web applications are deployed on powerful software stacks such as mean javascript or lamp php which consist of multiple layers such as an operating system web server database execution engine and application framework each of which provide resources to the layer just above it.
these powerful software stacks unfortunately are plagued by so called cross stack configuration errors csces where a higher layer in the stack suddenly starts to behave incorrectly or even crash due to incorrect configuration choices in lower layers.
due to differences in programming languages and lack of explicit links between configuration options of different layers sysadmins and developers have a hard time identifying the cause of a csce which is why this paper performs a qualitative analysis of configuration errors to understand the impact effort and complexity of dealing with csces then proposes a modular approach that plugs existing source code analysis slicing techniques in order to recommend the culprit configuration option.
empirical evaluation of this approach on real csces of the top lamp stack layers shows that our approach reports the misconfigured option with an average rank of .
for of the csces and takes only few minutes making it practically useful.
i. i ntroduction every web app requires a so called software stack to provide the computation and storage resources that it needs.
for example a web app would not be accessible without a web server.
moreover a web app requires a database to store its state and some kind of execution engine within which computations can be run.
hence a web app requires a large set of services each of which is served by a separate layer together forming a stack of services consuming each other s resources.
one popular software stack is the so called lamp stack figure consisting of linux operating system os apache web server mysql database and php execution engine layers for deploying web apps such as wordpress wp or drupal dr .
other common stacks are the j2ee and mean stacks .
once a web app is deployed the behaviour of the stack can further be adapted to a particular platform by changing the layers configuration options.
such options are basically a set of key value pairs in which the key represents an option name and the value a user s desired choice for that option.
these pairs typically are stored in dedicated configuration stores files databases ... and can change the behaviour of a system without re compilation.
for example one can configure the database server to limit the number of connections by using the database option max connections while one can also configure the php interpreter to limit the execution time of a script by the option max execution time .
web framework wordpress joomla drupal ... framework plugins nextgen contact form .... scripting language php perl java ... database mysql postgresql ... web server apache iis ... operating system linux windows ... figure architecture of a lamp stack.
despite this flexibility assigning a wrong value to a configuration option could lead the configured stack to behave incorrectly or even to crash.
although technically one only needs to change the value of a configuration option to fix it finding the correct option s to change and the correct value is the topic of ongoing research .
moreover configuration errors have a severe impact.
studies have shown that configuration related errors can account for of all customer support cases in industrial contexts while a well known google engineer prioritized them as one of the top directions for future research major problems.
while resolving misconfiguration errors related to a single layer of a software stack is difficult such errors can span across multiple stack layers which could make them even harder to troubleshoot and resolve .
indeed each stack layer has its own configuration options and programming language and some features could be managed by different options.
for example the memory size a script is able to use can be changed in the wp layer by changing the option wp memory limit in the php interpreter layer by memory limit and in the web server layer by php value memory limit .
such configuration choices could contradict each other and hence confuse end users.
in the context of the wp lamp stack a notorious example of a cross stack configuration error csce was the inability of users of the nextgen gallery plugin to upload an image due to a memory misconfiguration in the lower php interpreter layer.
this paper empirically studies the characteristics of csces then proposes and empirically evaluates a novel modular algorithm that leverages existing code slicing approaches.
the algorithm analyzes configuration options and their code dependencies across multiple layers of a stack to recommend the configuration option most likely causing a csce.
we make the following contributions ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a large qualitative study on configuration errors obtained from online discussion forums to understand the impact of csces the effort required to resolve such errors and the complexity of csce fixes.
a modular algorithm that allows to plug in existing code slicing techniques to recommend the configuration options that are most likely responsible for a csce.
a large empirical evaluation of the algorithm on real csces in wp dr and wp plugins showing that our approach reports the culprit option within few minutes with a rank average of .
for out of the cases.
a public dataset of evaluated csces .
ii.
b ackground and related work this section presents background and related work about software stacks configuration errors and csces.
a. software stacks definition.
we define a software stack as an acyclic graph where nodes represent layers and an edge connects a layer to another layer whose resources it requires.
figure shows the lamp stack and mentions different components possibly existing within each layer.
here wp plugins extend the functionality of the wp framework which needs resources from php for computation e.g.
standard library which relies on mysql and apache for database and web access etc.
note that stack dependencies model resource usage not the order in which an http request is being served by a web server.
lamp stack.
even though the problem of csces and our approach apply to any software stack that fits our definition e.g.
mean or j2ee this paper uses the lamp stack as example in particular with the wp and dr web apps.
wp and dr are two of the world s most successful content management systems.
wp .
had .
million downloads thousand plugins and serves .
million web sites while dr .x .x together have around .
million downloads .
thousand plugins and serve over million websites.
this success is largely due to the variety of themes and plugins which are php scripts that access the wp dr layers php to extend basic functionalities for example easier image uploads extra widgets or interfacing with other web apps.
existing work.
many research efforts focus on wp as case study.
in prior work we found that each wp plugin is using up to .
of the wp layer s configuration options while of all wp options are used by at least two different wp plugins suggesting a large risk of csces.
nguyen et al.
verify plugin conflicts by testing all possible combinations of enabled wp plugins at once.
they also proposed an approach to detect undefined variables and functions across all possible instances of a web page.
eshkevari et al.
proposed an approach to detect interference problems like conflicts between entity names or between generated client codes between wp and its plugins.
b. single layer configuration errors definition.
a configuration error is an incorrect system behavior due to a bad value assigned to an option.
it typicallyhas as symptom an error message generated by the source code.
a single layer configuration error is a configuration error in a software stack where the symptom and misconfigured option are known to belong to the same stack layer.
existing work.
many researchers focused on understanding configuration errors.
yin et al.
classified misconfiguration errors from four open source systems and one commercial software system into different categories to understand the different causes of such errors.
jin et al.
conducted an empirical study to understand the challenges that configuration introduces for testing and debugging.
hubaux et al.
conducted an empirical study to find the challenges of configuration across linux and ecos users and found that better configuration support is required.
arshad et al.
analyzed bugs of two java ee application servers in order to characterize configuration errors.
together with our prior work these papers found that configuration errors are an important problem and are hard to debug.
however as reported by xu et al.
none of these papers focus on csces.
two major strategies have been used to analyze or test the configurations of a system.
sampling algorithms try to select the most representative configurations for analysis or testing using conventional analysis test techniques.
conversely variability aware approaches aim to analyze all configurations at once by making analysis or testing tools configuration aware e.g.
aware that a particular line is only executed for a specific option value .
several debugging approaches for single layer configuration errors exist.
zhang et al.
resolved misconfiguration errors in java programs by comparing erroneous program executions with a pre built database of correct execution profiles.
later they used historical information to identify which configuration option is introducing a bug in a new version.
dong et al.
instead used static slicing while attariyan et al.
use control flow analysis.
wang et al.
rank the reported culprit options based on user feedback.
xiong et al.
used constraint models to not only identify misconfigured configuration errors but also propose a correct value.
c. cross stack configuration errors definition.
in the most narrow sense a csce is a configuration error whose symptoms are reported in a stack layer without any direct link access to the culprit option.
for example a permission problem in an option of the php interpreter in figure could yield a file cannot be uploaded error in the wp layer without any read or write of the culprit option in the latter layer.
the definition of csce could be broadened to cases where the layer with the error symptom a reads the misconfigured option but the option and the incorrect value assignment still belong to a different layer or b both reads and assigns the misconfigured option but the user is misled to think that the symptom is generated by a different layer.
the latter case is very common as web or database error messages often are returned as is by the top stack layer.
although we target the narrow definition of csce our approach can also help with the two broad interpretations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
existing work.
to the best of our knowledge no existing approach resolves csces .
one alternative could be to use the single layer approaches discussed in the previous section.
even though sampling based approaches cannot guarantee to detect all errors they could be used to prevent certain csces complementing debugging techniques.
yet thus far they have not been evaluated on run time configuration using preprocessor macros and conditions to store check option values instead of regular variables and if conditions.
furthermore each stack layer brings its own options of string type not just boolean and can be implemented using different technologies e.g.
mysql vs. postgresql yielding a significantly larger search space to sample from.
variabilityaware approaches are not immune to this search space explosion either as they require customization to the specific configuration variability mechanisms and layers used.
many approaches for debugging single layer configuration errors require additional input that is hard to obtain in a software stack.
for example several require configuration constraint models as input i.e.
the allowed combinations of option values.
approaches to generate such models have only been applied on single layer systems using the c preprocessor or other configuration conventions .
similarly other approaches require data of a correct version of the system .
this is more difficult to obtain in a software stack context as it requires to have access to all configuration data for an identical stack setup same layer technologies and versions which also increases the volume of data to process.
our approach does not require any oracle or model and hence is able to scale to csces.
the single layer approach closest to our work is the static slicing based one of dong et al.
.
our modular algorithm can plug in a single layer slicing based technique such as this to make it layer dependency aware and combine it with similar techniques for different layers .
finally attariyan et al.
do not use slicing but dynamically explore and replay condition branches to avoid the error and hence find the culprit option.
replaying a large number of branches can be costly in terms of time and this only aggravates for multi layer systems which have significantly more branches and options.
recently research has started focusing on understanding software systems that contain multiple programming languages of which software stacks form a subset.
for example kochhar et al.
found a correlation between the number of programming languages in a system and the system s overall quality.
one such quality issue studied by nguyen et al.
is consistency between variables shared between different languages in particular js html and sql .
they developed a custom slicer for php web apps that combines traditional program analysis with symbolic execution and abstract interpretation in order to handle js html and sql code embedded in php code.
while they did not address nor evaluate their approach for configuration problems a restricted version of the slicer focusing only on configuration variables could be integrated into our generic approach to handle other stack layers and technologies than those it was built for.table i qualitative data source statistics.
q a platform time period threads config.
errors stack overflow aug jun stack exchange sep feb server fault may feb table ii overview of the five layers and three data sources analyzed for the qualitative study.
so stands for stackoverflow ste for stackexchange and sf for serverfault.
wp drupal php apache mysql single so ste so ste sf sf sf cross so ste php .
.
.
so ste php .
.
.
sf sf sf mysql apache mysql apache iii.
q ualitative analysis to gain an in depth understanding of the impact of csces the effort required to fix them and the complexity of the obtained fixes this section presents the results of a qualitative study on forum threads from online q a platforms.
a. methodology data sources.
given the vast variety of software stacks we focused our qualitative analysis on the popular lamp software stack figure in particular on configuration errors in the apache mysql php and wordpress wp drupal dr application layers.
due to time limitations we did not consider linux related errors nor errors related to wp dr plugins.
basically we conducted a top down and a bottom up analysis of cross stack and single layer errors.
the top down study analyzes both kinds of errors in the wp dr layers in the context of a lamp stack.
the bottom up approach instead focuses on configuration errors caused by the php apache or mysql layer regardless of which layers are running on top of them i.e.
not necessarily a lamp stack .
we used the study design outlined in table ii on the data sources of table i with columns and of table ii corresponding to the top down analysis and to to the bottom up analysis.
amongst the studied data sources stackoverflow is a general q a site covering a wide range of topics for the general public users and developers.
we selected only those questions that were marked as solved and tagged with wordpress or drupal then filtered the resulting questions by searching for discussion comments not code blocks mentioning the names of configuration options of wordpress drupal single layer candidate errors so or php mysql apache cross stack candidate errors so php mysql apache .
we obtained those names from the documentation of the corresponding layers.
for apache we only retained discussions mentioning the filename httpd.conf to reduce false positives.
stackexchange has subcommunities dedicated to wordpress and drupal users and developers.
we used the same approach as above yielding the single layer ste and cross stack configuration error candidates ste php mysql apache for the analyzed layers.
finally serverfault is a q a site targeted by system administrators.
we searched for questions mentioning authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure difference between the number of single layer errors and csces for each case study.
options of php mysql or apache.
as mentioned earlier serverfault is not limited to lamp hence our bottom upanalysis is able to find options causing csces in any stack.
approach.
two human raters first two authors independently analyzed the selected questions and their discussionson the three q a sites to determine the values of nu meric boolean and textual characteristics.
for the textualcharacteristics each rater could assign arbitrary tags suchas production environment or conflicting option .
sincethis resulted in a large set of tags for these characteristics and in order to resolve disagreement between raters theyperformed card sorting for each textual characteristic.this allowed to cluster tags into either fewer or broadercategories effectively turning these textual characteristics intonominal data.
they then revisited the discussions replacingtheir initial tags by the corresponding nominal cluster names.
of the studied discussions .
were related to configuration errors table i .figure shows for eachof the studied layers of table ii a comparison between thenumber of analyzed configuration errors that are single layerversus those that are cross stack.
note that this figure doesnot allow comparison between layers.
for drupal and php wefound substantially more csces than single layer errors whilefor apache we found the opposite.
given the imbalanced datafor drupal php and apache we decided to aggregate the dataof the five layers obtaining single layer and csces.
b. impact of cross stack configuration errors we found a statistically significant difference in the distribution of impact for single layer and csces 2test pvalue .2e 16with .
.
as shown in figure csces are more severe compared to single layer errors in terms of the percentage of crashes occurring of allcsces compared to while they have approximatelythe same percentage of hangs vs. .
our card sortanalysis shows that cross stack configuration crashes typicallyare related to lower layer options that control the stack scapacity like the memory size memory limit or execution time max execution time allowed for a script.
surpassing these limits ends up with a crash.
on the other hand single layer errors are more related to user access permissions thancsces but such errors do not tend to crash the system.
since errors in the production environment are more severe and at least half of the single layer and csces occurred in production we refined the results of figure to production figure impact of single layer errors vs. csces.
figure when do single layer and csces occur?
errors only.
we found that csces exhibit a more severe impactcompared to single layer errors even in production p value of .106e .
again the vast majority of csces were crashes a percentage that is much higher compared tosingle layer errors .
the reason for this besides the mistake of using different environments for testing and production is the lack of testingat scale before production.
for example in one case the max input vars option caused a csce where adding more than menu items to a wp site crashed the system.
thesite had never been tested with more than a handful menuitems.
single layer production crashes are more related tomisconfigured urls and paths to lower layers which breakwhen for example another database or web layer is installed.
figure shows that users face the majority of singlelayer configuration errors just after setting up their stack or during application maintenance for examplewhen a new plugin is installed or theme is changed.
theseproblems have a relatively low impact as they can be resolvedbefore release or while the system is undergoing maintenance.however csces frequently occur during devops activities vs. such as running scripts or backups whenoperating the web application.
for the same reasons as above when restricting the analysis to production errors the devopscsces grow to compared to for single layer.
conclusion cross stack configuration errors have a severe impact compared to single layer errors due to the highpercentage of crashes they are responsible for especially in theproduction environment.
due to this severe impact sysadminsneed automated support to debug and resolve csces.
c. effort to solve cross stack configuration errors in terms of effort to understand or fix configuration error we did not find any statistically significant difference between single layer and csces for the number of comments on aquestion wilcoxon p value of .
of proposed answers authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
p value of .
of hours until a question took to be answered p value of .
of options discussed before finding the real culprit median of with a p value of .
nor of comments on the provided answers p value of .
.
we hypothesize that the number of comments and answers are related to how well people expressed their problem and the forum members experience.
for example we found that of the questions was answered by the original poster typically after a very long time.
this could explain the difference in median time to answer a csce question of .
hours for csces compared to .
hours for single layer errors mean of .
and .
hours resp.
.
conclusion while the literature reports that finding a single layer misconfigured option is a hard and timeconsuming task we found that csces are at least as hard and time consuming to resolve .
this time could be reduced with automated support for resolving csces.
d. complexity of cross stack configuration resolution whereas we found that single layer errors have a relatively less severe impact than csces they seem to require significantly more options p value of .847e to be changed to fix them than csces median of vs. .
manual analysis showed that around wp single layer options always need to be changed together.
common cases are the options wp home and wp siteurl for wp or options managing url redirections and permissions for apache like rewriterule and rewritecond .
while php interpreter errors were the most common of the wp and dr csces were caused by options assigned all the way inside the os layer.
we also found a non negligible percentage of errors coming from the other layers i.e.
the web server and the database server .
the decreasing percentage from top to bottom layers is typical for a layered architecture where layers mostly talk with their neighbours only.
furthermore the of csces originating from the os is a lower bound as this study only considers csces related to file system related os options e.g.
.
in future work we plan to consider other os options as well.
in of the cases the user did not have access to one or more faulty configuration files and hence had to override the misconfigured options by modifying them within the source code of the web application.
such overrides are risky potentially causing additional conflicts.
one example we found showed a user modifying the memory limit option in the php interpreter configuration file but his modification did not work because the same option is overridden by the wp source code via the function ini set .
conclusion csces require to change options not only in the top layer of a stack but also in deeper ones all the way down to the os not all of which are open for change by the user.
iv .
m ethodology for identifying cause of csce this section presents our modular algorithm to recommend the configuration option responsible for a csce.
we firstdiscuss the slicing program analysis technique at the core of the algorithm followed by important preliminary concepts.
a. backward slicing backward slicing is a program analysis technique used to find the statements that affect a given variable seed used on a particular line of a program .
the line of code and seed together form the so called slicing criterion .
backward slicing is typically used to analyze debug and understand a program since it reduces the scope of the program to only those statements impacting a targeted seed.
since its introduction by weiser et al.
slicing techniques have seen applications in many domains .
here we use both static and dynamic slicing techniques.
to illustrate static slicing let s consider the example code in figure 5a and the resulting backward slice for the criterion line higher in figure 5b.
as shown backward slicing starts from the targeted line then goes backwards through the code to find all lines on which the seed variable higher is modified and recursively repeats this for all variables and function calls whose value is used to calculate higher .
the resulting static slice is a compilable part of the original program that contains all statements required to calculate i.e.
that impact the value of higher in line .
dynamic slicing figure 5c only analyzes the statements that were executed during a specific execution of the system ignoring all other statements.
for example for an if condition it only analyzes the executed branch of an if condition ignoring the second branch.
dynamic slicing is better suited than static slicing to deal with reflective function calls event handlers and dynamic file includes .
furthermore it reduces the size of the slice and hence the amount of source code to be analyzed scaling better to larger systems.
on the other hand it requires invasive instrumentation to obtain the necessary dynamic data and concrete scenarios to run.
b. cross stack slice dependency graph in subsection ii a we defined a stack as an acyclic graph in which edges represent dependencies between adjacent layers.
in practice such dependencies correspond to physical links i.e.
some kind of mapping between resources used e.g.
function called variables accessed or files read in a layer and the definition of those resources e.g.
function definition variable name or file name in the layer below.
such physical links can be based on naming conventions configuration files or could simply be hardcoded.
for example in the lamp stack a wordpress plugin would call functions in wordpress using regular php function calls while php primitives global variables or standard library functions would be called from wordpress using a phpto c naming convention e.g.
function is uploaded file in wordpress could map to is uploaded file in the php interpreter .
mysql could be called from the php interpreter via its official c api or via sql queries.
in each layer we can summarize the results of either dynamic or static slicing in the form of slice dependency authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g2int highervalue int a int b g3 nonmarkingreturnstring higher result g4 nonmarkingreturnint result g5 nonmarkingreturnif a b nonmarkingreturn nonmarkingreturnresult a nonmarkingreturn nonmarkingreturnhigher a is higher than b nonmarkingreturn else nonmarkingreturn nonmarkingreturnresult b nonmarkingreturn nonmarkingreturnhigher b is higher than a g2 g1 nonmarkingreturn g2 g2 nonmarkingreturnwrite higher g2 g3 nonmarkingreturnreturn result g2 g4 a original code.
g2int highervalue int a int b g3 nonmarkingreturnstring higher result g4 g5 nonmarkingreturnif a b nonmarkingreturn nonmarkingreturnhigher a is higher than b nonmarkingreturn else nonmarkingreturn nonmarkingreturnhigher b is higher than a g2 g1 nonmarkingreturn g2 g2 nonmarkingreturnwrite higher g2 g3 g2 g4 b static backward slice.
g2int highervalue int a int b g3 nonmarkingreturnstring higher result g4 g5 nonmarkingreturnif a b nonmarkingreturn nonmarkingreturnhigher a is higher than b nonmarkingreturn nonmarkingreturn g2 g1 g2 g2 nonmarkingreturnwrite higher g2 g3 g2 g4 c dynamic backward slice.
figure static vs. dynamic slicing for the criterion line higher .
wordpress 2if option5 bar mysql 7bool mysql foo return option3 11bool mysql bar return option4 php interpreter 2int php foo if option1 !
mysql foo php bar 9int php bar if option2 mysql bar print error symptom return figure example of a layer lamp stack.
bar option 10mysql foo false php bar option truemysql bar true print error return option3return option4wordpress layer php layer mysql layerphp foo php bar mysql foo mysql bar return 0option figure cross stack slice dependency graph for figure .
solid lines indicate slice dependencies dashed lines physical links and dotted lines slice dependencies derived from the physical links.
the black node is the start node while the white nodes could be ignored for optimization.
graphs .
for each expression occurring in the slicing results there is a corresponding node in the layer s slice dependency graph that will have dependencies edges to the previous expression in the layer s slice.
if the expression is preceded by if else or switch case conditions it will depend on each condition see the solid edges for the php layer in figure .
furthermore as is typical for slicing techniques if the expression is a function call it will depend on all return statements of the called function while the function definition1culpritoptions string 2nodesprocessed set 3errline finderrormsgline errormsg 4crossstackdepgraph sliceandcreategraph errline 5errnode graphnode errline crossstackdepgraph 6for n node in breadth first traversal of crossstackdepgraph starting from errnode do ifn nodesprocessed then nodesprocessed.add n for o configuration option used by n do culpritoptions.append o end 12end algorithm csce root cause recommendation algorithm.
will depend on all function calls to it.
in case of access to a global variable the node will depend on the last statement modifying that variable.
recursion typically is eliminated .
finally to integrate the slicing results across all layers of a given stack s we introduce the notion of a cross stack slice dependency graph g n e where n e uniontext i l nl i el i ephys where nl i el i is the slice dependency graph of a given component iof some layer l. a layer can have more than one slice dependency graph if it contains parts e.g.
components that are independent from each other for example different wordpress plugins or mysql stored procedures.
the key enabler for gisephys which is the set of edges derived from the physical links that map an expression node in a graph of a given layer to an expression node in a graph of an adjacent lower layer.
ephysmaps a function definition in a layer to its calls in other layers function calls to the return node s of the called function defined in another layer1 and a variable access to its last modification in other layers.
in other words using the physical links of the stack a crossstack slice dependency graph stitches together the individual slice dependency graphs of each layer into one giant graph as illustrated in figure .
c. csce root cause recommendation our modular csce root cause recommendation algorithm ranks configuration options from most likely cause of a csce to least likely.
its main contribution is that it integrates existing 1in case of dynamic slicing we know exactly which return node was used but for static slicing we need to map to all possible return nodes.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static or dynamic slicing techniques applied on different layers or even individual components of a layer instead of requiring a customized slicer per stack.
indeed given the huge variety in programming languages and technologies in the layers of a stack and the even larger flexibility in dependencies between them a custom approach simply would not be feasible.
instead our approach uses the existing slicing techniques in each layer to generate the slice dependency graphs stitches them together in a cross stack slice dependency graph then traverses that graph to recommend options.
the main algorithm of our approach is presented in algorithm taking as input an error message generated by a given software stack.
first line it will try to find the line of code printing the error message using regular expressions.
if this cannot be automated or if no explicit error message is provided for a csce almost always some symptom of the csce can be identified manually for example an infinite loop failing connection or a particular gui element involved in the csce .
in such cases one could substitute errline on line by the manually identified line which can then be used on line to perform slicing on each layer generate the layers individual slice dependency graphs then construct the unified cross stack slice dependency graph.
the essence of the algorithm is a breadth first traversal of the cross stack slice dependency graph starting from the error message node errnode line .
starting from errnode w e navigate the node s backward slice in breadth first fashion along the node s edges in the dependency graph and check each such dependent node for manipulation of a configuration option.
if so we add it to culpritoptions .
to avoid visiting the same subgraph more than once we use a cache to mark the visited nodes line .
finally when following an edge from a function definition to a call the breadth first iteration on line of the algorithm will ignore the edge from the call to the function s return node.
for example after going from the php bar definition to the php bar call white node the algorithm will not return back to return .
we use breadth first traversal for the graph navigation since this will bring us first to the configuration options closest to the error message.
those are the options traditionally considered to have the highest likelihood of being the cause of a configuration error.
options at the same distance from the error message node will be returned in a random order.
since the unified cross stack slice dependency graph spans across all layers the algorithm traverses both lower and higher layers to find the cause of a csce.
some optimizations are possible.
for example when performing the slicing and creation of slice dependency graphs on line the slicing results of a given layer licould be used to limit the code that should be sliced in the next layer belowli .
indeed using a call graph one could filter out the functions from li 1that could never be reached from li via the physical links between the layers.
this works both for dynamic and static slicing.
in figure the white nodes could be ignored by the algorithm as they are not reachable from the definition of php bar which was called from the toptable iii the subject systems used in our evaluation.
subject versions loc options wp wp dr .x .
dr .
dr .
.
woocommerce .
.
hyper cache .
.
updraftplus .
.
wp super cache .
.
wp photo album .
.
nextgen gallery .
.
sitemap xml .
.
php interpreter .
.
preprocessed loc layer.
a second optimization would be to stop the traversal on line as soon as enough unique options have been appended toculpritoptions .
v. e mpirical ev aluation a. setup of empirical evaluation we evaluate algorithm on real csces that we reproduced in a local lamp environment to addresses the following research questions rq1 how accurate is our approach?
rq2 how fast is our approach?
data selection our evaluation considers a lamp stack with the top three layers of figure i.e.
the plugins layer web app wordpress drupal and the php interpreter.
the evaluated csces belong to three data sets table iv wp set csces occurring when using wordpress that are due to a misconfigured option in the php interpreter.
dr set the same but when using drupal.
plugins set csces that occur during the use of a wordpress plugin and that are due to a misconfigured option in wordpress or in the php interpreter.
to obtain the wp and dr sets we used three iterations first during our qualitative analysis of section iii we analyzed the csces that are due to a misconfigured option in the php interpreter and occurred while using wordpress or drupal in order to identify those that could be reproduced locally with the available configuration information.
we also added two additional csces encountered during our previous experiments .
we ended up with configuration errors that in theory should be reproducible.
this step was part of our qualitative study.
the second iteration was the most tedious and timeconsuming as we tried to reproduce each of the csces on our local lamp setup.
it soon became clear that often crucial information required to reproduce an error was missing from a forum conversation.
the major challenges of csces in particular the need to understand each layer s configuration options and their interactions as well as missing version numbers of some of the layers made this iteration quite painful and tedious.
in the end after substantial trial and error we were able to reproduce of the configuration errors.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in the third iteration we filtered out csces with similar symptoms and caused by the same configuration option ending up with distinct csces.
to obtain the plugins set we randomly selected errors from the official wordpress forum and stackoverflow using the configuration options of wordpress and the php interpreter as keywords then manually identifed whether the problem is related to a wordpress plugin.
by following steps and above we obtained new reproducible errors out of .
as shown in table iii our evaluation eventually considers layer instances wp versions dr versions wp plugins and the php interpreter version .
the number of configuration options in these instances ranges from to and each instance has a medium code size ranging up to sloc .
when analyzing a full stack consisting of one wp dr instance one or more wp plugins and the php interpreter the total number of options considered in the evaluation of a csce is the sum of options of all layers.
the evaluated plugins are amongst the top most popular wp plugins with two of them amongst the top .
implementation of approach as described in section iv our approach combines existing static or dynamic slicing tools inside each layer.
to deal with the complexities of the dynamic php language we performed dynamic slicing on php based layers plugins and wp dr layer while we used a static slicing approach on the c based phpinterpreter.
our prototype implementation respectively uses our dynamic phpslicer and static c backslicer tools.
nguyen et al.
s static slicer for php could be an alternative for phpslicer yet it does not consider all dynamic php features like dynamic includes variable of variables ... .
to build the database of physical links between layers we manually analyzed the wp dr and php interpreter source code and found two main kinds of physical links function call to a function implemented in the php interpreter.
for example the basic php function move uploaded file implemented in ext standard basic functions.c of the php interpreter can be called from any higher php layer by the same name move uploaded file .
the php interpreter offers more than such functions to web apps .
superglobal variables i.e.
variables modified in the php interpreter that can be used from any web app.
for example the superglobal variable request when used in a web app actually calls the function php auto globals create request in the file main php variables.c .
such variables exist .
we implemented algorithm in java exploiting the physical links above and calling out to phpslicer and backslicer for the actual slicing.
we optimized the execution time and accuracy of the static c slicing using the dynamic slicing results of the php based layers as explained in subsection iv c. this improvement was essential to make the c slicing scale to the preprocessed version of the php interpreter code base.
evaluation of performance to evaluate the performance of our approach we used two main metrics.
for rq1 weconsidered the rank of the reported misconfigured option in the output of algorithm .
the lower this rank the better since this indicates that a user needs to try out less options before finding the root cause option.
for rq2 we measure the total execution time of our algorithm.
again the lower this metric the better.
we did not count the time to instrument the web application for dynamic slicing purposes and to re run the system to reproduce the error on the instrumented version since is done only once and never surpassed seconds.
table iv summarizes our answers to the two research questions.
rq1 how accurate is our approach?
answer our approach has a high accuracy for ranking the misconfigured options ranking configuration errors with an average rank of .
and a median of with only errors unable to be ranked.
from the configuration errors for which we are able to find the cause in cases we report the culprit option with a good ranking 1st or 2nd suggestion and in one case with an acceptable ranking 5th position while in only three cases a low ranking of or was obtained.
however we think that even if that ranking is not ideal it is still much better compared to manual debugging.
based on the distance based ranking criterion of our algorithm algorithm we are able to report the misconfigured option as the first suggestion even if the distance between the print statement generating the error message and an access to the culprit option is large.
for example for the 3rd and 24th csces we are able to find the misconfigured option as the first suggestion even though the distance between the cslicing criterion and the access is a distance of slicing graph edges apart.
the case with a ranking of corresponds to the 10th csce where the distance is slicing graph edges.
such a ranking is still acceptable in practice since manually finding these options would be hard due to the median distance and the complexity of the php interpreter source code.
in three cases we were only able to report the culprit option as the 10th and 12th suggestion due to the large number of configuration options used in the sliced source code and the high slicing graph distance of and edges.
considering additional strategies for traversing the cross stack slice dependency graph or ranking the culpritoptions e.g.
in algorithm could further improve the results.
deeper analysis of our results showed that the successful csces could be divided into three groups.
the narrow group corresponds to the narrow definition of a software stack section ii b where the code line printing the error message and the line with the culprit option belonged to different layers of the stack.
the broad group contains examples of the first broader interpretation of csces where the wp dr layer generates the csce symptom and reads the value of the offending php interpreter option via the function ini get .
finally the broad group contains examples of the second broader interpretation where symptoms authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
misconfigured option and access to the option s value really happened within the same php interpreter layer yet due to the error reporting option being on the php interpreter s error messages showed up on the user visible wordpress web page not just in the execution logs causing confusion.
in total out of the csces belonged to the narrow group to broad and to broad .
note that narrow errors are impossible to detect by existing single layer approaches see section ii c .
the broad categories may be found by existing approaches but only for higher layers in which most of the functions slice dependency graphs tend to be connected by a call graph.
the deeper one goes the more functions slice dependency graphs are disconnected since lower layers are called by higher ones to provide a specific service then return.
for example the two subgraphs within the mysql layer in figure are not connected directly.
however they are connected via the php layer graph.
without this crosslayer context it is impossible to navigate between functions and hence apply existing single layer approaches.
of course even if all functions in all layers would be connected to each other it is still impossible to predict ahead of time whether the culprit option of a configuration error really belongs to the same layer as the error symptom.
hence even for broad our generic approach is the most pragmatic.
finally we also analyzed the four cases for which we were not able to rank the misconfigured option at all.
the first reason our approach failed is when there was no concrete starting point for the slicing 14th 35th and 36th csces .
for the first two of these errors the culprit configuration option disabled the execution of plugin php code altogether option short open tag was set to off .
for the 36th case the user is redirected to the login page after trying to access the admin panel without any error message.
in general unexecuted code or lack of symptom is a problem for all approaches.
the second reason preventing us from ranking the 13th error case is that the error message was shown in the browser by javascript code after an ajax call.
since our work currently does not consider javascript and its asynchronous calls we plan to combine our approach with existing work that analyzes client source code html js .
note that similar to related work on debugging configuration errors we also assume that an error is already classified as being a configuration issue.
our technique can be complemented by the approach of wen et al.
to first classify an error as configuration or non configuration error.
rq2 how fast is our approach?
answer the errors are reported within minutes which makes our approach practically useful for users.
dynamic slicing requires an execution trace which can be generated by instrumenting an application and executing it.
the instrumentation took .
seconds in the best case and .
minutes in the worse case with this time typically related to the size of the instrumented layer in sloc .
even when the instrumentation takes around minutes this needs to be done only once after which the instrumentedversion of the system can be deployed and made available by customer service to all troubleshooting users for example by manipulating the dns server or load balancer .
to generate the execution trace from the instrumented version a user needs to reproduce the error on the instrumented version of their web app.
although the instrumentation makes the web app slower from our evaluation the error reproduction did not require more than seconds on the evaluated errors.
after the error reproduction one has to execute our algorithm which takes between .77s and .18s median of .10s to perform the slicing and find the misconfigured option.
note that without the optimization that reduces the scope of slicing for lower layers based on the slicing results of higher layers the c slicer sometimes would not finish hence we considered this optimization crucial to make the approach compatible with static slicing of large layers.
hence even if some steps can still be improved in future work our approach is not only accurate but also fast enough for practical usage.
since to the best of our knowledge we are the first to propose a generic approach to debug csces we compared our approach to a manual search in an online forum like stackoverflow serverfault or stackexchange based on the qualitative study of section iii.
without considering the time required to test a proposed answer and to discuss it via comments one has to wait a median of .
hours to get the correct answer for misconfigured php interpreter options assuming the question was answered and the accepted answer also applies to other people.
although we do not have precise numbers on unresolved forum errors we did find that of php interpreter csce threads are answered by the original poster.
this suggests that a asking a question online does not guarantee an answer and that b in cases where the original poster had to find the answer on her own she took the effort to follow up on her own question.
instead our approach is more likely to propose a relevant answer and does this in a median of only .
hours current prototype .
vi.
t hreats to validity a. qualitative analysis despite the effort spent on our qualitative study design gathering and clustering data from q a forums we identified several threats to validity.
first extracting data from stackexchange and its sub forums is subject to construct validity since we used the configuration options as keywords retrieve discussion threads.
relevant discussions not mentioning explicit option names may have been missed.
moreover the data extracted is subject to potential threats to reliability due to the gamification characteristics of stackexchange .
q a participants compete for reputation points and badges which could encourage them to guess which configuration option might be the root cause of a csce introducing bias into our metrics such as the number of options or layers discussed .
fortunately questions and answers are voted upon by the community filtering out guesswork.
furthermore we manually analyzed the discussions text to cluster threads in categories which could introduce subjectiv262 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv the evaluated csces.
data error system used misconfigured option csce group rank trace size timewp set1 the maximum execution time allowed is exceeded wp max execution time php broad .
mb .13s the folder s path used to save session data is incorrect wp session.save path php broad .
mb .18s the allowed memory size wp is requiring has been exceeded wp memory limit php broad 3k b .56s unable to send mails wp sendmail path php narrow .4mb .35s web page inaccessible as its source code is outside the allowed path wp open basedir php broad .79s upload filesize has no effect on maximum file size to upload wp post max size php broad .
mb .75s no additional database connections available to wp wp mysql.max links php narrow kb .46s file upload disabled wp fileuploads php narrow .2mb .98s not able to upload a file wp max fileuploads php narrow .
mb .31s incorrectly specified wp source code include path wp include path php broad bytes .54s the maximum number of form inputs a user can send is exceeded wp max input vars php broad .
mb .91s not able to upload a file wp post max size php narrow .
mb .27s no results for ajax query that exceeded the alotted time wp max execution time php narrow .
mb web app does not execute php code wp short open tag php no symptom plugins set15 the plugin warns user from a lack of memory woocommerce wp memory limit wp broad .
mb .04s not able to use caching features as it is disabled in wp hyper cache wp cache wp broad .
mb .64s not able to use backup features in the plugin updraftplus disable wp cron wp broad .9mb .42s plugin disabled due to a wp option wp super cache permalink structure wp broad .5mb .07s not able to upload a file due to its large size wp photo album upload max filesize php broad .1mb .01s fail to upload a file due to a lack of memory nextgen gallery memory limit php broad 12mb .73s plugin reports error when compression is enabled in php interpreter wp super cache zlib.output compression php broad .7mb .24sdr set22 dr reports that the option s value is very low dr max execution time php broad .
mb .35s idem to the last case dr memory limit php broad .
mb .65s dr crashes as the allowed memory limit is exceed dr memory limit php broad kb .90s not able to load php extensions dr extension dir php broad kb .26s dr warns that option s value is incorrect dr magic quotes gpc php broad kb .50s dr crashes due to a limit of execution time dr max execution time php broad kb .10s not able to upload a file as its size is not allowed dr upload max filesize php broad 6m b .12s dr is reporting an error while the value of that option is incorrect dr register globals php broad kb .34s the number of form inputs is limited dr max input vars php broad .
mb .69s restriction of files that can be used dr open basedir php broad .77s not able to enable a dr module due to a missed php extension dr extension php narrow .
mb .90s upload max filesize has no effect on maximum file size to upload dr post max size php broad .
mb .78s not able to upload a file dr upload tmp dir php narrow .
mb .44s dr shows its source code instead of executing it dr short open tag php no symptom the user is redirected to the login page without error message dr max input vars php no symptom .
mb table v comparison to evaluation in related work.
paper errors real errors random cross studied evaluated evaluated stack systems our work yes zhang et al.
no yin et al.
no arshad et al.
no dong et al.
no attariyan et al.
no zhang et al.
no ity in the analysis.
to counter this we used two raters and a multi iteration approach for card sorting and we also analyzed a large data set of threads.
finally regarding threats to external validity we only considered lamp related discussions and we combined the single layer and csce data of the five analyzed layers to deal with data imbalance.
given its popularity in the field we believe lamp to be highly representative.
furthermore the large number of single layer and csce data analyzed as well as the variety of observations that we made provide us confidence about our results.
studies on other stacks and other lamp web apps should be performed in the future.
b. empirical evaluation regarding the threats to external validity of our evaluation we only analyzed wordpress plugins drupal and the php interpreter hence we cannot generalize the results to other stacks nor to lower layers such as apache and operating systems.
however our outcomes show promising results encouraging us to evaluate the approach as well on other stacks such as mean.
regarding threats to internal validity the number of analyzed and evaluated configuration errors is high compared to related work table v with the number of analyzedconfiguration errors twice the number of yin et al.
s study and the number of real evaluated error higher than dong et al.
.
in future work we aim to evaluate even more real csces although reproducing such errors is time consuming.
another threat to internal validity could be the fact that we did not evaluate our approach in cases where more than one option was misconfigured.
however we think that in such cases users can fix an initial option using our tool then reexecute their scenario to find the second misconfigured option and so on.
for future work we aim at exploring such cases.
finally we only focus on errors that cause a system to crash or write out an error message.
we are not focusing on misconfiguration errors that have an impact on the system s performance only.
however in section iii we found that the majority of configuration errors exhibit a crash or a hang.
for future work we plan to consider other kinds of errors.
vii.
c onclusion this paper empirically studied the impact effort and fix complexity of cross stack configuration errors csces for online configuration errors showing that csces are common and have a severe impact even in production.
we then proposed the concept of cross stack slice dependency graph and an accompanying modular algorithm to recommend the culprit option of a csce by integrating the results of existing slicing algorithms.
empirical evaluation on real csces in a lamp stack showed that the approach provides a good ranking in a minimal amount of time and could be integrated into the workflow of online stack hosting.
future work should evaluate our approach on other stacks and additional deeper layers.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.