syntax guided synthesis ofdatalogprograms xujie si universityof pennsylvania usa xsi cis.upenn.eduwoosuk lee universityof pennsylvania usa hanyanguniversitysouthkorea woosuk cis.upenn.edurichard zhang universityof pennsylvania usa rmzhang cis.upenn.edu aws albarghouthi universityof wisconsin madison usa aws cs.wisc.eduparaschoskoutris universityof wisconsin madison usa paris cs.wisc.edumayurnaik universityof pennsylvania usa mhnaik cis.upenn.edu abstract datalog has witnessed promising applications in a variety of domains.
we propose a programming by example system alps to synthesize datalog programs from input output examples.
scaling synthesistorealisticprogramsinthismannerischallengingdue to the rich expressivity of datalog.
we present a syntax guided synthesisapproachthatprunesthesearchspacebyexploitingthe observation that in practice datalog programs comprise rules that have similar latent syntactic structure.
we evaluate alpson a suite of 34benchmarksfrom threedomains knowledgediscovery program analysis and database queries.
the evaluation shows that alpscan synthesize of these benchmarks and outperforms the state of the art tools metagol and zaatar which can synthesize only upto ofthe benchmarks.
ccs concepts theoryofcomputation programanalysis activelearning software and its engineering programming by example domainspecificlanguages informationsystems relational databasequery languages keywords syntax guidedsynthesis datalog activelearning templateaugmentation program analysis acmreference format xujiesi woosuklee richardzhang awsalbarghouthi paraschoskoutris andmayurnaik.
.syntax guidedsynthesisofdatalogprograms.in proceedingsofthe26thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse november 4 9 lake buenavista fl usa.
acm new york ny usa 13pages.
the firsttwoauthorscontributed equally to thiswork.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse november 4 9 lake buenavista fl usa associationfor computing machinery.
acm isbn ... .
introduction datalog a declarative logic programming language has witnessed promising applications in a variety of domains including bioinformatics big dataanalytics naturallanguage processing networking program analysis and robotics .
a key reason is the emergence of scalable datalog solvers including open source and commercial ones .moreover theconciseanddeclarativenatureof dataloghasmadeitthetargetofagrowingbodyofmeta reasoning tools.forinstance programanalyseswrittenindatalogarereadily extensible with features such as fixed point frameworks abstraction refinement and user interaction .
likewise software definednetworking sdn applicationswrittenin datalog canavail ofefficient provenancetracking tohelp intasks such as debuggingandrepairing .
a key hindrance to bringing these benefits to a broad user base is the lack of automated tools to help develop datalog programs.
tothisend weproposeaprogramming by examplesystem alps to synthesize datalog programs from input output examples.
this constitutesanaturalnextstepinmanydomainssuchasprogram analysis and networking where reference imperative implementationscan provideinput output examples.
whileostensiblysimple synthesizingsuchprogramsischallenging because datalog is powerful enough to capture all polynomial time computations.
learning logic programs from examples has beenextensivelystudiedinasubfieldofmachinelearningcalled inductive logic programming ilp .
however even stateof the art ilptechniquesareverylimitedintheirabilitytolearn realistic datalogprograms .
we propose a new approach to synthesize datalog programs.
our key insight is that such programs in practice comprise rules that have similar latentsyntactic structure.
our approach exploits this insight via the syntax guided program synthesis paradigm whereinthesyntacticstructureofthetargetclassofprogramsis leveraged toefficiently traverse thehypothesisspace ofprograms.
for this purpose our approach must address three key challenges i capture syntactic structure effectively ii minimize the number of examples needed and iii explore the search space efficiently.
we nextelaborateuponeachof theseobjectives.
to capture the syntactic structure of rule based programs we usemeta rules templates that describe a set of possible rules that can appear in a program.
the key challenge is to obtain a setofmeta rulesthatis generalenoughtocaptureusefulprograms esec fse november4 lake buena vista fl usa x. si w.lee r. zhang a.albarghouthi p.koutris andm.
naik but specific enough to enable efficient synthesis .
we propose a novel approachtosystematicallygeneratemeta rules takingadvantage ofdomainknowledge.
tominimizethenumberofexamplesneeded ourapproachaims toaskanoracleasmallnumberofqueriesconcerningtheexpected outputonagiveninput.theoracleneedonlyanswerwith yesor no rather than crafting elaborate examples and supplying them to thesynthesizer.weusean activelearning technique called query by committee qbc to pick an example that can prune the searchspacethemost.inoursetting qbctakesasinputacommittee formed by a set of consistent programs and returns an example on which the committee disagrees the most the most controversial example.
we then prune the programs that disagree with the given label and repeat the process.
however it is infeasible to apply qbc onthe entire searchspace whichisprohibitivelylarge.
to explore the search space efficiently and overcome the challenge in using qbc we use a bidirectional synthesis strategy to maintain the most general andmost specific programs that are consistent with the given examples .
intuitively the most general and most specific programs defined through logical entailment form a representative set of the search space allowing us to preserve exactness of the search.
moreover this set is much smaller than the size ofthe search space making itan ideal committee .
to incrementally update the search space as examples are labeled we defineefficient top downandbottom uprefinementoperators that are guidedbythe given setofmeta rules.
we have implemented our end to end approach in the alpssystem and report on our experience evaluating it on a diverse set of34benchmarksfromthreedomains knowledgediscovery program analysis and relational queries.
the evaluation shows that alpscan synthesize of these benchmarks and outperforms the state of the arttoolsmetagol andzaatar whichcansynthesizeonly upto ofthe benchmarks.
we summarize the main contributionsofthis paper wepresentasyntax guidedapproachandsystem alpsforsynthesizingdatalogprograms from input output examples.
alpsemploys a bidirectional search strategy to efficiently traversethe spaceofpossible programs.
alpsminimizesthenumberofrequiredexamplesusinganactive learningtechniquecalledquery by committee.
we demonstrate the effectiveness of alpsat synthesizing realistic datalog programs from diverse domains and its ability to outperform existing state of the arttechniques.
overview examples alpslearns datalog programs that are correct with respect to a given instance of input and output relations.
in this section we firstpresenttwoillustrativeexamplesthathighlightapplicationsof alpsin two domains program analysis and relational queries.
we then present an example to elucidate key design choices in alps.
we alsouse itas the running example inthe restofthe paper.
example .
program analysis .
datalog has shown great potentialinthedomainofprogramanalysis .thus there is a growing need to help synthesize program analyzers in datalog foravarietyofprogramminglanguages includinggeneral purpose anddomain specific ones.we demonstrate how alpscan be used to learn a static analysis to detect api misuses a common source of bugs in today s world ofcomplexandevolvingapis.foragivenexampleprogramwith known api misuses we populate input relations representing the syntax ofthe program andoutput relations representing the bugs.
then alpslearns datalog rules that can be used for detecting similar api misuses.
considerthefollowingcprogramusingtheopensslapi.functionsssl socket open1 establishasslsocketandreturnaconstantokiftheysucceed.twofunctions ssl socket open contain api misuses in that they incorrectly return okwhen a ssl socketisnot properly established.
1intssl socket open1 ssl ssl 2x509 cert ssl get peer certificate ssl 3longerr ssl get verify result ssl 4if !cert ... 5if err x509 v ok ... 6returnok correct 9intssl socket open2 ssl ssl 10x509 cert ssl get peer certificate ssl 11if cert null ... 12longerr ssl get verify result ssl ... 14returnok incorrect missingcheckon err 17intssl socket open3 ssl ssl 18longerr ssl get verify result ssl 19if err!
x509 v ok ... 20x509 cert ssl get peer certificate ssl 21if cert ... 22returnok correct 25intssl socket open4 ssl ssl 26longerr ssl get verify result ssl 27switch err casex509 v ok cert ssl get peer certificate ssl 31returnok incorrect missingcheckon cert ourgoalisto learnadatalogprogramthatdetects functions that misuse the opensslapi whose behaviorisdefinedas follows ssl get peer certificate returns a pointer to the x509 certificatethepeerpresented.ifthepeerdidnotpresentacertificate nullisreturned.
ssl get verify result returns the result of the verification of the x509 certificate presented by the peer if any.
it returns a constant named x509 v ok if the verification succeeded or if no peer certificate waspresented.
functions should return okonly if i ssl get peer certificate returnsanon nullpointer and ii ssl get verify result returns the constant named x509 v ok .
theprobleminvolvesfourinputrelationsandoneoutputrelationwiththe following meaning 516syntax guidedsynthesis ofdatalogprograms esec fse november4 lake buena vista fl usa opsucc l1 l2 program controlmayflowfrom line l1tol2.
check x l the value of variable xis compared to a specific valueat line l. certify x l variable xat linelis assigned the return value ofssl get peer certificate .
verify x l variable xat linelis assigned the return value ofssl get verify result .
ok l thefunctionthatreturns okatlinelcorrectlyusesthe opensslapi.
relations opsuccandcheckare pre defined as part of the program s intermediate representation while relations certifyand verifycan be automatically extracted from a given api in this case openssl.
we provide an instance of these relations encoding the analyzedc program to alps namely certify cert verify err check cert check err ... alongwith ok andok aspositiveexamplesand ok and ok as negativeexamplesintheoutputrelation.
alpsgenerates the following program in6minutes.
certflow x l2 certify x l1 opsucc l1 l2 .
veriflow x l2 verify x l1 opsucc l1 l2 .
certcheck l2 certflow x l1 check x l1 opsucc l1 l2 .
vericheck l2 veriflow x l1 check x l1 opsucc l1 l2 .
ok l certcheck l vericheck l .
therulesareintendedtobereadright to left withallvariablesuniversally quantified and the operator interpreted as implication.
notethatpredicates certflow x l veriflow x l certcheck l andvericheck l are not specified among the input or output relations they are invented by alps highlighting the rich space of programs it explores.1we elaborate on how the search space is determined in section .
.
the relation certflow x l veriflow x l resp.
indicates the return value of ssl get peer certificate ssl get verify result resp.
flows to line l. the relationcertcheck l vericheck l resp.
meansthereturnvalue ofssl get peer certificate ssl get verify result resp.
is comparedto aspecific valueandcontrolflowsto line l. thedatalogprogramcorrectlycapturesanimportantportion of the proper use of the openssl api.
this example illustrates thatalpsrepresents a promising step towards synthesizing usable programanalyzers.onthecontrary thestate of the art ilptools metagolandzaatar fail to synthesize the program within 3hours.
example .
relational queries .
datalog is widely used as a relational query language due to its expressiveness and scalable performance .alpscanbeusedtosynthesizesophisticatedrelationalqueriesindatalogfrom input output behaviors.
we illustrate using alpsto synthesize a relational query for finding students who take two different classes on the same day.
the problem involves three input relations and one output relation withthe following meaning student s n student sisassociatedwiththe id n. class c d classcisheld onday d. enrolled n c the studenthavingid nisenrolledinclass c. busy s student stakes twodifferentclassesonthe same day.
1for readability we provide intuitive names for invented predicates instead of mechanically generated onesby alps.itisnaturalinaprogramming by examplesettingfortheuserto provide an instance specifying the input output behavior of the desiredquery.usingsuchaninstancecomprisinginputrelations regarding students and classes and examples in the output relation busy alpssynthesizes the following datalog program within seconds enrollclass n c l enrolled n c class c l .
busy s student s n enrollclass n c1 l enrollclass n c2 l c1!
c2.
whereenrollclass is an invented predicate.
while ostensibly simple the above query is non trivial to synthesize since it is semantically equivalentto the following complex sql query select s.s from student s where s.n in select e1 .n from enrolled e1 enrolled e2 class c1 class c2 where e1.n e2.n and e1.c e2.c and e1.c c1.c and e2.c c2.c and c1.d c2.d in contrast a state of the art tool scythe for synthesizing sql queriesfails to generatethe above sql query within 3hours.
example2.
knowledgediscovery .
wedemonstratehow alps synthesizes a prototypical program in knowledge discovery that is commonly used in the ilpliterature computing the transitive closureofadirectedgraph.theprobleminvolvesoneinputrelation edgeandone outputrelation pathwiththe following meaning edge x y there isan edge from node xto nodey.
path x y there isapathfrom node xto nodey.
suppose the user populates the input relation edge with the following example graph where an edge from node ito nodejindicates that edge i j appears inthe inputrelation.
given4examplesoftheoutput relation path alpssynthesizes the following recursive program in less than one second which computes the transitive closure of adirectedgraph.
path x y edge x y .
path x z path x y edge y z .
infact since alpsmaintainsallpossibleprograms italsodiscovers the following non linear recursive program path x y edge x y .
path x z path x y path y z .
wenextelaborateonthreetechniquesthat alpscombinessynergisticallyinorder to realizethis result.
meta rule guided synthesis.
learning datalog programs is a complextask evenapproximatelearningishard .3toovercome thisbarrier alpsexploitsthe observationthatin practicedatalog programs comprise rules with similar latent syntactic structure.
2datalogcan infactbe viewed as augmentingrelationalalgebra which iswidely used in the form of sql with recursion.
3in approximate learning the learnt program is not guaranteed to be consistent with the given examples.
517esec fse november4 lake buena vista fl usa x. si w.lee r. zhang a.albarghouthi p.koutris andm.
naik note that both of the recursive rules above are very similar the onlydifferenceisintherelationnames.wecapturesuchsimilarities viathenotionof meta rules whichareessentiallyhornclauses where the relation names are kept abstract and can be instantiated later.thenbothoftherecursiverulesareinstancesofthemeta rule r0 x z r x y r y z .
manydatalogrulesfollowasimilarchainpattern.thissuggests astrategyforsynthesizingdatalogprograms enumerateallpossibleinstantiationsoftheabovemeta rulewithconcreterelation namesandexaminetheircombinations.furthermore wecanthink of slight variations of this pattern to capture a broader range of programs.
for example the first rule in example .2is a slight variation of this meta rule the only difference being the arity of predicate enrollclass .
we formalize this concept via a process calledaugmentation see section .
.
query by committee qbc .alpsusesanactivelearningtechnique to iterativelyposemembershipqueriesaboutthe contents oftheoutput relation whichcanbe answeredupfront orinaninteractive manner.
to minimize the number of queries at each step alpspicks a query that can prune the space of candidate programs the most to converge to the oracle s desired program.
in the above example it begins by posing the query is there a path from 1to ?it obtains the answer yes.alpsthen poses the next query is thereapathfrom 3to2?itobtainstheanswer no andtheprocess continues.
after queries out of possible queries all pairs i j wherei j alpsarrivesattheaboveprograms.incontrast picking examples to query randomly may result in a large number ofquestions.
forinstance in100 trialswith random selection the maximum number ofqueriesis27 withan averageof12.
bidirectionalsearchstrategy.
toexplorethesearchspaceefficiently weproposeabidirectionalsynthesisstrategytomaintain aconcisecommittee i.e.
themost generalandmost specificprogramsthatareconsistentwithcurrentavailableexamples.inour running example using this strategy results in only 384programs beingevaluatedduringthesearch outofover 104possibleprograms inthe searchspace.
theabovethreetechniquesarecombinedinasynergisticalmanner inalps meta rules define a reasonably large and rich space of candidate programs the syntactic structure of the space enables bidirectionalsearchtoefficientlyrepresentandeffectivelyrefineall consistent candidateprograms as aconcise committee and using this committee qbcguides the refinement by picking the most controversialexample to query inthe nextiteration.
problem formulation in this section we formalize datalogandthe synthesis problem.
.
datalogprograms rules.atermtiseitheravariable x y z ... oraconstant a b c .... arelation symbol p q r ...is associated with an arity ar r .
an atomis an application of a relation symbol to a vector of variables and constants e.g.
r x y a for a relation rwith arity .
a ground atom is an application of a relation symbol to constants e.g.
r a1 ... an whereaiare constants.
a datalog rule cis an expression ofthe form a b1 b2 ... bn.
wherea b1 ... bnare atoms.
the atom ais called the headof the rule the set of atoms b1 ... bn is called the bodyof the rule.adatalogrulecanbeinterpretedasalogicalimplication if b1 ... bnare true then sois a. programs.
a datalog program pis a finite set of rules.
we divide relation symbols into two categories the input relations whose contents are given and the output relations whose contents are derived from the input relations using the program p. an input relation can never appear in the head of a rule.
we use ito denote the set of facts ground atoms in the input relations.
the herbrand basebdenotesallpossibleapplicationsoftheoutputrelationsto vectorsofconstantsin i.adatalogprogramis recursiveifarelation symbolappears inboth the head andthe body of arule.
semantically evaluating poniyieldsaminimalherbrandmodel ofp i whichisthesmallestsetofgroundatomsthatsatisfiesthe rules inpand input i. given a ground atom e p i edenotes thatpwithinput iderives fact e. .
synthesis problem our task is to synthesize datalog programs through examples.
an exampleis a ground atom from the herbrand base b which can be labeled as positive or negative .
we are now ready to define our synthesis problem.
definition3.
synthesisproblem .
asynthesisproblem sisatuple h o i where hisasetofdatalogprograms i.e.the hypothesisspace oisanoraclethat labels eachexample with iisasetofinputs facts inthe inputrelations.
lete o e b o e ande o e b o e be the positiveandnegativeexamplesdefinedbytheoraclerespectively.
thegoalistofind p hsuchthat forall e e o p i e and for alle e o p i e. givenasynthesisproblem h o i thesetofalldatalogprogramsp hthat are consistent with e e e is called the versionspace andisdenotedve.
ourapproach inthissection wepresentthesynthesisalgorithmunderlying alps.
section4.1describes the structure of the search space.
section .
presentsthealgorithmparameterizedbyrefinementoperators.section4.3instantiates the algorithm with meta rules.
section .
describes our methodology for designing meta rules.
lastly section4.5states formalpropertiesof our algorithm.
.
structureofthesearch space thehypothesisspace hconsistsofafinitesetofdatalogprograms overthe sameinputand outputrelations.
forourrunning example example .
we consider a simple hypothesis space where all programs use asubsetofthe following fourrules r1 path x y edge x y .
r2 path x z path y z .
r3 path x x edge x x .
r4 path x y path x z path z y .
518syntax guidedsynthesis ofdatalogprograms esec fse november4 lake buena vista fl usa algorithm1 thealpssynthesis algorithm e e p mostgeneral p mostspecific loop p p p construct committee if e b.d e p 0then return p e argmaxe bd e p most controversial example o e e e e p f p e e top down refinement p f p e e bottom uprefinement end loop wedenotethedatalogprogramconsistingofrules ri rj rkaspijk.
generalityorder.
westructurethesearchbyimposingageneralityorderonthespaceofdatalogprograms.todefinethisorder we use subsumption whichisasyntacticapproachfordeciding whether one rulesubsumes ismore generalthan anotherrule.
formally a rule csubsumes another rule diff there is a variable substitution suchthat c hasthesameheadas d andallatomsin thebodyof c appearinthebodyof d.4forexample r2subsumes r4with z y y z andr1subsumes r3with y x .
subsumption can be naturally extended from rules to programs.
for any two datalog programs pandq psubsumes q denoted q p iff for every rule in qthere exists a rule in pthat subsumes it.for instance inour running example p13subsumes p24.
given the hypothesis space h and a generality ordering everysubset pofhformsaquasi orderedsetw.r.t.
.wecannow construct a partial order on the quotient set of the equivalence relation twoprograms p qare equivalentif p qandq p .
inourrunningexample thefollowingequivalenceclassesare formed w.r.t.
subsumption p1234 p123 p124 p12 p143 p14 p13 p1 p324 p32 p24 p2 p34 p3 and p4 .
we restrict the hypothesis space such that it has one representative from each class anyoftheprogramswiththefewestrules anddefineapartial order directlyonthese representativesinsteadoftheequivalence classes.
we can achieve this without any loss of generality since we are discardingonlysemantically equivalent programs.
for our runningexample thehypothesisspacecannowbereformulated as p12 p14 p1 p32 p2 p34 p3 p4 .
sincethe generalityorderis a partialorder there may exist multiple maximal and minimal elements.
the set of maximal elements is denoted max p p p p p.p p and we call these themost general programs.similarly thesetofminimalelements is denoted min p p p p p.p p and we callthese themost specific programs.figure 1ashowstheinitialversionspace forourrunningexample wherethemost specificandmost general programs are coloredyellowandred respectively.
.
the alps algorithm given a synthesis problem s h o i alpsapplies algorithm tofindasolutionfor s.itisafixpointalgorithmthatmaintainsa 4asubstitution isaset v1 t1 vn tn wherethe viaredistinctvariables andtiareterms.notation c denotestheruleobtainedbyapplyingsubstitution onrulec i.e.
for each vi ti wereplaceeachoccurrenceof viincbyti.paire e e of positive and negative examples and a set of most general programs pand most specific programs pthat are always consistent with e. the examples are initially empty and p pare initialized to be the most general and most specific programs respectively wedefinethisinitialization insection .
.
at everyiteration itaddsa positiveornegative examplebyquerying the oracleo.
then it invokes two refinement operators f f whichrecalculatethemost generalprogramsandthemost specific programsthatagreewiththenewexample wedefinetherefinementoperatorsinsection .
.the algorithmstopswhennonew examples can be added.
the crux of the algorithm is the way we choose the example toquerytheoracle.theunionoftwosetsofprograms p pforms thecommittee p.thecommittee then picks the mostcontroversial examplee .
ifo e thene is added to e otherwise e is addedto e .ifnocontroversialexampleexists theneveryonein thecommitteeagrees thealgorithmterminatesandreturnsset p whichcontains allthe most general andmost specific solutions.
inordertodeterminethemostcontroversialexample weusethe metricof voteentropy .itisinspiredbyquery by committee a greedy yet effective strategy commonly used in active learning .
since there are only two possible labels for an example we use a simplified definition which is essentially equivalent to disagreement count.
definition .
vote entropy .
for an example eand set of committee members k thenormalized voteentropy is d e k k barex barex barex barexp k barex barex barex barex wherepisthenumberofcommitteemembersthatassignapositive label to the example e. when the vote entropy of an example is zero all programs in the committee agree on its label.
figure 1shows theversion space andthe query posedineachiteration for our running example.
.
refinementwith meta rules we now give concrete definitions of the initialization functions and refinement operators f andf in algorithm .
the design of the refinement operators is motivated by a practical insight the synthesis search should be biased towards patterns that are frequently used in practice.
we are inspired by meta rules which are templates that dictate syntactic restrictions on rules and therefore anaturalrepresentation to biasthe search.
meta rules.
ameta rule is asecond order rule .
multiple rules can be instantiated from a meta rule.
we shall use v1andv2to denote first andsecond ordervariables respectively.ameta ruletakes the following form r1 x1 ... xm1 r2 y1 ... ym2 ... rn z1 ... zmn .
wherexi yi zi v1andri v2.
a meta rule can be instantiated by substituting second order variables with relation symbols.
for example the rules from the running example are generatedbythe following meta rules t1 r0 x y r x y .
t2 r0 x z r y z .
519esec fse november4 lake buena vista fl usa x. si w.lee r. zhang a.albarghouthi p.koutris andm.
naik a initialization path ?no1 b iteration path ?yes1 c iteration path ?yes1 d iteration converged figure versionspaceineachiteration red yellow nodes represent most general specificprograms inthe currentiteration purple nodes represent programs that are both most general and most specific in the current iteration and grey nodes represent programs that have been evaluated .
anarrow from utovmeansthat program uismore generalthan program v. algorithm2 meta rule guidedrefinement function f p e e e e e whilep vedo p p ve ve p p t ve p p ve p end while returnpfunction f p e e e e e whilep vedo p p ve ve p p t ve p p ve p end while returnp t3 r0 x x r x x .
t4 r0 x z r x y r y z .
similartorules ageneralityorderbetweenmeta rulescanbeestablishedusing subsumptionbyallowingsubstitutionforsecondordervariablesaswellasfirst ordervariables.usingthisgenerality order asetofmeta rulesforms apartiallyorderedset.
initialization.
theinitializationfunction mostgeneral collects all rules instantiated from the most general meta rules and combinesthemasthemostgeneralprogram.theinitializationfunction mostspecific makes each individual rule instantiated from the mostspecificmeta rulesasasingleruleprogram andallofthese programs form the initialsetofmostspecific programs.
meta rule guidedrefinement.
algorithm 2describesourrefinement operations f andf which are parameterized by a set of meta rules t. we explain only top down refinement f in detail since bottom up refinement f works inasymmetrical manner.
the algorithm begins with the given set of programs p. then it iteratively specializes theprogramsbyapplyingthespecialization operator which is guided by t line2 5 .
in each iteration the condition p vechecks whether the current programs are consistentwiththeexamples.ifthereisnoviolation thealgorithm terminates.
otherwise line 3first eliminates programs violating positive examples and then selects programs violating negative examplestospecialize.intheformercase programsfailtoderivea positiveexample andmorespecificprogramswillalsofailtoderive it.thisprocessremovesnotonlyinconsistentprogramsbutalso anyprogramsmorespecificthanthem.theeliminationhappens inthethirditerationofourrunningexampleshowninfigure 1c whenp23is eliminated due to the positive example path all the more specific programs p34 p2 p3 p4are eliminated from considerationas well.
next line 4specializes programs violating negative examples bycalling andeliminatesanygeneratedprogramsthatfailto deriveapositiveexample.finally line 5updatespbyincludingthe newspecializedprograms.
the final piece of the puzzle is the specialization operator .
here canspecializeaprogramintwoways replacearule it witha more specificone forinstance inourrunningexample shown in figure 1b program p12is specialized to p14andp23 remove a rule that cannot be further specialized for instance p23could potentially be specialized to p2.
finding all more specific rules for a given rule rcan be efficiently done by consulting the generality order of the meta rules t first find the meta rule tr usedtoinstantiate r then findallmorespecificmeta rules tswith respectto tr finallyexamineallrulesinstantiatedfromameta rule intsandkeepthe ones more specific than r. .
augmentationandpredicateinvention the choice of meta rules dictates the effectiveness of our synthesis algorithm.if theset ofmeta rules istoolarge then alpswillnot beabletoscale sincethesearchspacewillbehuge.ontheother hand themeta rulesmustbesufficientlyrichtocapturethedesired program.
simply reusing meta rules that are either provided by the end user or mined from existing code repositories is usually insufficient.tosolvethisproblem westartwithaverysmallset ofintuitivemeta rulesthatarespecifiedmanually e.g.
thechain meta rule and then extend these using augmentation a process that slightly modifieseachmeta rule.
an augmentation t of a meta rule tis a meta rule where each atomr x1 ... xk intisreplacedbyanotheratom r y1 ... yl .
however we must take care to limit how much the sequence of variables changes.
denote by dr t t theedit distance between the strings x1...xkandy1...yl.
then the augmentation distance betweent t isdefinedas ad t t summationdisplay.
rdr t t 520syntax guidedsynthesis ofdatalogprograms esec fse november4 lake buena vista fl usa whererranges over all atoms in t. our key idea is to consider all theaugmentationsof tthatare withinaboundedaugmentation distance from t. the smaller this bound the fewer meta rules will be generatedfrom t. asanexample of augmentation considerthesetwo meta rules t1 r0 y r z r2 y z .
t2 r0 y z r z x r y z .
then t2isan augmentationof t1withdistance .
the augmentation distance required for alpsto synthesize a programpfrom an initialsetofmeta rules tis ad p t max t1min t2 tad t1 t2 wheret1ranges over all meta rules used in p1.
in our experiments we could synthesize almost all of the programs using an augmentationdistanceof5from three chain meta rules.
predicate invention.
another orthogonal way to improve the richness of programs in the search space is predicate invention.
predicate invention helps to break a complex rule into simpler ones andtherebyenablestoreuseexistingmeta rules.moreimportantly itisunavoidablefordatalogprogramswithrecursion.for instance consider the following program which computes strongly connectedcomponents scc inadirectedgraph path x y edge x y .
path x z path x y edge y z .
scc x y path x y path y x .
here the input and output relations are edgeandscc respectively.
given that scccannot be derived by any set of clauses in terms of onlytheinputrelation edge anewpredicate pathmustbeinvented.
the difficulty with predicate invention lies in determining what formtheinventedpredicatesshouldtake.withoutmeta rules we have no way to effectively constrain the syntax of such predicates.
with meta rules we can easily support predicate invention the rulesthatdefinethepotentialinventedpredicatesareexactlythe instantiationsofmeta ruleswithconcrete relations.
.
propertiesofalps thealpssynthesisalgorithm algorithm alwaysmakesprogress after every query to oracle o we remove from consideration a controversialexamplefrom b.sincethesetofpossibleexamples bis finite the algorithm always terminates.
it also guarantees that asolution isfoundifthere are nocontroversialexamplesleft in the committee.
to ensure this property it is critical that the algorithmtracksboththemost generalandmost specificprograms ateveryiteration.thefollowingtheoremsuccinctlycapturesthese properties.we provideits proofinthe appendix.
theorem .
.
lets h o i be a synthesis problem such that asolutionto sexistsinh.letpbetheoutputof alps.then soundness every p pis asolutionto s. completeness for every solution p htos there exist programs pl pu psuch that pl p pu.
an immediate corollaryisthatifthereexistsaprogrampthatisasolution tos thenpis nonempty.
termination alpsterminates in finitelymanysteps.
empirical evaluation we evaluate alpson a variety of synthesis tasks from different domains.
our implementation5comprises about lines of c code.itusesthefixpointengineofthez3 smtsolver fordatalog evaluation.ourexperimentswereperformedonalinuxmachine with16 gb ofram anda3.
ghz processor.
our evaluation aims to answer the following questions q1.howdoes alpsperformonsynthesistasksfromavarietyof domainsinterms ofsynthesis time andnumber of queries?
q2.how much does meta rule augmentation speed up synthesis?
q3.howeffectiveis qbcinreducingthenumberofqueriesasked?
q4.howsensitive is alpsto changes inagiven inputdata?
q5.howdoes alpscompare withexisting synthesis techniques?
.
benchmark suite we collected synthesis tasks from three different application domains i knowledge discovery ii program analysis and iii relationalqueries.table 1presentsusefulcharacteristicsofthesebenchmarks.thelastthreecolumnsshowthenumberofinput output relations the number of rules of the smallest desired program and whether the desiredprogram isrecursive ornot respectively.
knowledge discovery.
the knowledge discovery benchmarks comprise8tasksofsynthesizingdatalogprogramsfrequentlyused in the artificial intelligence and database literature.
the goal of the first benchmark inflammation is to discover interesting correlations between patient risk factors and a disease called acute inflammationsofurinarybladder.weusedadatasetcreatedbya medical expert to enable expert systems that perform presumptive diagnosisofthedisease .6thenextfourbenchmarks abduce ancestor animals andbuildwall are widely used in the field ofinductivelogicprogramming .thesamegenbenchmark is a standard datalog program in the database literature .
the pathbenchmarkistheproblemdescribedinexample .3andthe sccbenchmark is the problem of computing strongly connected componentsinadirectedgraph.
programanalysis.
theprogramanalysisbenchmarkscomprise tasksofsynthesizing staticanalyzers written indatalog polysite isapolymorphic call siteinference analysisfor java downcast isadowncast safetychecker for java rv check is the static api misuse detector described in example2.
which is motivated from a return value checker used in a toolcalled apisan .apisanidentifies apimisusesbydetecting inconsistent uses of the return values of apifunctions.
however the tool is neither sound nor complete due to the limitation of its statistical method.
this observation motivated our rule based approach for staticapi misuse detection.
andersen isaclassic pointer analysisfor c the next five benchmarks are pointer analyses for java with variouscontextabstractions .
modrefisamod refanalysisforjavaand escapeisanescapeanalysisforjava.bothbenchmarksoriginatedfromaprogramming assignment inan onlinecourse onprogram analysis .
5ourartifact isavailable ongithub .
6available at .
521esec fse november4 lake buena vista fl usa x. si w.lee r. zhang a.albarghouthi p.koutris andm.
naik table benchmarkcharacteristics.
benchmark briefdescription relations rulesrecursive?
knowledgediscovery inflammation diagnosis of bladderinflammation abduce grandparentof given father mother animals distinguishingclassesof animals ancestor ancestor in a family tree buildwall learn a stablewall strategy samegen same generationin a family tree path all pairsreachability in directed graph scc computesccs in directed graph programanalysis polysite polymorphiccall siteinferencefor java downcast downcast safetychecker for java rv check return value checker in apisan andersen inclusion based pointer analysis for c call site call sitepointer analysis for java call site call sitepointer analysis for java object object sensitivepointer analysis type type sensitivepointer analysis obj type type object sensitiveanalysis escape escapeanalysis for java modref mod ref analysis for java relational queries sql 1515sql queries relational queries.
these benchmarks comprise synthesis tasksfromstackoverflowpostsandtextbookexamples .we chosethe15tasksofsynthesizing sqlqueriesthatcanbeexpressed in datalog.
each task involves up to input tables and one output table.the desireddatalogprograms compriseupto fourrules.
.
experimentalsetup meta rules.
wefirstapplyonlythefollowingthreechainmetaruleswithupto 5augmentations for allbenchmarks r0 v1 v2 r1 v1 v2 .
r0 v1 v3 r1 v1 v2 r2 v2 v3 .
r0 v1 v4 r1 v1 v2 r2 v2 v3 r3 v3 v4 .
we observe that alpsfails to synthesize five context sensitive pointeranalysisbenchmarks asthenecessaryaugmentationdistance is too far and offers no filtering of the search space.
in these cases wealsoincludedomainspecificmeta rules e.g.meta rulesextracted the remaining four benchmarks.
also we set the maximum number ofinventedpredicates to .
input output relations.
foreachbenchmark alpsbeginswith no examplesof output relations and iteratively poses membership queries about the contents of the output relations.
to answer such queries we used the known solution of the benchmark i.e.
the desired datalog program as an oracle.
the populated input relations range insize from 3to withan averageof22.
.
evaluationresults q1 numberofqueriesandsynthesistime.
table2presentsthe mainresultsofourevaluation.consider forinstance the ancestor benchmark.
alpsmakes11queriestotheoracle outofamaximum of450queries whichisthesizeoftheherbrandbase ittakes25seconds to synthesize programs and in the process it evaluates 280programs outof 1010programs inthe search space.
overall our results demonstrate the small number of queries needed to discover non trivial programs.
for most benchmarks alpsrequires less than queries for our largest benchmark modref alpsmakes22queriestotheoracleinordertosynthesize10 rules.itsynthesizesmostprogramswithinafewminutes.incertain examples like modref a large number of programs are evaluated thus requiring more synthesis time.
q2 effectivenessofmeta ruleaugmentations.
figure3shows thefrequencydistributionofbenchmarksaccordingtotheiraugmentation distance with respect to chain meta rules.
only two benchmarks can be synthesized with no augmentation while most benchmarks 29outof34 canbesynthesizedwithnomorethan 5augmentations.thisindicatesthatsimplechainmeta rulesare quitelimitedbythemselves butwecanhandlealargenumberof benchmarks byslightly mutatingthem.
starting with only chain meta rules however alpsfails to scale on five context sensitive pointer analysis benchmarks whose augmentationdistanceis6orlarger.weobservethatalthoughthese five benchmarks are different from each other their rules are quite similar.table 3showstheaugmentationdistancesforeachofthese fivebenchmarkswithrespecttotwosetsofmeta rules chainmetarulesandmeta rulesminedfromtheotherfourbenchmarks.the augmentation distance implies that in comparison with general chain meta rules meta rules mined from the same domain are more useful to guide the synthesis search process.
indeed with extra meta rules mined from the other four benchmarks alpsis abletosynthesizefourofthefivecontext sensitivepointeranalysis benchmarks as shownintable .
q3 quality of qbc.we now investigate the quality of qbc s selectionstrategy.todoso weinstrument alpstorandomlypick an example that the committee disagrees on instead of one that maximizes vote entropy.
for each benchmark8 we ran trials with random example selection.
figure 2a shows a box plot of the number of queries made in these trials.
we see that random selection onaverage performsmuchworsethan qbc.forinstance on theancestor benchmark the median for random selection is more than120queries while qbconly needs11.
comparedtothebest casescenariosofrandomselection qbc makes roughly the same amount about queries of queries for mostbenchmarks.forthe andersen benchmark onerandomtrial behavessurprisinglywell itonlyrequires8questionstosynthesize all expected rules one of which eliminates .
of the committee members.
this is an artifact of qbc sconservative exampleselectionapproach itprefershigh entropyexamples soitmaymiss alow entropyexamplethatcouldeliminatemostofthecommittee indicating qbcisnot optimal but practically effective.
q4 sensitivity to the size of input data.
we now investigate the effects of increasing the size of input data on the number of queries needed.
we focus on the andersen benchmark as it is demonstrativeofthebehavioracrossourbenchmarksuite.recall obj type takesalps17hours to finish and hence is marked as timeout.
8we skip the sql benchmarks as alpsasks a very small number of queries for them.
522syntax guidedsynthesis ofdatalogprograms esec fse november4 lake buena vista fl usa table alpsperformanceresults the timeoutlimit is3 hours .
queriesasked metagol run.
time sec.
byalps possible queries synthesized programs evaluated programssearch spacetotal time sec.
alpssetting idealsettingzaatar run.
time sec.
inflammation .
.
.
timeout abduce .
timeout .
timeout animals .
.
.
timeout ancestor .
timeout .
timeout buildwall .
timeout .
timeout samegen .
timeout timeout .
path .
timeout .
.
scc .
timeout timeout timeout polysite .
timeout .
timeout downcast .
timeout .
timeout rv check .
timeout timeout timeout andersen .
timeout timeout .
call site .
timeout timeout timeout call site .
timeout timeout timeout object .
timeout timeout timeout type .
timeout timeout timeout obj type 1051timeout timeout timeout timeout escape .
timeout timeout timeout modref timeout timeout timeout sql .
.
.
.
sql .
.
.
timeout sql .
.
.
timeout sql .
.
.
timeout sql .
.
.
timeout sql .
.
.
timeout sql .
.
.
timeout sql .
.
.
timeout sql .
timeout .
sql .
timeout .
timeout sql .
timeout .
sql .
timeout timeout sql .
timeout timeout timeout sql .
timeout timeout timeout sql .
timeout timeout timeout a b figure a box plot of the number of queries asked by random selection green dots mark the number of queries by qbc and b numberofqueriesasked by alpsfortheandersen benchmarkunder differentsizesofinput data where x .
thatandersen is a pointer analysis for c programs.
we systematically increased the size of the input data i.e.
the size of the analyzed program and measured the numberof queries needed to synthesizeandersen sanalysis aswellasthesynthesistime.figure 2b summarizes theresultsofthisexperiment.itshowsthatas the size of the data increases the number of questions asked stays roughlyconstant.asaresult thequestionratio numberofquestions asked to the total number of possible questions is reducedsignificantly from nearly to .
.
the number of evaluated programsalsoremainsroughlyconstant.asexpected thesynthesis timeincreaseswithmoredata as alpsneedstoinvokethedatalog solver onlarger inputs.
q5 comparisonwith other tools.
we now compare alpswith two state of the art ilp tools metagol and zaatar .
we 523esec fse november4 lake buena vista fl usa x. si w.lee r. zhang a.albarghouthi p.koutris andm.
naik table augmentation distances of context sensitive pointer analysis benchmarks with respect to chain metarulesandmeta rules mined fromthesamedomain.
call site call site object type obj type chain same domain supply both of these tools with all ground facts upfront since they are non interactive.
metagol is an ilptool that is an instance of the meta interpretive learningframework whichisalsoparameterizedbymeta rules.
we run metagol with two settings the alpssetting which uses thesamesetofmeta rulesthat alpsusesafteritperformsaugmentation andtheidealsetting whichconsistsoftheminimalsetof meta rules that are sufficient for synthesizing a correct program.
usingalps s setting metagol cannot finish most knowledge discoverybenchmarksandallprogramanalysisbenchmarks.using the ideal setting metagol still fails on two knowledge discovery benchmarksandmostofprogramanalysisbenchmarks.metagol also fails on four of the sqlbenchmarks despite their lack of recursion.itisimportanttonotethatmetagolemploysmeta interpretive learning whichisnotacompletetechnique soitisnotguaranteed to terminate despitefiniteness ofthe searchspace.
zaatar is a constraint based datalog program synthesis tool.
itfailsonmostofourbenchmarksbecauseitisverysensitivetothe sizeoftheinputdata sincethesizeoftheencodingispolynomial in the input data.
in contrast alpshas much better scalability in termsofinputsize as alpsonlyevaluatescandidateprograms on inputdata instead ofencoding the inputas symbolic constraints.
summary.
to summarize our experimental evaluation demonstrates i theabilityof alpstosynthesizesophisticatedalgorithms ii the effectiveness of meta rules and augmentations iii the importance of qbcat reducing the number of queries and iv the robustnessofour synthesis approach to inputsize.
.
threatsto validity thereareseveralthreatstothevalidityofourapproach.weoutline thesenextalongwithproposalsto mitigate them.
alpsmayfailtosynthesizeadesirableprogrambecausetheinput relationsdonotcoverallcornercases i.e.
overfitting .wecan mitigate this threat by allowing the user to provide a large input andtakingadvantageof alps sabilitytohandlesizeableinput data as shown in figure 2b .
in practice large input relations often cover the vastmajority ofcorner cases.
the labeled examples may be noisy.
this threat can be mitigated bycollectinganswersfrommultipleoracles e.g.
throughcrowdsourcingormultiplereferenceimplementations andusingthe majority voteas the final answer.
alargenumberofequivalentfinalprogramsexistduetomanyapplicablecombinationsofmeta rules.thisthreatcanbemitigated bysacrificingcompletenessandreportingasubsetofprograms.
the meta rules generated by alpsmay be insufficient to capture adesiredprogram.thisthreatcanbemitigatedbyusingalarger numberofinventedpredicates.themoresuchpredicatesweuse thesimplerrulesweobtain.eventually thedesiredprogramwill comprisetypicalrules thus enabling alpsto synthesize it.
figure augmentation distance distribution.
related work inductive logic programming.
while we use key ideas from inductive logic programming ilp inalps a number of properties distinguish our approach from existing ilpapproaches.
first work inilpusuallylearnrelations oftenprobabilisticones fromvast amounts of mined data e.g.
biological data .
in our work and inalargeclassofsynthesistechniques thegoalisto interactively inferaprogramfroma small representativesetofexamples .second mostilpsystems are not adeptat learning recursive rules.in contrast we specifically aim to infer recursive rules.
third ilpis often interested in programs that correctly classify mostexamples.
in contrast we are interested in programs that correctly characterize allpositive and negative examples.
fourth many ilpsystems requireacomplicatedinteractionmodel forexample f ilp poses existential queries and cigol poses generalization queries .
in contrast alpshas a simple interaction model that only poses membership queries.
lastly we employ a completesearch strategy whereasilpsystems can fail to find a program even if one exists that isconsistent withthe given examples.
more recently ilphas been applied to end user programming andonlinetutoring .meta interpretivelearninghasbeenused to learn prolog programs for string manipulation tasks .
these applications share similar goals as ours of learning programs by obtaining examples from users.
we focus on datalog programs whereas they learn programs in other domains e.g.
string manipulationortabletransformation.also whentheirgeneratedprogram isincorrect theuserisexpectedtoprovideacounterexample.in contrast our approach automatically identifies the most controversial example to pose to the user.
template guided synthesis.
templates are commonly used to guide the search in program synthesis .
at a highlevel meta rules can also be seen as program sketches where the holes are the relation symbols.
interactive synthesis by example.
some of the programmingby example pbe approachesinteractivelyqueryanoracle forexamples.jhaetal.
presentanoracle guidedsynthesisprocedure for straight lines programs encodable in smt.
they require the oracle usuallyareferenceimplementation toprovidetheoutputwhen givensomeinput.anotherrecentinteractivesynthesis approachis applied in the contextof parsersynthesis tolearn agrammar.
synthesis ofrecursive programs.
a number of works have targetedtheproblemofsynthesizingrecursiveprograms 524syntax guidedsynthesis ofdatalogprograms esec fse november4 lake buena vista fl usa .mostoftheseworksfocusonrecursivefunctionalprograms that manipulate recursive data structures.
datalog programs recursively traverse relations hypergraphs .
to our knowledge none of the functional techniques have been appliedto this domain.
version space algebras.
version space algebras were used for synthesis initially by lau et al.
and more recently in flashfill for spreadsheet manipulation.
alpsmaintains a version space using most general and most specificprograms as first proposedbymitchell .oursettingisdifferentthanmitchell sin thesensethatthesearchspaceisdeterminedbyasetofmeta rules thatformsapartiallyorderedset andtherebywecanexploitthe generalityorder onthe meta rulesfor our bidirectionalsearch.
learning forprogram analysis.
recently several systems have beencreatedthatapplymachinelearningtechniquestoprogram analysis.
oh et al .
use bayesian optimization techniques to effectively learn adaptation strategies for parametric program analysis while bielik et al .
apply the id3 algorithm to learn a decision tree that represents points to and allocationsitefactsfor individualjavascriptfunctions.thisworkeitherlearnsanefficient configurationforprogramanalysisoranaccuraterepresentation for the results of an analysis.
in contrast our work can learn the rulesofthe program analysis expressedindatalog.
conclusionsand futurework we proposed a programming by example system alps to synthesize datalog programs.
it employs a syntax guided synthesis approachthatprunesthesearchspacebyexploitingtheobservation that datalog programs in practice comprise rules with similar latent syntactic structure.
to this end we synergistically combined threetechniques anovelapproachtosystematicallygeneratemetarules takingadvantageofdomainknowledge anactivelearning techniquecalledquery by committeetominimizethenumberof examples needed and a bidirectional synthesis strategy to explore thesearchspaceefficiently.weevaluatedthesystemonavariety of synthesis tasks from different domains and demonstrated that it significantly outperforms existing state of the arttools.
we envision many useful directions to extend our work.
one directionconcernsrepairingexistingdatalogprogramsusingexamples rather than synthesizing them from scratch.
for instance a user may modify an existing program analysis by refining its rules tobeconsistentwithknowntrueandfalsepositives.anotherdirection concerns using probabilistic models to expedite the search for instance by predicting which augmentations to use.
finally weplantoexplorehowtosynthesizeprogramsthatarenotonly correctwithrespectto examples but alsooptimalwithrespectto objectives such as likelihoodorevaluation complexity.
a proofof alpsproperties toprovetheorem .
weusetwokeypropertiesabouttheinterplaybetween qbcandbidirectionalsearch.thefollowinglemma capturesthefactthatthealgorithmdoesnotmissanycontroversial examples and thus always makes progress in terms of pruning the searchspace.
lemma a. .
letp hande b. thend e p nequal0iff there exist programs p1 p2 psuchthat p1 i eandp2 i e.proof.thisisdirectlyimpliedbythedefinitionofvoteentropy see definition .
.
thenextlemmastateskeyinvariantsthatholdateveryiteration ofthealgorithm i itdoesnotmissanyprogramsthataresolutions to the synthesis problems by ensuring that the contours of the version spaceform anupper lower boundof every solution.
ii it ensures that if the current version space contains non solutions then there are non zero entropy examples we can ask the oracle that can eliminatethem.
lemmaa.
invariant .
lets h o i beasynthesisproblem such that a solution to sexists inh.
lete e e be the set of known examples at any point during execution and p p p. then foreverysolution p htos thereexistprograms pl pu p suchthat pl p pu.
if there exists a program p pthat is not a solution to s then e b.d e p nequal0.
proof.wefirstshowitem .first noticethateverysolution p htosbelongs inthe version space ve since it satisfies all current examples.
since p max ve by the definition of f in algo.
there exists pu psuch that p pu.
similarly since p min ve there exists pl psuch that pl p .
we next showitem .
supposethat p pis nota solution to s andletp beasolutionto s.then thereexistsanexample e b suchthateither a p i eandp i e or b p i eand p i e.we nowdistinguishtwodifferentcases case a holds since p isasolution item tellsusthatthere existspu psuchthat p pu.thisimpliesthat pu i e. becausenow p pudisagreeonexample e lemmaa.1implies thatd e p nequal0.
case b holds since p is a solution item tells us that there exists pl psuch that pl p .this impliesthat pl i e. because now p pldisagree on example e lemmaa.
implies that d e p nequal0.
thus inbothcaseswefindanexample esuchthat d e p nequal0.
wearereadytoprovetheorem .2usingthelemmas a.1anda.
.
proof.thealgorithmterminateswhenforeveryexample e b we haved e p .
recall that p p p wheree e e are the knownexamples.
soundness as e b.d e p the contrapositive of item oflemma a.2indicatesthatevery p pisasolution.
completeness thisholdsdirectlyfromitem oflemma a. .
termination at every iteration the algorithm adds one exampletoeither e ore .noticethat afteranexample e is added to e e e it cannot be added again since it willneverbecontroversial d e p nequal0 fromthatpointon.
sincewehavefinitelymanyexamplesin b thealgorithm terminatesafter finitelymanysteps.
this concludes the proofof the theorem.