verifying arithmetic in cryptographic c programs jiaxiang liu xiaomu shi ming hsien tsai bow yaw wang and bo yin yang college of computer science and software engineering shenzhen university institute of information science academia sinica jiaxiang0924 xshi0811 mhtsai208 gmail.com bywang byyang iis.sinica.edu.tw abstract cryptographic primitives are ubiquitous for modern security.
the correctness of their implementations is crucial to resist malicious attacks.
typical arithmetic computation of these c programs contains large numbers of non linear operations hence is challenging existing automatic c verification tools.
we present an automated approach to verify cryptographic c programs.
our approach successfully verifies c implementations of various arithmetic operations used in nist p p p and curve25519 in openssl.
during verification we expose a bug and a few anomalies that have been existing for a long time.
they have been reported to and confirmed by the openssl community.
our results establish the functional correctness of these c implementations for the first time.
keywords program verification cryptographic programs functional correctness openssl i. i ntroduction cryptographic primitives are the foundation of modern computer security.
they are invoked for authentication encryption and key exchange protocols among others.
unlike normal programs typical cryptographic or security settings always assume an adversary who would take advantage of any mistakes and run out of his ways to induce errors so as to launch attacks.
as illustrated in even a tiny bug can have catastrophic impacts.
consequently the correctness of cryptographic primitives is of the utmost importance.
cryptography programming however is far from easy.
modern cryptography relies on complicated mathematical constructions.
consider for instance elliptic curve cryptography ecc .
such cryptosystems are based on arithmetic over large finite fields.
take the elliptic curve curve25519 used in openssh as an example.
it is defined over finite field z2255 .
each field element hence belongs to the integer set ... sums and products of two field elements are computed by addition and multiplication modulo 19respectively.
a point on curve25519 is a pair of field elements x y satisfying the curve equation y2 x3 x2 x or the symbolic point at infinity .
an operation on points called point addition can then be defined on top of those field operations.
with point addition a group is defined over points on curve25519.
point multiplication further takes hundreds of point addition operations.
and it is required by the public key primitives corresponding authorover curve25519 such as those in the default key exchange protocol in openssh.
reality is even more complicated than mathematics.
observe that a field element in z2255 19can be represented by a bit number.
yet there are no computers with 255bit architectures available.
in practice a field element is represented by four or five bit numbers in bit architectures.
arithmetic over the finite field has to be implemented on such representations.
in such implementations field multiplication requires several bit multiplication and addition instructions.
carries must be propagated.
modular computation must be performed.
cryptography programming can be very challenging even for experienced programmers.
curve25519 is but one elliptic curve in ecc.
in the widely used security library openssl cryptographic primitives based on four different curves over different finite fields are provided.
in addition to curve25519 three nistrecommended curves p p and p are used.
each curve is defined over its special finite field.
each finite field has its dedicated c functions for field arithmetic.
one wonders if there might be errors in these building blocks of computer security.
indeed the openssl source code can only be modified by a chosen group of developers for security purposes .
restricting code commits can reduce the probability but not remove the possibility of bugs in the library.
concern about correctness of cryptographic c programs in openssl thus has some justification.
program verification is an active research field with numerous promising ideas.
one naturally hopes that all such programs could be formally verified.
y et existing techniques do not appear to be able to verify cryptographic c programs.
motivating example.
montgomery reduction is a widely used algorithm in cryptography programming.
let b .
given integer inputs n n primeandtwithnn prime modb montgomery reduction is an efficient way to calculate tb 1modnwithout long division.
fig.
shows a simplified montgomery reduction algorithm.
observe that division and modulo by bare bit shifting and masking operations respectively for bis a power of .
the algorithm thus computes tb 1modnwith addition multiplication bit shifting and masking operations.
long division by n is indeed not needed.
a reference c implementation is as follows where n 231is assumed for simplicity.
34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pre condition n b withn m o d2 n prime b withnn prime m o db and t b n post condition redc n n prime t b t modn function redc n n prime t m tmodb n prime m o db t t mn b returnt figure .
montgomery reduction table i verifying function redc with selected tools configuration output cpa s eq sv comp2019 version1 default heap 10000m timeout svcomp19 heap 10000m timeout pesc o sv comp2019 version svcomp19 pesco heap 10000m stack 2048k timeout svcomp19 pesco linear heap 10000mtimeout stack 2048k ua utomizer sv comp2019 version architecture 64bit timeout smack version .
.
verifier boogie false bit precise verifier boogie timeout verifier corral timeout bit precise verifier corral timeout verifier symbooglix false bit precise verifier symbooglix unknown2 verifier duality timeout bit precise verifier duality timeout 1typedef uint64 t u64 define b u64 3u64 redc u64 n u64 np u64 t const u64 btm32bits 0xffffffff u64 m t btm32bits np btm32bits u64 t t m n return t the inputs n npandtare64 bit integers.
given n and pre conditions in fig.
we would like to verify whether redc n np t b t mod n .
we have tried automatic c verification tools including cpa s eq p esc o ua utomizer and smack on a linux machine with core .60ghz cpus and 16gb ram.
no tool can verify the line c program in 15minutes table i .
two false s are reported but the counterexamples turn out to be spurious.
real cryptographic c programs in openssl implement operations on field elements with hundreds of bits.
using existing verification tools it is very unlikely to verify these programs within a reasonable time limit.
1the sv comp2019 versions of cpa s eq p esc oand ua utomizer are downloadable at 2due to a bug of the tool see the issue at smack issues smack did claim that redc was verified.
the real output is unknown.in order to verify cryptographic c programs new techniques are needed.
in the modeling language c ryp toline and its tool for verifying cryptographic assembly programs are proposed.
we leverage the work by translating ll vm ir programs to c rypto line and use its tool to verify cryptographic c programs.
more specifically the following steps are needed to verify cryptographic c programs submit a cryptographic c program to clang and generate a program in llvm ir.
use our translator to convert the llvm ir program to a c rypto line program.
specify properties about the c program in the generated crypto line program.
v erify whether the c rypto line program conforms to the specification with the c rypto line verification tool.
using our translator the line reference c implementation for montgomery reduction is verified within 10seconds.
we then apply our approach to the cryptographic c programs for arithmetic operations over the four elliptic curves nist p nist p nist p and curve25519 in openssl.
cryptographic c functions in openssl are verified.
the largest function x25519 scalar mult has ll vm ir instructions and is verified within minutes on a dedicated linux server.
the function implements the critical step in the group operation on curve25519.
it takes bit field elements as inputs and returns bit field elements as outputs.
its specification consists of three nonlinear multivariate polynomial modulo equations over bit variables.
we are not aware of any other similar technique at such a scale.
we would like to point out a bug found during verification.
in the function felem diff 128 64 for the nist p521 curve our approach exposes an overflow error in the implementation.
we have reported our findings to the openssl developer community.
the community confirmed the bug and released a fix3.
to the credits of the community we only found one bug and minor anomalies in c functions out of .
yet programming errors did occur in this widely used and inspected security library.
one can never be too careful about security libraries.
our contributions.
we identify a useful subset of llvm ir called llvm crypto to model intermediate representations of cryptographic programs emitted from clang.
ll vm crypto contains the most common instructions used in implementations of arithmetic operations.
these instructions however form the core of many public key cryptographic programs.
using ll vm crypto a number of cryptographic programs are modeled.
given an ll vm crypto program we develop a translator to translate it into a c rypto line program.
c rypto line is 13fbce17fc9f02e2401fc3868f3f8e02d6647e5f authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
designed for cryptographic assembly programs not ll vm ir.
in particular c rypto line does not allow pointer arithmetic found in llvm crypto .
such llvm crypto features are translated to c rypto line automatically.
a soundness theorem is established for our translator.
it guarantees that no bug will be missed if a program is verified by our approach.
our case studies include c functions from nist p p p and curve25519 in openssl.
to the best of our knowledge this is the first automated approach which can verify the correctness of these cryptographic c programs.
we also expose a bug and two incorrect input assumptions in the nist p implementations.
in the rest of the paper after introducing llvm crypto in section ii we review c rypto line in section iii.
the translation is addressed in section iv while case studies are detailed in section v. conclusion comes in section vii.
ii.
ll vm crypto as ubset of llvm ir llvm is an open source project for modular compilation and related technologies.
it is based on a code representation called llvm ir for llvm intermediate representation .
v ery roughly any c program is represented in llvm ir for code transformations and optimizations.
for cryptographic c programs the full llvm ir is not necessary.
we examine the intermediate representations generated after architecturally independent optimizations in clang and identify a useful subset of llvm ir for cryptographic c programs called llvm crypto .
in this section we present llvm crypto and give its formal semantics.
a. notations letn n andzdenote the set of non negative positive and all integers respectively.
we use to denote the set ... n forn n .a bandamodbdenote the quotient and non negative remainder of adivided by b. that is we have a b a b amodb with amodb b. letf a bbe a function.
for a aandb b define the function f a bby f x braceleftbigg b ifx a f x otherwise .
b. syntax llvm ir is a strongly typed language.
in addition to variables and constants it supports pointers and vectors.
in cryptographic c programs arithmetic computation bitwise masking and shifting are widely used.
we consider the subset llvm crypto that is useful to the compilation of these programs.
the syntax of llvm crypto is shown in fig.
.
we usex y z ... for variables and p q ... for pointers.
an argument arg can be a variable or a number.
let lscript n .
an argument for a vector of size lscript argv lscript can be a vector variable or a sequence of lscriptnumbers.
in ll vm crypto operands and the result of each instruction can be o rnum var x y z ptr p q width arg var num argv lscript var num lscript inst var add width arg arg var addv lscriptxwidth argv lscript argv lscript var sub width arg arg var subv lscriptxwidth argv lscript argv lscript var mul width arg arg var mulv lscriptxwidth argv lscript argv lscript var shl width arg num var lshr width arg num var and width arg arg var load width ptr var loadv lscriptxwidth ptr store width arg ptr storev lscriptxwidth argv lscript ptr ptr geteltptr width ptr num ptr geteltptrv lscriptxwidth ptr num num var trunc arg var zext arg var insertelt lscriptxwidth argv lscript arg num prog inst inst prog figure .
the syntax of llvm crypto bit values specified by the instruction syntactically.
for instance the instruction y add 64a1a2adds the bit operands a1 a2together and assigns the sum to the bit variabley.
on the other hand y add 128a1a2has128 bit operands and result.
letw .y addv lscriptxw a1a2computes the element wise sum of the vectors a1anda2 and assigns the result to the vector variable ywhose lscriptelements are of bit width w. the instructions sub andmul as well as their vector versions subv andmulv work similarly.
two bitwise shifting instructions are defined in llvm crypto .y shlwan shifts the w bit operand ato the left byn w bits and stores the result as a w bit value in y. instruction lshr on the other hand shifts to the right.
the bitwise and instruction is y andwa 1a2.
the instruction y load wp loads the w bit value from pointer p. to load a vector of w bit values y loadv lscriptxw pis used.
the instructions store and storev store values into the memory.
one can obtain the pointer to an element of a vector stored in memory.
q geteltptr wpn makesqpoint to then thw bit element of the vector designated by p.i f ppoints to a vector whose elements are vectors of size lscript q geteltptrv lscriptxw pn1n2setsqto the pointer at then2 th element of the n1 th vector designated by p. the instruction y trunc atruncates the bit value a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to the low 64bits and stores the result in the bit variable y.y zextaextends the bit operand ato128 bits.
finally the instruction y insertelt lscriptxw a1a2k assigns to ythe lscript long vector identical to a1except that its k th element is a2wherek lscript .a n ll vm crypto program is simply a sequence of instructions separated by semicolons.
there are no control flow instructions like branching in llvm crypto .
those are avoided in typical cryptographic programs for side channel attack prevention.
example.
the file ecp nistp521.c in openssl implements the nist p elliptic curve over the prime p521 .
in this implementation a field element ais represented as a0 a1 a2 a8 8using nine bit limbsai s. the following llvm crypto fragment is extracted from the llvm ir code of the c function felem diff64 .
it subtracts a field element yrepresented by y0 ... y 8from the field element xrepresented by x0 ... x .
the result is then stored in the memory designated by pout.
v0 sub y0 v prime add 64v0x0 q0 geteltptr 64pout0 store 64v prime 0q0 the fragment only shows the operations on the least significant limb.
y0is subtracted from a constant at line .
the result is added to x0at line .
line computes q0pointing to the th64 bit element of the memory designated by pout.
the calculation result v prime 0is stored to the memory cell pointed byq0at line .
an ll vm crypto program is in ssa form static single assignment if its variables and pointers are defined at most once.
any llvm ir program generated from clang is in ssa form.
c. semantics similar to its syntax the semantics of llvm crypto is designed for cryptographic c programs.
observe that field elements in openssl are represented by unsigned integers.
our semantics is hence defined over unsigned numbers.
we moreover assume the underlying architecture is bit for simplicity.
each memory cell represents a value in .i t is straightforward to modify the semantics of ll vm crypto for32 bit architectures.
we give a small step semantics for llvm crypto .
let v defines var ptr nbe a valuation andm m defines n amemory state .s definesv m is the set of states .
a valuation formalizes the values of variables and pointers.
the content of memory cells is modeled by a memory state.
our semantics specifies how a state transits to another by executing each instruction.
fig.
gives the semantics of llvm crypto .given v we define the semantic function llbracket rrbracket for numbers variables and pointers as follows.
llbracketa rrbracket braceleftbigga ifa num a ifa var ptr from the state m the instruction y addwa 1a2 moves to the state prime m where primeupdates the value of y to llbracketa1 rrbracket llbracketa2 rrbracket m o d2w.
the sum is truncated to wbits by modulo 2w.
other variables in remain unchanged in prime.
more notations are needed for vectors.
for lscript n and v num lscript v denotes the i th element of vwheni .
we also use the variable x for thei th element of the vector variable x var .
given a valuation andn n the notation n i 0is short for .
the semantics of y addv lscriptxw a1a2should now be clear.
it updates the vector variable ywith the element wise sum of vectors a1 a2 and each element sum is truncated to a w bit value.
the semantics for subtraction and multiplication is similar and omitted from fig.
for clarity.
the semantics for bitwise instructions shl lshr andand is obvious.
in our memory model addresses are natural numbers and memory cells are elements in because we assume a bit architecture.
let m m be a memory state and n v n we use the following notations for convenience m64 n definesm n m64 definesm m64 n reads the memory cell located at the address n m64 updates the cell located at nwith the value v. inll vm crypto we also need to interpret two consecutive memory cells as a bit value.
we choose the little endian representation in our semantics.
define m128 n definesm n m n m128 definesm wherevl vmod 264andvh v m o d264.
hence m128 n reads a bit value from the memory cells located atn m128 updates the memory cells located at n with the bit value v. the semantics of y loadwp can now be explained.
it updatesyby thew bit value in the memory cell designated byp.
to load a vector of values define size w definesw for the number of memory cells needed for w bit values.
by y loadv lscriptxw p the vector variable yis updated with lscriptw bit values from the memory cells designated by p. the instructions store andstorev are defined similarly ifppoints to a vector of w bit values in memory the n th element is located at llbracketp rrbracket llbracketn rrbracket size w .
this is exactly what q geteltptr wpn computes.
geteltptrv is defined similarly when ppoints to a vector of vectors.
the semantics of instructions trunc andzext is straightforward.
finally y insertelt lscriptxw a1a2kcopies authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
m y addwa 1a2 prime m where prime y llbracketa1 rrbracket llbracketa2 rrbracket m o d2w m y addv lscriptxw a1a2 prime m where prime llbracketa1 rrbracket llbracketa2 rrbracket m o d2w lscript i m y shlwan prime m where prime y llbracketa rrbracket llbracketn rrbracket m o d2w m y lshr wan prime m where prime m y andwa 1a2 prime m where prime y llbracketa1 rrbracket band llbracketa2 rrbracket m y load wp prime m where prime m y loadv lscriptxw p prime m where prime mw llbracketp rrbracket i size w lscript i m storewap m prime wherem prime mw m storev lscriptxw ap m prime wherem prime mw rrbracket lscript i m q geteltptr wpn prime m where prime q llbracketp rrbracket llbracketn rrbracket size w m q geteltptrv lscriptxw pn 1n2 prime m where prime q llbracketp rrbracket llbracketn1 rrbracket lscript size w llbracketn2 rrbracket size w m y trunc a prime m where prime m y zext a prime m where prime m y insertelt lscriptxw a1a2k prime m where prime llbracketa1 rrbracket mod 2w lscript i llbracketa2 rrbracket mod 2w figure .
semantics of llvm crypto the vector a1of lscriptw bit values to yand then updates the k th element of ywith thew bit value a2.
iii.
d omain specific language crypto line crypto line is a domain specific language for cryptographic assembly programs and their verification.
it is equipped with an automatic verification tool.
we briefly review the language and its verification in this section.
a. the language crypto line serves as an abstraction for cryptographic assembly programs across different architectures.
details such as registers and address modes are ignored in the language.
for simplicity it only considers variables numbers and flags.
typical arithmetic assembly instructions are modeled in c rypto line.
fig.
gives the syntax of the language.
the semantics of c rypto line is parameterized by the bit width of the underlying architecture.
to be consistent with ll vm crypto the semantics of c rypto line is explained here for bit architectures.
all arguments arg are hence assumed bit.
the formal semantics can be found in .
ac rypto line state models the current values of variables and flags clflag .set is the assignment statement and cset is the conditional assignment.
carry and borrow flags are explicit in c rypto line.addbxuv sets the sum of uandv toxwith carry in b.adc is the addition with carry statement.
sub and sbb are subtraction and subtraction with borrow statements respectively.
full multiplication mulfxyuv updatesxandywith the high and low bits of the product ofuandv respectively.
and is the bitwise and statement.
shlxun shifts the value of uto the left by nbits and assigns the result to xif the high nbits ofuare all zero otherwise the c rypto line program goes into the error state .clflag b c d clexp arg clexp clexp clexp clexp clexp clexp clpred clexp clexp clexp clexp mod clexp clexp clexp clexp clexp clpred clpred clstmt set va r a rg cset v ar clflag arg arg add clflag v ar arg arg adc clflag v ar arg arg clflag sub clflag v ar arg arg sbb clflag v ar arg arg clflag mulf v ar v ar arg arg and v ar arg arg shl v ar arg num split v ar v ar arg num assert clpred assume clpred clprog epsilon1 clstmt clprog figure .
c rypto line statements and programs split is provided to model common patterns of assembly code in cryptographic programs.
the statement splitxyun splits the value of uinto two parts the low nbits are moved toyand the remaining high bits are moved to x. for verification purposes c rypto line supports assertions and assumptions.
predicates clpred e1 e2and e1 e2mode3are algebraic properties.
e1 e 2and e1 e2are range properties.
assert pred checks if the predicate pred holds in the current state.
if so the execution continues with the same state.
otherwise it enters the error state.
assume pred on the other hand assumes pred holds at the current program location thus the execution continues with states satisfying pred .
no predicate is satisfied in the error state.
a common usage for assertions and assumptions is to add external information for verification.
let us assume authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
say answer at some program location but this predicate is obscure.
in c rypto line a human verifier can assert the predicate and then assume it to pass the predicate to the verification tool.
the assertion ensures the predicate indeed holds at the location the assumption then adds the predicate as a lemma for verification.
ac rypto line program is simply a sequence of c ryp toline statements followed by semicolons.
b. v erification with specifications in addition to programs c rypto line allows to specify pre and post conditions using predicates clpred .
pre and post conditions together compose specifications .
given a crypto line program with its specification we would like to know if the program will end in a state satisfying the post condition whenever it starts from a state satisfying the pre condition.
the c rypto line verification tool checks if a c rypto line program conforms to its specification automatically.
example continued .according to the comments of felem diff64 in ecp nistp521.c the pre condition of the program is the range property logicalandtext8 i 0yi .
assume that the nine consecutive memory cells designated by poutare represented by variables addrp0 addrp1 ... addrp8 explained later .
the post condition of the c rypto line program generated from felem diff64 is addrp0 x addrp8 x radix x0 x1 ... x radix y0 y1 ... y radix addrp0 ... addrp8 modp521 whereradix a0 a1 ... a a0 a1 a2 a8 8denotes the field element represented byai s. the first part of the post condition is a range property.
the second part is an algebraic property stating that the result element is a difference between the inputs over the prime p521.
iv .
t ransla ting ll vm crypto to crypto line given an llvm crypto program we first translate it into a c rypto line program in order to verify with the crypto line verification tool.
the soundness property of the translation means that the generated program captures all behaviors of the input one being an over approximation of it.
we introduce the translation and discuss its soundness in this section.
a. symbolic memory addresses in c rypto line and its semantics model there are no pointers or memory.
but it is different in llvm crypto .
both pointers and memory are considered which is closer to reality.
we bridge this gap by representing memory addresses symbolically then using these symbols to translate pointers.assumesvar p q ... is a set of symbolic variables .
a definessvar zis called the set of symbolic memory addresses .
a symbolic address p o arepresents the memory address having an offset ofrom the memory address represented by p a.i n ll vm crypto a pointer is only allowed to be added with a constant offset.
hence we define the addition a a z aas p o1 ao2 defines p o1 o2 where p o1 aando2 z. this is sufficient to model pointer calculations in llvm crypto .
for instance the following two instructions are commonly used for accessing thei th element of the array adesignated by pointer p q geteltptr 64pi y load 64q whereyis the value of a .i fprefers to the memory address np qwill have the value nq np iaccording to the semantics.
if npis symbolically represented by p op our translation algorithm is sufficient to calculate nq s symbolic address as p oq p op ai.
even though symbolic addresses cannot capture complete information about memory addresses they reflect the relationships between the absolute memory addresses.
for example the offset ibetweennpand nqis preserved for their symbolic representations.
we define a pointer table ptas a mapping from pointers ptr to symbolic addresses a. it models the valuation of pointers and helps alias analysis in the translation algorithm.
pt p models the memory address represented by p. b. translation algorithm assume the pointer table ptmodels the valuation of pointers before executing an ll vm crypto instruction s. the function i nst toclprog pt s translates sinto a sequence cpof c rypto line statements.
it returns a pair angbracketleftpt prime cp angbracketright wherept primemodels the valuation of pointers after executing s.pt primereflects the effect on pointers when executing swith respect to the llvm crypto semantics.
we then translate ag i v e n llvm crypto program by sequentially applying inst toclprog to each instruction.
we summarize the translation for bit llvm crypto instructions as in table ii.
the translation of arithmetic instructions is straightforward.
for example the instruction add is translated to the statement add .
note that carries are not present in llvm crypto .
hence the introduced carry flag is discarded using a fresh named.
but the value of ddoes indicate the presence of overflow when executing the add instruction.
since the instruction add does not change pointers ptremains the same after executing add .
the instruction y addv lscriptx64 a1a2 adds two vectors a1anda2of length lscript.
it is equivalent to lscript add instructions on each pair of a1 anda2 .
hence we have it translated to lscriptadd statements.
the translation of bitwise shifting is a little subtle.
the instruction shl has similar semantics as shl except that shl may cause an error that is undesired by shl .
to avoid that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii summary of inst toclprog pt s the bit case instruction s output angbracketleftpt prime cp angbracketright y add 64a1a2 angbracketleftpt adddya 1a2 angbracketright y addv lscriptx64 a1a2 angbracketleftpt sequence of add s angbracketright y shl 64an angbracketleftpt splitzdta n shlytn angbracketright y lshr 64an angbracketleftpt splityzdan angbracketright y and 64a1a2 angbracketleftpt andya1a2 angbracketright y load 64p angbracketleftpt sety llparenthesispt p rrparenthesisv angbracketright y loadv lscriptx64 p angbracketleftpt sequence of set s angbracketright q geteltptr 64pn angbracketleftpt epsilon1 angbracketright y trunc a angbracketleftpt setyal angbracketright y zexta angbracketleftpt setyla setyh0 angbracketright y insertelt lscriptx64 a1a2k angbracketleftpt sequence of set s angbracketright the highnbits ofaare discarded first by split using the fresh variablezd.
then the remaining low nbits stored in the temporary variable tcan be safely shifted to the left by n bits.
similar translation is applied for lshr .
the translation forand is trivial.
to translate an instruction involving memory the memory cell is referred to using a c rypto line variable.
assume that we have a one to one function llparenthesis rrparenthesisv a var .i t converts each symbolic address into a c rypto line variable.
for example llparenthesis p rrparenthesisv addrp1in our implementation.
now the translation for y load 64pis straightforward.
yis assigned with the variable llparenthesispt p rrparenthesisv which represents the value in the memory cell indexed by p. the vector version loadv is translated in the same way as addv .
again load does not change pointers ptremaining unchanged.
the instructions store andstorev are treated similarly omitted in table ii.
when translating q geteltptr 64pn we obtain the symbolic address pt p and add it with offset n size n. then the value of qinptis updated with the result.
no crypto line statement is required since it does not modify variables or memory hence cp epsilon1.
the translation for geteltptrv is similar and hence omitted.
given any bit ll vm crypto variabley t w oc rypto line variables ylandyhare used to represent its low and high 64bits respectively in the translation.
the same applies to any number thus any argument.
then it is straightforward to translate instructions trunc andzext with set statements.
as well set statements are used to translate insertelt by copying each element of a1toywith thek th element y assigned by a2.
for128 bit instructions the idea is the same but more technical.
for instance when translating a bitadd t w o bit add s are required to mimic bit addition.
one bitload needs two set s to copy two consecutive cellsfunction prog toclprog prog construct pt0with prog letprog s1 s2 sn fori 1tondo angbracketleftpti cpi angbracketright inst toclprog pti si return cp1cp2 cpn figure .
translation of llvm crypto programs toylandyh.
the technicalities are not detailed here.
given an llvm crypto program prog a variable or a pointer is undefined if it is not assigned by any instructions inprog .
undefined variables denoted by varu and pointers byptru are usually the input variables and pointers of the program.
now the llvm crypto program translation is straightforward with i nst toclprog .
the algorithm is depicted in fig.
.
we first construct the initial pointer table pt0 as a mapping that maps each pj ptruinprog t ot h e symbolic address pj .
all pj s are distinct.
with pt0 the algorithm starts from the first instruction s1.
an updated pointer table pt1and a fragment of c rypto line program cp1are obtained.
it then continues to translate the next instruction s2withpt1.ptiis obtained at the i th iteration.
it actually models the valuation of pointers after executing i instructions of prog .
finally all cpi s are combined in order as the output c rypto line program.
example continued .given the whole ll vm crypto program we know that pout is an undefined pointer.
we let pt0 pout p when constructing pt0.
according to the translation algorithm pt2 pt1 pt0after translating lines and .
line is translated into no c rypto line statements but updates q0inpt3withpt3 q0 pt2 pout a0 p .
let llparenthesis p rrparenthesisv addrp0.
the llvm crypto program fragment is translated into the following c rypto line program fragment by our algorithm 1a subd0v04611686018427387872 y0 2a addd1v prime 0v0x0 4a setaddrp0v prime c. soundness given an initial state 0 m0 a n ll vm crypto program iswell formed if all its undefined variables and undefined pointers have their values in 0 and it is in ssa form.
we make an assumption on how programs access the memory.
separation assumption.
the memory is divided into several isolated segments.
each segment jcontains one base address designated by an undefined pointer pj ptru.
letpt0 pj pj .
every address in jisuniquely represented by the symbolic address pj o for some o zduring translation.
this assumption is indeed common in cryptographic programs.
assume that a cryptographic arithmetic function authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
has two arrays aandbas parameters.
pointers paandpbare the inputs pointing to their base addresses i.e.
the addresses ofa andb .
then the address of a can be and is always calculated via pa. no one will do this via pb.
the separation assumption is inspired by separation logic .
given an llvm crypto program prog with initial state 0 m0 w eu s e i mi to denote the state after executing the firstiinstructions.
that is for the i th instruction si ofprog w eh a v e i mi si i mi .
we define a simulation relation precedesorcurlybetween llvm crypto states m and c rypto line states .
m precedesorcurly reads as m is simulated by .
m precedesorcurly holds if the values of variables and the content of memory in m are correctly projected into .
for example given a bit ll vm crypto variable x its corresponding bit representations xlandxhin crypto line should satisfy xl xh x .
we prove the soundness property of our translation via the following theorem theorem .
given separation assumption and a wellformed llvm crypto program prog with initial state 0 m0 .
the generated crypto line program clprog prog toclprog prog cp1 cpn satisfies i for alli there exists a crypto line state i ofclprog such that i mi precedesorcurly i ii for alli and with i mi si i mi and i mi precedesorcurly there exists primesuch that cpi primeand i mi precedesorcurly prime.
theorem guarantees that after translation each state of the input llvm crypto program has its corresponding simulation c rypto line state s of the generated program each execution trace of the input ll vm crypto program has its corresponding simulation trace s of the generated crypto line program.
therefore all the behaviors of the input program are captured by the generated one.
with theorem assume that the given llvm crypto program prog hasninstructions.
if a property pllvm does not hold in the final state n mn then there must exist a crypto line state n with n mn precedesorcurly n of the generated program and a trace to n such that the corresponding property pcldoes not hold in neither.
in other words if the verification tool verifies that pclholds in all possible final states n s even if n mn negationslash precedesorcurly n along all possible execution traces of the generated c rypto line program thenpllvm is guaranteed to hold in n mn of the input prog .
therefore if our verification result shows that the generated c rypto line program is correct with respect to the specification it implies that the input llvm crypto program is also correct.
hence the input c program is correct.
d. implementation heuristics although our translator is fully automatic extra human effort is sometimes needed to get the generated c rypto line programs verified due to limitations of the c rypto lineverification tool.
in our first implementation of the translator we found that it took large amounts of human work to verify the generated c rypto line programs.
however most of the work was repetitive and tedious.
we develop four kinds of heuristics to reduce human efforts in the current implementation including heuristics for specific bitwise shifting for special and for overflow underflow and for the and after lshr pattern.
the former two apply specialized translation when the arguments of the input instruction have specific values.
the latter two are detailed as follows.
we stress that all the heuristics retain the soundness property of our verification results.
heuristics for overflow underflow in the translation ofadd sub andmul we introduce carry borrow flags that indicate the presence of overflow underflow in the input llvm crypto instructions.
for example when translating y add 64a1a2 the statement adddya 1a2is used.
a new flag dis introduced that indicates the presence of overflow in add .
but in most cases in cryptographic programs such an overflow will not happen thanks to the careful range assumptions on inputs.
nevertheless it is difficult for the crypto line tool to deduce d automatically and use this information to verify specified properties.
our heuristic hence automatically inserts the following two c rypto line statements for each flag dof such a kind during translation assertd assumed the assert statement tells c rypto line to check whether d is0.
if it is then assume utilizes this information to ease the verification.
only if it is not an overflow may arise.
human efforts hence are needed to investigate the problem.
this heuristic also applies to the translation of shl for the same reason to check whether the value of zdequals .
heuristics for and after lshr in cryptographic programs a masking and instruction often follows an lshr instruction to perform a splitting together.
for instance the following pattern is common y1 lshr 64a51 y2 and 64a0x7ffffffffffff y1andy2get the high bits and the low bits respectively ofa.
by our translation algorithm they are translated to splity1zda51 andy2a0x7ffffffffffff but c rypto line requires the extra information zd y2to pass the verification.
we implement heuristics to insert the following statements automatically to help the verification assertzd y2 assumezd y2 note that in practice the instructions lshr andand may not be adjacent.
they may not have exactly the same aas operands.
and several pairs of lshr andand may even interleave.
it makes this and after lshr pattern more authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
complicated.
the implemented simple heuristic only relates and to the previous lshr .
however it works in most of the scenarios we have encountered.
a more precise analysis of the pattern can further improve the automation of our technique.
v. e v alua tion we have implemented our translator on llvm .
.
and successfully applied our approach to c implementations of arithmetic operations in cryptographic primitives of openssl .
.
.
among them are verified.
one bug and several anomalies are exposed and confirmed in the remaining functions.
a. experiment setup the verification proceeded in the following way.
given a c implementation of an arithmetic operation first we compiled it into ll vm ir using clang .
.
.
then the ll vm ir code was translated by our translator to c rypto line automatically.
the very few instructions not supported by llvm crypto required manual translation.
the generated crypto line program was then verified by the verification tool.
some of them required human efforts to annotate the program like adding assert s. the verification was performed on two machines respectively a mac laptop m1 running os x .
.
with a core .6ghz cpu and 8gb ram and a linux machine m2 running ubuntu .
.
with two core .47ghz cpus and 128gb ram.
boolector .
.
and singular .
.
were utilized as smt solver and ideal membership solver respectively for the c rypto line verification tool.
b. v erification tasks the verified implementations include fundamental arithmetic operations in curve25519 and three nist elliptic curves p p and p .
each curve has its own special finite field zp p 19for curve25519 p for nist p p for nist p and p 1for nist p .
the field elements of different bit widths over different curves hence have different representations.
their arithmetic implementations thus differ.
most of the specifications of these arithmetic operations came from the comments in openssl source code.
for those without specifications written in the comments we determined their specifications from the context of their usage inside openssl.
the pre conditions of the verified specifications are range properties on inputs.
and the postconditions contain both algebraic and range properties relating outputs to the inputs.
see the example in section iii b .
the most complicated algebraic post condition we have verified is part of the montgomery ladderstep in curve25519 x1 x5 x2 z3 z2 x3 z5 x2 x3 z2 z3 2mod .
each of x1 x2 x3 x5 z2 z3andz5is a field element represented by five bit limbs.
note that montgomery ladderstep is a crucial step to compute point multiplication over curve25519 efficiently and securely.
it requires field operations that are implemented as individual functions.
such complicated algebraic properties involving large numbers cannot even be specified in existing general purpose c verification tools let alone be verified by them.
c. experiment results the results of the experiment are summarized in table iii.
in the table the loc ir column displays the number of lines of llvm ir code for each function and loc cl for their c rypto line code.
the diff columns show the percentage of manual modifications in each c rypto line program.
diff is for our translator with no heuristics implemented and diff h is with all four heuristics.
note that specifying pre and post conditions does not count but modifying one line i.e.
one statement counts two one deletion and one addition.
finally t1andt2are the verification time in seconds on m1 and m2 respectively.
they do not contain translation time from llvm crypto to c rypto line.
the translation for the largest target with instructions only took less than 5seconds.
the others took less than 2seconds.
we highlight the results as follows for functions felem diff 128 64 felem mul and felem square in ecp nistp521 marked with our approach shows that they do not conform to the specifications given in the openssl source code comments.
more details are given in section v d. most of the verified tasks .
25of35 are finished within only 5seconds even on m1.
.
of them take less than 20seconds.
two of those left require around 1minute.
the largest target in the experiment the montgomery ladderstep the last row makes m1 out of memory marked with om .
it requires around 47minutes on m2.
a further experiment showed that this can be accelerated by parallelization supported by crypto line.
the verification time on m2 is then reduced to seconds around 21minutes by using option jobs to parallelize with 6threads.
this improves the scalability of our approach.
the diff columns show that the automation of our approach is greatly improved by our heuristics.
with these heuristics most of the tasks .
25of38 are verified fully automatically.
almost all .
35of need only less than of manual modifications.
we believe that more heuristics can further reduce these efforts and improve the usability of our tool.
d. bug and anomalies in ecp nistp521 the functions felem diff 128 64 felem mul and felem square in ecp nistp521.c implement subtraction multiplication and squaring on field elements respectively.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii experiment results function loc ir loc cldiff diff h t1t2 s s ecp nistp224.c felem diff .
.
.
.
felem diff .
.
.
.
felem mul .
.
.
.
felem scalar .
.
.
.
felem square .
.
.
.
felem sum .
.
.
.
widefelem diff .
.
.
.
felem mul reduce .
.
.
.
felem neg .
.
.
.
felem reduce .
.
.
.
felem square reduce .
.
.
.
widefelem scalar .
.
.
.
ecp nistp256.c felem diff .
.
.
.
felem scalar .
.
.
.
felem small sum .
.
.
.
felem sum .
.
.
.
smallfelem mul .
.
.
.
smallfelem neg .
.
.
.
felem shrink .
.
.
.
felem small mul .
.
.
.
smallfelem square .
.
.
.
ecp nistp521.c felem diff64 .
.
.
.
felem diff128 .
.
.
.
felem neg .
.
.
.
felem scalar .
.
.
.
felem scalar64 .
.
.
.
felem scalar128 .
.
.
.
felem sum64 .
.
.
.
felem reduce .
.
.
.
felem diff .
.
felem mul .
.
felem square .
.
curve25519.c fe51 add .
.
.
.
fe51 sub .
.
.
.
fe51 mul .
.
.
.
fe51 mul121666 .
.
.
.
fe51 sq .
.
.
.
x25519 scalar multa1153 .
.
om .
aonly the montgomery ladderstep part is verified.
they all have input range assumptions given in the comments as pre conditions.
the verification of these three functions failed with these given pre conditions.
it turns out that the given range assumptions may cause unexpected overflows in the implementations.
these overflows then result in wrong returned values.
using the output of the c rypto line verification tool we succeeded in locating the instructions with unexpected overflows.
counterexamples were also constructed.
a counterexample offelem diff 128 64 shows that the unexpected overflow really happens when it is invoked by point double .
we reported our findings with the counterexamples to the openssl developer community.
the community confirmed that the overflow in felem diff 128 64 is a bug.
they then fixed it in the commit 13fbce1.
besides openssl .
.
this bug is hidden in various releases including .
.
.
.
etc.
for felem mul andfelem square the community confirmed that the range assumptions written in the comments were wrong.
new range assumptions were also given from the community.
the new implementation of felem diff 128 64 and the new range assumptions of felem mul andfelem square have been verified by our approach.
the verification of new felem diff 128 64 takes less than 5seconds on both m1 and m2.
felem mul andfelem square with new assumptions take around and80seconds respectively on both machines.
e. remark on compiler optimization in the experiment we found that there are vectorized instructions in the assembly output of x25519 scalar mult from clang even though the source code is sequential.
it turns out that compilers like clang are able to perform surprisingly non trivial optimizations.
it can vectorize a fragment of sequential code.
in the case of x25519 scalar mult t w o sequential additions a1 b1anda2 b2in c code are optimized to a vector addition addv on vectors aandb whereacontainsa1 a2andbsimilarly.
the vector addition is further assembled to a vectorized assembly instruction if the underlying architecture supports.
this means the two sequential c statements will be executed simultaneously in the binary executable.
vi.
r ela ted work to the best of our knowledge this work presents the first attempt to verify existing cryptographic c code automatically.
we compare our approach with others in three categories.
a. general purpose c v erification numerous techniques and well developed automatic tools such as are available for verifying c code.
the annual competition on software v erification svcomp 4is a showcase for them.
we have tried cpa s eq pesc o and ua utomizer from the top three winning in overall category in sv comp to verify our line motivating example.
as shown these generalpurpose verification tools are not very suitable for verifying bit precise non linear algebraic properties in cryptographic programs.
we specially mention smack since it works similarly as our approach.
it converts llvm ir programs into boogie programs then chooses various verifiers for boogie to perform verification.
however boogie is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
not designed for cryptographic programs and there is no verifier developed for that purpose.
f rama c allows to verify algebraic properties by combining smt solving and interactive theorem proving.
however the complicated algebraic properties involving large numbers are difficult or even impossible to be specified in these general purpose c verification tools.
b. v erifying cryptographic c code gfverif is an automatic tool used to verify a c implementation of the montgomery ladderstep in curve25519.
it needs to re implement existing c programs using its constructs before verification.
gfverif verifies fewer programs than our approach because its constructs are more limited.
for example it does not support bit integers or algebraic properties involving variable modulus.
it cannot verify our motivating example in section i either.
cryptol saw automatically verifies several cryptographic implementations in c and java against their reference implementations.
however the reference implementations are not proven correct.
f and v ale implement arithmetic operations in their languages and verify the results using smt solving and manual proofs.
fiat crypto is a project that tries to synthesize correct by construction c code for cryptographic primitives.
but its verification relies on manual proofs using coq .
a collection of hash functions random number generators and other operations are formally and manually verified using proof assistants like coq.
note that interactive theorem proving costs much more human efforts than our approach.
and our approach is able to construct counterexamples when verification fails while manual approaches cannot.
c. v erifying cryptographic assembly code in the authors verified a hand optimized assembly implementation of the montgomery ladderstep in curve25519 using smt solvers and coq.
they have to annotate programs extensively and manually.
if smt solving fails human verifiers have to use coq to manually fill the gap.
the work models cryptographic assembly programs with a domain specific language bvcrypto line.
programs in bvcrypto line can be verified automatically by a certified approach.
extending bvcrypto line c rypto line is equipped with automated tools for translation from assembly code to c rypto line.
although the verification is not certified it is much faster.
our approach is based on crypto line.
compared to them our approach works at a higher level and supports features like pointer arithmetic.
vii.
c onclusion we have presented an automated approach to translation and verification of arithmetic functions in cryptographic c programs.
the case studies on real world implementations in openssl suggest the applicability and scalability of ourapproach.
we were assisted greatly by the useful comments of openssl developers in our experiments.
there are three obvious future directions.
first more translation heuristics can be developed to ease the verification process.
second specifications are written at the c rypto line level for the moment.
it requires human verifiers to have knowledge about the translation.
another direction is to design a specification language that allows verifiers to write pre and post conditions at c source code.
finally we have only worked up to one iteration of an innermost loop the montgomery ladderstep .
we could elevate the verification to a higher level of the cryptographic primitive here a point multiplication on a curve by checking loop invariants.
acknowledgment the authors would like to thank the anonymous referees for their valuable comments and suggestions.
this work is supported by academia sinica under the grant numbers as ia m01 and as tp m06 the guangdong science and technology department under the grant number 2018b010107004 the ministry of science and technology of taiwan under grant numbers e my3 e e my2 2221e my3 and the national natural science foundation of china under the grant numbers and .