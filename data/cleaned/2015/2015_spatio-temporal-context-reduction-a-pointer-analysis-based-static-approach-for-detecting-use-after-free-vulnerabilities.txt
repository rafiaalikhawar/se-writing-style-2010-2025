spatio temporal context reduction a pointer analysis based static approach for detecting use after free vulnerabilities hua yan school of computer science and engineering university of new south wales australiayulei sui centre for artificial intelligence and school of software university of technology sydney australia shiping chen data61 csiro australiajingling xue school of computer science and engineering university of new south wales australia abstract zero dayuse after free uaf vulnerabilitiesareincreasinglypopular and highly dangerous but few mitigations exist.
we introduceanewpointer analysis basedstaticanalysis cred forfindinguafbugsinmulti mloccsourcecodeefficientlyandeffectively.cred achieves this by making three advances i a spatio temporal contextreductiontechniqueforscalingdownsoundlyandpreciselytheexponentialnumberofcontextsthatwouldotherwisebeconsideredatapairoffreeandusesites ii amulti stageanalysisforfilteringoutfalsealarmsefficiently and iii apath sensitivedemand driven approach for finding the points to information required.
wehaveimplementedcredinllvm .
.0andcompareditwith four different state of the art static tools cbmc model checking clang abstract interpretation coccinelle pattern matching and supa pointer analysis using all the c test cases in juliet test suite jts and10open sourcecapplications.fortheground truth validated with jts cred detects all the known uaf bugs as cbmc and supa do while clang and coccinelle miss some bugs with nofalse alarms fromany tool.
forpracticality validated with the10applications totaling3 mloc credreports132warnings including bugs in .
hours while the existing tools are either unscalablebyterminatingwithin3daysonlyforoneapplication cbmc or impractical by finding virtually no bugs clang and coccinelle or issuing an excessive number of false alarms supa .
ccs concepts securityandprivacy softwareandapplicationsecurity theoryofcomputation programanalysis softwareand its engineering software defect analysis keywords use after free program analysis bug detection these two authors contributed equally to this work.
this work is supported by arc grants dp180104069 and de170101081 .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
reference format hua yan yulei sui shiping chen and jingling xue.
.
spatio temporal contextreduction apointer analysis basedstaticapproachfordetecting use after freevulnerabilities.in proceedingsoficse 40thinternational conference on software engineering gothenburg sweden may june icse pages.
introduction use after free uaf vulnerabilities i.e.
danglingpointer dereferences referencinganobjectthathasbeenfreed areincreasingly beingexploited asshowninfigure1.uafvulnerabilitiesarehighly dangerous with .
in the nvd database being rated critical or high in severity causing crashes silent data corruption and arbitrarycodeexecution.thisvulnerabilityclasspersistsinallkinds of c c applications.
while other types of memory corruption errors such as buffer overflows are nowadays harder to exploit due to mitigations there are few mitigations deployed in production environments to prevent uaf vulnerabilities .
high severity all severity levels figure use after free vulnerabilities in nvd .
therehavebeenconsiderableeffortsonbuildingautomatictools for mitigating uaf bugs.
however existing solutions almost ex clusively rely on dynamic analysis which inserts metadata manipulating instrumentation code into theprogram anddetectsorprotectsagainstuafbugsatruntime by performing checks at all pointer dereferences o r invalidatingalldanglingpointersidentified .whilemaintaining zero or low false alarms due to unsound modeling for e.g.
casting and safety window sizes dynamic techniques haveanumberoflimitations includinglowcodecoverage when used as debugging aids binary incompatibility due to memory layouttransformationssuch asfat pointers and highruntime and memory overheads due to runtime instrumentation .
static analysis for detecting uaf bugs will not suffer from suchinstrumentation basedlimitations.however statictechniques for uaf detection are scarce with focusing on binary code although there are several source code analysis tools for de tecting other types of memory corruption bugs such as buffer acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hua yan yulei sui shiping chen and jingling xue overflows memory leaks and null dereferences .
inthispaper weintroduceanewpointer analysis basedstatic sourcecodeanalysisforfindinguafbugsinmulti mloccprograms efficiently and effectively.
we first formulate the problem of detecting uaf bugs statically.
we then describe several challenges faced existing static techniques for analyzing c c source code and our solution by highlighting its novelty .
problem statement.
consider a pair of statements parenleftbigfree p lf use q lu parenrightbig where pandqare pointers and lfandluare line numbers.
let p l be the set of all feasible concrete programpaths reachingline lfrom main .
thepair is a uaf bug if and only if st parenleftbigfree p lf use q lu parenrightbigholds st parenleftbigfree p lf use q lu parenrightbig colonequal f u p lf p lu f lf leadsto u lu f p simequal u q where leadstodenotestemporal reachability in the program s icfg interproceduralcontrolflowgraph and simequaldenotesa spatialalias relation meaning that pandqpoint to a common object .
by convention l identifiestheprogrampoint lunderapathabstraction .
both temporal and spatial properties must correlate on the same concrete program path.
however stis not computationally verifiable due to exponentially many paths in large codebases.
challenges.
one mainchallenge faced indesigning a pointeranalysis basedstatic uafanalysis a lies inhow toreasonabout theexponentialnumberofprogrampathsin p lf p lu inorder to find real bugs at a low false positive rate.
this entails approximating stwith staby abstracting these program paths with somecontextsaccordingtoatradeofftobemadeamongsoundness precision and scalability.
aissound by catching all uaf bugs ifst parenleftbigfree p lf use q lu parenrightbig sta parenleftbigfree p lf use q lu parenrightbig for every uaf pair parenleftbigfree p lf use q lu parenrightbig.aisprecise by reporting no false alarms if sta parenleftbigfree p lf use q lu parenrightbig st parenleftbigfree p lf use q lu parenrightbigfor every parenleftbigfree p lf use q lu parenrightbig.
ais regarded as being scalableifstacan analyze large codebasesunderagivenbudget.forconvenience staisalsosaidto be sound precise scalable if ais sound precise scalable.
anotherchallengeishowtoverify leadstoefficientlyandprecisely especially in the presence of aliasing as discussed below.
afinalchallengeliesinhowtoobtain simequalefficientlyandprecisely.
thisrequiresapointeranalysisthatis field sensitive bydistinguishingdifferentfieldsinastruct flow sensitive bydistinguishingflow of control context sensitive by distinguishing calling contexts for a function and path sensitive by distinguishing different program paths .
however computing such precise points to information byreasoningabout p lf p lu isunscalable despiterecentadvances on whole program and demand driven pointer analyses for c c programs.
stateof theart.
duetotheabovechallenges therehasbeen littleworkondevelopingspecializedstaticapproachesfordetectinguafbugsatthesource codelevel.general purposestaticapproaches for detecting memory corruption bugs include modelchecking abstractinterpretation patternmatching andpointeranalysis .theircorrespondingrepresentative tools are cbmc clang coccinelle and supa which can be leveraged for finding uaf bugs .
model checking.
cbmc is a bounded model checker that reasonsaboutalltheprogrampathsin p lf p lu givenin for c c programsasconstraintsthatcanbesolvedbyansmtsolver.
when used in finding uaf bugs cbmc is sound in a bounded manner and highly precise but scales only to small programs whose sizes are restricted according to its user manual .
abstract interpretation.
clang is anabstractinterpreterfor analyzingc c programs.itadoptsahighlyunsoundmodelby analyzingonlyasmallsubsetoftheprogrampathsin p lf p lu givenin inordertoachievescalabilityandprecision.toscale for large codebases with few false alarms clang limits its uafbug findingabilitybyperforminganintraproceduralanalysis with inlining .
in general such tools refrain from reporting too many false alarms but at the expense of missing many uaf bugs.
pattern matching.
coccinelle is a pattern based tool for analyzing and certifying c programs.
coccinelle can find uaf bugsbasedonsomepatternsgiven.duetothelackofthepoints to information coccinellecanbebothfairlyunsoundandimprecise but is highly scalable due to its pattern matching nature .
pointer analysis.
supa is a state of the art demand driven pointer analysis that is field flow and context sensitive but pathinsensitive for c programs.
when used in finding uaf bugs supa canberegardedasreasoningaboutalltheprogrampathsin p lf p lu withanextremelycoarseabstraction inor der to achieve soundness and scalability.
by convention represents allpossiblecallingcontextsandthusallpossible concrete paths reaching l. thus stin is weakened significantly to stsupa spatio temporal correlation with a high level of spuriosity stsupa parenleftbigfree p lf use q lu parenrightbig colonequal lf leadsto lu p simequal q where leadstoisthestandardcontext sensitivereachabilityand simequalisthe standard context sensitive alias relation obtained under .
when used in finding uaf bugs stsupawill be highly imprecise since spurious spatio temporal correlations are introduced at an extremely large number of uaf pairs where stsupa parenleftbigfree p lf use q lu parenrightbig notdblarrowrightst parenleftbigfree p lf use q lu parenrightbig holds asexplainedinsection2andvalidatedinsection5.these spurious correlations are false alarms.
our solution and contributions.
we introduce an interprocedural pointer analysis basedstaticanalysis cred forfinding uaf bugs in multi mloc c code by making several contributions.
first we present a spatio temporal context reduction technique that enables developing our new static uaf analysis systematically by simplifying stin into stcredgiven below stcred parenleftbigfree p lf use q lu parenrightbig colonequal tildewider f tildewider u tildewidep lf tildewidep lu tildewider f lf leadsto tildewider u lu tildewider f p simequal tildewider u q we ensure that stcredis sound by requiring tildewidep l to be a coarser abstraction of p l and scalable by requiring tildewidep lf authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
spatio temporal context reduction icse may june gothenburg sweden tildewidep lu lessmuch p lf p lu .
unlike stsupa however stcred will be highly precise as stcred parenleftbigfree p lf use q lu parenrightbig notdblarrowright st parenleftbigfree p lf use q lu parenrightbighappens only for a small number of uaf pairs.
with spatio temporal context reduction credis designed purposelytopreservethespatio temporalcorrelationof stbykeeping spurious correlations i.e.
false alarms as low as possible.
without it cred will be either highly unsound or highly imprecise.
second we adopta multi stageapproach thatstarts withsome uaf pairs obtained by a pre analysis and then uses increasingly morepreciseyetmorecostlyuafanalysesonincreasinglyfewer uaf pairs to filter out false alarms.
in our current implementation we perform context reduction by first using calling contexts and thenconsideringpathsensitivity.stagingsuchanalysesthisway improves the efficiency of the overall solution.
third weintroduceademand drivenpointeranalysiswith field flow context and path sensitivity as the foundation for the main analysis stages of cred.
this work is the first to consider pathsensitivity on demand in order to reduce false uaf alarms.
finally we have implemented cred in llvm .
.
and compareditwithfourstate of the artsource codeanalysistools cbmc model checking clang abstract interpretation coccinelle patternmatching andsupa pointeranalysis using all the c test cases in juliet test suite jts and opensource c applications.
for the ground truth evaluated with jts cred is as effective as cbmc and supa by detecting all the knownuafbugswhileclangreportsonly36bugsandcoccinelle finds126bugs withnofalsealarmsissuedinallthecases.forpracticality evaluated with the applications totaling over mloc cred produces warnings including bugs in about .
hours.
incontrast cbmcproducesnowarnings terminatingin19.0hours forthesmallestapplicationbutexceedingthe3 daytimebudgetfor every remaining application clang reports warnings including bug in .
hours coccinelle reports false alarms in .
seconds without finding any bugs and supa detects the same bugsfoundbycred togetherwith23 095falsealarms in5.1hours.
overview 5hilqhg sdluv bug report5hilqhg sdluv 5hilqhg sdluv demand driven pointer analysisprogram qsxw preanalysiscontext reductionpathsensitivity figure workflow of cred.
as depicted in figure we start with a fast but imprecise preanalysis i.e.
anandersen stylepointeranalysis toobtaina setofcandidateuafpairstobeanalyzed accordingto .wethen apply two spatio temporal context reductions calling context reduction section2.
and pathreduction section2.
founded onthesamedemand drivenpointeranalysisinfrastructure.note that each stage refines the results from the preceding one.
we focus on describing how calling context reduction works and why it is significant.
without the two reduction techniques auafanalysisthatreliesonexistingpointeranalysistechniques will be either unscalable or highly imprecise section .
.
calling context reduction theobjectiveistosimplify stin into stcredin byabstracting program paths with calling contexts so that cred is sound scalableandprecise.ourexampleisgiveninfigure3.weusewhole programpointeranalysis toexplainwhy credwould be unscalable if full calling contexts were used although it would be highly precise and imprecise if k limited calling contexts were used although it would be possibly scalable .
these arguments applyalsotodemand drivenpointeranalysis asvalidated later .
we achieve both efficiency and precision by reducing full calling contexts substantially in both length and quantity.
.
.
context sensitivity.
we introduce the terminologies and notations used in context sensitive program analysis.
call string or call stack .
in ak limitedork callsite contextsensitiveanalysis everyvariableaccessedorobjectallocatedinafunction funisidentifiedbyacallstring c known asacallingcontext whichrepresentsasequenceofthe k mostrecent call sites on the call stack calling fun.
in a call string every recursion cycle is typically approximated once.
the analysis is said to be fully context sensitive ifc1starts from main .
context sensitive control flow reachability.
given two programpoints landl primeidentifiedundercontexts candc prime respectively c l leadsto c prime l prime signifiesthat c l reachescontext sensitively c prime l prime .thisissolvedasa balanced parenthesesproblem bymatchingcallsandreturnstofilteroutunrealizablepathsinthepro gram s icfg .
we start from c l with an abstract stack initializedas c.whenenteringacalleefunctionfromacallsite ci wepushciintothe contextstackcontaining c denoted c .
when returning from a callee to a callsite cj w epo pcjfrom the currentstackcontaining c denoted c circleminus ifccontainscjasits topvalueor c sincearealizablepathmaystartandendin different functions.
finally c l leadsto c prime l prime is established if l primeis reached when the context stack contains c prime.
k call site context sensitive pointer analysis.
letpt c v bethepoints tosetofavariable vunderacallingcontext csuch that c k.giventwovariables pandq c p simequal c prime q holdsifp andqmay point to a common object i.e.
pt c p pt c prime q nequal .
here c c prime representsthecallingsequenceforthefunctionwhere p q is defined and h h prime represents the calling sequence for the function where object ois allocated.
we speak of full contextsensitivity if c c prime handh primeall start from main .
.
.
limitations of k call site context sensitivity.
figure3 a illustratesatypicalheapusagescenario.inlines1 thereare 2ncalling contexts to com from main .
in lines two heapobjects areallocated lines then used lines16 and and finally deallocated lines and through a series of wrappers.
there is one uaf pair parenleftbigfree p ln34 use q ln31 parenrightbigto be analyzed where use q ln31 stands for print q at line .
thisexampleisuaf free.withfullcontext sensitivity nowarnings would be reported but the resulting analysis is unscalable.
withk limiting the analysis scales but at the expense of precision.
fullcontext sensitivity precisebutunscalable.
asshown in figure b ris the set of 2nfull calling contexts for com .
thus there are 2n 2n 1calling context pairs reaching parenleftbigfree p print q parenrightbig.a s c r c ln34 leadsto authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hua yan yulei sui shiping chen and jingling xue int main f1 ca1 f1 cb1 void f f2 ca2 f2 cb2 ... ... void f n com c1 int x y void com x xmalloc c2 y xmalloc c3 xuse x c4 xfree x c5 xuse y c6 xfree y c7 int xmalloc return malloc o void xuse int u xxuse u c8 void xfree int v xxfree v c9 void xxuse int q print q use q void xxfree int p free p a programpt p o pt p o pt q o pt q o ... pt p o pt p o pt q o pt q o c fully context sensitive points to sets pt p o o pt q o o pt p o pt p o pt q o pt q o d k limited context sensitive e points to sets with points to sets k calling context reduction call return ... ...main free p xxfree x xmalloc y xmalloc xuse x xfree x xuse y xfree y xxfree v xfreemalloc xmalloccom common caller xxuse u xuseprint q use q xxuse com fn ... ... ... com .........main f 1f2 fn fn ... call strings from main to com b interprocedural control flow graph icfg figure3 calling contextreductionforovercomingthelimitationsoffulland k limitedcontext sensitivityinuafdetection.
...mainmalloc free use common caller transitively call malloc transitively call free transitively call use figure context reduction illustrated conceptually with an oracle fully context sensitive pointer analysis.
c ln31 free p reaches print q .
however as c r p simequal q pandqneverpointto a common object.
therefore no uaf warning will be issued.
to reason about simequal however we may have to compute 2n 2pointstosetsinfigure3 c makingexistingpointeranalysistechniques unscalable when nis large as validated later .
k limiting scalablebutimprecise.
withk the2n 1calling contexts reaching free p print q are abstracted by .
then ln34 leadsto ln31 .
in addition p simequal q holds spuriously based on the two points to sets in figure3 d computedimpreciselybutpossiblyefficiently.thus a false alarm from line to line is reported.
with limiting the false alarm will be suppressed.
however increasing kwillnotworkforlargecodebasesfortworeasons.
first thenumberofcontextpairstobeanalyzedatauafpairwillgrowexponentially.second theoptimalvaluesfor kvaryacross the uaf pairs.
finding such values is beyond the state of the art.
.
.
spatio temporal calling context reduction.
thekeyinsightisto removeprefixesinfullcalling contextsthatdonotcontribute to context sensitivity thereby achieving the precision of full context sensitivity and the scalability of k limiting.letpt c v be the points to set of vunder context ccomputed byanoraclepointeranalysisfullycontext sensitively.asillustrated in figure parenleftbigfree p lf use q lu parenrightbigis a bug when c1 c4 hold c1 main calls underacontext cfu acommoncallerfunction which calls an object allocation function e.g.
malloc free p anduse q at lineslo lpandlqin that order c2 ois allocated under context cfu tildewideh c3 cfu tildewideh o pt cfu tildewidecf p and c4 cfu tildewideh o pt cfu tildewidecu q .
by definition cf lf leadsto cu lu cf p simequal cu q tildewidecf lf leadsto tildewidecu lu tildewidecf p simequal tildewidecu q making cfuredundant.
forourexample figure3 b illustratesthecallingcontextreduction performed.
as cfu ris a common prefix for the common caller com thatsatisfiesc1 c4 atotalof2n 2n 1fullcalling contextpairsreaching parenleftbigfree p print q parenrightbighavebeenreducedto just four with tildewidecf tildewidecu and tildewideh c2 c3 .a scom is a common caller c tildewidecf p simequal c prime tildewidecu q doesnothold i.e.
pandqaremust not aliasesif candc primearedifferentprefixesin r.thus itisonlynecessarytoverify c tildewidecf ln34 leadsto c prime tildewidecu ln31 whenc c prime.wecandothisefficientlybycheckingif car tildewidecf appearslexicallybefore car tildewidecu incom i.e.
iflpappears beforelqin figure .
note that caris the standard function for returning the first element in a sequence.
for the four reducedcontext pairs only ln34 leadsto ln31 holds since c5 precedes c6incom .
according to the points to sets shown in figure3 e computedefficientlyforthereducedcallingcontexts p negationslash simequal q .
hence no uaf warnings are reported.
.
path reduction we improve precision by augmenting calling contexts with authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
spatio temporal context reduction icse may june gothenburg sweden void foo p malloc ... o1 if cnd free p free p ln4 p malloc ... o print p use p ln7 figure path reduction.path sensitivity.
consider a bugfree example in figure .
withoutpath sensitivity pat line points too1andqat line points to o1 ando2 causing a path insensitive detector to report a false alarm parenleftbigfree p ln4 use p ln7 parenrightbig.
with path sensitivity ho wever this false alarm will be suppressed successfully.
to the best of our knowledge cred is the first uaf detector for large codebases that reasons about path sensitivity on demand based on a new path sensitive demand driven pointer analysis.
thecredanalysisforuafdetection asshowninfigure2 credcomprisesthreekeycomponents circlecopyrt spatio temporalcontextreduction circlecopyrtdemand drivenpointeranalysis and circlecopyrtmulti stage uaf analysis.
while circlecopyrtrepresents the mostimportantcontributionofthispaper weintroduce circlecopyrtand3 circlecopyrt first in that order in order to build the basis for circlecopyrt.
.
demand driven pointer analysis wedescribeademand drivenpointeranalysisthatisnotonlyfield flow and context sensitive as in but also path sensitive.
addingpath sensitivityissignificantintermsofbothadvancing demand driven pointer analysis in general and reducing a large number of false alarms that would otherwise be reported by cred.
.
.1program representation.
a c program is represented byputtingitintollvm spartialssaform following .
the set of program variables vis separated into two subsets a containing all possible targets i.e.
address taken variables of a pointer and tcontainingall top levelvariables where v t a. after the ssa conversion a program has seven types of statements p a addrof p q copy p q load p q store p ... q ... phi p callfun q call and returnp return wherep q tanda a.top levelvariablesareputdirectlyin ssa form while address taken variables are accessed indirectly via load or store.
for an addrof statement p a known as anallocation site ais a stack or global variable with its address taken or a dynamically created abstract heap object.
passing parametersandreturnvalues explicitlyfortop levelandimplicitly for address taken variables is modeled by copy.
all pointer analyses used are field sensitive.
each field instance of a struct is treated as a separate object.
however arrays are considered monolithic.
precise solutions for arrays do not exist.
given a program its icfg is built in the normal manner .
a call site for a function funis split into a call node and a return node withacalledgefromthecallnodetotheentrynodeof fun and a return edge from the exit node of funto the return node.
.
.2algorithm.
as shown in figure we extend b y making it also path sensitive with the required path guards generated on demand.
our analysis is flow sensitive since it answers a points to query for a variable vby traversingall the def use chains affecting vbackwards on a value flow graph vfg .
in the vfg a node represents a statement identified by its linenumber and an edge from statement lto statement l prime denoted lv l prime representsadef userelationforavariable v v withits c l p o c l p arrowhookright c ol c l p qlqq l q guard lq l c l p arrowhookright c q lq q c l p .. q .. lqq l q guard lq l c l p arrowhookright c q lq q c l p q c q lq q arrowhookright co o o lqq lloo l q guard lq l o guard lo l c l p arrowhookright co o o lo o c l p q c p lp p arrowhookright co o o lpp ll qq ll oo l p guard lp l q guard lq l o guard lo l co o l o arrowhookright c q lq q co o l o arrowhookright co o o lo o c l definefun v ... lcall callfun a laa lcall a guard la lcall c l v arrowhookright c circleminus a la a c l y callfun ... definefun ... ... lret returnx lxx lret x guard lx lret c l y arrowhookright c x lx x c l v arrowhookright c prime prime l prime v prime c prime prime l prime v prime arrowhookright c prime prime prime prime l prime prime v prime prime c l v arrowhookright c prime prime prime prime l prime prime v prime prime figure demand driven pointer analysis with field flow andcontext sensitivityasin and path sensitivity added.
def at statement land its use at statement l prime.
these def use chains are pre computed with a fast but imprecise andersen style pointer analysis flow and context insensitively .
our analysis is also context sensitive.
the points to query pt v whereci identifiesacallsite returnsthepoints tosetof vforallthefunction calling sequences ending with .
thus pt v l gives the points to set of vat linelat all calling contexts.
we explain our extension on handling path sensitivity highlighted in red.
calling contexts are path abstractions but can be too coarse.
to perform path sensitive analysis we represent an abstract path by both a calling context cand a path guard so that cspecifies its calling sequence and collects its branch conditions.
thus pt c v l givesthepoints tosetof vatlinelunder c .
inafunction fun everybranchconditionistreatedasaboolean formula.
as in a loop after unrolling if needed is approximated only once with its back edge ignored.
for each controlflow edge e edgeguard e is the branch condition under which eis executed.
for a control flow path cp which consists of a set ofcontrol flowedges e thepathconditionisthelogicalconjunction of branch conditions of e i.e.
logicalandtext.
e cpedgeguard e .apath guard guard l l prime fromastatement ltoastatement l primeinfunisthelogical disjunctionofpathconditionofallcontrol flowpathsfrom ltol prime guard l l prime logicalordisplay.
cp path l l prime logicalanddisplay.
e cpedgeguard e wherepath l l prime denotes the set of control flow paths from ltol prime.
apath guard from the entry of main to a statement is definedsimplyintermsof .forthetwospecialcases true false represents an abstract feasible infeasible path.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hua yan yulei sui shiping chen and jingling xue given c l v wherevariable vappearsatline l thepoints to setofviscomputedbyfindingallreachableobjects co o o via backward traversal on the pre computed def use chains pt c v l co o o c l v arrowhookright co o o the first seven rules handle the seven types of statements in theprogrambytraversingbackwardsalongallthepre computed def use chains affecting v l. the last says that arrowhookrightis transitive.
in objects created at different allocation sites are identified by their line numbers.
in a vdenotes a variable passed into the callee directly or indirectly via parameter passing.
similarly x in represents a value returned directly or indirectly from the callee to its caller.
context sensitivity is enforced by matching calls and returns.
in c the callsite label lis appended to c.i n c circleminus lisremovedfrom cifccontainslasitstopvalueorisempty sincearealizablepathmaystartandendindifferentfunctions .
strong updates are performed on singleton objects as in supa .
foraprogram itscallgraphisbuiltonthefly.ouranalysishandlesitssccs stronglyconnectedcomponents context sensitively but the function calls in an scc context insensitively as in .
thus ouranalysisisfullyfield andflow sensitiveaswellasfully context and path sensitive modulo loops and recursion cycles .
main ln1 ln5 ln6 ln8ln7 returncnd true true cnd cnd cndguard ln1 ln2 true p o guard ln1 ln4 true x o guard ln1 ln6 cnd y o p x guard ln1 ln8 guard ln4 ln8 if cnd cnd cnd cnd cnd p y cnd if !cnd z p guard ln6 ln8 cnd a code b cfg c path guards figure path guard construction on a cfg.
.
.3example.
we use an example in figure to explain our rules on on demand path guard generation with some relevant pathguardsshown.supposeapoints toquery pt true z ln8 is issued.
with path sensitivity we can determine precisely that z points only to o2but noto3.
in line is applied true ln8 z p cnd ln1 p arrowhookright cnd o1 ln1p ln8 p guard ln1 ln8 cnd o1 guard ln4 ln8 cnd ln4o1 ln8 true ln8 z arrowhookright cnd ln4 o1 similarly applying and tolines4and2 respectively yields true ln8 z arrowhookright cnd ln4 o1 arrowhookright cnd ln2 x arrowhookright cnd o2 .
thus zpoints to o2.
we can also attempt to tracezbackwards to o3via p y by first applying in line which produces true ln8 z arrowhookright cnd ln6 o1 .
however no more rules can be applied further because cnd ln6 o1 negationslash arrowhookright cnd cnd ln6 y as cnd cnd false representing an infeasible path.
thus zcannot point to o3.
.
multi stage uaf analysis cred as shown in figure consists oftwo stages stages and .
eachstagedecideswhethertoissueawarningornotforagiven uafpairbyverifyingitsownversionof stcredgivenin which isdiscussedbelow.thepre analysis whichservestoprovidethe set of uaf pairs for cred to analyze can be regarded as stage .mainmalloc free use ...common caller mainmalloc free use ...common caller a b figure8 contextreductionwithademand drivenflow and context sensitivepointeranalysisthatcomputesthepoints tosetofavariableunderthecallingcontext .boxesandarrows represent functions and transitive calls respectively.
eachstageisfoundedonapointeranalysis pi.instage0 ourpreanalysis p0isflow context andpath insensitive.instage1 with calling context reduction p1is flow and context sensitive ondemand.
in stage with path reduction p2is also path sensitive.
asiincreases stage ibecomes progressively more precise but also more costly working on filtering out false alarms from an increasingly smaller set of uaf warnings provided by stage i .
atstagei where1 lessorequalslanti lessorequalslant2 weobtain leadstoand simequalasfollows.to obtain simequal weinvoke pitocomputethepoints toset pti i v with ptin subscriptedby i foreveryvariable vneededon demand under a budget i. here iis an appropriate path abstraction used bypifor querying v.i f iis exhausted before pti i v is found we fall back to pi 1by setting pti i v pti i v conservatively wherethesetofconcretepathsabstractedby iisasubset of the set of concrete paths abstracted by i .
to obtain leadsto w e compute it on the icfg obtained in stage and refined with the function pointers being resolved more precisely by pi.
.
spatio temporal context reduction we describe two reductions performed for stages and with the latterbeingdevelopedontopoftheformer makingstage2more precisebutalsomorecostlythanstage1.foreachstage wegive the inference rules for implementing for its reduction.
.
.
stage .
calling context reduction.
we abstractprogram paths with calling contexts so that the resulting uaf analysis is sound scalableandhighlyprecise withasfewspuriouscorrelations as possible as already motivated in section .
to this end we wouldliketoreplace p lf p lu in withacoarserabstraction tildewidec lf tildewidec lu expressed in terms of calling contexts reduced as shown in figure so that stin can simplify to stc stc parenleftbigfree p lf use q lu parenrightbig colonequal tildewidercf tildewidercu tildewidec lf tildewidec lu tildewidercf lf leadsto tildewidercu lu tildewidercf p simequal tildewidercu q how do we construct tildewidec lf tildewidec lu ?
the basic idea was illustrated earlier conceptually in figure with an oracle fully contextsensitive pointer analysis pt .
to reduce the number of context pairs in tildewidec lf tildewidec lu we should remove their redundant prefixes if they do not help separate calling contexts as desired.
however pt is non existent as it is not scalable for reasonably large programs.
below we obtain tildewidec lf tildewidec lu equivalently by usingpt1 whichisaflow andcontext sensitivepointeranalysis in stage section .
with the intuition illustrated in figure authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
spatio temporal context reduction icse may june gothenburg sweden tildewiderhp o pt1 p tildewiderhq o pt1 q tildewiderhpis a suffix of tildewiderhq lo car tildewiderhq lp car tildewidercf lq car tildewidercu lpandlqreside in the function containing loor its callee s.t.
lp nequallq tildewidercfis a calling context for lf tildewidercuis a calling context for lu tildewidercf tildewidercu tildewidec lf tildewidec lu figure illustrates a total of two cases in which parenleftbigfree p lf use q lu parenrightbigmay be potentially a uaf bug.
the scenario illustrated earlier in our motivating example given in figure is a special instance of one of these two cases.
asshowninfigure6 pt v iscomputed on demand bytraversing interprocedurally the statements producing values that may flow into v under all possible calling contexts for the function containing v as indicated by .i fvis found to point to ounder contextcwhen is applied then c o pt v .
note that c is a suffix of a calling sequence from main too s allocation site.
let us examine .a s tildewiderhp o pt1 p and tildewiderhq o pt1 q cf p simequal cu q holdsif tildewiderhpisasuffixof tildewiderhq i.e.
thesetof full callingcontexts from main abstracted by tildewiderhpis asuperset of the set of full calling contexts abstracted by tildewiderhq in which case tildewiderhp o and tildewiderhq o may represent a common concrete object.
the common caller com for malloc free p and use q is the function containing line lo.
lineslpandlqreside in either com figure a or a direct or indirect callee of com figure b in the special case lp lfandlq luhold .
thus tildewidecfis simply the calling context from lptolfsuch that lp car tildewidecf .
similarly tildewidecuis derived.
letst be obtained from stcsuch that tildewidec lf tildewidec lu are now expressed in terms of all full calling contexts possible.
by stc parenleftbigfree p lf use q lu parenrightbig st parenleftbigfree p lf use q lu parenrightbig.thus stcissoundandasprecise as possible by using calling contexts.
in addition stcis efficiently verifiable as motivated in section and validated later.
byconstruction cfu tildewidecf p negationslash simequal c prime fu tildewidecu q i.e.
pandqaremustnot aliasesif cfuandc prime fuaredifferentcontextprefixes.now cfu tildewidecf lf leadsto c prime fu tildewidecu lu holds where cfu c prime fu i.e.
tildewidecf lf leadsto tildewidecu lu holds onlyif lpappearslexicallybefore lqinthefunction containing loor its callee in .
to check tildewidecf p simequal tildewidecu q for these reachable pairs we rely on pt1 tildewidecf p andpt1 tildewidecu q .
let us apply to formally analyze the uaf pair parenleftbigfree p ln34 use q ln31 parenrightbigin figure .
by computing ondemand the points to sets of pandqflow and context sensitively we obtain pt1 p pt1 q c2 o c3 o .
let us consider c2 o only.
for this example considering also c3 o adds no information.
as tildewiderhp tildewiderhq we have lo car c2.
thus com is the common caller that transitively calls malloc free p anduse q .a slp c5 c7 andlq c4 c6 weobtain tildewidec lf tildewidec lu .
finally the uaf pair is filtered out as a false alarm as discussed in section .
.
.
.
stage .
path reduction.
weimprovecalling contextreductionbyaugmentingthecallingcontexts tildewidec tildewidec l fromstage1 with path guards tildewide tildewideg l thus achieving path reduction.
as acommon caller ff ttxfree ft xuseentry 1 xfree xuse 2 returnentry 3 free p return entry 4 use q returnft guard guard entry 1 3 2 4 guard entry guard entry 1 3 figure adding path guards to calling contexts in .
result stcis refined to stpby considering path sensitivity stp parenleftbigfree p lf use q lu parenrightbig colonequal parenleftbig tildewidercf tildewider f tildewidercu tildewider u parenrightbig parenleftbig tildewidec lf tildewideg lf parenrightbig parenleftbig tildewidec lu tildewideg lu parenrightbig tildewidercf tildewider f lf leadsto tildewidercu tildewider u lu tildewidercf tildewider f p simequal tildewidercu tildewider u q where parenleftbig tildewidec lf tildewideg lf parenrightbig parenleftbig tildewidec lu tildewideg lu parenrightbigis constructed below tildewidercf tildewidec lf tildewidercu tildewidec lu tildewider f logicalandtext.
ci tildewidercf guard entry ci ci tildewider u tildewider f guard lf car tildewidercu parenleftbig logicalandtext.
ci cdr tildewidestcu guard entry ci ci parenrightbig isfeasible tildewider u parenleftbig tildewidercf tildewider f tildewidercu tildewider u parenrightbig parenleftbig tildewidec lf tildewideg lf parenrightbig parenleftbig tildewidec lu tildewideg lu parenrightbig figure9 illustrates theintraprocedural pathscaptured bythese guards marked by different colors .
the interprocedural path from xfree tothecommoncallerandtheinterproceduralpathfrom the common caller to xuse are distinguished by calling contexts.
entrycidenotestheentrystatementofthefunctioncontaining the point ci.
thus tildewide frepresents the path from the entry of the functioncontainingthefirstcallsitein tildewidecftofree p lf and tildewide ufor use q lu consistsofthreeparts i tildewide f ii guard lf car tildewidecu whichrepresentsthepathfrom lftothefirstcallsitein tildewidecu and iii logicalandtext.
ci cdr cu guard entry ci ci whichissimilarlydefinedas tildewide f.givenasequence carreturnsitsfirstelementand cdrreturns the rest in the sequence.
we also check the feasibility of tildewide u and tildewide f implicitly by using an smt solver to enforce branch correlation.
stpis efficiently verifiable.
for leadsto tildewidecf lf leadsto tildewidecu lu tildewidecf tildewide f lf leadsto tildewidecu tildewide u lu .
for simequal we check tildewidecf tildewide f p simequal tildewidecu tildewide u q by querying pt2 tildewidecf tildewide f p andpt2 tildewidecu tildewide u q .
let us see how parenleftbigfree p ln4 use p ln7 parenrightbigin figure is reported as a uaf warning in stage with calling context reduction but removed as a false alarm in stage with path reduction .
in stage tildewidec ln4 tildewidec ln7 by applying .as ln4 leadsto ln7 and p ln4 simequal p ln7 since pt1 p ln4 o1 andpt1 p ln7 o1 o2 auafwarning is issued.
let us now apply .
we find that tildewide f cnd encodesthepathfromtheentryofthefunction foo toline4.similarly tildewide u cnd true true cndencodesthepathfromtheentry toline7vialine4.thus cnd ln4 leadsto cnd ln7 .weobtain parenleftbig tildewidec ln4 tildewideg ln4 parenrightbig parenleftbig tildewidec ln7 tildewideg ln7 parenrightbig braceleftbig parenleftbig cnd cnd parenrightbig bracerightbig .a s pt2 cnd p ln4 cnd o1 andpt2 cnd p ln7 cnd o2 we have cnd p ln4 negationslash simequal cnd p ln7 .
thus parenleftbigfree p ln4 use p ln7 parenrightbighas been filtered out as a false alarm.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hua yan yulei sui shiping chen and jingling xue implementation we have implemented cred in llvm .
.
.
the source files of a programarecompiledunder o0 intobit codeby clangfront end and then merged using the llvm gold plugin at link time to produceawholeprogrambcfile.fordebuggingpurposes llvmunder o1 orhigherflagsbehavesnon deterministicallyonundefined i.e.
undef values making bug detection nondeterministic.
wehaveimplementedourdemand drivenpointeranalysis by operating on the def use chains computed by the open source tool svf field sensitivelybutflow andcontext insensitivelyusing andersen s algorithm .
a program s call graph is built on the fly and points to sets are represented using sparse bit vectors.
instaticanalysis alinkedlistismodeledfinitely.thus anode inapoints tocycleisnotconsideredforuafdetection toavoid false alarms as it may represent many different concrete nodes.
arrays must be approximated in static analysis.
when computing leadstowith a pointer analysis arrays are considered monolithic.
when computing simequal we distinguish different array elements intraprocedurally.llvm s scalarevolution passisappliedtoreason about must aliases between two array accesses intraprocedurally.
pathguardsareencodedbybdds binarydecisiondiagrams usingcudd .
.
.forpathfeasibility isfeasible tildewide u in is checked by an smt solver known as z3 .
evaluation we show that cred is efficient and effective in detecting uaf bugs in real world programs without generating excessively many false alarms by answering three research questions rqs rq1 is cred effective in detecting existing uaf bugs?
rq2 cancredfind true uafbugsefficientlywithalowfalse positive rate in programs with millions of lines of code?
rq3 what are the patterns of uaf bugs detected?
.
methodology cred is fully automatic without requiring user annotations.
to answer rq1 and rq2 we compare cred with four state of the art source code analysis tools cbmc a bounded model checker for c c clang an abstract interpreter for c c in llvm coccinelle apattern basedbugdetectorforc and supa a flow and context sensitive demand driven pointer analysis for c used for detecting uaf bugs according to stsupain .toanswerrq3 weperformmanualinspectioninrealcode to check whether a reported uaf warning is a bug or not.
.
benchmarks to answer rq1 for ground truth we use all the c test cases in juliettestsuite jts including138knownuafvulnerabilities.
each test case consists of lines of code extracted from real worldapplications.toanswerrq2andrq3 inordertotest the practicality of cred we use widely used open source c applications totaling over mloc given in table .
.
experimental setup cbmcisconfiguredtorunasauafdetectorbyenabling pointer check anddisablingtheotherchecks.toensurethatcbmchandlesloops identically ascred as described insection .
.
every loop isunrolledbyspecifying unwind2 .toensuretermination thetable benchmarks.
program version kloc pointers frees uses bison .
.
curl .
.
ed .
grep .
ghostscript .
gzip .
phptrace .
redis .
.
sed .
zfs .
.
per program analysis budget for cbmc is set as days.
to use clang eachprogramiscompiledwith scan build.
configure and scan buildmake followingitsofficialusermanual .coccinelle isinvokedwith spatch sp file withtheuafpatternsspecified with its official uaf script osdi kfree.cocci .
supa is used for finding uaf bugs according to the analysis given in .
both supa and cred share the same pre analysis which is performedwithandersen salgorithm field sensitivelybutflow context andpath insensitively.inbothcases thebudgetforone points to query is set as the maximum number of def use chains traversable .
for any larger budget both supa and cred take longer to run but exhibit small improvements in precision.
for cred we apply one optimization in stage to reduce the human effort required in inspecting warnings.
considertwo warnings b1 parenleftbigfree p lf use q1 l1u parenrightbigandb2 parenleftbigfree p lf use q2 l2u parenrightbig with the same free site.
it suffices to reportb1only ifb1isabugwhenever b2isandb2isafalsealarm whenever b1is.
this happens if pt2 tildewidec1u tildewide 1u q1 includes all the objects in pt2 tildewidec2u tildewide 2u q2 and tildewide 2u tildewide 1u solved by z3 .
ourexperiments weredone ona3.
ghzintel core2duoprocessorwith128gbmemory runningredhatenterpriselinux5 .
.
.
the analysis time of a program is the average of runs.
.
results and analysis .
.1rq1 recall i.e.
hit rate .
we assess whether cred iscapableoflocatingthe138knownuafbugsinjts .asdisplayed in figure cred finds all the bugs just as cbmc and supa do but clang and coccinelle detect only and bugs respectively with no false alarms produced by any tool.
120credsupacoccinelleclangcbmc figure hit rates for the bugs in jts cbmc clang coccinelle supa and cred .
credachievesatotalrecall i.e.
a100 hitratein3.7seconds.
cbmc asaverificationtool alsoachievesatotalrecallbutin125.
seconds the longest among all the five tools.
supa as a sound pointer analysis achieves a total recall in .
seconds.
both clang and coccinelle miss some bugs.
clang finds only bugs in .
seconds with a hit rate of .
clang fails to detect out of uaf bugs for several reasons i it lacks a pointer analysis ii itperformsonlysomelimitedinterproceduralanalysis throughinlining and iii itreasonsaboutloopsveryconservatively.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
spatio temporal context reduction icse may june gothenburg sweden table experimental results t true positives bugs and f false positives i.e.
false alarms .
programcbmc clang coccinelle supa cred reporttimereporttimereporttimereporttime warnings context reduction reporttime t f secs t f secs t f secs t f secs pre cs ps before after t f secs bison .
.
curl .
.
ed .
.
grep .
.
ghostscript .
.
gzip .
.
phptrace .
.
redis .
.
sed .
.
zfs .
.
total .
.
coccinelle detects bugs in .
seconds.
it has missed bugs due to some unsound search space reduction heuristics used.
oneisconcernedwithmatchingafreesitewithitsusesites.given afreesite coccinelleexaminesonlytheusesitesreachablealong the forward edges in the program s call graph.
thus any uaf bugwillbemissedifitsfreesiteresidesinawrapper.anotheris related to the limited alias analysis in coccinelle.
given a free sitefree p coccinelleconsidersthealiasesfor pbytracking only the value flow of pforwards along the control flow via only a sequenceofcopyassignmentsontop levelvariables.thus analiasbetween pand q fora use q thatisformedbefore free p or indirectlyviaaddress takenvariablesintermsofloadsandstores will be missed.
all the bugs in jts are missed this way.
.
.2rq2 bug finding ability.
we assess how efficiently andeffectivelycredfindsnewuafbugsinthe10real worldappli cations .table2givestheresults.credissues132warningsincluding85bugsin27 334seconds .6hours startingfrom41 warningsissuedbyitspre analysis.however thefourexistingtools are either unscalable by terminating within days only for one application cbmc orimpracticalbyreportingvirtuallynobugs clang and coccinelle or excessively many false alarms supa .
cbmc does not scale yet to large codebases.
it spends seconds i.e.
.
hours in analyzing ed the smallest with kloc but cannot terminate for each remaining application in days.
as a result cbmc detects no uaf bugs as edis absent of uaf bugs .
clangreports3warningsincludingonly1 intraprocedurallydetectable bug whichisalsofoundbycred in1.2hours.interestingly clang has even a higher false positive rate than cred.
coccinelle reports warnings which are all false alarms by manualinspection in179.0seconds.coccinellefailstodetectanytruebugduetomainlyitstwounsoundheuristicsthataredescribed above in section .
.
.
specifically among the bugs detected by cred bugs require tracking the backward i.e.
return edges of wrappersforfreesites withoneexceptionin gzip which however requiresanalyzingthealiasingrelationsforaddress takenvariables.
inaddition allthe26bugsin sedand32bugsin zfsalsorequire the value flows of address taken variables to be tracked.
supa also starts with the same uaf warnings precomputedbycred spre analysis.beingsound supareportsthe same bugs foundby cred but also 180warnings with both asexpected .thesefalsealarmsarethespuriousspatio temporal correlations introduced in stsupain as motivated in section .
pre analysis context sensitive analysis path sensitive analysis figure11 percentagedistributionof cred sanalysistimes.
cred is effective in finding new uaf bugs in real world applications.byexaminingmanuallythe132warningsreported wefound to be bugs and to be false positives.
these false alarms are issued due to mainly imprecise handling of complex path conditions among others as explained in section .
.
clang finds only 1bugin gzip whichisalsofoundbycred amongthe3warnings reported.
the other warnings in sed are false alarms due to its lackofpointeranalysis.these2falsealarmsarenotreportedby cred.credisalsohighlyeffectiveinfilteringoutfalsealarmsin its two stages.
let wibe the warnings produced by stage i. the false alarm elimination fae rate at stage i where lessorequalslanti lessorequalslant2 is givenby wi wi wi .thetwostages csandpsintable2 are effective with their average fae rates being .
and .
.
credisalsoefficientinitstwostages asshowninfigure11 by using increasingly more precise yet more expensive analyses on handlingincreasinglyfeweruafwarnings asvalidatedintable2 .
in stage context sensitive analysis context reduction is significant as revealed in columns in table .
otherwise stage would run for 109days for the applications estimated based on the per query time consumed in implying that supa would be unscalable as its core pointer analysis pt1is used in .
given its effectiveness cred is the most scalable interprocedural uaf detector reported to the best of our knowledge .
cred spendsjust7.6hoursinanalyzingthe10applications totaling3 mloc .theanalysistimeforaprogramincludesthetimeselapsed initstwostagesanditspre analysis.forclangandcoccinelle ghostscript takes the longest to analyze since it is the largest with1693kloc.forcredandsupa redistakesthelongestsince ithasthesecondlargestnumberofuafcandidatepairs i.e.
pairs to be analyzed and complex constraints to be solved by z3.
.
.3rq3 understanding uaf bugs.
there are uaf bugsdetectedbycred.wefirstexaminetworepresentativepatterns in figures a and b and then discuss these bugs briefly.
figure a illustrates three uaf bugs found in sed counted as one in column in table as discussed in section .
.
under authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hua yan yulei sui shiping chen and jingling xue lib regexec.c reg errcode t re search internal ... for match first incr match last check matching mctx ... if match last reg error reg error return err idx check matching r e match context t mctx ... if be new entry null free mctx bkref ents returnreg espace reg espace mctx bkref ents .more mctx bkref ents .node node mctx bkref ents .str idx str idx a three uaf bugs in sed m m m m m m m deps lua src strbuf.c void strbuf free strbuf t s free s redis deps lua src lua cjson.c voidjson check encode depth ... strbuf t json strbuf free json voidjson append data ... strbuf t json json check enco de depth ... json json append array ... json ... voidjson append array ... strbuf t json ... strbuf append char json deps lua src strbuf.h voidstrbuf append char strbuf t s const char c s buf c b two uaf bugs in redis s bu s len figure a case study for some false alarms eliminated and some bugs reported by cred in real world applications.
a certain path condition the program frees mctx bkref ents line and returns an error flag reg espace line .
unfortunately the error is not captured later in line since reg espace nequalreg error causing the freed pointer mctx bkref ents to be dereferenced in lines .
figure12 b givestwouafbugs countedasoneincolumn19in table2 in redis.infunction json append data line660 jsonis indirectly freed in line by calling json check encode depth which in turn calls strbuf free line to free the object line113 .afterthat json append data calls json append array line with jsonpassed as a parameter where the freed object is accessed twice line resulting in two uaf bugs.
the85bugsdetectedbycredresidein grep gzip phptrace redis sedandzfs.precisepointeranalysisisessential.asmentionedearlier 58bugs including26in sedand32in zfs require analyzing aliases for address taken variables.
the other bugs which are found in grep gzip phptrace redisandzfs require analyzingtop levelpointersonly.the4bugsin zfswouldbemissed if some function pointers in the call sequence from their common callerstotheirusesiteswerenotresolvedaccurately.inaddition interprocedural analysis is also essential.
consider figure .
the averagecallsequencefromacommoncallertoafree use siteis .
.
with the longest being .
for only one out of the bugs its free and use sites reside directly in its common caller.
.
limitations as a static analysis cred can suffer from both false negatives and falsepositives.credcanmissbugsduetoitsunsoundmodelingof loops by analyzing two iterations its unsound handling of a linked list by ignoring its nodes participating in points to cycles and its unsound modeling of array access aliases by using llvm s scalarevolution pass for detecting must aliases .
in addition in non compliantcprograms whereoneusesapointerpointingto oneobjecttoaccessanotherobjectwithpointerarithmetic pointer analysis will be unsound resulting in potentially false negatives.
cred yields false alarms due to mainly i imprecise path reduction in and ii imprecise points to information for out of budget points to queries in traversing points to cycles .
related work detection.
almostall solutionsare dynamic instrumentationbased .
debugging tools such as valgrind and dr.memory candetectarangeofmemorycorruptionerrorsincludinguafbugsattheexpenseofhighruntimeandmemoryoverheads.addresssanitizer isanotherwidelyuseddynamictool.however itcan miss dangling pointers that when dereferenced point to an object that has reused the memory range.
undangle detects dangling pointers by performing a dynamic taint analysis.
its early detectionapproachcanincurhighruntimeoverheads.cets uses an identifier based scheme which assigns a unique key for each allocation region to identify dangling pointers.
it has an overhead of in order to provide complete memory safety.
static tools dedicated to uaf detection are scarce with focusingonbinarycode forthereasonsgiveninsection1.generalpurposememory safetycheckingtoolsthatcanbeusedtodetect uaf bugs include cbmc clang coccinelle and supa whichhavebeencomparedwithcred.specializedtools fordetectingothertypesofbugsexist.saturn detectsmemory leaks and null pointers by solving a boolean satisfiability problem.fastcheck andsaber findmemoryleaksonthe value flow graph of a program.
buffer overflows can be detected path sensitively or symbolically .
protection.
insteadofdetectinguafbugs protectionagainst their exploitation can be made.
for example control flow in tegrity prevents control flow hijacking attacks due to uaf buffer overflow exploits via runtime instrumentation.
however all fine grained solutions are toocostly to be deployed in production environments and all coarse grained solutions are bypassable .
cling represents a safe memory allocator that restricts memoryreusetoobjectsofthesametype.diehard anddieharder applyarandomizedmemoryallocatorbyprovidingprobabilistic safeguarantees.inthesecases uafexploitsaremadeharderbut noteliminated.alternatively freesentry anddangnull invalidatethedanglingpointersdetectedatruntime attheexpense of high runtime and memory overheads.
conclusion we present cred a novel static detector for finding uaf bugs anddemonstrateitseffectivenessandefficiencyinfindingallthe known uaf bugs in juliet test suite and new ones in multi mloc c applications.
cred achieves this level of scalability precisionand accuracy by making three advances i a context reductiontechnique for scaling cred to large codebases ii a multi stageapproach for filtering false alarms earlier and iii a field flow context and path sensitive demand driven pointer analysis for providing the precise points to information required.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
spatio temporal context reduction icse may june gothenburg sweden