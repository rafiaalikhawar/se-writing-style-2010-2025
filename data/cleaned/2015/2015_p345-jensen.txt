meminsight platform independent memory debugging for javascript simon holm jensen snowflake computing usa simon hjensen.netmanu sridharan samsung research america usa m.sridharan samsung.com koushik sen uc berkeley usa ksen cs.berkeley.edusatish chandra samsung research america usa schandra acm.org abstract javascript programs often su er from memory issues that can either hurt performance or eventually cause memory exhaustion.
while existing snapshot based pro ling tools can be helpful the information provided is limited to the coarse granularity at which snapshots can be taken.
we present meminsight a tool that provides detailed time varying analysis of the memory behavior of javascript applications including web applications.
meminsight is platform independent and runs on unmodi ed javascript engines.
it employs tuned source code instrumentation to generate a trace of memory allocations and accesses and it leverages modern browser features to track precise information for dom document object model objects.
it also computes exact object lifetimes without any garbage collector assistance and exposes this information in an easily consumable manner for further analysis.
we describe several client analyses built into meminsight including detection of possible memory leaks and opportunities for stack allocation and object inlining.
an experimental evaluation showed that with no modi cations to the runtime meminsight was able to expose memory issues in several real world applications.
categories and subject descriptors d. .
testing and debugging keywords memory pro ling leak detection .
introduction javascript has become a popular mainstream programming language.
it is the lingua franca of the web and is making inroads into other settings such as servers via node.js .
however developer tools for javascript still lag behind those figure number of objects in memory for three moves in annex as shown by meminsight.
the xaxis represents logical time.
for better established languages like c and java including tools for memory pro ling.
though free of traditional memory leaks javascript programs often su er from memory issues seen in other garbagecollected languages.
it is common to nd avoidable instances ofdrag i.e.
objects reachable in the heap past their last use if such objects never become unreachable they are considered leaked .
javascript programs also su er from churn i.e.
frequent heap allocation of short lived objects and bloat i.e.
wasteful representation of data.
it is common to nd mistakes in the way javascript objects and the objects in the browser s document object model dom interact causing insidious dom leaks.
moreover although javascript frameworks such as jquery are intended to make web programming simpler it is easy to introduce memory problems via incorrect use of framework apis.
as a concrete example of drag consider figure which shows the number of objects in memory over time in annex a reversi style game implemented as a web application.
t1 t2 and t3 denote the start of the machine s computation of its move in response to the human player s rst three moves respectively.
the blue upper curve shows the number of objects reachable in the heap the orange lower curve shows the number of stale objects reachable in the heap.
an object is stale if it is reachable in the heap but will not be used again in the current execution.
such objects can waste space since they cannot be reclaimed by the garbage collector.
although the memory for computation of the machine s move is de allocated right after the computation the peak memory consumption per move is increasing and much of the memory is stale.
if there were a way to release this stale memory early or not allocate it to begin with then the program s peak memory usage could be much lower.
in fact using our tool we were able to refactor this program to reduce its peak memory usage substantially see section .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
esec fse august september bergamo italy acm.
... .
345a common approach to debugging memory issues in javascript applications is to take periodic snapshots of the heap as implemented for example in the chrome developer tools cdt .
cdt allows for visualizing various useful properties of a heap snapshot e.g.
a count of objects of each type as determined by its constructor and the access paths to those objects.
the recommended way to diagnose memory issues with cdt is to compare di a series of snapshots and see if the counts of certain types of objects unexpectedly increase indicating a possible memory leak.
while useful the snapshot approach su ers from the key limitation that it misses many transient behaviors that occur between snapshots.
for example if snapshots were manually taken between computer moves for the execution shown in figure e.g.
at times t2 and t3 they would completely miss the staleness problem in this app.
in fact with snapshots alone one cannot determine whether an object is stale or not.
snapshots may also miss object churn issues as a large number of short lived objects may get allocated and collected between successive snapshots.
for c and java developers a number of techniques and tools have been developed e.g.
valgrind that go beyond heap snapshots to provide very detailed visibility into a program s memory usage and possible problems .
these techniques often modify language runtimes to monitor memory behaviors and apply various heuristics such as heap growth and object drag to detect memory problems.
however there are several challenges in simply porting these techniques and tools to javascript and web applications.
first javascript programs can be written for various platforms such as desktop browsers browsers on mobile operating systems such as tizen thewebviewer component of ios and node.js all running di erent javascript engines having di erent native apis.
therefore it is not possible to develop a universal javascript memory debugging tool which works for all platforms by modifying a single javascript engine.
second javascript engines of browsers can access create and manipulate dom components of a browser.
such interactions allow objects to move from the javascript world to the dom world and vice versa.
such data interactions across the language boundary create unique challenges when one cannot monitor memory behaviors by modifying a javascript engine.
to address these challenges we have developed meminsight a browser independent extensible memory debugging tool for javascript and web applications.
the tool works by instrumenting javascript programs and can run on any platform that provides a standard javascript engine.
the overall architecture of meminsight is shown in figure .
first javascript code a is instrumented such that exercising instrumented code b yields a trace c of operations relevant to memory analysis described in section .
.
to trace dom related memory behaviors meminsight uses modern browser features to asynchronously observe dom mutations and employs select additional modeling to record informative allocation sites for nearly all dom nodes in practice details in section .
.
a separate lifetime analysisrecovers object lifetime information from the trace by simulating the application s heap and combining reference counting with the merlin algorithm see section .
.
both the lifetime analysis and trace generation phases are carefully designed to handle unusual cases arising due to uninstrumented code and native library code section .
.the lifetime analysis produces an enhanced trace d that includes object unreachability events.
finally a number of client analyses compute useful additional information based on the enhanced trace such as potential memory leaks drags churns and opportunities for stack allocation and object inlining section .
the results are shown in a web based gui.
meminsight is fully extensible the enhanced trace generated by meminsight can be queried to implement other client analyses.
we observed that simply reporting a memory problem is often not su cient to e ectively debug the problem.
meminsight provides useful diagnostic information call tree and access paths for the objects responsible for a memory problem.
a call tree shows us the calling context in which the problematic objects got allocated and the access paths reveal the chain of objects that is holding the problematic object and is preventing it from getting garbage collected.
these information help developers to e ectively understand and x the memory problems reported by meminsight .
a key advantage of meminsight is that it is browser agnostic and requires no modi cation to a javascript runtime.
as such the tool is usable across a variety of javascript environments including desktop browsers browsers on mobile operating systems like tizen and node.js on the server.
beyond the need for portability building the tool without runtime modi cations brings advantages in maintainability and deployability.
javascript runtimes and browsers evolve very quickly making maintaining a modi ed runtime while retaining support for the latest browser features an enormous challenge.
deployment also becomes di cult with a modi ed runtime as users must download and use a custom browser build for pro ling purposes.
for all these reasons we focused on developing a browser independent instrumentation based approach to memory pro ling.
inmeminsight we addressed several challenges that arose due to our pragmatic decision to keep meminsight browser independent reasoning about an object s staleness requires determining when the object becomes unreachable.
however javascript does not provide any built in method for determining when an object is garbage collected from which unreachability times can be computed .
hence we had to reconstruct object lifetime information in meminsight with no support from the javascript runtime.
tools such as valgrind typically assume that they are able to observe allmemory accesses in a program.
for web applications this assumption is very hard to satisfy without browser modi cation due to various native libraries and the dom.
furthermore a user might wish to purposely exclude certain frameworks from instrumentation.
we designed meminsight so that it is resilient to passing of objects back and forth between instrumented and uninstrumented code.
the dom and its manipulation via javascript present special challenges.
dom manipulation can be performed via a wide variety of apis that would be di cult to model exhaustively.
also the notion of staleness for a dom node should take into account whether it is visible on the web page which is not evident when just tracing memory accesses.
finally javascript is a complex language and dealing with features such as closures constructors getters and a javascript code b instrumented javascript code instrumentor c trace d enhanced trace life me analysis run client analyses gui figure meminsight tool chain setters etc.
is not straightforward particularly when instrumenting source code rather than a normalized intermediate representation within a runtime.
to the best of our knowledge no previous work has shown how to address all of these challenges together in a realistic and practical tool that runs on unmodi ed browser runtimes.
we consider this as our key contribution.
we performed an experimental evaluation to test both the overhead and usefulness of meminsight on a variety of benchmarks.
meminsight incurred a reasonable .7x mean slowdown for the compute intensive octane benchmarks with the slowdown being hardly noticeable for more typical web applications.
thus far meminsight has been used to discover or con rm memory issues in ten web and node.js applications with several issues discovered by a product group at samsung using the tool.
in three cases we submitted patches to x discovered issues that were merged by the developers.
meminsight is publicly available at samsung meminsight .
a replication package for meminsight has been successfully evaluated by the replication packages evaluation committee and found to meet expectations.
we believe that meminsight can be modi ed and extended easily even if a researcher developer is not an expert in the internals of a javascript engine.
the rest of the paper is organized as follows.
section gives a detailed overview of debugging a memory issue with meminsight .
the di erent phases of meminsight are outlined in sections and as described above.
sections and respectively present case studies showing meminsight s effectiveness and a quantitative evaluation.
finally section discusses related work section discusses limitations and section concludes.
.
debugging with meminsight in this section we highlight the use of meminsight from a user s perspective.
we present an example illustrating the types of memory leaks often present in web applications and show how meminsight s features combine to help diagnose the problem.
a small jquery based example is shown in figure based on a real drag issue found in our shopping list case study see section .
in function f a new divdom node is allocated into variable newdiv line made to contain the text hello world line and attached to an existing dom node identi ed by the id contents line .
an event handler function is attached to the newly allocated node lines which changes the background color when a user clicks on the div.
in function g the developer removes this new divfrom the dom by assigning an empty string to the innerhtml property of the contents node line .
alas there is a memory problem.
the jquery framework caches event handlers associated with dom nodes and clears the cache only when a node is removed using a proper jquery1function f var newdiv div newdiv.html hello world newdiv.click function newdiv.css backgroundcolor red newdiv.appendto contents function g document.getelementbyid contents .innerhtml figure scr orig.js a small leak example api call e.g.
in this case contents .empty .
since the developer removed the node via innerhtml instead the event handler closure remains in jquery s cache and becomes stale as it does not get used again.
since the event handler uses variable newdiv line a reference to the divelement remains in its closure causing the dom element itself to also drag this is known in the developer community as leaking of dom nodes as it a common issue in web applications.
we will use the terms leak and drag interchangeably.
closure related drags are common in javascript programs as even local variables unrelated to the function for which the closure is created can get retained by the closure extending their lifetimes inadvertently.
assume that the creation of newdiv and buggy removal of that node by assignment to innerhtml is repeated a few times.
how does one begin to notice a memory problem?
as discussed in section meminsight reports which objects are stale and will not be used again using an analysis for computing object lifetimes.
figure shows screen captures from the meminsight gui.
the time line chart a shows the count of all objects with time in blue as well as all stale objects with time in orange .
the increasing count of stale objects is a cause for concern.
the pie chart on the right shows which allocation sites are the leading contributors to stale objects.
if we click on the pie chart slice for line of scr orig.js meminsight o ers details for that allocation site shown in figure c .
we see a timeline chart for only the objects allocated from that site a call tree leading up to that site here it is called from main and on demand access paths to objects allocated at that site.
the access paths show that the function object is held on by a cache internal to jquery.
we illustrate a case of dom leak as well.
going through the list of sites that meminsight nds having a high count of stale objects we come across the dom nodes allocated at line in jquery.
for a dom node d staleness means that dis unused detached from the document tree for the last time hence not to be displayed again and reachable from some javascript variable.
a b c figure a c. memory pro ling for the example in fig .
b. call tree and access paths for jquery line .
how does the user associate the allocation of dom objects at line in jquery to the program in figure ?
details provided by meminsight for line show the call tree and access paths shown in figure b which informs us that the allocation is the result of the function called at line in figure .
but why does it show increasing staleness?
the access paths reveal the answer the variable newdiv is in the closure of the handler allocated at line in figure .
we previously saw why the latter was leaking.
this now shows that inadvertently that causes a dom node leak as well.
incidentally to discover dom staleness a tool must know the structure of the dom as it evolves noting when dom nodes become detached from the main tree.
this information is not evident from javascript execution alone for this example the nodes are allocated by calling the native method createelement and become detached from the main dom due to the write to innerhtml at line in figure .
mem insight s dom modeling techniques enable it to handle this case correctly.
.
trace generation and lifetime analysis in this section we detail the trace generation and lifetime analysis functionality of meminsight .
basic trace generation described in section .
uses source instrumentation to log a detailed trace of an execution s memory operations.
the lifetime analysis described in section .
uses this trace to compute exact object lifetimes yielding an enhanced trace.
beyond this core functionality we also describe meminsight s carefully designed handling of uninstrumented code in section .
and dom apis in section .
.
finally we discuss handling of various tricky javascript constructs in section .
and in section .
we describe key optimizations that help to reduce meminsight s overhead.
3481var x 2var y 3function m p q p.f q 7m x y 8x null declare x y m allocobj at write x at allocobj at write y at allocfun at write m at call at declare p q putfield f at lastuse at return at lastuse at write x at unreachable at unreachable at end unreachable at end figure a simple code example and the corresponding trace.
red entries are added in the enhanced trace.
.
basic trace generation our generated traces must be su cient to reconstruct object lifetimes i.e.
when objects are created and become unreachable.
at a minimum traces must include records of each object allocation and each memory write both to variables and to object elds properties in javascript parlance .
a javascript delete operation on an object which removes a property is modeled as a write of null.
to enable proper handling of javascript functions and closures in the lifetime analysis the generator logs calls and returns and also logs declarations of local variables.
finally to enable reasoning about object staleness we also log information about uses of each object an object is used when it is dereferenced or for function objects when it is invoked.
by default meminsight enables two optimizations that reduce trace size and instrumentation overhead.
first we avoid logging writes when the old and new values are both of primitive type such writes are irrelevant for reasoning about object staleness and leaks.
similarly by default we only log the lastuse of each object rather than all uses since this information is su cient for detecting staleness.
these optimizations can be disabled at some cost in overhead see section in case the additional information would be useful for some client analysis e.g.
object equality pro ling further discussion in section .
figure shows the generated trace for a simple example.
most entries includes a source location at the end.
the allocation entries introduce a unique id used to name the corresponding object throughout the trace.
we use a distinct entry type to identify function object allocation to ease handling of closures in the lifetime analysis.
in our implementation lastuse entries include a timestamp and appear at the end of the generated trace since the last use is only known at the end of the program a separate post processing phase inserts the entries at the appropriate slots.
.
lifetime analysis here we describe how our lifetime analysis computes exact object lifetimes based on the initial trace inserting unreachable events into an enhanced trace shown as the red events in figure .
heap graphs the trace as described in section .
enables simulation of the execution s heap graph.
at each allocobj andallocfun trace entry a new vertex is added to the graph.
at each putfield entry an appropriate heap graph edge labeled with the eld name is added and or removed.1var elem document.createelement div 2elem.innerhtml p h1 hello world!
h1 p 3document.getelementbyid x .appendchild elem figure example to illustrate handling of domrelated code.
reasoning about variable writes in the presence of javascript closures is non trivial particularly since functions can update closure variables.
for example function f var x p o1 y o2 return set function z x z get function return x var r f r.set null here xis present in the returned setandgetclosures with updates via setre ected in future calls to get but yis not since it is not referenced by any nested function.
hence the object labeled o2above becomes unreachable after the call tof but o1remains reachable until after the call to r.set .
the heap graph construction handles closures using an approach similar to the cactus stack method of implementing rst class continuations .context nodes in the heap graph represent variable bindings for closures with parent pointers for lexical scoping.
a separate syntactic analysis computes which variables from enclosing scopes are captured by each function enabling a context to be sealed at function returns to remove pointers to uncaptured objects.
for the example above when the call to fcompletes sealing removes the outgoing edge from the context corresponding to variable y. we correctly handle corner cases in javascript semantics e.g.
writing to an undeclared variable creates a fresh global.
exact lifetimes given our simulated heap graph we use standard reference counting to compute exact unreachability times for all objects except those in cyclic data structures which reference counting cannot handle.
to handle cyclic structures we adopt techniques from lazy cycle collection .
whenever an object o s reference count is decremented to a non zero value ois placed in a cycle queue as it may be in an unreachable cycle.
to detect the true cycles we periodically perform a mark sweep over the heap sweeping only from unmarked nodes in the cycle queue su cient since the base reference counter handles acyclic structures .
to detect exact unreachability times for nodes in cycles we adopted the merlin algorithm .
whenever a node is placed in the cycle queue it is stamped with the current time .
if the node is already in the queue its timestamp is updated.
when sweeping unmarked queue nodes the queue is rst sorted by descending timestamp.
after this sort we are guaranteed that the node nin or reachable from an unreachable cycle with the latest timestamp twill be processed rst and that tis the true unreachability time for any unmarked node reachable from n. so we simply propagatetas the unreachability time for all unmarked nodes encountered from n. the merlin algorithm is presented in detail in hertz et al.
an extended version of the paper contains an example of applying the technique.
.
uninstrumented code meminsight works robustly in the presence of uninstrumented javascript code or native code from the environment.
349in principle uninstrumented code could arbitrarily mutate any memory locations to which it has access.
attempting to discover all such behavior via code instrumentation alone would be di cult or impossible particularly since invocations of uninstrumented code may not be observable e.g.
a browser invoking an uninstrumented event handler .
furthermore such detection would require frequent re ective traversals of all heap state visible to uninstrumented code a very costly operation.
in practice we have found a policy of only tracking