assertionguidedsymbolicexecution ofmultithreadedprograms shengjianguo virginiatech blacksburg va usa markuskusano virginiatech blacksburg va usa chaowang virginiatech blacksburg va usa zijiangyang westernmichiganuniversity kalamazoo mi usa aartigupta princetonuniversity princeton nj usa abstract symbolic execution is a powerful technique for systematic t esting ofsequentialandmultithreadedprograms.
however itsapp lication islimitedbythehighcostofcoveringallfeasibleintra th readpaths and inter threadinterleavings.
wepropose a new assertion guided pruningframeworkthatidentifiesexecutionsguaranteedno ttolead toanerror andremoves them duringsymbolic execution.
bysu mmarizing the reasons why previously explored executions ca nnot reachanerrorandusingtheinformationtopruneredundante xecutionsinthefuture wecansoundlyreducethesearchspace.
w ealso usestaticconcurrentprogramslicingandheuristicminimi zationof symbolic constraints tofurtherreduce thecomputational o verhead.
we have implemented our method in the cloud9 symbolic execution tool and evaluated it on a large set of multithreaded c c programs.
our experiments show that the new method can reduc e theoverallcomputationalcostsignificantly.
categoriesandsubjectdescriptors f. .
specifying and verifying and reasoning about programs d. .
software programverification keywords symbolic execution test generation concurrency partia l order reduction weakestprecondition .
introduction the past decade has seen exciting developments on symbolic execution of both sequential and concurrent p rograms .
however existing methods are still li mited in their capability of mitigating the state space explosion .
that is thenumberofpathsineachthreadmaybeexponential tothenu mber of branch conditions and the number of thread interleav ings maybeexponential tothenumber ofconcurrent operations.
m any techniques have been proposed to address this problem incl uding theuseoffunctionsummaries interpolation static permission to make digital or hard copies of all or part of thi s work for personalorclassroomuseisgrantedwithoutfeeprovidedth atcopiesarenot madeordistributed forprofitorcommercial advantage andth atcopiesbear thisnoticeandthefullcitationonthefirstpage.
copyright sforcomponents ofthisworkownedbyothersthanacmmustbehonored.
abstrac tingwith creditispermitted.
tocopyotherwise orrepublish topos tonserversorto redistribute tolists requirespriorspecificpermissiona nd orafee.
request permissionsfrompermissions acm.org.
esec fse august31 september bergamo italy.
copyright 2015acmx xxxxx xx x xx xx... .
.summary executions computing pruning no no yes yes symbolic execution in sch in sch in sch flipb pp?
end flipi pp?
initial slicing static testinput figure1 ourassertionguidedpruningframework.
analysis and coverage metrics .
in this paper we pr opose a new and complementary method which is designed specifical ly forpruningredundantexecutionsinmultithreadedprogram swhere thepropertiesunderverificationareexpressedasassertio ns.
our assertion guided symbolicexecutionframeworkfocuses on identifyingandeliminatingexecutionsthatareguarantee dtoberedundant for checking assertions.
assertions can be used to m odel awidevarietyofinterestingproperties rangingfromlogi candnumerical errors to memory safety and concurrency errors an d has beenthefocusofmanysoftwareverificationprojects.
whens emantic errors of the program are modeled as simple code reachabi lity i.e.
the reachability of a bad state guarded by the assertio n condition we can concentrate on exploring potentially failure inducing executions as opposed to all feasible executions of the prog ram.
thisisparticularlyattractiveinthepresence of concurrency since it becomes possible to uniformly handle the exploration of b oth intra thread execution paths and inter thread interleavi ngs leading toasimplebutmorepowerfulanalysisalgorithm.
the overall flow of our new method is illustrated in figure the shaded block represents our addition and the remainder i llustrates the classic symbolic execution procedure for multit hreaded programs .
specifically givenaprogram pandsomesymbolic input variables the procedure explores the feasible execu tions of theprogramsystematically e.g.
inadepth firstsearchor der.
starting with an initial test in sch consisting of inputs and threadschedule themethodfirstproducesaconcreteexecut ionfollowed by a symbolic execution.
then it tries to generate a ne w testbyflippingapriordecisionateitheraninterleavingpi votpoint i pp oralocalbranchpivotpoint b pp .thenewtestisde noted by either in sch or in sch depending on whether changes are made to the thread schedule sch or data input in respectively.
theiterativeprocedure terminateswhennonew test canbe generated.
stateexplosionoccursbecauseithastoexplore thecompermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
854bined space of inputs and thread schedules where each indivi dual executionmaybeunique i.e.
itleadstoadifferentprogra mstate.
we extend the baseline algorithm by adding a constraint bas ed pruningblockshowninfigure1 whichcentersaroundtheide aof summarizing the reasons whythe bad state is unreachable via previously explored executions and leveraging such informat ion to avoid similarly futile executions.
specifically at each gl obal controllocation n weuseapredicatesummary ps constrainttocapturethe weakestpreconditions oftheassertionconditionalong allexploredexecutions startingfrom n. therefore ps captures the reason why prior executions are not able to violate the as sertion.
whenever symbolic state nis reached again through another executionpath wecheckifthenew pathcondition issubsumedby ps .
if so we can safely backtrack from nsince extending the executionbeyond nwouldneverleadtoabadstate.
our method for pruning redundant executions can be viewed as a wayof systematicallyexploring anabstract searchspace d efined by a set of predicates which in this case are extracted f rom the assertion.
although the concrete search space may be arb itrarily large the abstract search space can be significantly sma ller.
in this sense our method is similar to predicate abstraction in model checking except that the latter requires constructin ga priori a finite statemodel from the actual software code whereas ou r method directly works on the software code while leveraging the predicatestoeliminateredundantexecutions.
our method complements partial order reduction por techniques in that it relies on property specific information to reduce thestatespace.
but portechniques typicallydonot target particularstates.
wewillshowthroughexperimentsthatournewme thod canindeedeliminateadifferentclassofredundantexecuti onsfrom those eliminated by state of the art por techniques such as dynamicpartialorderreduction dpor .
towardthisend since dporisanelegantbutdelicatealgorithm thatcaneasilybem ade unsound without taking great care in the implementation a maintechnicalchallengeinourworkistomakesureournewpr uningmethoddoesnotinterferewithdporormakeitlesseffect ive.
ourmethoddiffersfrompriorworksbywachteretal.
an d chu andjaffar whichextended the frameworkof lazyabst raction with interpolants to multithreaded programs.
one main differenceisthatourcomputationofpredicatesummariesi ssignificantlymoregeneralthanexistingmethods especiallyatt hethread interleaving pivot points where we merge summaries from mu ltiple execution paths to form a combined summary.
another main difference is in the integration of property specific prunin g with partialorderreduction.
bothexistingmethodsimplemente davariant of thesymbolic partialorder reduction algorithmby kah lonet al.
whereasweintegrateourpredicatesummary basedp runing methodwiththemorescalabledporalgorithm.
wehaveimplementedourmethodin cloud9 astate of theartsymbolicexecutiontoolformultithreadedc c progra ms. we have implemented an inter procedural static program slici ng algorithm executed priortosymbolicexecution tofurthe rreduce the search space.
we have also implemented heuristic based m inimizations of predicate summary constraints during symbol ic execution to reduce the computational overhead.
in both cases the maintechnicalchallengeistoensuretheoverallalgorithm remains sound in the presence of such optimizations.
we have conduct ed experimentsonasetofstandardmultithreadedc c applic ations.
our results show that the new method can reduce the number of exploredexecutionsaswellastheoverallruntimesignifica ntly.
tosumup thispapermakesthefollowingcontributions we propose anassertion guided symbolic execution method for eliminating redundant executions in multithreaded pro gramstoreducetheoverallcomputationalcost.
weimplementourmethodinastate of the artsymbolicexecutiontool whileensuring itdoes not interferewiththe pop ulardporalgorithmormakeitlesseffective.
we demonstrate through experiments that our new method can indeed achieve a significant performance improvement onpublicbenchmarks.
the remainder of this paper is organized as follows.
first w e illustrate our new method through examples in section the n establishthe notationand review the baseline symbolic execu tion algorithm insection .
we present our method for summarizing e xplored executions in section and pruning redundant execut ions insection5.
we present optimization techniques insection 6and experimental results in section .
we review related work in section8andfinallygiveourconclusionsinsection9.
.
motivatingexamples in this section we illustrate the high level ideas in our me thod using examples.
consider the example infigure whichhas t wo threads t1and t2 a global variable x and two local variables a and b. the initialvalue of xis a symbolic input which can be any integer value.
we want to check if the assertion fails and if so computeafailure inducingtestinput.
x symbolic v if x return x a x x b x assert a b x a x a x n1 n2 n4 n7n5n3 n6 n8 n9a x x x x x b x b x b x x x run run run run run a b run1 if x x x a x b x leadsto a b .
run2 if x x a x x b x leadsto a b .
run3 if x x a x b x x leadsto a b .
run4 if x a x x x b x leadsto a v b .
run5 if x a x x b x x leadsto a v b .
run6 if x a x b x x x leadsto a v b v .
a x n1 n2 n4n3 n6b x x x n5 n7 n7 n7 n8 n8x n8x n5 a x a x b x b x x b x b x x x x b x x x n9 a b n9 n9 n9 n9 n9 a b a b a b a b a b figure2 ourmethodhastoexploreonefullrunandfourpartialruns asopposedtoallsixrunsbyexistingmethods.
855theprogramhassixdistinctexecutions eachleadingtoadi fferent final state defined by the values of aand b. according to the theory of partial order reduction they belong to six di fferent equivalence classes as each has a different final state .
however exploring all six executions is not necessary for the p urpose ofcheckingtheassertion sincesomeoftheseexecutions sh arethe samereasonwhytheycannotreachthebadstate.
ournewmetho d can reduce the exploration from six executions to one full ex ecution together with four partial executions as illustrated by the red dottedlinesinfigure2.
our method first extracts a set of predicates by computing the weakestpreconditionsoftheassertionconditionalongthe explored executions.
thesepredicatesarethencombinedatthemerge points inthegraph toformasuccinct summarythatcaptures there ason whythebadstatehasnotbeenreachedviaexecutionsstartin gfrom these merge points.
during subsequent symbolic execution i terations ourmethodneedstoexploreonlythoseexecutions tha thave not be covered by these predicates thereby leading to a soun d reductionofthesearchspace.
now weexplainhowourmethodworksonthisexample run is the first and only execution fully explored which goes through nodes n1 n2 n4 n7in the graph in figure beforeexecuting b x if a b .sinceitdoesnotviolation theassertion wesummarizethereasonat n9and n7 respectively asfollows ps a b and ps a x .
that is as long as a x holds at node n7 it would be impossiblefortheexecutiontoreachthebadstate.
run goes through n1 n2 n5before reaching n7 where its path condition is pcon v and symbolic memoryis m a x .
since pcon ps under m meaning the set of reachable states falls inside ps continuingtheexecutionfrom n7wouldnotleadtoa badstate.
therefore weskiptheremainderofthisexecutio n. run goes through nodes n1 n2 n5 n8before reaching n9 where its path condition again falls within ps .
we skiptheremainderofthisexecutionandupdatethesummary atn8and n5as follows ps a b and ps wp wp a a x .
by conjoining theweakestpreconditionsalongbothinterleavings n5 n7 and n5 n8 we capture the summary common to both interleavings.
run goes through nodes n1 n3before reaching n5 with thenewpathcondition pcon v andsymbolic memory m a v x .
since pcon ps under m weskiptheremainderofthisexecution whichwould haveledtorun4andrun5ifitisallowedtocontinue.
run goes through nodes n1 n3 n6before reaching n8 wherethenewpathconditionfallswithin ps .
therefore weskiptheremainderofthisexecution.
atthismoment ourmethodhascompletedtheexploration.
note that we conjoin weakest preconditions from different interleavings at i pp nodes such as n5 butunion them from different thread localpathsatb ppnodes seesection4.
alsonotet hatthe amount of reduction achieved by our method depends on the pro gramstructureaswellasthelocationoftheassertion.
fore xample if we change if x to if x our method would have to explorerun5insteadofskippingitbecause pcon v wouldnolongerbesubsumedby ps v .
this example demonstrates that our method differs from partial order reduction techniques such as dpor which coul d not prune away any of the six interleavings.
furthermore ou r method also differs from the stateful state space explorati on techniques commonly used in model checking which record the for ward reachable states explicitly during exploration to pre vent vis x y z a x x assert a b y y assert b c z z assert c x y z b a c run1 a x x if a b y y if b c z z if c .
run2 a x x if a b y y if b z c z if c .
run3 a x x if a y b y if b c z z if c .
run4 a x x if a y b y if b z c z if c .
run5 x a x if a b y y if b c z z if c .
run6 x a x if a b y y if b z c z if c .
run7 x a x if a y b y if b c z z if c .
run8 x a x if a y b y if b z c z if c .
figure3 ourmethod canreducethenumberof executions from 2kdownto k .
iting them again.
such methods would not be effective for the example in figure either because each of the six executions le ads to a distinct state.
in contrast our new method can achieve a significant reduction due to its use of property specific informa tion as guidance.
in this sense our new method is a property directed reduction whereastheportechniquesare property agnostic .
however it can be tricky to combine our pruning method with thestate of the artdporalgorithm.
themainadvantageof dpor overstaticporliesinitsdynamicupdateofbacktracksets which uses runtime information to compute the dependency relatio n between shared accesses.
without taking any additional measu re pruning redundant executions may interfere with the dynami c update of backtrack sets in dpor.
consider run in figure as an example.
if the execution is allowed tocomplete when b x is executed thread t2will be added to the backtrack set of node n3.
however ifrun4isterminatedpre maturelyatnode n5duetoour predicate summary based pruning thread t2would not be added to the backtrack set of node n3since b x has been skipped.
as a result the dpor algorithm would not explore run .
therefo re integrating dpor with property specific pruning is a challen ging task.
wepresentoursolutiontothisprobleminsection5.
.
ourcomputation ofpredicate summaries atthe threadinterl eaving merge point n5in figure shows that it is different from the prior work by wachter et al.
and chu and jaffar .
spec ifically we combine the summaries from all outgoing edges by co njoining them whereas existing methods do not merge interpo lants at these i pp nodes.
furthermore these existing methods im plemented symbolic por whereas our method is integrated with th e morescalabledpor.
now we use the example in figure to demonstrate that our new method has the potential to achieve an exponential reduc tion.
inthiscontrivedexample theinterleavingofinstruction s in a x x is completely independent from b y y and c z z .
exploring all feasible executions results in 23runs each of whichleads toadifferent final state.
however based onth e abstract searchspace induced by the assertions our new metho d can reduce the exploration of eight runs down to one full run toge ther with three partial runs as marked by the symbol in figure .
to further generalize the example a program with kindependent code segments would have 2kdistinct interleavings which can be reducedbyourmethodto k executions.
.
preliminaries we establish the notation and review the baseline symbolic e xecutionalgorithmformultithreadedprogramsinthissectio n. .
multithreadedprograms for ease of presentation we consider a simple imperative la nguage with integer variables assignments and if else sta tements only.
we elide the details for handling of complex language f eatures such as pointers recursion and system calls in symbo lic execution since these are orthogonal issues addressed previo usly by many symbolic execution tools .
a multithreaded prog ram pconsists of a set of threads t1...t m where each thread ti is a sequential program.
threads share a set of global variables.
eachthreadalsohasasetof local variables.
letst be an instruction in a thread with the thread index tid .
letevent e an bracketle ttid l st l an bracketri htbe an execution instance of st where land l are locations in the thread before and after executing the instance of st .
if the same instruction is executed more thanonce e.g.
whenitisinalooporarecursivefunctioncall wemake copies of l st l to make them unique for each event.
conceptually this correspondstounrollingloopsandrecursivecalls.
a globalcontrol state of the multithreaded program is a tuple s an bracketle tl1 ... l m an bracketri ht where each liis a location in ti.
we regard a global control state as an abstract state implicitly containing all concrete states that have the same thread locations but potentially different va lues of thelocalandglobalvariables.
withoutlossofgenerality weassumethateveryassertiono fthe form assert c is transformed to if !c abort .
we use a special eventabortto denote faulty program termination and haltto denote normalprogramtermination.
let vldenote alocalvariable vgdenote a global variable cond ldenote a local condition and exp ldenoteanlocalexpression.
inadditionto abortand halt each instruction st inaneventmayhaveoneofthefollowingtypes operation whichisalocalassignment vl exp l operation whichisalocalbranch assume cond l operation whichisaglobaloperationdefinedasfollows iisaglobalwrite vg exp lorread vl vg iiisathreadsynchronizationoperations.
for each if c else statement we use assume c to denote the execution of then branch and assume c to denote the execution of else branch.
without loss of generality we assum e that all if else conditions use only local variables or local cop ies of global variables .
for thread synchronizations we foc us on mutexlocks andconditionvariablessincetheyarefrequent lyused in mainstream multithreaded programming environments suc h as c c andjava.
specifically we consider thefollowingtyp es of ii operations thread creation thread join lock unlock signal and wait.
if other thread synchronizations or blocking oper ations areusedtheycanbemodeledsimilarlyas iievents.
duringtheprogramexecution operationsarethreadinterleaving points whereas operations are thread local branching points.
both contribute to the path interleaving explosion.
in con trast operations arelocalandthusinvisibletootherthreads th eydonot contributedirectlytothepath interleavingexplosion.
aconcrete execution of the multithreaded program is characterized by in sch where in is the data input and sch is the thread schedule corresponding to the total order of ev ents e1...e n. the corresponding symbolic execution is denoted by sch where the indicates the data input is kept symbolic and thus maytake anyvalue.
eachexecution ofthe program pcanbe representedbyafiniteword halt abort .
iftheexecution ends with haltit is a normal execution.
if the execution ends with abortitisa faulty execution.a1 a x a2 if a a1 else a1 a3 a y a4 if a a2 else a2 a5 b1 b x b2 if b b1 else b1 b3 b y b4 if b b2 else b2 b5 a3 b a3 b a1 b a3 b a5 b a1 b a3 b a1 b a5 b a5 b a1 a2b1a1 b1 b1b1 b2b1 b1b1 a1 a1a1 a2 a2 a2a2a1 a2 b a4 b b1 b2 run ii run i run iiia2 a5 b a5 b b1 b1 a1 b a1 b a2 b a4 b a3 b a4 b figure4 atwo threadedprogramanditsgeneralizedinterleavinggraph gig .blackedgesrepresenteventsfromthre ad t1andblueedgesrepresenteventsfromthread t2.
.
generalizedinterleavinggraph gig the set of all possible executions of a multithreaded progra m canbe captured bya generalized interleaving graph gig where nodesareglobalcontrolstatesandedgesareevents.
theroo tnode correspondstotheinitialstate.
leafnodescorrespondton ormalor faultyendsoftheexecution.
eachinternalnodemayhave oneoutgoingedgecorrespondingtoan operation twooutgoingedgescorrespondingtoa operation or koutgoing edges where k 2is the number of enabled operationsfromdifferentthreads.
wecallanodewithmorethanoneoutgoingedgea pivot point .
if the pivot point corresponds to operations we call it a branching pivot point b pp .
if the pivot point corresponds to operations we call it a thread interleaving pivot point i pp .
figure4showsaprogramanditsgig.forsimplicity weassum e a x isatomic.
therootnode a1 b correspondstothestarting points of the two threads.
the terminal node a5 b corresponds totheendofthetwothreads.
nodessuchas a1 b arei ppnodes where we can execute either thread which leads to a2 b or thread2whichleadsto a1 b .
incontrast nodessuchas a2 b are b pp nodes where we can take either the assume a branch leading to the code segment a1 or the assume a negationslash branch leadingtothecodesegment a1.
notethatthegigdoes nothaveloop back edges since thegig paths represent unrolled executions.
furthermore pointe rs aliasing andfunctioncallshavebeenresolvedaswellduringexe cution.
however a gig may have branches which makes it significantl y 857differentfromthetypicalthreadinterleavinggraphusedi nthepartialorderreductionliterature.
asistypicalinsymbolicexecutionalgorithms wefocusono nly a finite set of executions and assume that each execution has a finite length.
typically the user of a symbolic execution too l needs to construct a proper testing environment that satisfies the above assumption.
in klee and cloud9 for example the user mayachievethisbyboundingthesizeofthesymbolicinputth ereby restrictingtheexecutiontoafixednumberofpathsoffinitel engths.
.
symbolicexecution we present the baseline symbolic execution procedure for mu ltithreaded programs inalgorithm followingsenet al.
.
the recursive procedure e xplore isinvoked withthesymbolic initial state s0.
insidetheprocedure wedifferentiateamongthreescenar ios based on whether s the current state is an i pp node a b pp node oranon branchingnode.
if sisan i pp nodewheremultiple operationsareenabled we recursively explore the next event from each thread.
if sis a b pp node where multiple sequential branches are feasible we re cursively explore each branch.
if sis a non branching node we explore the unique next event.
the current execution ends if s is a leaf node normal end state faulty end state or an i nfeasible state at whichpoint we returnfrom e xplore s by popping thestate sfromthestack s. algorithm1 baselinesymbolicexecution.
initially stack s s0 rune xplore s0 withthesymbolicinitialstate s0.
explore s s.push s if sisani ppnode while t s.enabled s.done s next state s t explore s s.done s.done t elseif sisab ppnode while t s.branch s.done s next state s t explore s s.done s.done t elseif sisaninternalnode t s.next s next state s t explore s s.pop next state s t lets a bracketle tpcon m enabled branch done a bracketri ht if tis halt s normal end state elseif tis abort s faulty end state elseif tis assume c if s.pcon isunsatisfiableunder m s infeasible state else s a bracketle tpcon c m a bracketri ht elseif tisassignment v exp s a bracketle tpcon m a bracketri ht return s eachstate s sisatuple an bracketle tpcon m enabled branch done an bracketri ht where pcon isthe pathconditionfortheexecutiontoreach sfrom s0 mis the symbolic memory map s. enabled is the set of eventswhen sisani ppnode s. branch isthesetof eventswhen sis a b pp node and s. done is the set of or events already explored from sby the recursive procedure.
initially s0is set to an bracketle ttrue minit an bracketri ht where true meansthestateisalwaysreachableand minit represents theinitialcontentofthememory.
theexecution ofeachinstruction tiscarriedoutbyn ext state s t asfollows if tis halt theexecutionendsnormally.
if tis abort and s. pcon issatisfiableunderthecurrentmemorymap s. m wehavefoundanerror.
if tis v exp we need to update the current memory map mbychangingthecontentof vto exp .
if tis assume c wechangethepathconditionto pcon c .
ateachpivotpoint i pporb pp wetrytoflipadecisionmad e previously to compute a new execution.
let in sch denote the current execution.
by flipping the decision made previously at an i ppnode wecomputeanewexecution in sch where sch isa permutationoftheoriginalthreadschedule.
incontrast b yflipping the decision made previously at a b pp node we compute a new execution in sch where in is a new data input.
note that in both cases the newly computed execution will be the same as t he original execution up to the flipped pivot point.
after the fli pping therestoftheexecutionwillbeafreerun.
asanexample consider thegiginfigure where thecurrent execution is represented by the dotted line run i .
flipping at the b ppnode a4 b wouldleadtothe newexecutionlabeled run ii whereas flipping at the i pp node a3 b would lead to the new execution run iii .
.
summarizingtheexploredexecutions we first present our method for symbolically summarizing the reason why explored executions cannot reach the bad state.
i nthe nextsection wewillleveragetheinformationtopruneaway redundantexecutions.
our method for summarizing the explored executions is based on the weakest precondition computation .
we different iate the following two scenarios depending on whether the execu tion encounterstheassertstatementornot.
for each execution that encounters assert c and satisfies thecondition c wecomputetheweakestpreconditionofthe predicate calongthisexecution.
for each execution that does not encounter the assert statementatall wecomputetheweakestpreconditionofthepredicate true alongthisexecution.
sincetheweakestpreconditionisaformofcraig sinterpol ant itprovidesasuccinctexplanationastowhytheexploredexe cution cannotreachthebadstateguardedby c. definition .the weakest precondition of the predicate withrespect toasequence ofinstructions is defined as follo ws for t v exp wp t for t assume c wp t c and for sequence t1 t2 wp t1 t2 wp t1 wp t2 .
intheabovedefinition denotesthesubstitutionofvariable vin with exp .
asanexample considertheexecutionpathin the following table which consists of three branch conditi ons and threeassignments.
column1showsthecontrollocationsalo ngthe current path.
column shows the sequence of instructions ex ecuted.
column3showstheweakest preconditions computedba ckwardlystartingat l6.
column4shows the rulesappliedduringthe computation.
loc.
instruction wp computed ruleapplied l0if a a b c wp c l1res res b c wp l2if b b c wp c l3res res c wp l4if c c wp c l5res res true wp l6 true terminal .
predicatesummariesatb ppnodes assumethatthebaselinesymbolicexecutionproceduretrav erses the gig in a depth first search dfs order meaning that it ba cktracks s a branching pivot point b pp only after exploring both outgoing edges sassume c s and sassume c s .
this also includestheentireexecutiontreesstartingfromthesetwoed ges.
let wp and wp be the weakest preconditions computed from thetwooutgoingexecutions respectively.
followingtheclassicdefinitionofweakestprecondition we computethemattheb ppnode sasfollows wp c wp c wp .
then weuse wp computedfromtheseoutgoingedgestoupdate theglobalpredicatesummary.
the predicate summary ps defined for each global control state s istheunionofallweakestpreconditionsalongtheoutgoin g edges.
recall that each node smay be visited by e xplore multiple times presumably from different execution paths fr om s0to s .
therefore wemaintainaglobalmap ps andupdate eachpredicate summary entry ps incrementally.
initially ps false foreverygignode s. then wemergethenewlycomputed wp to ps everytimee xplore backtracksfrom s. thedetailedmethodforupdatingthepredicatesummaryishi ghlighted in blue in algorithm which follows the overall flow of algorithm1 exceptforthefollowingtwoadditions wecompute wp beforetheprocedurebacktracksfromstate s. atthismoment wp captures thesetof allexploredexecutionsfrom sasacontinuationofthecurrentexecution.
weupdate thesummaryasfollows ps ps wp .
here ps capturesthesetofexecutiontreesasacontinuationofallexploredexecutionsfrom s0to s including wp whichrepresentsthenewlyexploredexecutiontree.
.
predicatesummariesati ppnodes incontrasttothestraightforwardcomputationofweakestp reconditionatthesequentialmergepoint thesituationatthein terleaving merge point is trickier.
infact tothe best of our knowledge there does not exista definitionof weakest preconditioninthelit erature forthreadinterleavingpoints.
a naive extension of dijkstra s original definition would be inefficient since it leads to the explicit enumeration of all po ssible interleavings.
for example assume that an i ppnode has two outgoingedges s 1 s and s 2 s onemayattempttodefinethe weakestpreconditionatnode sasfollows parenleftbig 1 hb 2 wp parenrightbig parenleftbig 2 hb 1 wp parenrightbig where 1 hb 2 means that we choose to execute 1before 2 2 hb 1 means that we choose to execute 2before 1 and wp and wp aretheweakestpreconditionsalongthetwo interleavings respectively.
although the above definition serves the purpose of summariz ing the weakest preconditions along all explored execution s from s it has a drawback the size of wp computed in this way can quickly explode when there are a large number of threads.
rec all thatinamultithreadedprogramthenumberofoutgoingedges atan i ppnodeequalsthenumberofenabledthreadsandthenumber of interleavingsof kconcurrentthreadscanbe k!intheworstcase.
however for the purpose of pruning redundant executions t he weakest precondition computation does not have to be precis e to beeffective.
tomitigatetheaforementionedinterleaving explosion problem weresorttothefollowingdefinition whichcanbev iewed asanunder approximationofthenaivedefinition wp logicalanddisplay i kwp whereeach wp istheweakestpreconditioncomputedalongone of the koutgoing edges of the form s i si such that i k. consider figure as an example.
we compute the weakest preconditionatnode n5byconjoiningweakestpreconditionsatthe two successor nodes n7and n8.
that is wp wp wp a a x .
algorithm2 assertionguidedsymbolicexecution.
initially summary ps false for all node n stack s s0 run e xplore s0 withinitialstate s0.
explore s s.push s if sisani ppnode wp true while t s.enabled s.done s next state s t explore s wp wp compute wp s t s s.done s.done t elseif sisab ppnode wp false while t s.branch s.done s next state s t explore s wp wp compute wp s t s s.done s.done t elseif sisaninternalnode t s.next s next state s t explore s wp compute wp s t s else endstate wp true ps ps wp s.pop compute wp s t s if tis assume c return wp c elseif tisassignment v exp return substitute wp v exp else return wp next state s t letsbetuple a bracketle tpcon m enabled branch done a bracketri ht if tis halt s normal end state elseif tis abort s faulty end state elseif tis assume c if s.pcon isunsatisfiableunder m s infeasible state elseif pcon ps s early termination state else s a bracketle tpcon c m a bracketri ht elseif tisassignment v exp s a bracketle tpcon m a bracketri ht return s forpruningredundant executions conjoiningweakestprec onditions from different interleavings at i pp nodes is a sound a pproximation.
although it may not capture all the explored execut ions and thus fail to prune certain redundant executions all the pruned executionsareguaranteedtoberedundant.
.
pruningredundantexecutions we present our method for leveraging the predicate summarie s topruneawayredundant executionsinthissection.
.
assertionguidedpruning todecideifwecanskipexecutionsstartingfromaglobalcon trol state s where shas been visited by e xplore through some executions from s0to sbut isreachedagainthrough anew execution we check whether the current path condition s. pcon is subsumed by ps underthecurrentmemorymap s. m. intuitively thepath condition s. pcon represents the set of states reachable along the currentexecutionfrom s0to s whereas ps representsthesetof statesfromwhichitisimpossibletoreachthebadstate.
withinthe n ext state procedureinalgorithm2 wecheckfor thepruningconditionasfollow if s. pcon ps holds under s. m extending the current executionbeyond swouldnotleadtoabadstate.
therefore we backtrack immediately by setting s as an early terminationstate .
otherwise there may existanextensionofthecurrentexecutionbeyond storeachthebadstate.
inthiscase weneedto continuetheforwardsymbolicexecutionasusual.
the validity of s.pcon ps can be decided by checking the satisfiability of s.pcon ps using an smt solver.
that is s.pcon ps holdsifandonlyif s.pcon ps isunsatisfiable.
our new pruning method is complementary to partial order reduction techniques.
por is a generic reduction that relies s olely on commutativity between concurrent operations.
therefor e two executions are considered equivalent as long as they result in the same program state.
our new method in contrast uses assert ions to guide the pruning.
therefore even executions that resul t indifferentprogramstatesmaystillberegardedasequivalent.
consider the giginfigure4 whichhas54feasible execution s. to make the presentation simple we have assumed that x is atomicinthisexample.
however notethat a1 a x and b1 b x donotcommute becausefromastatewhere x forinstance executing a1 b1 leadsto a b x butexecuting b1 a1 leads to a b x .
asshownintable1 withoutapplyinganyreduction technique the program has a total of distinct runs.
p artial order reduction por alone can reduce the runs down to runs.
ournewpredicatesummary basedpruningmethodalone can reduce the54runsdowntothe18runs.
finally applyingboth our methodandporcanreducethe54runsdownto13runs.
table1 applyingvariousreductiontechniquestofigure4.
reductiontechnique numberofpaths none partialorderreduction por ourpredicatesummary basedpruningmethod bothporandournewpruningmethod .
interactionwithdpor however thereisacaveatincombiningourpredicatesummar ybased pruning method with dynamic partial order reduction because dpor is a delicate algorithm that relies on the dynam ic computation of the backtrack sets .
without taking precautions naivelypruningawayredundantexecutions eveniftheydon otlead tothebadstate maydeprivedportheopportunitytoproperl yupdateitsbacktracksets therebyleadingtounsoundreducti on.
aswehaveshowninsection2 whenthecurrentexecutionisru n in figure by the time node n5is reached dpor has not had theopportunitytoupdateitsbacktracksetat n3.
ideally thread t2 should be put into the backtrack set of n3 that is after e xplore backtracksto n3 itshouldproceedtoexplorerun6.however since n5.pcon ps along run our pruning methodwouldforce e xplore tobacktrackfrom n5 therebyskippingtheremainderofrun4andrun5.
here thetechnicalchal lenge is how to properly update the backtrack set at node n3before e xplore backtracks from n5.
fortunately similarproblemswereencounteredduringthe development ofstatefuldporalgorithms .
inthiswork wefol low the solution by yang et al.
.
we maintain two global table s rvar and wvar for each global control state s. the rvar tablestoresthesetofglobalvariablesthathavebeenreadb ysome threadduringpreviouslyexploredexecutions startingfro ms. similarly the wvar table stores the set of global variables that have been written to by some thread during previously explored ex ecutionsstartingfrom s. thesetwotablesareupdatedatthesametime theglobal ps tableisupdated.
fortheexampleinfigure2 afterexploringrun1 run2 andr un we would have wvar x t representing that x has previously been executed by thread t1at some point after n5.
similarly we have rvar x t representing that b x haspreviouslybeenexecutedbythread t2atsomepointafter n5.
whenever e xplore decides to skip the execution tree from a node s we can leverage the information stored in wvar and rvar to properly update the backtrack sets for dpor.
for example theoriginal dporalgorithmwaitsuntilassignment b x is executedbythread t2before itcanupdate the backtracksetof n3.
now using the entry x t rvar it can put thread t2 intothebacktracksetof n3 asif b x has beenexecutedbythread t2atsomepointafter n5.
the correctness of this solution follows yang et al.
in t he contextofstatefuldpor whichensurethatdporremainssou nd inthepresence ofassertionguided pruning.
formore inform ation onthedynamicupdateofbacktracksets pleaserefertotheo riginal descriptionofdpor .
.
proofofcorrectness now westateandprovethecorrectnessofouroverallalgori thm.
letse orig bethebaselinesymbolicexecutionproceduredescribed in algorithm and se new be our new symbolic execution procedure withpredicate summary based pruning asdescribed in algorithm .
we say that se new is a sound reduction of se orig if it alwaysreachesthesamesetoferrorstatesas se orig .
theorem .givenaprogram pandanerrorlocation e. our new symbolic execution procedure se new reaches eif and only if the original symbolic executionprocedure se orig reaches e. proof we divide the proof into two steps.
first we prove tha t if se new reaches e then se orig also reaches e. this is straightforward because se new explores a subset of the execution paths exploredby se orig asshownbyacomparisonofthetwoversions of n ext state inalgorithms1and2.
second weprove that if se orig reaches e then se new reaches e. wedothisbycontradiction.
assume se orig canreach ealong butse new cannot.
since lines in algorithm are the onlyplaceswhere se new canskipapath theremustexistanevent an bracketle ts t s an bracketri htin suchthat s. pcon ps holdsunder s. m. sincepath isfeasible thesubpath of from s to emust alsobe feasible.
toskip in se new thesubpath musthave been explored and then summarized in ps presumably when se new firstexploredthesubpath.
butif ps alreadyincludes this common subpath from s to e bydefinition se new musthavereachedtheerrorblock e. this contradicts our assumption that the new symbolic executionprocedure se new cannotreachtheerrorblock e. therefore ourassumptionisincorrect.
thetheoremholds.
.
optimizations in our new method the size of the summary table as well as the size of the logical constraint ineachentrymaybecome an performance bottleneck.
since large logic formulas are expens ive to compute and store we would like toreduce the associated com putational cost without affecting soundness of the overall pr ocedure.
towardthisend weproposetwooptimizations.
.
leveragingstaticprogramslicing ourfirstoptimizationistocombineourassertionguidedpru ning withstaticprogram slicing toachieveamoresignificantstatespace reduction.
givenanassertionstatement st wedefinethe slice of st asthesetofallstatementsintheprogramthatmayaffectthe result of st .
the slice is computed based on two dependency relations the control dependency relation and the data dependency rel ation.
intuitively a statement st is a control dependency of a statement st if the execution of st determines whether st can be executed.
whereasastatement st isadatadependencyof st iftheexecution of st mayaffectthedatausedin st .
1if p 2y v 3z w 4if q 5x z 6assert x figure5 exampleforstatic programslicing.slice ab assert c s0 figure6 usingtypeaand bnodesoutsidetheslice.
consider the example in figure .
the write to xat line has acontrol dependency at line and a data dependency at line .
the slice ofline5isdefinedasthetransitiveclosureofitscontrol and data dependencies which consists of lines .
in contr ast the branching statement at line and the write to yat line are irrelevant since their execution will not affect the value written to xat line5nor thereachabilityof line5.
therefore forcheck ing the assertionatline6 whichisrelatedtothe value of xatline5 wecansimplyignorelines1 .
inotherwords thesliceofli ne5 and line defines a sub program producing anequivalent re sult asthefullprogramasfarasassertioncheckingisconcerned .
weimplementedtheinter proceduralslicingmethodofhorw itz et al.
together withan andersen style flow insen sitive alias analysis to compute the program slice statically.
we i mplemented the method in llvm using the datalog engine inside the z3 smt solver .
the overall method is flow insensitive a nd safe for handling multithreaded program with sequentially consistentmemory.
duetothelackofspace wedonotgooverthedeta ils here.
readerscanreferto formoredetails.
we combine static program slicing with symbolic execution a s follows.
first wecomputethestaticprogramslicepriorto thestart of symbolic execution.
then inside the symbolic execution procedure as described in algorithm for each to be executed b pp or i ppnode s we check ifthe corresponding branch condition or global operation belongs to the static slice of the assertio n statement.
ifthe answerisno wehandle apivot point s whichcanbe an i pp or a b pp in one of the following ways depending on the nodetypeasillustratedinfigure6.
typea if sisnotonanypathfrom s0totheassertionstatement we treat each outgoing edge from sas if it is halt.
in other words we stop the current execution and backtrack from simmediately.
note that backtracking will automaticallytriggerthecomputationofweakestprecondition.
typeb if sis on some gig path from s0to the assertion statement wecannotsimplytreat sastheendoftheprogram since outgoing paths from smay still lead to the assertion failure.
as shown infigure we have tosymbolically executeatleastoneoftheoutgoingedgesfromthetypebnode whileskippingtheotheroutgoingedges.
the correctness of this approach directly follows from the d efinition of slicing.
for both type a and type b nodes outside the program slice which outgoing edge to execute does not affect the reachability of the bad state.
due to the relative efficie ncy of static slicing the overhead of computing the slice is small compared to the subsequent symbolic execution.
however we wil l showthroughexperimentsthat byleveragingstaticslicin g wecan significantly decrease of the number of executions to be expl ored thusdecreasingthecomplexityoftheoverallanalysis.
.
approximatingthesummaryconstraints following theorem we can prove that in general any kind ofunderapproximation of ps maybeusedinalgorithm 2toreplace ps whilemaintainingthesoundnessofourpruningmethod.
our optimization is to heuristically reduce the computatio nal cost associatedwithpredicatesummaries.
towardthisend wepr opose thefollowingtwounderapproximations.
first weuseaglobalhashtablewithafixednumber nofentries tolimitthestoragecostfor ps thatis twoglobalcontrollocations sand s maybehashed tothesame entry.
whenever thishappens instead of storing both ina linked list we drop one of them.
t hat is when key s key s we heuristically remove one entry effectivelysettingthecorresponding predicatesummary false .
second we use a fixed threshold to bound the size of each individual logical constraint for ps .
in other words when the predicate summary becomes too large we will stop adding new weakest preconditions to it thereby dropping all subsequ ently exploredsubpaths.
thatis if size ps bnd ps ps wp .
thisisagainanunderapproximation of ps .
a main advantage of this on demand constraint minimization framework is that it allows various forms of underapproxima tions to be plugged into it without affecting the soundness proof o f the overallalgorithm.
withunderapproximations itispossib lethatwe maynolongerbeabletopruneawayallredundantexecutions however we can guarantee that all pruned executions are truly r edundant.
inparticular thebaselinesymbolic executioninalg orithm1 no pruning can be viewed as an extreme form of underapproxi mation where ps is underapproximated to false for all global controllocations.
.
experiments wehaveimplementedourmethodin cloud9 whichinturn builds upon the llvm compiler and the klee symbolic virtual machine .
note that klee does not by itself support mu ltithreading and although cloud9 has extended klee to support a limited number of posix thread routines it does not attemp t to cover all feasible thread interleavings.
indeed cloud9 allows for context switches only before certain posix thread synch ronizations butnotbefore sharedvariablereads writes.
fur thermore cloud9 doesnot support partialorderreduction.
instead itforks a newexecutioneverytimeaposixsynchronizationisencount ered whichcancausethenumberofexecutionstoexplode quickly.
we have extended cloud9 to implement the baseline symbolic executioninalgorithm1 whichsystematicallyexploresbo thintrathread paths and thread interleavings.
then we implemente d the 861dpor algorithm .
based on these extensions we have impl emented our new assertion guided pruning algorithm with t he optimizationspresentedinsection6.
table2 summaryofourexperimentalresults.
cloud9 dpor dpor ag name loc threads runs time s runs time s runs time s fibbenchfalse1 .
.
.
fibbenchfalse2 .
.
fibbenchfalse3 .
.
indexertrue .
.
lazy01false .
.
.
reorder2false1a .
.
.
reorder2false1b .
.
.
reorder2false1c .
.
.
reorder2false2a .
.
.
reorder2false2b .
.
.
sigmafalse1 .
.
.
sigmafalse2 .
.
.
sigmafalse3 .
.
.
singletonfalse .
.
.
stackfalse .
.
.
stateful01true .
.
.
twostage3false .
.
.
dekkertrue .
.
petersontrue1 .
.
petersontrue2 .
.
readwritelktrue1 .
.
.
readwritelktrue2 .
timevarmutextrue .
.
.
szymanskitrue .
unveriftrue .
.
bluetoothbad .
.
art example .
.
.
fsbenchbad .
.
tickettrue .
.
.
accountbad .
.
.
circularbufbad1 .
.
.
circularbufbad2 .
.
.
readreadwrite .
.
.
queuefalse .
.
.
nbds slu1a .
.
nbds slu1b .
nbds slu1c .
nbds slu2a .
.
nbds slu2b .
nbds slu2c .
nbds skiplist .
nbds hashw1a .
.
nbds hashw1b .
.
nbds hashw1c .
nbds hashw2a .
.
nbds hashw2b .
nbds hashw2c .
nbds hash .
nbds list .
.
nedmalloc .
average .
.
.
wehaveconductedexperimentsontwosetsofbenchmarks.
the first set consists of multithreaded c programs from the s oftware verification competition sv comp benchmark and programs from .
the second set consists of two real mu ltithreaded applications nbds a collection of lock free data structures and nedmalloc a thread safe malloc implementation.
eachoftheseprogramshasbetween40to6 500linesofc ode withacombinedtotalof40 291linesofcode.
eachbenchmark program is first transformed into llvm bitcode using clang llvm beforegiventothesymbolicexecutiontoolwithasetofuser annotatedvariablesassymbolicinput.
table summarizes the results of our experimental evaluati on.
columns show the name lines of code and the number of runscloud9 runs dpor ag time s cloud9 time s dpor ag figure7 scatterplotscomparingourmethodwithcloud9.
threads for each program.
columns 9compare the performan ce ofthreedifferentmethods intermsofthenumber ofexplored runs andthetotalruntimeinseconds.
cloud9 denotesthebaselinesymbolicexecutionalgorithminalgorithm1 dpordenotesthe baselinealgorithmwithdynamicpartialorderreduction and d por ag denotes our new method which augments the baseline algorithm with dpor and assertion guided pruning.
the runtime of dpor ag includes the timeto compute the slice.
for alltest s weusedamaximumtimeof30minutes.
in the remainder of this section we analyze the experimenta l resultsinmoredetails toanswerthefollowingresearchqu estions .
howeffectiveisourproposedpruningtechnique?
isitmor e effectivethandporalone?
.
how scalable is our technique?
is it practical in handling realisticc c programs?
first we show the comparison of cloud9 and dpor ag in two scatter plots in figure where the x axis in each scatter plot represents the number of runs or time of the baseline algor ithm cloud9 and the y axis represents the number of runs or time ofour method dpor ag .eachbenchmark program isrepresented by a dot in the scatter plots dots below the diagonal l ines are winning cases for our method.
the results show that our ne w method can significantly reduce the number of runs explored b y symbolic execution as wellas the overall execution time.
in many cases the baseline algorithm timedout after minutes whi le our newmethodfinishedinafewseconds.
next weshowthecomparisonof dporand dpor agin the scatter plots in figure .
our goal is to quantify how much of the performance improvement comes from our new assertion guided pruning as opposed to dpor.
again dots below the diagonal lines are winning cases for our method dpor ag overdpor.formostofthebenchmarkprograms ournewmethod demonstrated a significant performance improvement over dp or.
but for some benchmark programs dpor ag was slightly slowerthan dpordespitethatitexecutedthesame orasmal ler number of runs.
this is due to the additional overhead of running the supplementary static slicing algorithm as well as predicate summary based pruning whichdidnot provide sufficien t performanceboosttooffsettheiroverhead.
however it is worth noting that where our combined optimiz ationofslicingandpruningisabletobringaperformance imp rovement itoftenleadstoadrasticreductionintheexecutiont imecompared to dpor alone.
for example in nedmalloc our newmethodwasabletoidentifythatthepropertydoesnotdep end onanysharedvariables.
insuchcases itcansafelyskipexp loring theentireinterleavedstatespaceandfinishinjustonerun.
we also evaluated the growth trends of the three methods when thecomplexityofthebenchmarkprogramincrease.
figure9s hows theresultsofcomparingthethreemethodsonaparameterize dprogram named reorder2false .
in these two figures the x axis repre86210 runs dpor runs dpor ag time s dpor time s dpor ag figure8 scatterplotscomparingourmethodwithdpor.
numberofthreads runs cloud9 dpor dpor ag numberofthreads time s cloud9 dpor dpor ag figure9 parameterizedresultsfor reorder2false experiment.
sents the number of threads created in the parameterized pro gram and the y axis represents inlogarithmicscale the number ofruns explored and the execution time in seconds.
as shown by these two figures the computational overhead of all three methods increases as the complexity of the program increases.
however our new method increases at a significantly reduced rate compare d to thetwoexistingmethods.
.
relatedwork as we have mentioned earlier for sequential programs ther e is a large body of work on mitigatingpath explosion in symbolic executionusingfunctionsummaries may mustabstracti on demand driven refinement state matching state m erging andstructuralcoverage .
mcmillanproposed lazy abstraction withinterpolants whichhasbeenshowntobeeffectiveinmodelcheckingsequentialsoftware .
jaffare tal.
useda similarmethodinthecontext ofconstraint programmi ng to computeresource constrainedshortestpathsandworst ca seexecution time.
however a direct extension of such methods to mul tithreadedprogramswouldbeinefficientsincetheyleadtothe naive explorationofallthreadinterleavings.
wachteretal.
extendedmcmillan slazyabstractionwi thinterpolants tomultithreadedprograms whilecombining itwith a symbolic implementation of the monotonic partial order re duction algorithm .
the idea is to apply interpolant ba sed reduction to each interleaved execution while applying sym bolic portoreducethenumberofinterleavings.
chuandjaffar proposedasimilarmethod wheretheyimprovedthesymbolicpor by considering not only the standardindependence relationbu t alsoa new semi commutativity relation.
however these existing methods differfromourmethodsignificantly.
first wemergepredicatesummariesatinterleavingpivotp oints whereas the existing methods do not.
second we lever age static program slicing and heuristic minimization of su mmary constraints during symbolic execution tofurther reduce th e search space.
finally ourpruningmethodisdesignedtoworkseaml essly with the more scalable dpor algorithm whereas the exist ing methods implemented symbolic por.
neither of these prev i ous methods demonstratedhandlingc c code withmorethan a thousandlinesofcodeasinourwork.
kusano and wang introduced a notion of predicate dependence in the context of dynamic partial order reduction.
wan g et al.
proposed similar property driven pruning meth ods for dynamic model checking.
however all these prior methods we re gearedtowardstatelessmodel checking whichcanbe viewed asa formofsystematictestingwithfixeddatainput asopposedt osymbolic data inputs.
furthermore these methods relied on con trol and data dependency relations as opposed to symbolic constr aints generated from weakest precondition computation and ther efore were unable to merge non failing executions reaching diffe rent finalstates.
inthissense ournewmethodisamoregeneraland more accurate version of the prior works.
furthermore it is orth ogonal and complementary to the symmetry reduction method propos ed byyangetal.
.
our sound method for pruning executions differs significant ly from various heuristic reduction techniques inconcurrenc y testing thatdonotguaranteethesoundness.
forexample farzaneta l. and razavi et al.
proposed heuristic methods for quickl y exploringcertainsubsetsofthreadinterleavingscenariosi nsymbolic executionof concurrent programs.
thistype ofselectivein terleaving exploration techniques were also used by wang et al.
to quickly cover certain pairs of dependent operations captur ed by a historyawarepredecessorset.
furtheralongthisline the rearepredictivebugdetectionmethodsbasedontheuseofsmtsolvers whichdifferfromourme thod in that they explore only the thread interleavings under fixe d programinputs.
thegreentoolbyvisseretal.
providesawrapperaround constraint satisfiability solvers to check if the results ar e already available from prior invocations and reuse the results if a vailable.
assuch theycanachievesignificantreuseamongmultipleca llsto the same solvers during the symbolic execution of different paths.
green achieves this by distilling constraints into their es sential parts and then representing them in a canonical form.
the reu se achievedbygreenisatamuchlowerlevel andthereforeisco mplementarytoournewpruningmethod.
finally weassume sequentialconsistency althoughourme thod canbeintegratedwithdynamicpartialorderreductionmeth odsfor relaxedmemorymodels weleavethisforfuturework.
.
conclusions we have presented a predicate summary based pruning method for improving symbolic execution of multithreaded program .
our methodisdesignedtoworkwiththepopulardporalgorithm a nd has the potential of achieving exponential reduction.
we ha ve implementedthemethodin cloud9 anddemonstrateditseffectiveness throughexperiments onmultithreadedc c benchmarks.
fo rfuture work we plan to conduct more experiments to identify th e sweetspots inusingheuristicminimizationsofsummaryconstraints to exploit the trade off between increasing the pruning pow er and decreasingthecomputationaloverhead.
.