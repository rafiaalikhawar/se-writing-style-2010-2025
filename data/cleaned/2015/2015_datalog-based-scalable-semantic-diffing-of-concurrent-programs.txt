datalog based scalable semantic diffing of concurrent programs chungha sung university of southern california los angeles ca usashuvendu k. lahiri microsoft research redmond wa usa constantin enea university paris diderot paris francechao wang university of southern california los angeles ca usa abstract when an evolving program is modified to address issues related to thread synchronization there is a need to confirm the change is correct i.e.
itdoesnotintroduceunexpectedbehavior.however manually comparing two programs to identify the semantic difference is laborintensive and error prone whereas techniques based on model checking are computationally expensive.
to fill the gap we develop a fastandapproximate static analysis forcomputingsynchronizationdifferencesoftwoprograms.the method is fast because instead of relying on heavy weight model checking techniques it leverages a polynomial time datalog based programanalysisframeworktocompute differentiating data flow edges i.e.
edges allowed by one program but not the other.
although approximationis used ourmethod issufficiently accurate duetocarefuldesignofthedataloginferencerulesanditerativeincreaseoftherequireddata flowedgesforrepresentingadifference.
wehaveimplementedourmethodandevaluateditonalargenumber ofmultithreaded c programsto confirmits ability toproduce oftenwithinseconds thesamedifferencesobtainedbyhuman in contrast priortechniquesbasedonmodelcheckingtakeminutes or even hours and thus can be 10x to 1000x slower.
ccs concepts software and its engineering software verification and validation keywords concurrency semantic diffing change impact static analysis race condition atomicity datalog acm reference format chungha sung shuvendu k. lahiri constantin enea and chao wang.
.
datalog based scalable semantic diffing of concurrent programs.
in proceedingsofthe201833rdacm ieeeinternationalconferenceonautomated software engineering ase september montpellier france.
acm newyork ny usa 11pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
introduction whenanevolvingconcurrentprogramismodified oftentimes the sequential program logic is not changed instead the modification focusesonthreadsynchronization e.g.
tooptimizeperformance or remove bugs such as data races and atomicity violations.
since concurrencyishard itisimportanttoensurethemodificationis correctanddoesnotintroduceunexpectedbehavior.however manually comparing two programs to identify the semantic difference isdifficult andthesituationisexacerbatedinthepresenceofthread interactions changing a single instruction in a thread may have a ripple effect on many instructions in other threads.
although techniqueshavebeenproposedtocomputethesynchronizationdif ference e.g.
byleveragingmodelcheckers theyareexpensive forpracticeuse.forexample comparingtwoversionsofaprogram with lines of c code takes half an hour.
to fill the gap we develop a fastandapproximate static analysis tocomputesuchdifferenceswiththegoalofreducinganalysistime fromhoursorminutestoseconds.weassumethetwoprograms are closely related versions of an evolving software where changes are made to address issues related to thread synchronization asopposed to the sequential computation logic.
therefore same asin prior works we focus on synchronization differences.
however our method is orders of magnitude faster because insteadofmodelcheckingweleverageapolynomial timedeclarative programanalysisframeworkwhichusesasetofdatalogrulesto model and reason about thread interactions.
the reason why prior techniques are expensive is because they insist on being precise.
specifically they either enumerate interleavings or use a model checker to ensure a semantic difference representedasasetofdata flowedges isallowedbyoneofthepro gramsbutnotbytheother.however thisingeneralisequivalenttoprogramverification whichisanundecidableproblem evenin cases where it is reduced to a decidable problem the cost of model checking is toohigh.
our insight isthat in practice it isrelatively easyfordeveloperstoinspecta givendifferencetodetermineifit is feasible what is not easy and hence requires tool support is a systematicexplorationofbehaviorsofthetwoprogramstoidentify all possible differences in the first place.
unfortunately developing such a tool is a non trivial task for example the naive approach of comparingindividualthreadinterleavingswouldnotworkdueto the often exponential blowup in the number of interleavings.
our method avoids the problem by being approximate in that it does not enumerate interleavings.
this also means infeasible behaviors are sometimes included.
however our approximation is carefullydesignedtotakeintoconsiderationtheprogramsemantics authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france chungha sung shuvendu k. lahiri constantin enea and chao wang figure overview of our semantic diffing method.
mostrelevanttothreadinteraction.furthermore theapproximationcanberefinedbyiterativelyincreasingthenumberofdata flow edgesusedtocharacterizeasynchronizationdifference.weshall show through experiments that our fastandapproximate analysis method does not lead to overly inaccurate results.
to the contrary the synchronization differences reported by our method closely matchtheonesidentifiedbyhuman.comparedtothepriortechniquebasedonmodelchecking whichoftentakesminutesoreven hours our method can be 10x to 1000x faster.
figure1showstheoverallflowofourmethod.theinputconsists of two versions of a concurrent program p1is the original version p2is the changed version and patch info represents their syntactic difference e.g.
information about which instructions are added removed or modified.
the output consists of a set of differences each of which is represented by a set of data flow edges allowed in oneoftheprogramsbutnottheother.whendata flowedgesare allowed in p1but notp2 for example they represent a removed behavior.conversely whendata flowedgesareallowedin p2but notp1 they represent a new behavior introduced by the change.
our method first generates a set of datalog facts that encode thestructuralinformationofthecontrolflowgraphs.thesefacts are then combined with inference rules that codify the analysis algorithm.
when the combined program is fed to a datalog solver theresultingfixedpointcontainsnewrelations facts thatrepresenttheanalysisresult.specifically itcontainsdata flowedgesthatmayoccurineachprogram.bycomparingdata flowedgesfromthetwo programs we can identify the semantic differences.
sinceprogramverificationisundecidableingeneral andwith concurrency it is undecidable even for boolean programs approximation is inevitable.
our method makes two types of approximations.thefirstoneisincheckingthefeasibilityofdata flow edges.
the second one is related to the number of data flow edges used to characterize a difference also referred to as the rankof an analysis .
although in the worst case a precise analysis means the rank needs to be as large as the length of the execution we restrict it to a small number in our method because prior research shows that concurrency bugs often can be exposed by executions with a bounded number of context switches.
since our method is approximate in nature the usefulness dependsonhowcloseitapproachesthegroundtruth.ideally wewanttohavefewfalsepositivesand fewfalsenegatives.towardthisend we choose to stay away from the tradition of insisting the analysis beingeither soundorcomplete whenonecannothaveboth.fora concurrentprogram beingsoundoftenmeans existential abstraction a data flow edge is considered feasible in all interleavings if it is feasible in an interleaving and being complete often meansuniversal abstraction adata flowedgeisconsideredfeasibleonly if it is feasible in all interleavings.
both cases result in extremelycoarse grained approximations which in turn lead to numerous false positives or false negatives.
instead we want to minimize the difference between our analysis result and the ground truth.
we have implemented our method in a tool named ec diff which uses llvm as the front end and z i nz 3a st h e datalogsolver.weevaluated ec diffon47multithreadedprograms with13 500linesofccodeintotal.thesearebenchmarkswidely used in prior research some illustraterealconcurrencybugpatterns andthecorresponding patches while others are applications from public repositories.
we applied ec diffto these benchmarks while comparing with thepriortechniqueofbouajjanietal.
.ourresultsshowthat ec diffcandetect ofteninseconds thesamedifferencesidentified by human.
furthermore compared to the prior technique based on model checking ec diffis 10x to 1000x faster.
to summarize this paper makes the following contributions we propose a fastandapproximate analysis based on a polynomial timedeclarativeprogramanalysisframeworkto compute synchronization differences.
we show why our approximate analysis is reasonably accurateduetothecustom designedinferencerulesanditerative increase of the number of data flow edges.
weimplementourmethodinapracticaltoolandevaluate it on a large number of benchmarks to confirm its high accuracy and low overhead.
the remainder of the paper is as follows.
first we motivate our workusingexamples insection .then weprovidethe technical background in section 3before presenting our analysis method in section .
this is followed by our procedures for interpreting the analysis result and optimizing performance in section .w e present our experimental results in section .
finally we review the related work in section 7and give our conclusions in section .
motivation we use examples to motivate the need for conducting a differential analysis.
programs used in these examples illustrate common bug patterns alsousedduringourexperimentsinsection .ineach example there are two program versions the original one may violateahypothetical assertionandthechangedoneavoidsit.these assertionsarehypothetical addedforillustrationpurposesonly in the sense that our method does not need them to operate.
.
the first example fig.
a shows a two threaded program where the shared variable xis initialized to .
the assertion at line may be violated e.g.
when thread1 executes the statement at line right after thread2executes the statement at line .
the reason is because no synchronization operation is used to enforce any order.
assumethedeveloperidentifiestheproblemandpatchesitby addinglocks figure b theassertionviolationwillbeavoided.
toseewhythisisthecase considerthedata flowedgefromline5 to line due to the critical sections enforced by lock unlock pairs theloadof xatline2isnotaffectedbythestoreof xatline5.for example ifthecriticalsectioncontainingline5isexecutedfirst thesubsequent unlock a mustbeexecutedbeforethe lock a in thread1 which in turn must be executed before line and line .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
datalog based scalable semantic diffing of concurrent programs ase september montpellier france thread1 x x if x assert thread2 x ... x rf rf a before change thread1 lock a x x if x assert unlock a thread2 x ... lock a x unlock a rf rf b after change figure example programs with synchronization differences lock unlock .
since the store of xat line is the most recent the load of xat line will get its value not the value written at line .
thus the allowed data flow edges are as follows rf l4 l2 andrf l5 l2 for the original program and rf l4 l2 for the changedprogram.thisnotionofcomparingconcurrentexecutions was introduced by shasha and snir and extended by bouajjani et al.
although in both cases enumeration or model checking techniques were used.
in our work the goal is to avoid such heavyweight analyses while maintaining sufficient accuracy.
in addition to rfedges there are other types of relations considered during our analysis including program order inter thread orderimposedbythread create join signal wait aswellas store store order.nevertheless wheninterpretingthefinalresults wefocus on differences in the rfedges because they affect the externally observable behavior of a program e.g.
characterized by assertions and other reachability properties.
.
the second example fig.3showsamoresophisticatedexample theuseof signal wait whichisoftendifficultforstaticanalyzers.sincethevariable xis initialized to when the critical section in thread1 is executed before thread2 theloadof xatline1willgetthevalue0 which leads to the assertion violation in fig.
a .
assume the intended behaviorisfor thread2 tocompletefirst aninter threadexecution ordermustbeenforced e.g.
byusingthe signal wait pairshown infig.
b .theassertionviolationisavoidedbecausetheloadof x at line can only read from the store of xat line .
tocorrectlydeploythe signal wait pair avariablenamed cbool needs to be added.
if the operating system voluntarily schedules thread2 first thread1 needs to be aware by checking the value ofcbool and then skips the execution of wait otherwise wait maygetstuckbecausethecorresponding signalhasalreadybeen fired and lost .
but if thread1is executed first since cboolhas not been set it will invoke waitwhich forces the corresponding signalto be sent.
as for the data flow edges we can see that rf l5 l1 and rf l3 l4 areallowedintheoriginalprogram butonly rf l5 l1 isallowedinthechangedprogram.
rf l3 l4 isnotallowedbecauseline4musthappenbeforeline5 line5musthappenbeforethread1 lock a if x assert y foo x unlock a thread2 ... lock a bar y x unlock a rf rf a before change thread1 lock a if !cbool wait cond if x assert y foo x unlock a thread2 ... lock a bar y x cbool signal cond unlock a rf rf b after change figure example programs with synchronization differ ences signal wait .
musthb fig2 a mayhb musthb ... mayrf musthb fig2 b mayhb musthb ... mayrf musthb fig3 a mayhb musthb ... mayrf musthb fig3 b mayhb musthb mayrf figure analysis steps for programs in figs.
a and3 b .
signal and signalmusthappenbefore wait whichresidesbefore lines in thread1.
thus there is a cycle contradiction .
.
how our method works ourmethoddiffersfrompriortechniqueswhichrelyoneitherenumerating interleavings and conducingpairwise comparison ormodelcheckingbasedtechniques .botharecomputationally expensive.
instead we use lightweight static analysis.
our method represents the control and data dependencies of each program as a set of datalog facts.
we also design a set of dataloginferencerules whichcaptureouralgorithmforderiving new facts from existing facts.
leveraging a datalog solver we can repeatedly apply the inference rules over the facts until a fixedpointisreached.wewillexplaindetailsofourdatalogfactsand inference rules in section .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france chungha sung shuvendu k. lahiri constantin enea and chao wang fornow considerthestepsofcomputingsynchronizationdifferencesfortheprogramsinfig.
2andfig.
whichareoutlined by the tables in fig.
.
first ourmethodcomputesmust happen before musthb edges which represent the execution order of two instructions respected by all thread interleavings.
from musthb our method computes may happen before mayhb edges which represent the execution orderrespectedbysomeinterleavings e.g.
threadcontextswitches not contradicting to musthb.f r o m mayhb our method computes mayrfedges which represent data flows over shared variables from store instructions to the corresponding load instructions.
the mayrfedges are over approximated in that if an edge is included in mayrf the corresponding data flow mayoccur in an execution.butifanedgeisnotincludedin mayrf weknowforsure thecorrespondingdataflowisdefinitelyinfeasible.forexample in fig.
mayrfhas four edges for fig.
a but only three edges for fig.
b .
rf l5 l2 is no longer allowed in the changed program indicating it is a difference between the two programs.
for the example in fig.
we compute musthbbased on the sequentialprogramorderand infig.
b theinter threadexecution order imposed by signal wait.
then from musthbwe compute mayhb whichincludesedgesin musthbandmore.forfig.
a since there is no restriction on the inter thread execution order all pairs of events are included whereas for fig.
b there is only one way data flow.
finally we compute mayrfbased on mayhb.
there are three edges for fig.
a but only two for fig.
b .
.
the rank of an analysis when comparing mayrfin these two examples we identify the difference as edges allowed in only one of the two programs such asrf l5 l2 in fig.
2andrf l3 l4 in fig.
.
however even if mayrfedges are allowed individually they maynotoccurinthesameexecution.forexample rf l5 l1 and rf l3 l4 infig.
a cannotoccurtogether because otherwise they form a cycle together with the program order edges.
our method has inferences rules designed to check if two or more dataflow edges can occur together this is referred to as the rank .
withthenotionofrank wecancaptureorderedsetsof mayrf edges as opposed to individual mayrfedges.
thus even if the mayrfrelation remains the same there may be differences of high ranks twoormoreedgesfrom mayrfmayoccurtogetherin p1but notinp2.wewillpresentourmethodforcheckingsuchdifferences in section 5following the baseline procedure in section .
preliminaries .
partial trace comparison to compare the synchronizations of two concurrent programs we usethenotionofpartialtraceintroducedbyshashaandsnir and extended by bouajjani et al.
.
letpbe a program and gbe the set of global variables shared by threads in p. for each x g letw x denote a store instruction and r x denotes a load instruction.
let ibe the set of all instructions in the program.
any binary relation over these instructions is a subset of i i. for example so i iis a relation that orders the store instructions w1 x w2 x meansw1 iis executed before w2 i. thus in fig.
a l1 l4 l4 l1 l1 l5 l5 l1 l4 l5 belong to so but l5 l4 does not belong to sobecause it is not consistent with the program order.similarly rfisarelationbetweenloadandstoreinstructions.in fig.
a wehave l4 l2 and l5 l2 in rf meaningtheloadat line may read from values written at lines and .
given soand rf wedefine setsasasetof subsetsof rf so whereeachelement ss setshas at most kedges.
edgesinssarefromeither rfor so theycapturetheabstract trace.thenumber k whichiscalledthe rank isboundedby the length of the trace.
definition1 abstracttracewithrank k .anabstracttrace with rank kis a tuple t angbracketleft so rf sets k angbracketright where so w1 x w2 x w1 i w2 i andw1 w2in some execution trace rf w x r x w iandr i and sets ss rf so ss k .
giventheabstracttraces t1and t2oftwoprograms p1andp2 respectively we define their difference as 12 21 where 12 t1 t2and 21 t2 t1.
next we define what it means for t1to be a refinement of t2 denoted t1 t2.
definition abstract trace refinement .
given two abstract traces t1 angbracketleft so1 rf1 sets1 k angbracketrightand t2 angbracketleft so2 rf2 sets2 k angbracketright w e say t1isarefinementof t2 denoted t1 t2 ifandonlyif so1 so2 rf1 rf2 and sets1 sets2.
that is when t1 t2 the abstract behavior of p1is covered by that ofp2.
and the difference t2 t1 is characterized by so2 so1 rf2 rf1 and sets2 sets1.finally iftheabstracttracesof p1and p2refine each other we say they are rank kequivalent.
althoughcomparisonofabstracttracesinvolves soand rf when reportingthedifferences wefocusonthe rfedgesonlybecause they directly affect the observable behaviors of the programs.
in contrast store store ordering so may not be observable unless they also affect the read from rf edges.
.
datalog based analysis datalogisalogicprogramminglanguagebutinrecentyearshas beenwidelyusedfordeclarativeprogramanalysis .
the main advantage is that a datalog program is polynomial time solvableand the corresponding fixed pointcomputationmapsnaturallytofixed pointcomputationsinprogram analysisalgorithms.inthiscontext structuralinformationofthe programisrepresentedasrelationscalledthe facts whilethefixedpoint algorithm is expressed as recursive relations called the inference rules.
consider a relation named po a b which represents the programorderof twoimmediateadjacentinstructions aandb while hb c d meanscmusthappenbefore d.first wewritedownthe datalog facts based on the cfg structure po s1 s2 p o s1 s3 p o s2 s4 p o s3 s4 p o s4 s5 .
then we write down the datalog inference rules hb a b po a b hb c e hb c d hb d e here the left arrow separates the inferred datalog facts on the left hand side from the existing datalog fact s on the righthand side.
the first rule says the program order relation impliesthe must happen before relation.
the second rule says the musthappen before relation is transitive.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
datalog based scalable semantic diffing of concurrent programs ase september montpellier france adatalogsolver basedontheabovefactsandrules willcompute themaximalsetofedgesforthehbrelation.bysendingaqueryto the datalog solver one may confirm that hb s1 s5 indeed holds whereas hb s2 s3 does not hold.
constraint based synchronization analysis inthissection wepresentourmethodforcomputingabstracttraces ofasingleprogram.inthenextsection weleveragetheabstract traces of two programs to compute their differences.
first wedefinetheelementaryrelationsthatcanbeconstructed directly from the cfg of a program.
st s1 th1 statement s1resides in thread th1 po s1 s2 statement s1is befores2in a thread dom s1 s2 statement s1dominates s2in a thread postdom s1 s2 s1post dominates s2in a thread thrdcreate th1 s1 th2 thread th1createsth2ats1 thrdjoin th1 s1 th2 thread th1joins back th2ats1 condwait s1 v1 s1waits for condition variable v1 condsignal s1 v1 s1sends condition variable v1 load s1 v1 statement s1reads from variable v1 store s1 v1 statement s1writes to variable v1 incs s1 l1 s1residesinacriticalsectionguardedbylock l1 unlock l1 pair samecs s1 s2 l1 s1ands2arein thesamecritical section guarded by l1 diffcs s1 s2 l1 s1ands2are in different critical sections guarded by l1 while traversing the cfg to compute the po dom and postdom relations we take loops into consideration.
for example two instructionsinvolvedwiththesameloopmaynothaveadomor postdomrelation butaninstructionoutsidetheloopcanhavea dom or postdom relation with an instruction inside the loop.
next wedefineinferencerulesforcomputingnewrelationssuch as mayhb musthb and mayrf.
.
rules for intra thread dependency to capture the execution order of instructions we define the following relations mayhb s1 s2 meanss1may happen before s2in someexecution and musthb s1 s2 meanss1happensbefore s2in allexecutions whenboth occur.since theprogram orderin each thread implies the execution order we have the following rule musthb s1 s2 po s1 s2 in this work we assume sequential consistency but datalog is capable of handling weaker memory models as well.
by definition musthb implies mayhb which means mayhb s1 s2 musthb s1 s2 .
rules for inter thread dependency whenaparentthread th1createsachildthread th2atthestatement s1 e.g.
byinvoking pthread create anystatement s2inthechild thread must occur after s1.
musthb s1 s2 thrdcreate th1 s1 th2 st s2 th2 similarly when a parent thread th1joins back a child thread th2at s1 any statement s2inth2must occur before s1.
musthb s2 s1 thrdjoin th1 s1 th2 st s2 th1 thread1 a cond true thread2 while !cond x a figure ad hocsynchronization cond false initially .
.
rules for signal wait dependency when a condition variable cis used e.g.
through signal c and wait c it imposes an execution order.
musthb s1 s2 condsignal v1 s1 condwait v1 s2 however the rule needs to be used with caution.
in practice wait c is often wrapped in an if condition as shown in figure b .
to be conservative our method analyzes the control flow of these threadsandappliestheaboveruleonlyafterdetectingtheusage pattern.
since our method doesnot analyze the concrete values of anysharedvariables itdoesnotcheckiftheif conditionisvalid.
also developers may use condition variables in a different way.
thus inourexperiments section weevaluatedtheimpactof this conservative approach assuming the if condition is always valid to confirm it does not lead to significant loss of accuracy.
.
ad hoc synchronization we handle ad hocsynchronization similar to signal wait.
fig.
shows an example where condis a user added flag initialized to .
the busy waiting in thread2 ensures that a 1always occurs before x a.bytraversingthecfgsofthesethreads wecanidentify the pattern this is practical since the number of usage patterns islimited.afterthat weaddamusthbedgefrom cond true to while !cond .
this is similar to adding musthb edges for condwait and condsignal.
as a result we can decide the read from edge between x aand the initialization of ais infeasible.
.
transitive closure sincemusthbistransitive weusethefollowingruletocompute the transitive closure musthb s1 s3 musthb s1 s2 musthb s2 s3 wheninstructionsinconcurrentthreadsarenotorderedbymusthb we assume they may occur in any order mayhb s1 s2 st s1 th1 st s2 th2 musthb s2 s1 the mayhb relation is also transitive mayhb s1 s3 mayhb s1 s2 mayhb s2 s3 .
lock enforced critical section for critical sections based on lock unlock we introduce rules based on access patterns.
first we compute coveredstore s1 v1 l1 meaning the store in s1is overwritten by a subsequent store in the same critical section.
consider lk a w1 v w2 v unlk a wherew1 v is a covered store and thus not visible to reads in other critical sections protected by the same lock.
coveredstore s1 v1 l1 store s1 v1 store s2 v1 postdom s2 s1 samecs s1 s2 l1 similarly coveredload s2 v1 l1 means the load of v1ins2is covered and thus can only read from a preceding store in the same authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france chungha sung shuvendu k. lahiri constantin enea and chao wang p1p2 p2p1 figure differences of abstract traces 12 left and 21 right .
critical section.
coveredload s2 v1 l1 store s1 v1 load s2 v1 dom s1 s2 samecs s1 s2 l1 consider lk a w v r v unlk a as anexample r v is covered by w v and thus cannot read from stores in other critical sections protected by the same lock.
.
read from relation finally we compute norf s1 s2 which means the read from edge betweens1ands2is infeasible.
norf s1 s2 store s1 v1 store s3 v1 load s2 v1 musthb s1 s3 musthb s3 s2 that is in w x w x r x the first store cannot be read by the load.
in addition to this generic rule we have two more inference rules norf s1 s2 store s1 v1 load s2 v1 mayhb s1 s2 coveredload s2 v1 l1 diffcs s1 s2 l1 thisrulemeansifonestoremayhappenbeforeoneload theloadis covered and the store is in a different critical section the load cannotreadfromthestore.thisisbecauseanotherstorewilloverwrite the value to be read.
norf s1 s2 store s1 v1 load s2 v1 mayhb s1 s2 coveredstore s1 v1 l1 diffcs s1 s2 l1 this rule means if a store is covered i.e.
overwritten by a subsequent store the store cannot reach to any load in other critical sections protected by the same lock.
we also compute mayrf s1 s2 which means the load in s2may read from the store in s1.
mayrf s1 s2 store s1 v1 load s2 v1 mayhb s1 s2 norf s1 s2 computing the differences in this section we show how to compare abstract traces of the two programs to identify the differences.
.
symmetric difference fig.6shows the venn diagram of our method for computing the differences when given the abstract traces of two programs.
the actual behaviors of programs p1andp2are represented by the circles with solid lines.
the approximate behaviors in the form of abstracttraces t1and t2 arerepresentedbythecircleswithdashed lines.
conceptually the symmetric difference is computed based on 12 t1 t2and 21 t2 t1 and for each is presented as pink colored region in fig.
left and right .
the details of them are presented in the remainder of this section.
to computethe difference we definetwo relationsdiffp1 and diffp2 and rules for computing them diffp1 s1 s2 mayrf s1 s2 p1 mayrf s1 s2 p2 diffp2 s1 s2 mayrf s1 s2 p2 mayrf s1 s2 p1 s1 w x s2 w x s3 r x rf rfs4 r x s1 w x s2 r x s3 w x rf rf musthb musthb figure illustrating the first two rank inference rules.
diffp1 represents edges that may happen in p1but not in p2.
similarly diffp2 represents edges that may happen in p2but not in p1.if diffp1isnotempty therearemorebehaviorsin p1 andif diffp2 is not empty there are more behaviors in p2.
since the datalog solver may enumerate all possible mayhb edges used to compute mayrf and the number of mayhb edges increases rapidly as the program size increases we need to reduce the computational overhead.
our insight is that since we are only concerned with synchronization differences in the end as opposed to behaviors of the sequential computation we can restrict our analysis to instructions that access global variables.
toward this end wedefine anewrelationnamed access v1 s1 whichmeans s1accesses a global variable v1 and use it to guard the inference rules for mayhb and hence musthb .
it forces the datalog solver to consider only global accesses which reduces the computational overheadwithoutlosingaccuracy.wedemonstratetheeffectiveness of this optimization using experiments in section .
.
differences at higher ranks the rules so far use individual read from edges to characterize the differences whichisequivalentto rank 1analysis butsome programsmaynothaverank 1differencebuthavedifferencesof higherranks.todetectthem weneedtocompute orderedsetsof data flow edges allowed in one program but not in the other.
to be specific for rank we extend the mayrf relation which wasdefinedovertwoinstructions anedge tomayrfsdefinedover four instructions to represent an ordered set of two read from edges.similarly weextendthenorfrelationtonorfs whichis alsodefinedoverfourinstructionstorepresentanorderedsetof two read from edges.
previously norf s1 s2 meansthereisnoexecutiontracewhere thestores1canbereadbytheload s2 whereas mayrf s1 s2 means theremayexistsomeexecutiontracethatallowsthe read from edge s1 s2 .
similarly norfs s1 s2 s3 s4 means there is no execution trace where the two read from edges s1 s2 and s3 s4 occur togetherandinthatorder and mayrfs s1 s2 s3 s4 meansthere mayexistsomeexecutiontracethatallowsthetwo read from edges to occur together and in that order.
first we present our rules for computing norfs which in turn isusedtocompute mayrfs.sinceitisnotpossibletoenumerate all scenarios due to theoretical limitations we resort to the mostcommon scenarios.
nevertheless we guarantee that norfsis an under approximation and the corresponding mayrfsis an overapproximation.
norfs s1 s3 s2 s3 mayrf s1 s3 mayrf s2 s3 thisruleisobviousbecause asinfig.
left inthesameexecution trace a load s3 cannot read from two different stores s1 s2 .
norfs s1 s2 s3 s4 mayrf s1 s2 mayrf s3 s4 musthb s2 s3 musthb s4 s1 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
datalog based scalable semantic diffing of concurrent programs ase september montpellier france lk l1 s1 w x s4 r x unlk l1 lk l1 s2 r x s3 w x unlk l1 rf rflk l1 s4 r x unlk l1 s1 w x lk l1 s2 r x s3 w x unlk l1 rf rf postdom figure illustrating rank rules related to lock unlock.
thisruleisalsoobviousbecause asshowninfig.
right ifthetwo read from edgesformacycletogetherwiththemust happen before edges they lead to a contradiction.
norfs s1 s2 s3 s4 samecs s1 s4 l1 samecs s2 s3 l1 diffcs s1 s2 l1 this rule is related to lock unlock pairs.
the rationale behind it can beexplainedusingthediagraminfig.
left .duetothe lock unlock pairs there are only two possible interleavings if s1happens befores2 s4musthappenbefore s3ands2 whichcontradictstothe read from edge s3 s4 ifs3happens before s4 s2must happen befores1 which contradicts to the read from edge s1 s2 .
thus the read from edges cannot occur in the same execution trace.
next we define another rule related to lock unlock pairs.
in this rule we use postdom s3 s2 to mean after s2is executed s3is guaranteed to be executed as well.
norfs s1 s2 s1 s4 store s3 v1 postdom s3 s2 diffcs s2 s4 l1 samecs s2 s3 l1 therationalebehindthisrulecanbeexplainedusingthediagramin fig.
right .
here the loads and stores access the same variable.
if theread fromedge s1 s2 isaheadof s1 s4 inthesameexecution trace the store in s3contradicts to the read from edge s1 s4 .
finally we compute mayrfs based on norfs mayrfs s1 s2 s3 s4 norfs s1 s2 s3 s4 itmeanstheread fromedges s1 s2 and s3 s4 mayoccurtogether andinthatorderinsomeexecutiontrace.withmayrfs wecompute differences diffp1 and diffp2 by replacing mayrf with mayrfs.ourmethodforcomputingdifferencesofrank3orhigher are similar and we omit the details for brevity.
.
example for rank analysis fig.9showsanexamplethatillustratestherank 2analysis.here thread1 setstto0and xto1beforecreating thread2.duetolockunlock pairs the assertion cannot be violated in fig.
a .
however ifthelock unlockin thread1isremovedasinfig.
b theassertion may be violated because in between lines and there may be a context switch which was not allowed previously.
however the synchronization difference cannot be captured by anyindividual mayrfedge.infact thetableinfig.
10showsthat the two programs have the same set of mayrfedges.
in particular since there are two stores of x the load at line may read from both line and line .
to capture the difference we need rank analysis.
assume rf l1 l4 occurs first meaning thread2 acquires thelockand thusprevents thread1 fromacquiringthesamethread1 t x create t2 lock a ... assert x !
t unlock a thread2 ... lock a t x ... x unlock a ... rf rfrf a before change thread1 t x create t2 lock a ... assert x !
t unlock a thread2 ... lock a t x ... x unlock a ... rf hb2 rf b after change figure example programs with rank differences.
musthb fig9 a mayhb musthb mayrf rank2 musthb fig9 b mayhb musthb mayrf rank2 figure steps of our analysis for the programs in fig.
.
lock until thread2 exits the critical section.
it means the store at line will set xto .
therefore the load of xat line will have to read from line not from line .
in other words rf l1 l2 cannot occur after rf l1 l4 in the same execution.
assume rf l1 l2 occurs first and thread2 will not be executeduntil thread1finishes.inthiscase rf l1 l4 is allowed since no store of xis in thread1.
asaresult theprograminfig.
a allowstheorderedset rf l1 l2 rf l1 l4 but not the ordered set rf l1 l4 rf l1 l2 .
however theprograminfig.
b allowstheorderedset rf l1 l4 rf l1 l2 as well due to the removal of the lock unlock pairs inthread1.
specifically when rf l1 l4 occurs at the start of an execution thread1 may execute line before thread2 execute line which allows line to read the value of xfrom line .
our steps of conducting the rank analysis based on inference rulespresentedsofar areshowninfig.
.thereisnodifferencein themayrfsets however whencomparingtheorderedsetof mayrf edges wecanstillseethedifference.tosupportthisanalysis we apply the aforementioned inference rules of rank which checks the existence of .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france chungha sung shuvendu k. lahiri constantin enea and chao wang experiments we have implemented the method in a tool named ec diff which uses llvm as the frontend and z in z3 as the datalog solveratthebackend.specifically weuseclang llvmtoparsethe c c code of multithreaded programs and construct the llvm intermediaterepresentation ir .then wetraversethellvmir to generate program specific datalog facts.
these datalog facts whencombinedwithasetofprogram independentinferencerules form the entire datalog program.
finally the zdatalog solver is used to solve the program which repeatedly applies the rules to the fact until a fixed point is reached.
by querying relations in the fixed point we can retrieve the analysis result.
.
experimental setup we usedtwo setsof benchmarks inour experiments.the firstset ofbenchmarks consistsof41 multithreadedprograms whichpreviously have been used to illustrate concurrency bug patterns found in real applications .
with these programs our goal is to evaluate how well the various types of concurrency bugs are handled by our method and how our results comparetothatofthepriortechniquebasedonmodelchecking .
forthesebenchmarks thepriortechniqueisnotabletosoundly instrument all applications.
therefore we manually insert assertions to be checked later by the cbmc bounded model checker for detecting only one different edge.
the second set of benchmarks consists of medium sized applications from open source repositories they have also been used previously to evaluate testing and automated program repairtools.similarly wearenotabletoapplythepriortechnique because it has limitations to instrument large size programs and it is impossible for us to manually insert assertions.
nevertheless wecanevaluatehowefficientournewmethod ec diffisonthesereal applications.
in total our benchmarks has lines of c code.
for each benchmark program there are two versions one of whichistheoriginalprogramandtheotheristhechangedprogram.
thesechangedprogramsarepatchescollectedfromvarioussources some are from benchmarks used in prior research on testing andrepair whereasothersarefrombenchmarksusedin differentialanalysis .wealsocreatedfourprograms case1 to illustratemotivatingexamplesusedthroughoutthispaper.these benchmark programs together with our experimental data the llvm based tool as well as data obtained from applying the prior technique have been made available online1.
our experiments were designed specifically to answer the following research questions isournewmethod basedona fastandapproximate static analysisasopposedtoheavy weightmodelcheckingtechniques accurateenoughforidentifyingtheactualsynchronization differences in the benchmark programs?
is our new method significantly more efficient measured in terms of the analysis time than the prior technique based on model checking?
in all these experiments we used a computer with an intel corei5 cpu .
ghz x cpus with gb of ram running the ubuntu .
lts operating system.
results on the first set of benchmarks table1shows our results on the first set of benchmarks with programsillustratingcommonbugpatterns.columns1and2show thenameandthenumberoflinesofc code.column3showsthe number of threads.
column shows the type of bug illustrated by the program.
specifically sync.means the bug is due to misuse of locks and thus to repair it some lock unlock pairs have been added removedormodified cond.meansthebugisduetomisuse of condition variables and thus to repair it some signal wait pairs havebeenadded removedormodified th.order meansthebugis related to thread creation and join and thus involves thrdjoin or thrdcreate and order.means the bugis related to ordering of instructionsimposedbyad hocsynchronization.notethat ineach of these benchmarks there is some synchronization difference.
the remaining columns show the statistics reported by ec diff as well as the prior technique .
specifically column shows if ec diffdetected the synchronization difference.
column shows at which rank our analysis is conducted section we iteratively increasetherankstartingfrom1 untilasynchronizationdifference is detected.
to be efficient we bound the rank to during ourevaluation.
columns and show the number of differences in 12 t1 t2and 21 t2 t1.
for a rank analysis it is the numberofread fromedges forarank 2orrank 3analysis itisthe number of ordered sets of read from edges.
the next two columns show the total number of mayhb edges used to compute mayrf inp1andp2 respectively.
the last two columns compare the analysis time of our method andthemodelcheckingtimeofthepriortechnique tocheck one different edge.
for each benchmark we limit the run time to one hour.
our results show ec diffoften finishes each benchmark in a secondwhereasthepriortechniquecantakeupto2 384seconds rtl8169 .
in total ec difftook less than seconds whereas thepriortechniquetookmorethan3hours.intermsofaccuracy exceptforoneprogram ec diffdetectedallthesynchronization differences.
this has been confirmed through manual inspection wherethereporteddifferencesarecomparedwiththegroundtruth.
sincewehaverandomlylabeledtheoriginalandchangedprograms asp1andp2 some of the differences are in 12whereas the others arereportedin 21.intotal ec difffound251differencesin 12 and differences in 21. the missed difference resides in rtl8169 after running the rank analysis our method still could not find it.
the reason isbecause the differentiating behavior involves a deadlock and the patchthatremovedit.weexplainwhyourmethodcannotdetect it in section .
.
.
results on the second set of benchmarks table2shows our results on the second set of benchmarks consisting of six medium sized programs.
note that these programsarealreadyoutofthereachofthepriortechnique duetoits requirementofmanualcodeinstrumentation therefore weonlyreport the statistics of applying ec diff.
again the original and modified programs are randomly labeled as p1andp2 respectively to facilitate evaluation.
intotalec difffound30differencesin 12and42differencesin 21.furthermore allofthemwerefoundduringrank 1analysis and confirmed by manual inspection.
what is impressive is thatthese differences were identified by sifting through a combined authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
datalog based scalable semantic diffing of concurrent programs ase september montpellier france table experimental results on the first set of benchmark programs.
ec diff prior technique name loc threads type difference rank 12 21 of mayhb in p1 of mayhb in p2time s time s case1 sync.
yes .
.
case2 cond.
yes .
.
case3 th.order yes .
.64case4 sync.
yes .
.
i2c hid sync.
yes .
.
i2c hid noa sync.
yes .
.
r8169 order yes .
.
r8169 order yes .
.
r8169 order yes .
.
rtl8169 order yes .
.
rtl8169 order yes .
.
rtl8169 order no .
.
cherokee sync.
yes .
.
transmission cond.
yes .
.
apache sync.
yes .
.
apache sync.
yes .
.
account cond.
yes .
.
barrier cond.
yes .
.
boop sync.
yes .
.
fibbench cond.
yes .
.
lazy cond.
yes .
.
reorder cond.
yes .
.
threadrw cond.
yes .
.
lineeq 2t sync.
yes .
.
linux iio sync.
yes .
.
linux tg3 cond.
yes .
.
vectprime sync.
yes .
.
mozilla cond.
yes .
.
mysql cond.
yes .
.
mysql cond.
yes .
.
counter seq sync.
yes .
.
ms queue sync.
yes .
.
mysql5 sync.
yes .
.
freebsd a cond.
yes .
.
llvm cond.
yes .
.
gcc sync.
yes .
.
gcc sync.
yes .
.
gcc sync.
yes .
.
gcc sync.
yes .
.
glib sync.
yes .
.
jetty sync.
yes .
.
total .
3h .
means verification of the edge in p1succeeded but verification of the edge in p2timed out after an hour.
total of million mayhb edges and yet the analysis of all programstookonly140seconds.theefficiencyis inlargepart due to the restriction of our analysis on instructions that access global variables as opposed to all instructions in the program refer to the last paragraph of section .
.
otherwise the number of mayhb edges would have been orders of magnitude larger.
.
discussion now we answer the two research questions.
q1 isec diffaccurateenoughforidentifyingsynchronizationdifferences?
the answer is yes.
as shown in our experimental results ec diffproduced a large number of differences the majority of which are at rank which means they are individual read from edgesallowedinonlyoneofthetwoprograms while therestare at rank .
although we do not guarantee that ec difffinds alldifferentiating behaviors these detected ones have been confirmed by manual inspection.
given that these benchmarks contain real concurrency bug patterns reported and analyzed by many existing tools for testing and repair the result of ec diffis sufficiently accurate.
the success inalargepartisduetothenatureoftheseprograms wheretwo versionsbehavealmostsameexceptforthethreadsynchronization.
in such cases our approximate analysis can come really close to the ground truth.
q2 isec diffmore efficient than the prior technique based on model checking?
the answer is yes.
as shown in our results ec diffwas 10x to 1000x faster and in total completed the differential analysis of lines of multithreaded c code in about seconds.
in contrast thepriortechniquetookamuchlongertimetoanalyze these programs.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france chungha sung shuvendu k. lahiri constantin enea and chao wang table experimental results on the second set of benchmark programs.
ec diff name loc threads type difference rank 12 21 of mayhb in p1 of mayhb in p2time s pbzip th.order yes .
pbzip th.order yes .
aget cond.
yes .
aget cond.
yes .
pfscan cond.
yes .
pfscan cond.
yes .
total .
thread1 lock a lock b ...unlock b unlock a thread1 lock b lock a ...unlock a unlock b figure code from rtl8169 the original left and changed right versions.
thus we conclude that ec diffis effective in identifying synchronizationdifferencesinevolvingprograms.inpractice when developers update a program to fix concurrency bugs or remove performance bugs e.g.
by eliminating redundant locks the differences in behavior are often reflected in sets of data flow edges being feasible in one version but not in the other version.
thus computing these sets of data flow edges can be a fast way of checking if the changes introduce unexpected behaviors.
the missing case although ec diffdetected most of the actual differences itmissedonein rtl8169 .fig.
11showsthecodesnippet ofthread1 from the original program p1on the left and the changed program p2on the right .
the purpose of this patch is to resolve a deadlock issue by changing the acquisition order of locks.
sinceec difffocuses solely on data flow edges it is not able to detectbehavioraldifferencesrelatedtolockingonly.insomesense this is a limitation shared by techniques relying on the notion of abstract traces the two programs do not have data related semanticdifferenceotherthanthefactthatadeadlockexistsinone program but does not exist in the other program.
related work there has been prior work on statically computing the semantic differences of sequential and concurrent programs.
for sequential programs jackson and ladd p r o p o s e da method for computing the semantic differences by summarizing andcomparingthedependenciesbetweeninputandoutput.godlineandstrichman proposedtheuseofinferencerulestoprove the equivalence of two programs.
in the symdiffproject lahiri et al.
developedalanguage agnosticassertioncheckingtool for computing the differences ofimperative programs.
in the contextofincrementalsymbolicexecution variouschange impact analysistechniqueswereusedtoidentifyinstructionsthatareaffected by code modification and use the information to compute thecorrespondingtestinputs .however thesemethodsarenot directly applicable to concurrent programs.
for concurrent programs joshi et al.
proposed the use of failurefrequenciesofassertionstocomparetwoprograms while the general framework of refinement checking could also beappliedtotracesoftwoprograms.however thesetechniquesare limited to individual executions.
change impact analysis were alsoappliedtoconcurrentprograms e.g.
inregressiontesting prioritized scheduling and incremental symbolic execution .however thesetechniquesfocusonreducingthecost oftestingandanalysisasopposedtoidentifyingthesynchronization differences.
aswe havementionedearlier themostclosely relatedworkis that of bouajjani et al.
which computes the differences between partial data flow dependencies of two concurrent programs using a bounded model checker.
however the method is costly furthermore itrequirescodeinstrumentationtoinsertassertions so they can be verified using a model checker.
for example it took about30minutesforaprogram rtl8169 thatcanbeanalyzedby our method in less than a second.
our method relies on the datalog based declarative program analysis framework which previously has been applied to both sequentialandconcurrentprogramsaswellaswebapplications .inthecontextofstaticanalysisofconcurrentprograms forexample kusanoandwang used datalog in a thread modular abstract interpretation to check the feasibility of inter thread data flow edges on sequentially consistent and weaker memory models.
sung et al.
used a similar techniqueformodelingpreemptionschedulingofinterruptsand thus improving the accuracy of static analysis for interrupt driven programs.
however none of these existing methods computes the synchronization differences of evolving programs.
conclusions wehavepresenteda fastandapproximate staticanalysismethod forcomputingthesynchronizationdifferencesoftwoconcurrent programs.
the method uses datalog to capture structural information of the programs and uses a set of inference rules to codifythe analysis algorithm.
the analysis result computed by an off the shelf datalog solver consists of sets of data flow edges that are allowed by only one of the two programs.
we implemented theproposedmethodandevaluateditonalargenumberofbenchmark programs.
our results show the method is orders of magnitudes faster than the prior technique while being sufficiently accurate in identifying the actual differences.