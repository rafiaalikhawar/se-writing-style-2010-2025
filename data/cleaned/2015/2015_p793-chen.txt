guided differential testing of certificate validation in ssl tls implementations yuting chen department of computer science and engineering shanghai jiao tong university china chenyt cs.sjtu.edu.cnzhendong su department of computer science university of california davis usa su cs.ucdavis.edu abstract certificate validation in ssl tls implementations is critical for internet security.
there is recent strong effort namely frankencert in automatically synthesizing certificates for stress testing certificate validation.
despite its early promise it remains a significant challenge to generate effective test certificates as they are structurally complex with intricate syntactic and semantic constraints.
this paper tackles this challenge by introducing mucert a novel guided technique to much more effectively test real world certificate validation code.
our core insight is to leverage easily accessible internet certificates as seed certificates and diversify them by adapting markov chain monte carlo mcmc sampling.
the diversified certificates are then used to reveal discrepancies thus potential flaws among different certificate validation implementations.
we have implemented mucert and extensively evaluated it against frankencert.
our experimental results show that mucert is significantly more cost effective than frankencert.
indeed 1kmucerts i.e.
mucert mutated certificates yield three times as many distinct discrepancies as 8mfrankencerts i.e.
frankencert synthesized certificates and 200mucerts can achieve higher code coverage than 000frankencerts.
this improvement is significant as it incurs much cost to test each generated certificate.
we have analyzed and reported latent discrepancies presumably missed by frankencert and reported an additional discrepancy triggering certificates to ssl tls developers who have already confirmed some of our reported issues and are investigating causes of all the reported discrepancies.
in particular our reports have led to bug fixes active discussions in the community and proposed changes to relevant ietf s rfcs.
we believe that mucert is practical and effective for helping improve the robustness of ssl tls implementations.
more information on mucert and our results can be found at .
categories and subject descriptors d. .
testing and debugging testing tools e.g.
data generators coverage testing general terms algorithms keywords differential testing mutation certificate validation .
introduction secure sockets layer ssl and transport layer security tls are cryptographic protocols for security protection over the internet.
various implementations and libraries e.g.
openssl and nss exist to support the protocols they facilitate the incorporation of ssl tls in user applications.
all web browsers also support users in establishing ssl tls connections.
x. certificates provide the principal medium for websites and internet users to authenticate each other and establish secure ssl tls connections.
for example when a web browser requests anhttps connection to a website it will retrieve the site s x. certificate and validate it.
if the certificate fails in validation the browser will display a warning message to the user who may then refuse this connection.
but similar to any real world software ssl tls implementations or libraries may contain defects and in particular may not validate x. certificates correctly making certification validation the most dangerous code in the world .
indeed certificate validation has been completely broken in many security critical applications and libraries defects can be embedded into certificate validation code making ssl tls connections completely vulnerable or insecure.
certificate validation mainly checks given a server certificate whether it is well formed whether it has not expired and whether it is issued by a trusted certificate authority ca .
however all ssl tls implementations validate x. certificates by following a complicated ad hoc process described in several rfcs including rfc .
developers must define their respective validation policies for handling ambiguous descriptions e.g.
the serial number must be a positive integer assigned by the ca to each certificate ... non conforming cas may issue certificates with serial numbers that are negative or zero.
certificate users should be prepared to gracefully handle such certificates .
developers can also make minor mistakes such as misunderstanding the ssl tls application program interfaces apis using insecure middleware or libraries and breaking disabling certificate validation .
furthermore existing ssl tls implementations are not adequately tested before being released as test certificates have to be designed elaborately and mainly manually.
one main reason is that x. certificates are themselves structurally complex data each certificate is composed of several fields for identifying itself and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
793a sequence of extensions each field can encompass semantic and syntactic constraints and certificates must be carefully organized into certificate chains.
thus any test certificate must be constructed to conform to or deliberately violate the constraints which makes manual testing inevitably inadequate.
brubaker et al.
propose the first automated technique called frankencert to randomly combine parts of real certificates for differentially testing various ssl tls implementations.
this is a strong effort but the blind nature of frankencert makes it cost ineffective an enormous number of frankencerts are generated and tested so it is very resource intensive but most of the frankencerts do not trigger any discrepancies.
in particular frankencerts could only yield discrepancies which further reduce to only distinct ones among the many ssl tls implementations .
inspired by brubaker et al.
s work and recognizing its limitation we aim to generate effective test certificates and in particular our goal is to generate diverse certificates for testing.
by diverse we mean for example that some certificates should pass validation and some should not the certificates take different control flow paths and they enforce various validation policies or lead to different types of exceptions.
we cast effective test certificate generation as an optimization problem given certificates cert fcert cert cert ng construct cert0 fcert0 cert0 cert0 ngwhose certificates are as diverse as possible .
to this end we introduce mucert a novel guided approach to differential testing of certificate validation.
in particular mucert adapts markov chain monte carlo mcmc sampling to diversify certificates.
mcmc methods are a class of algorithms for sampling from a probability distribution by constructing a markov chain that converges to the desired distribution .
for many intractable problems without exact optimization algorithms mcmc sampling provides a general solution .
section discusses detailed design and technical challenges that we tackle to realize mucert such as choosing the acceptance condition and mutation operations.
this paper makes the following main contributions problem formulation .
we cast the difficult problem of certificate generation as an optimization problem which allows us to leverage the many easily accessable internet certificates and transform them to effectively test certificate validation logic.
this high level view is general and may be applicable in other settings with structurally complex test inputs.
mcmc guided certificate mutation .
we adapt mcmc sampling to effectively diversify certificates.
in particular we use code coverage to guide the sampling process to accept and retain representative certificates in the test suite.
to our knowledge this work is the first to utilize mcmc sampling for generating diverse test inputs in differential testing.
implementation and evaluation .
we have implemented mucert and compared it against frankencert and two other mutation algorithms on real world ssl tls implementations.
our results show that mucert significantly outperforms frankencert and the other techniques.
most notably 1kmucerts lead to as many distinct discrepancies as 8mfrankencerts demonstrating that mucert effectively diversifies certificates.
community feedback and impact .
we have also reported issues and an additional 357discrepancy triggering certificates and have already received confirmations and positive feedback from the ssl tls developers.
for example as a result of our reports arm mbed tls .
.
formerly known as polarssl started to forbid repeated extensions in x. certificates and active discussions on the reported certificates have led to proposed changes to ietf s relevant rfcs.the rest of the paper is structured as follows.
section presents the details of our guided technique including basic background on certificate validation mcmc guided certificate diversification and the differential testing process.
we next describe our extensive evaluation of mucert against frankencert and two other certificate mutation algorithms to demonstrate mucert s effectiveness section .
section surveys related work and section concludes.
.
approach this section presents the technical details of our approach.
we discuss necessary background on certification validation introduce our mcmc guided certificate mutation algorithm and describe our differential testing process.
.
background x. certificate validation an input to certificate validation is a chain of x. certificates.
each certificate consists of a sequence of three required fields certificate which contains a subject and an issuer a public key associated with the subject a validity period and other information.
an x. v3 certificate also has extensions that can convey such data as additional subject identification information policy information and certification path constraints certificate signature algorithm the identifier for the signature algorithm used by a certificate authority ca to sign this certificate and certificate signature a digital signature for the certificate.
in a public key infrastructure pki a certificate does not exist in isolation but is recursively organized together with its issuers into a certificate chain .
a certificate chain usually starts with an end entity certificate followed by a list of certificates and the ca certificates.
figure illustrates a typical certificate chain where the issuer of each certificate is the subject of the next certificate each certificate is signed by the next certificate and the last certificate is a self signed trust anchor.
given a certificate an ssl tls implementation mainly validates whether it can be chained to a trusted root certificate and whether each certificate on the chain is valid at the current time .
.
guided certificate optimization intuitively one may collect x. certificates from the internet to test ssl tls implementations although these real certificates unlikely expose flaws in validation code.
on the other extreme is frankencert which randomly combines pieces of real certificates to construct fake ones most of which are invalid and useless for testing.
instead we strive to find a sweet spot between the two extremes by systematically and continuously mutating a set of real certificates to make them diverse i.e.
following different program paths triggering different validation policies or triggering different error handlers for testing certificate validation logic.
.
.
mcmc sampling and fitness function for our purpose we adapt mcmc sampling to optimize a test suite with a fixed number of test certificates.
we utilize code coverage as the fitness function to balance our optimization goal and the easiness of measurement.
another reason for using code coverage as the fitness function is that code coverage is shown to strongly correlate with the output uniqueness of a test suite one manifestation of its diversity .
letcov cert be defined for computing the code coverage of a test suite cert w.r.t.
a given ssl tls implementation e.g.
openssl cov cert cov cert cov certn g18 g286 g396 g410 g1004 g68 g286 g410 g396 g381 g393 g381 g367 g349 g400 g3 g272 g346 g381 g349 g272 g286 g373 g437 g410 g258 g410 g286 g18 g286 g396 g410 g1004 g918 g18 g286 g396 g410 g1005 g373 g437 g410 g258 g410 g286 g18 g286 g396 g410 g1005 g918 g68 g286 g410 g396 g381 g393 g381 g367 g349 g400 g3 g272 g346 g381 g349 g272 g286 g18 g286 g396 g410 g1006 g856 g856 g856 g18 g286 g396 g410 g349 g373 g437 g410 g258 g410 g286 g18 g286 g396 g410 g349 g918 g68 g286 g410 g396 g381 g393 g381 g367 g349 g400 g3 g272 g346 g381 g349 g272 g286 g856 g856 g856 g18 g286 g396 g410 g374 g882 g1005 g373 g437 g410 g258 g410 g286 g18 g286 g396 g410 g374 g882 g1005 g918 g68 g286 g410 g396 g381 g393 g381 g367 g349 g400 g3 g272 g346 g381 g349 g272 g286 g18 g286 g396 g410 g374 g17 g437 g396 g374 g882 g349 g374 g3 g393 g346 g258 g400 g286 g94 g258 g373 g393 g367 g349 g374 g336 g3 g393 g346 g258 g400 g286figure mcmc guided certificate optimization.
certificate certificate certificate version version version serial number serial number serial number algorithm id algorithm id algorithm id issuer issuer issuer validity not before after validity not before aft er validity not before after subject subject subject subject public key info subject public key info subje ct public key info public key algorithm public key algorithm public key algorithm subject public key subject public key subject public key issuer unique identifier issuer unique identifier iss uer unique identifier subject unique identifier subject unique identifier s ubject unique identifier extensions extensions extensions ... ... ... certificate signature algorithmcertificate signature algorithmcertificate signature algorithm certificate signature certificate signature certifica te signature leaf cert enterprise ca cert root ca cert figure a typical certificate chain.
wherecov cert denotes the coverage achieved by an individual certificatecert and allows the coverage to be computed cumulatively.
in our setting code coverage helps make the test suite accept fresh test certificates.
let cert incert be mutated to cert0in cert0 see section .
.
.
let cov cert cov cert0 .
the certificatecert0is obviously distinct from cert or any other certificates incert0 as it exploits some new validation code or branches .
therefore code coverage provides the first means to approach the optimization goal that is given the test suite cert how can it be mutated continuously to optimizedcert such that cov cert cov optimizedcert wherecov cert cov optimizedcert denotes that the coverage should be increased as much as possible and is an upper bound of coverage that can be achieved by any test suite.
mcmc sampling provides another opportunity even if the coverage of a test suite cannot get increased to stochastically diversify the test certificates inside.
mcmc advocates the idea of sampling from a probability distribution by constructing a markov chain which converges to the desired distribution.
when applied to optimization mcmc sampling can work as an intelligent hill climbing method and thus creates sufficient samples most of which will be taken from the optimal values of the adopted fitness function.
in our setting each sample corresponds to a test suite.
.
.
sampling processalgorithm mcmc guided algorithm to optimize certificates input certificate corpus certstore n k output test suite ofncertificates selectnrandom certificates from certstore and add to cert highest cov cov cert optimizedcerts fcertg repeat cert random choice cert mutator random choice mutator cert0 apply mutator cert cert0 certnfcertg fcert0g ifhighest cov cov cert0 then highest cov cov cert0 optimizedcerts fcert0g else ifhighest cov cov cert0 then optimizedcerts optimizedcerts fcert0g accept certs0according to a cert!cert0 ifaccepted then cert cert0 untilhighest covhas not been increased for ksteps optimizedcert random choice optimizedcerts returnoptimizedcert for mcmc sampling mucert at first transforms the fitness function into a probability density function by following a commonly used approach p cert zexp cov cert ?
where is a constant za partition function that normalizes the distribution and?a lower bound of coverage that can be achieved by a test suite.
mucert then adopts the metropolis hastings algorithm for generating markov chains.
the metropolis hastings algorithm is an mcmc method for obtaining random samples from a probability distribution.
it works by generating a sequence of samples whose distribution closely approximates the desired distribution samples are produced iteratively with the distribution of the next sample say s0 being dependent only on the current one say s .
as figure shows in the burn in phase the coverage of the samples increases rapidly while in the sampling phase all samples hold high coverage values but their diversities stochastically vary.
we use metropolis choicea s!s0 for sampling acceptance or rejection a s!s0 min p s0 p s g s0!s g s!s0 cov cert cov cert cov cert cov cert cov cert cov cert figure an example of coverage information tree.
when one leaf node cov cert is updated the tree is updated in a bottom up style.
all updated nodes are colored in brown.
whereg s!s0 is the proposal distribution describing the conditional probability of proposing a new sample s0givens.
the proposal distribution in our setting is symmetric thus the acceptance probability is reduced to a cert!cert0 min p cert0 p cert min exp cov1 cov2 wherecov1 cov cert andcov2 cov cert0 .
the acceptance probability can be directly computed from the coverage functioncov .
let be a negative constant in .
the importance of a cert!cert0 is ifcov cert cov cert0 the proposal is always accepted otherwise the proposal is accepted with a certain small probability namely exp cov cert0 cov cert .
further the smaller cov cert0 cov cert is the less the acceptance probability will be.
for example let be cov cert be7200 sloc let cov cert andcov cert be7180 sloc and sloc respectively.
cert 1is easier to accept thancert 2because a cert!certs and a cert!certs algorithm shows the mucert algorithm for certificate optimization.
it first selects a test suite of ncertificates certificate chains more rigorously .
it then performs a number of iterations.
during each iteration exactly one certificate is chosen and mutated.
the algorithm chooses one sample with the highest coverage as an optimal solution theoretically any sample can be chosen for testing .
notice that mucert mutates an x. certificate or a certificate chain by rewriting the certificate or rewriting one certificate in the chain which we will explain in section .
.
.
.
.
certificate mutation we define mutators mutation operations for supporting certificate mutation.
mucert randomly picks a certificate or a chain and mutates it expecting that the mutant can exploit some new validation policies in the validation code.
as table shows these mutators are classified into two categories .chain mutator.
a chain mutator is used to update a certificate chain e.g.
inserting one certificate into the chain or deleting one from the chain.
a chain mutator is usually performed together with an updating of the issuers of the certificates on the chain so that each certificate is issued by the subsequent one.
.certificate mutator.
a certificate mutator is used to update a single certificate e.g.
rewriting the expiration date or addingtable sample mutation operations used.
category operations insert a certificate at a given position of a chain chain append a certificate to a chain mutator delete a certificate from a chain replace one certificate in a chain with another rewrite a certificate field e.g.
notafter notbefore serial number subject extensions rewrite a subject field of a certificate e.g.
countryname stateorprovincename stateorprovincename localityname organizationname organizationalunitname commonname emailaddress name title certificate append a set of extensions to the certificate mutator append one extension to the certificate rewrite the criticality of one extension rewrite one extension delete a certificate field or a subject filed an extension to the certificate.
nevertheless when the subject of a certificate is updated the issuer of the preceding certificate may be updated.
when its issuer is updated the subject of the subsequent certificate may be updated.
further we can mutate a certificate by deleting one of its fields in order to check whether the mutant can trigger some parsing errors or validation problems.
we prefer a grafting strategy when rewriting a certificate or its field.
given a certificate chain we can replace one certificate with an invader certificate that is randomly chosen from the certificate corpus.
similarly we can insert the invader into the chain or use its field to update the corresponding field of a certificate in the chain.
we can also choose one or more extensions of the invader certificate and add them into a certificate.
such a strategy helps produce syntactically correct mutants that otherwise might have been rejected early during validation due to trivial parsing errors.
.
differential testing we have implemented a testing framework in python to realize and utilize mucert.
figure illustrates the framework which contains two key components test certificate optimization and differential testing certificate optimization.
mucert selects a set of ncertificates at random and then performs an mcmc sampling process.
one sample with the highest coverage is chosen for testing.
differential testing.
differential testing is a mature testing technology for large software systems a test case is randomly generated and output is compared for a variety of systems.
in our work we employ the generated mucerts to test commonly used ssl tls implementations including openssl polarssl gnutls nss cyassl and matrixssl and web browsers including google s chrome mozilla s firefox and microsoft s internet explorer and then compare the validation results.
any behavior discrepancies among these implementations become oracles for finding flaws in their certificate validation code.
.
.
certificate validation in testing an ssl tls implementation can validate an x. certificate or a certificate chain in either a file mode or a client server c s mode or both.
the file mode provides a rather simple validation 796step certificate mutation step differential testing openssl polarssl cyassl chrome ...cert cert cert ... ...cert cert ...certificate validation code certificate mutantsvalidation results certs with disprecencies defect reportcert cert cert ...cert choosemutatecert cert cert ...cert covcompute coveragecov compute coverage accept or reject?reject accept cert cert g255 g255 g255 g255accept complete testingcert dbfigure guided differential testing of certificate validation.
style allowing the implementation to load and validate a pem file containing one or more certificates.
the c s mode provides a typical but slightly more complicated validation solution requiring a client to retrieve a server certificate and then validate it.
table shows the supportability of the ssl tls tools and browsers to the two validation modes.
note that cyassl and matrixssl do not provide released utilities for validating certificate files.
although the c s validation mode is supported by all of the implementations it is still difficult to validate a large number of certificates since each website is usually secured by only one certificate.
a browser mainly validates a certificate when it connects to a server while up to now we do not have any tools that can forge a web browser when it connects to a spoofed domain name matching to the domain name appearing in a certificate .
thus mucert adopts both modes to test ssl tls implementations .
test openssl polarssl gnutls and nss in file mode .test cyassl and matrixssl in c s mode.
we use the server in brubaker et al.
to warp and send the mutated certificates and use the clients released in cyassl matrixssl to retrieve and validate the certificates.
each client takes three arguments host port path to the file with trusted root certificates and makes an ssl .
connection to the host port.
the client records the validation results including error codes if any .import the certificates into the certificate databases used by the web browsers chrome firefox and internet explorer .
we assume that a validation is performed when a certificate is imported1.
we also use the browsers to connect a localhost 1in fact a certificate manager does not validate the trusted certificates see section .
.table supported validation modes by ssl tls implementations.
ssl tls tools file mode with standalone validation c s or libraries utility or certificate manager mode openssl .
.1j y openssl y polarssl .
.
y cert app y gnutls .
.
y certtool y nss .
.
y certutil y cyassl .
.
y matrixssl .
y chrome .
.
.
y an os level certificate manager y mozilla s firefox .
y psm nss y internet explorer .
.
y microsoft management console y openssl polarssl gnutls nss cyassl matrixssl chrome ubuntu firefox ubuntu ie windows cert0 x x rejected accepted x skipped figure result encoding example.
server on which fake certificates with the common name localhost are deployed and check whether the browsers can be forged in ssl tls connections.
.
.
discrepancy representation the validation results among the ssl tls implementations can be discrepant indicating that a certificate can be accepted by some implementations but rejected by the others.
in this work we encode the validation results for facilitating computation of the diversity of a test suite and identification of the subtle discrepancies and their root causes.
let each validation result be simplified to rejected or accepted .
as figure illustrates the validation results for a certificate can be encoded into a sequence of bits representing that the certificate is accepted by polarssl gnutls chrome ie but rejected by openssl nss firefox.
in cases where the validation is skipped e.g.
due to a server connection error we mark the corresponding bit as x .
therefore a behavior discrepancy can appear if a sequence is not all zeros or all ones x is omitted two discrepancies can be classified into one category if their encoded results are equal again x is omitted .
theoretically a sequence ofkbits has at most 2kpossible values.
in our setting the results can be reduced to at most distinct discrepancies.
.
empirical ev aluation we have conducted an extensive evaluation to compare mucert with frankencert and two other mutation algorithms.
our results show that mucert is significantly more cost effective than the other algorithms.
in particular mucerts can achieve higher code coverage than 000frankencerts.
more importantly mucert diversifies a test suite even if its coverage is not increased making 1k mucerts yield .
times as many distinct discrepancies as frankencerts in the experiment and times as many as those reported by brubaker et al.
.
we have reported latent discrepancies and an additional discrepancy triggering certificates to ssl tls developers who have been investigating causes of the reported discrepancies and identifying flaws in their implementations.
our reported certificates have also led to active discussions in the community and even proposed changes to ietf s rfcs.
the rest of the section presents our detailed results and analysis.
.
setup our empirical evaluation of mucert is designed to answer the following research questions coverage what coverage can be achieved by mucerts when used for testing of ssl tls implementations?
precision how precise are the mucerts for uncovering discrepancies among certificate validation code?
diversity are the mucerts diverse?
flaws can the discrepancies pinpoint any real flaws in certificate validation code?
.
.
preparation mucert optimizes a set of certificates iteratively guided by achieved code coverage w.r.t.
a specific ssl tls implementation.
for the initial seed certifates we use a collection of certificates provided by frankencert .
these certificates were gathered using zmap by scanning the internet and attempting ssl connections to hosts listening on port .
if a connection was successful the certificate presented by the server was added to the collection.
as for the reference ssl tls implementation we use openssl1.
.1j and the objective is to optimize mucerts to cover the source code of openssl as much as possible.
we consider both statementandbranch coverage optimized search heuristics which we call sosh and bosh repsectively to direct certificate mutations.
we use the mature widely adopted coverage tool gcov lcov to collect coverage statistics.
our evaluation was conducted on a bit ubuntu .
lts desktop with an intel core i7 cpu and 16gb ram .
we performed differential testing on nine ssl tools and browsers including openssl .
.1j polarssl .
.
gnutls .
.
nss .
.
cyassl .
.
matrixssl .
google s chrome .
.
.
mozilla s firefox .
and microsoft s internet explorer .
.
.
except internet explorer all these tools and browsers were tested on the 64bit ubuntu .
lts machine.
internet explorer was tested on a bit windows enterprise desktop with an intel core i5 2430m cpu and 4gb ram .
.
.
evaluated methods and metrics we evaluated mucert against three other methods frankencert frankencert produces a number of fake certificates that are randomly synthesized from parts of real certificates.
thus frankencerts include unusual combinations of extensions and constraints randmut it is a random mutation algorithm that we designed to compare against mucert.
it performs random mutation operations on the certificates in a test suite and greedymut it is a greedy mutation algorithm that we designed also for the purpose of demonstrating mucert s capability.
it is similar to mucert and computes the coverage w.r.t.
a sample.
it differs from mucert in that it will accept a proposed sample if the sample leads to increased coverage and otherwise rejects the sample.
we record several metrics during the evaluation.
we report the covered statements and branches by the test suites.
the more program statements branches are covered the more validation policies can be triggered by the corresponding test suites.
we also normalize the coverage cov using the following formula normcov cov ?
?
where?and are respectively the lower and the upper bounds of the coverage values.
we do not use the absolute coverage rates asopenssl supports a rich set of functions while many e.g.
generation of self signed certificates and private keys do not concern certificate validation.
for the same reason we can only approximate the lower and the upper bounds but not their actual values which suffice for guiding certificate mutation.
we record any discovered validation discrepancies and compute theprecision of a test suite cert as follows precision jdcertj jcertj wherejcertjdenotes the number of certificates in the test suite and dcert a subset of the certificates that trigger discrepancies.
the more discrepancies discovered by a test suite with a fixed number of certificates the more precise the test suite is.
we compute the diversity of a test suite using the formula diversity jddcertj jcertj wherejddcertjdenotes the number of distinct discrepancies and the numerator jddcertj denotes the number of distinct encoded results 2f0 2gto count for the all zeros and all ones if they exist .
the more distinct discrepancies found the more diverse are the certificates in the test suite.
in practice neither discrepancies nor diversity can be conveniently computed during certificate generation due to the very different validation styles of ssl tls implementations.
in our evaluation we will show that mcmc sampling does indeed help diversify a test suite besides increasing coverage see section .
.
.
results on certificate generation mucert randmut and greedymut all require an initial set of ncertificates but take their respective strategies to optimize the set.
in the evaluation we include in the initial set all 006certificate chains in the corpus n .
when using randmut we perform mutation operations while for greedymut and mucert we continue to mutate the certificates until the coverage does not increase for k k iterations.
for a straightforward direct comparison of various methods we produce 000frankencerts.
table and figure show the code coverage of the test suites on openssl which has sloc and branches in total.
we use the minimal values sloc and branches in table to approximate the lower bound ?
and the maximum values sloc and branches for the upper bound .
the last column shows the normalized coverage achieved.
finding 1kmucerts achieve up to higher normalized coverage than 1kfrankencerts mucerts achieve higher coverage than100kfrankencerts.
both mucert and greedymut achieve high coverage lines and branches regardless of the values ofkand .
in contrast frankencert and randmut achieve as low coverage as the initial set 2indicating that the validation code is inadequately tested by their certificates.
in particular mucerts can achieve higher coverage than 100kfrankencerts demonstrating that mucerts are more effective in testing than frankencerts.
although mucerts and greedymut certificates achieve similar coverage values mucerts are more diverse than the greedymut certificates as the coverage of the former increases more rapidly than the latter.
2the certificates in the initial corpus cannot pass validation because they are validated against a special ca certificate but not the certificates of their issuers.
798table coverage achieved by the test suites w.r.t.
openssl .
greedymut and mucert use sosh while greedymut and mucert use bosh.
the arguments for greedymut and mucert are greedymut k greedymut k mucert k mucert k mucert k mucert k .
certification generation jcertj normcov approaches cov.
jcertj initial test suite stmt.
.
branch .
frankencert stmt.
.
.
branch .
.
randmut stmt.
.
branch .
greedymut stmt.
.
branch .
stmt.
greedymut stmt.
cov.
branch .
optimized mucert stmt.
.
search branch .
sosh mucert stmt.
.
branch .
greedymut stmt.
.
branch .
branch greedymut stmt.
.
cov.
branch optimized mucert stmt.
?
.
search branch ?
.
bosh mucert stmt.
.
branch .
.
.
.
.
.
.
.
.
.
g2419 g2419 g2419 g2419 initial set frankencert randmut greedymut mucert test certificates executedkloc a statement coverage.
.
.
.
.
.
.
000initial set frankencert randmut greedymut mucert test certificates executed g104 g104 g104 g1041000 branches b branch coverage.
figure coverage achieved by the test suites.
the x axis shows the numbers of executed certificates.
for brevity we omit greedymut and mucert .
finding compared with the simpler sosh bosh does not lead to improved coverage.
mucert and mucert achieve similar statement and branch coverage values which shows that even the simpler sosh can help achieve high code coverage when the test suite has been sufficiently mutated and diversified.
finding greedymut mucert generate certificates more slowly.
table compares the time spent by different approaches on generating certificates.
as the table shows frankencert generates certificates quickly since it adopts the simple synthesis strategy for test certificate generation.
greedymut and mucert spend much moretable time spent on generating certificates and iterations.
the time budget is days i.e.
seconds .
iterations time seconds frankencert randmut greedymut greedymut greedymut greedymut timeout mucert mucert mucert mucert timeout time on generating certificates since they need to compute the coverage of each sample for guiding the acceptance rejection of the next sample.
greedymut and mucert spend on average more time than greedymut and mucert at each iteration because when bosh is employed lcov needs to generate and merge large tracing files containing branch coverage information.
both greedymut and mucert reach a steady state when the coverage does not increase after i.e.
iterations k iterations.
when using sosh greedymut and mucert reach their steady states in up to .
hours while when using bosh they reach their steady states in more than .
hours.
.
results on discrepancy analysis table shows the discrepancies found in testing.
the last two columns list the precisions and diversities of different approaches.
799table discrepancies discovered by the respective test certificates.
10k 100k all accepted all rejected jddcertjprecision diversity initial set .
frankencert .
.
.
.
randmut .
.
greedymut .
.
greedymut .
.
greedymut .
.
greedymut .
.
mucert .
.
mucert .
.
mucert .
.
mucert .
.
g1004 g1009 g1004 g1005 g1004 g1004 g1005 g1009 g1004 g1006 g1004 g1004 g1006 g1009 g1004 g1007 g1004 g1004 g1007 g1009 g1004 g1006 g1004 g1004 g1008 g1004 g1004 g1010 g1004 g1004 g1012 g1004 g1004 g1005 g1004 g1004 g1010 g100 g286 g400 g410 g3 g272 g286 g396 g410 g349 g296 g349 g272 g258 g410 g286 g400 g3 g286 g454 g286 g272 g437 g410 g286 g282 g349 g374 g349 g410 g349 g258 g367 g3 g400 g286 g410 g296 g396 g258 g374 g364 g286 g374 g272 g286 g396 g410 g396 g258 g374 g282 g373 g437 g410 g336 g396 g286 g286 g282 g455 g373 g437 g410 g882 g1005 g336 g396 g286 g286 g282 g455 g373 g437 g410 g882 g1006 g336 g396 g286 g286 g282 g455 g373 g437 g410 g882 g1007 g336 g396 g286 g286 g282 g455 g373 g437 g410 g882 g1008 g373 g437 g272 g286 g396 g410 g882 g1005 g373 g437 g272 g286 g396 g410 g882 g1006 g373 g437 g272 g286 g396 g410 g882 g1007 g373 g437 g272 g286 g396 g410 g882 g1008 g878 g24 g18 g286 g396 g410 g878 a discrepancies.
g1004 g1009 g1008 g1008 g1008 g1007 g1007 g1006 g1011 g1006 g1010 g1006 g1012 g1005 g1011 g1004 g1009 g1005 g1004 g1005 g1009 g1006 g1004 g1006 g1009 g1007 g1004 g878 g24 g24 g18 g286 g396 g410 g878 g1005 g1007 b distinct discrepancies.
g1004 g1005 g856 g1013 g1013 g1006 g1007 g856 g1007 g1010 g1004 g856 g1009 g1004 g856 g1009 g1004 g856 g1009 g1004 g856 g1009 g1005 g1009 g856 g1006 g1005 g1006 g1012 g856 g1011 g1007 g1006 g1009 g856 g1004 g1009 g1005 g1004 g856 g1011 g1008 g1004 g1009 g1005 g1004 g1005 g1009 g1006 g1004 g1006 g1009 g1007 g1004 g1007 g1009 g1081 g1006 g856 g1011 g1008 c precision.
g1004 g856 g1005 g1004 g856 g1010 g1004 g856 g1009 g1004 g856 g1009 g1004 g856 g1009 g1004 g856 g1008 g1004 g856 g1008 g1006 g856 g1011 g1012 g1006 g856 g1010 g1012 g1006 g856 g1013 g1012 g1005 g856 g1011 g1013 g1004 g1004 g856 g1009 g1005 g1005 g856 g1009 g1006 g1006 g856 g1009 g1007 g1007 g856 g1009 g1081 d diversity.
figure discrepancy analysis.
the columns in orange hold the values for frankencerts when jcertj .
g1011 g1005 g1004 g1004 g1011 g1006 g1004 g1004 g1011 g1007 g1004 g1004 g1011 g1008 g1004 g1004 g1011 g1009 g1004 g1004 g1011 g1010 g1004 g1004 g1011 g1011 g1004 g1004 g1005 g1008 g1011 g1008 g1013 g1008 g1011 g1005 g1008 g1006 g1004 g1005 g1012 g1013 g1007 g1006 g1007 g1010 g1010 g1006 g1012 g1007 g1013 g1007 g1007 g1005 g1006 g1007 g1011 g1012 g1009 g1008 g1006 g1009 g1012 g1008 g1011 g1007 g1005 g1009 g1006 g1004 g1008 g1009 g1010 g1011 g1011 g1010 g1005 g1009 g1004 g1010 g1010 g1006 g1007 g1011 g1004 g1013 g1010 g1011 g1009 g1010 g1013 g1012 g1004 g1008 g1006 g1012 g1009 g1005 g1009 g1012 g1013 g1012 g1012 g1013 g1008 g1010 g1005 g13099 g13099 g13099 g13099 g2119 g2119 g2119 g2119 g1007 g13099 g13099 g13099 g13099 g2119 g2119 g2119 g2119 g1009 g373 g437 g272 g286 g396 g410 g882 g1006 g373 g437 g272 g286 g396 g410 g882 g1008 g349 g410 g286 g396 g258 g410 g349 g381 g374 g400 g62 g75 g18 a coverage g1004 g1009 g1004 g1005 g1004 g1004 g1005 g1009 g1004 g1006 g1004 g1004 g1006 g1009 g1004 g1007 g1004 g1004 g1009 g1008 g1006 g1004 g1012 g1007 g1009 g1005 g1006 g1009 g1004 g1005 g1010 g1010 g1009 g1006 g1004 g1012 g1004 g1006 g1008 g1013 g1009 g1006 g1013 g1005 g1004 g1007 g1007 g1006 g1009 g1007 g1011 g1008 g1004 g1008 g1005 g1009 g1009 g1008 g1009 g1011 g1004 g1008 g1013 g1012 g1009 g1009 g1008 g1004 g1004 g1009 g1012 g1005 g1009 g1010 g1006 g1007 g1004 g1010 g1010 g1008 g1009 g1011 g1004 g1010 g1004 g1011 g1008 g1011 g1009 g1011 g1012 g1013 g1004 g1012 g1007 g1004 g1009 g1012 g1011 g1006 g1004 g13099 g13099 g13099 g13099 g2119 g2119 g2119 g2119 g1007 g13099 g13099 g13099 g13099 g2119 g2119 g2119 g2119 g1009 g373 g437 g272 g286 g396 g410 g882 g1006 g373 g437 g272 g286 g396 g410 g882 g1008 g349 g410 g286 g396 g258 g410 g349 g381 g374 g400 g951 g24 g18 g286 g396 g410 dcert b discrepancy g1004 g1005 g1006 g1007 g1008 g1009 g1010 g1011 g1012 g1013 g1005 g1004 g1009 g1008 g1006 g1004 g1012 g1007 g1009 g1005 g1006 g1009 g1004 g1005 g1010 g1010 g1009 g1006 g1004 g1012 g1004 g1006 g1008 g1013 g1009 g1006 g1013 g1005 g1004 g1007 g1007 g1006 g1009 g1007 g1011 g1008 g1004 g1008 g1005 g1009 g1009 g1008 g1009 g1011 g1004 g1008 g1013 g1012 g1009 g1009 g1008 g1004 g1004 g1009 g1012 g1005 g1009 g1010 g1006 g1007 g1004 g1010 g1010 g1008 g1009 g1011 g1004 g1010 g1004 g1011 g1008 g1011 g1009 g1011 g1012 g1013 g1004 g1012 g1007 g1004 g1009 g1012 g1011 g1006 g1004 g13099 g13099 g13099 g13099 g2119 g2119 g2119 g2119 g1007 g13099 g13099 g13099 g13099 g2119 g2119 g2119 g2119 g1009 g373 g437 g272 g286 g396 g410 g882 g1006 g373 g437 g272 g286 g396 g410 g882 g1008 g349 g410 g286 g396 g258 g410 g349 g381 g374 g400 g951 g24 g24 g18 g286 g396 g410 ddcert c distinct discrepancies figure correlation between coverage and discrepancies.
the x axis stands for the numbers of iterations.
table validation results of the mucerts.
a certificate is accepted by firefox chrome or ie if it can be imported into the certificate manager without any warning messages.
any parsing error reported by browsers is taken as a rejection.
openssl polarssl gnutls nss cyassl matrixssl firefox chrome ie accepted not parsable rejected 800figures a and b compare the discrepancies and distinct ones found by the different approaches respectively c and d compare their precisions and diversities respectively.
finding 1kmucerts trigger up to .
as many discrepancies and .
as many distinct discrepancies as 1kfrankencerts 1kmucerts trigger up to .
as many distinct discrepancies as 100kfrankencerts.
randmut and mucert trigger the most number of discrepancies whenjcertj .
on average of mucerts can trigger discrepancies and each mucert mutated test suite can help identify about distinct discrepancies.
in comparison .
of 100k frankencerts can only trigger distinct discrepancies as most frankencerts are rejected due to trivial parsing errors.
in particular 1kmucert certificates can trigger .
as many discrepancies as1kfrankencerts 1kmucert certificates can trigger .
and .
as many distinct discrepancies as 1kand100kfrankencerts respectively.
many discrepancies have also been discovered by the randmut certificates but they are reduced to only four distinct discrepancies.
this shows that most discrepancies found by randmut certificates are redundant.
finding mucerts achieve .
precision and .
diversity all distinct discrepancies found by frankencerts and randmut greedymut certificates are also found by mucerts.
up to .
of mucerts reveal discrepancies so do .
frankencerts .
randmut certificates and .
greedymut certificates.
mxucerts achieve up to .
diversity while the others achieve only less than .
.
these results show that mucert is much more cost effective than frankencert and greedymut.
in addition we have observed that each distinct discrepancy found by frankencerts and randmut greedymut certificates is also discovered by mucerts.
finding mucert can stochastically diversify a test suite even when it does not further increase test coverage.
we have investigated the samples generated by mucert and observed how the coverage and discrepancies vary w.r.t.
the number of iterations.
to make the analysis feasible we selected one sample every five iterations and only ran these test suites on openssl polarssl gnutls and nss and identified validation discrepancies.
figure a shows that a test suite can approach a peak coverage value after about iterations.
nevertheless mcmc sampling continues to diversify the test suite figures b and c show that more distinct discrepancies can be triggered by the samples even if their coverage does not increase or even decrease .
in addition we observe that most discrepancies and distinct ones are discovered by the samples between and iterations but the numbers decrease slowly in subsequent iterations.
one main reason for this is that the proposed distribution of mcmc sampling is in fact not symmetric mucert needs to parse a certificate and then mutate it so a valid certificate can be mutated to a mutant with parsing errors but the opposite direction is usually infeasible.
for example 1kmucert certificates can contain .
certificates with parsing errors w.r.t.
openssl after iterations.
.
bug reports and developer feedback we have reported distinct discrepancies and an additional discrepancy triggering mucerts to ssl tls developers maintainers.
these certificates illustrate prevalent validation discrepancies among the different implementations.
as table shows openssl does not report any parsing errors during validation as the certificates were created by openssl.
polarssl tends to accept more certificate chains having self signed certificates than openssl gnutls andnss.
certificates are accepted by both matrixssl and cyassl and rejected by both while the remaining are accepted by one and rejected by the other.
browsers also behave differently when certificates are imported and certificates can be imported into firefox and ie s certificate managers without triggering any warning messages respectively while chrome accepts nearly all certificates except one expired and another failed to parse.
finding certificate validation discrepancies are prevalent.
however this does not necessarily indicate that ssl tls connections are insecure because the discrepancies more likely exhibit compatibility issues among ssl tls implementations.
for example certificates in the test suite are issued by an issuer with a valid private key and thus the certificate chains can pass validation if they are well formed and have not expired.
but some ssl tls implementations also validate malformed certificate chains.
to date we have yet to find any real exploits that maliciously use the discrepancies we have found although it has been reported that parsing differences between ca software and browser certificate validation code can be exploited as man in the middle attacks .
we have also made some fake certificates issued by a valid ca certificate with a fake private key and checked whether they could trigger any discrepancies.
they are similar to some real man in themiddle attacks.
finding developers do have many doubts and concerns when implementing certificate validation code.
openssl security team admitted that there are a lot of certificates that can violate rfcs but they cannot reject all of them unless they are certainly security related.
polarssl developers have confirmed a parsing error one certificate has relativedistinguishedname that contains more than one attributetypeandvalue .
they explained that they were unsure if such structured names were actually used and thus they were hesitant to increase code complexity in order to cover that case.
they have fixed the naming problem in their internal development branch and the patch will be included in the next release.
openssl gnutls polarssl and matrixssl behave differently when a certificate has two instances of the subjectkeyidentifier .
this finding has triggered an open question on ietf pkix 3which further requires the ietf pkix tls working groups to investigate the necessity of matching aki ski certificate extensions during certificate validation and inconsistencies among rfcs and .
arm mbed tls developers also started to forbid repeated extensions in x. certificates4because rfc states that a certificate must not include more than one instance of a particular extension .
gnutls developers replied that although the certificate could be accepted in certificate verification a user would receive warning messages when printing it out.
polarssl accepts certificate chains of the format cert cert cert even ifcert 1has the same subject as cert but the others e.g.
openssl gnutls cyassl reject such chains and issue different warning messages e.g.
unable to get local issuer certificate asn signature error or the certificate issuer is unknown .
polarssl developers have explained that polarssl accepts these certificate chains since they have complete and valid key chains they may reject these chains in future development.
suggested replacement text for rfc5280 section .
.
.
current msg33248.html mbedtls .
.
released 801openssl polarssl and gnutls accept a certificate chain if the first certificate is a trusted self signed ca certificate but omit verifying the subsequent certificates.
it does not strictly conform to the validation policy when the trust anchor is provided in the form of a self signed certificate this self signed certificate is not included as part of the prospective certification path .
the developers have explained that it is useful to accept it because many misinformed users include the trust anchor in the chain they provide even though the rfcs recommend not to do it.
more importantly accepting such chains allows users to trust self signed non ca certificates if they choose to.
all the ssl tls implementations and browsers but nss strictly reject the invalid certificates issued by a valid ca with a fake private key.
we have reported to the nss developers that certutil incidentally skips signature checking when it validates a certificate in a certificate database.
the developers have responded to us that in pki existence as trusted is sufficient for validity.
on the other hand other developers have claimed that this behavior confuses many users and even security engineers.
the chrome security team has explained that importing an invalid certificate into the certificate manager is intentional and confers trust.
when an end user attempts to manually import an untrusted certificate into the certificate manager certificate validation is skipped.
.
related work we discuss four strands of related work testing certificate validation code random and symbolic execution feedbackdirected test generation and mcmc sampling for testing.
testing certificate validation code ssl tls tools and libraries are vulnerable.
marlinspike has shown several vulnerabilities in certificate validation code in browsers and ssl libraries.
kaminsky et al.
have shown that a ca can issue a certificate that can be used for man in the middle attacks due to parsing differences between ca software and browser certificate validation code.
georgiev et al.
have used both white and black box techniques to uncover vulnerabilities in validation logic and have identified several vulnerabilities.
in contrast mucert does not require deep security knowledge but rather employs a set of test certificates to test the certificate validation code and find flaws inside.
thus the mucert approach can be easily adapted in practice for verifying ssl tls tools and libraries.
bates et al.
present certshim a mechanism that improves ssl security by interposing on ssl apis and retrofitting legacy software to support ssl trust enhancements.
they also show how to poll results of several verification methods to improve security.
mucert also leverages results of multiple certificate verification handlers but focus on generating test certificates to trigger discrepancies among these handlers.
the most closely related work to ours is frankencert the first systematic technique for synthesizing test certificates for testing ssl tls implementations.
due to its completely random and thus blind nature most of frankencerts are invalid or redundant and do not trigger new validation policies.
compared with frankencert mucert allows the tester to much more effectively explore the input space and select diverse certificates for testing.
random and symbolic execution random testing has been a very common testing technique which requires testers to select tests from an input domain at random.
random testing is usually not cost effective especially for settings with structurally complex input domains.
adaptive random testing art is a controversial idea that tries to spread out the selected values over the input domain .
many art algorithms mainly select tests based on thelocations of successful tests and use distances to measure whether the next test case is sufficiently far away from all successful tests.
meanwhile art is not applicable in our adversarial testing as the input space of x. certificate is high dimensional while it has been reported that art often does not work well even in onedimension domains .
symbolic execution has been used for generating test cases for complex programs.
klee automatically generates test cases by running programs symbolically and generating path constraints attempting to hit every line of executable code and detect dangerous operations.
dynamic symbolic execution techniques such as dart cute and pex improve the effectiveness of symbolic execution and random testing by dynamically analyzing the program behaviors under random testing and automatically generating new test inputs to direct the execution along alternative program paths.
however so far these symbolic execution tools have not been used for generating certificates as the modern constraint solvers are not able to solve the intricate syntactical and semantic constraints on the certificates.
in contrast mucert proposes coverage optimized search heuristics to mutate certificates but does not rely on any constraint solver to generate certificates.
feedback directed test generation another emerging direction is to employ the previously constructed tests to design new tests.
pacheco et al.
present a feedback directed random test generation technique .
the feedback directed technique builds inputs incrementally by randomly selecting a method call to apply and finding arguments from among previously constructed inputs.
once an input is built it is executed and the result determines whether the input should be rejected or accepted for generating more inputs.
inspired by the idea of feedback directed testing we leverage the code coverage to measure and optimize a test suite.
fraser and arcuri introduce a technique called whole test suite generation that can evolve all the test cases in a test suite simultaneously .
the technique starts with an initial set of randomly generated test suites and then uses a genetic algorithm to optimize toward satisfying a chosen coverage criterion while keeping the total size of the test suite as small as possible.
mucert also employs coverage to measure a test suite but uses mcmc sampling to stochastically diversify a test suite as the diversities of test suites cannot be rapidly obtained during the sampling phase.
mcmc sampling for testing zhou et al.
propose a markov chain monte carlo random testing mcmcrt approach to random testing .
on the basis of the bayes approach to parametric models for software testing mcmcrt can utilize the prior knowledge and the information on preceding test outcomes for their parameter estimation.
the mcmc sampler is also used to enhance performance of random testing and test case prioritization .
however mcmcrt mainly generates test inputs for numerical programs.
to our knowledge our work is the first that effectively uses mcmc sampling for creating structured test inputs.
.
conclusion we have introduced mucert a guided differential testing of certificate validation by adopting mcmc sampling to mutate x. certificates and produce diverse certificates for testing ssl tls implementations.
our experimental results have clearly demonstrated mucert s strengths over frankencert more detected discrepancies and improved code coverage with orders of magnitude fewer test certificates.
we believe that developers can use mucert routinely to identify latent flaws in ssl tls implementations to improve the security and robustness of the internet infrastructure.
.
replication package the mucert package has been successfully evaluated by the replication packages evaluation committee and found to meet expectations.
the mucert package is composed of three key components .certificate mutation engine that consumes a set of internet certificates and produces another set of diversified test certificates.
five certificate optimization algorithms are supported in the mutation engine the mcmc guided certificate mutation algorithm proposed in this paper and two random and two greedy mutation algorithms that we designed to compare against mucert .scripts for supporting differential testing and analysis and .seeding certificates and a sample ca certificate for comparison reasons we used the same seeding certificates provided by frankencert .
a typical certificate generation process includes two phases .preparation mucert generates a coverage trace file for each certificate w.r.t.
openssl and constructs a coverage information tree for the corpus of seeding certificates and .mutation mucert takes one optimization algorithm to mutate the seeding certificates.
the mutants can be either accepted for further mutations or discarded and the coverage information tree is updated along with the mutations.
after a number of iterations the resulting certificates are used to differentially test the ssl tls implementations.
most of the state of the art ssl tls implementations and web browsers can be tested in c s mode e.g.
openssl polarssl mbed tls gnutls cyassl nss matrixssl google s chrome and mozilla s firefox .
some ssl tls implementations e.g.
openssl polarssl and gnutls can also validate these certificate files via the command line.
some basic commands for validating certificates are shown next where ca file is a ca certificate and cert a mutated certificate to be validated openssl openssl verify cafile ca file cert polarssl mbed tls cert app mode file filename cert ca file ca file gnutls certtool verify load ca certificate ca file cert the validation results are recorded and compared within a spreadsheet.
each cell records the validation result accept or reject of a certificate w.r.t.
an ssl tls implementation.
when a certificate is accepted by one ssl tls implementation but rejected by another a discrepancy is found and reported.
a corpus of discrepancy triggering certificates are also contained in the replication package such that other researchers and developers can use them to further investigate the causes of discrepancies among ssl tls implementations.
.