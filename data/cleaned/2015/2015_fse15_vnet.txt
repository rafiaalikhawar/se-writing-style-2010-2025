generating tcp udp network data for automated unit test generation andrea arcuri scienta norway and university of luxembourg luxembourggordon fraser university of sheffield dep.
of computer science sheffield ukjuan pablo galeotti saarland university computer science saarbr cken germany abstract although automated unit test generation techniques can in principle generate test suites that achieve high code coverage in practice this is often inhibited by the dependence of the code under test on external resources.
in particular a common problem in modern programming languages is posed by code that involves networking e.g.
opening a tcp listening port .
in order to generate tests for such code we describe an approach where we mock simulate the networking interfaces of the java standard library such that a search based test generator can treat the network as part of the test input space.
this not only has the benefit that it overcomes many limitations of testing networking code e.g.
different tests binding to the same local ports and deterministic resolution of hostnames and ephemeral ports it also substantially increases code coverage.
an evaluation on classes from open source projects totalling more than .
million lines of java code reveals that network access happens in classes .
our implementation of the proposed technique as part of the evosuite testing tool addresses the networking code contained in of these classes and leads to an increase of the average line coverage from .
to .
.
on a manual selection of java classes heavily depending on networking line coverage with evosuite more than doubled with the use of network mocking increasing from .
to .
.
categories and subject descriptors d. .
testing and debugging testing tools keywords unit testing automated test generation java junit .
introduction unit testing is a common practice in industry with the aim to improve software quality.
however writing effective unit tests is a challenging and tedious task.
automated test generation techniques such as random testing dynamic symbolic execution dse search based software testing sbst or hybrid approaches permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august september bergamo italy copyright acm isbn ... .
.have been developed to address these problems.
these approaches generate sequences of function calls with the right data to achieve high code coverage on the classes under test cuts .
to evaluate just how well this works in practice we conducted a large empirical study on the sf110 corpus of classes projects randomly chosen from sourceforge also referred to as sf100 and the top most downloaded ones artificial software previously used in the literature and seven industrial systems using theevosuite unit test generation tool .
although reasonably high code coverage was achieved these experiments pointed out a severe limitation of current test data generation techniques environment dependencies.
it is not uncommon that code manipulates files takes inputs from a gui opens network connections etc.
in those cases sequences of function calls on the cuts are not enough the environment needs to be taken into account and environment events e.g.
incoming tcp connections need to be part of the test data.
to overcome some of these limitations in previous work we introduced a technique to control environmental dependencies using bytecode instrumentation.
for several of the java api classes involving for example the file system e.g.
java.io the cpu clock console inputs outputs and some non deterministic functions in the jvm we wrote mock classes that are semantically equivalent operating on a virtual environment e.g.
a virtual clock and a virtual file system in memory .
when a cut is loaded in a test our instrumentation automatically replaces all those java classes operating on the environment e.g.
java.io.file with the corresponding mocks e.g.
mockfile .
as these mocks are semantically equivalent the instrumentation is transparent to the cut.
this technique not only makes the tests more stable e.g.
we can control the cpu clock thus making assertions relating to time deterministic but also leads to higher code coverage.
we measured increases of up to code coverage on some classes when applying this technique.
when run on all the 219classes of the sf100 corpus the code coverage increased from .
to .
indicating that there are further problems that need to be addressed.
in this paper we extend our initial work on mocking by implementing a virtual network used to mock classes in the java.net package like tcp sockets.
each generated test case uses its own virtual network which is independent from the ones used in the other tests.
this has several advantages as it is possible to run tests in parallel that bind to the same local ports and it is possible to programmatically control remote resources.
furthermore we also present search operators to better control how network inputs are generated as test data.
to study the effects of a virtual network on code coverage we carried out an empirical study on the sf110 corpus .
sf110 consists of .
millions of java code lines involving classes coming from different systems.
using a custom security manager to1public class example udp tcp 2public string getmessage int port throws ioexception defines message to send in udp broadcast 5inetaddress addr inetaddress.getbyname .
.
.
7string handshake hand shake 8string outmsg addr port handshake 9byte data outmsg.getbytes send the message datagrampacket packet new datagrampacket data data.length inetaddress.getbyname .
.
.
datagramsocket udpsocket new datagramsocket udpsocket.send packet open listening tcp server based on sent out message serversocket tcpserver new serversocket port addr socket tcpsocket tcpserver.accept read string from incoming tcp connection scanner in new scanner tcpsocket.getinputstream string msg in.nextline close all resources in.close tcpsocket.close tcpserver.close check if first line contains the handshake token if msg.startswith handshake return msg else throw new ioexception invalid header msg figure example class with udp and tcp communication.
track network accesses it turned out that networking is a problem for classes .
of those our current implementation of the presented technique can fully handle the network accesses in cases increasing average line coverage from .
to .
.
furthermore we carried out more detailed experiments on a manual selection of java classes showing that the achieved line coverage more than doubled increasing from .
to .
.
the main contributions of this paper are empirical evidence that networking is a common problem happening in of the classes out of .
millions of java code lines used in the experiments.
an extension of the instrumentation based environment mocking approach to a allow mocking of final classes and b allow the mocking behavior to be activated and deactivated at runtime.
a virtual network implementation that can be controlled by a test generator through method calls in the tests.
an adaptation of the search operators in the search based evosuite test generation tool that uses runtime observations to improve the selection of operations on the virtual network.
empirical evidence that these techniques increase line coverage by more than on average on network related classes.
.
motivating examples the java class listed in figure presents a non trivial usage example covering a wide range of network functionalities.
the method getmessage takes as input an integer value representing a local port.
the method first sends a udp broadcast on the network with a handshake code and the local port number.
then it opens a tcp listening server on the same port.
when an incoming connection from a remote entity is established the cut reads the incoming1 test public void test0 throws throwable 2example udp tcp example udp tcp0 3new example udp tcp undeclared exception!
5try 6example udp tcp0.getmessage 7fail expecting exception illegalargumentexception catch illegalargumentexception e port value out of range figure without virtual network tests generated by evosuite on the class in figure only result in exceptions for getmessage .
1try 2socket socket serversocket.accept 3inetsocketaddress addr inetsocketaddress socket.getremotesocketaddress 5if addr.isunresolved !
isallowed addr system.out.println telnetui rejecting connection from addr as address is not allowed socket.close else figure code excerpt from socketserver in vuze.
message and check if it is valid by looking at the handshake code.
if so the received message is returned to the caller of getmessage .
otherwise an exception is thrown.
to the best of our knowledge no current unit test generation tool can achieve full coverage on such a cut as it requires network communications as test data.
for example previously evosuite would not be able to execute the method getmessage without leading to a security exception first caused by line which leads to an attempt to bind to an ephemeral port.
deactivating evosuite s security manager would still lead to an exception at that line due to maximum number of datagramsockets reached when generating several test cases as the udp sockets are never closed in this code example.
furthermore a correct execution also depends on whether the ip address at line is a valid local address otherwise opening a tcp server on the address at line would fail.
figure shows the only test that e vosuite could previously generate.
.
network transmissions code relying on networking is not only a problem with respect to achieving code coverage.
for example during test generation with an sbst or dse tool the method getmessage could be called several times to find the right test data even in the order of hundreds of thousands of times.
however broadcasting hundreds of thousands of messages line on a network might not be the smartest idea especially when an engineer is using evosuite on her development machine which most likely would be connected to a corporate network.
this is not a problem in a virtual network.
.
blocking calls consider the call at line in figure the code attempts to listen to an incoming tcp connection which is a blocking call if no external entity actually tries to connect the test callinggetmessage will never return.
although a junit test case can be run with a timeout e.g.
five seconds in evosuite each test execution would always use the full amount of time specified in the timeout making the search for test cases extremely inefficient.
as another example see the snippet in figure from the class socketserver in the vuze program one of the most used peerto peer programs in the world .
the ifstatement will never be executed if there is no incoming connection the accept method is blocking .
therefore for testing purposes there is the need to create incoming connections as test data for the cut.1public class example url 2public boolean checkurl 3try url url new url urlconnection connection url.openconnection scanner in new scanner connection.getinputstream string line in.nextline in.close if line.contains html return true else return false catch ioexception e return false figure example of an http read with a url object.
test public void test0 throws throwable example url example url0 new example url boolean boolean0 example url0.checkurl assertfalse boolean0 figure without networking support tests generated by evosuite on the class in figure will only return false.
1public static final string whois server whois.geektools.com 3public static final int whois server port ... 5try socket socket new socket whois server whois server port unsyncbufferedreader unsyncbufferedreader new unsyncbufferedreader new inputstreamreader socket.getinputstream printstream out new printstream socket.getoutputstream ... 13catch exception e 14throw new webcacheexception domain e.tostring figure code excerpt whoiswebcacheitem in liferay.
on the other hand a case of interest for testing might be the behavior of a cut if no incoming connection is registered again this is difficult to achieve in a test in an efficient way.
.
networking data directly opening tcp connections or sending udp packets are not the only way to do networking in java.
for example one could use http to download the content of a remote resource e.g.
a webpage by using a url object as shown in figure .
the branch at line is not trivial only if the resource exists and contains the needed data the predicate will be true.
but having two different test cases in the same test suite one for each branch would require a change in the remote resource.
if the tester has write permission access to the resource it could be done although it might be a bit cumbersome.
if not then there would not be many options.
even without a sandbox activated previous evosuite versions could only generate tests covering the false branch as shown in figure .
another interesting case can be seen in figure which shows a code snippet from the class whoiswebcacheitem in the liferay project.
the cut connects to a remote host whose ip address is hardcoded in a final variable.
at the time of writing of this paper it points to a valid public server the interested reader might want to use a web browser to look at the address whois.geektools.com .
it would be cumbersome if possible at all to deterministically control the behavior of that remote server from within a test e.g.
if one wants to cover the code within the catch block .
furthermore agenerated test that captures the current behavior of the cut could fail tomorrow if the remote server behaves differently or more simply if the internet connection of the developer running the test momentarily goes down.
.
background it is not in the scope of this paper to provide a full description of computer networking.
in this section we provide a brief description of different key concepts used in the paper as well as background information on test generation.
for more details about networking we refer to standard literature on the topic e.g.
.
.
networking concepts .
.
network addresses a machine on a network is identified with an internet protocol ip address.
the most used version of the protocol is ipv4 in which an address is specified with bits usually visualized by showing its bytes separated by dots e.g.
1for the loopback address.
to communicate with a remote host one not only needs to know its ip address but also the port on which the remote host is listening for incoming connections.
typically there are up to different ports where the first are reserved for special purposes.
for example a webserver hosting webpages will have a server application listening on port and an ssh connection is usually done on port .
binding on a port is unique no other process thread can bind on the same port with the same protocol e.g.
udp tcp .
even if a port is closed it is not necessarily going to be available again in the immediate future.
the closing reallocation of ports is handled by the operating system and in special cases it can even take several minutes.
instead of specifying a local port to open one can also use an ephemeral one the operating system will just use any currently available port that is not already bound.
instead of specifying an ip address numerically one can also use the name of the remote server which is then mapped to an ip address using the domain name system dns .
for example to connect to one would first connect to a dns server which would return the ip address .
to connect to a remote host a network interface card is needed.
typical connections are through ethernet and wifi.
a computer can have more than one interface specifying different ip subdomains.
when an outbound message is sent based on its remote ip address it will be forwarded to the right interface serving that subdomain which will then send the message to the first hop e.g.
a router toward the final destination.
.
.
udp tcp internet protocols the user datagram protocol udp is one of the core elements of the internet.
it is a connectionless simple protocol.
it does not guarantee that messages will be delivered to the final destination and even if they arrive their order is not guaranteed either.
a message can get lost if for example it is forwarded through a router that is overloaded and has no space left in its memory buffer.
in udp one sends packets with five main components the ip address and port of the remote host i.e.
final destination the ip address and port of the local interface from which the message is originated from i.e.
the source and the payload up to 65k bytes .
the transmission control protocol tcp is more sophisticated than udp it does guarantee delivery and the order of messages.
this is achieved by for example resending packets that are lost and re ordering the packets on the destination if they are in the wrong order.
similar to udp one needs to specify a remote destination with an ip address and port and a local interface address and port.from the point of view of the user the connection with the remote host can be seen as a stream to from where data can be sent read.
accurate delivery of tcp compared to udp comes at the cost of possible time delays e.g.
when lost packets need to be resent.
which protocol to use depends on the application requirements.
.
.
http the hypertext transfer protocol http is an application protocol usually built on top of tcp.
it defines a request response protocol between hosts usually used to retrieve textual data.
the most typical case is the world wide web.
for example if one uses a web browser to view the page then the browser will open a tcp connection on port on the server .
once the tcp connection is established the browser will send a message looking like get evosuite .
on the same connection the remote server will send the textual information contained in that web page.
the http protocol is very common.
therefore many programming languages provide libraries to handle it without the need of dealing with the raw details of the tcp messages.
for example in java one can simply use a url object to get the content of a remote resource as was done in figure .
.
test data generation different techniques have been proposed in order to generate unit tests automatically.
random test generators like randoop autotest and jcrasher are able to automatically synthesise method sequences for a given cut.
dynamic symbolic execution based tools e.g.
use constraint solvers to generate primitive input data but rely on heuristic approaches to generate sequences of calls e.g.
.
search based approaches use meta heuristic algorithms to optimize sequences of calls .
various tools such as testful or evosuite implement different flavours of search algorithm.
the techniques presented in this paper are implemented and evaluated in the context of the evosuite unit test generation tool which combines sbst and dse using a genetic algorithms ga .
a ga works by mimicking the natural process of evolution given a population of individuals the best individuals are selected survival of the fittest and combined with operations such as crossover and mutation to produce offspring.
this iterative process continues until all search goals are covered or the computational resources at hand are exhausted.
then one of the best individuals is reported as the result of the search.
evosuite applies a ga guiding the evolution of whole test suites towards some selected criterion e.g.
branch coverage .
in evosuite individuals are entire test suites.
starting from an initial population of test suites this initial population can be seeded or randomly created evosuite will evolve these whole test suites towards the selected criterion.
some of the criteria implemented currently in evosuite include optimizing branch coverage dataflow coverage and killing the highest number of mutants .
besides combining whole test suites using crossover single test cases can be mutated with a certain probability.
this modification may include non deterministically adding a new statement removing an existing statement or modifying the argument on an existing statement.
.
environment mocking mocking is an approach to isolate a class from its dependencies by using replacements of classes instead of original ones.
in common terminology a stub is a replacement with a fixed usually default behavior while a mock not only replaces the original class it alsohas some partial behavior mimicking the intended behavior of the class that needs to be configured usually during the preparation of the test execution.
in this paper we use mocks as synonym for some common terms like fakes dummies ortest doubles .
there are many industrial frameworks that allow a developer to manually write her own mock classes by specifying which behavior they should have.
some examples for java include mockito1 easymock2and jmock3.
although it is a good practice to isolate a class from its dependencies for unit testing so also adds an additional problem as the behavior of the mock classes should be kept in sync with the real implementation.
none of the aforementioned frameworks can automatically create mock objects it is the user who is expected to declare how the mock behaves.
perhaps not surprisingly most of the research towards automatically creating mock objects has been done to enhance automatic test case generation.
for example dsc m ock automatically creates mock objects for interfaces with no implementing concrete class while using the symbolic execution tool dsc .
if formal pre and post conditions are given it is possible to synthesize more realistic mocks satisfying the method s specification .
in turn these mocks are used as input data for parameterized unit tests.
some specific techniques have been presented to improve code coverage of automatic test generators by mocking interactions with databases and file systems .
the moles framework works together with the pex automatic test generator moles not only allows mocking of classes it also enables redirecting calls by using code instrumentation.
finally although not directly related to automatic test generation saff and ernst created mock objects to replace components with long execution times.
in previous work we extended the evosuite test generator to handle classes with environment dependencies.
when a user class is loaded into memory it is automatically instrumented to isolate the class from its environment.
this is done by redirecting invocations accessing environment dependant data such as system.currenttimemillis and by mocking classes that interact with the environment e.g.
java.io.file for handling the file system or system.in for the console .
in turn search operators are enabled to allow the ga to update the environment dependencies that were used during the test execution.
however that extension did not handle test data generation for classes with network accesses used a simpler instrumentation that was neither applicable to final classes nor allowed to control when mocked or regular behavior was needed nor was any systematic study on the impact of networking for automatically generating tests presented.
.
a virtual network for testing in order to make it possible for automated test generators to target classes with networking dependencies we propose a technique that uses mocking to replace the networking libraries of the java standard library with custom mocked versions.
these replacement classes do not access the real network interfaces but instead access a simulated virtual network the state of which is determined by the test generation tool.
the virtual network simulates remote hosts all the communications between the remote and the local host hostname resolution choice of ephemeral ports by the operating system etc.
in this section we describe the two main components of this solution first we look at which parts of the standard library need to be replaced.
second we describe how a test generation tool can be extended in order to manipulate the state of the virtual network.
accessed march accessed march accessed march 20151public class mocksocket extends socket implements overridemock ... override 5public inetaddress getlocaladdress if !
mockframework.isenabled return super.getlocaladdress if !isbound return mockinetaddress.anylocaladdress ... ... figure an override mock for java.net.socket all methods are overriden and ensure that the virtual network is used.
.
network mocking .
.
mocked classes in order to make the cut use the virtual network instead of the real one we extended the mocking technique presented in which was originally used to mock the file system and the cpu clock.
the extension introduces different types of mocks to allow mocking of final classes as well as instrumentation to conditionally activate the mocked behavior or restore the un mocked behavior.
using instrumentation does notrequire any changes in the cut but by using an instrumenting classloader we can automatically modify the cut code when it is loaded into memory.
every time a network related class is accessed we rather load a mocked version that is semantically equivalent but operates on the virtual network.
each program behavior exhibited when a mock class is used should be possible also with the original program provided that the environment is properly set up for the execution.
in other words mocked classes should not introduce infeasible behavior.
the state of the virtual network is reset after each test execution to avoid dependencies among tests.
to handle java programs using network features we needed to mock the following classes from the java.net package inetaddress networkinterface inetsocketaddress datagramsocket serversocket socket socketimpl url urlstreamhandler uri mocking a class means providing implementations for each of its methods.
for example the method getbyname in the class inetaddress returns the ip address for the given hostname by making a dns lookup.
in our case we implemented a method that queries a virtual dns in memory that for each request decides whether to return an ip address in valid form or state that the hostname is invalid.
each mock class needs to be implemented only once and has to be part of the test data generation framework.
the final user should not be needed to write any mock classes.
however it is essential that the implemented mocks are semantically equivalent to the classes they are mocking.
the cut should not behave differently depending on whether a mock or its original class is used.
at the end of day evosuite is used to generate test cases that can be used for debugging and it would not be helpful for this purpose if the cut would behave different from expectations.
we distinguish between two different kinds of environment mocks to achieve this which we call override mocks andstatic replacement mocks .
.
.
override mocks given a java api class xto mock e.g.
java.net.socket an override mock is a class that extends x see figure and1public class mocknetworkinterface implements staticreplacementmock ... 4public static boolean isloopback networkinterface ni throws socketexception return virtualnetwork.getinstance .getnetworkinterfacestate ni.getname .isloopback ... figure a static replacement mock for java.net.mocknetworkinterface for each method and constructor of the class url there is one static method with the same name and signature except for the additional first parameter that represents the instance of the mocked object.
overrides every single of its methods and constructors.
all those overriden methods will operate on the virtual network.
every single static method will be replicated in the mock with the same signature note in java the static methods are not overridden .
when a cut is loaded in the jvm we instrument it using a java agent in a way that each constructor for xwill be replaced by a constructor of its mock with same signature e.g.
new socket ... is replaced by new mocksocket ... .
every static call will be replaced by a static call of the mock e.g.
each call to socket.setsocketimplfactory ... is replaced by mocksocket.setsocketimplfactory ... .
if the cut extends x then it will rather extend the mock e.g.
class foo extends socket will be replaced by class foo extends mocksocket .
when instances of xare needed in the test cases as input for the cut we rather use the mock.
for example if the cut has a method to test public void foo socket input then evosuite will only instantiate a mocksocket to give as input to the method foo.
.
.
static replacement mocks unfortunately it is not always possible to create an override mock for the java apis.
for example a final class cannot be overridden.
likewise classes with no public constructors cannot be overridden either.
in those cases we use a static replacement mock.
a static replacement mock for a java api class xwill not override it but rather provides a static method for each method constructor inx.
for each non static method the mock will need to provide a static one with same name and a reference to xas first parameter followed by all the remaining parameters of the mocked method.
for example given a method void foo int v the mock will need to implement static void foo x x int v .
then when the cut is loaded each x.foo ... will be replaced bymockx.foo x ... .
there is the need to pass the reference ofxto be able to change its state e.g.
by reflection if there are no appropriate setters accordingly to the semantics of the mocked method foo.
for each constructor the mock will need to implement a static method with same input signature and returning an instance ofx.
then the instrumentation will replace each construction call new x ... withmockx.x ... which will have signature static x x ... .
finally static methods in xwill be treated like they are treated in an override mock.
note in the case of a static replacement mock by definition we will not have cases of cuts extending it e.g.
class foo extends x .
figure shows the example static mock for class java.net.networkinterface which contains a mocked method for each method and constructor.
for example method isloopback is mocked using isloopback networkinterface and accesses the virtual network to determine the status of the simulated device.
test public void test1 throws throwable evosuitelocaladdress evosuitelocaladdress0 new evosuitelocaladdress .
.
.
example udp tcp example udp tcp0 new example udp tcp boolean boolean0 networkhandling.sendmessageontcp evosuitelocaladdress0 hand shake string string0 example udp tcp0.getmessage assertequals hand shake string0 figure test generated by evosuite with networking support on the class in figure technically each override mock could be rewritten as a static replacement mock.
so why two different kinds of mocks instead of making things simple by just always using the static replacement one?
the main reason is that at runtime we cannot instrument java api classes that have already been loaded in memory by the boot classloader.
assume the cut creates an instance xof a java api class xfor which we have defined the mock mockx .
this instance is given as input to another java api class ywhich is not mocked like for example by calling y.foo x .
ifmockx is an override mock then all the calls in y foo onxwill be done on the virtual network.
on the other hand if mockx is rather a static replacement mock then all the calls in y foo will be on the original version of x and not the mocked one as ycannot be instrumented.
in this case an override mock is a better option.
.
.
switching between mocked and original behavior another essential feature of our framework is the ability to rollback the behavior of a mock to its original unmocked class.
this became a major requirement when running evosuite in industry as automatically generated tests could be run together with the existing manually written ones.
this was a typical case in continuous integration servers when build programs like maven are used and all tests are run in sequence with a mvn test call at each new build.
once the cut has been instrumented when running an evosuite test all tests afterwards will use that instrumented version.
depending on how the manual tests are written e.g.
depending on an actual remote host to connect to like for example a web service some manual tests could fail because they would now be running on a virtual network that has not been properly initialized for such tests.
those failing tests would be time consuming false positives as the user would not know whether these tests fail due to a bug before actually spending time in debugging them.
therefore in our framework we use a flag each time we instrument a cut we automatically wrap each mock call in an ifstatement.
if the flag is true then the mock is used otherwise the original class is rather used.
the flag is activated before each evosuite test done a in a before call and de activated afterwards in an after call .
this approach would handle all instrumentation cases but one theextends of a mock class e.g.
class foo extends mockx .
once the class is loaded its hierarchy cannot be changed e.g.
rolled back to class foo extends x .
therfore in an override mock we need to manually implement each single method with its own rollback behavior based on such a flag.
this is important when instances of that foo are given as input to java api classes that cannot be instrumented.
see for example line in figure .
.
network as test data using a virtual network has many advantages like avoiding dns resolutions and preventing port binding conflicts.
however it also enables the creation of remote servers resources on the fly to be able to better test the cuts.
for this purpose we created methods to mod test public void test2 throws throwable evosuiteurl evosuiteurl0 new evosuiteurl example url example url0 new example url boolean boolean0 networkhandling.
createremotetextfile evosuiteurl0 html boolean boolean1 example url0.checkurl asserttrue boolean1 figure tests generated by e vosuite on the class in figure .
test public void test3 throws throwable example udp tcp example udp tcp0 new example udp tcp try example udp tcp0.getmessage fail expecting exception ioexception catch ioexception e simulated exception on waiting server figure additional test generated by evosuite with networking support on the class in figure .
ify the virtual network which is accessed by the mocked networking classes directly in the test cases.
for a search based tool like evosuite those methods will be part of the search like any other method of the cut.
see for example the usage of the evosuite framework class networkhandling in the automatically generated test case in figure and figure .
there tcp messages are sent with sendmessageontcp whereas remote resources can be created on the virtual network with createremotetextfile .
however being able to generate network events as test data is not enough.
for example there is no point in sending a tcp message on a port that the cut is not listening on or in creating remote resources that the cut never tries to access.
even more there is no point at all in using any method from networkhandling if the cut does not do any networking.
generating such test data would be just a waste of time.
to overcome these issues when tests are generated and evaluated as part of the search e.g.
the generations of the genetic algorithm we keep track of what the cut tries to access.
if the cut opens a udp listening socket on a port x then we will enable in the search the usage of methods to simulate the sending of udp packets to port x. likewise if the cut accesses a remote resource via a http url then we will enable the search to use the methods to create only those remote resources.
this drastically reduces the search space of possible test cases to only those relevant ones.
on the other hand if no incoming connection is registered in the test case in our virtual network we can just simulate the throwing of a valid ioexception this is the default behavior if no incoming connection is registered as shown in figure at line .
another key aspect of these helper methods in networkhandling is that they are asynchronously buffered.
for example consider the case of a cut listening for an incoming tcp connection e.g.
recall line in figure .
creating an incoming connection before the cut calls the method accept would fail as there is no listening socket yet.
trying to create an incoming connection afteraccept is called would not work either asaccept would block the junit execution until a connection is accepted.
one would have have to create a second separated thread from which to initiate the tcp connection and synchronize it properly.
to avoid the complications of handling different threads in a junit test we chose a different approach.
because we have full complete control over the virtual network every tcp connection or udp1 test public void test2 throws throwable evosuitelocaladdress evosuitelocaladdress0 new evosuitelocaladdress .
.
.
boolean boolean0 networkhandling.sendmessageontcp evosuitelocaladdress0 example udp tcp example udp tcp0 new example udp tcp undeclared exception!
try example udp tcp0.getmessage int byte fail expecting nosuchelementexception catch nosuchelementexception e no line found figure additional test generated by evosuite with networking support on the class in figure .
test public void test1 throws throwable evosuiteurl evosuiteurl0 new evosuiteurl boolean boolean0 networkhandling.
createremotetextfile evosuiteurl0 example url example url0 new example url undeclared exception!
try boolean boolean1 example url0.checkurl fail expecting nosuchelementexception catch nosuchelementexception e no line found figure test generated by e vosuite on the class in figure .
packet sent by the test case is buffered.
this allows the creation of network test data before the cut is executed.
when the cut open a listening port then we check if in the virtual network there is any buffered incoming connection.
if yes then we immediately established the connection.
if not there is no point in keeping the cut hanging on a blocking call until the test case timeouts as no further incoming connection would be possible.
therefore to save precious time that can be used to evaluate new test cases we hence simulate an immediate error on the network by throwing a valid ioexception.
.
detecting faulty networking code besides generating high coverage test suites evosuite can also identify faults in the cut e.g.
when undeclared exceptions are thrown .
in both examples figure and figure there is the same kind of fault reading a line from a stream without first checking if such a line exists at all e.g.
with the method hasnextline in the class scanner .evosuite can generate input data in this case network messages that manage to crash the cuts by getting them to throw an undeclared nosuchelementexception see line in figure and line in figure .
.
empirical study intuitively using a virtual network for unit testing has many immediate benefits.
whether the virtual network is of benefit in automated test data generation is a more difficult question will it be sufficient to achieve full code coverage or is more research needed to develop new techniques to better choose how to generate the network events?
formally in this section we want to give an answer to the following research questions rq1 how common is network communication in open source java classes?
rq2 what cases of networking code can our mocking technique handle?
rq3 how much does coverage improve when using a virtual network?1class clienthelper 2static void send string command string server string port 3try dosend command server port 6catch ioexception e e.printstacktrace 11static void dosend string command string server string port throws ioexception socket socket new socket server integer.parseint port outputstream os socket.getoutputstream bufferedoutputstream out new bufferedoutputstream os out.write command.getbytes out.write r out.flush socket.close figure snippet code from clienthelper in jiprof.
1public class clear 2public static void main string args 3clienthelper.send clear args args figure snippet code from clear in jiprof.
.
case study we used the sf110 corpus of classes for evaluation.
the sf110 is composed of projects randomly selected from sourceforge which is one of largest web repositories for open source software.
furthermore to also take into account programs that are popular the sf110 corpus includes the most downloaded software.
for example these include the peer to peer bitorrent downloading tool vuze formerly called azureus and the webportal liferay.
in total the sf110 corpus consists of java classes spanning over .
millions of lines of code.
to carry out more detailed experiments we also selected java classes coming from different software projects in the sf110 corpus the smaller number permits more repetitions which is helpful for the statistical analysis.
those classes were chosen manually based on different criteria we first looked at experiments on the whole sf110 to see which classes ask for network permissions.
we then searched for keywords e.g.
url and socket in the source code and identified interesting classes making use of network features.
we tried to have at least one class for each major network component we simulate e.g.
udp tcp and http via url .
we avoided classes that albeit using some network features were only marginally depending on those.
finally we only selected a relatively small amount classes as we had to look at their source code manually and wanted to present their results in more details.
note to answer rq3 there would not be much point in using classes without network features.
the selected classes are not independent but rather parts of larger software projects.
therefore looking at metrics like lines of code can be misleading when evaluating the complexity of such classes.
for example a cut might be relatively short and not any direct network access.
on the other hand such a class might call other classes that do a lot of networking and that hence require to generate several network events in the test cases.
this was the case for many of the analyzed cuts for example consider the class clienthelper from the project jiprof listed in figure .
tofully cover such a class one has to create a remote server listening on the specified tcp port beside providing the right input value to thesend method.
now consider the trivially small class clear from the same sf110 project listed in figure .
this class has practically just one statement that calls clienthelper .
still beside the need to create a string array with at least two elements one representing a valid ip address and the other a valid integer port one has still to create a remote listening server.
otherwise when a security manager is used the method send will throw a security exception and not return properly.
.
experiments to give an answer to our research questions we ran several experiments with evosuite considering two different configurations with and without the virtual network vnet .
when evosuite is run without the virtual network i.e.
the base default configuration we employ a security manager to prevent potentially harmful operations .
first we ran the base configuration once on all classes in sf110 to determine which classes try to access the network.
each search was left running for two minutes.
from this run we determined classes using the network by analysing the network permissions they asked for.
then we ran both configurations on those classes.
to take the randomness of the algorithms into account each experiment was repeated five times with different random seeds for a total of 420runs.
finally on the manually chosen classes we ran both configurations times for a total of 520runs.
all experiments were run with an hpc cluster .
the results of these experiments were analyzed following the guidelines in .
in particular we used a wilcox mann whitney u test to check statistical difference among the two analyzed configurations.
effect sizes were measure with the standardized varghadelaney a12statistics.
a value a12 5means no difference between two compared configurations whereas a12 1means the first configuration always obtained better results and the other way round for a12 .
in other words the a12statistics is a measure of the probability of a run with the first configuration obtaining higher values e.g.
better coverage than using the second configuration.
.
rq1 how common is networking?
by using a custom java security manager we can track each time a cut attempts to access the network because this results in the cut asking for either a socketpermission or anetpermission .
in our previous exploratory experiments in which we monitored allthe java permissions it turned out that network permissions were asked in of the classes in sf110.
however after a more in detail analysis carried out in this paper we found out that such a high number is misleading.
there are many classes in sf110 that are gui based e.g.
using swing components .
widgets extend the abstract class jcomponent .
to draw a widget its frame window needs to know the size of such a component.
to our greatest surprise a call to getpreferredsize leads to network access in java!
in particular getpreferredsize leads to a call to getfontmetrics which ends up in the sun.font.fcfontconfiguration class where the method getfcinfofile uses a inetaddress to resolve the local host address.
if a security exception is thrown then getfcinfofile just defaults to using the loopback address.
note although we mock inetaddress we cannot instrument java api classes that are loaded by the boot classloader.as resolving the local host does seem relatively harmless and at any rate we do mock inetaddress in the cuts and all thirdparty libraries it uses we hence relaxed the security manager to grant this permission.
a new run of experiments with the relaxed security manager identified classes accessing the network i.e.
of all classes.
rq1 of all classes in sf110 access the network.
.
rq2 what is handled by evosuites s mocking?
to determine whether a specific networking interaction was successfully mocked we can again make use of the security manager networking related permissions should only be requested by standard networking code mocked networking code will not ask permission and instead uses the virtual network.
after running evosuite with the virtual network mocking on the classes that originally asked for network related permissions it turned out that in cases no network permission was asked.
this means that our techniques managed to handle all cases of network access in those classes.
in other words our technique fully handled of all classes in which networking is involved.
note that for the remaining classes there are likely also several networking aspects that are handled but in each of these classes there was at least one attempt to access the actual network.
why was not achieved?
by manually looking at some of the classes that were not handled we can identify at least two reasons.
first it turned out that there are further classes in the java api related to networking which we did not create mocks for.
beside the java.net package there are networking classes like serversocketchannel in the java.nio.channels and the whole java.rmi package remote method invocation .
in principle this can be solved by extending the virtual network to also mock all those classes.
second mocking has limitations when final classes are involved.
for example the class url is final.
mocking that class cannot be simply done by subclassing and so we need to replace every single of its occurrences with our mock i.e.
we need to use a static replacement mock recall section .
.
.
if the cut calls a method of one class in the java api that takes a url as input an example we saw in the experiment logs was one of the constructors in the swing class imageicon then we cannot make those replacements in classes that have been already loaded by the boot classloader.
fully solving such issues would require to mock all those java api classes e.g.
imageicon to make them use our virtual network e.g.
by rather using our mockurl class .
this for the whole java api would most likely be too complicated and time consuming.
however it would be reasonable to do it for a few selected classes that are widely used in practice.
rq2 mocking java.net fully covers of the selected classes but misses cases involving the rmi and nio packages.
.
rq3 how much does code coverage improve?
to measure coverage increase we focus on line coverage instead of the more commonly used branch coverage for practical reasons most java bytecode based coverage measurement tools measure branch coverage in terms of the outcomes of conditional statements without considering coverage on non branching code that is in practice branch coverage does not subsume statement coverage .
as many operations on the network results in either blocking method calls e.g.
waiting for an incoming connection or calls that throwtable results of the experiments on the whole sf110.
cuts using network cuts handled by vnet coverage for base .
coverage for vnet .
better equal worse paired u test p value .
exceptions e.g.
trying to connect to a non existing remote host we argue that line coverage would be a better measure to evaluate improvements on the handling of network related cuts.
table shows the results on the sf110 case study.
on the classes for which the virtual network was successfully used average line coverage increased from .
base to .
vnet a .
improvement.
there are classes in which vnet brought no improvement likely these are cases in which network access happened when generating input parameters to the cut but those inputs were not needed to achieve higher coverage.
improvements are obtained on classes whereas there are in which vnet led to worse results.
a paired u test on the average line coverage for each class i.e.
pairs resulted in a very low p value .
in other words there is strong statistical evidence that vnet leads to a higher number of classes in which there is improvement compared to the cases in which it has a negative effect.
there are at least three complementary hypotheses to explain why using a virtual network led to worse results in cases randomness of the algorithm which also applies to the cases with improvements the network is not really needed to achieve higher coverage e.g.
it is accessed by unnecessary calls on input data to the cut and expanding the search to create network events increases the search space with no benefit bugs in the virtual network.
however it can be misleading to look at classes in isolation as the average values are only based on five runs.
table shows the results of our empirical study on the selected classes.
as we have runs per class results are shown and analyzed for each class in isolation.
in most cases line coverage vastly increases with strong statical significance.
on average it increases from .
to .
a .
improvement more than double.
the average standarized a12is extremely high .
.
this means that even when taking the randomness of the algorithm into account in out times using a virtual network leads to higher coverage.
the largest coverage increases seem to be related to code that without virtual networking is completely inaccessible for example for project lilith there are several classes with code coverage that with virtual network achieve up to line coverage.
in these cases the network is already accessed in the constructor of the classes the superclassabstractserversocketeventsourceproducer attempts to listen on a serversocket which the security manager prohibits.
even when it is possible to instantiate networking related classes much of the code may be inaccessible due to a networking dependency at method entry.
an example for this are classes clienthelper andclear fromjiprof see figure both of which have substantial increases of coverage.
however code that can only be executed with a virtual network is likely to have further networking dependencies beyond class instantiation for example once a serializingmessagebasedserversocketeventsourceproducer is instantiated it requires tcp data on tothe server socket it is listening on which evosuite successfully does.
class blockingudpclient in project quickserver mainly consists of methods related to sending and receiving networking data and although it can be instantiated without virtual network the achieved coverage doubles once network traffic can be simulated.
as another example class httpmonitor in project quickserver reads content from a remote http server and reports whether the remote machine appears to be active or down depending on whether the content transmitted via http matches expected content.
evosuite created tests on average that explore several different scenarios including simulated data matching and not matching the expected content leading to a coverage increase of .
rq3 on average the virtual network increases line coverage by more than on classes dealing with networking.
for classes heavily depending on it we observed an increase of over .
.
threats to validity threats to internal validity come from how the experiments were carried out.
all techniques discussed in this paper have been implemented as part of the evosuite tool.
although the tool has been intensively tested no system is guaranteed to be error free.
furthermore because evosuite is based on randomized algorithms each experiment has been repeated several times either or and the results have been evaluated with rigorous statistical methods.
threats to construct validity come from what measure we chose to evaluate the success of our techniques.
to measure improvements on testing effectiveness we considered the achieved line coverage.
when dealing with methods that either are very likely to throw exceptions or block the caller until an external event happens e.g.
an incoming tcp connection we argue that this measure is more revealing than looking at more common measures like branch coverage.
however to get a better picture there would also be the need to look at measures like mutation testing score.
furthermore code coverage does not tell us how easy it will be for the final user to understand the generated test cases which is needed for debugging .
even if we can numerically quantify the benefits in terms of increased line coverage it is hard to quantify all the other benefits that a virtual network gives.
such benefits are for example avoiding test cases failing due to opening ports that are already bound by other unrelated processes or due to a wifi network being temporarily down for few seconds etc.
whether those benefits address very common or rare problems is hard to quantify in an objective way.
threats to external validity come from how well the results generalize to other case studies.
to reduce this threat we used the sf110 corpus which is a statistically valid random sample of projects from sourceforge plus its most downloaded ones.
that corpus is large consisting of more than .
millions of lines of code.
there is hence reasonable expectance that our virtual network might successfully work as well on other open source software.
.
conclusions generating unit tests for real world software is not only a matter of instantiating classes with the right input objects and having sequences of function calls on them.
real world software often interacts with their environment as for example the file system graphical user interfaces the cpu clock databases etc.
environment events are part of what is needed to effectively unit test classes.
in this paper we have proposed a novel approach to handle network communications e.g.
udp messages tcp connections or host name resolutions .
our approach is based on semantically equivalent mock classes interacting on a virtual network and ontable results of evosuite with vnet and without base the virtual network.
for each of the java classes we report the obtained average line coverage standardised a12effect sizes and p values of the statistical tests.
project class base vnet difference a12 p value vuze transcodepipestreamsource .
.
.
.
clcachediscovery .
.
.
.
natcheckerserver .
.
.
.
prhelpers .
.
.
.
trblockingserver .
.
.
.
socketserver .
.
.
.
freemind editserver .
.
.
.
liferay ipdetector .
.
.
.
whoiswebcacheitem .
.
.
.
dsachat cserver .
.
.
.
servermain .
.
.
.
gangup serverconnectionlistener .
.
.
.
lilith abstractserversocketeventsourceproducer .
.
.
.
accesseventprotobufserversocketeventsourceproducer .
.
.
.
loggingeventprotobufserversocketeventsourceproducer .
.
.
.
serializingmessagebasedserversocketeventsourceproducer .
.
.
.
lilithxmlmessageloggingserversocketeventsourceproducer .
.
.
.
lilithxmlstreamloggingserversocketeventsourceproducer .
.
.
.
abstractlogbackserversocketeventsourceproducer .
.
.
.
logbackaccessserversocketeventsourceproducer .
.
.
.
summa solrsearchnode .
.
.
.
jiprof clear .
.
.
.
clienthelper .
.
.
.
file .
.
.
.
finish .
.
.
.
start .
.
.
.
stop .
.
.
.
remotecontroller .
.
.
.
hft bomberman testdriver .
.
.
.
forwardingobserver .
.
.
.
.
clientquitrunningsessionmsg .
.
.
.
playerleftmsg .
.
.
.
bomberserver .
.
.
.
clientinfo .
.
.
.
stopserver .
.
.
.
servermsgreceiver .
.
.
.
io project server .
.
.
.
.
at robots2 j client .
.
.
.
jaw br update .
.
.
.
quickserver blockingudpclient .
.
.
.
httpmonitor .
.
.
.
falselight services .
.
.
.
average .
.
.
.
runtime bytecode instrumentation.
to the best of our knowledge no other unit test generator can create network events as test data.
our experiments suggest that networking is very common in opensource java software.
in projects the sf110 corpus consisting of java classes network accesses happened in of the classes.
our current implementation fully handles of those cases leading to an average incease in line coverage of .
on classes heavily depending on networking average improvements are in the range of .
the increase in code coverage we observed indicates that our technique is effective at handling networking communications.
however .
coverage on of the classes in sf110 translates to an overall increase of coverage by .
on sf110.
thus there are still several areas for further investigation like for example handling more interactions we have not mocked all the java api classes involved in networking.
our virtual network can be extended to cover the most common remaining cases.
improving input data although we can generate input data coming through a network channel how to best do it is open to improvements.
for example if a class reads a byte stream from a remote host and then later on it uses such data to deserialize an object instance it would be hard to generate valid bytes usingtraditional methods like dynamic symbolic execution or searchbased testing.
most likely there would be the need to do static analyses to catch the occurrence of those cases and improve the data generation algorithms accordingly to exploit such information.
enhancing readability if one wants to obtain test cases that are useful for debugging and regression purposes there is the need generate readable tests.
test case readability is a very important topic that is still largely unexplored in the literature.
we can expect that adding environment events in the generated tests will only exacerbate this problem further.
framework reuse our mocked framework could also be used as a standalone library for helping the writing of manual tests and or be integrated in other test data generation tools.
all techniques discussed in this paper have been implemented as part of the evosuite test data generation tool which is freely available to download.
to learn more about evosuite please visit our website at .