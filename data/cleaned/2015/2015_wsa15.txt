generating qualifiable avionics software an experience reportandreas w olfl norbert siegmund sven apel harald kosch johann krautlager guillermo weber urbina university of passau germanyemail andreas.woelfl norbert.siegmund apel harald.kosch uni passau.de airbus helicopters s.a.s.
germanyemail johann.krautlager guillermo.weber urbina airbus.comabstract we report on our experience with enhancing thedata management component in the avionics software of thenh90 helicopter at airbus helicopters.
we describe challengesregarding the evolution of avionics software by means of real world evolution scenarios that arise in industrial practice.
akey role plays a legally binding certification process calledqualification which is responsible for most of the developmenteffort and cost.
to reduce effort and cost we propose a novelgenerative approach to develop qualifiable avionics software bycombining model based and product line technology.
using thisapproach we have already generated code that is running onthe nh90 helicopter and that is in the process of replacing thecurrent system code.
based on an interview with two professionaldevelopers at airbus and an analysis of the software repositoryof the nh90 we systematically compare our approach withestablished development approaches in the avionics domain interms of implementation and qualification effort.i.
introductionengineering in the avionics domain is driven by variouslegally mandated regulations dedicated to safety and reliabil ity.
prior to the first official flight in a commercial aircraft anational certification authority has to inspect the airworthinessof all components including airborne computers and software.this process is called avionicsqualification.
the acceptance isstrictly related to compliance with international aerospace stan dards such as do software considerations in airbornesystems and equipment certification .
together with whitepapers1from the certification authorities software team these documents define process completion and functionalityverification with software life cycle objectives.
depending onthe safety criticality of the target system applicants forqualification have to meet a specific set of life cycle objectives determined by different design assurance levels2.in industry compliance with do adds about to the total development costs caused by additionaleffort for developing or extending code and documentation forlife cycle objectives calledqualification assets.
by over twothird the majority of these artifacts relates to software ver ification and validation e.g.
establishing bidirectional trace ability evidence from system requirements to unit tests .developing qualification assets also complicates programmingof the software itself because many assets must adhere to1 with five criticality levels ranging from level a most critical tolevel e least critical assigned by the national certification authority.strict coding constraints such as the prohibition of late bindingor dynamic dispatch.
the impact is most significant betweendesign assurance level d and c. level c is assigned tomission criticalsoftware and demands about more budgetand schedule than software at level d .in this paper we report on our experience gained in acooperation between airbus helicopters and the university ofpassau.
the key objective of the cooperation was to developa highly configurable real time database management system intended for integration in core mission control applicationsin the avionics software of the nato helicopter nh90 .analogous to product lines in other industry branches customers in the aviation domain can choose among a largenumber of features and configuration options for the airborneequipment which requires variability of the avionics softwarein the nh90 including the data management component.in a first step we investigated state of the art developmentmethods used at airbus helicopters.
there are two basicapproaches to handle variability in qualified avionics soft ware the first approach is to consider a software variantas separate unit such that for each variant the source codemust be implemented and qualified manually.
the secondapproach is to apply specifically qualified development toolsto automatically generate variant specific software artifacts.based on the findings of a semi structured interview with twosenior developers at airbus helicopters we found that theseapproaches are economically suboptimal implementing datamanagement in the avionics domain.
while an approach ofseparately implementing and qualifying software variants doesnot scale with an ever increasing number of new requirements introducing a qualified development tool causes huge initialcosts for either purchasing a commercial tool or implementingand qualifying a suitable tool in house.based on our analysis we propose a novel generativedevelopment approach that addresses the challenges of vari ability and software evolution in the context of qualificationdemands in the avionics domain.
essentially we combined theaforementioned approaches.
in a nutshell using model basedand product line technology we generate tailored system vari ants based on declarative specifications written in a domain specific language.
furthermore we ease software verificationand validation by automatically generating qualification assetsin this process.
this way we have a scalable approach in termsof the number of variants and we keep the initial effort feasibleby supporting the qualification of the generated code insteadof qualifying the tool itself.
we integrated our approach intothe tool chain of the nh90 development environment.
ourimplementation is fully operational.
the resulting softwarevariants are executable on the target avionics hardware andcurrently prepared for qualification at design assurance levelc as part of the next release of the nh90 system software.to compare our approach to established development ap proaches we systematically describe the evolution of avionicssoftware by means of real world scenarios regarding datamanagement in the nh90.
in detail we discuss frequencyand severity of functional and non functional requirementsby combining insights from a developer interview and datacollected from the software repository of the data managementcomponent of the nh90 system software.
the software repos itory contains the problem reports software change notes andengineering change requests of the past years.
in the longrun developers can use our results to assess maintenance effortin an avionics software project and determine a developmentstrategy for concrete scenarios.in summary we make the following contributions we analyze development approaches applied in the avion ics domain regarding practicability and feasibility in termsof the challenges of data management and qualificationdemands in the avionics domain.
we report on a developer interview at airbus helicopters providing insights into the implementation maintenance and evolution of avionics software.
we present a novel generative development approachbased on model driven and product line technology aim ing at the efficient realization of both implementation andqualification of avionics software.
we implement our approach as part of the real timedatabase management system of the nh90 avionics soft ware at airbus helicopters.
we quantitatively and qualitatively discuss our approachbased on real world evolution scenarios combined withthe analysis of the software repository of the nh90system software related to data management.ii.
avionicssoftwarein this section we explain the target avionics softwareenvironment and evolution with a focus on data management.furthermore we characterize general challenges in develop ing avionics software and describe established developmentapproaches with a focus on software qualification.a.
nh90 avionics software evolution and variabilitythe software division at airbus helicopters develops theon board software for federated avionics in the nh90.
thenh90 is a medium sized multi role helicopter manufacturedby the nhindustries consortium.
its operating system consistsof an application framework callednh90 system software and several application components calledoperational pro cessing functions.
the programming language of the nh90system software is ada3 which has been specifically de signed for the application in safety critical embedded andreal time systems.
the first qualified version of the nh90system software was released in the year of the maidenflight of the nh90.
from the first variants for field and3 missions economical success raised this numberto variants in the early 2000s.
from here obsolescenceled to the introduction of additional hardware architectures causing further variation in the software.
today variantsare deployed on different hardware platforms shipped tocustomers in nations .the helicopter variants differ in their integral equipmentconfiguration.
complex equipment provides optional features from which customers can select arbitrary combinations.
itis also possible that already integrated equipment from adelivered helicopter is replaced by a functional equivalent thatis manufactured by another company.
the effects on the asso ciated avionics software are significant.
the most frequentlychanged area is the combination and the implementation ofoperational processing functions which control or monitorsubsets of the avionic equipment.
some functions rely on thesame data or services so the presence or absence of oper ational processing functions can cause interactions betweenindividual components particular affecting data managementand data bus scheduling.
an amendment in the operationalprocessing functions regularly requires further adjustments inthe functional capabilities of these components.the constantly growing number of variants and the result ing complexity requires a re development of major parts ofthe nh90 system software.
the primary goal of our endeavorwas to improve extensibility and maintainability of the data management component while providing sufficient perfor mance and resource consumption to deploy the software evenon legacy hardware platforms.
as part of this re developmentendeavor airbus helicopters initiated the cooperation with theuniversity of passau.b.
data management in the nh90 system softwarea central component that posed problems regarding theevolution of variability in the nh90 system software is thedata management component.
a single avionics computer con tains about operational processing functions that usethe data management component to store and process variousdata structured by about entity types4.
when we startedthe cooperation data management was implemented as list based storage henceforth calledlist management lstm .all data were kept as plain lists of data records.
complexdata management functionality was left to the individual op erational processing functions.
with the increase of variabilityover time the developers faced three major problems first relationships between entities were only implicitly presentin the source code of the operational processing functions.second there was no guarantee that referential integrity of thedata is maintained consistently.
third values of related entitieshad to be stored redundantly.the re development group at airbus helicopters concludedthat the current data management solution lstm should bereplaced by a data and function centric component.
sincethere is no commercial of the shelf product available thatcan be qualified according to theplan for software aspectsof certification5of the nh90 airbus helicopters decidedto pursue an in house development in cooperation with the4the complex data types to handle records in the data management com ponent e.g.
waypoint .5an agreement between the aircraft manufacturer and the certificationauthority concerning certification activities.notenotequalified variantmanual developmentsourcecode verification validation assets qualificationfig.
code based development of qualified avionics softwareuniversity of passau henceforth calledembedded database edb .
to accomplish this goal we first had to discover thefactors that complicate software development in the avionicsdomain.c.
coding constraints for avionics softwarebased on accumulated knowledge gathered over years airbus helicopters meets high standards with respect to soft ware quality and safety resulting in a large number of non functional requirements.
a subset of these requirements relatesto qualification showing compliance with do for civil ian or dod std for military aviation.
conformityto these standards makes programming considerably moredifficult and tedious.
for reliability assurance in mission and safety critical avionics software there must be a proofthat program execution and resource consumption are entirelydeterministic and predictable.
depending on the system criti cality heavy non functional requirements prevail.
in the caseof the nh90 system software we list some representativeexamples of coding constraints referring to mission criticalcode qualified at design assurance level c dynamic programming mechanisms such as late bindingor dynamic dispatch are prohibited.
to predict the memory footprint at compile time and toguarantee faultless resource consumption memory mustbe allocated statically.
source code that is never executed in any configurationhas to be completely removed.
each line of source code must traceably correspond to alow level system requirement.to get permission for flight each development artifact must beapproved by designated engineering representatives from thenational certification authority.
next we explain the currentpractice in qualifying avionics software.d.
qualification of avionics softwaresoftware verification and validation is the most integralpart of the qualification process.
in this context do 178issues two methods formal methodsandrequirement basedtesting.
guidance for formal methods is documented in do .
it recommends model checking theorem proving andabstract interpretation as approved techniques for formal veri fication.
by contrast testing aims at validating the correctness completeness unambiguousness and logical consistency ofsystem requirements by running a comprehensive set of tests.in addition bidirectional traceability between requirements source code and associated tests has to be established .independent of verification and validation two softwaredevelopment approaches are commonly used in the avionicsdomain.
in code based development both source code andqualification assets are implemented manually and submitted sourcecodecriteria toolgenerationqualified variantqualification verification validation assetsnotenotefig.
tool based development of qualified avionics softwareto the certification authority for individual qualification fig ure .
by contrast tool based development relies on tool generated software artifacts figure .
a generator tool whoseoutput is part of the airborne software in do ascriteria 1tool must be qualified in compliance with the same softwarelife cycle objectives at the same design assurance level as theresulting software itself.
the benefit of this tool qualificationis that the output is automatically considered as verified andvalidated such that no additional approval is required forthe integration of generated artifacts into the airborne software.to properly determine the benefits and drawbacks of theseapproaches regarding the enhancement of data management inthe nh90 we asked developers to report on their experiencegained in the software development process of the currentlyoperating component which we describe next.iii.
developerinterviewin this section we report on the setup conduct and resultsof an interview with two senior software developers employedat airbus helicopters.
the goal was to collect informationon the current data management component of the nh90avionics software and implications for our new solution.
first we list our research questions followed by a description ofthe participants questionnaire and conduct.
the remainder isstructured by the research questions.
the survey follows theguidelines provided by jedlitschka and others .a.
objectivesthe subject of the interview was the development main tenance and evolution of the lstm the currently operatingdata management component of the nh90 avionics software.we had the following research questions rq1how much effort was required to implement and qualifythe initial version of the lstm?rq2how much effort requires deriving a new lstm variant?rq3what situations and circumstances cause typical main tenance and evolution tasks for the lstm?b.
participantstwo senior developers of the software division at airbushelicopters participated in the interview.
the first developeris a senior systems software analyst and developer.
during 25years of professional experience in the aviation domain heworked with real time scada systems supervisory controlsoftware and data acquisition.
with years within the nh90software team he is one of the leading senior developersand assists younger engineers with training and knowledgetransfer.
he designed and implemented the lstm and stillmaintains it.
the second developer has been employed formore than years in the avionics software domain.
he hasbuilt consolidated expertise in the nh90 software team formore than years.
his responsibilities include all areas oftable i topics of the semi structured interviewobjective topicrq1 rq2chronological sequence of the lstm developmentrq1application designrq1 rq2functional and non functional requirementsrq1 rq2stakeholders of the lstm in the nh90 system softwarerq2proceedings to add modify and delete a listrq2 rq3hardware platform and compiler specific aspectsrq1development approach for unit testsrq3software bugsrq1 rq2procedure to verify and validate a new or modified listrq1approach to establish traceabilityrq3evolution of functional requirementsrq3evolution of non functional requirementsrq3reasons of emergence of new requirementsrq3decision making for replacing the lstm with the edbthe software life cycle mainly the development of controlapplications and the design of the nh90 operating system.c.
questionnaire and conductthe interview was designed as a semi structured interview.the topics are outlined in table i. besides the efforts forinitial implementation and qualification we wanted to collectinformation on what factors contribute to maintenance andevolution effort of complex multi variant avionics software inindustrial practice.
we were particularly interested in reasonsand frequency of changes in the software.
our goal was to getinsights into long term implications and severity of changesregarding the realization of new and unexpected requirementsin the avionics domain.
therefore we asked the intervieweesabout real world challenges solution approaches and the timespent on resolving problems.
the conversation was conductedface to face at the software division of airbus helicopters andlasted about hours in total.d.rq1 how much effort was required to implement andqualify the initial version of the lstm?the lstm was implemented by hand code based de velopment .
the first qualified release was used for data management in nh90 variants.
the programming of theinitial version lasted about person months.
were constantly moving to a yearand a half really realistically.
if you look at the code it snot a huge many thousands of lines but the concept wellyou have to satisfy the constraints on the requirements.
for qualification requirement based testing was used.
as partof the specified process in do a preliminary design wascreated before programming.
this document comprises theinitial software specification including a mapping of low level system requirements to procedures in the implementation.traceability evidence as validation asset was built on thismapping.
it is realized by adding annotations in the formof machine readable comments to procedure headers.
thecompleteness and integrity of the traces is then automaticallyproved by tools.
the interviewees estimated the effort tocreate the combination of preliminary design and traceabilityevidence at .
person months which is of the totaldevelopment cost.
the development of validation assets inform of functional tests and unit tests was extensive.
a lot of almost as much effort todevelop the operational processing function i wouldsay easily months effort easily in summary the development time for qualification assets ofthe initial version amounts to about .
person months.e.rq2 how much effort requires deriving a new lstmvariant?the lstm relies on generic software packages.
in ada generic units are the instruments to safely implement paramet ric polymorphism.
a generic package represents a parameter ized template for a package whose parameters can be types variables subprograms and other packages.
each instantiationconceptually creates a copy of the specification and body ofthe generic package customized due to the actual parameters.all lstm variants share the same operational functionality.they are distinguished by the data dictionary which is definedby the absence or presence of certain operational processingfunctions in a specific nh90 variant.
each contained entitytype e.g.waypoint is implemented as an independentlist based on a central generic package.
it requires typedefinitions and subprograms to define the storage structure.
accessing the data is not hard that is the easy part.
thedifficult part is where it gets the data that you would liketo modify.
usually the operator or the pilot is makingchanges to the graphical display which is representing thedata of one record.
this is taking thedeveloper three months but the instantiation that is justone day.
the total cost of deriving a new lstm variant is the effortrequired for adding or modifying the instantiation of lists which is person hours per entity type.
on a single avionicscomputer the nh90 system software uses up to differentlists by operational processing functions.f.rq3 what situations and circumstances cause typicalmaintenance and evolution tasks for the lstm?maintenance effort arises from errors and flaws in thesource code.
the lstm head developer reported from source code changes due to bug fixes but estimated the correspondingcosts to be minor.
if you consider years of experience your codekeeps getting better.
i mean the software evolved of course but not much of changes because of bugs.
the majority of maintenance and evolution effort for thelstm is caused by engineering change requests which arerequests for system adjustments arising from new functionalor non functional requirements.
the reasons are mainly newcustomer requests and changes in terms of on board equip ment.
the new system requirements are allocated to softwarerequirements triggering development and maintenance activi ties for the corresponding components.in addition to these general situations we were interestedin concrete scenarios that represent typical maintenance andevolution tasks in the context of the lstm.
the intervieweesshared a number of actual scenarios from which we presentthree selected examples for unexpected functional and non functional requirements with differing severities.
each scenariodescribes a real world problem the actual solution and thetime required to resolve it.hardware platform in a new avionics hardwareplatform was introduced for two nh90 core computers.
thenew board differed in the number of processors and switchedthe processor architecture from cisc to risc.
the compilerrequired a version upgrade of the runtime kernel and anupgrade of the programming language from ada83 to ada95.the change in the architecture led to additional platform specific customization options in the lstm further increasingthe variability of the code significantly.
there were some minor complications but they wererelatively easy to fix.
it worked on the host but it didn t work on the target because the host compiler didn t change.
the fix was donewithin a day but if you start adding the initial analysis tolocate the error and the tests on the target you can figure weeks.
i would say that is very fair.
the implementation was limited to the generic package forlists which avoided further variant specific modifications.memory optimization over time more developers ofop erating processing functionsused the lstm as central data management component.
the source code was constantlyextended to support further entity types i.e.
new lists whichraised a problem related to resource consumption.
memory was an issue on the first computers.
they have8mb and you have to get data and executable code in there.actually the lists didn t take up that much code but it wasan issue with all the communication lists and all thecommunication related operational processing functions.
this issue has been addressed with a clone and own approach.some of the lists belong to operational processing functionsthat realize internal control applications which handle onlyprivate data.
these data are never printed on graphical displaysor transferred to other devices.
however due to the implemen tation as generic package each list allocates data structuresfor data transfer functionality regardless of whether used ornot.
ultimately a lesser memory footprint could be achievedby creating a slimmed down copy of the original lstmscode in which data structures and functionality related todata transfer have been removed.
the implementation requiredapproximately person months.navigation list in the replacement of the data management component was initiated.
the most importantargument emerged from one engineering change request there was one big effort when the navigation list came because there we had to program all the links which arenot in the list generic.
the mapping of the navigation data to the lstm was difficult.it requires multiple entity types that relate to each other.
forexample routes are basically sets of route points which arein turn defined by different types of guidance points such asairports or hospitals.
the architectural design of the lstm wasnever intended to support such complex data dictionaries.
thiscaused considerable complications regarding data storage andaccess since there is no mechanism for maintaining referentialintegrity.
to solve this problem a separate wrapper was addedto the lstm.
it enriches the navigation lists by a proper development toolverification validation assetsqualified variantgenerationqualificationsource code notenotefig.
asset based development of qualified avionics softwareaccess interface which controls data manipulation in termsof consistency and integrity constraints.
and this is where an effort came with another yearto implement.
it is maybe the set of requirements that isdifficult.
you have to re think your logic and you have tore implement this relationship.
due to the rigorous programming constraints for mission critical avionics software the code of the solution is strictlytailored to the specific use case.
it cannot be re used in differentscenarios i.e.
for varying entity types .g.
key insights the development of qualification assets for the lstm wasexpensive adding about .
person months to the totalimplementation time of person months increase .
a major maintenance effort arises from the realization ofnew functional and non functional requirements.
long term stability of system requirements is unlikely.customer requests and new equipment hardware demandconstant modifications.
the severity of new system requirements varies consid erably.
the technical realization of severe requirementsdemands up to person months of additional develop ment time which is an increase of compared to theinitial effort for implementation and qualification of .5person months.based on these findings we started working on an appropriatesolution for data management in the nh90 avionics software.iv.
designdecisions andintegrationrigorous non functional requirements in combination withstrict coding constraints impose a challenge for a single qualifi able implementation of the edb the new data managementsolution.
these requirements state that the source code of avariant must be tailored to correspond exactly to the specificequipment configuration and the accessory hardware softwareco design of the target system.
avariation pointis a locationin the software that differs in individual variants of the system.in the case of nh90 s data management variation points arisefrom various low level functional requirements such as thepresence of a table or column with a specific size or datatype.
accordingly there are many possibilities to derive edbvariants.
as a consequence an appropriate technical realizationrequires a sophisticated re use strategy.next we compare the two development approaches es tablished in the avionics domain regarding their applicabilityto multi variant software systems.
in addition as a corecontribution we introduceasset baseddevelopment as a novelapproach.a.
assessment of established development approachesthe practicability of a development approach depends onthe combination of implementation qualification and main tenance effort.
to decide whether to use code based or tool based development see section ii we compare their trade offs regarding initial effort and effort per variant regardingthese three development activities.
we define the initial effortas the effort required for setup and development of the initialvariant.incode baseddevelopment the initial effort boils downto the manual implementation and qualification of the firstvariant.
the approach demands substantial additional budgetand schedule to develop and maintain subsequent variantsby individually adapting or re implementing source code andqualification assets.
although the number of software vari ants is relatively small currently multi variant softwaresystems based on code based development are hard to grow since each individual variant must be qualified and maintained.there is no automatic process to obtain certification creditfor unchanged parts of the another software variant.
however some qualification assets can be re produced e.g.
the resultsof the unit tests of unmodified code .tool baseddevelopment relies on tool support.
the under lying generative approach increases quality of the software andfacilitates implementation by generating variants.
as no furtherassets are required the costs for deriving additional variants arereduced to the specification as input for the generator tool.
thedisadvantages are huge initial expenses for either purchasinga pre qualified commercial tool or developing and qualifyingan appropriate tool in house.from an economic point of view it turned out in ourinterview that both code based and tool based developmentare impractical for the technical realization of the edb atairbus helicopters.
regarding project parameters such as thenumber of variants degree of variability and potential artifactsize the cost benefit ratio is unsatisfactory.
to overcome theseproblems we propose asset based development.b.
asset based developmentthe key idea of asset based development is to combinecode based and tool based development such that we keep theinitial effort feasible while reducing the effort of maintainingand qualifying a growing number of variants figure .
to thisend we use model based and product line techniques to gener ate implementation and qualification assets that are used for thecode based qualification process.
that is instead of qualifyingthe code generator as in the tool based approach we generateassets that substantially reduce the effort for qualifying thegenerated source code.
following a model based approach we create a declarative system specification which is thenautomatically transformed by a non qualified generator toolto software artifacts and supplementary qualification assets such that they are amenable to requirement based testing interms of do .
this includes the automatic generation offunctional tests unit tests at statement coverage andtraceability evidence to low level system requirements.
thesequalification assets are intended to significantly facilitate qual ification for each variant.
this way we obtain benefits fromthe generative approach such as a reduced time to market andsoftware quality while avoiding the high initial costs for eitherpurchasing or developing a fully qualified tool in house.
the edb metamodel model transformation rules edb data model edb variant model code generatordomainengineering edb source coderequirementsspecification application engineering functional testsunit teststraceability evidencedata generatorfig.
overview of the edb development processasset based approach does not violate aerospace standards andis fully compliant with do civilian aviation and dod std military aviation .c.
implementationas illustrated in figure our approach follows the classicproduct line process dividing the development into do main and application engineering.
since data management isused by developers from various backgrounds and divisions we decided to use a specification and configuration mechanismthat is expressive and easy to learn.
to this end we createda domain specific language in the form of a set of sysmlmetamodels domain engineering .
it is used to define adescriptive system specification of a family of edb variants consisting of a data model to determine the storage structureand a variability model to define equipment specific varia tions.
during application engineering the stakeholder createsappropriate sysml models according to her requirements i.e.
equipment and hardware specifications .
thereupon acorresponding model transformation is invoked and a codegenerator instantiates the model transformation rules based onsource code templates with information extracted from thegiven sysml models.
to compose the source code of thetarget edb variant the code generator supplements prefab ricated database parts with glue code and the resulting codecomponents of the model transformation.to facilitate qualification unit tests functional tests andtraceability evidence are derived from the declarative systemspecification on the basis of generic test cases also imple mented as source code templates.
the tests require a consistentand integral database instance of the target edb variant tooperate on.
therefore the code generator is connected to adata generator which receives a normalized relational databaseschema from the data model as input.
then the data generatorinstantiates the schema with randomly generated values ac cording to a predefined distribution with respect to foreign keyintegrity and type specific value ranges e.g.
.
to .0for the typelatitude .
the resulting tuples are passed tothe code generator which is now aware of a consistent andintegral database instance.
finally the source code to fill atest instance as well as associated functional tests unit tests and traceability evidence are generated.in terms of tooling we decided to use open source softwareonly.
it is required by law that the manufacturer of an aircraftis capable to maintain the software across the entire life cycle.mainly due to its very long term support we used polarsys an open source tool suite for embedded model based mission and safety critical systems.
we applied polarsys tocover all tasks of domain engineering and application engi neering.
with the modeling component papyrus we specifiedthe domain specific language as well as an initial instanceof a data model and a variability model.
we implementedthe model transformation rules using the component acceleo which requires ocl as meta language for the source codetemplates.
ultimately we created templates for logicalcomponents of the edb templates for test cases and 2templates to generate test instances.
this way we generatedfully qualifiable edb variants in the programming languagesada83 and ada95.
overall our approach relies on standardtechniques but combined in a novel way to face the data management challenges in the avionics domain.a generated variant of the edb is already integrated asthe new data management component in the software of themission tactical computerof the nh90.
mainly it handlescomplex data related to area navigation and radio communi cation.v.
discussion andperspectivesin this section we compare code based and asset baseddevelopment by means of the example of the lstm old data management component and the edb new data managementcomponent .
to this end we systematically review the evo lution using the real world scenarios reported in the devel oper interview see section iii .
we categorize the scenariosaccording to their severities.
for each of the categories wedescribe the proceedings for the technical realization of thesubject once in context of the lstm and once in contextof the edb.
this way we discuss weaknesses and strengthsof code based and asset based development.
since there is nocomparable data management component implemented withtool based development an analysis of the tool based approachremains subject to further work.a.
nh90 maintenance datato learn about the frequency of maintenance and evolutiontasks regarding data management we collected maintenancedata of the nh90 avionics software from two sources.
first we accessed the software repository of two core avionicscomputers of the nh90.
second we analyzed the source code files of the data management component of the same twoavionics computers.
the software repository contains entriesof over years from until .
for each entry thereis a short description of the issue the current status the dateof creation and the date of the last modification.
the data setis divided into three subsets problem report pr describes a situation in which asoftware component is not working as intended.
prs areinitiated by engineers managers or software developersto inform project members including customers aboutproblems in the source code.
typically prs are raised ifa problem is of inter divisional interest for example if itoccurs on the software test bench or at test flights.
engineering change request ecr describes a requestto adjust the software.
ecrs arise from new systemrequirements feature requests from customers or devel opers and changes in the aerospace standards.
software change note scn documents a softwaremodification at a technical level.
scns are linked to thecausing prs or ecrs in a many to many relationship.as a second source we examined procedure headers of thesource code files of the same two avionics core computers.the headers are auto generated by the version control systemand include a full revision history of the target procedure.we parsed source code files containing 289procedure headers with revisions in total.
in .
of the annotations we were able to extract a ref erence to an scn which relates these revisions to maintenanceand evolution.
the remaining revisions are related to progressin the development process.
we transformed the data in bothrepositories into a unified format stored them in a database and joined them on the scn identifier.
this way we enrichedthe data in the software repository with file level information.by means of the folder structure of the source code files wewere able to assign entries in the software repository to logicalsoftware components.
ultimately we identified prs ecrs and scns related to data management.
we start our discussionwith a comparison of initial effort of lstm and edb.b.
comparison of initial effortfrom the developer interview we learned that the initialeffort of implementing and qualifying the lstm amounts to26 person months which is about person hours.
forthe edb we estimate person hours in total 736person hours development time and person hours foradaptation deployment and integration at airbus helicopters.the majority of effort required to develop the edb wasspend by the first author on the implementation of model transformation rules i.e.
source code templates .
at first weexperienced a significant overhead in programming in ocl.this overhead decreased rapidly with growing experience such that we could implement templates in ocl as fast assource code in ada.
in this context asset based developmentinvolved a higher initial effort due to the integration andfamiliarization of development tools.in the next four subsections we describe exemplary eventsand examine their effects on the evolution of the data management component of the nh90 from the perspective ofboth systems.
the discussion aims at establishing a descrip tive and explorable model to assess and identify factors thatinfluence maintenance and evolution in the avionics domain.all figures are meant as an illustration of the events and theircorresponding effects not for quantitative prediction.c.
deriving software system variantsto derive a new variant of the lstm the set of supportedentity types has to be tailored manually by removing changing or adding lists in the source code.
as reported in the developerinterview one extension demands about person hours ofdevelopment time.
by contrast the edb does not demand anymodifications in source code.
each extension is performed inthe declarative system specification i.e.
in the sysml mod els .
to remove change or add an entity type correspondingmodel elements have to be added to the data model and appliedwith stereotypes configuring variant specific properties.
aswe first created a new data model similar to the entities ofthe lstm it required person hours of development time.naturally this value depends on the size and complexity of thedata schema and may vary in different scenarios.
the modeltransformation to obtain the source code of the target variantis performed within seconds.figure shows the extrapolation of development time generic inst data model 45005000050100150number of extensionstotal development time h implementationembedded databaselist managementfig.
effort to modify the set of entity typesto derive a new variant of the lstm and of the edb.
they axis depicts the total time for providing source code andqualification assets in person hours.
the x axis covers thenumber of extensions in the set of entity types.
the valuesof both systems start with an offset for the initial effort andgrow in relation to the required development time.
the ratiois illustrated as genericinst in the case of the lstm and datamodel in the case of the edb.
in this scenario code based development outperforms asset based developmentfor a long time.
we assume that the break even point will notbe reached until the end of the life cycle of the nh90.
up tonow the lstm was extended to support additional entitytypes.d.
code re use with clone and ownthe developers at airbus resolved two issues in the lifecycle of the lstm by applyingclone and ownas a re use strategy.
the scenariomemory optimizationfrom thedeveloper interview see section iii falls into this category.the approach was used to deploy a solution to a subset of theinstantiated lists.
for this purpose the generic package of thelstm was copied and adapted to satisfy the requirement.the clone and own approach has two major drawbacks which we illustrate in figure .
the y axis depicts the totaldevelopment time for implementation and qualification withan offset for initial effort.
the x axis represents progress inevolution.
the grey areas illustrate the two phases where anew requirement was realized using clone and own.as a first drawback in addition to the effort required to per form a code change copied source code must also be qualified which involved about person hours for each case in thelstm.
these efforts are illustrated with cloneandown assharp increase in development time.
for the edb the effort isreduced to perform the actual code changes.
contrary to code based development asset based development transforms modelelements to source code.
this way we exploit the generativeapproach to add or remove functionality by integrating con ditional units directly into the generic application logic i.e.
introducing new variation points instead of adapting a codeclone manually.regardingmemory optimizationas a what if scenario in thecontext of the edb unnecessary data structures or procedureswould be encapsulated as conditional units which would bepresent in the target source code only if the functionality is in cluded in the declarative system specification of a desired vari ant.
due to the automatic generation of unit tests and functionaltests adjustments in terms of qualification assets are reduced tonew requirement clone and own evolutiontotal development time h implementationembedded databaselist managementfig.
effort required to realize evolution tasks by clone and ownthe specification of generic test cases.
whenever functionalityis removed as inmemory optimization no additional effortfor qualification is required.
overall we approximate the totaldevelopment time for the technical realization of this scenariofor the edb at about person hours.as a second negative effect of using a clone and ownapproach we identified increased costs related to maintenanceand evolution after cloning.
this situation occurs if a pr orecr concerns code clones.
let us assume we found changesthat were performed in original source code files as well asin two clones a and b. analyzing the software repository ofthe nh90 in this hindsight we found intersecting scnsin the original system and clone a intersecting scns inthe original system and clone b and no intersecting scnsin clones a and b. we identified such additional effort in 19cases.
we added up the time intervals of these intersectingscns and determined the ratio to the sum of the time intervalof all scns in the original system found .
this way we estimate the overhead in development time for the 19intersecting scns related to the clone and own approach inthe lstm at .
we illustrate this effect as an increasedslope after cloning in figure .in summary asset based development improves mainte nance and evolution in terms of code re use regarding twoaspects it reduces the effort required to realize changes withconditional units and code generation and it entirely eliminatesthe drawbacks arising from using a clone and own approach.e.
software changes in generic parts vs. specific partsso far we have considered only non severe requirementchanges which were realized in the lstm by means of a mod ification of the generic package as in the scenariohardwareplatform see section iii .
severe requirement changes as inthe scenarionavigation list see section iii however requirea specific solution.
to explore the factors of maintenanceand evolution effort related to changing generic and specificparts of the source code we analyzed the implementationof the lstm in this regard.
as generic part we consideredeach line of source code that is re used either by parametricpolymorphism in a generic package or by clone and own.
weassume that the remaining lines of code constitute specificfunctionality which consider the specific part.overall we parsed revisions in the generic partof the lstm.
.
of the revisions contain anscn and thus are considered as relevant for maintenance andevolution.
in total we identified scns which are related to94 prs and ecrs.
the effort for these tasks is basically thenew requirement navigation list evolutiontotal development time h implementationembedded databaselist managementfig.
effort required to realize a severe evolution tasksame for code based and asset based development since thetechnical realization affects the generic part of the software andthe qualification assets to equal shares i.e.
generic packagesof the lstm and source code templates of the edb .analogously we analyzed the specific part of the lstm.it contains revisions in total where .
are relevant for maintenance and evolution.
in total we iden tified scns related to prs and ecrs.
with 6times more scns targeting specific parts our data indicatea considerable increase in occurrences of software changesrelated to maintenance and evolution than in the genericpart.
regarding the number of revisions which has increasedby a factor of the frequency of software changes in thespecific part of the lstm is doubled compared to the genericpart.
in particular there is an exceptionally higher numberof ecrs almost factor .
this shift shows the increasedsignificance of realizing new requirements in specific variantsof the considered software.
next we discuss the scenarionavigation listfrom the developer interview as representativeexample for the severity of changes of this kind.the interviewees explained that the navigation list require ment was realized in the lstm by implementing a wrapperaround the instantiation of navigation lists with an additionalinterface for data access to maintain referential integrity andconsistency.
for the edb this scenario required the adaptionof the domain specific language to specify a model elementthat relates entity types in the declarative system specification.to this end we used instances ofsysml associationto linksysml blocks the model elements that represent entitytypes in the data model.
we realized this complex requirementby implementing conditional units that were integrated in thesource code template for query processing.regarding qualification we defined a generic test set thatcovers the additional functionality.
we integrated it into thesame template to automatically generate suitable test cases amenable for requirement based testing.
finally these testcases have been automatically instantiated with valid data fromthe data generator to create actual unit tests and functionaltests compliant to do .figure compare the development time required to realizethe scenarionavigation listin the context of the lstm and theedb.
the axes are as in figure .
the grey area illustratesthe phase in which a new requirement arose.
the effort forrealizing this severe requirement in the lstm is illustratedwith navigationlist as a stark increase in developmenttime.
the developers of the lstm estimated the effort atabout person months in total that is person hours.the ratio of required effort associated to qualification is thesame as for new developments which was estimated in theinterview at about .
in the case of the edb we estimatethe development time to person hours where personhours are spent on extending the domain specific language person hours to develop model transformation rules and80 person hours to define and implement the set of test cases.in summary asset based development can reduce the effortand cost for implementation and qualification compared tocode based in a severe scenario such asnavigation list byalmost two third which may compensate the higher initialeffort that is required by asset based development.f .
lessons learnedanswering the question of whether code based tool based or asset based development is the most suitable approachfor a specific subject matter depends on an estimation ofthe initial effort and a detailed assessment of potential tasksrelated to maintenance and evolution.
in safety critical appli cation domains where the software has to pass a qualificationprocess strict coding constraints often demand a tailoredsolution for a specific problem.
our analysis demonstrates thepotentially high severity of maintenance and evolution tasksin these domains.
real world scenarios considering severe newrequirements have shown that the technical realization requiresup to one third of the initial development cost.
however the efficiency of a development approach depends on theparameters of the target system.
if the system requirements arestable or changes are very unlikely code based developmentmay still outperform asset based development.
in cases wheremaintenance and evolution is likely such as in the data management of the nh90 asset based development appears tobe an efficient and practical development approach.
regardingtool based development further studies are required to exploreits application in software systems in which maintenance andevolution contribute to a majority of the effort.vi.
threatstovalidityour approach to assign source code files to logical softwarecomponents based on the folder structure might unintentionallyexclude files which threatens internal validity.
it is possiblethat semantically related source code files are located in differ ent folders.
the prs ecrs and scns of these files might havebeen mismatched.
however through personal communicationwith a senior developer who is familiar with the system asa whole we have been informed that the source files of thelstm as subject matter of our study are well encapsulatedand not scattered over multiple folders or packages.a second threat to internal validity arises from our assump tion that our data basis is free of defective entries.
after man ually reviewing the textual description of all affected entries prs ecrs and scns we could not find any duplicates but we cannot guarantee that the repository does not includeinvalid items e.g.
prs that could not be replicated .regarding external validity one could argue that insightsgained from an interview of two developers cannot be used tojustify general statements.
nonetheless one of the intervieweesis the head developer of the data management component andhas much like the second interviewee decades of experiencein the field of avionics software engineering.
furthermore theirapproximation of the ratio of effort for implementation andqualification of the lstm as case example of a complexavionics software agrees with the results of previous work coding makes up where unit tests functional tests and design reviews sum up to of the total developmentcosts of military avionics software .vii.
relatedworkas a first systematic report on achieving benefits fromadopting product line technology in complex avionics soft ware sharp suggested a logical pattern driven design to facil itate the integration of predefined components in the avionicssoftware in the context of the bold stroke initiative at theboeing company .
a similar approach was proposed byganesan et al.
at the nasa goddard space flight center.the authors use a layered architecture to re use modules configurable for mission specific needs in the core flightsoftware software platform for nasa missions .
bothapproaches rely on product line engineering to build hardware and mission specific variants of the avionics software.
theauthors focus on exploring domain and application designrather than facilitating the development process by addressingthe challenges of qualification that prevail in the avionicsdomain.regarding the application of model based methods in theaerospace industry batory et al.
suggest genvoca a domain independent model for hierarchical systems as compositionsof reusable components to create a reference architecture foravionics software synthesis .
similar to the work of sharpand ganesan et al.
the authors present lessons learned inapplying model based techniques to improve the applicationdesign but do not target qualification.
hovsepyan et al.
reporton an enhancement of the development life cycle at spaceapplications services by means of a model based developmentprocess to establish traceability of system requirements acrossthe phases of the v model .
in the work of dubois et al.
atthe thales group model based methods have been applied inthe form of a domain specific language in sysml to supportdomain engineering in context of product line engineering inthe ceasar project .
analogous to hovsepyans work dubois et al.
used models for maintaining traceability ofsystem requirements to application components but they donot target code generation or qualification.
delange et al.
propose model based engineering to capture architecturerequirements using the aadl modeling language.
their ap proach exploits aadl models to validate non functional re quirements such as resource dimensioning through simulation but they did not consider qualification obligations.there are model based and generative approaches to de velop software systems based on the arinc 6536specification .
horvth et al.
discuss model driven engineering asan approach to systematically develop configuration data.
asimilar strategy is described by choi et al.
.
they presenta tool to generate xml configuration files for an arinc 653compliant operating system.
in contrast to our approach theauthors apply code generation to derive configuration assets not qualification assets.with matlab simulink7and esterel scade8 there are two6a standard for space and time partitioning in avionics operating systems7 products that can be considered as the de factostandard tool set for tool based development.
both providemodel based design and code generation capabilities.
esterelscade was successfully applied at airbus to develop thesoftware for the flight control computers of multiple aircrafts such as the eurocopter ec and the airbus a340 .
the share of automatically generated code was which reduced the change cycle time by a factor of to 4compared to manual coding.
both projects showed complianceto design assurance level a. however these tools aim atgenerating source code for the most critical components of asystem and require a model based specification at a very lowlevel of abstraction which is inappropriate to handle complexdata management functionality.bridges et al.
and dorodwsky et al.
describe the successfulapplication of a generative approach at airbus helicopterswithout applying commercial tools .
they use tool based development based on an in house tool chain based ona fully qualified code generator.
it produces software artifactsfor low level components of the nh90 system software suchas the real time tasking model processor allocation and rawdata i o. the authors identified qualification as key factor butdid not provide any details on the process.viii.
conclusionin our experience report we described the enhancementof the data management component of the nh90 helicopterat airbus helicopters.
in a semi structured interview with twoprofessional developers we gained deep insights into the in dustrial practice of developing qualified avionics software.
wefound that established development approaches are not feasibleto cope with the challenges of realizing data management insuch an highly sensitive environment.to address problems regarding implementation and qual ification effort especially in the face of software evolution we propose asset based development as a novel generativeapproach to develop avionics software.
using model basedand product line technology we successfully implemented theembedded database a software product line and a generatorinfrastructure to generate fully qualifiable variants of real timeembedded database management systems which is alreadyintegrated in the nh90 development environment to replacethe former system.by a systematic comparison of the former data manage ment component and our solution we identified significantimprovements when using asset based development in termsof flexibility and efficiency of realizing tasks related to main tenance and evolution.
discussing a number of real world evo lution scenarios with data collected from the nh90 softwarerepository and the developer interview we demonstrated thelikelihood and the potential severity of these tasks and weidentified the main cost drivers of evolution.
finally our resultsare not restricted to data management in the avionics domainand may help developers to choose a suitable developmentstrategy in domains where qualification plays a key role.ix.
acknowledgmentthis work has been supported by the german researchfoundation ap ap ap .